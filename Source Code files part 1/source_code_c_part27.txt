fication(remoteResultPath, FALSE, FILE_NOTIFY_CHANGE_LAST_WRITE);
            }

            //
            // let's check result files if we have not gotten results yet
            //
            if (bResultReady == FALSE)
            {
                // check whether the .result and .secrefs files are ready
                if (IsFileReady(remoteResultFilename)
                    && (!bAccntRefExpected || IsFileReady(remoteSecrefsFilename)))
                    bResultReady = TRUE;
            }

            // now query the agent status
            if (bResultReady)
            {
                rc = TryConnectAgent(pNode, FALSE, dwAgentQueryTimeout + dwNotificationTimeout);
                if (!pNode->IsRunning() || pNode->QueryFailed())
                {
                    // if something is wrong or the agent is not running anymore
                    // let's get out of the loop
                    break;
                }
                dwNumOfQueryRetries = 0;  // reset the number of retries so far to zero
            }
            else if (bJoinDomainWithRename)
            {
                // if it is the "join domain with rename" case, we want to take a look
                // at status file as well
                if (IsFileReady(statusFilename))
                {
                    pNode->QueryStatusFromFile(statusFilename);
                    // just in case, we check result files again
                    if (IsFileReady(remoteResultFilename)
                        && (!bAccntRefExpected || IsFileReady(remoteSecrefsFilename)))
                        bResultReady = TRUE;
                    break;
                }
            }

            // figure out the elapsed time to see whether you should query the agent
            GetSystemTimeAsFileTime((FILETIME*)&uliCurrentTime);
            BOOL bNeedToQueryAgent = FALSE;
            // if somehow the time has been set back significantly or 
            // the timeout period has elapsed
            // we should query the agent
            // note: in the retry case, we use dwRetryTimeout instead of uliAgentQueryTimeout
            //       since if we do not want to wait too long before a retry
            if (uliCurrentTime.QuadPart <= uliPreviousTime.QuadPart
                || (dwNumOfQueryRetries > 0
                    && uliPreviousTime.QuadPart + dwRetryTimeout <= uliCurrentTime.QuadPart)
                || uliPreviousTime.QuadPart + uliAgentQueryTimeout.QuadPart <= uliCurrentTime.QuadPart)
            {
                bNeedToQueryAgent = TRUE;
            }
            
            if (bNeedToQueryAgent)
            {
                // reset the timeout for querying agent

                // if not in the retry case, we double the timeout
                // otherwise, we use the same timeout value
                if (dwNumOfQueryRetries == 0)
                {
                    dwAgentQueryTimeout += dwAgentQueryTimeout;
                    // if it hits the maximum timeout, it is set to the maximum value
                    if (dwAgentQueryTimeout > dwMaxTimeout)
                        dwAgentQueryTimeout = dwMaxTimeout;
                    uliAgentQueryTimeout.QuadPart = (ULONGLONG) dwAgentQueryTimeout * dwConversionFactor;
                }
                uliPreviousTime = uliCurrentTime;
                
                rc = TryConnectAgent(pNode, FALSE, dwAgentQueryTimeout + dwNotificationTimeout);

                // if it is the "join domain with rename" case and we are getting ERROR_ACCESS_DENIED
                // or RPC_S_SERVER_UNAVAILABLE, we should check the status file
                if (bJoinDomainWithRename
                    && (rc == ERROR_ACCESS_DENIED || rc == RPC_S_SERVER_UNAVAILABLE))
                {
                    pNode->QueryStatusFromFile(statusFilename);
                }
                    
                if (pNode->QueryFailed())
                {
                    if (dwNumOfQueryRetries < dwMaxNumOfQueryRetries)
                    {
                        // in retry mode, we need to use the original timeout value
                        dwNumOfQueryRetries++;
                        pNode->SetQueryFailed(FALSE);
                    }
                    else
                    {
                        // we have retried enough times, let's break out of the loop
                        break;
                    }
                }
                else if (!pNode->IsRunning())
                {
                    // if something is wrong or the agent is not running anymore
                    // let's get out of the loop
                    // but first check the result files again if they are not ready yet
                    if (!bResultReady && IsFileReady(remoteResultFilename)
                        && (!bAccntRefExpected || IsFileReady(remoteSecrefsFilename)))
                        bResultReady = TRUE;
                    break;
                }
                else
                {
                    // reset the number of query of retries to zero
                    dwNumOfQueryRetries = 0;
                }
            }

            // wait for the notification or sleep for one minute
            // this is to make agent monitoring thread as robust as possible
            if (hFindChange != INVALID_HANDLE_VALUE)
            {
                // if the notification is set up, let's wait on it
                WaitForSingleObject(hFindChange, dwNotificationTimeout);
            }
            else
            {
                // if the notification is not set up, let's sleep for one minute
                Sleep(dwNotificationTimeout);
            }

            // find the next notification
            if (hFindChange != INVALID_HANDLE_VALUE)
            {
                // this part is to make sure the code is robust
                if (!FindNextChangeNotification(hFindChange))
                {
                    FindCloseChangeNotification(hFindChange);
                    hFindChange = INVALID_HANDLE_VALUE;
                }
            }
        } while (!bDone);

        //
        // pull the result
        //
        pNode->SetHasResult(FALSE);

        if (bResultReady)
        {
            // make sure we copy all needed files over
            if (CopyFile(remoteResultFilename,resultFilename,FALSE)
                && (!pNode->IsAccountReferenceResultExpected()
                       || (pNode->IsAccountReferenceResultExpected()
                            && CopyFile(remoteSecrefsFilename,secrefsFilename,FALSE))))
            {
                // mark that we have the result
                pNode->SetHasResult(TRUE);
            }
        }

        // we should always mark that we have tried to pull the result
        // we do this after we tried to pull results so that the result monitoring thread
        // can handle it correctly
        pNode->SetResultPullingTried(TRUE);

        // finally, we signal the agent to shut down
        // however in the "join domain with rename" case, since we already lost contact
        // with the agent, we should not attempt to call TryConnectAgent
        if (!pNode->QueryFailed() && !bJoinDomainWithRename)
        {
            // tell the agent to shut down in 1 minute just in case
            // note: by using TRUE here, the status will not be updated
            TryConnectAgent(pNode, TRUE, 60000);
        }

        // if we cannot query the agent, we assume it has finished
        if (pNode->QueryFailed())
        {
            if (bResultReady)
            {
                // if bResultReady is TRUE, we will clean the Agent_Status_QueryFailed bit
                pNode->SetQueryFailed(FALSE);
            }
            pNode->SetFinished();
        }

        // one more update
        HWND                   listWnd;
        WCHAR                 sTime[32];
        gData.GetListWindow(&listWnd);
        pNode->SetTimeStamp(gTTime.FormatIsoLcl( gTTime.Now( NULL ), sTime ));
        SendMessage(listWnd,DCT_UPDATE_ENTRY,NULL,(LPARAM)pNode);
    }
    catch (_com_error& e)
    {
        pNode->SetFailed();
        pNode->SetOutOfResourceToMonitor(TRUE);
    }
    
    // clean up
    if (hFindChange != INVALID_HANDLE_VALUE)
        FindCloseChangeNotification(hFindChange);

    pNode->SetDoneMonitoring(TRUE);
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\scanlog.cpp ===
/*---------------------------------------------------------------------------
  File:  ScanLog.cpp

  Comments: Routines to scan the dispatch log for the DCT agents

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/15/99 13:29:18

 ---------------------------------------------------------------------------
*/


#include "StdAfx.h"
#include "Common.hpp"
#include "UString.hpp"
#include "TNode.hpp"
#include "ServList.hpp"
#include "Globals.h"
#include "Monitor.h"
#include "FParse.hpp"   
#include "afxdao.h"
#include "errDct.hpp"
#include "scanlog.h"
#include <Winnls.h>


#define AR_Status_Created           (0x00000001)
#define AR_Status_Replaced          (0x00000002)
#define AR_Status_AlreadyExisted    (0x00000004)
#define AR_Status_RightsUpdated     (0x00000008)
#define AR_Status_DomainChanged     (0x00000010)
#define AR_Status_Rebooted          (0x00000020)
#define AR_Status_Warning           (0x40000000)
#define AR_Status_Error             (0x80000000)


#define  BYTE_ORDER_MARK   (0xFEFF)

extern DWORD __stdcall MonitorRunningAgent(void *);

void ParseInputFile(const WCHAR * filename);

DWORD __stdcall LogReaderFn(void * arg)
{
    WCHAR             logfile[MAX_PATH];
    BOOL              bDone;
    long              nSeconds;

    CoInitialize(NULL);

    gData.GetLogPath(logfile);
    gData.GetDone(&bDone);
    gData.GetWaitInterval(&nSeconds);

    while ( ! bDone )
    {
        ParseInputFile(logfile);
        Sleep(nSeconds * 1000);
        gData.GetDone(&bDone);
        if (bDone)
        {
            // before we finish up this thread, set the LogDone to TRUE
            gData.SetLogDone(TRUE);
            break;
        }

        // if the dispatcher.csv has been processed, we should terminate this thread
        gData.GetLogDone(&bDone);
        gData.GetWaitInterval(&nSeconds);
    }

    CoUninitialize();

    return 0;
}

bool ConvertToLocalUserDefault(WCHAR* originalTimestamp, WCHAR* convertedTimestamp, size_t size)
{
    SYSTEMTIME st;
    bool bConverted = false;
    
    int cFields = _stscanf(
        originalTimestamp,
        _T("%hu-%hu-%hu %hu:%hu:%hu"),
        &st.wYear,
        &st.wMonth,
        &st.wDay,
        &st.wHour,
        &st.wMinute,
        &st.wSecond
    );

    if (cFields == 6)
    {
        // format date and time using LOCALE_USER_DEFAULT
        WCHAR formatedDate[100];
        WCHAR formatedTime[100];
        st.wMilliseconds = 0;
        int formatedDateLen = 
            GetDateFormatW(LOCALE_USER_DEFAULT, NULL, &st, NULL, formatedDate, sizeof(formatedDate)/sizeof(formatedDate[0]));
        int formatedTimeLen =
            GetTimeFormatW(LOCALE_USER_DEFAULT, NULL, &st, NULL, formatedTime, sizeof(formatedTime)/sizeof(formatedTime[0]));
        if (formatedDateLen != 0 && formatedTimeLen != 0 && formatedDateLen + formatedTimeLen + 1 < (int) size)
        {
            swprintf(convertedTimestamp, L"%s %s", formatedDate, formatedTime);
            bConverted = true;
        }
    }

    return bConverted;
}
    
BOOL TErrorLogParser::ScanFileEntry(
      WCHAR                * string,      // in - line from TError log file
      WCHAR                * timestamp,   // out- timestamp from this line
      int                  * pSeverity,   // out- severity level of this message
      int                  * pSourceLine, // out- the source line for this message
      WCHAR                * msgtext      // out- the textual part of the message
   )
{
    BOOL bScan = FALSE;

    // skip byte order mark if present

    if (string[0] == BYTE_ORDER_MARK)
    {
        ++string;
    }

    // initialize return values

    *timestamp = L'\0';
    *pSeverity = 0;
    *pSourceLine = 0;
    *msgtext = L'\0';

    // scan fields

    //2001-09-11 20:27:32 ERR2:0080 Unable...

    SYSTEMTIME st;
    _TCHAR szError[4];

    int cFields = _stscanf(
        string,
        _T("%hu-%hu-%hu %hu:%hu:%hu %3[^0-9]%d:%d %[^\r\n]"),
        &st.wYear,
        &st.wMonth,
        &st.wDay,
        &st.wHour,
        &st.wMinute,
        &st.wSecond,
        szError,
        pSeverity,
        pSourceLine,
        msgtext
    );

    // if warning or error message
    // else re-scan message

    if ((cFields >= 9) && ((_tcsicmp(szError, _T("WRN")) == 0) || (_tcsicmp(szError, _T("ERR")) == 0)))
    {
        bScan = TRUE;
    }
    else
    {
        *pSeverity = 0;
        *pSourceLine = 0;

        cFields = _stscanf(
            string,
            _T("%hu-%hu-%hu %hu:%hu:%hu %[^\r\n]"),
            &st.wYear,
            &st.wMonth,
            &st.wDay,
            &st.wHour,
            &st.wMinute,
            &st.wSecond,
            msgtext
        );

        if (cFields >= 6)
        {
            bScan = TRUE;
        }
    }

    if (bScan)
    {
        _stprintf(
            timestamp,
            _T("%hu-%02hu-%02hu %02hu:%02hu:%02hu"),
            st.wYear,
            st.wMonth,
            st.wDay,
            st.wHour,
            st.wMinute,
            st.wSecond
        );
    }

    return bScan;
}

BOOL GetServerFromMessage(WCHAR const * msg,WCHAR * server)
{
   BOOL                      bSuccess = FALSE;
   int                       ndx = 0;

   for ( ndx = 0 ; msg[ndx] ; ndx++ )
   {
      if ( msg[ndx] == L'\\' && msg[ndx+1] == L'\\' )
      {
         bSuccess = TRUE;
         break;
      }
   }
   if ( bSuccess )
   {
      int                    i = 0;
      ndx+=2; // strip of the backslashes
      for ( i=0; msg[ndx] && msg[ndx] != L'\\' && msg[ndx]!= L' ' && msg[ndx] != L',' && msg[ndx] != L'\t' && msg[ndx] != L'\n'  ; i++,ndx++)
      {
         server[i] = msg[ndx];      
      }
      server[i] = 0;
   }
   else
   {
      server[0] = 0;
   }
   return bSuccess;
}
   

void ParseInputFile(WCHAR const * gLogFile)
{
   FILE                    * pFile = 0;
   WCHAR                     server[MAX_PATH];

   int                       nRead = 0;
   int                       count = 0;
   HWND                      lWnd = NULL;
   long                      totalRead;
   BOOL                      bNeedToCheckResults = FALSE;
   TErrorLogParser           parser;
   TErrorDct                 edct;
   BOOL bTotalReadGlobal;  // indicates whether we have read the total number of agents
   BOOL bTotalReadLocal = FALSE;  // indicates whether we will encounter total read in the file this time

   parser.Open(gLogFile);

   gData.GetLinesRead(&totalRead);
   gData.GetTotalRead(&bTotalReadGlobal);
   
   if ( parser.IsOpen() )
   {
      // scan the file
      while ( ! parser.IsEof() )
      {
         if ( parser.ScanEntry() )
         {
            nRead++;
            if ( nRead < totalRead )
               continue;
            // the first three lines each have their own specific format
            if ( nRead == 1 )
            {
               // first comes the name of the human-readable log file
               gData.SetReadableLogFile(parser.GetMessage());
            }
            else if ( nRead == 2 )
            {
               // next, the name result directory - this is needed to look for the result files
               WCHAR const * dirName = parser.GetMessage();
               gData.SetResultDir(dirName);
            }
            else if ( nRead == 3 )
            {
               // now the count of computers being dispatched to
               count = _wtoi(parser.GetMessage());
               ComputerStats        cStat;
               
               gData.GetComputerStats(&cStat);
               cStat.total = count;
               gData.SetComputerStats(&cStat);
               bTotalReadLocal = TRUE;
               continue;
            }
            else // all other message have the following format: COMPUTER<tab>Action<tab>RetCode
            { 
               WCHAR                   action[50];
               WCHAR           const * pAction = wcschr(parser.GetMessage(),L'\t');
               WCHAR           const * retcode = wcsrchr(parser.GetMessage(),L'\t');
               TServerNode           * pServer = NULL;

               if ( GetServerFromMessage(parser.GetMessage(),server) 
                     && pAction 
                     && retcode 
                     && pAction != retcode 
                  )
               {
                  
//                  UStrCpy(action,pAction+1,retcode - pAction);
                  UStrCpy(action,pAction+1,(int)(retcode - pAction));
                  // add the server to the list, if it isn't already there
                  gData.Lock();
                  pServer = gData.GetUnsafeServerList()->FindServer(server); 
                  if ( ! pServer )
                     pServer = gData.GetUnsafeServerList()->AddServer(server);
                  gData.Unlock();
                  
                  retcode++;

                  DWORD          rc = _wtoi(retcode);
                  
                  if ( pServer )
                  {
                     if ( UStrICmp(pServer->GetTimeStamp(),parser.GetTimestamp()) < 0 )
                     {
                        pServer->SetTimeStamp(parser.GetTimestamp());
                     }
                     if ( !UStrICmp(action,L"WillInstall") )
                     {
                        pServer->SetIncluded(TRUE);
                     }
                     else if (! UStrICmp(action,L"JobFile") )
                     {
                        // this part is in the form of "%d,%d,job path"
                        // where the number is indicative of whether account reference 
                        // result is expected
                        WCHAR acctRefResultFlag = L'0';
                        WCHAR joinRenameFlag = L'0';
                        const WCHAR* msg = retcode;
                        WCHAR* comma = wcschr(msg, L',');
                        if ( comma )
                        {
                            if ( comma != msg )
                            {
                                acctRefResultFlag = *msg;
                                WCHAR* msg1 = comma + 1;
                                comma = wcschr(msg1, L',');
                                if (comma != msg1)
                                    joinRenameFlag = *msg1;
                            }
                            pServer->SetJobPath(comma+1);
                        }
                        else
                        {
                            pServer->SetJobPath(L"");
                        }
                        
                        // set whether account reference result is expected or not
                        if (acctRefResultFlag == L'0')
                            pServer->SetAccountReferenceResultExpected(FALSE);
                        else
                            pServer->SetAccountReferenceResultExpected(TRUE);

                        // set whether join & rename is expected or not
                        if (joinRenameFlag == L'0')
                            pServer->SetJoinDomainWithRename(FALSE);
                        else
                            pServer->SetJoinDomainWithRename(TRUE);
                     }
                     else if (!UStrICmp(action,L"RemoteResultPath"))
                     {
                        pServer->SetRemoteResultPath(retcode);
                     }
                     else if (! UStrICmp(action,L"Install") )
                     {
                        if ( rc )
                        {
                           if ( ! *pServer->GetMessageText() )
                           {
                              TErrorDct         errTemp;
                              WCHAR             text[2000];
                              errTemp.ErrorCodeToText(rc,DIM(text),text);
                              
                              pServer->SetMessageText(text);
                           }
                           pServer->SetSeverity(2);
                           pServer->SetFailed();
                           pServer->SetIncluded(TRUE);
                           gData.GetListWindow(&lWnd);
                           SendMessage(lWnd,DCT_ERROR_ENTRY,NULL,(LPARAM)pServer);
                        }
                        else
                        {
                           pServer->SetInstalled();
                           pServer->SetIncluded(TRUE);
                           gData.GetListWindow(&lWnd);
                           SendMessage(lWnd,DCT_UPDATE_ENTRY,NULL,(LPARAM)pServer);
                        }
                     }
                     else if ( ! UStrICmp(action,L"Start") )
                     {
                        if ( rc )
                        {
                           if ( ! *pServer->GetMessageText() )
                           {
                              TErrorDct         errTemp;
                              WCHAR             text[2000];
                              errTemp.ErrorCodeToText(rc,DIM(text),text);
                              
                              pServer->SetMessageText(text);
                           }
                           pServer->SetSeverity(2);
                           pServer->SetFailed();
                           pServer->SetIncluded(TRUE);
                           gData.GetListWindow(&lWnd);
                           SendMessage(lWnd,DCT_ERROR_ENTRY,NULL,(LPARAM)pServer);                  
                        }
                        else
                        {
                           // extract the filename and GUID from the end of the message
                           WCHAR filename[MAX_PATH];
                           WCHAR guid[100];
                           WCHAR * comma1 = wcschr(parser.GetMessage(),L',');
                           WCHAR * comma2 = NULL;
                           if ( comma1 )
                           {
                              comma2 = wcschr(comma1 + 1,L',');

                              if ( comma2 )
                              {
                                 
//                                 UStrCpy(filename,comma1+1,(comma2-comma1));  // skip the comma & space before the filename
                                 UStrCpy(filename,comma1+1,(int)(comma2-comma1));  // skip the comma & space before the filename
                                 safecopy(guid,comma2+1);         // skip the comma & space before the guid
                                 pServer->SetJobID(guid);
                                 pServer->SetJobFile(filename);
                                 pServer->SetStarted();
                                 bNeedToCheckResults = TRUE;

                                 // launch a worker thread to monitor the agent

                                 // IsMonitoringTried is used to make sure that at most one
                                 // thread is created to monitor a particular agent.
                                 // The reason for adding this logic is that in case that lWnd
                                 // is NULL the total number of read lines will not be set in 
                                 // gData so that the same line containing "Start" could be read
                                 // more than once and thus more than one thread will be 
                                 // created to monitor an agent.  This is problematic.
                                 // lWnd will be NULL if server list dialog has not been initialized
                                 // or it is command line case where there is no UI.
                                 if (!pServer->IsMonitoringTried())
                                 {
                                    // mark that we have tried to monitor the agent
                                    pServer->SetMonitoringTried(TRUE);
                                    
                                    DWORD id;
                                    HANDLE aThread = CreateThread(NULL,0,&MonitorRunningAgent,(void*)pServer,0,&id);
                                    if (aThread == NULL)
                                    {
                                        // indicate so if we have run out of resource to monitor the agent
                                        pServer->SetFailed();
                                        pServer->SetOutOfResourceToMonitor(TRUE);
                                    }
                                    else
                                    {
                                        CloseHandle(aThread);
                                    }
                                 }
                              }
                              gData.GetListWindow(&lWnd);
                              SendMessage(lWnd,DCT_UPDATE_ENTRY,NULL,(LPARAM)pServer);
                           }
                        }
                     }
                     else if ( ! UStrICmp(action,L"Finished") )
                     {
                        SendMessage(lWnd,DCT_UPDATE_ENTRY,NULL,NULL);
                     }
                  }
               }
			   else
			   {
					// if dispatcher finished dispatching agents set log done

					LPCWSTR psz = parser.GetMessage();

					if (wcsstr(psz, L"All") && wcsstr(psz, L"Finished"))
					{
                        gData.SetLogDone(TRUE);
                        ComputerStats        cStat;
                        gData.GetComputerStats(&cStat);
						if (cStat.total == 0  && bTotalReadGlobal)
						{
						    gData.GetListWindow(&lWnd);
						    SendMessage(lWnd,DCT_UPDATE_ENTRY,NULL,NULL);
						}
					}
			   }
            }   
         }
         else
         {
            // once we hit an invalid entry, we stop scanning
            break;
         }
      }
      
      // if we don't have the handle from the list window, we couldn't really send the messages
      // in that case we must read the lines again next time, so that we can resend the messages.
      if ( lWnd )
      {
         // if we have sent the messages, we don't need to send them again   
         gData.SetLinesRead(nRead);
      }

      // we signal the first pass done only after the total number of server has been read
      // and we only need to set it once
      if (!bTotalReadGlobal && bTotalReadLocal)
      {
        gData.SetFirstPassDone(TRUE);
        gData.SetTotalRead(TRUE);
      }
      parser.Close();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\servlist.cpp ===
#include "stdafx.h"
#include "ServList.hpp"
#include "globals.h"
#include "resstr.h"
#include "resource.h"

#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")

extern GlobalData gData;

//----------------------------------------------------------------------------
// Function:   QueryStatusFromFile
//
// Synopsis:   Query the job status from the status file
//
// Arguments:
//
// statusFilename   the name of the status file
//
// Returns:
//
// Modifies:   Call SetFinished and SetSeverity functions
//
//----------------------------------------------------------------------------

void TServerNode::QueryStatusFromFile(WCHAR* statusFilename)
{
    if (bHasQueriedStatusFromFile)
        return;
    
    try
    {
        IVarSetPtr             pVarSet;
        IStoragePtr            store;
        HRESULT hr = S_OK;
        BOOL bDoneTry = FALSE;

        SetQueryFailed(FALSE);

        // attempt to open status file
        while (TRUE)
        {
            hr = StgOpenStorage(statusFilename,
                                NULL,
                                STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                                NULL,
                                0,
                                &store);

            // if sharing or lock violation then...
            if ((hr == STG_E_SHAREVIOLATION) || (hr == STG_E_LOCKVIOLATION))
            {
                // wait 30 seconds before trying again
                if (bDoneTry)
                    break;
                Sleep(30000);
                bDoneTry = TRUE;  // we only try once
            }
            else
            {
                // otherwise stop trying
                break;
            }
        }

        // load varset from file and check the status
        if (SUCCEEDED(hr))
        {
            hr = OleLoad(store, IID_IVarSet, NULL, (void**)&pVarSet);
            if (SUCCEEDED(hr))
            {
                bHasQueriedStatusFromFile = TRUE;
                _bstr_t jobStatus = pVarSet->get(GET_BSTR(DCTVS_JobStatus));
                if (!UStrICmp(jobStatus,GET_STRING(IDS_DCT_Status_Completed)))
                    SetFinished();
                else if (!UStrICmp(jobStatus,GET_STRING(IDS_DCT_Status_Completed_With_Errors)))
                {
                    SetFinished();
                    SetSeverity(2);
                }
            }
            else
                SetQueryFailed(TRUE);
        }
        else
            SetQueryFailed(TRUE);
    }
    catch (...)
    {
        SetQueryFailed(TRUE);
    }
}

void TServerNode::QueryStatusFromFile()
{
    if (bHasQueriedStatusFromFile)
        return;
    
    try 
    {
        _bstr_t remoteResultPath = GetRemoteResultPath();
        _bstr_t statusFilename = remoteResultPath + GetJobID();
        QueryStatusFromFile(statusFilename);
    }
    catch (...)
    {
        SetQueryFailed(TRUE);
    }
}
        

//----------------------------------------------------------------------------
// Function:   PrepareForLogging
//
// Synopsis:   Prepare the status and error message for logging agent
//             completion status into migration log.
//             The logic is taken from COLUMN_STATUS and COLUMN_MESSAGE parts
//             of CAgentMonitorDlg::OnGetdispinfoServerlist.
//             Due to the fact that this code is added for RTM, the minimum
//             change is preferred to prevent behavioral regression.
//             These two codes should be consolidated after ADMT v2.
//
// Arguments:
//
// Returns:
//
// Modifies:   It updates the bstrStatusForLogging, bstrErrorMessageForLogging
//             and dwStatusForLogging member variables.
//
//----------------------------------------------------------------------------
void TServerNode::PrepareForLogging()
{
    CString status;

    status.LoadString(IDS_Status_Installing);
    dwStatusForLogging = Completion_Status_Installing;
    
    if (HasFailed())
    {
        status.LoadString(IDS_Status_InstallFailed);
        dwStatusForLogging = Completion_Status_InstallFailed;
    }
    if (IsInstalled())
    {
        if (!HasFailed())
        {
            status.LoadString(IDS_Status_Installed);
            dwStatusForLogging = Completion_Status_Installed;
        }
        else
        {
            status.LoadString(IDS_Status_DidNotStart);
            dwStatusForLogging = Completion_Status_DidNotStart;
        }
    }
    if (GetStatus() & Agent_Status_Started)
    {
        if (!HasFailed())
        {
            status.LoadString(IDS_Status_Running);
            dwStatusForLogging = Completion_Status_Running;
        }
        else
        {
            status.LoadString(IDS_Status_Failed);
            dwStatusForLogging = Completion_Status_StatusUnknown;
        }
    }
    if (IsFinished())
    {
        if (QueryFailed())
        {
            // we show "Status Unknown" in the status field
            status.LoadString(IDS_Status_Unknown);
            dwStatusForLogging = Completion_Status_StatusUnknown;
        }
        else if (!IsResultPullingTried() || (HasResult() && !IsResultProcessed()))
        {
            // if still pulling results or results not yet processed
            // we want to show the status of still running
            status.LoadString(IDS_Status_Running);
            dwStatusForLogging = Completion_Status_Running;
        }
        else
        {
            if (!HasResult())
            {
                // if there is no result, we consider it an error
                status.LoadString(IDS_Status_Completed_With_Errors);
                dwStatusForLogging = Completion_Status_CompletedWithErrors;
            }
            else if (!GetSeverity())
            {
                // if we have the result and no error happened during agent operation
                // we show the status of complete
                status.LoadString(IDS_Status_Completed);
                dwStatusForLogging = Completion_Status_Completed;
            }
            else
            {
                // if we have the result, we set the status 
                // based on the error/warning level
                switch (GetSeverity())
                {
                case 1:
                    status.LoadString(IDS_Status_Completed_With_Warnings);
                    dwStatusForLogging = Completion_Status_CompletedWithWarnings;
                    break;
                case 2:
                case 3:
                default:
                    status.LoadString(IDS_Status_Completed_With_Errors);
                    dwStatusForLogging = Completion_Status_CompletedWithErrors;
                    break;
                }
            }
        }
    }

    bstrStatusForLogging = (LPCWSTR)status;

    // this part deals with the error message
    
    status = L"";  // reset the status
    
    if (IsFinished() && QueryFailed())
    {
        // in this case, we show the error during the query
        status = GetMessageText();
    }
    else if (IsFinished()
              && (!IsResultPullingTried()
                  || (HasResult() && !IsResultProcessed())))
    {
        // if agent has finished but result not yet pulled or processed,
        // we show the status of "still processing results"
        status.LoadString(IDS_Status_Processing_Results);
    }
    else if (IsFinished() && IsResultPullingTried() && !HasResult())
    {
        // if agent finished but we cannot retrieve results
        // we show the status of "cannot retrieve results"
        status.LoadString(IDS_Status_Cannot_Retrieve_Results);
    }
    else if (HasFailed() || QueryFailed() || GetSeverity() || IsFinished())
    {
        // for these cases, we get the message stored on the node
        status = GetMessageText();
    }

    bstrErrorMessageForLogging = (LPCWSTR)status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\servlist.hpp ===
#ifndef __SERVERLIST_HPP__
#define __SERVERLIST_HPP__
/*---------------------------------------------------------------------------
  File: ...

  Comments: ...

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/04/99 17:10:38

 ---------------------------------------------------------------------------
*/
//#import "\bin\MCSEADCTAgent.tlb" no_namespace, named_guids 
#import "Engine.tlb" no_namespace, named_guids 

#include "Common.hpp"
#include "UString.hpp"
#include "TNode.hpp"


#define Agent_Status_Unknown        (0x00000000)
#define Agent_Status_Installed      (0x00000001)
#define Agent_Status_Started        (0x00000002)
#define Agent_Status_Finished       (0x00000004)
#define Agent_Status_Failed         (0x80000000)
#define Agent_Status_QueryFailed    (0x40000000)

// these completion statuses are arranged in an order by which you
// want to present them in the migration log
#define Completion_Status_Completed 0
#define Completion_Status_CompletedWithWarnings 1
#define Completion_Status_CompletedWithErrors 2
#define Completion_Status_Running 3
#define Completion_Status_StatusUnknown 4
#define Completion_Status_DidNotStart 5
#define Completion_Status_Installed 6
#define Completion_Status_InstallFailed 7
#define Completion_Status_Installing 8

class TServerNode : public TNode
{
   
   BOOL                        bInclude;
   WCHAR                     guid[100];
   WCHAR                     serverName[MAX_PATH];
   WCHAR                     remoteResultPath[MAX_PATH];
   BOOL                      bResultPullingTried;
   BOOL                      bHasResult;
   BOOL                      bResultProcessed;
   BOOL                      bAccountReferenceResultExpected;
   BOOL                      bJoinDomainWithRename;
   BOOL                      bHasQueriedStatusFromFile;
   WCHAR                     resultpath[MAX_PATH];
   WCHAR                     jobpath[MAX_PATH];
   WCHAR                     logpath[MAX_PATH];
   BOOL                      isLogPathValid;
   WCHAR                     timestamp[30];
   IDCTAgent               * pAgent;
   int                       errSeverity;
   DWORD                     status;
   WCHAR                     errMsg[500];
   int                       listNdx;
   BOOL                      bOutOfResourceToMonitor;
   BOOL                      bMonitoringTried;
   BOOL                      bDoneMonitoring;

   // several member variables related to the logging of the agent completion status
   _bstr_t                   bstrStatusForLogging;
   _bstr_t                   bstrErrorMessageForLogging;
   DWORD                     dwStatusForLogging;
   
public:

   TServerNode(WCHAR const * server) 
   {
      safecopy(serverName,server);
      guid[0] = 0;
      pAgent = NULL;
      errSeverity = 0;
      errMsg[0] = 0;
      timestamp[0] = 0;
      resultpath[0] = 0;
      remoteResultPath[0] = 0;
      bResultPullingTried = FALSE;
      bHasResult = FALSE;
      bResultProcessed = FALSE;
      bHasQueriedStatusFromFile = FALSE;
      jobpath[0] = 0;
      logpath[0] = 0;
      isLogPathValid = TRUE;
      bInclude = FALSE;
      status = 0;
      listNdx = -1;
      bOutOfResourceToMonitor = FALSE;
      bMonitoringTried = FALSE;
      bDoneMonitoring = FALSE;
      dwStatusForLogging = Completion_Status_Installing;
   }
   ~TServerNode()
   {
      if ( pAgent )
         pAgent->Release();
   }
   
   WCHAR * GetServer() { return serverName; }
   WCHAR * GetJobID() { return guid; }
   WCHAR * GetMessageText() { return errMsg; } 
   int    GetSeverity() { return errSeverity; }
   
   IDCTAgent * GetInterface() { return pAgent; }
   
   WCHAR * GetTimeStamp() { return timestamp;  }    
   WCHAR * GetJobFile() { return resultpath; }
   WCHAR * GetJobPath() { return jobpath; }
   WCHAR * GetLogPath() { return logpath; }
   BOOL    GetLogPathValid() { return isLogPathValid; }
   WCHAR * GetRemoteResultPath()  { return remoteResultPath; }
   BOOL   Include() { return bInclude; }
   DWORD  GetStatus() { return status; }
   BOOL   IsInstalled() { return status & Agent_Status_Installed; }
   BOOL   IsStarted() { return status & Agent_Status_Started; }
   BOOL   IsFinished() { return status & Agent_Status_Finished; }
   BOOL   IsRunning() { return ( (status & Agent_Status_Started) && !(status & (Agent_Status_Finished|Agent_Status_Failed))); }
   BOOL   HasFailed() { return status & Agent_Status_Failed; }
   BOOL   QueryFailed() { return status & Agent_Status_QueryFailed; }

   void SetJobID(WCHAR const * id) { safecopy(guid,id); }
   void SetSeverity(int s) { if ( s > errSeverity ) errSeverity = s; }
   void SetInterface(IDCTAgent* p) { if ( p ) p->AddRef();  pAgent = p; }
   void SetMessageText(WCHAR const * txt) { safecopy(errMsg,txt); }
   void SetTimeStamp(WCHAR const * t) { safecopy(timestamp,t); }
   void SetJobFile(WCHAR const * filename) { safecopy(resultpath,filename); }
   void SetJobPath(WCHAR const * filename) { safecopy(jobpath,filename); safecopy(resultpath,filename); }
   void SetLogPath(WCHAR const * filename) { safecopy(logpath,filename); }
   void SetLogPathValid(BOOL bValid)  { isLogPathValid = bValid; }
   void SetRemoteResultPath(WCHAR const * filename) { safecopy(remoteResultPath, filename); }
   void SetIncluded(BOOL v) { bInclude = v; }
   void SetStatus(DWORD val) { status = val; }
   
   void SetInstalled() { status |= Agent_Status_Installed; }
   void SetStarted() { status |= Agent_Status_Started; }
   void SetFinished() { status |= Agent_Status_Finished; }
   void SetFailed() { status |= Agent_Status_Failed; }
   void SetQueryFailed(BOOL bVal) { (bVal) ? status |= Agent_Status_QueryFailed : status &= ~Agent_Status_QueryFailed; }
   void SetResultPullingTried(BOOL bTried) { bResultPullingTried = bTried; }
   BOOL IsResultPullingTried() { return bResultPullingTried; }
   void SetHasResult(BOOL bResult) { bHasResult = bResult; }
   BOOL HasResult() { return bHasResult; }
   void SetResultProcessed(BOOL bIsProcessed) { bResultProcessed = bIsProcessed; }
   BOOL IsResultProcessed() { return bResultProcessed; }
   void SetAccountReferenceResultExpected(BOOL isExpected) { bAccountReferenceResultExpected = isExpected; }
   BOOL IsAccountReferenceResultExpected() { return bAccountReferenceResultExpected; }
   void SetJoinDomainWithRename(BOOL bValue) { bJoinDomainWithRename = bValue; }
   BOOL IsJoinDomainWithRename() { return bJoinDomainWithRename; }
   void SetOutOfResourceToMonitor(BOOL bOutOfResource) { bOutOfResourceToMonitor = bOutOfResource; }
   BOOL IsOutOfResourceToMonitor() { return bOutOfResourceToMonitor; }
   void SetMonitoringTried(BOOL bValue) { bMonitoringTried = bValue; }
   BOOL IsMonitoringTried() { return bMonitoringTried; }
   void SetDoneMonitoring(BOOL bValue) { bDoneMonitoring = bValue; }
   BOOL IsDoneMonitoring() { return bDoneMonitoring; }

   void QueryStatusFromFile(WCHAR* statusFilename);
   void QueryStatusFromFile();

   void PrepareForLogging();
   WCHAR* GetStatusForLogging() { return ((!bstrStatusForLogging) ? L"" : bstrStatusForLogging); }
   DWORD GetStatusNumberForLogging() { return dwStatusForLogging; }
   WCHAR* GetErrorMessageForLogging() { return ((!bstrErrorMessageForLogging) ? L"" : bstrErrorMessageForLogging); }
};

int static CompareNames(TNode const * t1, TNode const * t2)
{
   TServerNode             * server1 = (TServerNode*)t1;
   TServerNode             * server2 = (TServerNode*)t2;
   WCHAR                   * name1 = server1->GetServer();
   WCHAR                   * name2 = server2->GetServer();
   
   return UStrICmp(name1,name2);
}

int static CompareVal(TNode const * t, void const * v)
{
   TServerNode             * server = (TServerNode*)t;
   WCHAR                   * name1 = server->GetServer();
   WCHAR                   * name2 = (WCHAR*)v;

   return UStrICmp(name1,name2);
}

class TServerList : public TNodeListSortable
{
public:
   TServerList() 
   {
      TypeSetSorted();
      CompareSet(&CompareNames);
   }
   ~TServerList()
   {
      DeleteAllListItems(TServerNode);
   }
   void Clear() { DeleteAllListItems(TServerNode); }
   TServerNode * FindServer(WCHAR const * serverName) { return (TServerNode*)Find(&CompareVal,(void*)serverName); }
   TServerNode * AddServer(WCHAR const * serverName) { TServerNode * p = new TServerNode(serverName); Insert(p); return p; }
};

#endif //__SERVERLIST_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\setdlg.cpp ===
/*---------------------------------------------------------------------------
  File:  LogSettingsDlg.cpp

  Comments: This dialog allows the user to specify a log file, or to manually
  stop and restart the monitoring thread.  This normally won't be needed, but 
  it is useful for debugging.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// LogSettingsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "SetDlg.h"
#include "Monitor.h"
#include "Globals.h"

#include <htmlhelp.h>
#include "helpid.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLogSettingsDlg property page

IMPLEMENT_DYNCREATE(CLogSettingsDlg, CPropertyPage)

CLogSettingsDlg::CLogSettingsDlg() : CPropertyPage(CLogSettingsDlg::IDD)
{
	//{{AFX_DATA_INIT(CLogSettingsDlg)
	m_LogFile = _T("");
	m_Database = _T("");
	m_Import = FALSE;
	//}}AFX_DATA_INIT
   m_ThreadHandle = INVALID_HANDLE_VALUE;
   m_ThreadID = 0;
   gData.GetWaitInterval(&m_Interval);
	m_StartImmediately = FALSE;
}

CLogSettingsDlg::~CLogSettingsDlg()
{
}

void CLogSettingsDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLogSettingsDlg)
	DDX_Control(pDX, IDC_IMPORT, m_ImportControl);
	DDX_Control(pDX, IDC_INTERVAL, m_IntervalEditControl);
	DDX_Control(pDX, IDC_LOGFILE, m_LogEditControl);
	DDX_Control(pDX, IDC_REFRESH_LABEL, m_RefreshLabel);
	DDX_Control(pDX, IDC_LOG_LABEL, m_LogLabel);
	DDX_Control(pDX, IDC_DB_LABEL, m_DBLabel);
	DDX_Control(pDX, IDC_DB, m_DBEditControl);
	DDX_Control(pDX, IDC_STOPMONITOR, m_StopButton);
	DDX_Control(pDX, IDC_STARTMONITOR, m_StartButton);
	DDX_Text(pDX, IDC_INTERVAL, m_Interval);
	DDX_Text(pDX, IDC_LOGFILE, m_LogFile);
	DDX_Text(pDX, IDC_DB, m_Database);
	DDX_Check(pDX, IDC_IMPORT, m_Import);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLogSettingsDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CLogSettingsDlg)
	ON_BN_CLICKED(IDC_STARTMONITOR, OnStartMonitor)
	ON_BN_CLICKED(IDC_STOPMONITOR, OnStopMonitor)
	ON_EN_CHANGE(IDC_LOGFILE, OnChangeLogfile)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogSettingsDlg message handlers


void CLogSettingsDlg::OnStartMonitor() 
{
   UpdateData(TRUE);
   // Kick off a thread to do the monitoring!
   //m_ServerList.DeleteAllItems();
   
   // make sure the filename is not empty
   m_LogFile.TrimLeft();
   m_LogFile.TrimRight();
   if ( m_LogFile.GetLength() == 0 )
   {
      CString message;
      message.LoadString(IDS_PromptEnterDispatchLogName);
      MessageBox(message);
      m_LogEditControl.SetFocus();
      return;
   }
   gData.SetDone(FALSE);
   if ( m_Interval > 0 )
   {
      gData.SetWaitInterval(m_Interval);
   }
   UpdateData(FALSE);
   SetDefID(IDC_STOPMONITOR);
   m_StopButton.EnableWindow(FALSE);      // Disable the buttons, since they don't do anything useful in ADMT
   m_StopButton.SetFocus();
   m_StartButton.EnableWindow(FALSE);

   // disable the interval and other controls
   m_LogLabel.EnableWindow(FALSE);
   m_LogEditControl.EnableWindow(FALSE);
   m_RefreshLabel.EnableWindow(FALSE);
   m_IntervalEditControl.EnableWindow(FALSE);
   m_DBLabel.EnableWindow(FALSE);
   m_DBEditControl.EnableWindow(FALSE);   
   m_ImportControl.EnableWindow(FALSE);

   gData.SetLogPath(m_LogFile.GetBuffer(0));
   gData.SetDatabaseName(m_Database.GetBuffer(0));
   gData.SetImportStats(m_Import);

   m_ThreadHandle = CreateThread(NULL,0,&ResultMonitorFn,NULL,0,&m_ThreadID);
   CloseHandle(m_ThreadHandle);
   m_ThreadHandle = CreateThread(NULL,0,&LogReaderFn,NULL,0,&m_ThreadID);
   CloseHandle(m_ThreadHandle);
   m_ThreadHandle = INVALID_HANDLE_VALUE;
   
}

void CLogSettingsDlg::OnStopMonitor() 
{
   UpdateData(FALSE);
   SetDefID(IDC_STARTMONITOR);
   m_StartButton.EnableWindow(TRUE);
   m_StartButton.SetFocus();
   m_StopButton.EnableWindow(FALSE);

   // enable the interval and other controls
   m_LogLabel.EnableWindow(TRUE);
   m_LogEditControl.EnableWindow(TRUE);
   m_RefreshLabel.EnableWindow(TRUE);
   m_IntervalEditControl.EnableWindow(TRUE);
   m_DBLabel.EnableWindow(TRUE);
   m_DBEditControl.EnableWindow(TRUE);
   m_ImportControl.EnableWindow(TRUE);


   if( m_ThreadHandle != INVALID_HANDLE_VALUE )
   {
      gData.SetDone(TRUE);
      CloseHandle(m_ThreadHandle);
      m_ThreadID = 0;
   }
}


BOOL CLogSettingsDlg::OnSetActive()
{
   BOOL rc = CPropertyPage::OnSetActive();
   
   CancelToClose( );
   return rc;
}

BOOL CLogSettingsDlg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
   if ( m_StartImmediately )
      OnStartMonitor();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CLogSettingsDlg::OnChangeLogfile() 
{
   UpdateData(TRUE);

   CString temp = m_LogFile;

   temp.TrimLeft();
   temp.TrimRight();

   UpdateData(FALSE);
}

void CLogSettingsDlg::OnOK() 
{
   gData.SetDone(TRUE);
   CPropertyPage::OnOK();
}

BOOL CLogSettingsDlg::OnQueryCancel() 
{
	return CPropertyPage::OnQueryCancel();
}

BOOL CLogSettingsDlg::OnApply() 
{
    ComputerStats             stats;
    CString                   strTitle;
    CString                   strText;

    gData.GetComputerStats(&stats);

    // only when all agents have either finished or failed do we allow the user to close the agent monitor
    if ( (stats.numError + stats.numFinished) < stats.total )
    {
        strTitle.LoadString(IDS_MessageTitle);
        strText.LoadString(IDS_AgentsStillRunningCannotExit);
        int result = MessageBox(strText,strTitle,MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2);
        if (result == IDYES)
        {
            gData.SetDone(TRUE);
            gData.SetForcedToStopMonitoring(TRUE);
            return CPropertyPage::OnApply();
        }
    }
    else
    {
        gData.SetDone(TRUE);
        return CPropertyPage::OnApply();
    }

    return FALSE;
}

BOOL CLogSettingsDlg::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
   LPNMHDR lpnm = (LPNMHDR) lParam;
	switch (lpnm->code)
	{
	   case PSN_HELP :
	      helpWrapper(m_hWnd, IDH_WINDOW_AGENT_MONITOR_SETTING);
         break;
   }
   return CPropertyPage::OnNotify(wParam, lParam, pResult);
}

BOOL CLogSettingsDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
   helpWrapper(m_hWnd, IDH_WINDOW_AGENT_MONITOR_SETTING);
	
	return CPropertyPage::OnHelpInfo(pHelpInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\setdlg.h ===
#if !defined(AFX_LOGSETTINGSDLG_H__62C9BACD_D7C6_11D2_A1E2_00A0C9AFE114__INCLUDED_)
#define AFX_LOGSETTINGSDLG_H__62C9BACD_D7C6_11D2_A1E2_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// LogSettingsDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLogSettingsDlg dialog

class CLogSettingsDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogSettingsDlg)

// Construction
public:
	CLogSettingsDlg();
	~CLogSettingsDlg();

   void SetDatabase(WCHAR const * file) { m_Database = file; m_Import = (m_Database.GetLength() > 0); }
   void SetDispatchLog(WCHAR const * logfile) { m_LogFile = logfile; }
   void SetImmediateStart(BOOL bVal) { m_StartImmediately = bVal; }
   virtual BOOL OnSetActive( );
// Dialog Data
	//{{AFX_DATA(CLogSettingsDlg)
	enum { IDD = IDD_STARTSTOP };
	CButton	m_ImportControl;
	CEdit	m_IntervalEditControl;
	CEdit	m_LogEditControl;
	CStatic	m_RefreshLabel;
	CStatic	m_LogLabel;
	CStatic	m_DBLabel;
	CEdit	m_DBEditControl;
	CButton	m_StopButton;
	CButton	m_StartButton;
	long	m_Interval;
	CString	m_LogFile;
	CString	m_Database;
	BOOL	m_Import;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogSettingsDlg)
	public:
	virtual void OnOK();
	virtual BOOL OnQueryCancel();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
   HANDLE m_ThreadHandle;
   DWORD  m_ThreadID;
   BOOL   m_StartImmediately;

   // Generated message map functions
	//{{AFX_MSG(CLogSettingsDlg)
	afx_msg void OnStartMonitor();
	afx_msg void OnStopMonitor();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeLogfile();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOGSETTINGSDLG_H__62C9BACD_D7C6_11D2_A1E2_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\working.cpp ===
// Working.cpp : implementation file
//

#include "stdafx.h"
#include "migdrvr.h"
#include "Working.h"
#include "Resstr.h"
#include <COMDEF.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWorking dialog


CWorking::CWorking(long MSG_ID, CWnd* pParent /*=NULL*/)
	: CDialog(CWorking::IDD, pParent)
{
   _bstr_t x = GET_BSTR(MSG_ID);
   m_strMessage = (WCHAR*)x;
	//{{AFX_DATA_INIT(CWorking)
	//}}AFX_DATA_INIT
}


void CWorking::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWorking)
	DDX_Text(pDX, IDC_STATIC_MESSAGE, m_strMessage);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWorking, CDialog)
	//{{AFX_MSG_MAP(CWorking)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWorking message handlers

BOOL CWorking::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
   CenterWindow();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9287DED1_2A77_11D3_8AE4_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__9287DED1_2A77_11D3_8AE4_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#ifdef _DEBUG
//#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
//#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>


#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC Automation classes
#endif // _AFX_NO_OLE_SUPPORT

#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <iads.h>
#include <adshlp.h>
#include <comdef.h>
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9287DED1_2A77_11D3_8AE4_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\strdesc.cpp ===
/*---------------------------------------------------------------------------
  File:  StrDesc.cpp

  Comments: Implementation of CMigrator member functions that build string descriptions
  of the operations to be performed.  These are implemented in this seperate file to avoid cluttering 
  Migrator.cpp.
  
  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// Migrator.cpp : Implementation of CMcsMigrationDriverApp and DLL registration.

#include "stdafx.h"
#include "MigDrvr.h"
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")

#include "Migrator.h"
#include "TaskChk.h"
#include "ResStr.h"
#include "Common.hpp"
#include "UString.hpp"

void CMigrator::BuildGeneralDesc(IVarSet * pVarSet,CString & str)
{
   CString                   temp;
   _bstr_t                   str1;
   _bstr_t                   str2;

   temp.FormatMessage(IDS_DescGeneral);
   str += temp;
   // Migrate from %ls to %ls
   str1 = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
   str2 = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));

   temp.FormatMessage(IDS_DescDomains,(WCHAR*)str1,(WCHAR*)str2);
   //str += temp;
   // Logfile: %ls
   str1 = pVarSet->get(GET_BSTR(DCTVS_Options_Logfile));
   temp.FormatMessage(IDS_DescLogfile,(WCHAR*)str1);
   str += temp;

   // write changes
   str1 = pVarSet->get(GET_BSTR(DCTVS_Options_NoChange));
   if ( !UStrICmp(str1,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescNoChange);
   }
   else
   {
      temp.FormatMessage(IDS_DescWriteChanges);
   }
   str += temp;
}

void CMigrator::BuildAcctReplDesc(IVarSet * pVarSet,CString & str)
{
   const WCHAR DELIMITER[3] = L",\0";//used to seperate names in the prop exclusion lists

   CString                   temp;
   _bstr_t                   val;
   _bstr_t                   val2;
   _bstr_t                   val3;
   _bstr_t                   val4;
   LONG_PTR                  nVal;
   BOOL                      bCanUseSIDHistory = FALSE;
   CString                   sPropList;

   temp.FormatMessage(IDS_DescAccountMigration);
   str += temp;
   // count of accounts to be copied
   nVal = pVarSet->get(GET_BSTR(DCTVS_Accounts_NumItems));
   temp.FormatMessage(IDS_DescAccountCount,nVal);
   str += temp;
   temp.FormatMessage(IDS_DescCopyAccountTypes);
   str += temp;

   // copy users?
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyUsers));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescCopyUsers);
      str += temp;
      bCanUseSIDHistory = TRUE;
   }
   
   // copy groups?
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyGlobalGroups));
   val2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyLocalGroups));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) || ! UStrICmp(val2,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescCopyGroups);
      str += temp;
      bCanUseSIDHistory = TRUE;
   }

   // copy ous 
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyOUs));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescCopyOUs);
      str += temp;
   }
   
   // copy computers
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyComputers));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescCopyComputers);
      str += temp;
   }

   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_AddSidHistory));
   val2 = pVarSet->get(GET_BSTR(DCTVS_Options_IsIntraforest));

   if ( !UStrICmp(val,GET_STRING(IDS_YES)) || !UStrICmp(val2,GET_STRING(IDS_YES)) )  
   {
      temp.FormatMessage(IDS_SIDHistory_Yes);
   }
   else
   {
      temp.FormatMessage(IDS_SIDHistory_No);
   }
   // If SID-History doesn't apply (i.e. Migrating Computers), don't mention it in the summary screen
   if ( bCanUseSIDHistory )
   {
      str += temp;
   }

   //if rename with prefix
   val = pVarSet->get(GET_BSTR(DCTVS_Options_Prefix));
   if (val.length())
   {
      temp.FormatMessage(IDS_DescRenameWithPrefix,(WCHAR*)val);
      str += temp;
   }
   //if rename with suffix
   val = pVarSet->get(GET_BSTR(DCTVS_Options_Suffix));
   if (val.length())
   {
      temp.FormatMessage(IDS_DescRenameWithSuffix,(WCHAR*)val);
      str += temp;
   }
   
   // name collisions
   temp.FormatMessage(IDS_DescNoReplaceExisting);
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ReplaceExistingAccounts));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescReplaceExisting);
   }
   else
   {
      val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_Prefix));
      if ( val.length() )
      {
         temp.FormatMessage(IDS_DescRenameWithPrefixOnConf,(WCHAR*)val);
      }
      else
      {
         val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_Suffix));
         if ( val.length() )
         {
            temp.FormatMessage(IDS_DescRenameWithSuffixOnConf,(WCHAR*)val);
         }
      }
   }
   str += temp;

      // account disabling status
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableSourceAccounts));
   val2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableCopiedAccounts));
   val3 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExpireSourceAccounts));
   val4 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_TgtStateSameAsSrc));
        //if disable source accounts, add to summary
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescDisableSrcAccts);
      str += temp;
   }
        //if expire source accounts, add to summary
   if (wcslen(val3))
   {
      nVal = _wtol(val3);
      temp.FormatMessage(IDS_DescExpireSrcAccts,nVal);
      str += temp;
   }
        //else if disable target accounts, add to summary
   if ( !UStrICmp(val2,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescDisableTgtAccts);
      str += temp;
   }
   
   else if ( !UStrICmp(val4,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescTgtSameAsSrc);
      str += temp;
   }
        //else if leave source and target accounts active, add to summary
   else 
   {
      temp.FormatMessage(IDS_DescLeaveAcctsActive);
      str += temp;
   }
   
    // roaming profile translation?
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_TranslateRoamingProfiles));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescTranslateRoaming);
      str += temp;
   }

    // update user rights?
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_UpdateUserRights));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescUpdateUserRights);
      str += temp;
   }

    // password generation?
    // only applicable if migrating users
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyUsers));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      //if copying password, say so
      //passwords are always copied during intra-forest migrations
      val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyPasswords));
      val2 = pVarSet->get(GET_BSTR(DCTVS_Options_IsIntraforest));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)) || !UStrICmp(val2,GET_STRING(IDS_YES)) )
      {
          temp.FormatMessage(IDS_DescCopyPassword);
          str += temp;
      }
      else //else checkfor complex or same as username
      {
          val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_GenerateStrongPasswords));
          val2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordFile));
              //if complex, say so
          if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
          {
              temp.FormatMessage(IDS_DescStrongPassword, (WCHAR*)val2);
              str += temp;
          }
          else //else if same as username, say so
          {
              temp.FormatMessage(IDS_DescSimplePassword, (WCHAR*)val2);
              str += temp;
          }
      }
   }

   /* add description of any excluded properties */
     //add user properties excluded, if any 
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyUsers));
   val2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludeProps));
   val3 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedUserProps));
   if (!UStrICmp(val,GET_STRING(IDS_YES)) && !UStrICmp(val2,GET_STRING(IDS_YES)) 
       && UStrICmp(val3, L""))
   {
      temp.FormatMessage(IDS_DescExUserProps);
      str += temp;
         //diplay the list of props (currently in a comma-seperated string)
      sPropList = (WCHAR*)val3;
      if (!sPropList.IsEmpty())
      {
         WCHAR* pStr = sPropList.GetBuffer(0);
         WCHAR* pTemp = wcstok(pStr, DELIMITER);
         while (pTemp != NULL)
         {
            temp.FormatMessage(IDS_DescExcludedProp, pTemp);
            str += temp;
               //get the next item
            pTemp = wcstok(NULL, DELIMITER);
         }
         sPropList.ReleaseBuffer();
      }
   }

     //add InetOrgPerson properties excluded, if any 
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyUsers));
   val2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludeProps));
   val3 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedInetOrgPersonProps));
   if (!UStrICmp(val,GET_STRING(IDS_YES)) && !UStrICmp(val2,GET_STRING(IDS_YES)) 
       && UStrICmp(val3, L""))
   {
      temp.FormatMessage(IDS_DescExInetOrgPersonProps);
      str += temp;
         //diplay the list of props (currently in a comma-seperated string)
      sPropList = (WCHAR*)val3;
      if (!sPropList.IsEmpty())
      {
         WCHAR* pStr = sPropList.GetBuffer(0);
         WCHAR* pTemp = wcstok(pStr, DELIMITER);
         while (pTemp != NULL)
         {
            temp.FormatMessage(IDS_DescExcludedProp, pTemp);
            str += temp;
               //get the next item
            pTemp = wcstok(NULL, DELIMITER);
         }
         sPropList.ReleaseBuffer();
      }
   }
   
     //add group properties excluded, if any 
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyGlobalGroups));
   val2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyLocalGroups));
   val3 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludeProps));
   val4 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedGroupProps));
   if ((!UStrICmp(val,GET_STRING(IDS_YES)) || !UStrICmp(val2,GET_STRING(IDS_YES)))
       && !UStrICmp(val3,GET_STRING(IDS_YES)) && UStrICmp(val4, L""))
   {
      temp.FormatMessage(IDS_DescExGrpProps);
      str += temp;
         //diplay the list of props (currently in a comma-seperated string)
      sPropList = (WCHAR*)val4;
      if (!sPropList.IsEmpty())
      {
         WCHAR* pStr = sPropList.GetBuffer(0);
         WCHAR* pTemp = wcstok(pStr, DELIMITER);
         while (pTemp != NULL)
         {
            temp.FormatMessage(IDS_DescExcludedProp, pTemp);
            str += temp;
               //get the next item
            pTemp = wcstok(NULL, DELIMITER);
         }
         sPropList.ReleaseBuffer();
      }
   }

     //add computer properties excluded, if any 
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyComputers));
   val2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludeProps));
   val3 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedComputerProps));
   if (!UStrICmp(val,GET_STRING(IDS_YES)) && !UStrICmp(val2,GET_STRING(IDS_YES)) 
       && UStrICmp(val3, L""))
   {
      temp.FormatMessage(IDS_DescExCmpProps);
      str += temp;
         //diplay the list of props (currently in a comma-seperated string)
      sPropList = (WCHAR*)val3;
      if (!sPropList.IsEmpty())
      {
         WCHAR* pStr = sPropList.GetBuffer(0);
         WCHAR* pTemp = wcstok(pStr, DELIMITER);
         while (pTemp != NULL)
         {
            temp.FormatMessage(IDS_DescExcludedProp, pTemp);
            str += temp;
               //get the next item
            pTemp = wcstok(NULL, DELIMITER);
         }
         sPropList.ReleaseBuffer();
      }
   }
}

void CMigrator::BuildSecTransDesc(IVarSet * pVarSet,CString & str,BOOL bLocal)
{
   CString                   temp;
   CString                   temp2;
   BOOL                      bHeaderShown = FALSE;

   if ( bLocal )
   {
      // exchange translation
      _bstr_t                server = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateContainers));

      if ( server.length() )
      {
         temp.FormatMessage(IDS_DescContainerTranslation,(WCHAR*)server);
         str += temp;

               // include the translation mode
         _bstr_t mode = pVarSet->get(GET_BSTR(DCTVS_Security_TranslationMode));
         temp.FormatMessage(IDS_TranslationMode,(WCHAR*)mode);
         str += temp;
      }
   }
   else
   {
      CString               head;
      _bstr_t               val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityInputMOT));
      _bstr_t               sInput;
      
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         sInput = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
         temp.FormatMessage(IDS_DescTransInputMOT, (LPCTSTR)sInput);
         str += temp;
      }
      else
      {
         sInput = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityMapFile));
         temp.FormatMessage(IDS_DescTransInputFile, (WCHAR*)sInput);
         str += temp;
      }

      head.FormatMessage(IDS_DescSecurityTranslationFor);
      // translate files?
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateFiles));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescFileTrans);
         str += temp;
      }
      // translate shares?
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateShares));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescShareTrans);
         str += temp;
      }
      // translate printers?
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslatePrinters));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescPrinterTrans);
         str += temp;
      }
      // Translate local group memberships
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateLocalGroups));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescLGTrans);
         str += temp;
      }
      // Translate user rights
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateUserRights));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescRightsTrans);
         str += temp;
      }
      // Translate local user profiles
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateUserProfiles));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescProfileTrans);
         str += temp;
      }
      // Translate Registry
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateRegistry));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescRegistryTrans);
         str += temp;
      }

      if ( bHeaderShown )
      {
         // include the translation mode
         val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslationMode));
         temp.FormatMessage(IDS_TranslationMode,(WCHAR*)val);
         str += temp;
      }
   }

}
void CMigrator::BuildDispatchDesc(IVarSet * pVarSet,CString & str)
{
   BuildSecTransDesc(pVarSet,str,FALSE);
}

void CMigrator::BuildUndoDesc(IVarSet * pVarSet,CString & str)
{
   CString                   temp;
   _bstr_t                   val;
   _bstr_t                   val2;
   long                      nVal;

   temp.FormatMessage(IDS_DescUndo);
   str += temp;
   // count of accounts to be copied
   nVal = pVarSet->get(GET_BSTR(DCTVS_Accounts_NumItems));
   temp.FormatMessage(IDS_DescAccountCountForDelete,nVal);
   str += temp;
}
void CMigrator::BuildReportDesc(IVarSet * pVarSet, CString & str)
{
   _bstr_t                   text;
   CString                   temp;


   text = pVarSet->get(GET_BSTR(DCTVS_Reports_Generate));
   if ( UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      // not generating any reports
      return;
   }

   text = pVarSet->get(GET_BSTR(DCTVS_Reports_MigratedAccounts));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_GenerateMigratedAccountsReport);
      str += temp;
   }

   text = pVarSet->get(GET_BSTR(DCTVS_Reports_MigratedComputers));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_GenerateMigratedComputersReport);
      str += temp;
   }
   

   text = pVarSet->get(GET_BSTR(DCTVS_Reports_ExpiredComputers));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_GenerateExpiredComputersReport);
      str += temp;
   }


   text = pVarSet->get(GET_BSTR(DCTVS_Reports_AccountReferences));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_GenerateAccountReferencesReport);
      str += temp;
   }
   

   text = pVarSet->get(GET_BSTR(DCTVS_Reports_NameConflicts));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_GenerateNameConflictReport);
      str += temp;
   }
   
}

void CMigrator::BuildGroupMappingDesc(IVarSet * pVarSet, CString & str)
{
   long                      nItems;
   CString                   temp;

   nItems = pVarSet->get(GET_BSTR(DCTVS_Accounts_NumItems));
   
   _bstr_t        tgtGroup = pVarSet->get(L"Accounts.0.TargetName");
   
   temp.FormatMessage(IDS_GroupsWillBeMapped,nItems,(WCHAR*)tgtGroup);

   str += temp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\working.h ===
#if !defined(AFX_WORKING_H__84F65A5F_1CE3_43D8_B403_1A0DB5F127DC__INCLUDED_)
#define AFX_WORKING_H__84F65A5F_1CE3_43D8_B403_1A0DB5F127DC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Working.h : header file
//
#include "resource.h"
/////////////////////////////////////////////////////////////////////////////
// CWorking dialog

class CWorking : public CDialog
{
// Construction
public:
	CWorking(long l, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWorking)
	enum { IDD = IDD_PLEASEWAIT };
	CString	m_strMessage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWorking)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWorking)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WORKING_H__84F65A5F_1CE3_43D8_B403_1A0DB5F127DC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\moveobj\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "MoveObj_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\moveobj\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\moveobj\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__B6111B19_491D_11D3_8AEE_00A0C9AFE114__INCLUDED_)
#define AFX_DLLDATAX_H__B6111B19_491D_11D3_8AEE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__B6111B19_491D_11D3_8AEE_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\moveobj\moveobj.cpp ===
// MoveObj.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for MoveObj.idl by adding the following 
//      files to the Outputs.
//          MoveObj_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f MoveObjps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MoveObj.h"
#include "dlldatax.h"

#include "MoveObj_i.c"
#include "Mover.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Mover, CMover)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		ATLTRACE(_T("{MoveObj.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_MOVEOBJLib);
        DisableThreadLibraryCalls(hInstance);
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		ATLTRACE(_T("{MoveObj.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\moveobj\mover.h ===
// Mover.h: Definition of the CMover class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MOVER_H__42ADFF02_491E_11D3_8AEE_00A0C9AFE114__INCLUDED_)
#define AFX_MOVER_H__42ADFF02_491E_11D3_8AEE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include "winldap.h"


/////////////////////////////////////////////////////////////////////////////
// CMover

class CMover : 
	public IDispatchImpl<IMover, &IID_IMover, &LIBID_MOVEOBJLib>, 
	public ISupportErrorInfoImpl<&IID_IMover>,
	public CComObjectRoot,
	public CComCoClass<CMover,&CLSID_Mover>
{
public:
	CMover() {m_srcLD = NULL; m_tgtLD = NULL;}
   ~CMover() { Close(); }
BEGIN_COM_MAP(CMover)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMover)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CMover) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_Mover)

// IMover
public:
	STDMETHOD(MoveObject)(BSTR sourcePath, BSTR targetRDN,BSTR targetOuPath);
	STDMETHOD(CheckMove)(BSTR sourcePath, BSTR targetRDN,BSTR targetOuPath);
	STDMETHOD(Close)();
	STDMETHOD(Connect)(BSTR sourceComp, BSTR targetComp, BSTR srcCredDomain, BSTR srcCredAccount, BSTR srcCredPassword,
                     BSTR tgtCredDomain, BSTR tgtCredAccount, BSTR tgtCredPassword);
protected:
   LDAP        * m_srcLD;
   LDAP        * m_tgtLD;
   WCHAR         m_sourceDSA[300];
   WCHAR         m_targetDSA[300];
};

#endif // !defined(AFX_MOVER_H__42ADFF02_491E_11D3_8AEE_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\moveobj\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MoveObj.rc
//
#define IDS_PROJNAME                    100
#define IDS_MOVER_DESC                  101
#define IDR_Mover                       102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\moveobj\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B6111B11_491D_11D3_8AEE_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__B6111B11_491D_11D3_8AEE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B6111B11_491D_11D3_8AEE_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\moveobj\mover.cpp ===
// Mover.cpp : Implementation of CMoveObjApp and DLL registration.

#include "stdafx.h"
#include <stdio.h>
#include <basetsd.h>
#include <ntdsapi.h>
#include "MoveObj.h"
#include "Mover.h"
#include "UString.hpp"
#include "EaLen.hpp"

#include "ErrDct.hpp"
#include "TReg.hpp"
#include "ResStr.h"
#include "LSAUtils.h"

#include "winldap.h"    // use the platform SDK version of winldap.h, which is in the project directory



#define SECURITY_WIN32  1       // Needed for sspi.h

#include <sspi.h>               // Needed for ISC_REQ_DELEGATE


#define LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID     "1.2.840.113556.1.4.521"
#define LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID_W  L"1.2.840.113556.1.4.521"


TErrorDct      err;
TErrorDct      errLogMain;
StringLoader   gString;

BOOL                                       // ret- whether to perform trace logging to a file
   MoverTraceLogging(   
      WCHAR               * filename       // out- filename to use for trace logging
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;
   WCHAR                     fnW[MAX_PATH];

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),(HKEY)HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"MoveObjectLog",fnW,MAX_PATH);
      if ( ! rc )
      {
         if ( *fnW ) 
         {
            bFound = TRUE;
            UStrCpy(filename,fnW);
         }
         else
         {
            filename[0] = 0;
         }
      }
   }
   return bFound && filename[0];
}


// In the following function we are sending in the logFilename in the tgtCredDomain argument.
// This is done since this is always called with a null value in the ADMT code. To be safe we
// will check if the account value is null then we will treat this as a log file otherwise
// we will need to treat this as credentials.
STDMETHODIMP 
   CMover::Connect(
      BSTR                   sourceComp,        // in - source domain computer to connect to
      BSTR                   targetDSA,         // in - target domain computer to connect to
      BSTR                   srcCredDomain,     // in - credentials to use for source domain
      BSTR                   srcCredAccount,    // in - credentials to use for source domain           
      BSTR                   srcCredPassword,   // in - credentials to use for source domain
      BSTR                   tgtCredDomain,     // in - credentials to use for target domain
      BSTR                   tgtCredAccount,    // in - credentials to use for target domain
      BSTR                   tgtCredPassword    // in - credentials to use for target domain
   )
{

    DWORD                     rc = 0;
    LONG                      value = 0;
    ULONG                     flags = 0;
    ULONG                     result = 0;
    SEC_WINNT_AUTH_IDENTITY   srcCred;
    SEC_WINNT_AUTH_IDENTITY   tgtCred;
    BOOL                      bUseSrcCred = FALSE;
    BOOL                      bUseTgtCred = FALSE;
    BOOL                      bSrcGood = FALSE;
    WCHAR                   * logFileMain;

    // strip off leading \\ if present
    if ( sourceComp && sourceComp[0] == L'\\' )
    {
        UStrCpy(m_sourceDSA,sourceComp + 2);
    }
    else
    {
        UStrCpy(m_sourceDSA,sourceComp);
    }
    if ( targetDSA && targetDSA[0] == L'\\' )
    {
        UStrCpy(m_targetDSA,targetDSA + 2);
    }
    else
    {
        UStrCpy(m_targetDSA,targetDSA);
    }

    // set up credentials structure to use for bind, if needed
    if ( srcCredDomain && *srcCredDomain && srcCredAccount && *srcCredAccount )
    {
        srcCred.User = srcCredAccount;
        srcCred.Domain = srcCredDomain;
        srcCred.Password = NULL;
        srcCred.UserLength = UStrLen(srcCred.User);
        srcCred.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
        srcCred.DomainLength = UStrLen(srcCred.Domain);
        srcCred.PasswordLength = 0;
        bUseSrcCred = TRUE;
    }

    if ( tgtCredAccount && *tgtCredAccount )
    {
        tgtCred.User = tgtCredAccount;
        tgtCred.Domain = tgtCredDomain;
        tgtCred.Password = NULL;
        tgtCred.UserLength = UStrLen(tgtCred.User);
        tgtCred.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
        tgtCred.DomainLength = UStrLen(tgtCred.Domain);
        tgtCred.PasswordLength = 0;
        bUseTgtCred = TRUE;
    }
    else if ( tgtCredDomain && *tgtCredDomain )
    {
        logFileMain = tgtCredDomain;
        if (*logFileMain)
        {
            errLogMain.LogOpen(logFileMain, 1);
        }
    }

    // Open LDAP connections to the source and target computers


    // first, connect to the source computer
    WCHAR                     logFile[LEN_Path];

    if ( MoverTraceLogging(logFile) )
    {
        err.LogOpen(logFile,1);
    }
    err.DbgMsgWrite(0,L"\n\nMoveObject::Connect(%ls,%ls)",m_sourceDSA,m_targetDSA);

    //   m_srcLD = ldap_openW(m_sourceDSA, LDAP_PORT);
    //replace ldap_open(servername,..) with ldap_init and set LDAP_OPT_AREC_EXCLUSIVE 
    //flag so that the following ldap calls (i.e. ldap_bind) will not need to 
    //unnecessarily query for the domain controller
    m_srcLD = ldap_initW(m_sourceDSA, LDAP_PORT);

    if ( m_srcLD == NULL )
    {
        value  = LdapGetLastError();
        if (value == LDAP_SUCCESS )
        {
            rc = ERROR_CONNECTION_REFUSED;
        }
        else
        {
            rc = LdapMapErrorToWin32(result);
        }
        errLogMain.SysMsgWrite(ErrE, rc, DCT_MSG_CONNECT_ERROR_SOURCE_SD, (WCHAR*)m_sourceDSA, rc);
    }

    if ( m_srcLD )
    {
        //set LDAP_OPT_AREC_EXCLUSIVE flag so that the following calls tp
        //ldap_open will not need to unnecessarily query for the domain controller
        flags = PtrToUlong(LDAP_OPT_ON); 
        ldap_set_option(m_srcLD, LDAP_OPT_AREC_EXCLUSIVE, &flags);

        err.DbgMsgWrite(0,L"Setting source options");
        flags = 0;
        // set the delegation flag for the source handle
        result = ldap_get_option(m_srcLD, LDAP_OPT_SSPI_FLAGS,&flags);

        if ( result )
        {
            rc = LdapMapErrorToWin32(result);
        }
        else
        {
            flags |= ISC_REQ_DELEGATE;


            result = ldap_set_option(m_srcLD,LDAP_OPT_SSPI_FLAGS, &flags);
            if ( result )
            {
                rc = LdapMapErrorToWin32(result);
            }
        }
    }

    if ( ! rc )
    {
        err.DbgMsgWrite(0,L"Binding to source");
        // try to bind to the source LDAP server
        if( bUseSrcCred )
        {
            WCHAR szPassword[LEN_Password];

            DWORD dwPasswordError = RetrievePassword(srcCredPassword, szPassword, sizeof(szPassword) / sizeof(szPassword[0]));

            if (dwPasswordError == ERROR_SUCCESS)
            {
                srcCred.Password = szPassword;
                srcCred.PasswordLength = UStrLen(szPassword);

                result = ldap_bind_s(m_srcLD,NULL,(WCHAR*)&srcCred, LDAP_AUTH_SSPI);

                srcCred.Password = NULL;
                srcCred.PasswordLength = 0;

                SecureZeroMemory(szPassword, sizeof(szPassword));

                if (result)
                {
                    rc = LdapMapErrorToWin32(result);
                }
            }
        }
        else
        {
            result = ldap_bind_s(m_srcLD,NULL,NULL, LDAP_AUTH_SSPI);

            if (result)
            {
                rc = LdapMapErrorToWin32(result);
            }
        }

        if (rc == ERROR_SUCCESS)
        {
            bSrcGood = TRUE;
        }
    }

    if ( ! rc )
    {
        err.DbgMsgWrite(0,L"Connecting to target");
        // now try to connect to the target server
        //      m_tgtLD = ldap_openW(m_targetDSA, LDAP_PORT);
        //replace ldap_open(servername,..) with ldap_init and set LDAP_OPT_AREC_EXCLUSIVE 
        //flag so that the following ldap calls (i.e. ldap_bind) will not need to 
        //unnecessarily query for the domain controller
        m_tgtLD = ldap_initW(m_targetDSA, LDAP_PORT);

        if ( m_tgtLD == NULL )
        {
            value  = LdapGetLastError();
            if (value == LDAP_SUCCESS )
            {
                rc = ERROR_CONNECTION_REFUSED;
            }
            else
            {
                rc = LdapMapErrorToWin32(result);
            }
            errLogMain.SysMsgWrite(ErrE, rc, DCT_MSG_CONNECT_ERROR_TARGET_SD, (WCHAR*)m_targetDSA, rc);
        }

        if ( m_tgtLD )
        {
            //set LDAP_OPT_AREC_EXCLUSIVE flag so that the following calls tp
            //ldap_open will not need to unnecessarily query for the domain controller
            flags = PtrToUlong(LDAP_OPT_ON); 
            ldap_set_option(m_tgtLD, LDAP_OPT_AREC_EXCLUSIVE, &flags);

            err.DbgMsgWrite(0,L"Setting target options.");
            flags = 0;

            result = ldap_get_option(m_tgtLD,LDAP_OPT_REFERRALS,&flags);
            if ( result )
            {
                rc = LdapMapErrorToWin32(result);
            }
            else
            {
                flags = PtrToUlong(LDAP_OPT_OFF); 
                result = ldap_set_option(m_tgtLD,LDAP_OPT_REFERRALS,&flags);

                if ( result )
                {
                    rc = LdapMapErrorToWin32(result);
                }
            }
            if ( ! rc )
            {
                err.DbgMsgWrite(0,L"Binding to target.");
                if ( bUseTgtCred )
                {
                    WCHAR szPassword[LEN_Password];

                    DWORD dwPasswordError = RetrievePassword(tgtCredPassword, szPassword, sizeof(szPassword) / sizeof(szPassword[0]));

                    if (dwPasswordError == ERROR_SUCCESS)
                    {
                        srcCred.Password = szPassword;
                        srcCred.PasswordLength = UStrLen(szPassword);

                        result = ldap_bind_s(m_tgtLD,NULL,(PWCHAR)&tgtCred,LDAP_AUTH_SSPI);

                        srcCred.Password = NULL;
                        srcCred.PasswordLength = 0;

                        SecureZeroMemory(szPassword, sizeof(szPassword));

                        if (result)
                        {
                            rc = LdapMapErrorToWin32(result);
                        }
                    }
                }
                else
                {
                    result = ldap_bind_s(m_tgtLD,NULL,NULL,LDAP_AUTH_SSPI);

                    if (result)
                    {
                        rc = LdapMapErrorToWin32(result);
                    }
                }

                if ( rc )
                {
                    err.DbgMsgWrite(0,L"Bind to target failed,rc=%ld, ldapRC=0x%lx",rc,result);
                }
                else
                {
                    err.DbgMsgWrite(0,L"Everything succeeded.");
                }
            }
        }

    }
    if ( bSrcGood )
    {
        rc = 0;
    }
    if ( rc )
    {
        // if failure, clean up any sessions we may have opened
        Close();
    }

    err.LogClose();

    if ( logFileMain && *logFileMain )
    {
        errLogMain.LogClose();
    }

    if ( SUCCEEDED(rc))
        return HRESULT_FROM_WIN32(rc);
    else 
        return rc;
}

STDMETHODIMP CMover::Close()
{
   // close any open connections	
   if ( m_srcLD )
   {
      ldap_unbind_s(m_srcLD);
      m_srcLD = NULL;
   }
   
   if ( m_tgtLD )
   {
      ldap_unbind_s(m_tgtLD);
      m_tgtLD = NULL;
   }

   return S_OK;
}

char * MakeNarrowString(PWCHAR strInput)
{
    char                   * strResult = NULL;
    ULONG                    len = 0;
    
    if ( strInput )
    {
      len = WideCharToMultiByte(CP_UTF8,
                             0,
                             strInput, 
                             wcslen(strInput),
                             NULL,
                             0, 
                             NULL, 
                             NULL);
                             
      strResult = (PCHAR)malloc(len + 1);

      if ( strResult )
      {
         WideCharToMultiByte(CP_UTF8,
                            0, 
                            strInput, 
                            wcslen(strInput),
                            strResult, 
                            len, 
                            NULL, 
                            NULL);
         // make sure the resulting string is null terminated
         strResult[len] = 0;            
      }
    }
    
    return strResult;
}

void StripDN(WCHAR * str)
{
   int                       curr=0,i=0;

   for ( curr=0,i=0; str[i] ; i++ )
   {
      if ( str[i] == L'\\' && str[i+1] == L'/' )
      {
         continue;
      }
      str[curr] = str[i];
      curr++;
  }
  str[curr] = 0;
}
         
STDMETHODIMP CMover::MoveObject(BSTR sourcePath, BSTR targetRDN, BSTR targetOUPath )
{
	WCHAR                     sTargetContainer[LEN_Path];
   WCHAR                     sSourceDN[LEN_Path];
   WCHAR                     sTargetRDN[LEN_Path];
   WCHAR                     sTargetDSA[LEN_Path];
   char                    * pTgtDSA = NULL;
   WCHAR             const * prefix = L"LDAP://";
   HRESULT                   hr = S_OK;
   WCHAR                     logFile[LEN_Path];

   
   // set up the arguments needed to call the interdomain move operation
   UStrCpy(sTargetDSA,m_targetDSA);
   pTgtDSA = MakeNarrowString(sTargetDSA);
   

   // the source path and target OuPath are provided in the LDAP:// format
   
   // get the target container, target DN, and source DN in canonical LDAP format

   if ( !UStrICmp(targetOUPath,prefix,UStrLen(prefix)) )
   {
      WCHAR * start = wcschr(targetOUPath+UStrLen(prefix) + 1,L'/');
      if ( start )
      {
         UStrCpy(sTargetContainer,start + 1);
      }
      else
      {
         // error!
         hr = E_INVALIDARG;
      }
   }
   else
   {
      // error!
      hr = E_INVALIDARG;
   }
   
   if ( !UStrICmp(sourcePath,prefix,UStrLen(prefix)) )
   {
      WCHAR * start = wcschr(sourcePath+UStrLen(prefix)+1,L'/');
      if ( start )
      {
         UStrCpy(sSourceDN,start+1);
         UStrCpy(sTargetRDN,start + 1);
         WCHAR * temp = wcschr(sTargetRDN,L',');
         if ( temp )
         {
            (*temp) = 0;
         }
      }
      else
      {
         // error!
         hr = E_INVALIDARG;
      }
   }
   else
   {
      // error!
      hr = E_INVALIDARG;
   }


   if ( MoverTraceLogging(logFile) )
   {
      err.LogOpen(logFile,1);
   }


   if (hr != S_OK)
   {
      err.DbgMsgWrite(0,L"Bad path parameter to MoveObject, hr=%ld",hr);
      err.LogClose();
      free(pTgtDSA);
      
      return hr;
   }

   StripDN(sSourceDN);
   StripDN(sTargetRDN);
   StripDN(sTargetContainer);
   
   berval  Value;
   Value.bv_val = pTgtDSA;
   Value.bv_len = (pTgtDSA != NULL) ? strlen(pTgtDSA) : 0;

   LDAPControl   ServerControl;
   LDAPControl * ServerControls[2];
   LDAPControl * ClientControls = NULL;

   ServerControl.ldctl_oid = LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID_W;
   ServerControl.ldctl_value = Value;
   ServerControl.ldctl_iscritical = TRUE;

   ServerControls[0] = NULL;
   ServerControls[0] = &ServerControl;
   ServerControls[1] = NULL;
   
   /*
    DstDSA = dns name of dc
    Dn = distinguished name of object to be moved
    NewRdn = relative distinguished name of object 
    NewParent = distinguished name of new parent container
    ServerControls= specify the LDAP operational control for cross domain move
   */ 
   DWORD             ldaprc = ldap_rename_ext_s(m_srcLD, 
                              sSourceDN, 
                              targetRDN, 
                              sTargetContainer, 
                              TRUE,
                              ServerControls, 
                              &ClientControls
                          );

  DWORD            winrc = 0;
  ULONG             error;
  ULONG             result;
 
  if ( ldaprc )
  {

    result =  ldap_get_option(m_srcLD, LDAP_OPT_SERVER_EXT_ERROR,&error);
    if (! result ) 
    {
       winrc = error;
    }
    else
    {
       err.DbgMsgWrite(0,L"Failed to get extended error, result=%ld",result);
       winrc = LdapMapErrorToWin32(ldaprc);
    }
     
  }

   
  err.DbgMsgWrite(0,L"\nMoveObject(sSourceDN=%ls\n,sTargetRDN=%ls\n,sTargetContainer=%ls\n,pTargetDSA=%S)  rc=%ld,ldapRC=%ld",
                              sSourceDN,targetRDN,sTargetContainer,pTgtDSA,winrc,ldaprc);
                                        
  err.LogClose();
  
  free(pTgtDSA);

   if ( SUCCEEDED(winrc))
      return HRESULT_FROM_WIN32(winrc);
   else 
      return winrc;
}



         
STDMETHODIMP CMover::CheckMove(BSTR sourcePath, BSTR targetRDN, BSTR targetOUPath )
{
	WCHAR                     sTargetContainer[LEN_Path];
   WCHAR                     sSourceDN[LEN_Path];
   WCHAR                     sTargetRDN[LEN_Path];
   WCHAR                     sTargetDSA[LEN_Path];
   char                    * pTgtDSA = NULL;
   WCHAR             const * prefix = L"LDAP://";
   HRESULT                   hr = S_OK;
   WCHAR                     logFile[LEN_Path];

   
   // set up the arguments needed to call the interdomain move operation
   UStrCpy(sTargetDSA,m_targetDSA);
   pTgtDSA = MakeNarrowString(sTargetDSA);
   

   // the source path and target OuPath are provided in the LDAP:// format
   
   // get the target container, target DN, and source DN in canonical LDAP format

   if ( !UStrICmp(targetOUPath,prefix,UStrLen(prefix)) )
   {
      WCHAR * start = wcschr(targetOUPath+UStrLen(prefix) + 1,L'/');
      if ( start )
      {
         UStrCpy(sTargetContainer,start + 1);
      }
      else
      {
         // error!
         hr = E_INVALIDARG;
      }
   }
   else
   {
      // error!
      hr = E_INVALIDARG;
   }

   if ( !UStrICmp(sourcePath,prefix,UStrLen(prefix)) )
   {
      WCHAR * start = wcschr(sourcePath+UStrLen(prefix)+1,L'/');
      if ( start )
      {
         UStrCpy(sSourceDN,start+1);
         UStrCpy(sTargetRDN,start + 1);
         WCHAR * temp = wcschr(sTargetRDN,L',');
         if ( temp )
         {
            (*temp) = 0;
         }
      }
      else
      {
         // error!
         hr = E_INVALIDARG;
      }
   }
   else
   {
      // error!
      hr = E_INVALIDARG;
   }

   if ( MoverTraceLogging(logFile) )
   {
      err.LogOpen(logFile,1);
   }
   
   if (hr != S_OK)
   {
      err.DbgMsgWrite(0,L"Bad path parameter to CheckMove, hr=%ld",hr);
      err.LogClose();
      free(pTgtDSA);
      
      return hr;
   }


   StripDN(sSourceDN);
   StripDN(sTargetRDN);
   StripDN(sTargetContainer);
   
   berval  Value;
   // this call will just do the source domain checks, so pass in NULL for the target domain
   Value.bv_val = NULL;
   Value.bv_len = 0;

   LDAPControl   ServerControl;
   LDAPControl * ServerControls[2];
   LDAPControl * ClientControls = NULL;

   ServerControl.ldctl_oid = LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID_W;
   ServerControl.ldctl_value = Value;
   ServerControl.ldctl_iscritical = TRUE;

   ServerControls[0] = NULL;
   ServerControls[0] = &ServerControl;
   ServerControls[1] = NULL;
   
   /*
    DstDSA = dns name of dc
    Dn = distinguished name of object to be moved
    NewRdn = relative distinguished name of object 
    NewParent = distinguished name of new parent container
    ServerControls= specify the LDAP operational control for cross domain move
   */ 
   DWORD             ldaprc = ldap_rename_ext_s(m_srcLD, 
                              sSourceDN, 
                              targetRDN, 
                              sTargetContainer, 
                              TRUE,
                              ServerControls, 
                              &ClientControls
                          );

  DWORD            winrc = 0;
  ULONG            error;
  ULONG            result;

   if ( ldaprc )
   {
      result =  ldap_get_option(m_srcLD, LDAP_OPT_SERVER_EXT_ERROR,&error);
      if (! result ) 
      {
         winrc = error;
      }
      else
      {
         err.DbgMsgWrite(0,L"Failed to get extended error, result=%ld",result);
         winrc = LdapMapErrorToWin32(ldaprc);
      }
   }
 
  err.DbgMsgWrite(0,L"\nMoveObject(sSourceDN=%ls\n,sTargetRDN=%ls\n,sTargetContainer=%ls\n,pTargetDSA=%S)  rc=%ld,ldapRC=%ld,result=%ld",
                              sSourceDN,targetRDN,sTargetContainer,pTgtDSA,winrc,ldaprc,result);
                                        
  err.LogClose();
  
  free(pTgtDSA);

   if ( SUCCEEDED(winrc))
      return HRESULT_FROM_WIN32(winrc);
   else 
      return winrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\mspwdmig\admtcrypt.cpp ===
#include <StdAfx.h>
#include "AdmtCrypt.h"
#include "Array.h"

#include <NtSecApi.h>

#pragma comment( lib, "AdvApi32.lib" )


namespace
{

void __stdcall CreateByteArray(DWORD cb, _variant_t& vntByteArray)
{
	vntByteArray.Clear();

	vntByteArray.parray = SafeArrayCreateVector(VT_UI1, 0, cb);

	if (vntByteArray.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntByteArray.vt = VT_UI1|VT_ARRAY;
}

_variant_t operator +(const _variant_t& vntByteArrayA, const _variant_t& vntByteArrayB)
{
	_variant_t vntByteArrayC;

	// validate parameters

	if ((vntByteArrayA.vt != (VT_UI1|VT_ARRAY)) || ((vntByteArrayA.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	if ((vntByteArrayB.vt != (VT_UI1|VT_ARRAY)) || ((vntByteArrayB.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// concatenate byte arrays

	DWORD cbA = vntByteArrayA.parray->rgsabound[0].cElements;
	DWORD cbB = vntByteArrayB.parray->rgsabound[0].cElements;

	CreateByteArray(cbA + cbB, vntByteArrayC);

	memcpy(vntByteArrayC.parray->pvData, vntByteArrayA.parray->pvData, cbA);
	memcpy((BYTE*)vntByteArrayC.parray->pvData + cbA, vntByteArrayB.parray->pvData, cbB);

	return vntByteArrayC;
}

#ifdef _DEBUG

_bstr_t __stdcall DebugByteArray(const _variant_t& vnt)
{
	_bstr_t strArray;

	if ((vnt.vt == (VT_UI1|VT_ARRAY)) && ((vnt.parray != NULL)))
	{
		_TCHAR szArray[256] = _T("");

		DWORD c = vnt.parray->rgsabound[0].cElements;
		BYTE* pb = (BYTE*) vnt.parray->pvData;

		for (DWORD i = 0; i < c; i++, pb++)
		{
			_TCHAR sz[48];
			wsprintf(sz, _T("%02X"), (UINT)(USHORT)*pb);

			if (i > 0)
			{
				_tcscat(szArray, _T(" "));
			}

			_tcscat(szArray, sz);
		}

		strArray = szArray;
	}

	return strArray;
}

#define TRACE_BUFFER_SIZE 1024

void _cdecl Trace(LPCTSTR pszFormat, ...)
{
	_TCHAR szMessage[TRACE_BUFFER_SIZE];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);

		_vsntprintf(szMessage, TRACE_BUFFER_SIZE, pszFormat, args);

		va_end(args);

	#if 0
		OutputDebugString(szMessage);
	#else
		HANDLE hFile = CreateFile(L"C:\\AdmtCrypt.log", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hFile != INVALID_HANDLE_VALUE)
		{
			SetFilePointer(hFile, 0, NULL, FILE_END);
			DWORD dwWritten;
			WriteFile(hFile, szMessage, _tcslen(szMessage) * sizeof(_TCHAR), &dwWritten, NULL);
			CloseHandle(hFile);
		}
	#endif
	}
}

#else

_bstr_t __stdcall DebugByteArray(const _variant_t& vnt)
{
	return _T("");
}

void _cdecl Trace(LPCTSTR pszFormat, ...)
{
}

#endif

}


//---------------------------------------------------------------------------
// Target Crypt Class
//---------------------------------------------------------------------------


// Constructor

CTargetCrypt::CTargetCrypt()
{
	Trace(_T("CTargetCrypt::CTargetCrypt()\r\n"));
}


// Destructor

CTargetCrypt::~CTargetCrypt()
{
	Trace(_T("CTargetCrypt::~CTargetCrypt()\r\n"));
}


// CreateEncryptionKey Method

_variant_t CTargetCrypt::CreateEncryptionKey(LPCTSTR pszKeyId, LPCTSTR pszPassword)
{
	Trace(_T("CreateEncryptionKey(pszKeyId='%s', pszPassword='%s')\r\n"), pszKeyId, pszPassword);

	// generate encryption key bytes

	_variant_t vntBytes = GenerateRandom(ENCRYPTION_KEY_SIZE);

	Trace(_T(" vntBytes={ %s }\r\n"), (LPCTSTR)DebugByteArray(vntBytes));

	// store encryption key bytes

	StoreBytes(pszKeyId, vntBytes);

	// create key from password

	CCryptHash hashPassword(CreateHash(CALG_SHA1));

	if (pszPassword && pszPassword[0])
	{
		hashPassword.Hash(pszPassword);
	}
	else
	{
		BYTE b = 0;
		hashPassword.Hash(&b, 1);
	}

	CCryptKey keyPassword(DeriveKey(CALG_3DES, hashPassword));

	_variant_t vntPasswordFlag;
	CreateByteArray(1, vntPasswordFlag);
	*((BYTE*)vntPasswordFlag.parray->pvData) = (pszPassword && pszPassword[0]) ? 0xFF : 0x00;

	// concatenate encryption key bytes and hash of encryption key bytes

	CCryptHash hashBytes(CreateHash(CALG_SHA1));
	hashBytes.Hash(vntBytes);

	_variant_t vntDecrypted = vntBytes + hashBytes.GetValue();

//	Trace(_T(" vntDecrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntDecrypted));

	// encrypt bytes / hash pair

	_variant_t vntEncrypted = keyPassword.Encrypt(NULL, true, vntDecrypted);

//	Trace(_T(" vntEncrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntEncrypted));

	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vntBytes), GET_BYTE_ARRAY_SIZE(vntBytes));
	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vntDecrypted), GET_BYTE_ARRAY_SIZE(vntDecrypted));
    

	return vntPasswordFlag + vntEncrypted;
}


// CreateSession Method

_variant_t CTargetCrypt::CreateSession(LPCTSTR pszKeyId)
{
	Trace(_T("CreateSession(pszKeyId='%s')\r\n"), pszKeyId);

	// get encryption key

	CCryptHash hashEncryption(CreateHash(CALG_SHA1));
	hashEncryption.Hash(RetrieveBytes(pszKeyId));

	CCryptKey keyEncryption(DeriveKey(CALG_3DES, hashEncryption));

	// generate session key bytes

	_variant_t vntBytes = GenerateRandom(SESSION_KEY_SIZE);

	// create session key

	CCryptHash hash(CreateHash(CALG_SHA1));
	hash.Hash(vntBytes);

	m_keySession.Attach(DeriveKey(CALG_3DES, hash));

	// concatenate session key bytes and hash of session key bytes

	_variant_t vntDecrypted = vntBytes + hash.GetValue();

	// encrypt session bytes and include hash
	_variant_t varEncrypted = keyEncryption.Encrypt(NULL, true, vntDecrypted);

	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vntBytes), GET_BYTE_ARRAY_SIZE(vntBytes));
	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vntDecrypted), GET_BYTE_ARRAY_SIZE(vntDecrypted));

	return varEncrypted;
}


// Encrypt Method

_variant_t CTargetCrypt::Encrypt(_bstr_t strData)
{
	Trace(_T("Encrypt(strData='%s')\r\n"), (LPCTSTR)strData);

	// convert string to byte array

	_variant_t vnt;

	HRESULT hr = VectorFromBstr(strData, &vnt.parray);

	if (FAILED(hr))
	{
		_com_issue_error(hr);
	}

	vnt.vt = VT_UI1|VT_ARRAY;

	// encrypt data

	_variant_t varEncrypted = m_keySession.Encrypt(NULL, true, vnt);

	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vnt), GET_BYTE_ARRAY_SIZE(vnt));

	return varEncrypted;
}


//---------------------------------------------------------------------------
// Source Crypt Class
//---------------------------------------------------------------------------


// Constructor

CSourceCrypt::CSourceCrypt()
{
	Trace(_T("CSourceCrypt::CSourceCrypt()\r\n"));
}


// Destructor

CSourceCrypt::~CSourceCrypt()
{
	Trace(_T("CSourceCrypt::~CSourceCrypt()\r\n"));
}


// ImportEncryptionKey Method

void CSourceCrypt::ImportEncryptionKey(const _variant_t& vntEncryptedKey, LPCTSTR pszPassword)
{
	Trace(_T("ImportEncryptionKey(vntEncryptedKey={ %s }, pszPassword='%s')\r\n"), (LPCTSTR)DebugByteArray(vntEncryptedKey), pszPassword);

	// validate parameters

	if ((vntEncryptedKey.vt != (VT_UI1|VT_ARRAY)) || ((vntEncryptedKey.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// extract password flag and verify with password

	bool bPassword = *((BYTE*)vntEncryptedKey.parray->pvData) ? true : false;

	if (bPassword)
	{
		if ((pszPassword == NULL) || (pszPassword[0] == NULL))
		{
			_com_issue_error(HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
		}
	}
	else
	{
		if (pszPassword && pszPassword[0])
		{
			_com_issue_error(HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
		}
	}

	// create key from password

	CCryptHash hashPassword(CreateHash(CALG_SHA1));

	if (pszPassword && pszPassword[0])
	{
		hashPassword.Hash(pszPassword);
	}
	else
	{
		BYTE b = 0;
		hashPassword.Hash(&b, 1);
	}

	CCryptKey keyPassword(DeriveKey(CALG_3DES, hashPassword));

	// encrypted data

	_variant_t vntEncrypted;
	DWORD cbEncrypted = vntEncryptedKey.parray->rgsabound[0].cElements - 1;
	CreateByteArray(cbEncrypted, vntEncrypted);
	memcpy(vntEncrypted.parray->pvData, (BYTE*)vntEncryptedKey.parray->pvData + 1, cbEncrypted);

//	Trace(_T(" vntEncrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntEncrypted));

	// decrypt encryption key bytes plus hash

	_variant_t vntDecrypted = keyPassword.Decrypt(NULL, true, vntEncrypted);

//	Trace(_T(" vntDecrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntDecrypted));

	// extract encryption key bytes

	_variant_t vntBytes;
	CreateByteArray(ENCRYPTION_KEY_SIZE, vntBytes);
	memcpy(vntBytes.parray->pvData, (BYTE*)vntDecrypted.parray->pvData, ENCRYPTION_KEY_SIZE);

	Trace(_T(" vntBytes={ %s }\r\n"), (LPCTSTR)DebugByteArray(vntBytes));

	// extract hash of encryption key bytes

	_variant_t vntHashValue;
	DWORD cbHashValue = vntDecrypted.parray->rgsabound[0].cElements - ENCRYPTION_KEY_SIZE;
	CreateByteArray(cbHashValue, vntHashValue);
	memcpy(vntHashValue.parray->pvData, (BYTE*)vntDecrypted.parray->pvData + ENCRYPTION_KEY_SIZE, cbHashValue);

//	Trace(_T(" vntHashValue={ %s }\n"), (LPCTSTR)DebugByteArray(vntHashValue));

	// create hash from bytes and create hash from hash value

	CCryptHash hashA(CreateHash(CALG_SHA1));
	hashA.Hash(vntBytes);

	CCryptHash hashB(CreateHash(CALG_SHA1));
	hashB.SetValue(vntHashValue);

	// if hashes compare store encryption key bytes

	if (hashA == hashB)
	{
		StoreBytes(m_szIdPrefix, vntBytes);
	}
	else
	{
		_com_issue_error(HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
	}

	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vntDecrypted), GET_BYTE_ARRAY_SIZE(vntDecrypted));
	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vntBytes), GET_BYTE_ARRAY_SIZE(vntBytes));
	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vntHashValue), GET_BYTE_ARRAY_SIZE(vntHashValue));
}


// ImportSessionKey Method

void CSourceCrypt::ImportSessionKey(const _variant_t& vntEncryptedKey)
{
	Trace(_T("ImportSessionKey(vntEncryptedKey={ %s })\r\n"), (LPCTSTR)DebugByteArray(vntEncryptedKey));

	// validate parameters

	if ((vntEncryptedKey.vt != (VT_UI1|VT_ARRAY)) || ((vntEncryptedKey.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// get encryption key

	CCryptKey keyEncryption(GetEncryptionKey(m_szIdPrefix));

	// decrypt session key bytes plus hash

	_variant_t vntDecrypted = keyEncryption.Decrypt(NULL, true, vntEncryptedKey);

	// extract session key bytes

	_variant_t vntBytes;
	CreateByteArray(SESSION_KEY_SIZE, vntBytes);
	memcpy(vntBytes.parray->pvData, vntDecrypted.parray->pvData, SESSION_KEY_SIZE);

	// extract hash of session key bytes

	_variant_t vntHashValue;
	DWORD cbHashValue = vntDecrypted.parray->rgsabound[0].cElements - SESSION_KEY_SIZE;
	CreateByteArray(cbHashValue, vntHashValue);
	memcpy(vntHashValue.parray->pvData, (BYTE*)vntDecrypted.parray->pvData + SESSION_KEY_SIZE, cbHashValue);

	// create hash from bytes and create hash from hash value

	CCryptHash hashA(CreateHash(CALG_SHA1));
	hashA.Hash(vntBytes);

	CCryptHash hashB(CreateHash(CALG_SHA1));
	hashB.SetValue(vntHashValue);

	// if hashes compare

	if (hashA == hashB)
	{
		// derive session key from session key bytes hash

		m_keySession.Attach(DeriveKey(CALG_3DES, hashA));
	}
	else
	{
		_com_issue_error(E_FAIL);
	}

	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vntDecrypted), GET_BYTE_ARRAY_SIZE(vntDecrypted));
	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vntBytes), GET_BYTE_ARRAY_SIZE(vntBytes));
	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vntHashValue), GET_BYTE_ARRAY_SIZE(vntHashValue));
}


// Decrypt Method

_bstr_t CSourceCrypt::Decrypt(const _variant_t& vntData)
{
	Trace(_T("Decrypt(vntData={ %s })\r\n"), (LPCTSTR)DebugByteArray(vntData));

	// decrypt data

	_variant_t vnt = m_keySession.Decrypt(NULL, true, vntData);

	// convert into string

	BSTR bstr;

	HRESULT hr = BstrFromVector(vnt.parray, &bstr);

	if (FAILED(hr))
	{
		_com_issue_error(hr);
	}

	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vnt), GET_BYTE_ARRAY_SIZE(vnt));

	return bstr;
}


//---------------------------------------------------------------------------
// Domain Crypt Class
//---------------------------------------------------------------------------


// Constructor

CDomainCrypt::CDomainCrypt()
{
	Trace(_T("CDomainCrypt::CDomainCrypt()\r\n"));
}


// Destructor

CDomainCrypt::~CDomainCrypt()
{
	Trace(_T("CDomainCrypt::~CDomainCrypt()\r\n"));
}


// GetEncryptionKey Method

HCRYPTKEY CDomainCrypt::GetEncryptionKey(LPCTSTR pszKeyId)
{
	// retrieve bytes

	_variant_t vntBytes = RetrieveBytes(pszKeyId);

	// set hash value

	CCryptHash hash;
	hash.Attach(CreateHash(CALG_SHA1));
	hash.Hash(vntBytes);

	// create encryption key derived from bytes

	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vntBytes), GET_BYTE_ARRAY_SIZE(vntBytes));

	return DeriveKey(CALG_3DES, hash);
}


// StoreBytes Method

void CDomainCrypt::StoreBytes(LPCTSTR pszId, const _variant_t& vntBytes)
{
	// validate parameters

	if ((pszId == NULL) || (pszId[0] == NULL))
	{
		_com_issue_error(E_INVALIDARG);
	}

	if ((vntBytes.vt != VT_EMPTY) && (vntBytes.vt != (VT_UI1|VT_ARRAY)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	if ((vntBytes.vt == (VT_UI1|VT_ARRAY)) && (vntBytes.parray == NULL))
	{
		_com_issue_error(E_INVALIDARG);
	}

	LSA_HANDLE hPolicy = NULL;

	try
	{
		// open policy object

		LSA_OBJECT_ATTRIBUTES loa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

		NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &loa, POLICY_CREATE_SECRET, &hPolicy);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		// store data

		PWSTR pwsKey = const_cast<PWSTR>(pszId);
		USHORT cbKey = _tcslen(pszId) * sizeof(_TCHAR);

		PWSTR pwsData = NULL;
		USHORT cbData = 0;

		if (vntBytes.vt != VT_EMPTY)
		{
			pwsData = reinterpret_cast<PWSTR>(vntBytes.parray->pvData);
			cbData = (USHORT) vntBytes.parray->rgsabound[0].cElements;
		}

		LSA_UNICODE_STRING lusKey = { cbKey, cbKey, pwsKey };
		LSA_UNICODE_STRING lusData = { cbData, cbData, pwsData };

		ntsStatus = LsaStorePrivateData(hPolicy, &lusKey, &lusData);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		// close policy object

		LsaClose(hPolicy);
	}
	catch (...)
	{
		if (hPolicy)
		{
			LsaClose(hPolicy);
		}

		throw;
	}
}


// RetrievePrivateData Method

_variant_t CDomainCrypt::RetrieveBytes(LPCTSTR pszId)
{
	_variant_t vntBytes;

	// validate parameters

	if ((pszId == NULL) || (pszId[0] == NULL))
	{
		_com_issue_error(E_INVALIDARG);
	}

	LSA_HANDLE hPolicy = NULL;

	try
	{
		// open policy object

		LSA_OBJECT_ATTRIBUTES loa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

		NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &loa, POLICY_GET_PRIVATE_INFORMATION, &hPolicy);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		// retrieve data

		PWSTR pwsKey = const_cast<PWSTR>(pszId);
		USHORT cbKey = _tcslen(pszId) * sizeof(_TCHAR);

		LSA_UNICODE_STRING lusKey = { cbKey, cbKey, pwsKey };
		PLSA_UNICODE_STRING plusData;

		ntsStatus = LsaRetrievePrivateData(hPolicy, &lusKey, &plusData);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		vntBytes.parray = SafeArrayCreateVector(VT_UI1, 0, plusData->Length);

		if (vntBytes.parray == NULL)
		{
			LsaFreeMemory(plusData);
			_com_issue_error(E_OUTOFMEMORY);
		}

		vntBytes.vt = VT_UI1|VT_ARRAY;

		memcpy(vntBytes.parray->pvData, plusData->Buffer, plusData->Length);

		LsaFreeMemory(plusData);

		// close policy object

		LsaClose(hPolicy);
	}
	catch (...)
	{
		if (hPolicy)
		{
			LsaClose(hPolicy);
		}

		throw;
	}

	return vntBytes;
}


// private data key identifier

_TCHAR CDomainCrypt::m_szIdPrefix[] = _T("L$6A2899C0-CECE-459A-B5EB-7ED04DE61388");


//---------------------------------------------------------------------------
// Crypt Provider Class
//---------------------------------------------------------------------------


// Constructors
//
// Notes:
// If the enhanced provider is not installed, CryptAcquireContext() generates
// the following error: (0x80090019) The keyset is not defined.

CCryptProvider::CCryptProvider() :
	m_hProvider(NULL)
{
	Trace(_T("E CCryptProvider::CCryptProvider(this=0x%p)\r\n"), this);

	if (!CryptAcquireContext(&m_hProvider, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_VERIFYCONTEXT))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

#ifdef _DEBUG
	char szProvider[256];
	DWORD cbProvider = sizeof(szProvider);

	if (CryptGetProvParam(m_hProvider, PP_NAME, (BYTE*) szProvider, &cbProvider, 0))
	{
	}

	DWORD dwVersion;
	DWORD cbVersion = sizeof(dwVersion);

	if (CryptGetProvParam(m_hProvider, PP_VERSION, (BYTE*) &dwVersion, &cbVersion, 0))
	{
	}

//	char szContainer[256];
//	DWORD cbContainer = sizeof(szContainer);

//	if (CryptGetProvParam(m_hProvider, PP_CONTAINER, (BYTE*) szContainer, &cbContainer, 0))
//	{
//	}
#endif

	Trace(_T("L CCryptProvider::CCryptProvider()\r\n"));
}

CCryptProvider::CCryptProvider(const CCryptProvider& r) :
	m_hProvider(r.m_hProvider)
{
//	if (!CryptContextAddRef(r.m_hProvider, NULL, 0))
//	{
//		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
//	}
}


// Destructor

CCryptProvider::~CCryptProvider()
{
	Trace(_T("E CCryptProvider::~CCryptProvider()\r\n"));

	if (m_hProvider)
	{
		if (!CryptReleaseContext(m_hProvider, 0))
		{
			#ifdef _DEBUG
			DebugBreak();
			#endif
		}
	}

	Trace(_T("L CCryptProvider::~CCryptProvider()\r\n"));
}


// assignment operators

CCryptProvider& CCryptProvider::operator =(const CCryptProvider& r)
{
	m_hProvider = r.m_hProvider;

//	if (!CryptContextAddRef(r.m_hProvider, NULL, 0))
//	{
//		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
//	}

	return *this;
}


// CreateHash Method

HCRYPTHASH CCryptProvider::CreateHash(ALG_ID aid)
{
	HCRYPTHASH hHash;

	if (!CryptCreateHash(m_hProvider, aid, 0, 0, &hHash))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return hHash;
}


// DeriveKey Method

HCRYPTKEY CCryptProvider::DeriveKey(ALG_ID aid, HCRYPTHASH hHash, DWORD dwFlags)
{
	HCRYPTKEY hKey;

	if (!CryptDeriveKey(m_hProvider, aid, hHash, dwFlags, &hKey))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return hKey;
}


// GenerateRandom Method
//
// Generates a specified number of random bytes.

_variant_t CCryptProvider::GenerateRandom(DWORD dwNumberOfBytes) const
{
	_variant_t vntRandom;

	// create byte array of specified length

	vntRandom.parray = SafeArrayCreateVector(VT_UI1, 0, dwNumberOfBytes);

	if (vntRandom.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntRandom.vt = VT_UI1|VT_ARRAY;

	// generate specified number of random bytes

	GenerateRandom((BYTE*)vntRandom.parray->pvData, dwNumberOfBytes);

	return vntRandom;
}


// GenerateRandom Method
//
// Generates a specified number of random bytes.

void CCryptProvider::GenerateRandom(BYTE* pbData, DWORD cbData) const
{
	// generate specified number of random bytes

	if (!CryptGenRandom(m_hProvider, cbData, pbData))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}
}


//---------------------------------------------------------------------------
// Crypt Key Class
//---------------------------------------------------------------------------


// Constructor

CCryptKey::CCryptKey(HCRYPTKEY hKey) :
	m_hKey(hKey)
{
}


// Destructor

CCryptKey::~CCryptKey()
{
	if (m_hKey)
	{
		if (!CryptDestroyKey(m_hKey))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
}


// Encrypt Method

_variant_t CCryptKey::Encrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData)
{
	_variant_t vntEncrypted;

	// validate parameters

	if ((vntData.vt != (VT_UI1|VT_ARRAY)) || ((vntData.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// get encrypted data size

	DWORD cbData = vntData.parray->rgsabound[0].cElements;
	DWORD cbBuffer = cbData;

	if (!CryptEncrypt(m_hKey, hHash, bFinal ? TRUE : FALSE, 0, NULL, &cbBuffer, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// create encrypted data buffer

	vntEncrypted.parray = SafeArrayCreateVector(VT_UI1, 0, cbBuffer);

	if (vntEncrypted.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntEncrypted.vt = VT_UI1|VT_ARRAY;

	// copy data to encrypted buffer

	memcpy(vntEncrypted.parray->pvData, vntData.parray->pvData, cbData);

	// encrypt data

	BYTE* pbData = (BYTE*) vntEncrypted.parray->pvData;

	if (!CryptEncrypt(m_hKey, hHash, bFinal ? TRUE : FALSE, 0, pbData, &cbData, cbBuffer))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return vntEncrypted;
}


// Decrypt Method

_variant_t CCryptKey::Decrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData)
{
	_variant_t vntDecrypted;

	// validate parameters

	if ((vntData.vt != (VT_UI1|VT_ARRAY)) || ((vntData.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// decrypt data

	_variant_t vnt = vntData;

	BYTE* pb = (BYTE*) vnt.parray->pvData;
	DWORD cb = vnt.parray->rgsabound[0].cElements;

	if (!CryptDecrypt(m_hKey, hHash, bFinal ? TRUE : FALSE, 0, pb, &cb))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// create decrypted byte array
	// the number of decrypted bytes may be less than
	// the number of encrypted bytes

	vntDecrypted.parray = SafeArrayCreateVector(VT_UI1, 0, cb);

	if (vntDecrypted.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntDecrypted.vt = VT_UI1|VT_ARRAY;

	memcpy(vntDecrypted.parray->pvData, vnt.parray->pvData, cb);

	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vnt), GET_BYTE_ARRAY_SIZE(vnt));

	return vntDecrypted;
}


//---------------------------------------------------------------------------
// Crypt Hash Class
//---------------------------------------------------------------------------


// Constructor

CCryptHash::CCryptHash(HCRYPTHASH hHash) :
	m_hHash(hHash)
{
}


// Destructor

CCryptHash::~CCryptHash()
{
	if (m_hHash)
	{
		if (!CryptDestroyHash(m_hHash))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
}


// GetValue Method

_variant_t CCryptHash::GetValue() const
{
	_variant_t vntValue;

	// get hash size

	DWORD dwHashSize;
	DWORD cbHashSize = sizeof(DWORD);

	if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE*)&dwHashSize, &cbHashSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// allocate buffer

	vntValue.parray = SafeArrayCreateVector(VT_UI1, 0, dwHashSize);

	if (vntValue.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntValue.vt = VT_UI1|VT_ARRAY;

	// get hash value

	if (!CryptGetHashParam(m_hHash, HP_HASHVAL, (BYTE*)vntValue.parray->pvData, &dwHashSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return vntValue;
}


// SetValue Method

void CCryptHash::SetValue(const _variant_t& vntValue)
{
	// if parameter is valid

	if ((vntValue.vt == (VT_UI1|VT_ARRAY)) && ((vntValue.parray != NULL)))
	{
		// get hash size

		DWORD dwHashSize;
		DWORD cbHashSize = sizeof(DWORD);

		if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE*)&dwHashSize, &cbHashSize, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}

		// validate hash size

		BYTE* pbValue = (BYTE*)vntValue.parray->pvData;
		DWORD cbValue = vntValue.parray->rgsabound[0].cElements;

		if (cbValue != dwHashSize)
		{
			_com_issue_error(E_INVALIDARG);
		}

		// set hash value

		if (!CryptSetHashParam(m_hHash, HP_HASHVAL, (BYTE*)pbValue, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


// Hash Method

void CCryptHash::Hash(LPCTSTR pszData)
{
	if (pszData && pszData[0])
	{
		Hash((BYTE*)pszData, _tcslen(pszData) * sizeof(_TCHAR));
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


// Hash Method

void CCryptHash::Hash(const _variant_t& vntData)
{
	if ((vntData.vt == (VT_UI1|VT_ARRAY)) && ((vntData.parray != NULL)))
	{
		Hash((BYTE*)vntData.parray->pvData, vntData.parray->rgsabound[0].cElements);
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


// Hash Method

void CCryptHash::Hash(BYTE* pbData, DWORD cbData)
{
	if ((pbData != NULL) && (cbData > 0))
	{
		if (!CryptHashData(m_hHash, pbData, cbData, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


bool CCryptHash::operator ==(const CCryptHash& hash)
{
	bool bEqual = false;

	DWORD cbSize = sizeof(DWORD);

	// compare hash sizes

	DWORD dwSizeA;
	DWORD dwSizeB;

	if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE*)&dwSizeA, &cbSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	if (!CryptGetHashParam(hash.m_hHash, HP_HASHSIZE, (BYTE*)&dwSizeB, &cbSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// if sizes are equal

	if (dwSizeA == dwSizeB)
	{
		// compare hashes

		c_array<BYTE> pbA(dwSizeA);
		c_array<BYTE> pbB(dwSizeB);

		if (!CryptGetHashParam(m_hHash, HP_HASHVAL, pbA, &dwSizeA, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}

		if (!CryptGetHashParam(hash.m_hHash, HP_HASHVAL, pbB, &dwSizeB, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}

		if (memcmp(pbA, pbB, dwSizeA) == 0)
		{
			bEqual = true;
		}
	}

	return bEqual;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\mspwdmig\admtcrypt.h ===
#pragma once

#include <TChar.h>
#include <Windows.h>
#include <WinCrypt.h>
#include <ComDef.h>


#define ENCRYPTION_KEY_SIZE 16 // in bytes
#define SESSION_KEY_SIZE    16 // in bytes

#define GET_BYTE_ARRAY_DATA(v) ((char*)((v).parray->pvData))
#define GET_BYTE_ARRAY_SIZE(v) ((unsigned long)((v).parray->rgsabound[0].cElements))


//---------------------------------------------------------------------------
// Crypt Provider Class
//---------------------------------------------------------------------------

class CCryptProvider
{
public:

	CCryptProvider();
	CCryptProvider(const CCryptProvider& r);
	~CCryptProvider();

	CCryptProvider& operator =(const CCryptProvider& r);

	HCRYPTHASH CreateHash(ALG_ID aid);
	HCRYPTKEY DeriveKey(ALG_ID aid, HCRYPTHASH hHash, DWORD dwFlags = 0);

	_variant_t GenerateRandom(DWORD cbData) const;
	void GenerateRandom(BYTE* pbData, DWORD cbData) const;

protected:

	HCRYPTPROV m_hProvider;
};


//---------------------------------------------------------------------------
// Crypt Key Class
//---------------------------------------------------------------------------

class CCryptKey
{
public:

	CCryptKey(HCRYPTKEY hKey = NULL);
	~CCryptKey();

	operator HCRYPTKEY()
	{
		return m_hKey;
	}

	void Attach(HCRYPTKEY hKey)
	{
		m_hKey = hKey;
	}

	HCRYPTKEY Detach()
	{
		HCRYPTKEY hKey = m_hKey;
		m_hKey = NULL;
		return hKey;
	}

	_variant_t Encrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData);
	_variant_t Decrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData);

protected:

	CCryptKey(const CCryptKey& key) {}
	CCryptKey& operator =(const CCryptKey& key) { return *this; }

protected:

	HCRYPTKEY m_hKey;
};


//---------------------------------------------------------------------------
// Crypt Hash Class
//---------------------------------------------------------------------------

class CCryptHash
{
public:

	CCryptHash(HCRYPTHASH hHash = NULL);
	~CCryptHash();

	operator HCRYPTHASH()
	{
		return m_hHash;
	}

	void Attach(HCRYPTHASH hHash)
	{
		m_hHash = hHash;
	}

	HCRYPTKEY Detach()
	{
		HCRYPTKEY hHash = m_hHash;
		m_hHash = NULL;
		return hHash;
	}

	_variant_t GetValue() const;
	void SetValue(const _variant_t& vntValue);

	void Hash(LPCTSTR pszData);
	void Hash(const _variant_t& vntData);
	void Hash(BYTE* pbData, DWORD cbData);

	bool operator ==(const CCryptHash& hash);

	bool operator !=(const CCryptHash& hash)
	{
		return !this->operator ==(hash);
	}

protected:

	CCryptHash(const CCryptKey& hash) {}
	CCryptHash& operator =(const CCryptHash& hash) { return *this; }

protected:

	HCRYPTHASH m_hHash;
};


//---------------------------------------------------------------------------
// Domain Crypt Class
//---------------------------------------------------------------------------

class CDomainCrypt : public CCryptProvider
{
protected:

	CDomainCrypt();
	~CDomainCrypt();

	HCRYPTKEY GetEncryptionKey(LPCTSTR pszKeyId);

	void StoreBytes(LPCTSTR pszId, const _variant_t& vntBytes);
	void StoreBytes(LPCTSTR pszId, BYTE* pBytes, DWORD cBytes);
	_variant_t RetrieveBytes(LPCTSTR pszId);

protected:

	static _TCHAR m_szIdPrefix[];
};


//---------------------------------------------------------------------------
// Target Crypt Class
//
// CreateEncryptionKey
// - creates encryption key
// - stores encryption key using key identifier
// - returns encryption key encrypted with given password
//---------------------------------------------------------------------------

class CTargetCrypt : public CDomainCrypt
{
public:

	CTargetCrypt();
	~CTargetCrypt();

	_variant_t CreateEncryptionKey(LPCTSTR pszKeyId, LPCTSTR pszPassword = NULL);

	_variant_t CreateSession(LPCTSTR pszKeyId);

	_variant_t Encrypt(_bstr_t strData);

protected:

	void StoreBytes(LPCTSTR pszId, const _variant_t& vntBytes)
	{
		LPTSTR psz = (LPTSTR) _alloca((_tcslen(m_szIdPrefix) + 1 + _tcslen(pszId) + 1) * sizeof(_TCHAR));

		_tcscpy(psz, m_szIdPrefix);
		_tcscat(psz, _T("_"));
		_tcscat(psz, pszId);

		CDomainCrypt::StoreBytes(psz, vntBytes);
	}

	_variant_t RetrieveBytes(LPCTSTR pszId)
	{
		LPTSTR psz = (LPTSTR) _alloca((_tcslen(m_szIdPrefix) + 1 + _tcslen(pszId) + 1) * sizeof(_TCHAR));

		_tcscpy(psz, m_szIdPrefix);
		_tcscat(psz, _T("_"));
		_tcscat(psz, pszId);

		return CDomainCrypt::RetrieveBytes(psz);
	}

protected:

	CCryptKey m_keySession;
};


//---------------------------------------------------------------------------
// Source Crypt Class
//---------------------------------------------------------------------------

class CSourceCrypt : public CDomainCrypt
{
public:

	CSourceCrypt();
	~CSourceCrypt();

	void ImportEncryptionKey(const _variant_t& vntEncryptedKey, LPCTSTR pszPassword = NULL);

	void ImportSessionKey(const _variant_t& vntEncryptedKey);

	_bstr_t Decrypt(const _variant_t& vntData);

protected:

	CCryptKey m_keySession;
};


//---------------------------------------------------------------------------
// Use Cases
//---------------------------------------------------------------------------
//
// Target Domain Controller
// ------------------------
// Generate Encryption Key
// - given source domain name and optional password
// - generate 128 bit encryption key
// - store encryption key using source domain name
// - if given optional password encrypt key with password
// - return encrypted key
//
// Generate Session Key
// - given source domain name
// - generate 128 bit session key
// - generate hash of session key
// - retrieve encryption key using source domain name
// - encrypt session key and hash with encryption key
// - return encrypted session key/hash
//
// Encrypt Data
// - given data
// - encrypt data using session key
// - return encrypted data
//
// Password Export Server (PES)
// ----------------------------
// Store Encryption Key
// - given encrypted encryption key and password
// - decrypt key using password
// - store key
//
// Decrypt Session Key
// - given an encrypted session key / hash
// - decrypt using encryption key
// - generate hash of decrypted session key
// - compare against decrypted hash
// - store session key
// - return success or failure
//
// Decrypt Data
// - given encrypted data
// - decrypt data using session key
// - return un-encrypted data
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\mspwdmig\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\mspwdmig\error.h ===
#pragma once

#include <ComDef.h>


//---------------------------------------------------------------------------
// Error Methods
//---------------------------------------------------------------------------


void __cdecl ThrowError(_com_error ce, UINT uId, ...);
void __cdecl ThrowError(_com_error ce, LPCTSTR pszFormat = NULL, ...);
void __cdecl ThrowError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...);
void __cdecl ThrowError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat = NULL, ...);


HRESULT __cdecl SetError(_com_error ce, UINT uId, ...);
HRESULT __cdecl SetError(_com_error ce, LPCTSTR pszFormat = NULL, ...);
HRESULT __cdecl SetError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...);
HRESULT __cdecl SetError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat = NULL, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\mspwdmig\error.cpp ===
#include "StdAfx.h"
#include "Error.h"


using namespace _com_util;

#define FORMAT_BUFFER_SIZE	    1024
#define DESCRIPTION_BUFFER_SIZE 2048

#define COUNT_OF(a) (sizeof(a) / sizeof(a[0]))
#define LENGTH_OF(a) (sizeof(a) / sizeof(a[0]) - sizeof(a[0]))


namespace
{


    // AdmtCreateErrorInfo Method

    IErrorInfoPtr __stdcall AdmtCreateErrorInfo(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription)
    {
        ICreateErrorInfoPtr spCreateErrorInfo;

        CreateErrorInfo(&spCreateErrorInfo);

        if (spCreateErrorInfo)
        {
            IErrorInfoPtr spErrorInfo = ce.ErrorInfo();

            //		if (spErrorInfo == NULL)
            //		{
            //			GetErrorInfo(0, &spErrorInfo);
            //		}

            // source

            if (IsEqualCLSID(clsid, GUID_NULL) == FALSE)
            {
                LPOLESTR pszProgId;

                if (ProgIDFromCLSID(clsid, &pszProgId) == S_OK)
                {
                    spCreateErrorInfo->SetSource(pszProgId);
                    CoTaskMemFree(pszProgId);
                }
                else
                {
                    spCreateErrorInfo->SetSource(L"");
                }
            }
            else if (spErrorInfo)
            {
                BSTR bstrSource;
                HRESULT hr = spErrorInfo->GetSource(&bstrSource);

                if (SUCCEEDED(hr))
                {
                    spCreateErrorInfo->SetSource(bstrSource);
                    SysFreeString(bstrSource);
                }
                else
                {
                    spCreateErrorInfo->SetSource(L"");
                }
            }
            else
            {
                spCreateErrorInfo->SetSource(L"");
            }

            // GUID

            bool bInterfaceSpecified = false;

            if (IsEqualIID(iid, GUID_NULL) == FALSE)
            {
                spCreateErrorInfo->SetGUID(iid);
                bInterfaceSpecified = true;
            }
            else if (spErrorInfo)
            {
                GUID guid;
                HRESULT hr = spErrorInfo->GetGUID(&guid);

                if (SUCCEEDED(hr))
                {
                    spCreateErrorInfo->SetGUID(guid);
                }
                else
                {
                    spCreateErrorInfo->SetGUID(GUID_NULL);
                }
            }
            else
            {
                spCreateErrorInfo->SetGUID(GUID_NULL);
            }

            // description

            _bstr_t strDescription = pszDescription;

            if (spErrorInfo)
            {
/*
                BSTR bstrSource;
                spErrorInfo->GetSource(&bstrSource);

                if (SysStringLen(bstrSource) > 0)
                {
                if (strDescription.length() > 0)
                {
                strDescription += _T(" : ");
                }

                strDescription += bstrSource;
                }

                SysFreeString(bstrSource);
*/
                BSTR bstrDescription = NULL;
                HRESULT hr = spErrorInfo->GetDescription(&bstrDescription);

                if (SUCCEEDED(hr) && (SysStringLen(bstrDescription) > 0))
                {
                    if (strDescription.length() > 0)
                    {
                        strDescription += _T(" ");
                    }

                    strDescription += bstrDescription;
                }
                else if (bInterfaceSpecified == false)
                {
                    LPCTSTR pszErrorMessage = ce.ErrorMessage();

                    if (pszErrorMessage)
                    {
                        if (strDescription.length() > 0)
                        {
                            strDescription += _T(" ");
                        }

                        strDescription += pszErrorMessage;
                    }
                }

                if (bstrDescription)
                {
                    SysFreeString(bstrDescription);
                }
            }
            else if (bInterfaceSpecified == false)
            {
                LPCTSTR pszErrorMessage = ce.ErrorMessage();

                if (pszErrorMessage)
                {
                    if (strDescription.length() > 0)
                    {
                        strDescription += _T(" ");
                    }

                    strDescription += pszErrorMessage;
                }
            }

            spCreateErrorInfo->SetDescription(strDescription);

            // help file

            if (spErrorInfo)
            {
                BSTR bstrHelpFile;
                HRESULT hr = spErrorInfo->GetHelpFile(&bstrHelpFile);

                if (SUCCEEDED(hr))
                {
                    spCreateErrorInfo->SetHelpFile(bstrHelpFile);
                    SysFreeString(bstrHelpFile);
                }
                else
                {
                    spCreateErrorInfo->SetHelpFile(L"");
                }
            }
            else
            {
                spCreateErrorInfo->SetHelpFile(L"");
            }

            // help context

            DWORD dwHelpContext = 0;

            if (spErrorInfo)
            {
                spErrorInfo->GetHelpContext(&dwHelpContext);
            }

            spCreateErrorInfo->SetHelpContext(dwHelpContext);
        }

        return IErrorInfoPtr(spCreateErrorInfo);
    }


    // ThrowErrorImpl Method

    inline void __stdcall ThrowErrorImpl(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription)
    {
        IErrorInfoPtr spErrorInfo = AdmtCreateErrorInfo(clsid, iid, ce, pszDescription);

        if (spErrorInfo)
        {
            _com_raise_error(ce.Error(), spErrorInfo.Detach());
        }
        else
        {
            _com_raise_error(ce.Error());
        }
    }


    // SetErrorImpl Method

    inline HRESULT __stdcall SetErrorImpl(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription)
    {
        IErrorInfoPtr spErrorInfo = AdmtCreateErrorInfo(clsid, iid, ce, pszDescription);

        if (spErrorInfo)
        {
            SetErrorInfo(0, spErrorInfo);
        }

        return ce.Error();
    }


} // namespace


//---------------------------------------------------------------------------
// Error Methods
//---------------------------------------------------------------------------


//
// ThrowError Methods
//


void __cdecl ThrowError(_com_error ce, UINT uId, ...)
{
    _TCHAR szFormat[FORMAT_BUFFER_SIZE];
    _TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

    if (LoadString(_Module.GetResourceInstance(), uId, szFormat, COUNT_OF(szFormat)))
    {
        va_list args;
        va_start(args, uId);
        _vsntprintf(szDescription, COUNT_OF(szDescription), szFormat, args);
        szDescription[COUNT_OF(szDescription) - 1] = _T('\0');
        va_end(args);
    }
    else
    {
        szDescription[0] = _T('\0');
    }

    ThrowErrorImpl(GUID_NULL, GUID_NULL, ce, szDescription);
}


void __cdecl ThrowError(_com_error ce, LPCTSTR pszFormat, ...)
{
    _TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

    if (pszFormat)
    {
        va_list args;
        va_start(args, pszFormat);
        _vsntprintf(szDescription, COUNT_OF(szDescription), pszFormat, args);
        szDescription[COUNT_OF(szDescription) - 1] = _T('\0');
        va_end(args);
    }
    else
    {
        szDescription[0] = _T('\0');
    }

    ThrowErrorImpl(GUID_NULL, GUID_NULL, ce, szDescription);
}


void __cdecl ThrowError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...)
{
    _TCHAR szFormat[FORMAT_BUFFER_SIZE];
    _TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

    if (LoadString(_Module.GetResourceInstance(), uId, szFormat, COUNT_OF(szFormat)))
    {
        va_list args;
        va_start(args, uId);
        _vsntprintf(szDescription, COUNT_OF(szDescription), szFormat, args);
        szDescription[COUNT_OF(szDescription) - 1] = _T('\0');
        va_end(args);
    }
    else
    {
        szDescription[0] = _T('\0');
    }

    ThrowErrorImpl(clsid, iid, ce, szDescription);
}


void __cdecl ThrowError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat, ...)
{
    _TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

    if (pszFormat)
    {
        va_list args;
        va_start(args, pszFormat);
        _vsntprintf(szDescription, COUNT_OF(szDescription), pszFormat, args);
        szDescription[COUNT_OF(szDescription) - 1] = _T('\0');
        va_end(args);
    }
    else
    {
        szDescription[0] = _T('\0');
    }

    ThrowErrorImpl(clsid, iid, ce, szDescription);
}


//
// SetError Methods
//


HRESULT __cdecl SetError(_com_error ce, UINT uId, ...)
{
    _TCHAR szFormat[FORMAT_BUFFER_SIZE];
    _TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

    if (LoadString(_Module.GetResourceInstance(), uId, szFormat, COUNT_OF(szFormat)))
    {
        va_list args;
        va_start(args, uId);
        _vsntprintf(szDescription, COUNT_OF(szDescription), szFormat, args);
        szDescription[COUNT_OF(szDescription) - 1] = _T('\0');
        va_end(args);
    }
    else
    {
        szDescription[0] = _T('\0');
    }

    return SetErrorImpl(GUID_NULL, GUID_NULL, ce, szDescription);
}


HRESULT __cdecl SetError(_com_error ce, LPCTSTR pszFormat, ...)
{
    _TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

    if (pszFormat)
    {
        va_list args;
        va_start(args, pszFormat);
        _vsntprintf(szDescription, COUNT_OF(szDescription), pszFormat, args);
        szDescription[COUNT_OF(szDescription) - 1] = _T('\0');
        va_end(args);
    }
    else
    {
        szDescription[0] = _T('\0');
    }

    return SetErrorImpl(GUID_NULL, GUID_NULL, ce, szDescription);
}


HRESULT __cdecl SetError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...)
{
    _TCHAR szFormat[FORMAT_BUFFER_SIZE];
    _TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

    if (LoadString(_Module.GetResourceInstance(), uId, szFormat, COUNT_OF(szFormat)))
    {
        va_list args;
        va_start(args, uId);
        _vsntprintf(szDescription, COUNT_OF(szDescription), szFormat, args);
        szDescription[COUNT_OF(szDescription) - 1] = _T('\0');
        va_end(args);
    }
    else
    {
        szDescription[0] = _T('\0');
    }

    return SetErrorImpl(clsid, iid, ce, szDescription);
}


HRESULT __cdecl SetError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat, ...)
{
    _TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

    if (pszFormat)
    {
        va_list args;
        va_start(args, pszFormat);
        _vsntprintf(szDescription, COUNT_OF(szDescription), pszFormat, args);
        szDescription[COUNT_OF(szDescription) - 1] = _T('\0');
        va_end(args);
    }
    else
    {
        szDescription[0] = _T('\0');
    }

    return SetErrorImpl(clsid, iid, ce, szDescription);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\mspwdmig\passwordmigration.h ===
#pragma once

#include <memory>
#include "Resource.h"
#include "ADMTCrypt.h"


//---------------------------------------------------------------------------
// CPasswordMigration
//---------------------------------------------------------------------------

class ATL_NO_VTABLE CPasswordMigration : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CPasswordMigration, &CLSID_PasswordMigration>,
    public ISupportErrorInfoImpl<&IID_IPasswordMigration>,
    public IDispatchImpl<IPasswordMigration, &IID_IPasswordMigration, &LIBID_MsPwdMig>
{
public:

    CPasswordMigration();
    ~CPasswordMigration();

    DECLARE_REGISTRY_RESOURCEID(IDR_PASSWORDMIGRATION)
    DECLARE_NOT_AGGREGATABLE(CPasswordMigration)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CPasswordMigration)
        COM_INTERFACE_ENTRY(IPasswordMigration)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP()

    // IPasswordMigration
    STDMETHOD(EstablishSession)(BSTR bstrSourceServer, BSTR bstrTargetServer);
    STDMETHOD(CopyPassword)(BSTR bstrSourceAccount, BSTR bstrTargetAccount, BSTR bstrTargetPassword);
    STDMETHOD(GenerateKey)(BSTR bstrSourceDomainName, BSTR bstrKeyFilePath, BSTR bstrPassword);

protected:

    void GenerateKeyImpl(LPCTSTR pszDomain, LPCTSTR pszFile, LPCTSTR pszPassword);
    void CheckPasswordDC(LPCWSTR srcServer, LPCWSTR tgtServer);
    void CopyPasswordImpl(LPCTSTR pszSourceAccount, LPCTSTR pszTargetAccount, LPCTSTR pszPassword);

    void CheckPreWindows2000CompatibleAccessGroupMembers(bool& bEveryone, bool& bAnonymous);
    static _bstr_t GetPathToPreW2KCAGroup();
    static BOOL DoesAnonymousHaveEveryoneAccess(LPCWSTR tgtServer);

    static void GetDomainName(LPCTSTR pszServer, _bstr_t& strNameDNS, _bstr_t& strNameFlat);
    static _bstr_t GetDefaultNamingContext(_bstr_t strDomain);

protected:

    bool m_bSessionEstablished;
    handle_t m_hBinding;
    _TCHAR* m_sBinding;

    _bstr_t m_strSourceServer;
    _bstr_t m_strTargetServer;

    _bstr_t m_strSourceDomainDNS;
    _bstr_t m_strSourceDomainFlat;
    _bstr_t m_strTargetDomainDNS;
    _bstr_t m_strTargetDomainFlat;

    CTargetCrypt* m_pTargetCrypt;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\mspwdmig\mspwdmig.cpp ===
// MsPwdMig.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f MsPwdMigps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MsPwdMig.h"

#include "MsPwdMig_i.c"
#include "PasswordMigration.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_PasswordMigration, CPasswordMigration)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MsPwdMig);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\mspwdmig\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MsPwdMig.rc
//
#define IDS_PROJNAME                    100
#define IDR_PASSWORDMIGRATION           101
#define IDS_E_CANNOT_ESTABLISH_SESSION  101
#define IDS_E_CANNOT_COPY_PASSWORD      102
#define IDS_E_CANNOT_GENERATE_KEY       103
#define IDS_E_KEY_DOMAIN_NOT_SPECIFIED  104
#define IDS_E_KEY_FILE_NOT_SPECIFIED    105
#define IDS_E_KEY_FILE_NOT_LOCAL_DRIVE  106
#define IDS_E_KEY_FILE_EXTENSION_INVALID 107
#define IDS_E_KEY_CANT_CREATE_FILE      108
#define IDS_E_KEY_CANT_WRITE_FILE       109
#define IDS_E_CANNOT_GET_DOMAIN_NAME    110
#define IDS_E_EVERYONE_NOT_MEMBEROF_GROUP 111
#define IDS_E_EVERYONE_DOES_NOT_INCLUDE_ANONYMOUS 112
#define IDS_E_HIGH_ENCRYPTION_NOT_INSTALLED 113
#define IDS_E_ENCRYPTION_OBJECT_FAILURE 114
#define IDS_E_GENERATE_SESSION_KEY_FAILED 115
#define IDS_E_GENERATE_SESSION_PASSWORD_FAILED 116
#define IDS_E_PASSWORD_MIGRATION_NOT_ENABLED 117
#define IDS_E_ENCRYPTION_KEYS_DO_NOT_MATCH 118
#define IDS_E_PASSWORD_MIGRATION_NOT_RUNNING 119
#define IDS_E_SESSION_NOT_ESTABLISHED   120
#define IDS_E_PASSWORD_MIGRATION_NOT_FUNCTIONING 121
#define IDS_E_SOURCE_SERVER_NOT_SPECIFIED 122
#define IDS_E_TARGET_SERVER_NOT_SPECIFIED 123
#define IDS_E_SOURCE_ACCOUNT_NOT_SPECIFIED 124
#define IDS_E_TARGET_ACCOUNT_NOT_SPECIFIED 125
#define IDS_E_NO_ENCRYPTION_KEY_FOR_DOMAIN 126

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\mspwdmig\passwordmigration.cpp ===
#include "stdafx.h"
#include "MsPwdMig.h"
#include "PasswordMigration.h"

#include <NtSecApi.h>
#include <io.h>
#include <winioctl.h>
#include <lm.h>
#include <eh.h>
#include <ActiveDS.h>
#include <Dsrole.h>
#include "TReg.hpp"
#include "pwdfuncs.h"
#include "PWGen.hpp"
#include "UString.hpp"
#include "PwRpcUtl.h"
#include "PwdSvc.h"
#include "PwdSvc_c.c"
#include "Error.h"
#include "GetDcName.h"

#pragma comment(lib, "netapi32.lib")
#pragma comment(lib, "adsiid.lib")
#pragma comment(lib, "activeds.lib")
#pragma comment(lib, "commonlib.lib")

using namespace _com_util;


namespace 
{


struct SSeException
{
	SSeException(UINT uCode) :
		uCode(uCode)
	{
	}

	UINT uCode;
};

void SeTranslator(unsigned int u, EXCEPTION_POINTERS* pepExceptions)
{
	throw SSeException(u);
}

#ifdef ADMT_TRACE
void _cdecl ADMTTRACE(LPCTSTR pszFormat, ...)
{
    if (pszFormat)
    {
        _TCHAR szMessage[2048];
        va_list args;
        va_start(args, pszFormat);
        _vsntprintf(szMessage, 2048, pszFormat, args);
        va_end(args);
        OutputDebugString(szMessage);
    }
}
#else
inline void _cdecl ADMTTRACE(LPCTSTR pszFormat, ...)
{
}
#endif

#ifndef IADsPtr
_COM_SMARTPTR_TYPEDEF(IADs, IID_IADs);
#endif
#ifndef IADsGroupPtr
_COM_SMARTPTR_TYPEDEF(IADsGroup, IID_IADsGroup);
#endif
#ifndef IADsMembersPtr
_COM_SMARTPTR_TYPEDEF(IADsMembers, IID_IADsMembers);
#endif

}
// namespace


//---------------------------------------------------------------------------
// CPasswordMigration
//---------------------------------------------------------------------------


// Constructor

CPasswordMigration::CPasswordMigration() :
    m_bSessionEstablished(false),
    m_hBinding(NULL),
    m_sBinding(NULL),
    m_pTargetCrypt(NULL)
{
}


// Destructor

CPasswordMigration::~CPasswordMigration()
{
    delete m_pTargetCrypt;

    if (m_bSessionEstablished)
    {
        _se_translator_function pfnSeTranslatorOld = _set_se_translator((_se_translator_function)SeTranslator);

        try
        {
            PwdBindDestroy(&m_hBinding,&m_sBinding);
        }
        catch (SSeException& e)
        {
            ADMTTRACE(_T("PwdBindDestroy: %s (%u)\n"), _com_error(HRESULT_FROM_WIN32(e.uCode)).ErrorMessage(), e.uCode);
        }

        _set_se_translator(pfnSeTranslatorOld);
    }
}


//
// IPasswordMigration Implementation ----------------------------------------
//


// EstablishSession Method

STDMETHODIMP CPasswordMigration::EstablishSession(BSTR bstrSourceServer, BSTR bstrTargetServer)
{
    HRESULT hr = S_OK;

    USES_CONVERSION;

    LPCWSTR pszSourceServer = OLE2CW(bstrSourceServer);
    LPCWSTR pszTargetServer = OLE2CW(bstrTargetServer);

    ADMTTRACE(_T("E CPasswordMigration::EstablishSession(SourceServer='%s', TargetServer='%s')\n"), pszSourceServer, pszTargetServer);

    try
    {
        m_bSessionEstablished = false;

        CheckPasswordDC(pszSourceServer, pszTargetServer);

        m_bSessionEstablished = true;
    }
    catch (_com_error& ce)
    {
        hr = SetError(ce, IDS_E_CANNOT_ESTABLISH_SESSION);
    }
    catch (...)
    {
        hr = SetError(E_UNEXPECTED, IDS_E_CANNOT_ESTABLISH_SESSION);
    }

    ADMTTRACE(_T("L CPasswordMigration::EstablishSession() : %s 0x%08lX\n"), _com_error(hr).ErrorMessage(), hr);

    return hr;
}


// CopyPassword Method

STDMETHODIMP CPasswordMigration::CopyPassword(BSTR bstrSourceAccount, BSTR bstrTargetAccount, BSTR bstrTargetPassword)
{
    HRESULT hr = S_OK;

    USES_CONVERSION;

    LPCTSTR pszSourceAccount = OLE2CT(bstrSourceAccount);
    LPCTSTR pszTargetAccount = OLE2CT(bstrTargetAccount);
    LPCTSTR pszTargetPassword = OLE2CT(bstrTargetPassword);

    ADMTTRACE(_T("E CPasswordMigration::CopyPassword(SourceAccount='%s', TargetAccount='%s', TargetPassword='%s')\n"), pszSourceAccount, pszTargetAccount, pszTargetPassword);

    try
    {
        // if session established then...

        if (m_bSessionEstablished)
        {
            // copy password
            CopyPasswordImpl(pszSourceAccount, pszTargetAccount, pszTargetPassword);
        }
        else
        {
            // else return error
            ThrowError(PM_E_SESSION_NOT_ESTABLISHED, IDS_E_SESSION_NOT_ESTABLISHED);
        }
    }
    catch (_com_error& ce)
    {
        hr = SetError(ce, IDS_E_CANNOT_COPY_PASSWORD);
    }
    catch (...)
    {
        hr = SetError(E_UNEXPECTED, IDS_E_CANNOT_COPY_PASSWORD);
    }

    ADMTTRACE(_T("L CPasswordMigration::CopyPassword() : %s 0x%08lX\n"), _com_error(hr).ErrorMessage(), hr);

    return hr;
}


// GenerateKey Method

STDMETHODIMP CPasswordMigration::GenerateKey(BSTR bstrSourceDomainName, BSTR bstrKeyFilePath, BSTR bstrPassword)
{
    HRESULT hr = S_OK;

    USES_CONVERSION;

    LPCTSTR pszSourceDomainName = OLE2CT(bstrSourceDomainName);
    LPCTSTR pszKeyFilePath = OLE2CT(bstrKeyFilePath);
    LPCTSTR pszPassword = OLE2CT(bstrPassword);

    ADMTTRACE(_T("E CPasswordMigration::GenerateKey(SourceDomainName='%s', KeyFilePath='%s', Password='%s')\n"), pszSourceDomainName, pszKeyFilePath, pszPassword);

    try
    {
        //
        // Retrieve flat (NetBIOS) name of domain and use it for storing the key. The flat
        // name is used because the registry supports a maximum key name length of 256
        // Unicode characters. The combination of a DNS name and GUID string to uniquely
        // identify the key as belonging to this component could exceed this maximum length.
        //

        _bstr_t strFlatName;
        _bstr_t strDnsName;

        DWORD dwError = GetDomainNames5(pszSourceDomainName, strFlatName, strDnsName);

        if (dwError != ERROR_SUCCESS)
        {
            _com_issue_error(HRESULT_FROM_WIN32(dwError));
        }

        // The only reason the flat name would be empty at this point would be if
        // the _bstr_t object was unable to allocate the internal Data_t object.

        if (!strFlatName)
        {
            _com_issue_error(E_OUTOFMEMORY);
        }

        //
        // Generate key.
        //

        GenerateKeyImpl(strFlatName, pszKeyFilePath, pszPassword);
    }
    catch (_com_error& ce)
    {
        hr = SetError(ce, IDS_E_CANNOT_GENERATE_KEY);
    }
    catch (...)
    {
        hr = SetError(E_UNEXPECTED, IDS_E_CANNOT_GENERATE_KEY);
    }

    ADMTTRACE(_T("L CPasswordMigration::GenerateKey() : %s 0x%08lX\n"), _com_error(hr).ErrorMessage(), hr);

    return hr;
}


//
// Implementation -----------------------------------------------------------
//


// GenerateKeyImpl Method

void CPasswordMigration::GenerateKeyImpl(LPCTSTR pszDomain, LPCTSTR pszFile, LPCTSTR pszPassword)
{
	//
	// validate source domain name
	//

	if ((pszDomain == NULL) || (pszDomain[0] == NULL))
	{
		ThrowError(E_INVALIDARG, IDS_E_KEY_DOMAIN_NOT_SPECIFIED);
	}

	//
	// validate key file path
	//

	if ((pszFile == NULL) || (pszFile[0] == NULL))
	{
		ThrowError(E_INVALIDARG, IDS_E_KEY_FILE_NOT_SPECIFIED);
	}

	_TCHAR szDrive[_MAX_DRIVE];
	_TCHAR szExt[_MAX_EXT];

	_tsplitpath(pszFile, szDrive, NULL, NULL, szExt);

	// verify drive is a local drive

	_TCHAR szDrivePath[_MAX_PATH];
	_tmakepath(szDrivePath, szDrive, _T("\\"), NULL, NULL);

	if (GetDriveType(szDrivePath) == DRIVE_REMOTE)
	{
		ThrowError(E_INVALIDARG, IDS_E_KEY_FILE_NOT_LOCAL_DRIVE, pszFile);
	}

	// verify file extension is correct

	if (_tcsicmp(szExt, _T(".pes")) != 0)
	{
		ThrowError(E_INVALIDARG, IDS_E_KEY_FILE_EXTENSION_INVALID, szExt);
	}

	//
	// create encryption key and write to specified file
	//

	// create encryption key

	_variant_t vntKey;

    try
    {
	    CTargetCrypt crypt;

	    vntKey = crypt.CreateEncryptionKey(pszDomain, pszPassword);
    }
    catch (_com_error& ce)
    {
        //
        // The message 'keyset not defined' is returned when
        // the enhanced provider (128 bit) is not available
        // therefore return a more meaningful message to user.
        //

        if (ce.Error() == NTE_KEYSET_NOT_DEF)
        {
			ThrowError(ce, IDS_E_HIGH_ENCRYPTION_NOT_INSTALLED);
        }
        else
        {
		    throw;
        }
    }

	// write encrypted key bytes to file

	HANDLE hFile = CreateFile(pszFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		ThrowError(HRESULT_FROM_WIN32(GetLastError()), IDS_E_KEY_CANT_CREATE_FILE, pszFile);
	}

	DWORD dwWritten;

	BOOL bWritten = WriteFile(hFile, vntKey.parray->pvData, vntKey.parray->rgsabound[0].cElements, &dwWritten, NULL);

	CloseHandle(hFile);

	if (!bWritten)
	{
		ThrowError(HRESULT_FROM_WIN32(GetLastError()), IDS_E_KEY_CANT_WRITE_FILE, pszFile);
	}

	SecureZeroMemory(GET_BYTE_ARRAY_DATA(vntKey), GET_BYTE_ARRAY_SIZE(vntKey));
}


#pragma optimize ("", off)

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 15 DEC 2000                                                 *
 *                                                                   *
 *     This function is a wrapper around a password DC "CheckConfig" *
 * call that can be used by the GUI and scripting to test the given  *
 * DC.                                                               *
 *     First we connect to a remote Lsa notification package dll,    *
 * which should be installed on a DC in the source domain.  The      *
 * connect will be encrypted RPC.  The configuration check, which    *
 * establishes a temporary session for this check.                   *
 *     We will also check anonymous user right access on the target  *
 * domain.                                                           *
 *                                                                   *
 * 2001-04-19 Mark Oluper - updated for client component             *
 *********************************************************************/

//BEGIN CheckPasswordDC
void CPasswordMigration::CheckPasswordDC(LPCWSTR srcServer, LPCWSTR tgtServer)
{
    ADMTTRACE(_T("E CPasswordMigration::CheckPasswordDC(srcServer='%s', tgtServer='%s')\n"), srcServer, tgtServer);

/* local constants */
    const DWORD c_dwMinUC = 3;
    const DWORD c_dwMinLC = 3;
    const DWORD c_dwMinDigits = 3;
    const DWORD c_dwMinSpecial = 3;
    const DWORD c_dwMaxAlpha = 0;
    const DWORD c_dwMinLen = 14;

/* local variables */
    DWORD                     rc = 0;
    WCHAR                     testPwd[PASSWORD_BUFFER_SIZE];
    WCHAR                     tempPwd[PASSWORD_BUFFER_SIZE];
    _variant_t               varSession;
    _variant_t               varTestPwd;

/* function body */
//  USES_CONVERSION;

    if ((srcServer == NULL) || (srcServer[0] == NULL))
    {
        ThrowError(E_INVALIDARG, IDS_E_SOURCE_SERVER_NOT_SPECIFIED);
    }

    if ((tgtServer == NULL) || (tgtServer[0] == NULL))
    {
        ThrowError(E_INVALIDARG, IDS_E_TARGET_SERVER_NOT_SPECIFIED);
    }

      //make sure the server names start with "\\"
    if ((srcServer[0] != L'\\') && (srcServer[1] != L'\\'))
    {
        m_strSourceServer = L"\\\\";
        m_strSourceServer += srcServer;
    }
    else
        m_strSourceServer = srcServer;
    if ((tgtServer[0] != L'\\') && (tgtServer[1] != L'\\'))
    {
        m_strTargetServer = L"\\\\";
        m_strTargetServer += tgtServer;
    }
    else
        m_strTargetServer = tgtServer;

    //get the password DC's domain NETBIOS name
    GetDomainName(m_strSourceServer, m_strSourceDomainDNS, m_strSourceDomainFlat);

    //get the target DC's domain DNS name
    GetDomainName(m_strTargetServer, m_strTargetDomainDNS, m_strTargetDomainFlat);

    //
    // Verify that target domain allows anonymous access.
    //
    // Windows 2000 Server
    // 'Everyone' must be a member of the 'Pre-Windows 2000 Compatible Access' group.
    //
    // Windows Server
    // 'Everyone' must be a member of the 'Pre-Windows 2000 Compatible Access' group
    // and either 'Anonymous Logon' must be a member of this group or the
    // 'Network access: Let everyone permissions apply to anonymous users' must be
    // enabled in the 'Security Options' for domain controllers.
    //

    bool bEveryoneIsMember;
    bool bAnonymousIsMember;

    CheckPreWindows2000CompatibleAccessGroupMembers(bEveryoneIsMember, bAnonymousIsMember);

    if (bEveryoneIsMember == false)
    {
        ThrowError(
            __uuidof(PasswordMigration),
            __uuidof(IPasswordMigration),
            PM_E_EVERYONE_NOT_MEMBEROF_COMPATIBILITY_GROUP,
            IDS_E_EVERYONE_NOT_MEMBEROF_GROUP,
            (LPCTSTR)m_strTargetDomainDNS
        );
    }

    if (!bAnonymousIsMember && !DoesAnonymousHaveEveryoneAccess(m_strTargetServer))
    {
        ThrowError(
            __uuidof(PasswordMigration),
            __uuidof(IPasswordMigration),
            PM_E_EVERYONE_DOES_NOT_INCLUDE_ANONYMOUS,
            IDS_E_EVERYONE_DOES_NOT_INCLUDE_ANONYMOUS,
            (LPCTSTR)m_strTargetDomainDNS
        );
    }

    //if the high encryption pack has not been installed on this target
    //DC, then return that information
    try
    {
        if (m_pTargetCrypt == NULL)
        {
            m_pTargetCrypt = new CTargetCrypt;
        }
    }
    catch (_com_error& ce)
    {
        if (ce.Error() == 0x80090019)
            ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_HIGH_ENCRYPTION_NOT_INSTALLED, IDS_E_HIGH_ENCRYPTION_NOT_INSTALLED);
        else
            throw;
    }

    //
    // Note that PwdBindCreate will destroy the binding if m_hBinding is non-NULL.
    //

    rc = PwdBindCreate(m_strSourceServer, &m_hBinding, &m_sBinding, TRUE);

    if(rc != ERROR_SUCCESS)
    {
        _com_issue_error(HRESULT_FROM_WIN32(rc));
    }

    try
    {
        try
        {
            //create a session key that will be used to encrypt the user's
            //password for this set of accounts
            varSession = m_pTargetCrypt->CreateSession(m_strSourceDomainFlat);
        }
        catch (_com_error& ce)
        {
            if (ce.Error() == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_NO_ENCRYPTION_KEY_FOR_DOMAIN, IDS_E_NO_ENCRYPTION_KEY_FOR_DOMAIN, (LPCTSTR)m_strSourceDomainFlat);
            }
            else
            {
                ThrowError(ce, IDS_E_GENERATE_SESSION_KEY_FAILED);
            }
        }

        //now create a complex password used by the "CheckConfig" call in
        //a challenge response.  If the returned password matches, then
        //the source DC has the proper encryption key.
        if (EaPasswordGenerate(c_dwMinUC, c_dwMinLC, c_dwMinDigits, c_dwMinSpecial, c_dwMaxAlpha, c_dwMinLen, testPwd, PASSWORD_BUFFER_SIZE))
        {
            ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_GENERATE_SESSION_PASSWORD_FAILED, IDS_E_GENERATE_SESSION_PASSWORD_FAILED);
        }

        //encrypt the password with the session key
        try
        {
            varTestPwd = m_pTargetCrypt->Encrypt(_bstr_t(testPwd));
        }
        catch (...)
        {
            ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_GENERATE_SESSION_PASSWORD_FAILED, IDS_E_GENERATE_SESSION_PASSWORD_FAILED);
        }

        _se_translator_function pfnSeTranslatorOld = _set_se_translator((_se_translator_function)SeTranslator);

        HRESULT hr;

        try
        {
            //check to see if the server-side DLL is ready to process
            //password migration requests
            hr = PwdcCheckConfig(
                m_hBinding,
                GET_BYTE_ARRAY_SIZE(varSession),
                GET_BYTE_ARRAY_DATA(varSession),
                GET_BYTE_ARRAY_SIZE(varTestPwd),
                GET_BYTE_ARRAY_DATA(varTestPwd),
                tempPwd
            );
        }
        catch (SSeException& e)
        {
            if (e.uCode == RPC_S_SERVER_UNAVAILABLE)
                ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_PASSWORD_MIGRATION_NOT_RUNNING, IDS_E_PASSWORD_MIGRATION_NOT_RUNNING);
            else
                _com_issue_error(HRESULT_FROM_WIN32(e.uCode));
        }

        _set_se_translator(pfnSeTranslatorOld);

        if (SUCCEEDED(hr))
        {
            if (UStrICmp(tempPwd,testPwd))
                ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_ENCRYPTION_KEYS_DO_NOT_MATCH, IDS_E_ENCRYPTION_KEYS_DO_NOT_MATCH);
        }
        else if (hr == PM_E_PASSWORD_MIGRATION_NOT_ENABLED)
        {
            ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_PASSWORD_MIGRATION_NOT_ENABLED, IDS_E_PASSWORD_MIGRATION_NOT_ENABLED);
        }
        else if ((m_strSourceDomainDNS.length() == 0) && ((hr == NTE_FAIL) || (hr == NTE_BAD_DATA)))
        {
            //
            // This case is only applicable for NT4.
            //
            ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), hr, IDS_E_ENCRYPTION_KEYS_DO_NOT_MATCH);
        }
        else
        {
            _com_issue_error(hr);
        }
    }
    catch (...)
    {
        PwdBindDestroy(&m_hBinding, &m_sBinding);
        throw;
    }

    SecureZeroMemory(GET_BYTE_ARRAY_DATA(varSession), GET_BYTE_ARRAY_SIZE(varSession));

    ADMTTRACE(_T("L CPasswordMigration::CheckPasswordDC()\n"));
}
//END CheckPasswordDC

#pragma optimize ("", on)


//---------------------------------------------------------------------------
// CopyPassword Method
//
// Copies password via password migration server component installed on a
// password export server.
//
// 2001-04-19 Mark Oluper - re-wrote original written by Paul Thompson to
// incorporate changes required for client component
//---------------------------------------------------------------------------

void CPasswordMigration::CopyPasswordImpl(LPCTSTR pszSourceAccount, LPCTSTR pszTargetAccount, LPCTSTR pszPassword)
{
    ADMTTRACE(_T("E CPasswordMigration::CopyPasswordImpl(SourceAccount='%s', TargetAccount='%s', Password='%s')\n"), pszSourceAccount, pszTargetAccount, pszPassword);

    if ((pszSourceAccount == NULL) || (pszSourceAccount[0] == NULL))
    {
        ThrowError(E_INVALIDARG, IDS_E_SOURCE_ACCOUNT_NOT_SPECIFIED);
    }

    if ((pszTargetAccount == NULL) || (pszTargetAccount[0] == NULL))
    {
        ThrowError(E_INVALIDARG, IDS_E_TARGET_ACCOUNT_NOT_SPECIFIED);
    }

    // encrypt password

    _variant_t vntEncryptedPassword = m_pTargetCrypt->Encrypt(pszPassword);

    // copy password

    HRESULT hr = PwdcCopyPassword(
        m_hBinding,
        m_strTargetServer,
        pszSourceAccount,
        pszTargetAccount,
        GET_BYTE_ARRAY_SIZE(vntEncryptedPassword),
        GET_BYTE_ARRAY_DATA(vntEncryptedPassword)
    );

    SecureZeroMemory(GET_BYTE_ARRAY_DATA(vntEncryptedPassword), GET_BYTE_ARRAY_SIZE(vntEncryptedPassword));

    if (FAILED(hr))
    {
        _com_issue_error(hr);
    }

    ADMTTRACE(_T("L CPasswordMigration::CopyPasswordImpl()\n"));
}


//---------------------------------------------------------------------------
// GetDomainName Function
//
// Retrieves both the domain DNS name if available and the domain flat or
// NetBIOS name for the specified server.
//
// 2001-04-19 Mark Oluper - initial
//---------------------------------------------------------------------------

void CPasswordMigration::GetDomainName(LPCTSTR pszServer, _bstr_t& strNameDNS, _bstr_t& strNameFlat)
{
    ADMTTRACE(_T("E CPasswordMigration::GetDomainName(Server='%s', ...)\n"), pszServer);

    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC ppdib;

    DWORD dwError = DsRoleGetPrimaryDomainInformation(pszServer, DsRolePrimaryDomainInfoBasic, (BYTE**)&ppdib);

    if (dwError != NO_ERROR)
    {
        ThrowError(HRESULT_FROM_WIN32(dwError), IDS_E_CANNOT_GET_DOMAIN_NAME, pszServer);
    }

    strNameDNS = ppdib->DomainNameDns;
    strNameFlat = ppdib->DomainNameFlat;

    DsRoleFreeMemory(ppdib);

    ADMTTRACE(_T("L CPasswordMigration::GetDomainName(..., NameDNS='%s', NameFlat='%s')\n"), (LPCTSTR)strNameDNS, (LPCTSTR)strNameFlat);
}


//---------------------------------------------------------------------------
// CheckPreWindows2000CompatibleAccessGroupMembers Method
//
// Synopsis
// Checks if Everyone and Anonymous Logon are members of the Pre-Windows
// 2000 Compatible Access group.
//
// Arguments
// OUT bEveryone  - set to true if Everyone is a member
// OUT bAnonymous - set to true if Anonymous Logon is a member
//---------------------------------------------------------------------------

void CPasswordMigration::CheckPreWindows2000CompatibleAccessGroupMembers(bool& bEveryone, bool& bAnonymous)
{
    //
    // Initialize return values.
    //

    bEveryone = false;
    bAnonymous = false;

    //
    // Generate ADsPath to built-in Pre-Windows 2000 Compatible Access group.
    //
    // Note that the GetPathToPreW2KCAGroup function returns partial DN with trailing comma.
    //

    _bstr_t strGroupPath;
    strGroupPath = _T("LDAP://");
    strGroupPath += m_strTargetDomainDNS;
    strGroupPath += _T("/");
    strGroupPath += GetPathToPreW2KCAGroup();
    strGroupPath += GetDefaultNamingContext(m_strTargetDomainDNS);

    //
    // Bind to the enumerator of the members interface
    // of the Pre-Windows 2000 Compatible Access group.
    //

    IADsGroupPtr spGroup;
    CheckError(ADsGetObject(strGroupPath, IID_IADsGroup, (VOID**)&spGroup));

    IADsMembersPtr spMembers;
    CheckError(spGroup->Members(&spMembers));

    IUnknownPtr spunkEnum;
    CheckError(spMembers->get__NewEnum(&spunkEnum));
    IEnumVARIANTPtr spEnum(spunkEnum);

    //
    // Initialize variables used to retrieve SID of each member.
    //

    VARIANT varMember;
    VariantInit(&varMember);
    ULONG ulFetched;
    PWSTR pszAttrs[] = { L"objectSid" };
    VARIANT varAttrs;
    VariantInit(&varAttrs);
    CheckError(ADsBuildVarArrayStr(pszAttrs, sizeof(pszAttrs) / sizeof(pszAttrs[0]), &varAttrs));
    _variant_t vntAttrs(varAttrs, false);
    VARIANT varObjectSid;
    VariantInit(&varObjectSid);

    //
    // Generate well known Everyone and Anonymous Logon SIDs.
    //

    SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaNT = SECURITY_NT_AUTHORITY;

    PSID pEveryoneSid = NULL;
    AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pEveryoneSid);

    PSID pAnonymousSid = NULL;
    AllocateAndInitializeSid(&siaNT, 1, SECURITY_ANONYMOUS_LOGON_RID, 0, 0, 0, 0, 0, 0, 0, &pAnonymousSid);

    if ((pEveryoneSid == NULL) || (pAnonymousSid == NULL))
    {
        if (pAnonymousSid)
        {
            FreeSid(pAnonymousSid);
        }

        if (pEveryoneSid)
        {
            FreeSid(pEveryoneSid);
        }

        _com_issue_error(E_OUTOFMEMORY);
    }

    //
    // Enumerate members...if Everyone or Anonymous Logon
    // is a member then set corresponding parameter to true.
    //

    try
    {
        while ((spEnum->Next(1ul, &varMember, &ulFetched) == S_OK) && (ulFetched == 1ul))
        {
            IADsPtr spMember(IDispatchPtr(_variant_t(varMember, false)));
            CheckError(spMember->GetInfoEx(vntAttrs, 0));
            CheckError(spMember->Get(pszAttrs[0], &varObjectSid));

            if (V_VT(&varObjectSid) == (VT_ARRAY|VT_UI1))
            {
                PSID pSid = (PSID) GET_BYTE_ARRAY_DATA(varObjectSid);

                if (pSid && IsValidSid(pSid))
                {
                    if (EqualSid(pSid, pEveryoneSid))
                    {
                        bEveryone = true;
                    }
                    else if (EqualSid(pSid, pAnonymousSid))
                    {
                        bAnonymous = true;
                    }
                }
            }

            VariantClear(&varObjectSid);

            if (bEveryone && bAnonymous)
            {
                break;
            }
        }
    }
    catch (...)
    {
        FreeSid(pAnonymousSid);
        FreeSid(pEveryoneSid);

        throw;
    }

    FreeSid(pAnonymousSid);
    FreeSid(pEveryoneSid);
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 12 APR 2001                                                 *
 *                                                                   *
 *     This function is responsible for creating a path to the       *
 * "Pre-Windows 2000 Compatible Access" builtin group from its well- *
 * known RID.  This path will then be used by                        *
 * "IsEveryoneInPW2KCAGroup" to see if "Everyone" is in that group.  *
 *                                                                   *
 * 2001-12-09 moluper - updated to return default path instead of    *
 *                      empty path                                   *
 *********************************************************************/

//BEGIN GetPathToPreW2KCAGroup
_bstr_t CPasswordMigration::GetPathToPreW2KCAGroup()
{
/* local constants */
   const _TCHAR BUILTIN_RDN[] = _T(",CN=Builtin,");
   const _TCHAR PRE_WINDOWS_2000_COMPATIBLE_ACCESS_RDN[] = _T("CN=Pre-Windows 2000 Compatible Access");

/* local variables */
   SID_IDENTIFIER_AUTHORITY  siaNtAuthority = SECURITY_NT_AUTHORITY;
   PSID                      psidPreW2KCAGroup;
   _bstr_t					 sPath = _bstr_t(PRE_WINDOWS_2000_COMPATIBLE_ACCESS_RDN) + BUILTIN_RDN;
   WCHAR                     account[MAX_PATH];
   WCHAR                     domain[MAX_PATH];
   DWORD                     lenAccount = MAX_PATH;
   DWORD                     lenDomain = MAX_PATH;
   SID_NAME_USE              snu;

/* function body */
      //create the SID for the "Pre-Windows 2000 Compatible Access" group
   if (!AllocateAndInitializeSid(&siaNtAuthority,
								 2,
								 SECURITY_BUILTIN_DOMAIN_RID,
								 DOMAIN_ALIAS_RID_PREW2KCOMPACCESS,
								 0, 0, 0, 0, 0, 0,
								 &psidPreW2KCAGroup))
      return sPath;

      //lookup the name attached to this SID
   if (!LookupAccountSid(NULL, psidPreW2KCAGroup, account, &lenAccount, domain, &lenDomain, &snu))
      return sPath;

   sPath = _bstr_t(L"CN=") + _bstr_t(account) + _bstr_t(BUILTIN_RDN);
   FreeSid(psidPreW2KCAGroup); //free the SID

   return sPath;
}
//END GetPathToPreW2KCAGroup


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 6 APR 2001                                                  *
 *                                                                   *
 *     This function is responsible for checking if anonymous user   *
 * has been granted Everyone access if the target domain is Whistler *
 * or newer.  This function is a helper function for                 *
 * "CheckPasswordDC".                                                *
 *     If the "Let Everyone permissions apply to anonymous users"    *
 * security option has been enabled, then the LSA registry value of  *
 * "everyoneincludesanonymous" will be set to 0x1.  We will check    *
 * registry value.                                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN DoesAnonymousHaveEveryoneAccess
BOOL CPasswordMigration::DoesAnonymousHaveEveryoneAccess(LPCWSTR tgtServer)
{
/* local constants */
   const int	WINDOWS_2000_BUILD_NUMBER = 2195;

/* local variables */
   TRegKey		verKey, lsaKey, regComputer;
   BOOL			bAccess = TRUE;
   DWORD		rc = 0;
   DWORD		rval;
   WCHAR		sBuildNum[MAX_PATH];

/* function body */
	  //connect to the DC's HKLM registry key
   rc = regComputer.Connect(HKEY_LOCAL_MACHINE, tgtServer);
   if (rc == ERROR_SUCCESS)
   {
         //see if this machine is running Windows XP or newer by checking the
		 //build number in the registry.  If not, then we don't need to check
		 //for the new security option
      rc = verKey.OpenRead(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",&regComputer);
	  if (rc == ERROR_SUCCESS)
	  {
			//get the CurrentBuildNumber string
	     rc = verKey.ValueGetStr(L"CurrentBuildNumber", sBuildNum, MAX_PATH);
		 if (rc == ERROR_SUCCESS) 
		 {
			int nBuild = _wtoi(sBuildNum);
		    if (nBuild <= WINDOWS_2000_BUILD_NUMBER)
               return bAccess;
		 }
	  }
		 
	     //if Windows XP or greater, check for the option being enabled
	     //open the LSA key
      rc = lsaKey.OpenRead(L"System\\CurrentControlSet\\Control\\Lsa",&regComputer);
	  if (rc == ERROR_SUCCESS)
	  {
			//get the value of the "everyoneincludesanonymous" value
	     rc = lsaKey.ValueGetDWORD(L"everyoneincludesanonymous",&rval);
		 if (rc == ERROR_SUCCESS) 
		 {
		    if (rval == 0)
               bAccess = FALSE;
		 }
		 else
            bAccess = FALSE;
	  }
   }
   return bAccess;
}
//END DoesAnonymousHaveEveryoneAccess


//---------------------------------------------------------------------------
// GetDefaultNamingContext Method
//
// Synopsis
// Retrieves the default naming context for the specified domain.
//
// Arguments
// IN strDomain - name of domain
//
// Return
// Default naming context for specified domain.
//---------------------------------------------------------------------------

_bstr_t CPasswordMigration::GetDefaultNamingContext(_bstr_t strDomain)
{
    _bstr_t strDefaultNamingContext;

    //
    // Bind to rootDSE of specified domain and
    // retrieve default naming context.
    //

    IADsPtr spRootDse;
    _bstr_t strPath = _T("LDAP://") + strDomain + _T("/rootDSE");
    HRESULT hr = ADsGetObject(strPath, IID_IADs, (VOID**)&spRootDse);

    if (SUCCEEDED(hr))
    {
        VARIANT var;
        VariantInit(&var);
        hr = spRootDse->Get(_T("defaultNamingContext"), &var);

        if (SUCCEEDED(hr))
        {
            strDefaultNamingContext = _variant_t(var, false);
        }
    }

    return strDefaultNamingContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\mspwdmig\stdafx.h ===
#pragma once

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <ComDef.h>

//{{AFX_INSERT_LOCATION}}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\attrnode.h ===
/*---------------------------------------------------------------------------
  File: TAttrNode.h

  Comments: interface for the TAttrNode class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#if !defined(AFX_TATTRNODE_H__BE06D000_268B_11D3_8C89_0090270D48D1__INCLUDED_)
#define AFX_TATTRNODE_H__BE06D000_268B_11D3_8C89_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "TNode.hpp"

class TAttrNode : public TNode  
{
public:
	HRESULT Add( long nOrigCol, long nCol, _variant_t val[]);
	TAttrNode(long nCnt, _variant_t val[]);
	virtual ~TAttrNode();

	_variant_t m_Val;
private:
   long * m_nElts;
};

#endif // !defined(AFX_TATTRNODE_H__BE06D000_268B_11D3_8C89_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\attrnode.cpp ===
/*---------------------------------------------------------------------------
  File: TAttrNode.cpp

  Comments: implementation of the TAttrNode class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/
#include "stdafx.h"
#include "AttrNode.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

TAttrNode::TAttrNode(
                        long nCnt,              //in -Number of columns to set
                        _variant_t val[]        //in -Array of column values
                        )
{
   SAFEARRAY               * pArray;
   SAFEARRAYBOUND            bd = { nCnt, 0 };
   _variant_t        HUGEP * pData;

   pArray = ::SafeArrayCreate(VT_VARIANT, 1, &bd);
   ::SafeArrayAccessData(pArray, (void**)&pData);
   
   for ( long i = 0; i < nCnt; i++ )
      pData[i] = val[i];

   ::SafeArrayUnaccessData(pArray);
   m_Val.vt = VT_ARRAY | VT_VARIANT;
   m_Val.parray = pArray;

   m_nElts = new long[nCnt];
   if (!m_nElts)
      return;
   for (int ndx = 0; ndx < nCnt; ndx++)
   {
      m_nElts[ndx] = 0;
   }
}

TAttrNode::~TAttrNode()
{
   if (m_nElts)
      delete [] m_nElts;
}

HRESULT TAttrNode::Add(long nOrigCol, long nCol, _variant_t val[])
{
   if (!m_nElts)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   SAFEARRAY               * pArray = NULL;
   SAFEARRAYBOUND            bd = { m_nElts[nOrigCol], 0 };
   _variant_t        HUGEP * pData;
   HRESULT                   hr;
   SAFEARRAY               * pVars;
   SAFEARRAY               * psaTemp;
   _variant_t        HUGEP * pTemp;
   long						 nCnt;
   pVars = m_Val.parray;
   
   hr = ::SafeArrayAccessData(pVars, (void HUGEP **) &pData);
   if(SUCCEEDED(hr) )
   {
      if ( pData->vt & VT_ARRAY )
         pArray = pData[nOrigCol].parray;
      else
         hr = E_INVALIDARG;
   }

   if(SUCCEEDED(hr) )
      hr = ::SafeArrayUnaccessData(pVars);

   if ( SUCCEEDED(hr) )
   {
      if ( val[nCol].vt & VT_ARRAY )
      {
         // Get the current number of elts
         m_nElts[nOrigCol] = pArray->rgsabound->cElements;
         // Get the number of new elts
         nCnt = val[nCol].parray->rgsabound->cElements;
         // Get the array to transfer data.
         psaTemp = val[nCol].parray;

         // Extend the array to support the new values.
         bd.cElements = m_nElts[nOrigCol] + nCnt;
         hr = ::SafeArrayRedim(pArray, &bd);

         if ( SUCCEEDED(hr) )
            hr = ::SafeArrayAccessData(pArray, (void HUGEP **)&pData);
   
         if ( SUCCEEDED(hr) )
		 {
            hr = ::SafeArrayAccessData(psaTemp, (void HUGEP **)&pTemp);

            if ( SUCCEEDED(hr) )
			{
               for ( long i = m_nElts[nOrigCol]; i < m_nElts[nOrigCol] + nCnt; i++ )
                  pData[i] = pTemp[i - m_nElts[nOrigCol]];

               hr = ::SafeArrayUnaccessData(psaTemp);
			}
            hr = ::SafeArrayUnaccessData(pArray);
         }
      }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\domain.h ===
/*---------------------------------------------------------------------------
  File: Domain.h

  Comments: interface for the CDomain abstract class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/
#if !defined(AFX_DOMAIN_H__B310F880_19F9_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_DOMAIN_H__B310F880_19F9_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CDomain  
{
public:
   CDomain() {}
   virtual ~CDomain() {}
   
   //All our interfaces. These are implemented by the individual objects depending on NT4.0 v/s Win2000 domains.
   virtual HRESULT  GetEnumeration(BSTR sContainerName, BSTR sDomainName, BSTR m_sQuery, long attrCnt, LPWSTR * sAttr, ADS_SEARCHPREF_INFO prefInfo,BOOL  bMultiVal,IEnumVARIANT **& pVarEnum) = 0;
};

#endif // !defined(AFX_DOMAIN_H__B310F880_19F9_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\netnode.h ===
/*---------------------------------------------------------------------------
  File: TNetObjNode.h

  Comments: interface for the TNetObjNode class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#if !defined(AFX_TNETOBJNODE_H__3D7EBCD0_1AB6_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_TNETOBJNODE_H__3D7EBCD0_1AB6_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "TNode.hpp"

class TNetObjNode : public TNode  
{
public:
	TNetObjNode();
	virtual ~TNetObjNode();
   WCHAR        m_strObjName[255];
};

#endif // !defined(AFX_TNETOBJNODE_H__3D7EBCD0_1AB6_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\netnode.cpp ===
/*---------------------------------------------------------------------------
  File: TNetObjNode.cpp

  Comments: implementation of the TNetObjNode class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "NetNode.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

TNetObjNode::TNetObjNode()
{

}

TNetObjNode::~TNetObjNode()
{
   ::SysFreeString(m_strObjName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\netobjen.cpp ===
/*---------------------------------------------------------------------------
  File: MCSNetObjectEnum.cpp

  Comments: Implementation of DLL Exports.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f MCSNetObjectEnumps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "NetEnum.h"

#include "NetEnum_i.c"
#include "ObjEnum.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_NetObjEnumerator, CNetObjEnumerator)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        ATLTRACE(_T("{MCSNetObjectEnum.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_MCSNETOBJECTENUMLib);
        DisableThreadLibraryCalls(hInstance);
        _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
        ATLTRACE(_T("{MCSNetObjectEnum.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\nt4dom.cpp ===
/*---------------------------------------------------------------------------
  File: NT4Dom.cpp

  Comments: Implementation of NT4 object enumeration. This object enumerates
            members in USERS,GROUPS,COMPUTERS container for NT4 domain. It
            returns a fixed set of columns. For more information please refer
            to the code below.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "TNode.hpp"
#include "NetNode.h"
#include "AttrNode.h"
#include <lm.h>
#include "NT4Dom.h"
#include "NT4Enum.h"
#include "GetDcName.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

#define     MAX_BUF     100
#define     LEN_Path    255
CNT4Dom::CNT4Dom()
{

}

CNT4Dom::~CNT4Dom()
{
	mDCMap.clear();
}

bool GetSamNameFromInfo( WCHAR * sInfo, WCHAR * sDomain, WCHAR * sName)
{
   WCHAR domain[LEN_Path];
   DWORD dwArraySizeOfDomain = sizeof(domain)/sizeof(domain[0]);
   WCHAR * temp;
   bool rc = false;

   if (sInfo == NULL || wcslen(sInfo) >= dwArraySizeOfDomain)
      return rc;
   wcscpy(domain, sInfo);
   temp = wcschr(domain, L'\\');
   if ( temp )
   {
      *temp = 0;
      if (!_wcsicmp(domain, sDomain) || !wcsncmp(sDomain, L"\\\\", 2))
      {
         rc = true;
         wcscpy(sName, ++temp);
      }
   }
   return rc;
}

//-----------------------------------------------------------------------------
// GetEnumeration: This function Enumerates all objects in the above specified
//                 containers and their 6 standard values which are
//                 'name,comment,user/groupID,flags,FullName,description'
//-----------------------------------------------------------------------------
HRESULT  CNT4Dom::GetEnumeration(
                                    BSTR sContainerName,             //in -Container path
                                    BSTR sDomainName,                //in -Domain name
                                    BSTR m_sQuery,                   //in -IGNORED...
                                    long attrCnt,                    //in -IGNORED...
                                    LPWSTR * sAttr,                  //in -IGNORED...
                                    ADS_SEARCHPREF_INFO prefInfo,    //in -IGNORED...
                                    BOOL  bMultiVal,                 //in -IGNORED...
                                    IEnumVARIANT **& pVarEnum        //out -Pointer to the enumeration object
                                )
{
   // From the full LDAP path truncate to appropriate LDAP subpath
   // This function enumerates four types of containers
   // USERS, COMPUTERS, GROUPS, DOMAIN CONTROLLERS
   // if the container parameter specifies anything other than the three containers then
   // we returns UNEXPECTED.

   DWORD                  ulCount = 0;
   DWORD                  rc=0; 
   DWORD                  ndx = 0;
   TNodeList            * pNodeList = new TNodeList();
   WCHAR                  sServerName[LEN_Path];
   
   if (!pNodeList)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   if ( wcsncmp((WCHAR*)sDomainName, L"\\\\", 2) )
   {
      _bstr_t sDC = GetDC(sDomainName);
	  wcscpy(sServerName, (WCHAR*)sDC);
   }
   else
      wcscpy((WCHAR*)sServerName, (WCHAR*) sDomainName);

   if ( ! rc )
   {
      for (UINT i = 0; i < wcslen(sContainerName); i++)
         sContainerName[i] = towupper(sContainerName[i]);

      if ( wcscmp(sContainerName,L"CN=USERS") &&
           wcscmp(sContainerName,L"CN=COMPUTERS") &&
           wcscmp(sContainerName,L"CN=GROUPS") &&
           wcscmp(sContainerName,L"CN=DOMAIN CONTROLLERS") )
      {
         // if they selected a group we enumerate the membership of that group.
         WCHAR * sTemp = wcstok( sContainerName, L",");
         WCHAR * ndx = wcstok( NULL, L",");

         if ((!ndx) || ( ndx && _wcsicmp(ndx, L"CN=GROUPS") ))
		 {
			delete pNodeList;
            return E_UNEXPECTED;
		 }
         else
         {
            // Get the members of the group and add them to the List,
            GROUP_USERS_INFO_0            * pbufNetUser;
//            DWORD                           resume=0, total=0;
            DWORD                           total=0;
            DWORD_PTR                       resume=0;
            // Get the first set of Members from the Group
            rc = NetGroupGetUsers((WCHAR*) sServerName, sTemp, 0, (LPBYTE*) &pbufNetUser, sizeof(GROUP_USERS_INFO_0) * MAX_BUF, &ulCount, &total, &resume);
            if ((rc != ERROR_SUCCESS) && (rc != NERR_GroupNotFound) && (rc != ERROR_MORE_DATA))
            {
               delete pNodeList;
               return HRESULT_FROM_WIN32(rc);
            }

            while ( ulCount > 0 )
            {
               // For each user construnct the array of the properties that they asked for. Then construct a node of that
               // array and stuff that into the List.
               for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
               {
                  _variant_t varArr[6] = { pbufNetUser[dwIdx].grui0_name, (long)0, (long)0, (long)0, (long)0, (long)0 } ;
                  TAttrNode * pNode = new TAttrNode(6, varArr);
			      if (!pNode)
				  {
				     delete pNodeList;
                     NetApiBufferFree(pbufNetUser);
			         return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				  }
                  pNodeList->InsertBottom(pNode);
               }
               NetApiBufferFree(pbufNetUser);
               // Get the next set of objects
               if ( rc == ERROR_MORE_DATA ) 
               {
                  rc = NetGroupGetUsers((WCHAR*) sServerName, sTemp, 0, (LPBYTE*) &pbufNetUser, sizeof(GROUP_USERS_INFO_0) * MAX_BUF, &ulCount, &total, &resume);
                  if ((rc != ERROR_SUCCESS) && (rc != NERR_GroupNotFound) && (rc != ERROR_MORE_DATA))
                  {
                     delete pNodeList;
                     return HRESULT_FROM_WIN32(rc);
                  }
               }
               else
                  ulCount = 0;
            }
            // Get the members of the local group and add them to the List,
            LOCALGROUP_MEMBERS_INFO_3     * pbufNetInfo;
            resume=0;
            total=0;
            WCHAR                           sTempName[LEN_Path];
            WCHAR                           sName[LEN_Path];
            // Get the first set of Members from the Group
            rc = NetLocalGroupGetMembers((WCHAR*) sServerName, sTemp, 3, (LPBYTE*) &pbufNetInfo, sizeof(LOCALGROUP_MEMBERS_INFO_3) * MAX_BUF, &ulCount, &total, &resume);
            if ((rc != ERROR_SUCCESS) && (rc != ERROR_NO_SUCH_ALIAS) && (rc != ERROR_MORE_DATA))
            {
               delete pNodeList;
               return HRESULT_FROM_WIN32(rc);
            }
            
            while ( ulCount > 0 )
            {
               // For each user create a node set the value of the node to the object name and add it to the list.
               for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
               {
                  wcscpy(sTempName, pbufNetInfo[dwIdx].lgrmi3_domainandname);
                  if (GetSamNameFromInfo(sTempName, (WCHAR*)sDomainName, sName))
                  {
                     _variant_t varArr[6] = { sName, (long)0, (long)0, (long)0, (long)0, (long)0 } ;
                     TAttrNode * pNode = new TAttrNode(6, varArr);
			         if (!pNode)
					 {
				        delete pNodeList;
                        NetApiBufferFree(pbufNetInfo);
			            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
					 }
                     pNodeList->InsertBottom(pNode);
                  }  
               }
               NetApiBufferFree(pbufNetInfo);
               // Get the next set of objects
               if ( rc == ERROR_MORE_DATA )
               {
                  rc = NetLocalGroupGetMembers((WCHAR*) sServerName, sTemp, 3, (LPBYTE*) &pbufNetInfo, sizeof(LOCALGROUP_MEMBERS_INFO_3) * MAX_BUF, &ulCount, &total, &resume);
                  if ((rc != ERROR_SUCCESS) && (rc != ERROR_NO_SUCH_ALIAS) && (rc != ERROR_MORE_DATA))
                  {
                     delete pNodeList;
                     return HRESULT_FROM_WIN32(rc);
                  }

               }
               else
                  ulCount = 0;
            }
         }
      }

      if (!wcscmp(sContainerName,L"CN=USERS"))
      {
         // Build User enumeration
         NET_DISPLAY_USER           * pbufNetUser;
      
         // Get the first set of users from the domain
         rc = NetQueryDisplayInformation((WCHAR *)sServerName, 1, ndx, MAX_BUF, sizeof(NET_DISPLAY_USER) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
         if ((rc != ERROR_SUCCESS) && (rc != ERROR_MORE_DATA))
         {
            delete pNodeList;
            return HRESULT_FROM_WIN32(rc);
         }
            
         while ( ulCount > 0 )
         {
            // For each user create a node set the value of the node to the object name and add it to the list.
            TAttrNode         * pNode;
            for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
            {
               {
                  _variant_t val[6] = { pbufNetUser[dwIdx].usri1_name,
                                     pbufNetUser[dwIdx].usri1_comment,
                                     (long)0,
                                     (long)0,
                                     pbufNetUser[dwIdx].usri1_full_name,
                                     L"" };
                  val[2].vt = VT_UI4;
                  val[2].ulVal = pbufNetUser[dwIdx].usri1_user_id;

                  val[3].vt = VT_UI4;
                  val[3].ulVal = pbufNetUser[dwIdx].usri1_flags;

                     
                  pNode = new TAttrNode(6, val);
			      if (!pNode)
				  {
				     delete pNodeList;
                     NetApiBufferFree(pbufNetUser);
			         return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				  }
               }
               pNodeList->InsertBottom(pNode);
            }

            // Set the index for next set of users.
            if ( ulCount > 0 )
               ndx = pbufNetUser[ulCount-1].usri1_next_index;
            
            NetApiBufferFree(pbufNetUser);
            // Get the next set of objects
            if ( rc == ERROR_MORE_DATA )
            {

               rc = NetQueryDisplayInformation((WCHAR *)sServerName, 1, ndx, MAX_BUF, sizeof(NET_DISPLAY_USER) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
               if ((rc != ERROR_SUCCESS) && (rc != ERROR_MORE_DATA))
               {
                  delete pNodeList;
                  return HRESULT_FROM_WIN32(rc);
               }
            }
            else
               ulCount = 0;
         }
      }
 
      else if (!wcscmp(sContainerName,L"CN=COMPUTERS"))
      {
         // Build Computers enumeration
         NET_DISPLAY_MACHINE      * pbufNetUser;
      
         // Get the first set of users from the domain
         rc = NetQueryDisplayInformation((WCHAR *)sServerName, 2, ndx, MAX_BUF, sizeof(NET_DISPLAY_MACHINE) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
         if ((rc != ERROR_SUCCESS) && (rc != ERROR_MORE_DATA))
         {
            delete pNodeList;
            return HRESULT_FROM_WIN32(rc);
         }
      
         // Build the PDC account name.
         WCHAR          server[LEN_Path];
         WCHAR          name[LEN_Path];
         BOOL           bPDCFound = FALSE;
         wcscpy(server, (WCHAR*)(sServerName + (2*sizeof(WCHAR))));
         wsprintf(name, L"%s$", server);

         while ( ulCount > 0 )
         {
            // For each user create a node set the value of the node to the object name and add it to the list.
            TAttrNode         * pNode;
            for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
            {
               // if we process the PDC then we need to let the function know.
               if ( wcscmp(pbufNetUser[dwIdx].usri2_name, name) == 0 )
                  bPDCFound = TRUE;

               _variant_t val[6] = { pbufNetUser[dwIdx].usri2_name,
                                     pbufNetUser[dwIdx].usri2_comment,
                                     (long)0,
                                     (long)0,
                                     (long)0,
                                     L"" };

               val[2].vt = VT_UI4;
               val[2].ulVal = pbufNetUser[dwIdx].usri2_user_id;

               val[3].vt = VT_UI4;
               val[3].ulVal = pbufNetUser[dwIdx].usri2_flags;
            
               pNode = new TAttrNode(6, val);
			   if (!pNode)
			   {
				  delete pNodeList;
                  NetApiBufferFree(pbufNetUser);
			      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			   }
               pNodeList->InsertBottom(pNode);
            }

            // Set the index for next set of users.
            if ( ulCount > 0 )
               ndx = pbufNetUser[ulCount-1].usri2_next_index;
         
            NetApiBufferFree(pbufNetUser);
            // Get the next set of objects
            if ( rc == ERROR_MORE_DATA )
            {
               rc = NetQueryDisplayInformation((WCHAR *)sServerName, 2, ndx, MAX_BUF, sizeof(NET_DISPLAY_MACHINE) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
               if ((rc != ERROR_SUCCESS) && (rc != ERROR_MORE_DATA))
               {
                  delete pNodeList;
                  return HRESULT_FROM_WIN32(rc);
               }
            }
            else
               ulCount = 0;
         }
         // if pdc is already added then we dont need to do any of this.
         if ( !bPDCFound )
         {
            // we will fake all other attributes other than the name
            _variant_t val[6] = { name,
                                  L"",
                                  L"",
                                  L"",
                                  L"",
                                  L"" };

            val[2].vt = VT_UI4;
            val[2].ulVal = 0;

            val[3].vt = VT_UI4;
            val[3].ulVal = UF_SERVER_TRUST_ACCOUNT | UF_SCRIPT;
      
            TAttrNode * pNode = new TAttrNode(6, val);
			if (!pNode)
			{
			   delete pNodeList;
			   return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			}
            pNodeList->InsertBottom(pNode);
         }
      }
   
      else if (!wcscmp(sContainerName,L"CN=GROUPS"))
      {
         // Build Groups enumeration
         // Build Computers enumeration
         NET_DISPLAY_GROUP      * pbufNetUser;
      
         // Get the first set of users from the domain
         rc = NetQueryDisplayInformation((WCHAR *)sServerName, 3, ndx, MAX_BUF, sizeof(NET_DISPLAY_GROUP) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
         if ((rc != ERROR_SUCCESS) && (rc != ERROR_MORE_DATA))
         {
            delete pNodeList;
            return HRESULT_FROM_WIN32(rc);
         }
         
         while ( ulCount > 0 )
         {
            // For each user create a node set the value of the node to the object name and add it to the list.
            TAttrNode             * pNode;
            for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
            {
               _variant_t val[6] = { pbufNetUser[dwIdx].grpi3_name,
                                     pbufNetUser[dwIdx].grpi3_comment,
                                     L"",
                                     L"",
                                     L"",
                                     L"" };
            
               val[2].vt = VT_UI4;
               val[2].ulVal = pbufNetUser[dwIdx].grpi3_group_id;

               val[3].vt = VT_UI4;
               val[3].ulVal = pbufNetUser[dwIdx].grpi3_attributes;
            
               pNode = new TAttrNode(6, val);
			   if (!pNode)
			   {
				  delete pNodeList;
                  NetApiBufferFree(pbufNetUser);
			      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			   }
               pNodeList->InsertBottom(pNode);
            }

            // Set the index for next set of users.
            if ( ulCount > 0 )
               ndx = pbufNetUser[ulCount-1].grpi3_next_index;
            
            NetApiBufferFree(pbufNetUser);
            // Get the next set of objects
            if ( rc == ERROR_MORE_DATA )
            {
               rc = NetQueryDisplayInformation((WCHAR *)sServerName, 3, ndx, MAX_BUF, sizeof(NET_DISPLAY_GROUP) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
               if ((rc != ERROR_SUCCESS) && (rc != ERROR_MORE_DATA))
               {
                  delete pNodeList;
                  return HRESULT_FROM_WIN32(rc);
               }
            }
            else
               ulCount = 0;
         }
      }
      else if (!wcscmp(sContainerName,L"CN=DOMAIN CONTROLLERS"))
      {
            // Build Domain Controller enumeration
		 LPSERVER_INFO_101 pBuf = NULL;
         DWORD dwLevel = 101;
         DWORD dwSize = MAX_PREFERRED_LENGTH;
         DWORD dwEntriesRead = 0L;
         DWORD dwTotalEntries = 0L;
         DWORD dwTotalCount = 0L;
         DWORD dwServerType = SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL; // domain controllers
         DWORD dwResumeHandle = 0L;
         NET_API_STATUS nStatus;
         DWORD dw;

		    //enumerate the primary and backup domain controllers
         nStatus = NetServerEnum(NULL,
								 dwLevel,
								 (LPBYTE *) &pBuf,
								 dwSize,
								 &dwEntriesRead,
								 &dwTotalEntries,
								 dwServerType,
								 (WCHAR*) sDomainName,
								 &dwResumeHandle);

         if (nStatus == NERR_Success)
		 {
            if (pBuf != NULL)
			{
                  // For each DC create a node set the value of the node to the object name and add it to the list.
               for (dw = 0; dw < dwEntriesRead; dw++)
			   {
                  _variant_t varArr[6] = { pBuf[dw].sv101_name, (long)0, (long)0, (long)0, (long)0, (long)0 } ;
                  TAttrNode * pNode = new TAttrNode(6, varArr);
			      if (!pNode)
				  {
				     delete pNodeList;
                     NetApiBufferFree(pBuf);
			         return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				  }
                  pNodeList->InsertBottom(pNode);
			   }
               NetApiBufferFree(pBuf);
            }
         }
         else
         {
            delete pNodeList;
            return HRESULT_FROM_WIN32(nStatus);
         }
	  }//end if enum DCs

      // Build an enumerator and return it to the caller.
      *pVarEnum = new CNT4Enum(pNodeList);
   }
   else
      delete pNodeList;
	  

   return S_OK;
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 14 JUNE 2001                                                *
 *                                                                   *
 *     This function is responsible for getting the name of the PDC  *
 * for the given domain.  We store the domain\PDC pairs in a map     *
 * class variable so that we only have to look up the PDC once per   *
 * instantiations of this object.                                    *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDC
_bstr_t CNT4Dom::GetDC(_bstr_t sDomain)
{
/* local variables */
	_bstr_t		sDC;
	CDCMap::iterator	itDCMap;

/* function body */
	if (!sDomain.length())
		return L"";

		//look if we have already cached the naming context for this domain
	itDCMap = mDCMap.find(sDomain);
		//if found, get the cached naming context
	if (itDCMap != mDCMap.end())
	{
		sDC = itDCMap->second;
	}
	else //else, lookup the PDC from scratch and add that to the cache
	{
		if (GetAnyDcName5(sDomain, sDC) == ERROR_SUCCESS)
		{
			mDCMap.insert(CDCMap::value_type(sDomain, sDC));
		}
	}

	return sDC;
}
//END GetDC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\nt4dom.h ===
/*---------------------------------------------------------------------------
  File: NT4Dom.h

  Comments: interface for the NT4 Domain class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#if !defined(AFX_NT4DOM_H__62E14C50_1AAC_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_NT4DOM_H__62E14C50_1AAC_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Domain.h"
#include <map>

class CNT4Dom : public CDomain  
{
public:
	CNT4Dom();
	virtual ~CNT4Dom();
   HRESULT  GetEnumeration(BSTR sContainerName, BSTR sDomainName, BSTR m_sQuery, long attrCnt, LPWSTR * sAttr, ADS_SEARCHPREF_INFO prefInfo,BOOL  bMultiVal, IEnumVARIANT **& pVarEnum);
private:
	typedef std::map<_bstr_t,_bstr_t> CDCMap;
	CDCMap mDCMap;   //map to store domains and one of its DCs

	_bstr_t GetDC(_bstr_t sDomain);
};

#endif // !defined(AFX_NT4DOM_H__62E14C50_1AAC_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\nt4enum.cpp ===
/*---------------------------------------------------------------------------
  File: NT4Enum.cpp

  Comments: Implementation of the enumeration object. This object implements
            IEnumVARIANT interface.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "NetNode.h"
#include "AttrNode.h"
#include "TNode.hpp"
#include "NT4Enum.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CNT4Enum::CNT4Enum(TNodeList * pNodeList) : m_listEnum(pNodeList)
{
   m_pNodeList = pNodeList;
}

CNT4Enum::~CNT4Enum()
{
}

//---------------------------------------------------------------------------
// Next : Implements next method of the IEnumVaraint interface. This method
//        returns the next object in the enumeration. It returns S_FALSE when
//        there are no more objects to enumerate.
//---------------------------------------------------------------------------
HRESULT CNT4Enum::Next(
                        unsigned long celt,              //in -Number of elements to return IGNORED.
                        VARIANT FAR* rgvar,              //out-Variant used to return the object information
                        unsigned long FAR* pceltFetched  //out-Number of elements returned (ALWAYS 1).
                      )
{
   TAttrNode     * pNode = (TAttrNode *)m_listEnum.Next();
   if ( pNode == NULL ) 
      return S_FALSE;
//   *rgvar = pNode->m_Val;
   HRESULT hr = VariantCopy(rgvar, &pNode->m_Val);
   if (SUCCEEDED(hr))
   {
      *pceltFetched = 1;
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\nt4enum.h ===
/*---------------------------------------------------------------------------
  File: NT4Enum.h

  Comments: interface for the CNT4Enum class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/
#if !defined(AFX_NT4ENUM_H__C0171FA0_1AB3_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_NT4ENUM_H__C0171FA0_1AB3_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "AttrNode.h"

class CNT4Enum : public IEnumVARIANT  
{
public:
	TNodeList            * m_pNodeList;
	TNodeListEnum          m_listEnum;
   CNT4Enum(TNodeList * pNodeList);
	virtual ~CNT4Enum();
   HRESULT STDMETHODCALLTYPE Next(unsigned long celt, VARIANT FAR* rgvar, unsigned long FAR* pceltFetched);
   HRESULT STDMETHODCALLTYPE Skip(unsigned long celt){ return E_NOTIMPL; }
   HRESULT STDMETHODCALLTYPE Reset(){ return E_NOTIMPL; }
   HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT FAR* FAR* ppenum){ return E_NOTIMPL; }
   HRESULT STDMETHODCALLTYPE QueryInterface(const struct _GUID &,void ** ){ return E_NOTIMPL; }
   ULONG   STDMETHODCALLTYPE AddRef(void){ return E_NOTIMPL; }
   ULONG   STDMETHODCALLTYPE Release(void)
   {
      if ( m_pNodeList )
      {
         
         TAttrNode * pNode = (TAttrNode *)m_pNodeList->Head();
         TAttrNode * temp;

         for ( pNode = (TAttrNode*)m_listEnum.OpenFirst(m_pNodeList) ; pNode; pNode = temp )
         {
            temp = (TAttrNode *)m_listEnum.Next();
            m_pNodeList->Remove(pNode);
            delete pNode;
         }
         m_listEnum.Close();
         delete m_pNodeList;
         m_pNodeList = NULL;
         delete this;
      }
      return 0;
   }
};

#endif // !defined(AFX_NT4ENUM_H__C0171FA0_1AB3_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NetObjEn.rc
//
#define IDS_PROJNAME                    100
#define IDR_NETOBJENUMERATOR            101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\objenum.cpp ===
/*---------------------------------------------------------------------------
  File: NetObjEnumerator.cpp

  Comments: Implementation of NetObjectEnumerator COM object.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "NetEnum.h"
#include "ObjEnum.h"
#include "Win2KDom.h"
#include "NT4DOm.h"
#include <lmaccess.h>
#include <lmwksta.h>
#include <lmapibuf.h>
#include "GetDcName.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetObjEnumerator

//---------------------------------------------------------------------------
// SetQuery: This function sets all the parameters necessary for a query
//           to be executed. User can not call Execute without first calling
//           this method.
//---------------------------------------------------------------------------
STDMETHODIMP CNetObjEnumerator::SetQuery(
                                          BSTR sContainer,     //in -Container name
                                          BSTR sDomain,        //in -Domain name
                                          BSTR sQuery,         //in -Query in LDAP syntax
                                          long nSearchScope,   //in -Scope of the search. ADS_ATTR_SUBTREE/ADS_ATTR_ONELEVEL
                                          long bMultiVal       //in- Do we need to return multivalued properties?
                                        )
{
   Cleanup();
   // Save all the settings in member variables.
   m_sDomain = sDomain;
   m_sContainer = sContainer;
   m_sQuery = sQuery;
   m_bSetQuery = true;
   m_bMultiVal = bMultiVal;
   if ( nSearchScope < 0 || nSearchScope > 2 )
      return E_INVALIDARG;
   prefInfo.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
   prefInfo.vValue.dwType = ADSTYPE_INTEGER;
   prefInfo.vValue.Integer = nSearchScope;

	return S_OK;
}

//---------------------------------------------------------------------------
// SetColumns: This function sets all the columns that the user wants to be
//             returned when query is executed. 
//---------------------------------------------------------------------------
STDMETHODIMP CNetObjEnumerator::SetColumns(
                                            SAFEARRAY * colNames      //in -Pointer to a SafeArray that contains all the columns
                                          )
{
   // We require that the SetQuery method be called before SetColumns is called. Hence we will return E_FAIL
   // If we expose these interface we should document this.
   if (!m_bSetQuery)
      return E_FAIL;

   if ( m_bSetCols )
   {
      Cleanup();
      m_bSetQuery = true;
   }

   SAFEARRAY               * pcolNames = colNames;
   long                      dwLB;
   long                      dwUB;
   BSTR              HUGEP * pBSTR;
   HRESULT                   hr;

   // Get the bounds of the column Array
   hr = ::SafeArrayGetLBound(pcolNames, 1, &dwLB);
   if (FAILED(hr))
      return hr;

   hr = ::SafeArrayGetUBound(pcolNames, 1, &dwUB);
   if (FAILED(hr))
      return hr;

   m_nCols = dwUB-dwLB + 1;

   // We dont support empty columns request atleast one column.
   if ( m_nCols == 0 )
      return E_FAIL;

   hr = ::SafeArrayAccessData(pcolNames, (void **) &pBSTR);
   if ( FAILED(hr) )
      return hr;

   // Allocate space for the array. It is deallocated by Cleanup()
   m_pszAttr = new LPWSTR[m_nCols];

   if (m_pszAttr == NULL)
   {
      ::SafeArrayUnaccessData(pcolNames);
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   }

   // Each column is now put into the Array
   for ( long dw = 0; dw < m_nCols; dw++)
   {
      m_pszAttr[dw] = SysAllocString(pBSTR[dw]);
      if (!m_pszAttr[dw] && pBSTR[dw] && *(pBSTR[dw]))
      {
          
          for (long i = 0; i < dw; i++) {
            SysFreeString(m_pszAttr[i]);
          }
          delete [] m_pszAttr;
          m_pszAttr = NULL;  

          ::SafeArrayUnaccessData(pcolNames);
          return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
      }
   }
   hr = ::SafeArrayUnaccessData(pcolNames);
   m_bSetCols = true;
   return hr;
}

//---------------------------------------------------------------------------
// Cleanup: This function cleans up all the allocations and the member vars.
//---------------------------------------------------------------------------
void CNetObjEnumerator::Cleanup()
{
   if ( m_nCols > 0 )
   {
      if ( m_pszAttr )
      {
         // delete the contents of the array
         for ( int i = 0 ; i < m_nCols ; i++ )
         {
            SysFreeString(m_pszAttr[i]);
         }
         // Dealloc the array itself
         delete [] m_pszAttr;
         m_pszAttr = NULL;
      }
      // Reset all counts and flags.
      m_nCols = 0;
      m_bSetQuery = false;
      m_bSetCols = false;
   }
}

//---------------------------------------------------------------------------
// Execute: This function actually executes the query and then builds an
//          enumerator object and returns it.
//---------------------------------------------------------------------------
STDMETHODIMP CNetObjEnumerator::Execute(
                                          IEnumVARIANT **pEnumerator    //out -Pointer to the enumerator object.
                                       )
{
   // This function will take the options set in SetQuery and SetColumns to enumerate objects
   // for the given domain. This could be a NT4 domain or a Win2K domain. Although at the moment
   // NT4 domains simply enumerate all objects in the given container, we could later implement
   // certain features to support queries etc.
   if ( !m_bSetCols )
      return E_FAIL;

   HRESULT                   hr = S_OK;

   *pEnumerator = NULL;

		//if we have not yet create the Domain-specific class object, for doing the
        //actual enumeration, then create it now
   if (!m_pDom)
   {
      hr = CreateDomainObject();
   }//end if no domain object yet

      //if we encountered a problem getting the domain object, return
   if ((hr != S_OK) || (!m_pDom))
      return hr;

      //call the enumeration function on the domain object
   try
   {
      hr = m_pDom->GetEnumeration(m_sContainer, m_sDomain, m_sQuery, m_nCols, m_pszAttr, prefInfo, m_bMultiVal, pEnumerator);
   }
   catch ( _com_error &e)
   {
      return e.Error();
   }

   return hr;
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 13 JUNE 2001                                                *
 *                                                                   *
 *     This function is responsible for try to instantiate one of the*
 * OS-specific classes and storing that object in the m_pDom class   *
 * variable.  This function returns an HRESULT that indicates success*
 * or failure.                                                       *
 *                                                                   *
 *********************************************************************/

//BEGIN CreateDomainObject
HRESULT CNetObjEnumerator::CreateDomainObject()
{
/* local variables */
    HRESULT hr = S_OK;

/* function body */

    _bstr_t strDc;
    DWORD rc = GetAnyDcName5(m_sDomain, strDc);

    //if we got the DC, get the OS version of that DC
    if ( !rc ) 
    {
        WKSTA_INFO_100  * pInfo = NULL;
        rc = NetWkstaGetInfo(strDc,100,(LPBYTE*)&pInfo);
        if ( ! rc )
        {
            //if NT 4.0, create an NT 4.0 class object
            if ( pInfo->wki100_ver_major < 5 )
                m_pDom = new CNT4Dom();
            else //else create a W2K class object
                m_pDom = new CWin2000Dom();

            if (!m_pDom)
                hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

            NetApiBufferFree(pInfo);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(rc);
        }
    }//end if got DC
    else
    {
        hr = HRESULT_FROM_WIN32(rc);
    }

    return hr;
}
//END CreateDomainObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\objenum.h ===
/*---------------------------------------------------------------------------
  File: NetObjEnumerator.h

  Comments: Declaration of the CNetObjEnumerator COM object. This COM object
            is used to get an enumeration for the members in a container and
            their properties. If user simply needs all the objects in a given
            container then they can use the GetContainerEnum method. If user
            wants to perform some advanced searches/queries then they should
            use the set of three functions (SetQuery, SetColumns, Execute) to
            Setup and execute a query against the container. Both sets of methods
            return IEnumVaraint supporting objects. This object will allow user
            to go through all the values returned by queries.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#ifndef __NETOBJENUMERATOR_H_
#define __NETOBJENUMERATOR_H_

#include "resource.h"       // main symbols
#include "Domain.h"

/////////////////////////////////////////////////////////////////////////////
// CNetObjEnumerator
class ATL_NO_VTABLE CNetObjEnumerator : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CNetObjEnumerator, &CLSID_NetObjEnumerator>,
   public INetObjEnumerator
{
public:
   CNetObjEnumerator() : m_bSetQuery(false), m_bSetCols(false)
	{
      m_nCols = 0;
      m_pszAttr = NULL;
      m_pDom = NULL;
	}
   ~CNetObjEnumerator()
   {
      Cleanup();
         //delete the cached domain object
      if (m_pDom)
	  {
	     delete m_pDom;
	     m_pDom = NULL;
	  }
   }

DECLARE_REGISTRY_RESOURCEID(IDR_NETOBJENUMERATOR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNetObjEnumerator)
	COM_INTERFACE_ENTRY(INetObjEnumerator)
END_COM_MAP()

// INetObjEnumerator
public:
	STDMETHOD(Execute)(/*[out]*/ IEnumVARIANT ** pEnumerator);
	STDMETHOD(SetColumns)(/*[in]*/ SAFEARRAY * colNames);
	STDMETHOD(SetQuery)(/*[in]*/ BSTR sContainer, /*[in]*/ BSTR sDomain, /*[in,optional]*/ BSTR sQuery=L"(objectClass=*)", /*[in,optional]*/ long nCnt = 1, /*[in,optional]*/ long bMultiVal = FALSE);
private:
	void Cleanup();
	long m_nCols;                       // Number of columns requested by the user.
	_bstr_t m_sQuery;                   // Stores the query set by the user. This will be used to query the info from AD.
	_bstr_t m_sContainer;               // Stores the container name of where the search is to be made.
   _bstr_t m_sDomain;                  // Domain name that we are enumerating.
   bool m_bSetQuery;                   // Flag indicating whether SetQuery called or not
   bool m_bSetCols;                    // Similar flag for SetColumn
   LPWSTR *m_pszAttr;                  // Stores the array of columns requested by the user of the object.
   ADS_SEARCHPREF_INFO prefInfo;       // The Search Scope
   BOOL  m_bMultiVal;                  // Flag to indicate whether to return multivalues or not.
   CDomain * m_pDom;				   // Pointer to our domain object

   HRESULT CreateDomainObject();       //create the proper OS-specific domain object
};

#endif //__NETOBJENUMERATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\win2kdom.h ===
/*---------------------------------------------------------------------------
  File: Win2000Dom.h

  Comments: interface for the CWin2000Dom class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#if !defined(AFX_WIN2000DOM_H__2DE5B8E0_19FA_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_WIN2000DOM_H__2DE5B8E0_19FA_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "AttrNode.h"
#include "Domain.h"
#include <map>

class CWin2000Dom : public CDomain  
{
public:
	CWin2000Dom();
	virtual ~CWin2000Dom();
   HRESULT  GetEnumeration(BSTR sContainerName, BSTR sDomainName, BSTR m_sQuery, long attrCnt, LPWSTR * sAttr, ADS_SEARCHPREF_INFO prefInfo,BOOL  bMultiVal, IEnumVARIANT **& pVarEnum);
private:
	typedef std::map<_bstr_t,_bstr_t> CNameContextMap;
	CNameContextMap mNameContextMap;   //map to store domains and their default naming contexts

	//	void UpdateAccountInList( TNodeList * pList, BSTR sDomainName);
	bool AttrToVariant(ADSVALUE adsVal, _variant_t& var);
   HRESULT  DoRangeQuery(BSTR sDomainName, BSTR sQuery, LPWSTR * sAttr, int attrCnt, ADS_SEARCH_HANDLE hSearch, IDirectorySearch * pSearch, BOOL bMultiVal, TNodeList * pNode);
    bool IsPropMultiValued(const WCHAR * sPropName, const WCHAR * sDomain);
	_bstr_t GetDefaultNamingContext(_bstr_t sDomain);
};

#endif // !defined(AFX_WIN2000DOM_H__2DE5B8E0_19FA_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__14B26371_191D_11D3_8C7F_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__14B26371_191D_11D3_8C7F_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <iads.h>
#include <adshlp.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__14B26371_191D_11D3_8C7F_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\win2kdom.cpp ===
// Win2000Dom.cpp: implementation of the CWin2000Dom class.
/*---------------------------------------------------------------------------
  File: Win2000Dom.cpp

  Comments: Implementation of Win2K object enumeration. This object enumerates
            members in any given container for Win2k domain. It
            returns all information about the object that user requested.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "EaLen.hpp"
#include <adserr.h>
#include "NT4Enum.h"
#include "Win2KDom.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWin2000Dom::CWin2000Dom()
{

}

CWin2000Dom::~CWin2000Dom()
{
	mNameContextMap.clear();
}

//---------------------------------------------------------------------------
// GetEnumeration : Given the information this method returns all requested
//                  values for a given object in a VARIANT containing 
//                  SAFEARRAY containing each of the property value that was 
//                  requested by the caller.
//---------------------------------------------------------------------------
HRESULT  CWin2000Dom::GetEnumeration(
                                       BSTR sContainerName,             //in- Container to enumerate ( LDAP sub path )
                                       BSTR sDomainName,                //in- Domain where the container resides
                                       BSTR m_sQuery,                   //in- LDAP query string (for filtering)
                                       long attrCnt,                    //in- Number of properties requested.
                                       LPWSTR * sAttr,                  //in- Pointer to array of Property names.
                                       ADS_SEARCHPREF_INFO prefInfo,    //in- Search preference info.
                                       BOOL  bMultiVal,                 //in- Indicates whether to return multivalue props or not.
                                       IEnumVARIANT **& pVarEnum        //out- IEnumVARIANT object that will enumerate all returned objects.
                                    )
{
   // First get the full path to the container from the subpath that we have here.
   _bstr_t                   sAdsPath;
   _bstr_t                   sNamingContext;
   _bstr_t                   sGrpDN;
   _bstr_t                   sQuery;
   _variant_t                var, var2;
   IADs                    * pAds = NULL;
   int                       nCnt = 0;
//   IADsMembers             * pMbr = NULL;
//   IADsGroup               * pGrp = NULL;
   HRESULT                   hr = S_OK;
   HRESULT                   hr2;
   IDirectorySearch        * pSearch = NULL;
   ADS_SEARCH_HANDLE         hSearch = NULL;
   TNodeList               * pList = new TNodeList();
//   int                       cnt = 0;
   bool                      cont = true;
   ADS_SEARCH_COLUMN         col;
   BSTR                      sClass = NULL;
   
   if (!pList)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

      //get the default naming context for this domain
   sNamingContext = GetDefaultNamingContext(sDomainName);
   if (sNamingContext.length())
   {
      if ( (wcsncmp(sContainerName, L"LDAP://", 7) != 0) && (wcsncmp(sContainerName, L"GC://", 5) != 0) )
      {
         // Partial path supplied so we will build the rest.
         if ( sContainerName && *sContainerName )
         {
            sAdsPath = L"LDAP://";
            sAdsPath += sDomainName;
            sAdsPath += L"/";
            sAdsPath += sContainerName;
            sAdsPath += L",";
            sAdsPath += sNamingContext;
         }
         else
         {
            sAdsPath = L"LDAP://";
            sAdsPath += sDomainName;
            sAdsPath += L"/";
            sAdsPath += sNamingContext;
         }
	  }
      else  //else full path so no need to build anything.
         sAdsPath = sContainerName; 
   }//end if got default naming context
   
   if (sAdsPath.length())
   {
	     //connect to the object
      hr = ADsGetObject(sAdsPath, IID_IADs, (void**) &pAds);
      if (SUCCEEDED(hr))
      {
         hr = pAds->get_Class(&sClass);
      }
      if ( SUCCEEDED(hr) )
      {
         if ( sClass && wcscmp(sClass, L"group") == 0 && prefInfo.vValue.Integer != ADS_SCOPE_BASE )
         {
            // If we're trying to enumerate the contents of a group, 
            // Construct the DN for group and the LDAP path to whole directory
	         hr = pAds->Get(L"distinguishedName", &var2);
	         if ( SUCCEEDED(hr) )
            {
               sGrpDN = var2.bstrVal;
               sAdsPath = L"LDAP://";
               sAdsPath += sDomainName;
               sAdsPath += L"/";
               sAdsPath += sNamingContext;

               // modify the query so that we have (& (memberOf=%s) (...) ) query
               sQuery = L"(&(memberOf=";
               sQuery += sGrpDN;
               sQuery += L") ";
               sQuery += m_sQuery;
               sQuery += L")";
               // Also the scope changes since we need to search the whole domain
               prefInfo.vValue.Integer = ADS_SCOPE_SUBTREE;
               hr = ADsGetObject(sAdsPath, IID_IDirectorySearch, (void**) &pSearch);
            }
         }//end if group object
         else
         {
            sQuery = m_sQuery;
            hr = pAds->QueryInterface(IID_IDirectorySearch, (void**)&pSearch);
         }
         SysFreeString(sClass);
      }//end if got the object class
      
      if ( SUCCEEDED(hr) )
      {
         hr = pSearch->SetSearchPreference(&prefInfo, 1);
         // Set the query to be paged query so that we can get the data larger than a 1000.
         ADS_SEARCHPREF_INFO prefInfo2;
         prefInfo2.dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
         prefInfo2.vValue.dwType = ADSTYPE_INTEGER;
         prefInfo2.vValue.Integer = 999;
         if (SUCCEEDED(hr))
         {
            hr = pSearch->SetSearchPreference(&prefInfo2, 1);
         }
      }

      if ( SUCCEEDED(hr) )
      {
         if ( (prefInfo.vValue.Integer == ADS_SCOPE_BASE) && (bMultiVal) && 
			  (_wcsicmp(L"member", sAttr[0]) == 0) || (_wcsicmp(L"memberOf", sAttr[0]) == 0) || 
			  (_wcsicmp(L"directReports", sAttr[0]) == 0) || (_wcsicmp(L"managedObjects", sAttr[0]) == 0))
         {
            DoRangeQuery(sDomainName, sQuery, sAttr, attrCnt, hSearch, pSearch, bMultiVal, pList);
         }
         else
         {
            hr = pSearch->ExecuteSearch(sQuery, sAttr, attrCnt, &hSearch);
            if ( SUCCEEDED(hr) )
            {
               hr = pSearch->GetFirstRow(hSearch);
            }
            if ( hr == S_OK )
            {
               while( cont )
               {
                  _variant_t        * varAr = new _variant_t[attrCnt];
	              if (!varAr)
				  {
                     if ( pSearch )
					 {
                        pSearch->CloseSearchHandle(hSearch);
                        pSearch->Release();
					 }
                     if ( pAds )
                        pAds->Release();
					 delete pList;
                     return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				  }
//                  int ncol = 0;
                  for ( long dw = 0; dw < attrCnt; dw++ )
                  {
                     hr = pSearch->GetColumn( hSearch, sAttr[dw], &col );
                     if ( SUCCEEDED(hr) )
                     {
                        if ( col.dwNumValues > 0 )
                        {
                           // Get the type of attribute and put the value into the variant
                           // and then into the Enumerator object. 
					            if ( col.dwNumValues < 2 || !bMultiVal )
   					            // put the last item into the enumeration.(memberOf=CN=DNSAdmins,CN=USERS,DC=devblewerg,DC=com)
                              AttrToVariant(col.pADsValues[col.dwNumValues - 1], varAr[dw]);
                           else
                           {
                              // Build a VARIANT array of all the values.
                              SAFEARRAY            * pArray;
                              SAFEARRAYBOUND         bd = {col.dwNumValues, 0};
                              _variant_t             var;
                              _bstr_t                strTemp;  
                              _variant_t  HUGEP    * vArray;
                              pArray = SafeArrayCreate(VT_VARIANT|VT_BSTR, 1, &bd);
                  
                              // Fill up the VARIANT Array
                              SafeArrayAccessData(pArray, (void HUGEP **) &vArray);
                              for ( DWORD x = 0; x < col.dwNumValues; x++ )
                              {
                                 nCnt++;
                                 AttrToVariant(col.pADsValues[x], var);
                                 strTemp = var;
                                 vArray[x] = _variant_t(strTemp);
                              }
                              SafeArrayUnaccessData(pArray);
                              varAr[dw].vt = VT_ARRAY | VT_VARIANT;
                              SafeArrayCopy(pArray, &varAr[dw].parray);
                           }
                        }
                        else
                        {
                           // Put an empty string here.
                           varAr[dw] = (BSTR)NULL;
                           hr = S_OK;
                        }
                        pSearch->FreeColumn( &col );
                     }
                     else 
                     {
                        // Put an empty string here.
                        varAr[dw] = (BSTR)NULL;

                        if (hr == E_ADS_COLUMN_NOT_SET)
                        {
                            hr = S_OK;
                        }
                     }
                  }
                  TAttrNode * pNode = new TAttrNode(attrCnt, varAr);
	              if (!pNode)
				  {
                     delete [] varAr;
                     if ( pSearch )
					 {
                        pSearch->CloseSearchHandle(hSearch);
                        pSearch->Release();
					 }
                     if ( pAds )
                        pAds->Release();
					 delete pList;
                     return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				  }
			         // Clear the array
                  delete [] varAr;
                  hr2 = pSearch->GetNextRow(hSearch);
                  if ( hr2  == S_ADS_NOMORE_ROWS ) {
                     cont = false;
                  }
                  else if (FAILED(hr2)) {

                     if ( pSearch )
					 {
                        pSearch->CloseSearchHandle(hSearch);
                        pSearch->Release();
					 }
                     if ( pAds )
                        pAds->Release();
					 delete pList;
                     return hr2;
                  }
                  
                  pList->InsertBottom(pNode);
               }
            }
            pSearch->CloseSearchHandle(hSearch);
         }
      }
   }//end if got adspath
   else
   {
      hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
   }
   
   if ( pSearch )
      pSearch->Release();

   if ( pAds )
      pAds->Release();

   if (FAILED(hr))
   {
      delete pList;
      return hr;
   }
   
//   UpdateAccountInList(pList, sDomainName);
   *pVarEnum = (IEnumVARIANT *) new CNT4Enum(pList);
   if (!(*pVarEnum))
   {
	  delete pList;
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   }
   return S_OK;
}

//--------------------------------------------------------------------
// AttrToVariant : This function stores a value from ADSValue struct
//                 into a variant in a appropriate type.
//--------------------------------------------------------------------
bool CWin2000Dom::AttrToVariant(
                                 ADSVALUE pADsValues,    //in- Value for a property in ADSVALUE struct
                                 _variant_t& var         //out-Variant filled with info from the in parameter.
                               )
{
   HRESULT hr = S_OK;
      // Fill in the values as per the varset.
      switch (pADsValues.dwType)
      {
         case ADSTYPE_INVALID             :  break;

         case ADSTYPE_DN_STRING           :  var = pADsValues.DNString;
                                             break;
         case ADSTYPE_CASE_EXACT_STRING   :  var = pADsValues.CaseExactString;
                                             break;
         case ADSTYPE_CASE_IGNORE_STRING  :  var = pADsValues.CaseIgnoreString;
                                             break;
         case ADSTYPE_PRINTABLE_STRING    :  var = pADsValues.PrintableString;
                                             break;
         case ADSTYPE_NUMERIC_STRING      :  var = pADsValues.NumericString;
                                             break;
         case ADSTYPE_INTEGER             :  var.vt = VT_I4;
                                             var.lVal = pADsValues.Integer;
                                             break; 
         case ADSTYPE_OCTET_STRING        :  {
                                                var.vt = VT_ARRAY | VT_UI1;
                                                var.parray = NULL;
                                                byte           * pData;
                                                DWORD            dwLength = pADsValues.OctetString.dwLength;
                                                SAFEARRAY      * sA;
                                                SAFEARRAYBOUND   rgBound = {dwLength, 0}; 
                                                sA = ::SafeArrayCreate(VT_UI1, 1, &rgBound);
                                                ::SafeArrayAccessData( sA, (void**)&pData);
                                                for ( DWORD i = 0; i < dwLength; i++ )
                                                   pData[i] = pADsValues.OctetString.lpValue[i];
                                                hr = ::SafeArrayUnaccessData(sA);
                                                hr = ::SafeArrayCopy(sA, &var.parray);
												            hr = ::SafeArrayDestroy(sA);
                                             }
                                             break;
/*         case ADSTYPE_UTC_TIME            :  var = L"Date not supported.";
                                             break;
         case ADSTYPE_LARGE_INTEGER       :  var = L"Large Integer not supported.";
                                             break;
         case ADSTYPE_PROV_SPECIFIC       :  var = L"Provider specific strings not supported.";
                                             break;
         case ADSTYPE_OBJECT_CLASS        :  var = pADsValues.ClassName;
                                             break;
         case ADSTYPE_CASEIGNORE_LIST     :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Case ignore lists are not supported.";
                                             break;
         case ADSTYPE_OCTET_LIST          :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Octet lists are not supported.";
                                             break;
         case ADSTYPE_PATH                :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Path type not supported.";
                                             break;
         case ADSTYPE_POSTALADDRESS       :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Postal addresses are not supported.";
                                             break;
         case ADSTYPE_TIMESTAMP           :  var.vt = VT_UI4;
                                             var.lVal = attrInfo.pADsValues[dw].UTCTime;
                                             break;
         case ADSTYPE_BACKLINK            :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Backlink is not supported.";
                                             break;
         case ADSTYPE_TYPEDNAME           :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Typed name not supported.";
                                             break;
         case ADSTYPE_HOLD                :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Hold not supported.";
                                             break;
         case ADSTYPE_NETADDRESS          :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"NetAddress not supported.";
                                             break;
         case ADSTYPE_REPLICAPOINTER      :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Replica pointer not supported.";
                                             break;
         case ADSTYPE_FAXNUMBER           :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Faxnumber not supported.";
                                             break;
         case ADSTYPE_EMAIL               :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Email not supported.";
                                             break;
         case ADSTYPE_NT_SECURITY_DESCRIPTOR : wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Security Descriptor not supported.";
                                             break;
                                             */
         default                          :  return false;
   }
   return true;
}

/*void CWin2000Dom::UpdateAccountInList(TNodeList *pList, BSTR sDomainName)
{
	bool found = false;
	for ( TAttrNode * pNode = (TAttrNode *)pList->Head(); pNode; pNode = (TAttrNode *)pNode->Next())
	{
		if ( _bstr_t(pNode->m_Val) == _bstr_t(sPDC) )
		{
			found = true;
			break;
		}
	}

	if ( !found )
	{
		TAttrNode * pNode = new TAttrNode(attrCnt, varAr);
		pList->InsertBottom(pNode);
	}
}
*/

HRESULT  CWin2000Dom::DoRangeQuery(BSTR sDomainName, BSTR sQuery, LPWSTR * sAttr, int attrCnt, ADS_SEARCH_HANDLE hSearch, IDirectorySearch * pSearch, BOOL bMultiVal, TNodeList * pList)
{
   HRESULT                   hr = S_OK;
   HRESULT                   hr2;
   bool                      cont = true;
   ADS_SEARCH_COLUMN         col;
   int                       nCnt = 0;
   int                     * pStartWith;
   int                     * pEndWith;
   WCHAR                     sAttrRange[LEN_Path];
   int                       tryCols = 0;
   LPWSTR                  * sAttrs = NULL;
   _variant_t              * varAr;
   TAttrNode               * pNode;
   LPWSTR				   * psAttrNames;
   BOOL					   * pDone;
   BOOL					     bAllDone = FALSE;
   int						 nOrigCnt = attrCnt;
   int						 ndx;

   pStartWith = new int[attrCnt];
   pEndWith = new int[attrCnt];
   psAttrNames = new LPWSTR[attrCnt];
   sAttrs = new LPWSTR[attrCnt];
   pDone = new BOOL[attrCnt];

   if ((!pStartWith) || (!pEndWith) || (!psAttrNames) || (!sAttrs) || (!pDone))
   {
	  if (pStartWith)
         delete [] pStartWith;
	  if (pEndWith)
         delete [] pEndWith;
	  if (psAttrNames)
         delete [] psAttrNames;
	  if (sAttrs)
         delete [] sAttrs;
	  if (pDone)
         delete [] pDone;
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   }

   for (ndx = 0; ndx < attrCnt; ndx++)
   {
	  pStartWith[ndx] = 0;
	  pEndWith[ndx] = 0;
	  psAttrNames[ndx] = sAttr[ndx];
	  sAttrs[ndx] = _wcsdup(sAttr[ndx]);
	  if (!sAttrs[ndx] && sAttr[ndx])
	  {
          for (int i=0; i < ndx; i++)
          {
              free(sAttrs[i]);
          }
	  
          delete [] pStartWith;
          delete [] pEndWith;
          delete [] psAttrNames;
          delete [] sAttrs;
          delete [] pDone;
          return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	  }
	  
	  pDone[ndx] = FALSE;
   }

   // continue to retrieve field's values in MAX chunks until done
   while (!bAllDone)
   {
	  int last = 0;
      for (ndx = 0; ndx < attrCnt; ndx++)
	  {
		 if (pDone[ndx] == FALSE)
		 {
			if (IsPropMultiValued((WCHAR*)psAttrNames[ndx], (WCHAR*)sDomainName) == true)
               wsprintf(sAttrRange, L"%s;range=%d-*", (WCHAR*)(psAttrNames[ndx]), pStartWith[ndx]);
			else
			   wcscpy(sAttrRange, (WCHAR*)psAttrNames[ndx]);

			free(sAttrs[ndx]);
            sAttrs[last] = _wcsdup(sAttrRange);
            if (!sAttrs[last])
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            }
            psAttrNames[last] = psAttrNames[ndx];
			pStartWith[last] = pStartWith[ndx];
			pEndWith[last] = pEndWith[ndx];
			pDone[last] = pDone[ndx];
			last++;
		 }
		 else
            free(sAttrs[ndx]);
	  }
	  attrCnt = last;
	  if (hr != S_OK)
	  {
          for (int i=0; i < attrCnt; i++)
          {
              free(sAttrs[i]);
          }
	  
          delete [] pStartWith;
          delete [] pEndWith;
          delete [] psAttrNames;
          delete [] sAttrs;
          delete [] pDone;
          return hr;
	  }
	  
      varAr = new _variant_t[attrCnt];
	  if (!varAr)
	  {
         delete [] pStartWith;
         delete [] pEndWith;
         delete [] psAttrNames;
         delete [] pDone;
         for (ndx = 0; ndx < attrCnt; ndx++)
		 {
            free(sAttrs[ndx]);
		 }
         delete [] sAttrs;
         return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	  }

	  for (ndx=0; ndx<attrCnt; ndx++)
	  {
         varAr[ndx] = (BSTR)NULL;
	     pDone[ndx] = TRUE;
	  }

      hr = pSearch->ExecuteSearch(sQuery, sAttrs, attrCnt, &hSearch);
      if ( SUCCEEDED(hr) )
      {
         hr = pSearch->GetFirstRow(hSearch);
      }
      if ( hr == S_OK )
      {
         while( cont )
         {
			LPWSTR pszColumn;
			_bstr_t sTemp;
			   //since the column name could have changed (in the case that there are
			   //more values to enumerate than IDirectorySearch can in a single call : 
			   //default is 1000) we need to find the column's new name
            hr = pSearch->GetNextColumnName(hSearch, &pszColumn);
			while (pszColumn != NULL)
			{
			   int current = -1;
               if ((SUCCEEDED(hr)) && (hr != S_ADS_NOMORE_COLUMNS))
			   {
				     //get the new column name
				  do
				  {
				     current++;
				     sTemp = psAttrNames[current];
				     if (wcslen(psAttrNames[current]) != (wcslen(pszColumn)))
				        sTemp += L";range=";
				  }
				  while ((current < attrCnt) && (wcsstr(pszColumn, (WCHAR*)sTemp) == NULL));

	              pDone[current] = FALSE;

				  if (wcsstr(pszColumn, (WCHAR*)sTemp) != NULL)
				  {
				     _bstr_t oldName = psAttrNames[current];
				     oldName += L";range=";
				     if ((wcsstr(pszColumn, oldName) != NULL) && 
					     (wcsstr(pszColumn, L"-*") == NULL))
					 {
					    WCHAR  sName[MAX_PATH];
				           //now get the new range max retrieved so far
                        swscanf(pszColumn, L"%[^;];range=%d-%d", sName, &pStartWith[current], &pEndWith[current]);
                        free(sAttrs[current]);
                        sAttrs[current] = _wcsdup(pszColumn); //save the new column name
                        if (!sAttrs[current])
                        {
                            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                        }
					 }
				     else if ((wcsstr(pszColumn, L"-*") != NULL) || (!wcscmp(pszColumn, psAttrNames[current])))
					    pDone[current] = TRUE;
				     FreeADsMem(pszColumn);

				     if (hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY))
				     {
                        delete [] varAr;
                        delete [] pStartWith;
                        delete [] pEndWith;
                        delete [] psAttrNames;
                        delete [] pDone;
                        for (ndx = 0; ndx < attrCnt; ndx++)
            			{
                           free(sAttrs[ndx]);
            			}
                        delete [] sAttrs;
                        pSearch->CloseSearchHandle(hSearch);
                        return hr;
				     }
				  }
			   }

               hr = pSearch->GetColumn( hSearch, sAttrs[current], &col );
               if ( SUCCEEDED(hr) )
               {
                  if ( col.dwNumValues > 0 )
                  {
                     // Build a VARIANT array of all the values.
                     SAFEARRAY            * pArray;
                     SAFEARRAYBOUND         bd = {col.dwNumValues, 0};
                     _variant_t             var;
                     _bstr_t                strTemp;  
                     _variant_t  HUGEP    * vArray;
                     pArray = SafeArrayCreate(VT_VARIANT|VT_BSTR, 1, &bd);
      
                     // Fill up the VARIANT Array
                     SafeArrayAccessData(pArray, (void HUGEP **) &vArray);
                     for ( DWORD x = 0; x < col.dwNumValues; x++ )
                     {
                        nCnt++;
                        AttrToVariant(col.pADsValues[x], var);
                        strTemp = var;
                        vArray[x] = _variant_t(strTemp);
                     }
                     SafeArrayUnaccessData(pArray);
                     varAr[current].vt = VT_ARRAY | VT_VARIANT;
                     SafeArrayCopy(pArray, &varAr[current].parray);
                  }
                  pSearch->FreeColumn( &col );
               }
               hr = pSearch->GetNextColumnName(hSearch, &pszColumn);
            }//end while more columns
            hr2 = pSearch->GetNextRow(hSearch);
            if ( (hr2  == S_ADS_NOMORE_ROWS) || FAILED(hr2) )
            {
               hr = S_OK;
               cont = false;
            }
         }
      }
      else
      {
         bAllDone = TRUE;
      }

      if ( pStartWith[0] == 0 )
	  {
         pNode = new TAttrNode((long)attrCnt, varAr);
	     if (!pNode)
		 {
            delete [] varAr;
            delete [] pStartWith;
            delete [] pEndWith;
            delete [] psAttrNames;
            delete [] pDone;
            for (ndx = 0; ndx < attrCnt; ndx++)
			{
               free(sAttrs[ndx]);
			}
            delete [] sAttrs;
            pSearch->CloseSearchHandle(hSearch);
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
		 }
	  }
      else  //else add the new values for any remaining attributes
	  {
	     for (int i=0; i<attrCnt; i++)
		 {
			int j=-1;
			bool bFound = false;
			  //find the original column of this attribute for the 'Add' call
		    while ((j < nOrigCnt) && (!bFound))
			{
			   j++;
			   if (wcscmp(psAttrNames[i], sAttr[j]) == 0)
			      bFound = true; //original column number
			}
			if (bFound) //if found, add the new values for that column
               pNode->Add((long)j, (long)i, varAr);
		 }
	  }

      // Clear the array
      delete [] varAr;

      pSearch->CloseSearchHandle(hSearch);
      cont = true;
      
	  bAllDone = TRUE;
      for (ndx = 0; ndx < attrCnt; ndx++)
	  {
		 pStartWith[ndx] = pEndWith[ndx] + 1;  //start the next query
		 bAllDone = ((bAllDone) && (pDone[ndx])) ? TRUE : FALSE; //see if done with all properties
	  }
   }

   delete [] pStartWith;
   delete [] pEndWith;
   delete [] psAttrNames;
   delete [] pDone;

   for (ndx = 0; ndx < attrCnt; ndx++)
   {
      free(sAttrs[ndx]);
   }

   delete [] sAttrs;

   pList->InsertBottom(pNode);

   return hr;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 10 NOV 2000                                                 *
 *                                                                   *
 *     This function is responsible for checking a property's schema *
 * to see if that property is multi-valued or not.                   *
 *                                                                   *
 *********************************************************************/

//BEGIN IsPropMultiValued
bool CWin2000Dom::IsPropMultiValued(const WCHAR * sPropName, const WCHAR * sDomain)
{
   HRESULT                         hr;
   VARIANT_BOOL                    bMulti = VARIANT_FALSE;
   WCHAR                           sAdsPath[LEN_Path];
   DWORD                           dwArraySizeOfsAdsPath = sizeof(sAdsPath)/sizeof(sAdsPath[0]);
   IADsProperty                  * pProp = NULL;

   if ( sPropName == NULL || wcslen(sPropName) == 0 )
      return false;

   if (sDomain == NULL)
       _com_issue_error(E_INVALIDARG);
   
   //prepare to call the property's schema
   if (wcslen(L"LDAP://") + wcslen(sDomain) + wcslen(L"/")
       + wcslen(sPropName) + wcslen(L", schema") >= dwArraySizeOfsAdsPath)
       _com_issue_error(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
   wcscpy(sAdsPath, L"LDAP://");
   wcscat(sAdsPath, sDomain);
   wcscat(sAdsPath, L"/");
   wcscat(sAdsPath, sPropName);
   wcscat(sAdsPath, L", schema");

   hr = ADsGetObject(sAdsPath, IID_IADsProperty, (void **)&pProp);

   // Get the Multi-Valued flag for the property
   if (SUCCEEDED(hr))
   {
      hr = pProp->get_MultiValued(&bMulti);
      pProp->Release();
   }

   if (FAILED(hr))
   {
      _com_issue_error(hr);
   }

   if (bMulti == VARIANT_TRUE)
      return true;
   else
      return false;
}
//END IsPropMultiValued


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 13 JUNE 2001                                                *
 *                                                                   *
 *     This function is responsible for getting the default naming   *
 * context for the given domain.  We store the domain\naming context *
 * pairs in a map class variable so that we only have to look up the *
 * naming context once per instantiations of this object.            *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDefaultNamingContext
_bstr_t CWin2000Dom::GetDefaultNamingContext(_bstr_t sDomain)
{
/* local variables */
	HRESULT		hr;
	_bstr_t		sNamingContext = L"";
	CNameContextMap::iterator	itDNCMap;

/* function body */
	if (!sDomain.length())
		return sNamingContext;

		//look if we have already cached the naming context for this domain
	itDNCMap = mNameContextMap.find(sDomain);
		//if found, get the cached naming context
	if (itDNCMap != mNameContextMap.end())
	{
		sNamingContext = itDNCMap->second;
	}
	else //else, lookup the naming context from scratch and add that to the cache
	{
		_bstr_t		sAdsPath;
		_variant_t	var;
		IADs	  * pAds = NULL;

			// Get the default naming context for this domain
		sAdsPath = L"LDAP://";
		sAdsPath += sDomain;
		sAdsPath += L"/rootDSE";
		hr = ADsGetObject(sAdsPath, IID_IADs, (void**) &pAds);
		if ( SUCCEEDED(hr))
		{
			hr = pAds->Get(L"defaultNamingContext", &var);
				//if got the context, add it to the cache
			if ( SUCCEEDED(hr) )
			{
				sNamingContext = var.bstrVal;
				mNameContextMap.insert(CNameContextMap::value_type(sDomain, sNamingContext));
			}
		}
	}

	return sNamingContext;
}
//END GetDefaultNamingContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\enumtest\enumtest.h ===
// EnumTest.h : main header file for the ENUMTEST application
//

#if !defined(AFX_ENUMTEST_H__36AFC712_1921_11D3_8C7F_0090270D48D1__INCLUDED_)
#define AFX_ENUMTEST_H__36AFC712_1921_11D3_8C7F_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CEnumTestApp:
// See EnumTest.cpp for the implementation of this class
//

class CEnumTestApp : public CWinApp
{
public:
	CEnumTestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEnumTestApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CEnumTestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ENUMTEST_H__36AFC712_1921_11D3_8C7F_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\enumtest\enumtest.cpp ===
// EnumTest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "EnumTest.h"
#include "EnumTestDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEnumTestApp

BEGIN_MESSAGE_MAP(CEnumTestApp, CWinApp)
	//{{AFX_MSG_MAP(CEnumTestApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnumTestApp construction

CEnumTestApp::CEnumTestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CEnumTestApp object

CEnumTestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CEnumTestApp initialization

BOOL CEnumTestApp::InitInstance()
{
	AfxEnableControlContainer();
   CoInitialize(NULL);

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CEnumTestDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

int CEnumTestApp::ExitInstance() 
{
   CoUninitialize();	
	return CWinApp::ExitInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\enumtest\enumvar.cpp ===
// EnumVar.cpp: implementation of the CEnumVar class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <COMDEF.h>
#include "EnumTest.h"
#include "EnumVar.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEnumVar::CEnumVar(IEnumVARIANT  * pEnum)
{
   m_pEnum = pEnum;
   m_pEnum->AddRef();
}

CEnumVar::~CEnumVar()
{
   m_pEnum->Release();
}

BOOL CEnumVar::Next(long flag, SAttrInfo * pAttr)
{
   // This function enumerates through and gets name strings for the Values
   ULONG                     ulFetched=0;
   IADs                    * pADs=NULL;
   _variant_t                var;
   BSTR                      bstrName;
   
   if ( !m_pEnum )
   {
      return FALSE;
   }

   HRESULT hr = m_pEnum->Next(1, &var, &ulFetched);

   if ( ulFetched == 0 || FAILED(hr) )
      return FALSE;

   if ( var.vt == VT_BSTR )
   {
      // We have a bstring so lets just return that as names
      wcscpy(pAttr->sName, var.bstrVal);
      wcscpy(pAttr->sSamName, var.bstrVal);
   }
   else
   {
      if ( flag == NULL )
         return FALSE;
      // We have a Dispatch Pointer
      IDispatch * pDisp = V_DISPATCH(&var);
      // We ask for a IAds pointer
      hr = pDisp->QueryInterface( IID_IADs, (void**)&pADs); 
      // and Ask IAds pointer to give us the name of the container.

      // Now fill up information that they need.
      
      // Common Name
      if ( flag | F_Name )
      {
         hr = pADs->get_Name(&bstrName);
         if ( FAILED(hr) )
            return FALSE;
         wcscpy( pAttr->sName, bstrName);
      }

      // SAM Account Name
      if ( flag | F_SamName )
      {
         hr = pADs->Get(L"sAMAccountName", &var);
         if ( FAILED(hr) )
            return FALSE;
         wcscpy( pAttr->sSamName, var.bstrVal);
      }

      // Class name of the object.
      if ( flag | F_Class )
      {
         hr = pADs->get_Class(&bstrName);
         if ( FAILED(hr) )
            return FALSE;
         wcscpy( pAttr->sClass, bstrName);
      }

      // Group Type
 /*     if ( flag | F_GroupType )
      {
         hr = pADs->Get(L"groupType", &var);
         if ( FAILED(hr) )
         {
            var.vt = VT_I4;
            var.lVal = -1;
         }
         pAttr->groupType = var.lVal;
      }
*/   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\enumtest\enumtestdlg.cpp ===
// EnumTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "EnumTest.h"
#include "EnumTestDlg.h"
#include "EnumVar.h"
#include <sddl.h>

#import "\bin\NetEnum.tlb"  no_namespace
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnumTestDlg dialog

CEnumTestDlg::CEnumTestDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CEnumTestDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEnumTestDlg)
	m_strContainer = _T("");
	m_strDomain = _T("");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CEnumTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEnumTestDlg)
	DDX_Control(pDX, IDC_LIST_MEMBERS, m_listBox);
	DDX_Text(pDX, IDC_EDIT_Container, m_strContainer);
	DDX_Text(pDX, IDC_EDIT_DOMAIN, m_strDomain);
	DDX_Text(pDX, IDC_EDIT_QUERY, m_strQuery);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CEnumTestDlg, CDialog)
	//{{AFX_MSG_MAP(CEnumTestDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_MEMBERS, OnDblclkListMembers)
	ON_BN_CLICKED(IDC_BACKTRACK, OnBacktrack)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnumTestDlg message handlers

BOOL CEnumTestDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	m_strContainer = L"OU=ShamTest";
	m_strDomain    = L"devblewerg";
   m_strQuery     = L"(objectClass=*)";
	UpdateData(FALSE);
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CEnumTestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CEnumTestDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CEnumTestDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CEnumTestDlg::OnOK() 
{
/*   m_listBox.DeleteAllItems();
   UpdateData();
   INetObjEnumeratorPtr           pNetObj(__uuidof(NetObjEnumerator));
   BSTR                           sContName = m_strContainer.AllocSysString();
   BSTR                           sDomain = m_strDomain.AllocSysString();
   IEnumVARIANT					  * pEnum;
   HRESULT                        hr;
   VARIANT                        varEnum;
   ULONG                          ulFetch = 0;
   VariantInit(&varEnum);

   m_listBox.InsertItem(0, "====================");
   hr = pNetObj->raw_GetContainerEnum( sContName, sDomain, &pEnum);
   if ( FAILED(hr) )
   {
      m_listBox.InsertItem(0, "Invalid Container");
      return;
   }

   ::SysFreeString(sContName);
   ::SysFreeString(sDomain);
   hr = S_OK;
   SAttrInfo      sInfo;
   CString        disp;
   long           flag = 15;  // Get all four values.
   if (pEnum)
   {
      CEnumVar          enumVar(pEnum);
      while ( enumVar.Next(flag, &sInfo) )
      {
         disp.Format("%ls<%ls>", sInfo.sName, sInfo.sClass);
         m_listBox.InsertItem(0, disp);
      }
      ADsFreeEnumerator(pEnum); 
   }
   */
   m_listBox.DeleteAllItems();
   bool	bFullPath;
   UpdateData();
   BSTR                           sContName = m_strContainer.AllocSysString();
   if ( m_strDomain.Left(5) == L"GC://" )
	   bFullPath = true;
   BSTR                           sDomain = m_strDomain.AllocSysString();
   BSTR                           sQuery = m_strQuery.AllocSysString();
   INetObjEnumeratorPtr           pNetObj(__uuidof(NetObjEnumerator));
   IEnumVARIANT					  * pEnum;
   DWORD                          ulFet=0;
   _variant_t                     var, var2;
   _variant_t                   * pVars;
   CString						  sX;
   CString                       strDisp;
   BSTR HUGEP * pData;
//   BSTR   pBSTR[] = { L"name", L"accountExpires", L"sAMAccountName", L"objectClass", L"objectSID", L"ou", L"cn"  };
   BSTR   pBSTR[] = { L"name", L"dc"};
   long   ind = sizeof(pBSTR)/sizeof(BSTR);
   SAFEARRAYBOUND b = { ind, 0 };
   SAFEARRAY * pArray = NULL;
   pArray = ::SafeArrayCreate(VT_BSTR, 1, &b);

   ::SafeArrayAccessData(pArray, (void HUGEP **)&pData);
   for (long i = 0; i < ind; i++)
      pData[i] = pBSTR[i];
   ::SafeArrayUnaccessData(pArray);
   try
   {
//      pNetObj->SetQuery(sContName, sDomain, sQuery, ADS_SCOPE_ONELEVEL );
      pNetObj->SetQuery(sContName, sDomain, sQuery, ADS_SCOPE_SUBTREE );
      pNetObj->SetColumns((long) pArray);
      pNetObj->Execute(&pEnum);
   }
   catch (const _com_error &e)
   {
      ::AfxMessageBox(e.ErrorMessage());
      return;
   }
   if (pEnum)
   {
      while (pEnum->Next(1, &var, &ulFet) == S_OK)
      {
         if ( ulFet )
         {
            pArray = var.parray;
            long ub, lb;
            ::SafeArrayGetUBound(pArray, 1, &ub);
            ::SafeArrayGetLBound(pArray, 1, &lb);

            ::SafeArrayAccessData(pArray, (void HUGEP **)&pVars);
//            for ( long x = lb; x <= ub - 2; x++)
			for ( long x = lb; x <= ub ; x++)
            {
               if ( x > lb )
               {
                  if ( pVars[x].vt == VT_BSTR)
                     strDisp = strDisp + "<" + CString(pVars[x].bstrVal) + ">";
                  else
                     if ( pVars[x].vt == (VT_ARRAY | VT_UI4) )
                        // Octet string 
                        strDisp = strDisp + "<" + CString(GetSidFromVar(pVars[x])) + ">";
                     else
					 {
						// an integer
                        sX.Format("%s<%d>", strDisp, pVars[x].lVal);
						strDisp = sX;
					 }
               }
               else
               {
                  if ( !CString(pVars[ub-1].bstrVal).IsEmpty() )
                     strDisp = "OU=";
                  else
                     // it is a CN
                     strDisp = "CN=";
                  strDisp = strDisp + CString(pVars[x].bstrVal);
               }
            }
            m_listBox.InsertItem(0, strDisp);
            ::SafeArrayUnaccessData(pArray);
         }
      }
   }
   ::SysFreeString(sDomain);
   ::SysFreeString(sQuery);
   ::SysFreeString(sContName);
}

void CEnumTestDlg::OnDblclkListMembers(NMHDR* pNMHDR, LRESULT* pResult) 
{
   int len = m_strContainer.GetLength();
   UpdateData();
   CString str = m_listBox.GetItemText(m_listBox.GetSelectionMark(),0);	
   str = str.Left(str.Find("<"));
   if ( len )
      m_strContainer = str + "," + m_strContainer;
   else
      m_strContainer = str;
   UpdateData(FALSE);
   OnOK();
	*pResult = 0;
}

void CEnumTestDlg::OnBacktrack() 
{
   UpdateData();
   int ndx = m_strContainer.Find(",");
   if ( ndx != -1 )
      m_strContainer = m_strContainer.Mid(ndx + 1);
   else
      m_strContainer = "";
   UpdateData(FALSE);
   OnOK();
}

char * CEnumTestDlg::GetSidFromVar(_variant_t var)
{
   void HUGEP *pArray;
   PSID        pSid;
   char        * sSid;
   HRESULT hr = SafeArrayAccessData( V_ARRAY(&var), &pArray );
   if ( SUCCEEDED(hr) ) 
      pSid = (PSID)pArray;
   ::ConvertSidToStringSid(pSid, &sSid);
   hr = ::SafeArrayUnaccessData(V_ARRAY(&var));
   return sSid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\enumtest\enumvar.h ===
// EnumVar.h: interface for the CEnumVar class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ENUMVAR_H__EFC2C760_1A9F_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_ENUMVAR_H__EFC2C760_1A9F_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define UNLEN        255

// The follwing flags make up a bitmask used to define what values the Enumerator fills up
// for a given object.

// TODO :: We can add more attributes in order to get the appropriate information from the Object
//         when we enumerate it. To add items simply add a flag and then add an item to the struct.
#define  F_Name              0x00000001
#define  F_Class             0x00000002
#define  F_SamName           0x00000004
#define  F_GroupType         0x00000008

// Structure used to fill out information about the object
typedef struct _Obj {
   WCHAR                     sName[UNLEN];    // Common Name of the object
   WCHAR                     sClass[UNLEN];   // The type of the object
   WCHAR                     sSamName[UNLEN]; // SamAccountName of the object
   long                      groupType;       // The type of a group object (UNIVERSAL etc)
} SAttrInfo;

class CEnumVar  
{
public:
	BOOL Next( long flag, SAttrInfo * pAttr );
	IEnumVARIANT  * m_pEnum;
	CEnumVar(IEnumVARIANT  * pEnum);
	virtual ~CEnumVar();
};

#endif // !defined(AFX_ENUMVAR_H__EFC2C760_1A9F_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\enumtest\enumtestdlg.h ===
// EnumTestDlg.h : header file
//

#if !defined(AFX_ENUMTESTDLG_H__36AFC714_1921_11D3_8C7F_0090270D48D1__INCLUDED_)
#define AFX_ENUMTESTDLG_H__36AFC714_1921_11D3_8C7F_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CEnumTestDlg dialog

class CEnumTestDlg : public CDialog
{
// Construction
public:
	CEnumTestDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CEnumTestDlg)
	enum { IDD = IDD_ENUMTEST_DIALOG };
	CListCtrl	m_listBox;
	CString	m_strContainer;
	CString	m_strDomain;
   CString  m_strQuery;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEnumTestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CEnumTestDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	virtual void OnOK();
	afx_msg void OnDblclkListMembers(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnBacktrack();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
   char * GetSidFromVar(_variant_t var);

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ENUMTESTDLG_H__36AFC714_1921_11D3_8C7F_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\enumtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by EnumTest.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_ENUMTEST_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDC_LIST_MEMBERS                1000
#define IDC_EDIT_Container              1001
#define IDC_EDIT_DOMAIN                 1002
#define IDC_BACKTRACK                   1003
#define IDC_EDIT_QUERY                  1004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\enumtest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	EnumTest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\enumtest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__36AFC716_1921_11D3_8C7F_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__36AFC716_1921_11D3_8C7F_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <iads.h>
#include <adshlp.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__36AFC716_1921_11D3_8C7F_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\mcspisag\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\mcspisag\csvcinf.cpp ===
// CSvcInf.cpp : Implementation of CCSvcAcctInfo
#include "stdafx.h"
#include "McsPISag.h"
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#import "DBMgr.tlb" no_namespace, named_guids
#include "CSvcInf.h"
#include "ResStr.h"
#include "ErrDct.hpp"

#include <ntdsapi.h>
#include <lm.h>
#include "GetDcName.h"

// these are needed for ISecPlugIn
#include "cipher.hpp"
#include "SecPI.h"

#define EXCHANGE_SERVICE_NAME       L"MSExchangeSA"
#define SvcAcctStatus_DoNotUpdate			   1
#define SvcAcctStatus_NeverAllowUpdate       8

TErrorDct err;
/////////////////////////////////////////////////////////////////////////////
// CCSvcAcctInfo


typedef UINT (CALLBACK* DSBINDFUNC)(TCHAR*, TCHAR*, HANDLE*);
typedef UINT (CALLBACK* DSUNBINDFUNC)(HANDLE*);

typedef NTDSAPI
DWORD
WINAPI
 DSCRACKNAMES(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCWSTR       *rpNames,           // in
    PDS_NAME_RESULTW    *ppResult);         // out

typedef NTDSAPI
void
WINAPI
 DSFREENAMERESULT(
  DS_NAME_RESULTW *pResult
);

// This method is called by the dispatcher to verify that this is a valid plug-in
// Only valid plug-ins will be sent out with the agents
// The purpose of this check is to make it more difficult for unauthorized parties 
// to use our plug-in interface, since it is currently undocumented.
STDMETHODIMP CCSvcAcctInfo::Verify(/*[in,out]*/ULONG * pData,/*[in]*/ULONG size)
{
   
   McsChallenge            * pMcsChallenge;
   long                      lTemp1;
   long                      lTemp2;

   if( size == sizeof(McsChallenge)  )
   {
      pMcsChallenge = (McsChallenge*)(pData);
      
      SimpleCipher((LPBYTE)pMcsChallenge,size);
      
      pMcsChallenge->MCS[0] = 'M';
      pMcsChallenge->MCS[1] = 'C';
      pMcsChallenge->MCS[2] = 'S';
      pMcsChallenge->MCS[3] = 0;

   
      lTemp1 = pMcsChallenge->lRand1 + pMcsChallenge->lRand2;
      lTemp2 = pMcsChallenge->lRand2 - pMcsChallenge->lRand1;
      pMcsChallenge->lRand1 = lTemp1;
      pMcsChallenge->lRand2 = lTemp2;
      pMcsChallenge->lTime += 100;

      SimpleCipher((LPBYTE)pMcsChallenge,size);
   }
   else
      return E_FAIL;


   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::GetRegisterableFiles(/* [out] */SAFEARRAY ** pArray)
{
   SAFEARRAYBOUND            bound[1] = { 1, 0 };
   LONG                      ndx[1] = { 0 };

   (*pArray) = SafeArrayCreate(VT_BSTR,1,bound);

   SafeArrayPutElement(*pArray,ndx,SysAllocString(L"McsPISag.DLL"));
   
   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::GetRequiredFiles(/* [out] */SAFEARRAY ** pArray)
{
   SAFEARRAYBOUND            bound[1] = { 1, 0 };
   LONG                      ndx[1] = { 0 };

   (*pArray) = SafeArrayCreate(VT_BSTR,1,bound);

   SafeArrayPutElement(*pArray,ndx,SysAllocString(L"McsPISag.DLL"));

   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::GetDescription(/* [out] */ BSTR * description)
{
   (*description) = SysAllocString(L"");

   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::PreMigrationTask(/* [in] */IUnknown * pVarSet)
{
   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::PostMigrationTask(/* [in] */IUnknown * pVarSet)
{
//   DWORD                     rc = 0;
   IVarSetPtr                pVS;
   
   pVS = pVarSet;

   _bstr_t                   log = pVS->get(GET_BSTR(DCTVS_Options_Logfile));

   err.LogOpen((WCHAR*)log,1);

   err.MsgWrite(0,DCT_MSG_MCSPISAG_STARTING);

   pVS->put(GET_BSTR(DCTVS_CurrentOperation),GET_BSTR(IDS_Gathering_SvcAcct));

   ProcessServices(pVS);

   pVS->put(GET_BSTR(DCTVS_CurrentOperation),L"");
   
   err.MsgWrite(0,DCT_MSG_MCSPISAG_DONE);

   err.LogClose();
   return S_OK;
}


STDMETHODIMP CCSvcAcctInfo::GetName(/* [out] */BSTR * name)
{
   (*name) = SysAllocString(L"");
   
   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::GetResultString(/* [in] */IUnknown * pVarSet,/* [out] */ BSTR * text)
{
   WCHAR                     buffer[1000] = L"";
   IVarSetPtr                pVS;

   pVS = pVarSet;

   
   (*text) = SysAllocString(buffer);
   
   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::StoreResults(/* [in] */IUnknown * pVarSet)
{
   IVarSetPtr                pVS = pVarSet;
   IIManageDBPtr             pDatabase;
   HRESULT                   hr;
   WCHAR                     key[200];
   _bstr_t                   service;
   _bstr_t                   account;
   _bstr_t                   computer;
   _bstr_t                   display;
   long                      ndx = 0;
   _bstr_t                   exchangeAccount;
   HINSTANCE                 hLibrary = NULL;
   DSCRACKNAMES            * DsCrackNames = NULL;
   DSFREENAMERESULT        * DsFreeNameResult = NULL;
   DSBINDFUNC                DsBind = NULL;
   DSUNBINDFUNC              DsUnBind = NULL;
   _bstr_t                   sourceDomainDns = pVS->get(GET_BSTR(DCTVS_Options_SourceDomainDns));
   WCHAR				   * atPtr = NULL;
   HANDLE                    hDs = NULL;

   computer = pVS->get("LocalServer");
   hr = pDatabase.CreateInstance(CLSID_IManageDB);
   if ( SUCCEEDED(hr) )
   {
      // make a pre-pass through the data
      do 
      {
         swprintf(key,L"ServiceAccounts.%ld.Service",ndx);
         service = pVS->get(key);
         
         swprintf(key,L"ServiceAccounts.%ld.Account",ndx);
         account = pVS->get(key);
         
         // make sure the account names are not in UPN format
         if ( NULL == wcschr((WCHAR*)account,L'\\') )
         {
			if (! hDs )
            {
               if (! hLibrary )
               {
                  hLibrary = LoadLibrary(L"NTDSAPI.DLL"); 
               }
               if ( hLibrary )
               {
                  DsBind = (DSBINDFUNC)GetProcAddress(hLibrary,"DsBindW");
                  DsUnBind = (DSUNBINDFUNC)GetProcAddress(hLibrary,"DsUnBindW");
                  DsCrackNames = (DSCRACKNAMES *)GetProcAddress(hLibrary,"DsCrackNamesW");
                  DsFreeNameResult = (DSFREENAMERESULT *)GetProcAddress(hLibrary,"DsFreeNameResultW");
               }
            
               if ( DsBind && DsUnBind && DsCrackNames && DsFreeNameResult)
               {
                  hr = (*DsBind)(NULL,(WCHAR*)sourceDomainDns,&hDs);
                  if ( hr )
                  {
                     hDs = NULL;
                  }
               }
            }
            if ( hDs )
            {
               PDS_NAME_RESULT         pNamesOut = NULL;
               WCHAR                 * pNamesIn[1];

               pNamesIn[0] = (WCHAR*)account;
               hr = (*DsCrackNames)(hDs,DS_NAME_NO_FLAGS,DS_USER_PRINCIPAL_NAME,DS_NT4_ACCOUNT_NAME,1,pNamesIn,&pNamesOut);
			   (*DsUnBind)(&hDs);
			   hDs = NULL;
               if ( !hr )
               {
                  if ( pNamesOut->rItems[0].status == DS_NAME_NO_ERROR )
                  {
                     account = pNamesOut->rItems[0].pName;
                     pVS->put(key,account);
                  }
					//if from another domain try connecting to that domain's DC and 
				    //retry DSCrackNames
                  else if ( pNamesOut->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY )
				  {
					  _bstr_t dc;

                      DWORD dwError = GetAnyDcName4(pNamesOut->rItems[0].pDomain, dc);
	                  
					  if (dwError == ERROR_SUCCESS)
					  {
							//bind to that domain DC
						  hr = (*DsBind)(dc,NULL,&hDs);
						  if ( !hr )
						  {
							 (*DsFreeNameResult)(pNamesOut);//release the old info
							 pNamesOut = NULL;
							   //retry DSCrackNames again
			                 hr = (*DsCrackNames)(hDs,DS_NAME_NO_FLAGS,DS_USER_PRINCIPAL_NAME,DS_NT4_ACCOUNT_NAME,1,pNamesIn,&pNamesOut);
							 if ( !hr )
							 {
								 if ( pNamesOut->rItems[0].status == DS_NAME_NO_ERROR )
								 {
									 account = pNamesOut->rItems[0].pName;
									 pVS->put(key,account);
								 }
							 }
			                 (*DsUnBind)(&hDs);
			                 hDs = NULL;
						  }
					  }
				  }
				  if (pNamesOut)
                     (*DsFreeNameResult)(pNamesOut);
               }
            }
         }
         // also, look for the exchange server service account
         if ( !UStrICmp(service,EXCHANGE_SERVICE_NAME) )
         {
            exchangeAccount = account;
         }
         ndx++;
      } while ( service.length() );

      ndx = 0;
      WCHAR                serverFilter[300];

      // clear any old entries from the table for this computer
      swprintf(serverFilter,L"System = '%ls'",(WCHAR*)computer);
	  _variant_t Filter = serverFilter;
      hr = pDatabase->raw_ClearTable(SysAllocString(L"ServiceAccounts"), Filter);
      do 
      {
         swprintf(key,L"ServiceAccounts.%ld.Service",ndx);
         service = pVS->get(key);
         swprintf(key,L"ServiceAccounts.%ld.DisplayName",ndx);
         display = pVS->get(key);
         swprintf(key,L"ServiceAccounts.%ld.Account",ndx);
         account = pVS->get(key);
         if ( service.length() && account.length() )
         {
            hr = pDatabase->raw_SetServiceAccount(computer,service,display,account);   
            if ( SUCCEEDED(hr) && !UStrICmp((WCHAR*)account,(WCHAR*)exchangeAccount) )
            {
               // mark this account to be excluded from the processing
               hr = pDatabase->raw_SetServiceAcctEntryStatus(computer,service,account,SvcAcctStatus_NeverAllowUpdate);
            }
         }
         ndx++;
      } while ( service.length() );
   }
   if ( hLibrary )
   {
      FreeLibrary(hLibrary);
   }
   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::ConfigureSettings(/*[in]*/IUnknown * pVarSet)
{
   IVarSetPtr                pVS = pVarSet;

   MessageBox(NULL,L"This is a test",L"McsPISag PlugIn",MB_OK);

   return S_OK;
}

void CCSvcAcctInfo::ProcessServices(IVarSet * pVarSet)
{
   // Connect to the SCM on the local computer
   SC_HANDLE                 pScm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS );
   DWORD                     rc = 0;
   WCHAR                     domain[200];
   WKSTA_INFO_100          * info;

   // Get the name of the domain that this computer is in, so we can resolve any accounts that are
   // specified as .\Account to DOMAIN\account format

   rc = NetWkstaGetInfo(NULL,100,(BYTE**)&info);
   if ( ! rc )
   {
      UStrCpy(domain,info->wki100_langroup);
      NetApiBufferFree(info);
   }
   else
   {
      // if we can't get the domain name, just leave the .
      UStrCpy(domain,L".");
   }
   if ( pScm )
   {
      // Enumerate the services on the computer
      ENUM_SERVICE_STATUS    servStatus[1000];
      DWORD                  cbBufSize = (sizeof servStatus);
      DWORD                  cbBytesNeeded = 0;
      DWORD                  nReturned = 0;
      DWORD                  hResume = 0;
      WCHAR                  string[1000];
      long                   count = 0;

      if (! EnumServicesStatus(pScm,SERVICE_WIN32,SERVICE_STATE_ALL,servStatus,cbBufSize,&cbBytesNeeded,&nReturned,&hResume) )
      {
         rc = GetLastError();
         err.SysMsgWrite(ErrE,rc,DCT_MSG_SERVICE_ENUM_FAILED_D,rc);
      }
      else
      {
         rc = 0;
      }
      
      if ( rc == ERROR_SUCCESS || rc == ERROR_MORE_DATA )
      {

         for ( UINT i = 0 ; i < nReturned ; i++ )
         {
            SC_HANDLE               pService = OpenService(pScm,servStatus[i].lpServiceName,SERVICE_ALL_ACCESS );
            BYTE                    buf[3000];
            QUERY_SERVICE_CONFIG  * pConfig = (QUERY_SERVICE_CONFIG *)buf; 
//            BOOL                    bIncluded = FALSE;
            DWORD                   lenNeeded = 0;

            
            if ( pService )
            {
               // get the information about this service
               if ( QueryServiceConfig(pService,pConfig,sizeof buf, &lenNeeded) )
               {
                  err.MsgWrite(0,DCT_MSG_SERVICE_USES_ACCOUNT_SS,servStatus[i].lpServiceName,pConfig->lpServiceStartName);
                  // add the account to the list if it is not using LocalSystem or NT Authority account
                  // or local accounts
                  if ((UStrICmp(pConfig->lpServiceStartName,L"LocalSystem")) &&
                      (_wcsnicmp(pConfig->lpServiceStartName, L"NT Authority\\", wcslen(L"NT Authority\\"))) &&
                      (_wcsnicmp(pConfig->lpServiceStartName, L".\\", wcslen(L".\\"))))
                  {   
                     swprintf(string,L"ServiceAccounts.%ld.Service",count);
                     pVarSet->put(string,servStatus[i].lpServiceName);
                     swprintf(string,L"ServiceAccounts.%ld.DisplayName",count);
                     pVarSet->put(string,servStatus[i].lpDisplayName);
                     swprintf(string,L"ServiceAccounts.%ld.Account",count);
                     pVarSet->put(string,pConfig->lpServiceStartName);
                     count++;
                  }

               }
               CloseServiceHandle(pService);               
            }
            else
            {
               err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_OPEN_SERVICE_FAILED_SD,servStatus[i].lpServiceName,rc);
            }
         }
      }
      CloseServiceHandle(pScm);
   }
   else
   {
      rc = GetLastError();   
      err.SysMsgWrite(ErrE,rc,DCT_MSG_SCM_OPEN_FAILED_D,rc);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\mcspisag\csvcinf.h ===
// CSvcInf.h : Declaration of the CCSvcAcctInfo

#ifndef __CSVCACCTINFO_H_
#define __CSVCACCTINFO_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCSvcAcctInfo
class ATL_NO_VTABLE CCSvcAcctInfo : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CCSvcAcctInfo, &CLSID_CSvcAcctInfo>,
	public IDispatchImpl<IMcsDomPlugIn, &IID_IMcsDomPlugIn, &LIBID_MCSPISAGLib>,
   public ISecPlugIn
{
public:
	CCSvcAcctInfo()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CSVCACCTINFO)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCSvcAcctInfo)
	COM_INTERFACE_ENTRY(IMcsDomPlugIn)
   COM_INTERFACE_ENTRY(ISecPlugIn)
END_COM_MAP()

// IMcsDomPlugIn
public:
   STDMETHOD(GetRequiredFiles)(/* [out] */SAFEARRAY ** pArray);
   STDMETHOD(GetRegisterableFiles)(/* [out] */SAFEARRAY ** pArray);
   STDMETHOD(GetDescription)(/* [out] */ BSTR * description);
   STDMETHOD(PreMigrationTask)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(PostMigrationTask)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(GetName)(/* [out] */BSTR * name);
   STDMETHOD(GetResultString)(/* [in] */IUnknown * pVarSet,/* [out] */ BSTR * text);
   STDMETHOD(StoreResults)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(ConfigureSettings)(/*[in]*/IUnknown * pVarSet);	

   // ISecPlugIn
public:
   STDMETHOD(Verify)(/*[in,out]*/ULONG * data,/*[in]*/ULONG cbData);
   
protected:
   // Helper functions
   void ProcessServices(IVarSet * pVarSet);

};

#endif //__CSVCACCTINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\mcspisag\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__34934D09_461D_11D3_99F3_0010A4F77383__INCLUDED_)
#define AFX_DLLDATAX_H__34934D09_461D_11D3_99F3_0010A4F77383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__34934D09_461D_11D3_99F3_0010A4F77383__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\mcspisag\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "McsPISag_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\mcspisag\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by McsPISag.rc
//
#define IDS_PROJNAME                    100
#define IDR_CSVCACCTINFO                101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\trustmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\mcspisag\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__34934D01_461D_11D3_99F3_0010A4F77383__INCLUDED_)
#define AFX_STDAFX_H__34934D01_461D_11D3_99F3_0010A4F77383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__34934D01_461D_11D3_99F3_0010A4F77383__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\mcspisag\mcspisag.cpp ===
// McsPISag.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for McsPISag.idl by adding the following 
//      files to the Outputs.
//          McsPISag_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f McsPISagps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "McsPISag.h"
#include "dlldatax.h"

#include "McsPI_i.c"
#include "McsPISag_i.c"
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")

#include "CSvcInf.h"
#include "ResStr.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_CSvcAcctInfo, CCSvcAcctInfo)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

StringLoader gString;

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		ATLTRACE(_T("{McsPISag.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_MCSPISAGLib);
        DisableThreadLibraryCalls(hInstance);
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		ATLTRACE(_T("{McsPISag.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\trustmgr\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__52BFB1C6_A22F_4786_9752_A130DC59ABB4__INCLUDED_)
#define AFX_DLLDATAX_H__52BFB1C6_A22F_4786_9752_A130DC59ABB4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__52BFB1C6_A22F_4786_9752_A130DC59ABB4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\trustmgr\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "TrustMgr_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\trustmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TrustMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_TRUST_DESC                  101
#define IDR_Trust                       102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\trustmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__94D89238_AFE4_4CDA_AFE4_0F411D17E9E9__INCLUDED_)
#define AFX_STDAFX_H__94D89238_AFE4_4CDA_AFE4_0F411D17E9E9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__94D89238_AFE4_4CDA_AFE4_0F411D17E9E9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\trustmgr\trust.cpp ===
// Trust.cpp : Implementation of CTrustMgrApp and DLL registration.

#include "stdafx.h"
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#include "TrustMgr.h"
#include "Trust.h"
#include "Common.hpp"
#include "UString.hpp"
#include "ResStr.h"
#include "ErrDct.hpp"
#include "EaLen.hpp"
#include "LSAUtils.h"

#include <lm.h>
#include "GetDcName.h"
#include <iads.h>
#include <adshlp.h>
#include "ntsecapi.h"

#include "SecPI.h"
#include "cipher.hpp"

#ifndef TRUST_ATTRIBUTE_FOREST_TRANSITIVE
#define TRUST_ATTRIBUTE_FOREST_TRANSITIVE  0x00000008  // This link may contain forest trust information
#endif

StringLoader gString;
TErrorDct    err;

// This method is called by the dispatcher to verify that this is a valid plug-in
// Only valid plug-ins will be sent out with the agents
// The purpose of this check is to make it more difficult for unauthorized parties 
// to use our plug-in interface, since it is currently undocumented.
STDMETHODIMP CTrust::Verify(/*[in,out]*/ULONG * pData,/*[in]*/ULONG size)
{
   
   McsChallenge            * pMcsChallenge;
   long                      lTemp1;
   long                      lTemp2;

   if( size == sizeof(McsChallenge)  )
   {
      pMcsChallenge = (McsChallenge*)(pData);
      
      SimpleCipher((LPBYTE)pMcsChallenge,size);
      
      pMcsChallenge->MCS[0] = 'M';
      pMcsChallenge->MCS[1] = 'C';
      pMcsChallenge->MCS[2] = 'S';
      pMcsChallenge->MCS[3] = 0;

   
      lTemp1 = pMcsChallenge->lRand1 + pMcsChallenge->lRand2;
      lTemp2 = pMcsChallenge->lRand2 - pMcsChallenge->lRand1;
      pMcsChallenge->lRand1 = lTemp1;
      pMcsChallenge->lRand2 = lTemp2;
      pMcsChallenge->lTime += 100;

      SimpleCipher((LPBYTE)pMcsChallenge,size);
   }
   else
      return E_FAIL;


   return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP CTrust::QueryTrust(BSTR domTrusting, BSTR domTrusted, IUnknown **pVarSet)
{
   HRESULT                   hr = S_OK;

   return hr;
}

STDMETHODIMP CTrust::CreateTrust(BSTR domTrusting, BSTR domTrusted, BOOL bBidirectional, BOOL *pbErrorFromTrusting, BOOL *pbErrorFromTrusted)
{
   HRESULT                  hr = S_OK;
   *pbErrorFromTrusting = FALSE;
   *pbErrorFromTrusted = FALSE;
   
   hr = CheckAndCreate(domTrusting,domTrusted,NULL,NULL,NULL,NULL,NULL,NULL,TRUE,bBidirectional,pbErrorFromTrusting,pbErrorFromTrusted);
   
   return HRESULT_FROM_WIN32(hr);
}

STDMETHODIMP 
   CTrust::CreateTrustWithCreds(
      BSTR                   domTrusting,
      BSTR                   domTrusted,
      BSTR                   credTrustingDomain, 
      BSTR                   credTrustingAccount, 
      BSTR                   credTrustingPassword,
      BSTR                   credTrustedDomain, 
      BSTR                   credTrustedAccount, 
      BSTR                   credTrustedPassword,
      BOOL                   bBidirectional,
      BOOL                   *pbErrorFromTrusting,
      BOOL                   *pbErrorFromTrusted
   )
{
   HRESULT                   hr = S_OK;
   *pbErrorFromTrusting = FALSE;
   *pbErrorFromTrusted = FALSE;
   
   hr = CheckAndCreate(domTrusting,domTrusted,credTrustingDomain,credTrustingAccount,credTrustingPassword,
                        credTrustedDomain,credTrustedAccount,credTrustedPassword,TRUE,bBidirectional,
                        pbErrorFromTrusting,pbErrorFromTrusted);
   return hr;
}


STDMETHODIMP CTrust::GetRegisterableFiles(/* [out] */SAFEARRAY ** pArray)
{
   SAFEARRAYBOUND            bound[1] = { 0, 0 };
  
   // this plug-in runs locally, no files to distribute
   (*pArray) = SafeArrayCreate(VT_BSTR,1,bound);

   return S_OK;
}

STDMETHODIMP CTrust::GetRequiredFiles(/* [out] */SAFEARRAY ** pArray)
{
   SAFEARRAYBOUND            bound[1] = { 0, 0 };
   
   // this plug-in runs locally, no files to distribute
   (*pArray) = SafeArrayCreate(VT_BSTR,1,bound);

   return S_OK;
}

STDMETHODIMP CTrust::GetDescription(/* [out] */ BSTR * description)
{
   (*description) = SysAllocString(L"Sets up needed trusts between domains.");

   return S_OK;
}


BOOL IsDownLevel(WCHAR  * sComputer)
{
   BOOL                      bDownlevel = TRUE;
   WKSTA_INFO_100          * pInfo;
   
   long rc = NetWkstaGetInfo(sComputer,100,(LPBYTE*)&pInfo);
	if ( ! rc )
	{
      if ( pInfo->wki100_ver_major >= 5 )
      {
         bDownlevel = FALSE;
      }
      NetApiBufferFree(pInfo);
	}  
   return bDownlevel;
}

// Helper function that finds a trusts in our varset list
LONG CTrust::FindInboundTrust(IVarSet * pVarSet,WCHAR * sName,LONG max)
{
   LONG              ndx = -1;
   LONG              curr = 0;
   WCHAR             key[100];
   _bstr_t           tName;

   for ( curr = 0 ; curr < max ; curr++ ) 
   {
      swprintf(key,L"Trusts.%ld",curr);
      tName = pVarSet->get(key);

      if ( ! UStrICmp(tName,sName) )
      {
         // found it!
         ndx = curr;
         break;
      }
   } 
   
   return ndx;
}

HRESULT 
   CTrust::CheckAndCreateTrustingSide(
      LSA_HANDLE        hTrusting,
      WCHAR                * trustingDomain, 
      WCHAR                * trustedDomain, 
      WCHAR                * trustingComp,
      WCHAR                * trustedComp,
      WCHAR                * trustedDNSName,
      BYTE                 * trustedSid,
      BOOL                   bCreate,
      BOOL                   bBidirectional,
      BOOL                   bDownLevel,
      BOOL                 * pbErrorFromTrusting,
      BOOL                 * pbErrorFromTrusted
   )
{
   DWORD                     rc = S_OK;
   
   // if credentials are specified, use them
 
   NTSTATUS                  status;
   LSA_AUTH_INFORMATION      curr;
   LSA_AUTH_INFORMATION      prev;
   WCHAR                     password[] = L"password";
   

   if ( bCreate )
   {
     // set up the auth information for the trust relationship
     curr.AuthInfo = (LPBYTE)password;
     curr.AuthInfoLength = UStrLen(password) * sizeof(WCHAR);
     curr.AuthType = TRUST_AUTH_TYPE_CLEAR;
     curr.LastUpdateTime.QuadPart = 0;

     prev.AuthInfo = (LPBYTE)password;
     prev.AuthInfoLength = UStrLen(password) * sizeof(WCHAR);
     prev.AuthType = TRUST_AUTH_TYPE_CLEAR;
     prev.LastUpdateTime.QuadPart = 0;

     // set up the trusting side of the relationship
     if ( IsDownLevel(trustingComp) )
     {
        TRUSTED_DOMAIN_NAME_INFO               nameInfo;
  
        InitLsaString(&nameInfo.Name,const_cast<WCHAR*>(trustedDomain));
  
        status = LsaSetTrustedDomainInformation(hTrusting,trustedSid,TrustedDomainNameInformation,&nameInfo);
        rc = LsaNtStatusToWinError(status);
        if ( ! rc || rc == ERROR_ALREADY_EXISTS )
        {
           // set the password for the new trust
           TRUSTED_PASSWORD_INFO     pwdInfo;

           InitLsaString(&pwdInfo.Password,password);
           InitLsaString(&pwdInfo.OldPassword,NULL);

           status = LsaSetTrustedDomainInformation(hTrusting,trustedSid,TrustedPasswordInformation,&pwdInfo);
           rc = LsaNtStatusToWinError(status);
        }

     }
     else
     {
        
       // for Win2K domain, use LsaCreateTrustedDomainEx
        // to create the trustedDomain object.
        LSA_UNICODE_STRING                  sTemp;
        TRUSTED_DOMAIN_INFORMATION_EX       trustedInfo;
        TRUSTED_DOMAIN_AUTH_INFORMATION     trustAuth;

        InitLsaString(&sTemp, const_cast<WCHAR*>(trustedDomain));
        trustedInfo.FlatName = sTemp;

        if (bDownLevel)
            InitLsaString(&sTemp, trustedDomain);
        else
            InitLsaString(&sTemp, trustedDNSName);
        trustedInfo.Name = sTemp;

        trustedInfo.Sid = trustedSid;

        if (bDownLevel)
        {
           trustedInfo.TrustType = TRUST_TYPE_DOWNLEVEL;
        }
        else
        {
           trustedInfo.TrustType = TRUST_TYPE_UPLEVEL;
        }

        if ( bBidirectional )
           trustedInfo.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
        else
           trustedInfo.TrustDirection = TRUST_DIRECTION_OUTBOUND;

        trustedInfo.TrustAttributes = TRUST_ATTRIBUTE_NON_TRANSITIVE;

        trustAuth.IncomingAuthInfos = bBidirectional ? 1 : 0;
        trustAuth.OutgoingAuthInfos = 1;
        trustAuth.IncomingAuthenticationInformation = bBidirectional ? &curr : NULL;
        trustAuth.IncomingPreviousAuthenticationInformation = NULL;
        trustAuth.OutgoingAuthenticationInformation = &curr;
        trustAuth.OutgoingPreviousAuthenticationInformation = NULL;

        LSA_HANDLE           hTemp = NULL;

        status = LsaCreateTrustedDomainEx( hTrusting, &trustedInfo, &trustAuth, 0, &hTemp );
        rc = LsaNtStatusToWinError(status);

        // if the trust already exists, update its password
        if ( status == STATUS_OBJECT_NAME_COLLISION )
        {
           TRUSTED_DOMAIN_INFORMATION_EX       * pTrustedInfo = NULL;
           
           status = LsaQueryTrustedDomainInfo(hTrusting,trustedSid,TrustedDomainInformationEx,(LPVOID*)&pTrustedInfo);
           if ( ! status )
           {
              pTrustedInfo->TrustDirection |= trustedInfo.TrustDirection;
              status = LsaSetTrustedDomainInfoByName(hTrusting,&trustedInfo.Name,TrustedDomainInformationEx,(LPVOID*)pTrustedInfo);
              
              if ( ! status )
              {
                 status = LsaSetTrustedDomainInfoByName(hTrusting,&trustedInfo.Name,TrustedDomainAuthInformation,(LPVOID*)&trustAuth);
              }
           }
           rc = LsaNtStatusToWinError(status);
        
        }
        if( ! rc )
        {
		   if (hTemp)
              LsaClose(hTemp);
        }
     }
   }
   
   return rc;
}

HRESULT 
   CTrust::CheckAndCreateTrustedSide(
      LSA_HANDLE         hTrusted,
      WCHAR                * trustingDomain, 
      WCHAR                * trustedDomain, 
      WCHAR                * trustingComp,
      WCHAR                * trustedComp,
      WCHAR                * trustingDNSName,
      BYTE                 * trustingSid,
      BOOL                   bCreate,
      BOOL                   bBidirectional,
      BOOL                   bDownLevel,
      BOOL                 * pbErrorFromTrusting,
      BOOL                 * pbErrorFromTrusted
   )
{
   DWORD                     rc = S_OK;
   LSA_HANDLE                hTrusting = NULL;
   NTSTATUS                  status;
   LSA_AUTH_INFORMATION      curr;
   LSA_AUTH_INFORMATION      prev;
   WCHAR                     password[] = L"password";
   
  // set up the auth information for the trust relationship
  curr.AuthInfo = (LPBYTE)password;
  curr.AuthInfoLength = UStrLen(password) * sizeof(WCHAR);
  curr.AuthType = TRUST_AUTH_TYPE_CLEAR;
  curr.LastUpdateTime.QuadPart = 0;

  prev.AuthInfo = (LPBYTE)password;
  prev.AuthInfoLength = UStrLen(password) * sizeof(WCHAR);
  prev.AuthType = TRUST_AUTH_TYPE_CLEAR;
  prev.LastUpdateTime.QuadPart = 0;
  // set up the trusted side of the relationship
  if ( IsDownLevel(trustedComp) )
  {
        // create an inter-domain trust account for the trusting domain on the trusted domain
     USER_INFO_1          uInfo;
     DWORD                parmErr;
     WCHAR                name[LEN_Account];

     memset(&uInfo,0,(sizeof uInfo));

     UStrCpy(name,trustingDomain);
     name[UStrLen(name) + 1] = 0;
     name[UStrLen(name)] = L'$';

     if ( ! bCreate )
     {
        USER_INFO_1       * tempInfo = NULL;

        rc = NetUserGetInfo(trustedComp,name,1,(LPBYTE*)&tempInfo);
        if ( ! rc )
        {
           // the trust exists
           NetApiBufferFree(tempInfo);
           rc = NERR_UserExists;
        }
        else
        {
           if ( rc != NERR_UserNotFound )
           {
              err.SysMsgWrite(ErrE,rc,DCT_MSG_TRUSTING_DOM_GETINFO_FAILED_SSD,trustingDomain,trustedComp,rc);
           }
        }
     }
     else
     {
        // this creates the trust account if it doesn't already exist
        // if the account does exist, reset its password
        uInfo.usri1_flags = UF_SCRIPT | UF_INTERDOMAIN_TRUST_ACCOUNT;
        uInfo.usri1_name = name;
        uInfo.usri1_password = password;
        uInfo.usri1_priv = 1;

        rc = NetUserAdd(trustedComp,1,(LPBYTE)&uInfo,&parmErr);
        if ( rc && rc != NERR_UserExists )
        {
           err.SysMsgWrite(ErrE,rc,DCT_MSG_TRUSTING_DOM_CREATE_FAILED_SSD,trustingDomain,trustedDomain,rc);
        }
        else if ( rc == NERR_UserExists )
        {
           // reset the password for the existing trust account
           USER_INFO_1003    pwdInfo;
           DWORD             parmErr;

           pwdInfo.usri1003_password = password;
           rc = NetUserSetInfo(trustedComp,name,1003,(LPBYTE)&pwdInfo,&parmErr);
        }

     }
  }
  else
  {
     // Win2K, all trusts exist as trusted domain objects
     // Create the trustedDomain object.
     LSA_UNICODE_STRING                  sTemp;
     TRUSTED_DOMAIN_INFORMATION_EX       trustedInfo;
     TRUSTED_DOMAIN_AUTH_INFORMATION     trustAuth;
  
     InitLsaString(&sTemp, const_cast<WCHAR*>(trustingDomain));
     trustedInfo.FlatName = sTemp;

     if (bDownLevel)
        InitLsaString(&sTemp, trustingDomain);
     else
        InitLsaString(&sTemp, trustingDNSName);
     trustedInfo.Name = sTemp;

     trustedInfo.Sid = trustingSid;

     if (bDownLevel)
     {
        trustedInfo.TrustType = TRUST_TYPE_DOWNLEVEL;
     }
     else
     {
        trustedInfo.TrustType = TRUST_TYPE_UPLEVEL;
     }
  
     if ( bBidirectional )
        trustedInfo.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
     else
        trustedInfo.TrustDirection = TRUST_DIRECTION_INBOUND;
  
     trustedInfo.TrustAttributes = TRUST_ATTRIBUTE_NON_TRANSITIVE;

     trustAuth.IncomingAuthInfos = 1;
     trustAuth.OutgoingAuthInfos = bBidirectional ? 1 : 0;
     trustAuth.OutgoingAuthenticationInformation = bBidirectional ? &curr : NULL;
     trustAuth.OutgoingPreviousAuthenticationInformation = NULL;
     trustAuth.IncomingAuthenticationInformation = &curr;
     trustAuth.IncomingPreviousAuthenticationInformation = NULL;

     if ( bCreate )
     {
        status = LsaCreateTrustedDomainEx( hTrusted, &trustedInfo, &trustAuth, POLICY_VIEW_LOCAL_INFORMATION | 
                                      POLICY_TRUST_ADMIN | POLICY_CREATE_SECRET, &hTrusting );
        if ( status == STATUS_OBJECT_NAME_COLLISION )
        {
           TRUSTED_DOMAIN_INFORMATION_EX       * pTrustedInfo = NULL;

           // Get the old information
           status = LsaQueryTrustedDomainInfoByName(hTrusted,&sTemp,TrustedDomainInformationEx,(LPVOID*)&pTrustedInfo);
           if ( ! status )
           {
              pTrustedInfo->TrustAttributes |= trustedInfo.TrustAttributes;
              pTrustedInfo->TrustDirection |= trustedInfo.TrustDirection;

              status = LsaSetTrustedDomainInfoByName(hTrusted,&sTemp,TrustedDomainInformationEx,pTrustedInfo);

              if (! status )
              {
                 status = LsaSetTrustedDomainInfoByName(hTrusted,&sTemp,TrustedDomainAuthInformation,&trustAuth);
              }
              LsaFreeMemory(pTrustedInfo);
           }

        }
     }
     else
     {
        TRUSTED_DOMAIN_INFORMATION_EX       * pTrustedInfo = NULL;

        status = LsaQueryTrustedDomainInfoByName(hTrusted,&sTemp,TrustedDomainInformationEx,(LPVOID*)&pTrustedInfo);
        if ( ! status )
        {
           LsaFreeMemory(pTrustedInfo);
        }

     }
     rc = LsaNtStatusToWinError(status);
     if ( ! rc )
     {
        LsaClose(hTrusting);
        hTrusting = NULL;
     }
  }
  if ( bCreate && bBidirectional && IsDownLevel(trustingComp) )
  {
     // set up the trust account for the other side of the relationship 
     // For Win2K, both sides of the bidirectional trust are handled together,
     // but NT4 bidirectional trusts require 2 separate actions
     USER_INFO_1          uInfo;
     DWORD                parmErr;
     WCHAR                name2[LEN_Account];

     memset(&uInfo,0,(sizeof uInfo));

     UStrCpy(name2,trustedDomain);
     name2[UStrLen(name2) + 1] = 0;
     name2[UStrLen(name2)] = L'$';

     uInfo.usri1_flags = UF_SCRIPT | UF_INTERDOMAIN_TRUST_ACCOUNT;
     uInfo.usri1_name = name2;
     uInfo.usri1_password = password;
     uInfo.usri1_priv = 1;

     
     rc = NetUserAdd(trustingComp,1,(LPBYTE)&uInfo,&parmErr);
     if ( rc == NERR_UserExists )
     {
        LPUSER_INFO_1          puInfo;
        rc = NetUserGetInfo(trustingComp, name2, 1, (LPBYTE*)&puInfo);
        if ( !rc ) 
        {
           puInfo->usri1_flags &= UF_INTERDOMAIN_TRUST_ACCOUNT;
           puInfo->usri1_password = password;
           rc = NetUserSetInfo(trustingComp,name2,1,(LPBYTE)puInfo,&parmErr);   
           NetApiBufferFree(puInfo);
        }
        else
        {
           err.MsgWrite(0, DCT_MSG_INVALID_ACCOUNT_S, name2);
        }
     }
     else if ( rc )
     {
        err.SysMsgWrite(ErrE,rc,DCT_MSG_TRUSTING_DOM_CREATE_FAILED_SSD,trustingDomain,trustedDomain,rc);
     }
  }
   
   return rc;
}

// Main function used to create trusts
HRESULT 
   CTrust::CheckAndCreate(
      WCHAR                * trustingDomain, 
      WCHAR                * trustedDomain, 
      WCHAR                * credDomainTrusting,
      WCHAR                * credAccountTrusting,
      WCHAR                * credPasswordTrusting,
      WCHAR                * credDomainTrusted,
      WCHAR                * credAccountTrusted,
      WCHAR                * credPasswordTrusted,
      BOOL                   bCreate,
      BOOL                   bBidirectional,
      BOOL                 * pbErrorFromTrusting,
      BOOL                 * pbErrorFromTrusted
   )
{
   DWORD                     rc = 0;
   _bstr_t                   trustingDom;
   _bstr_t                   trustedDom;
   _bstr_t                   trustingComp;
   _bstr_t                   trustedComp;
   _bstr_t                   trustingDNSName;
   _bstr_t                   trustedDNSName;
   BYTE                      trustingSid[200];
   BYTE                      trustedSid[200];
   WCHAR                     name[LEN_Account];
   DWORD                     lenName = DIM(name);
   DWORD                     lenSid = DIM(trustingSid);
   SID_NAME_USE              snu;
   WCHAR                   * curr = NULL;     
   BOOL                      bConnectTrusted = FALSE;
   BOOL                      bConnectTrusting = FALSE;
   LSA_HANDLE                hTrusting = NULL;
   LSA_HANDLE                hTrusted = NULL;
   BOOL                      bDownLevel = FALSE;

   // Get the DC names, and domain SIDs for the source and target domains
   rc = GetDomainNames5(trustingDomain, trustingDom, trustingDNSName);
   if (rc)
       *pbErrorFromTrusting = TRUE;

   if (!rc)
   {
       rc = GetDomainNames5(trustedDomain, trustedDom, trustedDNSName);
       if (rc)
        *pbErrorFromTrusted = TRUE;
   }

   if (!rc)
   {
       // check whether the trust should be down level or not
       if (!trustingDNSName || !trustedDNSName)
        bDownLevel = TRUE;

       rc = GetDcName5(trustingDom, DS_PDC_REQUIRED, trustingComp);
       if ( rc )
       {
          *pbErrorFromTrusting = TRUE;
          err.SysMsgWrite(ErrE,rc,DCT_MSG_GET_DCNAME_FAILED_SD,trustingDom,rc);
       }
   }

   if ( ! rc )
   {
      rc = GetDcName5(trustedDom, DS_PDC_REQUIRED, trustedComp);
      if ( rc )
      {
         *pbErrorFromTrusted = TRUE;
         err.SysMsgWrite(ErrE,rc,DCT_MSG_GET_DCNAME_FAILED_SD,trustedDom,rc);
      }
   }   

   if (!rc)
   {
       if ( credAccountTrusted && *credAccountTrusted )
       {
          if ( EstablishSession(trustedComp,credDomainTrusted,credAccountTrusted,credPasswordTrusted,TRUE) )
          {
             bConnectTrusted = TRUE;
          }
          else
          {
             rc = GetLastError();
             *pbErrorFromTrusted = TRUE;
          }
       }
   }

   if (!rc)
   {
       if ( credAccountTrusting && *credAccountTrusting )
       {
          if ( EstablishSession(trustingComp,credDomainTrusting,credAccountTrusting,credPasswordTrusting,TRUE) )
          {
             bConnectTrusting = TRUE;
          }
          else
          {
             rc = GetLastError();
             *pbErrorFromTrusting = TRUE;
          }
       }
   }
   
   // Need to get the computer name and the SIDs for the domains.
   if ( ! rc && ! LookupAccountName(trustingComp,trustingDom,trustingSid,&lenSid,name,&lenName,&snu) )
   {
      rc = GetLastError();
      *pbErrorFromTrusting = TRUE;
      err.SysMsgWrite(ErrE,rc,DCT_MSG_GET_DOMAIN_SID_FAILED_1,trustingDom,rc);
   }
   lenSid = DIM(trustedSid);
   lenName = DIM(name);
   if (! rc && ! LookupAccountName(trustedComp,trustedDom,trustedSid,&lenSid,name,&lenName,&snu) )
   {
      rc = GetLastError();
      *pbErrorFromTrusted = TRUE;
      err.SysMsgWrite(ErrE,rc,DCT_MSG_GET_DOMAIN_SID_FAILED_1,trustedDom,rc);
   }
         
   // check whether we are able to call CheckAndCreateTrustedSide and CheckAndCreateTrustingSide
   // we need to be able to open policy to trusting and trusted computers with the following access right
   //   POLICY_VIEW_LOCAL_INFORMATION
   //   POLICY_TRUST_ADMIN
   //   POLICY_CREATE_SECRET
   if (!rc)
   {
        NTSTATUS status;
        WCHAR* szComputerFailed = NULL;
        status = OpenPolicy(trustingComp,
                                        POLICY_VIEW_LOCAL_INFORMATION|POLICY_TRUST_ADMIN|POLICY_CREATE_SECRET,
                                        &hTrusting);
        if (status == STATUS_SUCCESS)
        {
            status = OpenPolicy(trustedComp,
                                            POLICY_VIEW_LOCAL_INFORMATION|POLICY_TRUST_ADMIN|POLICY_CREATE_SECRET,
                                            &hTrusted);
            if (status != STATUS_SUCCESS)
            {
                szComputerFailed = trustedComp;
                *pbErrorFromTrusted = TRUE;
            }
        }
        else
        {
            szComputerFailed = trustingComp;
            *pbErrorFromTrusting = TRUE;
        }
        rc = LsaNtStatusToWinError(status);
        if (rc != ERROR_SUCCESS)
            err.SysMsgWrite(ErrE, rc, DCT_MSG_LSA_OPEN_FAILED_SD, szComputerFailed, rc);
   }

   // check the trusted side of the trust first
   if ( ! rc )
   {
      rc = CheckAndCreateTrustedSide(hTrusted, trustingDom,trustedDom,trustingComp,trustedComp,trustingDNSName,trustingSid,
                                       bCreate,bBidirectional, bDownLevel, pbErrorFromTrusting, pbErrorFromTrusted);
   }
   if ( ! rc )
   {
      rc = CheckAndCreateTrustingSide(hTrusting,trustingDom,trustedDom,trustingComp,trustedComp,trustedDNSName,trustedSid,
                                       bCreate,bBidirectional, bDownLevel, pbErrorFromTrusting, pbErrorFromTrusted);
   }

   // close LSA_HANDLE hTrusting and hTrusted
   if (hTrusting != NULL)
        LsaClose(hTrusting);
   if (hTrusted)
        LsaClose(hTrusted);

   if ( bConnectTrusted )
   {
      EstablishSession(trustedComp,credDomainTrusted,credAccountTrusted,credPasswordTrusted,FALSE);
   }

   if ( bConnectTrusting )
   {
      EstablishSession(trustingComp,credDomainTrusting,credAccountTrusting,credPasswordTrusting,FALSE);
   }
   
   
   return HRESULT_FROM_WIN32(rc);
}

long CTrust::EnumerateTrustedDomains(WCHAR * domain,BOOL bIsTarget,IVarSet * pVarSet,long ndxStart)
{
   DWORD                     rcOs;         // OS return code
   LSA_HANDLE                hPolicy;
   NTSTATUS                  status;
   _bstr_t                   computer;
   DOMAIN_CONTROLLER_INFO  * pInfo;
   WCHAR                     sName[LEN_Domain];
   WCHAR                     key[100];
   long                      ndxTrust = ndxStart;
/*   PDS_DOMAIN_TRUSTS		 *ChildDomains;
   ULONG					 numChilds;
*/
   err.MsgWrite(0,DCT_MSG_ENUMERATING_TRUSTED_DOMAINS_S,domain);

   // open a handle to the source domain
   rcOs = GetAnyDcName5(domain, computer);
   if ( rcOs )
   {
      err.SysMsgWrite(ErrE,rcOs,DCT_MSG_GET_DCNAME_FAILED_SD,domain,rcOs);
   }
  
   if ( ! rcOs )
   {
      if ( IsDownLevel(computer) )
      {
		  //Enumerate the trusted domains until there are no more to return.
		  status = OpenPolicy(computer, POLICY_VIEW_LOCAL_INFORMATION ,&hPolicy);
		  if ( status == STATUS_SUCCESS )
		  {
         
			 LSA_ENUMERATION_HANDLE    lsaEnumHandle=0; // start an enum
			 PLSA_TRUST_INFORMATION    trustInfo = NULL;
			 ULONG                     ulReturned;               // number of items returned
			 NTSTATUS                  status;
			 DWORD                     rc;   

			 do {
   
				status = LsaEnumerateTrustedDomains(
							  hPolicy,        // open policy handle
							  &lsaEnumHandle, // enumeration tracker
							  (void**)&trustInfo,     // buffer to receive data
							  32000,          // recommended buffer size
							  &ulReturned     // number of items returned
							  );

				 //Check the return status for error.
				rc = LsaNtStatusToWinError(status);
				if( (rc != ERROR_SUCCESS) &&
					 (rc != ERROR_MORE_DATA) &&
					 (rc != ERROR_NO_MORE_ITEMS)
					 ) 
				 {
					 err.SysMsgWrite(ErrE,rcOs,DCT_MSG_TRUSTED_ENUM_FAILED_SD,domain,rcOs);
				 } 
				 else 
				 {
				   // . . . Code to use the Trusted Domain information
				   for ( ULONG ndx = 0 ; ndx < ulReturned ; ndx++ )
				   {
					  _bstr_t        direction;

					  UStrCpy(sName,trustInfo[ndx].Name.Buffer, ( trustInfo[ndx].Name.Length / (sizeof WCHAR)) + 1);

                  
					  TRUSTED_DOMAIN_INFORMATION_EX       * pTrustedInfo = NULL;

					  status = LsaQueryTrustedDomainInfo(hPolicy,trustInfo[ndx].Sid,TrustedDomainInformationEx,(LPVOID*)&pTrustedInfo);
					  if ( ! status )
					  {
						 switch ( pTrustedInfo->TrustDirection )
						 {
						 case TRUST_DIRECTION_DISABLED:
							direction = GET_BSTR(IDS_TRUST_DIRECTION_DISABLED);
							break;
						 case TRUST_DIRECTION_INBOUND:
							direction = GET_BSTR(IDS_TRUST_DIRECTION_INBOUND);
							break;
						 case TRUST_DIRECTION_OUTBOUND:
							direction = GET_BSTR(IDS_TRUST_DIRECTION_OUTBOUND);
							break;
						 case TRUST_DIRECTION_BIDIRECTIONAL:
							direction = GET_BSTR(IDS_TRUST_DIRECTION_BIDIRECTIONAL);
							break;
						 default:
							break;
                        
						 };
						 if ( ! bIsTarget )
						 {
							swprintf(key,L"Trusts.%ld.Type",ndxTrust);
							pVarSet->put(key, GET_BSTR(IDS_TRUST_RELATION_EXTERNAL));
						 }
						 LsaFreeMemory(pTrustedInfo);

					  }
					  else
					  {
						 rcOs = LsaNtStatusToWinError(status);
						 // My logic here is that we are checking Trusted domains here so this is atleast true
						 // check whether this trust is already listed as an inbound trust
	//*                     direction = L"Outbound";
						 direction = GET_BSTR(IDS_TRUST_DIRECTION_OUTBOUND);
					  }
					  if ( ! bIsTarget )
					  {
						 swprintf(key,L"Trusts.%ld",ndxTrust);
						 pVarSet->put(key,sName);
                     
						 swprintf(key,L"Trusts.%ld.Direction",ndxTrust);
						 pVarSet->put(key,direction);
						 swprintf(key,L"Trusts.%ld.ExistsForTarget",ndxTrust);
	//*                     pVarSet->put(key,L"No");
						 pVarSet->put(key,GET_BSTR(IDS_No));
                        
						 err.MsgWrite(0,DCT_MSG_SOURCE_TRUSTS_THIS_SS,sName,domain);
					  }
					  long ndx2 = FindInboundTrust(pVarSet,sName,ndxTrust);
					  if ( ndx2 != -1 )
					  {
						 if ( ! bIsTarget )
						 {
							// we've already seen this trust as an inbound trust
							// update the existing record!
							WCHAR key2[1000];
							swprintf(key2,L"Trusts.%ld.Direction",ndx2);
	//*                        pVarSet->put(key2,L"Bidirectional");
							pVarSet->put(key2,GET_BSTR(IDS_TRUST_DIRECTION_BIDIRECTIONAL));
							continue;  // don't update the trust entry index, since we used the existing 
							// entry instead of creating a new one
						 }
						 else
						 {
							swprintf(key,L"Trusts.%ld.ExistsForTarget",ndx2);
	//*                        pVarSet->put(key,L"Yes");
							pVarSet->put(key,GET_BSTR(IDS_YES));
							err.MsgWrite(0,DCT_MSG_TARGET_TRUSTS_THIS_SS,domain,sName);
						 }

					  }
					  swprintf(key,L"Trusts.%ld.ExistsForTarget",ndxTrust);
                  
					  // check the trusted domain, to see if the target already trusts it
					  //if ( UStrICmp(sName,target) )
					 // {
					 //    continue;
					 // }
					  if ( ! bIsTarget )
						 ndxTrust++;
				   }
				   // Free the buffer.
				   LsaFreeMemory(trustInfo);
				 }
			 } while (rc == ERROR_SUCCESS || rc == ERROR_MORE_DATA );
			 LsaClose(hPolicy);
		  }
		}
		else
		{
			ULONG ulCount;
			PDS_DOMAIN_TRUSTS pDomainTrusts;

			DWORD dwError = DsEnumerateDomainTrusts(
				computer,
				DS_DOMAIN_IN_FOREST|DS_DOMAIN_DIRECT_INBOUND|DS_DOMAIN_DIRECT_OUTBOUND,
				&pDomainTrusts,
				&ulCount
			);

			if (dwError == NO_ERROR)
			{
				ULONG ulIndex;
				ULONG ulDomainIndex = (ULONG)-1L;
				ULONG ulParentIndex = (ULONG)-1L;

				// find local domain

				for (ulIndex = 0; ulIndex < ulCount; ulIndex++)
				{
					if (pDomainTrusts[ulIndex].Flags & DS_DOMAIN_PRIMARY)
					{
						ulDomainIndex = ulIndex;

						if (!(pDomainTrusts[ulIndex].Flags & DS_DOMAIN_TREE_ROOT))
						{
							ulParentIndex = pDomainTrusts[ulIndex].ParentIndex;
						}
						break;
					}
				}

				for (ulIndex = 0; ulIndex < ulCount; ulIndex++)
				{
					DS_DOMAIN_TRUSTS& rDomainTrust = pDomainTrusts[ulIndex];

					// filter out indirect trusts

					if (!(rDomainTrust.Flags & (DS_DOMAIN_DIRECT_INBOUND|DS_DOMAIN_DIRECT_OUTBOUND)))
					{
						continue;
					}

					// trusted or trusting domain name

                    _bstr_t bstrName(rDomainTrust.DnsDomainName ? rDomainTrust.DnsDomainName : rDomainTrust.NetbiosDomainName);

					// trust direction

					_bstr_t bstrDirection;

					switch (rDomainTrust.Flags & (DS_DOMAIN_DIRECT_INBOUND|DS_DOMAIN_DIRECT_OUTBOUND))
					{
						case DS_DOMAIN_DIRECT_INBOUND:
							bstrDirection = GET_BSTR(IDS_TRUST_DIRECTION_INBOUND);
							break;
						case DS_DOMAIN_DIRECT_OUTBOUND:
							bstrDirection = GET_BSTR(IDS_TRUST_DIRECTION_OUTBOUND);
							break;
						case DS_DOMAIN_DIRECT_INBOUND|DS_DOMAIN_DIRECT_OUTBOUND:
							bstrDirection = GET_BSTR(IDS_TRUST_DIRECTION_BIDIRECTIONAL);
							break;
						default:
						//	bstrDirection = ;
							break;
					}

					// trust relationship

					_bstr_t bstrRelationship;

					if (ulIndex == ulParentIndex)
					{
						bstrRelationship = GET_BSTR(IDS_TRUST_RELATION_PARENT);
					}
					else if (rDomainTrust.Flags & DS_DOMAIN_IN_FOREST)
					{
						if (rDomainTrust.ParentIndex == ulDomainIndex)
						{
							bstrRelationship = GET_BSTR(IDS_TRUST_RELATION_CHILD);
						}
						else if ((rDomainTrust.Flags & DS_DOMAIN_TREE_ROOT) && (pDomainTrusts[ulDomainIndex].Flags & DS_DOMAIN_TREE_ROOT))
						{
							bstrRelationship = GET_BSTR(IDS_TRUST_RELATION_ROOT);
						}
						else
						{
							bstrRelationship = GET_BSTR(IDS_TRUST_RELATION_SHORTCUT);
						}
					}
					else
					{
						switch (rDomainTrust.TrustType)
						{
							case TRUST_TYPE_DOWNLEVEL:
							case TRUST_TYPE_UPLEVEL:
								bstrRelationship = (rDomainTrust.TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) ? GET_BSTR(IDS_TRUST_RELATION_FOREST) : GET_BSTR(IDS_TRUST_RELATION_EXTERNAL);
								break;
							case TRUST_TYPE_MIT:
								bstrRelationship = GET_BSTR(IDS_TRUST_RELATION_MIT);
								break;
							default:
								bstrRelationship = GET_BSTR(IDS_TRUST_RELATION_UNKNOWN);
								break;
						}
					}

					if (bIsTarget)
					{
						// if same trust was found on source domain and the trust
						// directions match update exists for target to yes

						LONG lSourceIndex = FindInboundTrust(pVarSet, bstrName, ndxTrust);

						if (lSourceIndex >= 0)
						{
							// get source trust direction

							swprintf(key, L"Trusts.%ld.Direction", lSourceIndex);

							_bstr_t bstrSourceDirection = pVarSet->get(key);

							// if target trust direction is bi-directional or
							// target trust direction equals source trust direction
							// then set exists for target to yes

							bool bExists = false;

							if (bstrDirection == GET_BSTR(IDS_TRUST_DIRECTION_BIDIRECTIONAL))
							{
								bExists = true;
							}
							else if (bstrDirection == bstrSourceDirection)
							{
								bExists = true;
							}

							if (bExists)
							{
								swprintf(key, L"Trusts.%ld.ExistsForTarget", lSourceIndex);

								pVarSet->put(key, GET_BSTR(IDS_YES));

								// write trust directions to log

								if (rDomainTrust.Flags & DS_DOMAIN_DIRECT_OUTBOUND)
								{
									err.MsgWrite(0, DCT_MSG_TARGET_TRUSTS_THIS_SS, domain, (LPCTSTR)bstrName); 
								}

								if (rDomainTrust.Flags & DS_DOMAIN_DIRECT_INBOUND)
								{
									err.MsgWrite(0, DCT_MSG_TARGET_TRUSTED_BY_THIS_SS, domain, (LPCTSTR)bstrName);
								}
							}
						}
					}
					else
					{
						// domain name
						swprintf(key, L"Trusts.%ld", ndxTrust);
						pVarSet->put(key, bstrName);

						// trust direction
						swprintf(key, L"Trusts.%ld.Direction", ndxTrust);
						pVarSet->put(key, bstrDirection);

						// trust relationship

						if (bstrRelationship.length() > 0)
						{
							swprintf(key, L"Trusts.%ld.Type", ndxTrust);
							pVarSet->put(key, bstrRelationship);
						}

						// trust exists on target
						// initially set to no until target domain is enumerated
						swprintf(key, L"Trusts.%ld.ExistsForTarget", ndxTrust);
						pVarSet->put(key, GET_BSTR(IDS_No));

						// write trust directions to log

						if (rDomainTrust.Flags & DS_DOMAIN_DIRECT_OUTBOUND)
						{
							err.MsgWrite(0, DCT_MSG_SOURCE_TRUSTS_THIS_SS, (LPCTSTR)bstrName, domain);
						}

						if (rDomainTrust.Flags & DS_DOMAIN_DIRECT_INBOUND)
						{
							err.MsgWrite(0, DCT_MSG_SOURCE_IS_TRUSTED_BY_THIS_SS, (LPCTSTR)bstrName, domain);
						}

						++ndxTrust;
					}
				}

				NetApiBufferFree(pDomainTrusts);
			}
			else
			{
				 err.SysMsgWrite(ErrE, dwError, DCT_MSG_TRUSTED_ENUM_FAILED_SD, domain, dwError);
			}
		}
   }
   if ( bIsTarget )
   {
      // make sure we have "Yes" for the target domain itself
      long ndx2 = FindInboundTrust(pVarSet,domain,ndxTrust);
      if ( ndx2 != -1 )
      {
         swprintf(key,L"Trusts.%ld.ExistsForTarget",ndx2);
//*         pVarSet->put(key,L"Yes");
         pVarSet->put(key,GET_BSTR(IDS_YES));
      }
   }
   return ndxTrust;
}

long CTrust::EnumerateTrustingDomains(WCHAR * domain,BOOL bIsTarget,IVarSet * pVarSet,long ndxStart)
{
   DWORD                     rcOs;         // OS return code
   DWORD                     hEnum=0;      // enumeration handle
   USER_INFO_1             * pNetUsers=NULL; // NetUserEnum array buffer
   USER_INFO_1             * pNetUser;     // NetUserEnum array item
   DWORD                     nRead;        // Entries read.
   DWORD                     nTotal;       // Entries total.
   WCHAR                     sName[LEN_Domain]; // Domain name
   WCHAR                   * pNameEnd;     // Null at end
   _bstr_t                   computer;
   DOMAIN_CONTROLLER_INFO  * pInfo;
   long                      ndx = ndxStart;
   WCHAR                     key[100];

   err.MsgWrite(0,DCT_MSG_ENUMERATING_TRUSTING_DOMAINS_S,domain);
   rcOs = GetAnyDcName5(domain, computer);
   if ( rcOs )
   {
      return ndx;
   }

   // get the trusting domains for the NT 4 domain
   // for Win2K domains, the trusting domains will be listed as Incoming in the Trusted Domain enumeration
   if ( IsDownLevel(computer) )
   {
      do
      {
         nRead = 0;
         nTotal = 0;
         rcOs = NetUserEnum(
               computer,
               1,
               FILTER_INTERDOMAIN_TRUST_ACCOUNT,
               (BYTE **) &pNetUsers,
               10240,
               &nRead,
               &nTotal,
               &hEnum );
         switch ( rcOs )
         {
            case 0:
            case ERROR_MORE_DATA:
               for ( pNetUser = pNetUsers;
                     pNetUser < pNetUsers + nRead;
                     pNetUser++ )
               {
                  // skip trust accounts whose password age is older than 30 days to avoid
                  // delays caused by trying to enumerate defunct trusts
                  if ( pNetUser->usri1_password_age > 60 * 60 * 24 * 30 ) // 30 days (age is in seconds)
                  {
                     err.MsgWrite(0,DCT_MSG_SKIPPING_OLD_TRUST_SD,pNetUser->usri1_name,
                        pNetUser->usri1_password_age / ( 60*60*24) );
                     continue;
                  }

                  safecopy( sName, pNetUser->usri1_name );
                  pNameEnd = sName + UStrLen( sName );
                  if ( (pNameEnd > sName) && (pNameEnd[-1] == L'$') )
                  {
                     pNameEnd[-1] = L'\0';
                  }
                  if ( *sName )
                  {
                     // Found a (probably) valid trust!
                     if ( ! bIsTarget )
                     {
                        // for the source domain, simply add the trusts to the list in the varset
                        swprintf(key,L"Trusts.%ld",ndx);
                        pVarSet->put(key,sName);
                        swprintf(key,L"Trusts.%ld.Direction",ndx);
//*                        pVarSet->put(key,L"Inbound");
                        pVarSet->put(key,GET_BSTR(IDS_TRUST_DIRECTION_INBOUND));
						swprintf(key,L"Trusts.%ld.Type",ndx);
						pVarSet->put(key, GET_BSTR(IDS_TRUST_RELATION_EXTERNAL));
                        swprintf(key,L"Trusts.%ld.ExistsForTarget",ndx);
//*                        pVarSet->put(key,L"No");
                        pVarSet->put(key,GET_BSTR(IDS_No));
                        err.MsgWrite(0,DCT_MSG_SOURCE_IS_TRUSTED_BY_THIS_SS,sName,domain);
                        ndx++;
                     }
                     else
                     {
                        // for the target domain, look for this trust in the varset 
                        // and if it is there, mark that it exists on the target
                        long ndxTemp = FindInboundTrust(pVarSet,sName,ndxStart);
                        if ( ndxTemp != -1  )
                        {
                           swprintf(key,L"Trusts.%ld.ExistsForTarget",ndxTemp);
//*                           pVarSet->put(key,L"Yes");
                           pVarSet->put(key,GET_BSTR(IDS_YES));
                           err.MsgWrite(0,DCT_MSG_TARGET_TRUSTS_THIS_SS,sName,domain);
                        }
                     }
                  }
               }
               break;
            default:
               break;
         }
         if ( pNetUsers )
         {
            NetApiBufferFree( pNetUsers );
            pNetUsers = NULL;
         }
      
      
      }  while ( rcOs == ERROR_MORE_DATA );
   }
   
   // Win2K domain, don't need to enumerate the trusting domains here - they will all be included in the
   // trusted domain enum
         
   return ndx;
}

/*void CheckProc(void * arg,void * data)
{
   CTrust                  * tr = (CTrust*)arg;
}*/


STDMETHODIMP CTrust::PreMigrationTask(/* [in] */IUnknown * pVarSet)
{
/* IVarSetPtr              pVS = pVarSet;
   BOOL                    bCreate;
   _bstr_t                 source = pVS->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t                 target = pVS->get(GET_BSTR(DCTVS_Options_TargetDomain));
   _bstr_t                 logfile = pVS->get(GET_BSTR(DCTVS_Options_Logfile));
   _bstr_t                 localOnly = pVS->get(GET_BSTR(DCTVS_Options_LocalProcessingOnly));
   _bstr_t                 docreate = pVS->get(L"Options.CreateTrusts");

   if ( !UStrICmp(localOnly,GET_STRING(IDS_YES)) )
   {
      // don't do anything in local agent mode
      return S_OK;
   }
   
   if ( !UStrICmp(docreate,GET_STRING(IDS_YES)) )
   {
      bCreate = TRUE;
   }
   else
   {
      bCreate = FALSE;
   }
   pVS->put(GET_BSTR(DCTVS_CurrentOperation),L"Verifying trust relationships");
   

   err.LogOpen(logfile,1);
   err.LevelBeepSet(1000);
  
   err.LogClose();
*/ 
   return S_OK;
}

STDMETHODIMP CTrust::PostMigrationTask(/* [in] */IUnknown * pVarSet)
{
   return S_OK;
}


STDMETHODIMP CTrust::GetName(/* [out] */BSTR * name)
{
   (*name) = SysAllocString(L"Trust Manager");
   
   return S_OK;
}

STDMETHODIMP CTrust::GetResultString(/* [in] */IUnknown * pVarSet,/* [out] */ BSTR * text)
{
   WCHAR                     buffer[100] = L"";
   IVarSetPtr                pVS;

   pVS = pVarSet;

   
   (*text) = SysAllocString(buffer);
   
   return S_OK;
}

STDMETHODIMP CTrust::StoreResults(/* [in] */IUnknown * pVarSet)
{
   return S_OK;
}

STDMETHODIMP CTrust::ConfigureSettings(/*[in]*/IUnknown * pVarSet)
{
   return S_OK;
}

STDMETHODIMP CTrust::QueryTrusts(BSTR domainSource,BSTR domainTarget, BSTR sLogFile, IUnknown **pVarSet)
{
   HRESULT              hr = S_OK;
   IVarSetPtr           pVS(CLSID_VarSet);
   long                 ndx;

   _bstr_t sFile = sLogFile;
   err.LogOpen((WCHAR*) sFile, 1);
   err.LevelBeepSet(1000);
   hr = pVS.QueryInterface(IID_IUnknown,(long**)pVarSet);
   
   // Add a blank line to help differentiate different runs
   err.MsgWrite(0,DCT_MSG_GENERIC_S,L"");
   ndx = EnumerateTrustingDomains(domainSource,FALSE,pVS,0);
   EnumerateTrustingDomains(domainTarget,TRUE,pVS,0);
   ndx = EnumerateTrustedDomains(domainSource,FALSE,pVS,ndx);
   EnumerateTrustedDomains(domainTarget,TRUE,pVS,ndx);
   
   //err.LogClose();
   pVS->put(L"Trusts",ndx);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\trustmgr\trust.h ===
// Trust.h: Definition of the CTrust class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TRUST_H__BB315DAC_1A59_4EAC_99A0_2BFEFE6F1501__INCLUDED_)
#define AFX_TRUST_H__BB315DAC_1A59_4EAC_99A0_2BFEFE6F1501__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <ntsecapi.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CTrust
#include "ErrDct.hpp"

typedef void (*PPROCESSFN)(void * arg,void * data);

class CTrust : 
	public ITrust,
	public CComObjectRoot,
   public IDispatchImpl<IMcsDomPlugIn, &IID_IMcsDomPlugIn, &LIBID_TRUSTMGRLib>,
	public CComCoClass<CTrust,&CLSID_Trust>,
   public ISecPlugIn
{
public:
	CTrust() {}
BEGIN_COM_MAP(CTrust)
	COM_INTERFACE_ENTRY(ITrust)
   COM_INTERFACE_ENTRY(IMcsDomPlugIn)
   COM_INTERFACE_ENTRY(ISecPlugIn)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTrust) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_Trust)

// ITrust
public:
	STDMETHOD(CreateTrust)(BSTR domTrusting, BSTR domTrusted, BOOL bBidirectional, /*[out]*/BOOL *pbErrorFromTrusting, /*[out]*/BOOL *pbErrorFromTrusted);
	STDMETHOD(QueryTrust)(BSTR domainSource, BSTR domainTrust, /*[out]*/IUnknown ** pVarSet);
   STDMETHOD(QueryTrusts)(BSTR domainSource,BSTR domainTarget,/*[in]*/BSTR sLogFile,/*out*/IUnknown ** pVarSet);
   STDMETHOD(CreateTrustWithCreds)(BSTR domTrusting, BSTR domTrusted,
                     BSTR credTrustingDomain, BSTR credTrustingAccount, BSTR credTrustingPassword,
                     BSTR credTrustedDomain, BSTR credTrustedAccount, BSTR credTrustedPassword, BOOL bBidirectional, /*[out]*/BOOL *pbErrorFromTrusting, /*[out]*/BOOL *pbErrorFromTrusted);


   // IMcsDomPlugIn
public:
   STDMETHOD(GetRequiredFiles)(/* [out] */SAFEARRAY ** pArray);
   STDMETHOD(GetRegisterableFiles)(/* [out] */SAFEARRAY ** pArray);
   STDMETHOD(GetDescription)(/* [out] */ BSTR * description);
   STDMETHOD(PreMigrationTask)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(PostMigrationTask)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(GetName)(/* [out] */BSTR * name);
   STDMETHOD(GetResultString)(/* [in] */IUnknown * pVarSet,/* [out] */ BSTR * text);
   STDMETHOD(StoreResults)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(ConfigureSettings)(/*[in]*/IUnknown * pVarSet);	
// ISecPlugIn
public:
   STDMETHOD(Verify)(/*[in,out]*/ULONG * data,/*[in]*/ULONG cbData);
protected:
   long EnumerateTrustingDomains(WCHAR * domain,BOOL bIsTarget,IVarSet * pVarSet,long ndxStart);
   long EnumerateTrustedDomains(WCHAR * domain,BOOL bIsTarget,IVarSet * pVarSet, long ndxStart);
   LONG FindInboundTrust(IVarSet * pVarSet,WCHAR * sName,LONG max);

   HRESULT 
   CTrust::CheckAndCreate(
      WCHAR                * trustingDomain, 
      WCHAR                * trustedDomain, 
      WCHAR                * credDomainTrusting,
      WCHAR                * credAccountTrusting,
      WCHAR                * credPasswordTrusting,
      WCHAR                * credDomainTrusted,
      WCHAR                * credAccountTrusted,
      WCHAR                * credPasswordTrusted,
      BOOL                   bCreate,
      BOOL                   bBidirectional,
      BOOL                 * pbErrorFromTrusting,
      BOOL                 * pbErrorFromTrusted
   );

   HRESULT 
   CTrust::CheckAndCreateTrustingSide(
      LSA_HANDLE        hTrusting,
      WCHAR                * trustingDomain, 
      WCHAR                * trustedDomain, 
      WCHAR                * trustingComp,
      WCHAR                * trustedComp,
      WCHAR                * trustedDNSName,
      BYTE                 * trustedSid,
      BOOL                   bCreate,
      BOOL                   bBidirectional,
      BOOL                   bDownLevel,
      BOOL                 * pbErrorFromTrusting,
      BOOL                 * pbErrorFromTrusted
   );
   HRESULT 
   CTrust::CheckAndCreateTrustedSide(
      LSA_HANDLE        hTrusted,
      WCHAR                * trustingDomain, 
      WCHAR                * trustedDomain, 
      WCHAR                * trustingComp,
      WCHAR                * trustedComp,
      WCHAR                * trustingDNSName,
      BYTE                 * trustingSid,
      BOOL                   bCreate,
      BOOL                   bBidirectional,
      BOOL                   bDownLevel,
      BOOL                 * pbErrorFromTrusting,
      BOOL                 * pbErrorFromTrusted
   );

   
};

#endif // !defined(AFX_TRUST_H__BB315DAC_1A59_4EAC_99A0_2BFEFE6F1501__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\plugins\trustmgr\trustmgr.cpp ===
// TrustMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for TrustMgr.idl by adding the following 
//      files to the Outputs.
//          TrustMgr_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f TrustMgrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "TrustMgr.h"
#include "dlldatax.h"

#include "TrustMgr_i.c"
#include "McsPI_i.c"

//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")

#include "Trust.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Trust, CTrust)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TRUSTMGRLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\pwdsvc\lsaparammacros.h ===
//
// Macros for setting fields in an SE_AUDIT_PARAMETERS array.
//
// These must be kept in sync with identical macros in ds\security\base\lsa\server\adtp.h.
//


#define LsapSetParmTypeSid( AuditParameters, Index, Sid )                      \
    {                                                                          \
        if( Sid ) {                                                            \
                                                                               \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeSid;         \
        (AuditParameters).Parameters[(Index)].Length = RtlLengthSid( (Sid) );  \
        (AuditParameters).Parameters[(Index)].Address = (Sid);                 \
                                                                               \
        } else {                                                               \
                                                                               \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeNone;        \
        (AuditParameters).Parameters[(Index)].Length = 0;                      \
        (AuditParameters).Parameters[(Index)].Address = NULL;                  \
                                                                               \
        }                                                                      \
    }


#define LsapSetParmTypeAccessMask( AuditParameters, Index, AccessMask, ObjectTypeIndex ) \
    {                                                                                    \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeAccessMask;            \
        (AuditParameters).Parameters[(Index)].Length = sizeof( ACCESS_MASK );            \
        (AuditParameters).Parameters[(Index)].Data[0] = (AccessMask);                    \
        (AuditParameters).Parameters[(Index)].Data[1] = (ObjectTypeIndex);               \
    }



#define LsapSetParmTypeString( AuditParameters, Index, String )                \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeString;      \
        (AuditParameters).Parameters[(Index)].Length =                         \
                sizeof(UNICODE_STRING)+(String)->Length;                       \
        (AuditParameters).Parameters[(Index)].Address = (String);              \
    }



#define LsapSetParmTypeUlong( AuditParameters, Index, Ulong )                  \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeUlong;       \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (Ulong) );     \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG)(Ulong);        \
    }

#define LsapSetParmTypeHexUlong( AuditParameters, Index, Ulong )                  \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeHexUlong;       \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (Ulong) );     \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG)(Ulong);        \
    }

#define LsapSetParmTypeNoLogon( AuditParameters, Index )                       \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeNoLogonId;   \
    }



#define LsapSetParmTypeLogonId( AuditParameters, Index, LogonId )              \
    {                                                                          \
        PLUID TmpLuid;                                                         \
                                                                               \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeLogonId;     \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (LogonId) );   \
        TmpLuid = (PLUID)(&(AuditParameters).Parameters[(Index)].Data[0]);     \
        *TmpLuid = (LogonId);                                                  \
    }


#define LsapSetParmTypePrivileges( AuditParameters, Index, Privileges )                      \
    {                                                                                        \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypePrivs;                     \
        (AuditParameters).Parameters[(Index)].Length = LsapPrivilegeSetSize( (Privileges) ); \
        (AuditParameters).Parameters[(Index)].Address = (Privileges);                        \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\pwdsvc\admtcrypt2.cpp ===
//#include <StdAfx.h>
#include "AdmtCrypt2.h"

#include <NtSecApi.h>

#pragma comment( lib, "AdvApi32.lib" )


namespace AdmtCrypt2
{

#define SESSION_KEY_SIZE    16 // in bytes

HCRYPTKEY __stdcall DeriveEncryptionKey(HCRYPTPROV hProvider);
bool __stdcall IsDataMatchHash(HCRYPTPROV hProvider, const _variant_t& vntData, const _variant_t& vntHash);

// Provider Methods

HCRYPTKEY __stdcall DeriveKey(HCRYPTPROV hProvider, const _variant_t& vntBytes);
HCRYPTHASH __stdcall CreateHash(HCRYPTPROV hProvider);
bool __stdcall GenRandom(HCRYPTPROV hProvider, BYTE* pbData, DWORD cbData);

// Key Methods

void __stdcall DestroyKey(HCRYPTKEY hKey);
bool __stdcall Decrypt(HCRYPTKEY hKey, const _variant_t& vntEncrypted, _variant_t& vntDecrypted);

// Hash Methods

void __stdcall DestroyHash(HCRYPTHASH hHash);
bool __stdcall HashData(HCRYPTHASH hHash, const _variant_t& vntData);

// Miscellaneous Helpers

bool __stdcall RetrieveEncryptionBytes(_variant_t& vntBytes);

// Variant Helpers

bool __stdcall CreateByteArray(DWORD cb, _variant_t& vntByteArray);

}

using namespace AdmtCrypt2;


//---------------------------------------------------------------------------
// Source Crypt API
//---------------------------------------------------------------------------


// AdmtAcquireContext Method

HCRYPTPROV __stdcall AdmtAcquireContext()
{
	HCRYPTPROV hProvider = 0;

	BOOL bAcquire = CryptAcquireContext(
		&hProvider,
		NULL,
		MS_ENHANCED_PROV,
		PROV_RSA_FULL,
		CRYPT_MACHINE_KEYSET|CRYPT_VERIFYCONTEXT
	);

	if (!bAcquire)
	{
		hProvider = 0;
	}

	return hProvider;
}


// AdmtReleaseContext Method

void __stdcall AdmtReleaseContext(HCRYPTPROV hProvider)
{
	if (hProvider)
	{
		CryptReleaseContext(hProvider, 0);
	}
}


// AdmtImportSessionKey Method

HCRYPTKEY __stdcall AdmtImportSessionKey(HCRYPTPROV hProvider, const _variant_t& vntEncryptedSessionBytes)
{
	HCRYPTKEY hSessionKey = 0;

	if (hProvider && (vntEncryptedSessionBytes.vt == (VT_UI1|VT_ARRAY)) && ((vntEncryptedSessionBytes.parray != NULL)))
	{
		HCRYPTKEY hEncryptionKey = DeriveEncryptionKey(hProvider);

		if (hEncryptionKey)
		{
			_variant_t vntDecryptedSessionBytes;

			if (Decrypt(hEncryptionKey, vntEncryptedSessionBytes, vntDecryptedSessionBytes))
			{
				if (vntDecryptedSessionBytes.parray->rgsabound[0].cElements > SESSION_KEY_SIZE)
				{
					// extract session key bytes

					_variant_t vntBytes;

					if (CreateByteArray(SESSION_KEY_SIZE, vntBytes))
					{
						memcpy(vntBytes.parray->pvData, vntDecryptedSessionBytes.parray->pvData, SESSION_KEY_SIZE);

						// extract hash of session key bytes

						_variant_t vntHashValue;

						DWORD cbHashValue = vntDecryptedSessionBytes.parray->rgsabound[0].cElements - SESSION_KEY_SIZE;

						if (CreateByteArray(cbHashValue, vntHashValue))
						{
							memcpy(vntHashValue.parray->pvData, (BYTE*)vntDecryptedSessionBytes.parray->pvData + SESSION_KEY_SIZE, cbHashValue);

							if (IsDataMatchHash(hProvider, vntBytes, vntHashValue))
							{
								hSessionKey = DeriveKey(hProvider, vntBytes);
							}
						}
					}
				}
				else
				{
					SetLastError(ERROR_INVALID_PARAMETER);
				}
			}

			DestroyKey(hEncryptionKey);
		}
	}
	else
	{
		SetLastError(ERROR_INVALID_PARAMETER);
	}

	return hSessionKey;
}


// AdmtDecrypt Method

_bstr_t __stdcall AdmtDecrypt(HCRYPTKEY hSessionKey, const _variant_t& vntEncrypted)
{
	BSTR bstr = NULL;

	_variant_t vntDecrypted;

	if (Decrypt(hSessionKey, vntEncrypted, vntDecrypted))
	{
		HRESULT hr = BstrFromVector(vntDecrypted.parray, &bstr);

		if (FAILED(hr))
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		}
	}

	return _bstr_t(bstr, false);
}


// AdmtDestroyKey Method

void __stdcall AdmtDestroyKey(HCRYPTKEY hKey)
{
	DestroyKey(hKey);
}


//---------------------------------------------------------------------------
// Private Helpers
//---------------------------------------------------------------------------


namespace AdmtCrypt2
{


HCRYPTKEY __stdcall DeriveEncryptionKey(HCRYPTPROV hProvider)
{
	HCRYPTKEY hKey = 0;

	_variant_t vntBytes;

	if (RetrieveEncryptionBytes(vntBytes))
	{
		hKey = DeriveKey(hProvider, vntBytes);
	}

	return hKey;
}


bool __stdcall IsDataMatchHash(HCRYPTPROV hProvider, const _variant_t& vntData, const _variant_t& vntHash)
{
	bool bMatch = false;

	HCRYPTHASH hHash = CreateHash(hProvider);

	if (hHash)
	{
		if (HashData(hHash, vntData))
		{
			DWORD dwSizeA;
			DWORD cbSize = sizeof(DWORD);

			if (CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&dwSizeA, &cbSize, 0))
			{
				DWORD dwSizeB = vntHash.parray->rgsabound[0].cElements;

				if (dwSizeA == dwSizeB)
				{
					BYTE* pbA = new BYTE[dwSizeA];

                    if (pbA)
                    {
						if (CryptGetHashParam(hHash, HP_HASHVAL, pbA, &dwSizeA, 0))
						{
							BYTE* pbB = (BYTE*) vntHash.parray->pvData;

							if (memcmp(pbA, pbB, dwSizeA) == 0)
							{
								bMatch = true;
							}
						}

                        delete [] pbA;
                    }
                    else
                    {
						SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    }
				}
			}
		}
	}

	return bMatch;
}


// Provider Methods


HCRYPTKEY __stdcall DeriveKey(HCRYPTPROV hProvider, const _variant_t& vntBytes)
{
	HCRYPTKEY hKey = 0;

	HCRYPTHASH hHash = CreateHash(hProvider);

	if (hHash)
	{
		if (HashData(hHash, vntBytes))
		{
			if (!CryptDeriveKey(hProvider, CALG_3DES, hHash, 0, &hKey))
			{
				hKey = 0;
			}
		}

		DestroyHash(hHash);
	}

	return hKey;
}


HCRYPTHASH __stdcall CreateHash(HCRYPTPROV hProvider)
{
	HCRYPTHASH hHash;

	if (!CryptCreateHash(hProvider, CALG_SHA1, 0, 0, &hHash))
	{
		hHash = 0;
	}

	return hHash;
}


bool __stdcall GenRandom(HCRYPTPROV hProvider, BYTE* pbData, DWORD cbData)
{
	return CryptGenRandom(hProvider, cbData, pbData) ? true : false;
}


// Key Methods --------------------------------------------------------------


// DestroyKey Method

void __stdcall DestroyKey(HCRYPTKEY hKey)
{
	if (hKey)
	{
		CryptDestroyKey(hKey);
	}
}


// Decrypt Method

bool __stdcall Decrypt(HCRYPTKEY hKey, const _variant_t& vntEncrypted, _variant_t& vntDecrypted)
{
	bool bDecrypted = false;

	_variant_t vnt = vntEncrypted;

	if ((vnt.vt == (VT_UI1|VT_ARRAY)) && (vnt.parray != NULL))
	{
		// decrypt data

		BYTE* pb = (BYTE*) vnt.parray->pvData;
		DWORD cb = vnt.parray->rgsabound[0].cElements;

		if (CryptDecrypt(hKey, NULL, TRUE, 0, pb, &cb))
		{
			// create decrypted byte array
			// the number of decrypted bytes may be less than
			// the number of encrypted bytes

			vntDecrypted.parray = SafeArrayCreateVector(VT_UI1, 0, cb);

			if (vntDecrypted.parray != NULL)
			{
				vntDecrypted.vt = VT_UI1|VT_ARRAY;

				memcpy(vntDecrypted.parray->pvData, vnt.parray->pvData, cb);

				bDecrypted = true;
			}
			else
			{
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			}
		}
	}
	else
	{
		SetLastError(ERROR_INVALID_PARAMETER);
	}

	return bDecrypted;
}


// Hash Methods -------------------------------------------------------------


// DestroyHash Method

void __stdcall DestroyHash(HCRYPTHASH hHash)
{
	if (hHash)
	{
		CryptDestroyHash(hHash);
	}
}


// HashData Method

bool __stdcall HashData(HCRYPTHASH hHash, const _variant_t& vntData)
{
	bool bHash = false;

	if ((vntData.vt == (VT_UI1|VT_ARRAY)) && ((vntData.parray != NULL)))
	{
		if (CryptHashData(hHash, (BYTE*)vntData.parray->pvData, vntData.parray->rgsabound[0].cElements, 0))
		{
			bHash = true;
		}
	}
	else
	{
		SetLastError(ERROR_INVALID_PARAMETER);
	}

	return bHash;
}


// Miscellaneous Helpers ----------------------------------------------------


// RetrieveEncryptionBytes Method

bool __stdcall RetrieveEncryptionBytes(_variant_t& vntBytes)
{
	// private data key identifier
	_TCHAR c_szIdPrefix[] = _T("L$6A2899C0-CECE-459A-B5EB-7ED04DE61388");
	const USHORT c_cbIdPrefix = sizeof(c_szIdPrefix) - sizeof(_TCHAR);

	bool bRetrieve = false;

	// open policy object

	LSA_HANDLE hPolicy;

	LSA_OBJECT_ATTRIBUTES lsaoa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

	NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &lsaoa, POLICY_GET_PRIVATE_INFORMATION, &hPolicy);

	if (LSA_SUCCESS(ntsStatus))
	{
		// retrieve data

		LSA_UNICODE_STRING lsausKey = { c_cbIdPrefix, c_cbIdPrefix, c_szIdPrefix };
		PLSA_UNICODE_STRING plsausData;

		ntsStatus = LsaRetrievePrivateData(hPolicy, &lsausKey, &plsausData);

		if (LSA_SUCCESS(ntsStatus))
		{
			vntBytes.Clear();

			vntBytes.parray = SafeArrayCreateVector(VT_UI1, 0, plsausData->Length);

			if (vntBytes.parray != NULL)
			{
				vntBytes.vt = VT_UI1|VT_ARRAY;

				memcpy(vntBytes.parray->pvData, plsausData->Buffer, plsausData->Length);

				bRetrieve = true;
			}
			else
			{
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			}

			LsaFreeMemory(plsausData);
		}
		else
		{
			SetLastError(LsaNtStatusToWinError(ntsStatus));
		}

		// close policy object

		LsaClose(hPolicy);
	}
	else
	{
		SetLastError(LsaNtStatusToWinError(ntsStatus));
	}

	return bRetrieve;
}


// Variant Helpers ----------------------------------------------------------


// CreateByteArray Method

bool __stdcall CreateByteArray(DWORD cb, _variant_t& vntByteArray)
{
	bool bCreate = false;

	vntByteArray.Clear();

	vntByteArray.parray = SafeArrayCreateVector(VT_UI1, 0, cb);

	if (vntByteArray.parray)
	{
		bCreate = true;
	}
	else
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
	}

	vntByteArray.vt = VT_UI1|VT_ARRAY;

	return bCreate;
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\pwdsvc\admtcrypt2.h ===
#pragma once

#include <TChar.h>
#include <Windows.h>
#include <WinCrypt.h>
#include <ComDef.h>


HCRYPTPROV __stdcall AdmtAcquireContext();
void __stdcall AdmtReleaseContext(HCRYPTPROV hProvider);

HCRYPTKEY __stdcall AdmtImportSessionKey(HCRYPTPROV hProvider, const _variant_t& vntEncryptedSessionBytes);

_bstr_t __stdcall AdmtDecrypt(HCRYPTKEY hKey, const _variant_t& vntEncrypted);
void __stdcall AdmtDestroyKey(HCRYPTKEY hKey);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\pwdsvc\mschapp.h ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    mschapp - MS-CHAP Password Change API

Abstract:

    These APIs correspond to the MS-CHAP RFC -2433 sections 9 and 10. In order
    to develop an MS-CHAP RAS server that works with an NT domain, these APIs
    are required.

    The MS-CHAP change password APIs are exposed through a DLL that is obtained
    from PSS. This DLL is not distributed with NT4.0 or Win2000. It is up to
    the ISV to install this with their product. The DLL name is MSCHAPP.DLL.

    Only wide (Unicode) versions of these apis will be available. These are the
    2 callable APIs:

    *   MSChapSrvChangePassword
    *   MsChapSrvChangePassword2

Author:

    Doug Barlow (dbarlow) 10/12/1999

Remarks:

    Per original definition by John Brezak

Notes:

    ?Notes?

--*/

#ifndef _MSCHAPP_H_
#define _MSCHAPP_H_
#ifdef __cplusplus
extern "C" {
#endif


//
// The following definitions are copied from the crypt.h internal header
// file.  The definitions are duplicated here to simplify linkages.
//

#ifndef _NTCRYPT_
#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    CHAR    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;
//#endif

#define SAM_MAX_PASSWORD_LENGTH     (256)
typedef struct _SAMPR_ENCRYPTED_USER_PASSWORD {
    UCHAR Buffer[ (SAM_MAX_PASSWORD_LENGTH * 2) + 4 ];
} SAMPR_ENCRYPTED_USER_PASSWORD, *PSAMPR_ENCRYPTED_USER_PASSWORD;

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
} ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;
#endif


//
// Change a password.
//

extern NTSTATUS WINAPI
MSChapSrvChangePassword(
   IN LPWSTR ServerName,
   IN LPWSTR UserName,
   IN BOOLEAN LmOldPresent,
   IN PLM_OWF_PASSWORD LmOldOwfPassword,
   IN PLM_OWF_PASSWORD LmNewOwfPassword,
   IN PNT_OWF_PASSWORD NtOldOwfPassword,
   IN PNT_OWF_PASSWORD NtNewOwfPassword);


//
// Change a password using mutual encryption.
//

extern NTSTATUS WINAPI
MSChapSrvChangePassword2(
    IN LPWSTR ServerName,
    IN LPWSTR UserName,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    IN BOOLEAN LmPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLmOrNt);

#ifdef __cplusplus
}
#endif
#endif // _MSCHAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\pwdsvc\pwd.h ===
/* common includes for this dll */
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#include <nt.h>
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h
#include <rpc.h>        // DataTypes and runtime APIs
#include <string.h>     // strlen
#include <stdio.h>      // sprintf
//#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <samrpc.h>     // midl generated SAM RPC definitions
#include <ntlsa.h>
#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
extern "C"{
#include <samisrv.h>    // SamIConnect()
}

#include <ntsam.h>
#include <ntsamp.h>
#include <samsrv.h>     // prototypes available to security process

#include <lsarpc.h>
//#include <lsaisrv.h>
#include <ntrmlsa.h>
#include <ntseapi.h>
#include <ntpsapi.h>
#include <ntobapi.h>
#include <rpcdcep.h>
#include <ntexapi.h>
#include <ntregapi.h>
#include "msaudite.h"
#include "LsaParamMacros.h"

extern "C"{
#include "mschapp.h"
}

#pragma comment(lib, "vccomsup.lib")

/* common functions for this dll */
//NTSTATUS __stdcall GetDomainHandle(SAMPR_HANDLE *pDomainHandle);

extern CRITICAL_SECTION	csADMTCriticalSection; //critical sectio to protect concurrent first-time access
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\pwdsvc\pwdrpc.cpp ===
/*---------------------------------------------------------------------------
  File: PwdRpc.cpp

  Comments:  RPC interface for Password Migration Lsa Notification Package
             and other internal functions.

  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 09/04/00

 ---------------------------------------------------------------------------
*/


#include "Pwd.h"
#include <lmcons.h>
#include <comdef.h>
#include <malloc.h>
#include "PwdSvc.h"
#include "McsDmMsg.h"
#include "AdmtCrypt2.h"
#include "pwdfuncs.h"
#include "TReg.hpp"
#include "IsAdmin.hpp"
#include "ResStr.h"
#include "TxtSid.h"
#include "resource.h"
#include <MsPwdMig.h>

/* global definitions */
#define STATUS_NULL_LM_PASSWORD          ((NTSTATUS)0x4000000DL)
#define LM_BUFFER_LENGTH    (LM20_PWLEN + 1)
typedef NTSTATUS (CALLBACK * LSAIWRITEAUDITEVENT)(PSE_ADT_PARAMETER_ARRAY, ULONG);
typedef NTSTATUS (* PLSAIAUDITPASSWORDACCESSEVENT)(USHORT EventType, PCWSTR pszTargetUserName, PCWSTR pszTargetUserDomain);

#ifndef SECURITY_MAX_SID_SIZE
#define SECURITY_MAX_SID_SIZE (sizeof(SID) - sizeof(DWORD) + (SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)))
#endif

/* global variables */
CRITICAL_SECTION	csADMTCriticalSection; //critical sectio to protect concurrent first-time access
SAMPR_HANDLE		hgDomainHandle = NULL; //domain handle used in password calls
LM_OWF_PASSWORD		NullLmOwfPassword; //NULL representation of an LM Owf Password
NT_OWF_PASSWORD		NullNtOwfPassword; //NULL representation of an NT Owf Password
HCRYPTPROV g_hProvider = 0;
HCRYPTKEY g_hSessionKey = 0;
HANDLE	hEventSource;
HMODULE hLsaDLL = NULL;
LSAIWRITEAUDITEVENT LsaIWriteAuditEvent = NULL;
PLSAIAUDITPASSWORDACCESSEVENT LsaIAuditPasswordAccessEvent = NULL;
PWCHAR	pDomain = NULL;
BOOL LsapCrashOnAuditFail = TRUE;
int nOSVer = 4;
BOOL bWhistlerDC = FALSE;
static const WCHAR PASSWORD_AUDIT_TEXT_ENGLISH[] = L"Password Hash Audit Event.  Password of the following user accessed:     Target User Name: %s     Target User Domain: %s     By user:     Caller SID: %s";


/* Checks if this machine is running Whistler OS or something even newer and the OS major verison number, sets global variables accordingly */
void GetOS()
{
/* local constants */
   const int	WINDOWS_2000_BUILD_NUMBER = 2195;

/* local variables */
   TRegKey		verKey, regComputer;
   DWORD		rc = 0;
   WCHAR		sBuildNum[MAX_PATH];

/* function body */
	  //connect to the DC's HKLM registry key
   rc = regComputer.Connect(HKEY_LOCAL_MACHINE, NULL);
   if (rc == ERROR_SUCCESS)
   {
         //see if this machine is running Windows XP or newer by checking the
		 //build number in the registry.  If not, then we don't need to check
		 //for the new security option
      rc = verKey.OpenRead(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",&regComputer);
	  if (rc == ERROR_SUCCESS)
	  {
			//get the CurrentBuildNumber string
	     rc = verKey.ValueGetStr(L"CurrentBuildNumber", sBuildNum, MAX_PATH);
		 if (rc == ERROR_SUCCESS) 
		 {
			int nBuild = _wtoi(sBuildNum);
		    if (nBuild <= WINDOWS_2000_BUILD_NUMBER)
               bWhistlerDC = FALSE;
			else
               bWhistlerDC = TRUE;
		 }
			//get the Version Number
	     rc = verKey.ValueGetStr(L"CurrentVersion", sBuildNum, MAX_PATH);
		 if (rc == ERROR_SUCCESS) 
			nOSVer = _wtoi(sBuildNum);
	  }
   }
   return;
}


_bstr_t GetString(DWORD dwID)
{
/* local variables */
    HINSTANCE       m_hInstance = NULL;
    WCHAR           sBuffer[1000];
    _bstr_t         bstrRet;

/* function body */
    m_hInstance = LoadLibrary(L"PwMig.dll");

    if (m_hInstance)
    {
        if (LoadString(m_hInstance, dwID, sBuffer, 1000) > 0)
        {
            // prevent uncaught exception due to low memory condition

            try
            {
                bstrRet = sBuffer;
            }
            catch (...)
            {
                ;
            }
        }

        FreeLibrary(m_hInstance);
    }

    return bstrRet;
}


/***************************
 * Event Logging Functions *
 ***************************/

 
/*++

Routine Description:

    Implements current policy of how to deal with a failed audit.

Arguments:

    None.

Return Value:

    None.

--*/
void LsapAuditFailed(NTSTATUS AuditStatus)
{
/* local variables */
    NTSTATUS	Status;
    ULONG		Response;
    ULONG_PTR	HardErrorParam;
    BOOLEAN		PrivWasEnabled;
	TRegKey		verKey, regComputer;
	DWORD		rc = 0;
	WCHAR		sBuildNum[MAX_PATH];
	DWORD		crashVal;
	BOOL		bRaiseError = FALSE;


/* function body */
		//connect to this machine's HKLM registry key
	rc = regComputer.Connect(HKEY_LOCAL_MACHINE, NULL);
	if (rc == ERROR_SUCCESS)
	{
         //open the LSA key and see if crash on audit failed is turned on
		rc = verKey.Open(L"SYSTEM\\CurrentControlSet\\Control\\Lsa",&regComputer);
		if (rc == ERROR_SUCCESS)
		{
				//get the CrashOnAuditFail value
			rc = verKey.ValueGetDWORD(CRASH_ON_AUDIT_FAIL_VALUE, &crashVal);
			if (rc == ERROR_SUCCESS) 
			{ 
				   //if crash on audit fail is set, turn off the flag
				if (crashVal == LSAP_CRASH_ON_AUDIT_FAIL)
				{
					bRaiseError = TRUE; //set flag to raise hard error
					rc = verKey.ValueSetDWORD(CRASH_ON_AUDIT_FAIL_VALUE, LSAP_ALLOW_ADIMIN_LOGONS_ONLY);
					if (rc == ERROR_SUCCESS)
					{
							//flush the key to disk
						do 
						{
							Status = NtFlushKey(verKey.KeyGet());
						} while ((Status == STATUS_INSUFFICIENT_RESOURCES) || (Status == STATUS_NO_MEMORY));
						ASSERT(NT_SUCCESS(Status));
					}
				}
			}
		}
	}

		//if needed,  raise a hard error
	if (bRaiseError)
	{
		HardErrorParam = AuditStatus;

			// enable the shutdown privilege so that we can bugcheck
		Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE, TRUE, FALSE, &PrivWasEnabled);

		Status = NtRaiseHardError(
						 STATUS_AUDIT_FAILED,
						 1,
						 0,
						 &HardErrorParam,
						 OptionShutdownSystem,
						 &Response);
	}
	return;
}


/*Routine Description:

    Find out if auditing is enabled for a certain event category and
    event success/failure case.

Arguments:

    AuditCategory - Category of event to be audited.
        e.g. AuditCategoryPolicyChange

    AuditEventType - status type of event
        e.g. EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

Return Value:

    TRUE or FALSE
*/
BOOL LsapAdtIsAuditingEnabledForCategory(POLICY_AUDIT_EVENT_TYPE AuditCategory,
										 UINT AuditEventType)
{
   BOOL						 bSuccess = FALSE;
   LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
   NTSTATUS                  status = 0;
   LSA_HANDLE                hPolicy;
    
   ASSERT((AuditEventType == EVENTLOG_AUDIT_SUCCESS) ||
          (AuditEventType == EVENTLOG_AUDIT_FAILURE));

      //attempt to open the policy.
   ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));//object attributes are reserved, so initalize to zeroes.
   status = LsaOpenPolicy(	NULL,
							&ObjectAttributes,
							POLICY_READ,
							&hPolicy);  //recieves the policy handle

   if (NT_SUCCESS(status))
   {
         //ask for audit event policy information
      PPOLICY_AUDIT_EVENTS_INFO   info;
      status = LsaQueryInformationPolicy(hPolicy, PolicyAuditEventsInformation, (PVOID *)&info);
      if (NT_SUCCESS(status))
      {
		    //if auditing is enabled, see if enable for this type
		 if (info->AuditingMode)
		 {
			POLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
			EventAuditingOptions = info->EventAuditingOptions[AuditCategory];

			bSuccess = (AuditEventType == EVENTLOG_AUDIT_SUCCESS) ?
						(BOOL) (EventAuditingOptions & POLICY_AUDIT_EVENT_SUCCESS):
						(BOOL) (EventAuditingOptions & POLICY_AUDIT_EVENT_FAILURE);
		 }

		 LsaFreeMemory((PVOID) info); //free policy info structure
      }
      
      LsaClose(hPolicy); //Freeing the policy object handle
   }
    
   return bSuccess;
}


/*++

Routine Description:

    This routine impersonates our client, opens the thread token, and
    extracts the User Sid.  It puts the Sid in memory allocated via
    LsapAllocateLsaHeap, which must be freed by the caller.

Arguments:

    None.

Return Value:

    Returns a pointer to heap memory containing a copy of the Sid, or
    NULL.

--*/
NTSTATUS LsapQueryClientInfo(PTOKEN_USER *UserSid, PLUID AuthenticationId)
{
	NTSTATUS Status = STATUS_SUCCESS;
    HANDLE TokenHandle;
    ULONG ReturnLength;
    TOKEN_STATISTICS TokenStats;

	   //impersonate the caller
    Status = I_RpcMapWin32Status(RpcImpersonateClient(NULL));

    if (!NT_SUCCESS(Status))
        return( Status );

	   //open the thread token
    Status = NtOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,                    // OpenAsSelf
                     &TokenHandle);

    if (!NT_SUCCESS(Status))
	{
		I_RpcMapWin32Status(RpcRevertToSelf());
        return( Status );
	}

	   //revert to self
    Status = I_RpcMapWin32Status(RpcRevertToSelf());
	ASSERT(NT_SUCCESS(Status));

	   //get the size of the token information
    Status = NtQueryInformationToken (
                 TokenHandle,
                 TokenUser,
                 NULL,
                 0,
                 &ReturnLength);

    if (Status != STATUS_BUFFER_TOO_SMALL) 
	{
        NtClose(TokenHandle);
        return( Status );
    }

	   //allocate memory to hold the token info
    *UserSid = (PTOKEN_USER)malloc(ReturnLength);

    if (*UserSid == NULL) 
	{
        NtClose(TokenHandle);
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

	   //get the token info
    Status = NtQueryInformationToken (
                 TokenHandle,
                 TokenUser,
                 *UserSid,
                 ReturnLength,
                 &ReturnLength);


    if (!NT_SUCCESS(Status)) 
	{
        NtClose(TokenHandle);
        free(*UserSid);
        *UserSid = NULL;
        return( Status );
    }

	   //get the authentication ID
	ReturnLength = 0;
    Status = NtQueryInformationToken (
                 TokenHandle,
                 TokenStatistics,
                 (PVOID)&TokenStats,
                 sizeof(TOKEN_STATISTICS),
                 &ReturnLength);

    NtClose(TokenHandle);

    if (!NT_SUCCESS(Status)) 
	{
        free(*UserSid);
        *UserSid = NULL;
        return( Status );
    }

    *AuthenticationId = TokenStats.AuthenticationId;

	return Status;
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 23 APR 2001                                                 *
 *                                                                   *
 *     This function is responsible for generating a                 *
 * SE_AUDITID_PASSWORD_HASH_ACCESS event in the security log. This   *
 * function is called to generate that message when a user password  *
 * hash is retrieved by the ADMT password filter DLL.                *
 * All these event logging functions are copied and modified from LSA*
 * code written by others.                                           *
 *                                                                   *
 * Parameters:                                                       *
 * EventType - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE      *
 * pszTargetUserName - name of user whose password is being retrieved*
 * pszTargetUserDomain - domain of user whose password is being      *
 *                       retrieved                                   *
 *                                                                   *
 * Return Value:                                                     *
 * HRESULT - Standard Return Result                                  *
 *                                                                   *
 *********************************************************************/

//BEGIN LsaAuditPasswordAccessEvent
HRESULT LsaAuditPasswordAccessEvent(USHORT EventType, 
									PCWSTR pszTargetUserName,
									PCWSTR pszTargetUserDomain)
{
/* local constants */
    const int W2K_VERSION_NUMBER = 5;

/* local variables */
    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };
    PSE_ADT_PARAMETER_ARRAY_ENTRY Parameter;
    UNICODE_STRING TargetUser;
    UNICODE_STRING TargetDomain;
    UNICODE_STRING SubsystemName;
    UNICODE_STRING Explanation;
    _bstr_t sExplainText;

/* function body */
    //if parameters are invalid, return
    if ( !((EventType == EVENTLOG_AUDIT_SUCCESS) ||
        (EventType == EVENTLOG_AUDIT_FAILURE))   ||
        !pszTargetUserName  || !pszTargetUserDomain ||
        !*pszTargetUserName || !*pszTargetUserDomain )
    {
        return (HRESULT_FROM_WIN32(LsaNtStatusToWinError(STATUS_INVALID_PARAMETER)));
    }

    //If audit password access event function is available
    if (LsaIAuditPasswordAccessEvent)
    {
        Status = LsaIAuditPasswordAccessEvent(EventType, pszTargetUserName, pszTargetUserDomain);
    }
    else if (LsaIWriteAuditEvent)
    {
        //if auditing is not enabled, return asap
        if (!LsapAdtIsAuditingEnabledForCategory(AuditCategoryAccountManagement, EventType))
            return S_OK;

        // get caller info from the thread token
        Status = LsapQueryClientInfo( &TokenUserInformation, &ClientAuthenticationId );
        if (!NT_SUCCESS( Status ))
        {
            LsapAuditFailed(Status);
            return (HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status)));
        }

        //init UNICODE_STRINGS
        RtlInitUnicodeString(&TargetUser, pszTargetUserName);
        RtlInitUnicodeString(&TargetDomain, pszTargetUserDomain);
        RtlInitUnicodeString(&SubsystemName, L"Security");
        //if not Whistler the audit message will be vague as to its intent, therefore we will add some 
        //explanation text
        sExplainText = GetString(IDS_EVENT_PWD_HASH_W2K_EXPLAIN);
        RtlInitUnicodeString(&Explanation, (WCHAR*)sExplainText);

        //set the audit paramter header information
        RtlZeroMemory((PVOID) &AuditParameters, sizeof(AuditParameters));
        AuditParameters.CategoryId     = SE_CATEGID_ACCOUNT_MANAGEMENT;
        AuditParameters.AuditId        = SE_AUDITID_PASSWORD_HASH_ACCESS;
        AuditParameters.Type           = EventType;

        //now set the audit parameters for this OS.  Parameters are added to the structure using macros 
        //defined in LsaParamMacros.h
        AuditParameters.ParameterCount = 0;
        LsapSetParmTypeSid(AuditParameters, AuditParameters.ParameterCount, TokenUserInformation->User.Sid);
        AuditParameters.ParameterCount++;
        LsapSetParmTypeString(AuditParameters, AuditParameters.ParameterCount, &SubsystemName);
        AuditParameters.ParameterCount++;
        LsapSetParmTypeString(AuditParameters, AuditParameters.ParameterCount, &TargetUser);
        AuditParameters.ParameterCount++;
        LsapSetParmTypeString(AuditParameters, AuditParameters.ParameterCount, &TargetDomain);
        AuditParameters.ParameterCount++;
        LsapSetParmTypeLogonId(AuditParameters, AuditParameters.ParameterCount, ClientAuthenticationId);
        AuditParameters.ParameterCount++;
        LsapSetParmTypeString(AuditParameters, AuditParameters.ParameterCount, &Explanation);
        AuditParameters.ParameterCount++;

        //Write to the security log
        Status = LsaIWriteAuditEvent(&AuditParameters, 0);
        if (!NT_SUCCESS(Status))
            LsapAuditFailed(Status);
    }//end if Whistler


    if (TokenUserInformation != NULL) 
        free(TokenUserInformation);

    return (HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status)));
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 8 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for retrieving the caller's sid. *
 * We will use this prior to logging an event log.                   *
 *                                                                   *
 *********************************************************************/

//BEGIN GetCallerSid
DWORD GetCallerSid(PSID pCallerSid, DWORD dwLength)
{
/* local variables */
   DWORD                     rc;
   HANDLE                    hToken = NULL;
   TOKEN_USER                tUser[10];
   ULONG                     len;
   
/* function body */
   rc = (DWORD)RpcImpersonateClient(NULL);
   if (!rc)
   {
      if ( OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken) )
	  {
         if ( GetTokenInformation(hToken,TokenUser,tUser,10*(sizeof TOKEN_USER),&len) )
            CopySid(dwLength, pCallerSid, tUser[0].User.Sid);
         else
            rc = GetLastError();

         CloseHandle(hToken);
	  }
      else
         rc = GetLastError();

      RPC_STATUS statusRevertToSelf = RpcRevertToSelf();
      ASSERT(statusRevertToSelf == RPC_S_OK);
   }

   return rc;
}
//END GetCallerSid


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 19 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for logging major events in Event*
 * Viewer.                                                           *
 *                                                                   *
 *********************************************************************/

//BEGIN LogEvent
void LogPwdEvent(const WCHAR* srcName, bool bAuditSuccess)
{
/* local variables */
    USHORT                  wType;
    DWORD                   rc = 0;
    BOOL                    rcBool;

/* function body */
    if (bAuditSuccess)
        wType = EVENTLOG_AUDIT_SUCCESS;
    else
        wType = EVENTLOG_AUDIT_FAILURE;

    //if NT4.0, write to the Security Event Log as you would any log
    if (nOSVer == 4)
    {
        //get the caller's SID
        BYTE byteSid[SECURITY_MAX_SID_SIZE];
        PSID    pCallerSid = (PSID)byteSid;

        if (hEventSource && (GetCallerSid(pCallerSid, SECURITY_MAX_SID_SIZE) == ERROR_SUCCESS))
        {
            LPTSTR pStringArray[1];
            WCHAR  msg[2000];
            WCHAR  txtSid[MAX_PATH];
            DWORD  lenTxt = MAX_PATH;

            //prepare the msg to display
            if (!GetTextualSid(pCallerSid,txtSid,&lenTxt))
                wcscpy(txtSid, L"");

            //retrieve audit text
            //note that hard-coded English string is used if string retrieval fails
            _bstr_t strFormat = GetString(IDS_EVENT_PWD_HASH_RETRIEVAL);
            LPCWSTR pszFormat = strFormat;

            if (pszFormat == NULL)
            {
                pszFormat = PASSWORD_AUDIT_TEXT_ENGLISH;
            }

            _snwprintf(msg, sizeof(msg) / sizeof(msg[0]), pszFormat, srcName, pDomain, txtSid);
            msg[sizeof(msg) / sizeof(msg[0]) - 1] = L'\0';
            pStringArray[0] = msg;

            //log the event
            rcBool = ReportEventW(hEventSource,            // handle of event source
                wType,                      // event type
                SE_CATEGID_ACCOUNT_MANAGEMENT,// event category
                SE_AUDITID_PASSWORD_HASH_ACCESS,// event ID
                pCallerSid,                 // current user's SID
                1,                          // strings in lpszStrings
                0,                          // no bytes of raw data
                (LPCTSTR *)pStringArray,    // array of error strings
                NULL );                     // no raw data
            if ( !rcBool )
                rc = GetLastError();
        }
    }
    else  //else write the event by requesting LSA to do it for us
    {
        //if not already done, late bind to LsaIWriteAuditEvent since it is not present on an NT 4.0 box
        if (!LsaIWriteAuditEvent)
        {
            hLsaDLL = LoadLibrary(L"LsaSrv.dll");
            if ( hLsaDLL )
            {
                LsaIWriteAuditEvent = (LSAIWRITEAUDITEVENT)GetProcAddress(hLsaDLL, "LsaIWriteAuditEvent");
                LsaIAuditPasswordAccessEvent = (PLSAIAUDITPASSWORDACCESSEVENT)GetProcAddress(hLsaDLL, "LsaIAuditPasswordAccessEvent");
            }
        }

        if (LsaIWriteAuditEvent)
            LsaAuditPasswordAccessEvent(wType, srcName, pDomain);
    }
}
//END LogEvent

/*******************************
 * Event Logging Functions End *
 *******************************/

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 8 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for obtaining the account domain *
 * sid.  This sid will be later used to Open the domain via SAM.     *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDomainSid
NTSTATUS GetDomainSid(PSID * pDomainSid)
{
    /* local variables */
    LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
    NTSTATUS                  status = 0;
    LSA_HANDLE                hPolicy;
    HRESULT                   hr = 0;

    /* function body */
    //object attributes are reserved, so initalize to zeroes.
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));


    //attempt to open the policy.
    status = LsaOpenPolicy(
        NULL,
        &ObjectAttributes,
        POLICY_EXECUTE, 
        &hPolicy  //recieves the policy handle
    );

    if (NT_SUCCESS(status))
    {
        //ask for account domain policy information
        PPOLICY_ACCOUNT_DOMAIN_INFO   info;
        status = LsaQueryInformationPolicy(hPolicy, PolicyAccountDomainInformation, (PVOID *)&info);
        if (NT_SUCCESS(status))
        {
            //save the domain sid
            *pDomainSid = SafeCopySid(info->DomainSid);
            if (*pDomainSid == NULL)
                status = STATUS_INSUFFICIENT_RESOURCES;

            //save the domain name
            USHORT uLen = info->DomainName.Length / sizeof(WCHAR);
            pDomain = new WCHAR[uLen + sizeof(WCHAR)];
            if (pDomain)
            {
                wcsncpy(pDomain, info->DomainName.Buffer, uLen);
                pDomain[uLen] = L'\0';
            }

            //free policy info structure
            LsaFreeMemory((PVOID) info);
        }

        //Freeing the policy object handle
        LsaClose(hPolicy);
    }

    return status;
}
//END GetDomainSid


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 8 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for obtaining a domain handle    *
 * used repeatedly by our interface function CopyPassword.           *
 *     For optimization, this function should only be called once per*
 * the life of this dll.                                             *
 *      This function also gets an Event Handle to the event log.    *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDomainHandle
NTSTATUS GetDomainHandle(SAMPR_HANDLE *pDomainHandle)
{
/* local variables */
   PSID           pDomainSid;
   NTSTATUS       status;
   SAMPR_HANDLE   hServerHandle;
   SAMPR_HANDLE   hDomainHandle;

/* function body */
      //get the account domain sid
   status = GetDomainSid(&pDomainSid);

   if (NT_SUCCESS(status))
   {
	     //connect to the Sam and get a server handle
      status = SamIConnect(NULL, 
						   &hServerHandle, 
						   SAM_SERVER_ALL_ACCESS, 
						   TRUE);
      if (NT_SUCCESS(status))
	  {
		    //get the account domain handle
         status = SamrOpenDomain(hServerHandle,
								 DOMAIN_ALL_ACCESS,
								 (PRPC_SID)pDomainSid,
								 &hDomainHandle);
		 if (NT_SUCCESS(status))
		    *pDomainHandle = hDomainHandle;
		    //close the SamIConnect server handle
		 SamrCloseHandle(&hServerHandle);
	  }
      FreeSid(pDomainSid);
   }

   return status;
}
//END GetDomainHandle


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 8 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for retrieving the global domain *
 * handle.  If we don't have the handle yet, it calls the externally *
 * defined GetDomainHandle funtion to get the handle.  The handle    *
 * retrieval code is placed in a critical section.  Subsequent       *
 * calls to this functin merely return the handle.                   *
 *     I will also use this function to fill the global NULL         *
 * LmOwfPassword structure for possible use.  This should be done    *
 * one time only.                                                    *
 *                                                                   *
 *********************************************************************/

//BEGIN RetrieveDomainHandle
HRESULT RetrieveDomainHandle(SAMPR_HANDLE *pDomainHandle)
{
/* local constants */
  const WCHAR * svcName = L"Security";

/* local variables */
  NTSTATUS			status = 0;
  HRESULT			hr = ERROR_SUCCESS;
  BOOL				bInCritSec = FALSE;

/* function body */
  try
  {
	    //enter the critical section
     EnterCriticalSection(&csADMTCriticalSection);
     bInCritSec = TRUE;

        //if not yet retrieved, get the global handle and fill the NULL
	    //LmOwfPassword structure
	 if (hgDomainHandle == NULL)
	 {
		   //get the domain handle
		status = GetDomainHandle(&hgDomainHandle);
	    if (NT_SUCCESS(status))
		   pDomainHandle = &hgDomainHandle;

		GetOS(); //set global variable as to whether this DC's OS

		   //if NT4.0 OS on this DC, then set the event handle for logging events
		if (nOSVer == 4)
		{
		   NTSTATUS Status;
		   BOOLEAN PrivWasEnabled;
			  //make sure we have audit and debug privileges
		   RtlAdjustPrivilege( SE_SECURITY_PRIVILEGE, TRUE, FALSE, &PrivWasEnabled );
		   RtlAdjustPrivilege( SE_DEBUG_PRIVILEGE, TRUE, FALSE, &PrivWasEnabled );
		   RtlAdjustPrivilege( SE_AUDIT_PRIVILEGE, TRUE, FALSE, &PrivWasEnabled );
		      //register this dll with the eventlog, get a handle, and store globally
		   hEventSource = RegisterEventSourceW(NULL, svcName);
		   if (!hEventSource)
		   {
			  LeaveCriticalSection(&csADMTCriticalSection); // Release ownership of the critical section
		      return HRESULT_FROM_WIN32(GetLastError());
		   }
		}

           //fill a global NULL LmOwfPassword in case we need it later
        WCHAR			sNtPwd[MAX_PATH] = L"";
        UNICODE_STRING	UnicodePwd;
        ANSI_STRING     LmPassword;
		CHAR			sBuf[LM_BUFFER_LENGTH];
        
        RtlInitUnicodeString(&UnicodePwd, sNtPwd);

           //fill LmOwf NULL password
        LmPassword.Buffer = sBuf;
        LmPassword.MaximumLength = LmPassword.Length = LM_BUFFER_LENGTH;
        RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

        status = RtlUpcaseUnicodeStringToOemString( &LmPassword, &UnicodePwd, FALSE );
        if ( !NT_SUCCESS(status) ) 
		{
              //the password is longer than the max LM password length
           status = STATUS_NULL_LM_PASSWORD;
           RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );
           RtlCalculateLmOwfPassword((PLM_PASSWORD)&LmPassword, &NullLmOwfPassword);
		}
		else
		{
           RtlCalculateLmOwfPassword((PLM_PASSWORD)&LmPassword, &NullLmOwfPassword);
		}

		   //fill NtOwf NULL password
        RtlCalculateNtOwfPassword((PNT_PASSWORD)&UnicodePwd, &NullNtOwfPassword);
	 }

     LeaveCriticalSection(&csADMTCriticalSection); // Release ownership of the critical section
  }
  catch(...)
  {
     if (bInCritSec)
     {
        LeaveCriticalSection(&csADMTCriticalSection); // Release ownership of the critical section
        status = STATUS_UNSUCCESSFUL;
     }
     else
     {
        // EnterCriticalSection may raise a STATUS_INVALID_HANDLE under low memory conditions
        status = STATUS_INVALID_HANDLE;
     }
  }

      //convert any error to a win error
  if (!NT_SUCCESS(status))
     hr = LsaNtStatusToWinError(status);

  return hr;
}
//END RetrieveDomainHandle


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 11 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for retrieving the passwords for *
 * the given user's source domain account.  We use SAM APIs to       *
 * retrieve the LmOwf and NtOwf formats of the password.             *
 *                                                                   *
 *********************************************************************/

//BEGIN RetrieveEncrytedSourcePasswords
HRESULT RetrieveEncrytedSourcePasswords(const WCHAR* srcName, 
										 PLM_OWF_PASSWORD pSrcLmOwfPwd,
										 PNT_OWF_PASSWORD pSrcNtOwfPwd)
{
/* local variables */
   NTSTATUS				status = 0;
   HRESULT				hr = ERROR_SUCCESS;
   SAMPR_HANDLE			hUserHandle = NULL;
   ULONG				ulCount = 1;
   ULONG				userID;
   RPC_UNICODE_STRING	sNames[1];
   SAMPR_ULONG_ARRAY	ulIDs;
   SAMPR_ULONG_ARRAY	ulUse;
   PSAMPR_USER_INFO_BUFFER pInfoBuf = NULL;
   WCHAR			*   pName;

/* function body */
   pName = new WCHAR[wcslen(srcName)+1];
   if (!pName)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

      //get the user's ID
   sNames[0].Length = sNames[0].MaximumLength = (USHORT)((wcslen(srcName)) * sizeof(WCHAR));
   wcscpy(pName, srcName);
   sNames[0].Buffer = pName;
   ulIDs.Element = NULL;
   ulUse.Element = NULL;
   status = SamrLookupNamesInDomain(hgDomainHandle,
								    ulCount,
									sNames,
									&ulIDs,
									&ulUse);
   delete [] pName;
   if (!NT_SUCCESS(status))
      return HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));

   userID = *(ulIDs.Element);

      //get a user handle
   status = SamrOpenUser(hgDomainHandle,
						 USER_READ,
						 userID,
						 &hUserHandle);
   if (!NT_SUCCESS(status))
   {
	  SamIFree_SAMPR_ULONG_ARRAY(&ulIDs);
	  SamIFree_SAMPR_ULONG_ARRAY(&ulUse);
      return HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));
   }

      //get the user's password
   status = SamrQueryInformationUser(hUserHandle,
									 UserInternal3Information,
									 &pInfoBuf);
   if (NT_SUCCESS(status)) //if success, get LmOwf and NtOwf versions of the password
   {
	  if (pInfoBuf->Internal3.I1.NtPasswordPresent)
         memcpy(pSrcNtOwfPwd, pInfoBuf->Internal3.I1.NtOwfPassword.Buffer, sizeof(NT_OWF_PASSWORD));
	  else
         memcpy(pSrcNtOwfPwd, &NullNtOwfPassword, sizeof(NT_OWF_PASSWORD));
	  if (pInfoBuf->Internal3.I1.LmPasswordPresent)
         memcpy(pSrcLmOwfPwd, pInfoBuf->Internal3.I1.LmOwfPassword.Buffer, sizeof(LM_OWF_PASSWORD));
	  else //else we need to use the global NULL LmOwfPassword
         memcpy(pSrcLmOwfPwd, &NullLmOwfPassword, sizeof(LM_OWF_PASSWORD));
      SamIFree_SAMPR_USER_INFO_BUFFER (pInfoBuf, UserInternal3Information);
      LogPwdEvent(srcName, true);
   }
   else
      LogPwdEvent(srcName, false);


   SamIFree_SAMPR_ULONG_ARRAY(&ulIDs);
   SamIFree_SAMPR_ULONG_ARRAY(&ulUse);
   SamrCloseHandle(&hUserHandle);

   if (!NT_SUCCESS(status))
      hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));

   return hr;
}
//END RetrieveEncrytedSourcePasswords


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 11 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for using the MSCHAP dll to      *
 * change the given target user's password.                          *
 *                                                                   *
 *********************************************************************/

//BEGIN SetTargetPassword
HRESULT SetTargetPassword(handle_t hBinding, const WCHAR* tgtServer, 
						  const WCHAR* tgtName, WCHAR* currentPwd, 
						  LM_OWF_PASSWORD newLmOwfPwd, NT_OWF_PASSWORD newNtOwfPwd)
{
/* local variables */ 
   NTSTATUS				status;
   HRESULT				hr = ERROR_SUCCESS;
   RPC_STATUS           rcpStatus;
   UNICODE_STRING       UnicodePwd;
   OEM_STRING			oemString;
   LM_OWF_PASSWORD		OldLmOwfPassword;
   NT_OWF_PASSWORD		OldNtOwfPassword;
   BOOLEAN				LmOldPresent = TRUE;
   int					nConvert;
   WCHAR			  * pTemp;


/* function body */
   pTemp = new WCHAR[wcslen(currentPwd)+1];
   if (!pTemp)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

      //convert the old LmOwf password
   wcscpy(pTemp, currentPwd);
   _wcsupr(pTemp);
   RtlInitUnicodeString(&UnicodePwd, pTemp);
   status = RtlUpcaseUnicodeStringToOemString(&oemString, &UnicodePwd, TRUE);
   RtlSecureZeroMemory(pTemp, (wcslen(currentPwd)+1)*sizeof(WCHAR));
   delete [] pTemp;
   if (NT_SUCCESS(status))
   {
	  if (status == STATUS_NULL_LM_PASSWORD)
	     LmOldPresent = FALSE;
	  else
	  {
         status = RtlCalculateLmOwfPassword(oemString.Buffer, &OldLmOwfPassword);
	  }
	  RtlSecureZeroMemory(oemString.Buffer, oemString.Length);
	  RtlFreeOemString(&oemString);
   }

      //convert the old NtOwf password
   RtlInitUnicodeString(&UnicodePwd, currentPwd);
   status = RtlCalculateNtOwfPassword(&UnicodePwd, &OldNtOwfPassword);
   if (!NT_SUCCESS(status)) //if failed, leave
   {
	  hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));
	  goto exit;
   }

      //impersonate the caller when setting the password, if failed, leave
   rcpStatus = RpcImpersonateClient(hBinding);
   if (rcpStatus != RPC_S_OK)
   {
	  hr = HRESULT_FROM_WIN32(rcpStatus);
	  goto exit;
   }

      //change the Password!
   status = MSChapSrvChangePassword(const_cast<WCHAR*>(tgtServer),
									const_cast<WCHAR*>(tgtName),
									LmOldPresent,
									&OldLmOwfPassword,
									&newLmOwfPwd,
									&OldNtOwfPassword,
									&newNtOwfPwd);

   rcpStatus = RpcRevertToSelf();
   if (rcpStatus != RPC_S_OK)
      hr = HRESULT_FROM_WIN32(rcpStatus);

   if (!NT_SUCCESS(status))
      hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));

exit:

   RtlSecureZeroMemory(&OldLmOwfPassword, sizeof(LM_OWF_PASSWORD));
   RtlSecureZeroMemory(&OldNtOwfPassword, sizeof(NT_OWF_PASSWORD));

   return hr;
}
//END SetTargetPassword


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 8 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for checking to make sure that   *
 * the calling client has the proper access on this machine and      *
 * domain to change someone's password.  We use a helper function to *
 * do the actual check.                                              *
 *                                                                   *
 *********************************************************************/

//BEGIN AuthenticateClient
DWORD 
   AuthenticateClient(
      handle_t               hBinding        // in - binding for client call
   )
{
/* local variables */
   DWORD                     rc;
   
/* function body */
   rc = (DWORD)RpcImpersonateClient(hBinding);
   if (!rc)
   {
      rc = IsAdminLocal();
      RPC_STATUS statusRevertToSelf = RpcRevertToSelfEx(hBinding);
      ASSERT(statusRevertToSelf == RPC_S_OK);
   }
   return rc;
}
//END AuthenticateClient


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 6 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for migrating the given user's   *
 * password from the source domain, in which this dll is running, to *
 * the given migrated target domain account.  We will retrieve the   *
 * old user's current password and set the new user's password to    *
 * match.                                                            *
 *                                                                   *
 *********************************************************************/

//BEGIN CopyPassword
DWORD __stdcall 
   CopyPassword( 
      /* [in] */         handle_t              hBinding,
      /* [string][in] */ const WCHAR __RPC_FAR *tgtServer,
      /* [string][in] */ const WCHAR __RPC_FAR *srcName,
      /* [string][in] */ const WCHAR __RPC_FAR *tgtName,
      /* [in] */         unsigned long          dwPwd,
      /* [size_is][in] */const char __RPC_FAR  *currentPwd
   )
{
    HRESULT         hr = ERROR_SUCCESS;
    SAMPR_HANDLE    hDomain = NULL;
    LM_OWF_PASSWORD NewLmOwfPassword;
    NT_OWF_PASSWORD NewNtOwfPassword;
    NTSTATUS        status;
    DWORD           rc=0;
    PSID            pCallerSid = NULL;
    _variant_t      varPwd;
    _bstr_t         bstrPwd;
    BOOL            bInCritSec = FALSE;

    // validate parameters
    if ((tgtServer == NULL) || (srcName == NULL) || (tgtName == NULL) || 
        (currentPwd == NULL) || (dwPwd <= 0))
    {
        return E_INVALIDARG;
    }

    //validate the buffer and the reported size
    if (IsBadReadPtr(currentPwd, dwPwd))
        return E_INVALIDARG;

    try
    {
        //convert the incoming byte array into a variant
        varPwd = SetVariantWithBinaryArray(const_cast<char*>(currentPwd), dwPwd);
        if ((varPwd.vt != (VT_UI1|VT_ARRAY)) || (varPwd.parray == NULL))
            return E_INVALIDARG;

        //enter the critical section
        EnterCriticalSection(&csADMTCriticalSection);
        bInCritSec = TRUE;  //set flag that tells we need to leave the critical section

        //try to decrypt the password
        ASSERT(g_hSessionKey != NULL);
        bstrPwd = AdmtDecrypt(g_hSessionKey, varPwd);

        LeaveCriticalSection(&csADMTCriticalSection); // Release ownership of the critical section
        bInCritSec = FALSE;

        if (!bstrPwd)
        {
            rc = GetLastError();
            return HRESULT_FROM_WIN32(rc);
        }
    }
    catch (_com_error& ce)
    {
        if (bInCritSec)
            LeaveCriticalSection(&csADMTCriticalSection); // Release ownership of the critical section
        return ce.Error();
    }
    catch (...)
    {
        if (bInCritSec)
            LeaveCriticalSection(&csADMTCriticalSection); // Release ownership of the critical section
        return E_FAIL;
    }

    //get the domain handle
    hr = RetrieveDomainHandle(&hDomain);
    if (hr == ERROR_SUCCESS)
    {
        //get the user's password from the source domain
        hr = RetrieveEncrytedSourcePasswords(srcName, &NewLmOwfPassword, &NewNtOwfPassword);
        if (hr == ERROR_SUCCESS)
        {
            //set the target user's password to the source user's
            hr = SetTargetPassword(hBinding, tgtServer, tgtName, (WCHAR*)bstrPwd, 
                NewLmOwfPassword, NewNtOwfPassword);
        }
    }

    if ((WCHAR*)bstrPwd)
        RtlSecureZeroMemory((WCHAR*)bstrPwd, wcslen((WCHAR*)bstrPwd)*sizeof(WCHAR));

    RtlSecureZeroMemory(&NewLmOwfPassword, sizeof(LM_OWF_PASSWORD));
    RtlSecureZeroMemory(&NewNtOwfPassword, sizeof(NT_OWF_PASSWORD));

    return hr;
}
//END CopyPassword


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 6 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for checking a registry value to *
 * make sure that the ADMT password migration Lsa notification       *
 * package is installed, running, and ready to migrate passwords.    *
 *                                                                   *
 *********************************************************************/

//BEGIN CheckConfig
DWORD __stdcall
   CheckConfig(
      /* [in] */         handle_t               hBinding,
      /* [in] */         unsigned long          dwSession,
      /* [size_is][in] */const char __RPC_FAR  *aSession,
      /* [in] */         unsigned long          dwPwd,
      /* [size_is][in] */const char __RPC_FAR  *aTestPwd,
      /* [out] */        WCHAR __RPC_FAR        tempPwd[PASSWORD_BUFFER_SIZE]
   )
{
    DWORD       rc;
    DWORD       rval;
    DWORD       type;         // type of value
    DWORD       len = sizeof rval; // value length
    HKEY        hKey;
    _variant_t  varPwd;
    _variant_t  varSession;
    _bstr_t     bstrPwd = L"";
    BOOL        bInCritSec = FALSE;

    // validate parameters
    if ((aSession == NULL) || (aTestPwd == NULL) || (tempPwd == NULL) || 
        (dwSession <= 0) || (dwPwd <= 0))
    {
        return E_INVALIDARG;
    }

    //validate the buffer and the reported size
    if ((IsBadReadPtr(aSession, dwSession)) || (IsBadReadPtr(aTestPwd, dwPwd)) || 
        (IsBadWritePtr((LPVOID)tempPwd, PASSWORD_BUFFER_SIZE * sizeof(WCHAR))))
    {
        return E_INVALIDARG;
    }

    //make sure the registry value is set for password migration
    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
        L"System\\CurrentControlSet\\Control\\Lsa",
        0,
        KEY_READ,
        &hKey);
    if (rc == ERROR_SUCCESS)
    {
        rc = RegQueryValueEx(hKey, L"AllowPasswordExport", NULL, &type, (BYTE *)&rval, &len);
        RegCloseKey(hKey);
        if ((rc == ERROR_SUCCESS) && (type == REG_DWORD) && (rval == 1))
            rc = ERROR_SUCCESS;
        else
            return PM_E_PASSWORD_MIGRATION_NOT_ENABLED;
    }
    else
        return HRESULT_FROM_WIN32(rc); 

    try
    {
        //convert the incoming byte arrays into variants
        varSession = SetVariantWithBinaryArray(const_cast<char*>(aSession), dwSession);
        varPwd = SetVariantWithBinaryArray(const_cast<char*>(aTestPwd), dwPwd);
        if ((varSession.vt != (VT_UI1|VT_ARRAY)) || (varSession.parray == NULL) || 
            (varPwd.vt != (VT_UI1|VT_ARRAY)) || (varPwd.parray == NULL))
            return E_INVALIDARG;

        // acquire cryptographic service provider context

        //enter the critical section
        EnterCriticalSection(&csADMTCriticalSection);
        bInCritSec = TRUE;  //set flag that tells we need to leave the critical section

        if (g_hProvider == 0)
        {
            g_hProvider = AdmtAcquireContext();
        }

        if (g_hProvider)
        {
            // import new session key

            HCRYPTKEY hSessionKey = AdmtImportSessionKey(g_hProvider, varSession);

            // decrypt password

            if (hSessionKey)
            {
                // destroy any existing session key

                if (g_hSessionKey)
                {
                    AdmtDestroyKey(g_hSessionKey);
                }

                g_hSessionKey = hSessionKey;

                bstrPwd = AdmtDecrypt(g_hSessionKey, varPwd);
                if (!bstrPwd)
                    rc = GetLastError();
            }
            else
                rc = GetLastError();
        }
        else
        {
            rc = GetLastError();
        }

        LeaveCriticalSection(&csADMTCriticalSection); // Release ownership of the critical section
        bInCritSec = FALSE;

        //send back the decrypted password
        if (bstrPwd.length() > 0)
        {
            wcsncpy(tempPwd, bstrPwd, PASSWORD_BUFFER_SIZE);
            tempPwd[PASSWORD_BUFFER_SIZE - 1] = L'\0';
        }
        else
        {
            tempPwd[0] = L'\0';
        }
    }
    catch (_com_error& ce)
    {
        if (bInCritSec)
            LeaveCriticalSection(&csADMTCriticalSection); // Release ownership of the critical section
        return ce.Error();
    }
    catch (...)
    {
        if (bInCritSec)
            LeaveCriticalSection(&csADMTCriticalSection); // Release ownership of the critical section
        return E_FAIL;
    }

    return HRESULT_FROM_WIN32(rc);
}
//END CheckConfig


//----------------------------------------------------------------------------
// Security Callback Function
//
// Validates client access to PwdMigRpc interface.
//
// Arguments
// hInterface - interface handle (not used in this implementation)
// pContext   - the context is the client binding handle
//
// Return Value
// A returned value of RPC_OK means allow access whereas any other value
// means deny access. This implementation returns ERROR_ACCESS_DENIED to
// indicate that access should be denied to client.
//----------------------------------------------------------------------------

RPC_STATUS RPC_ENTRY SecurityCallback(RPC_IF_HANDLE hInterface, void* pContext)
{
    RPC_STATUS rpcStatusReturn = ERROR_ACCESS_DENIED;

    if (pContext)
    {
        //
        // Retrieve privilege attributes of client making call.
        //

        RPC_AUTHZ_HANDLE hPrivs;
        DWORD dwAuthnLevel;

        RPC_STATUS status = RpcBindingInqAuthClient(
            pContext,
            &hPrivs,
            NULL,
            &dwAuthnLevel,
            NULL,
            NULL
        );

        if (status == RPC_S_OK)
        {
            //
            // Verify authentication level is packet privacy.
            //

            if (dwAuthnLevel >= RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
            {
                //
                // Verify the client is an administrator on the local machine.
                //

                status = AuthenticateClient(pContext);

                //
                // If all checks have passed then allow client access.
                //

                if (status == RPC_S_OK)
                {
                    rpcStatusReturn = RPC_S_OK;
                }
            }
        }
    }

    return rpcStatusReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\pwdsvc\pwdsvc.cpp ===
/*---------------------------------------------------------------------------
  File: PwdSvc.cpp

  Comments:  entry point functions and other exported functions for ADMT's 
             password migration Lsa notification package.

  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 09/06/00

 ---------------------------------------------------------------------------
*/

#include "Pwd.h"
#include "PwdSvc.h"
#include "PwdSvc_s.c"

// These global variables can be changed if required
#define gsPwdProtoSeq TEXT("ncacn_np")
#define gsPwdEndPoint TEXT("\\pipe\\PwdMigRpc")
DWORD                    gPwdRpcMinThreads = 1;
DWORD                    gPwdRpcMaxThreads = RPC_C_LISTEN_MAX_CALLS_DEFAULT;

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS   ((NTSTATUS) 0x00000000L)
#endif

extern "C"
{
    BOOL WINAPI _CRT_INIT( HANDLE hInstance, DWORD  nReason, LPVOID pReserved );
}

RPC_STATUS RPC_ENTRY SecurityCallback(RPC_IF_HANDLE hInterface, void* pContext);

namespace
{
    //
    // Timer Class
    //

    class CTimer
    {
    public:

        CTimer() :
            m_hTimer(NULL)
        {
        }

        ~CTimer()
        {
            if (m_hTimer)
            {
                Close();
            }
        }

        DWORD Create()
        {
            ASSERT(m_hTimer == NULL);

            //
            // Create timer. Close timer first if already created.
            //

            if (m_hTimer)
            {
                Close();
            }

            m_hTimer = CreateWaitableTimer(NULL, TRUE, NULL);

            return m_hTimer ? ERROR_SUCCESS : GetLastError();
        }

        DWORD Wait(int nTime)
        {
            ASSERT(m_hTimer != NULL);

            DWORD dwError = ERROR_SUCCESS;

            if (m_hTimer)
            {
                //
                // Convert elapsed time parameter from milliseconds
                // to relative due time in 100s of nanoseconds.
                //

                LARGE_INTEGER liDueTime;
                liDueTime.QuadPart = nTime * -10000i64;

                //
                // Set timer and wait for timer to be signaled.
                //

                if (SetWaitableTimer(m_hTimer, &liDueTime, 0, NULL, NULL, FALSE))
                {
                    if (WaitForSingleObject(m_hTimer, INFINITE) == WAIT_FAILED)
                    {
                        dwError = GetLastError();
                    }
                }
                else
                {
                    dwError = GetLastError();
                }
            }
            else
            {
                dwError = ERROR_INVALID_HANDLE;
            }

            return dwError;
        }

        void Close()
        {
            ASSERT(m_hTimer != NULL);

            if (m_hTimer)
            {
                if (CloseHandle(m_hTimer) == FALSE)
                {
                    DWORD dwError = GetLastError();
                    ASSERT(dwError == ERROR_SUCCESS);
                }

                m_hTimer = NULL;
            }
        }

    protected:

        HANDLE m_hTimer;
    };
}

/******************************
 * RPC Registration Functions *
 ******************************/


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 11 JUNE 2001                                                *
 *                                                                   *
 *     This function is called by a thread spawned from our          *
 * "InitializeChangeNotify" password filter function to wait until   *
 * SAM, and therefore RPC, is up and running.                        *
 *                                                                   *
 * 04/17/02 MPO - rewritten to wait for SAM_SERVICE_STARTED event to *
 *                be created first before waiting for this event to  *
 *                be signaled                                        *
 *********************************************************************/

//BEGIN PwdMigWaitForSamService
DWORD __stdcall PwdMigWaitForSamService()
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // Attempt to open the SAM service started event object.
    //
    // Note that we must use the Nt APIs to open the event object
    // as the name begins with a \ character which is not valid
    // in the object name space used by the OpenEvent API.
    //

    HANDLE hEvent = NULL;

    UNICODE_STRING usEventName;
    RtlInitUnicodeString(&usEventName, L"\\SAM_SERVICE_STARTED");

    OBJECT_ATTRIBUTES oaEventAttributes;
    InitializeObjectAttributes(&oaEventAttributes, &usEventName, 0, 0, NULL);

    NTSTATUS ntStatus = NtOpenEvent(&hEvent, SYNCHRONIZE, &oaEventAttributes);

    if (NT_ERROR(ntStatus))
    {
        //
        // If the SAM service started event object has not been
        // created yet then wait until it has been created.
        //

        if (ntStatus == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            //
            // Enter a loop which waits until the open event API returns
            // an error other than the event object not found. The loop
            // waits 15 sec between attempts to open object.
            //

            CTimer timer;

            dwError = timer.Create();

            if (dwError == ERROR_SUCCESS)
            {
                for (;;)
                {
                    dwError = timer.Wait(15000);

                    if (dwError != ERROR_SUCCESS)
                    {
                        break;
                    }

                    ntStatus = NtOpenEvent(&hEvent, SYNCHRONIZE, &oaEventAttributes);

                    if (NT_SUCCESS(ntStatus))
                    {
                        break;
                    }

                    if (ntStatus != STATUS_OBJECT_NAME_NOT_FOUND)
                    {
                        dwError = LsaNtStatusToWinError(ntStatus);
                        break;
                    }
                }
            }
        }
        else
        {
            dwError = LsaNtStatusToWinError(ntStatus);
        }
    }

    //
    // If event has been opened then wait for it to be signalled.
    //

    if (hEvent != NULL)
    {
        NTSTATUS ntWaitStatus = NtWaitForSingleObject(hEvent, FALSE, NULL);

        NTSTATUS ntCloseStatus = NtClose(hEvent);
        ASSERT(NT_SUCCESS(ntCloseStatus));

        dwError = (ntWaitStatus == STATUS_WAIT_0) ? ERROR_SUCCESS : LsaNtStatusToWinError(ntWaitStatus);
    }

    return dwError;
}
//END PwdMigWaitForSamService


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 11 JUNE 2001                                                *
 *                                                                   *
 *     This function is a spawned thread created by the              *
 * "InitializeChangeNotify" password filter function to wait until   *
 * SAM, and therefore RPC, is up and running and then register the   *
 * ADMT Password Migration RPC interface.                            *
 *                                                                   *
 * 04/17/02 MPO - rewritten to wait until critical section is        *
 *                initialized and to use a stronger authentication   *
 *                service when built for Windows 2000 or later       *
 *********************************************************************/

//BEGIN PwdMigRPCRegProc
DWORD WINAPI PwdMigRPCRegProc(LPVOID lpParameter)
{
    RPC_STATUS rc = RPC_S_OK;

    //
    // Wait for the SAM service to start before registering RPC interface.
    //

    if (PwdMigWaitForSamService() == ERROR_SUCCESS)
    {
        //
        // Initialize critical section used by PwdRpc interface
        // implementation.
        // Note that the critical section must be initialized before
        // registering RPC interface to prevent a race condition.
        //

        bool bCriticalSection = false;

        try
        {
            InitializeCriticalSection(&csADMTCriticalSection);
            bCriticalSection = true;
        }
        catch (...)
        {
            ;
        }

        if (bCriticalSection == false)
        {
            //
            // The initialize critical section API must
            // have thrown a STATUS_NO_MEMORY exception.
            //
            // Enter a loop which waits until the critical
            // section is initialized. The loop waits 15 sec
            // between attempts to initialize critical section.
            //

            CTimer timer;

            DWORD dwError = timer.Create();

            if (dwError == ERROR_SUCCESS)
            {
                while (bCriticalSection == false)
                {
                    dwError = timer.Wait(15000);

                    if (dwError != ERROR_SUCCESS)
                    {
                        break;
                    }

                    try
                    {
                        InitializeCriticalSection(&csADMTCriticalSection);
                        bCriticalSection = true;
                    }
                    catch (...)
                    {
                        ;
                    }
                }
            }

            if (dwError != ERROR_SUCCESS)
            {
                return dwError;
            }
        }

        // specify protocol sequence and endpoint
        // for receiving remote procedure calls

        rc = RpcServerUseProtseqEp(gsPwdProtoSeq, RPC_C_PROTSEQ_MAX_REQS_DEFAULT, gsPwdEndPoint, NULL);

        if (rc == RPC_S_OK)
        {
            //
            // Register PwdMigRpc interface with the RPC run-time library.
            // Only allow connections with an authorization level higher than
            // RPC_C_AUTHN_LEVEL_NONE. Also specifying security callback to
            // validate client before allowing access to interface.
            //

            rc = RpcServerRegisterIfEx(
                PwdMigRpc_ServerIfHandle,
                NULL,
                NULL,
                RPC_IF_ALLOW_SECURE_ONLY,
                RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                SecurityCallback
            );

            if (rc == RPC_S_OK)
            {
#ifdef PWD_W2KORLATER
                //
                // Register authentication information with RPC specifying
                // default principal name and specifying GSS negotiate.
                //

                PWCHAR pszPrincipalName = NULL;

                rc = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE, &pszPrincipalName);

                if (rc == RPC_S_OK)
                {
                    ASSERT(pszPrincipalName && (wcslen(pszPrincipalName) != 0));

                    //set the authenification for this RPC interface
                    rc = RpcServerRegisterAuthInfo(pszPrincipalName, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, NULL);

                    RpcStringFree(&pszPrincipalName);
                }
#else
                //set the authenification for this RPC interface
                rc = RpcServerRegisterAuthInfo(NULL, RPC_C_AUTHN_WINNT, NULL, NULL);
#endif
            }
        }//end if set protocal sequence and end point set
    }//end if RPC service is ready

    return 0;
}
//END PwdMigRPCRegProc


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 7 SEPT 2000                                                 *
 *                                                                   *
 *     This function is called by Lsa when trying to load all        *
 * registered Lsa password filter notification dlls.  Here we will   *
 * initialize the RPC run-time library to handle our ADMT password   *
 * migration RPC interface and to begin looking for RPC calls.  If we*
 * fail to successfully setup our RPC, we will return FALSE from this*
 * function which will cause Lsa not to load this password filter    *
 * Dll.                                                              *
 *     Note that the other two password filter dll functions:        *
 * PasswordChangeNotify and PasswordFilter do nothing at this point  *
 * in time.                                                          *
 *                                                                   *
 *********************************************************************/

//BEGIN InitializeChangeNotify
BOOLEAN __stdcall InitializeChangeNotify()
{
/* local variables */
   BOOLEAN				      bSuccess = FALSE;

/* function body */
      //spawn a seperate thread to register our RPC interface once RPC is up and running
   HANDLE h = CreateThread(NULL, 0, PwdMigRPCRegProc, NULL, 0, NULL);
   if (h != NULL)
      bSuccess = TRUE;;
   CloseHandle(h);
   return bSuccess;
}
//END InitializeChangeNotify

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 7 SEPT 2000                                                 *
 *                                                                   *
 *     This function is called by Lsa for all registered Lsa password*
 * filter notification dlls when a password in the domain has been   *
 * modified.  We will simply return STATUS_SUCCESS and do nothing.   *
 *                                                                   *
 *********************************************************************/

//BEGIN PasswordChangeNotify
NTSTATUS __stdcall PasswordChangeNotify(PUNICODE_STRING UserName, ULONG RelativeId,
							  PUNICODE_STRING NewPassword)
{
	return STATUS_SUCCESS;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 7 SEPT 2000                                                 *
 *                                                                   *
 *     This function is called by Lsa for all registered Lsa password*
 * filter notification dlls when a password in the domain is being   *
 * modified.  This function is designed to indicate to Lsa if the new*
 * password is acceptable.  We will simply return TRUE (indicating it*
 * is acceptable) and do nothing.                                    *
 *                                                                   *
 *********************************************************************/

//BEGIN PasswordFilter
BOOLEAN __stdcall PasswordFilter(PUNICODE_STRING AccountName, PUNICODE_STRING FullName,
						PUNICODE_STRING Password, BOOLEAN SetOperation)
{
	return TRUE;
}
//END PasswordFilter


/***************************/
/* Internal DLL functions. */
/***************************/

static BOOL Initialize(void)
{
    return TRUE;
}

static BOOL Terminate(BOOL procterm)
{

	if (!procterm)
            return TRUE;

/* XXX Do stuff here */

	return TRUE;
}


BOOL WINAPI
DllMain(HINSTANCE hinst, DWORD reason, VOID *rsvd)
/*++

Routine description:

    Dynamic link library entry point.  Does nothing meaningful.


Arguments:

    hinst  = handle for the DLL
    reason = code indicating reason for call
    rsvd   = for process attach: non-NULL => process startup
     		for process detach: non-NULL => process termination

Return value:

    status = success/failure

Side effects:

    None

--*/
 
{
	switch (reason) {

	case DLL_PROCESS_ATTACH:
	{
		_CRT_INIT(hinst, reason, rsvd); 
        DisableThreadLibraryCalls(hinst);
		return Initialize();
		break;
	}

	case DLL_PROCESS_DETACH:
	{
		BOOL bStat = Terminate(rsvd != NULL);
		_CRT_INIT(hinst, reason, rsvd); 
        return bStat;
		break;
	}

	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		return TRUE;

	default:
		return FALSE;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Midl allocate memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_FAR * __RPC_USER
   midl_user_allocate(
      size_t                 len )
{
   return new char[len];
}

///////////////////////////////////////////////////////////////////////////////
// Midl free memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_USER
   midl_user_free(
      void __RPC_FAR       * ptr )
{
   delete [] ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\pwdsvc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PwdSvc.rc
//
#define IDS_EVENT_PWD_HASH_RETRIEVAL    1
#define IDS_EVENT_PWD_HASH_W2K_EXPLAIN  2

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\admtscript.cpp ===
// ADMTScript.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ADMTScriptps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ADMTScript.h"
#include "ADMTScript_i.c"
#include "Migration.h"


CAdmtModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Migration, CMigration)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		ATLTRACE(_T("{ADMTScript.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_ADMT);
        DisableThreadLibraryCalls(hInstance);
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		ATLTRACE(_T("{ADMTScript.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\computermigration.h ===
#pragma once

#include "MigrationBase.h"


//---------------------------------------------------------------------------
// ComputerMigration Class
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CComputerMigration :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IComputerMigration, &IID_IComputerMigration, &LIBID_ADMT>,
	public CMigrationBase
{
public:

	CComputerMigration();
	~CComputerMigration();

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CComputerMigration)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IComputerMigration)
	END_COM_MAP()

public:

	// IComputerMigration

	STDMETHOD(put_TranslationOption)(long lOption);
	STDMETHOD(get_TranslationOption)(long* plOption);
	STDMETHOD(put_TranslateFilesAndFolders)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateFilesAndFolders)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateLocalGroups)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateLocalGroups)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslatePrinters)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslatePrinters)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateRegistry)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateRegistry)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateShares)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateShares)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateUserProfiles)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateUserProfiles)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateUserRights)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateUserRights)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_RestartDelay)(long lTime);
	STDMETHOD(get_RestartDelay)(long* plTime);
	STDMETHOD(Migrate)(long lOptions, VARIANT vntInclude, VARIANT vntExclude);

protected:

	void ValidateMigrationParameters();

	virtual void DoNames();
	virtual void DoDomain();

	void DoContainers(CContainer& rSource, CContainer& rTarget);
	void DoComputers(CContainer& rSource, CContainer& rTarget);
	void DoComputers(CDomainAccounts& rComputers, CContainer& rTarget);

	void SetOptions(_bstr_t strTargetOu, CVarSet& rVarSet);
	void SetAccountOptions(CVarSet& rVarSet);
	void SetSecurity(CVarSet& rVarSet);

protected:

	long m_lTranslationOption;
	bool m_bTranslateFilesAndFolders;
	bool m_bTranslateLocalGroups;
	bool m_bTranslatePrinters;
	bool m_bTranslateRegistry;
	bool m_bTranslateShares;
	bool m_bTranslateUserProfiles;
	bool m_bTranslateUserRights;
	long m_lRestartDelay;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\domaincontainer.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "DomainContainer.h"

#include "Error.h"
#include "GetDcName.h"
#include "AdsiHelpers.h"
#include "NameCracker.h"

#include <map>
#include <memory>
#include <string>
#include <LM.h>
#include <DsGetDC.h>
#include <DsRole.h>
#include <NtLdap.h>
#include <NtDsAPI.h>
#include <ActiveDS.h>
#include <Sddl.h>
#define NO_WBEM
#include "T_SafeVector.h"

#ifndef tstring
typedef std::basic_string<_TCHAR> tstring;
#endif

using namespace _com_util;
using namespace NAMECRACKER;

namespace _DomainContainer
{

void __stdcall GetNamingAttribute(PCTSTR pszDomain, PCTSTR pszClasses, StringSet& setAttributes);

tstring __stdcall CreateFilter(LPCTSTR pszFilter, const StringSet& setNamingAttributes, const StringSet& setExcludeNames);

bool __stdcall IsClass(LPCTSTR pszClass, const _variant_t& vntClass);

IDispatchPtr GetADsObject(_bstr_t strPath);
void ReportADsError(HRESULT hr, const IID& iid = GUID_NULL);

} // namespace _DomainContainer

using namespace _DomainContainer;

const HRESULT DOMAINCONTAINER_E_TOOMANYLEVELS =
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x200 + 1);


//---------------------------------------------------------------------------
// Domain Class
//---------------------------------------------------------------------------


// Constructors and Destructor ----------------------------------------------


CDomain::CDomain() :
    m_bInitialized(false),
	m_bUpLevel(false),
	m_bNativeMode(false)
{
}


CDomain::~CDomain()
{
}


// Implementation -----------------------------------------------------------


// Initialize Method
//
// Initializes domain parameters such as DNS domain name, Flat (NETBIOS) domain name,
// forest name, domain controller name.

void CDomain::Initialize(_bstr_t strDomainName)
{
	if (!strDomainName)
	{
		AdmtThrowError(
			GUID_NULL, GUID_NULL,
			E_INVALIDARG,
			IDS_E_DOMAIN_NAME_NOT_SPECIFIED
		);
	}

	// retrieve name of a domain controller in the domain

	GetDcName(strDomainName, m_strDcNameDns, m_strDcNameFlat);

	// retrieve domain information

	PDSROLE_PRIMARY_DOMAIN_INFO_BASIC ppdib;

	DWORD dwError = DsRoleGetPrimaryDomainInformation(
		DomainControllerName(),
		DsRolePrimaryDomainInfoBasic,
		(BYTE**)&ppdib
	);

	if (dwError != NO_ERROR)
	{
		AdmtThrowError(
			GUID_NULL, GUID_NULL,
			HRESULT_FROM_WIN32(dwError),
			IDS_E_CANT_GET_DOMAIN_INFORMATION,
			(LPCTSTR)strDomainName
		);
	}

	// initialize data members from domain information

	m_bUpLevel = (ppdib->Flags & DSROLE_PRIMARY_DS_RUNNING) ? true : false;
	m_bNativeMode = (m_bUpLevel && !(ppdib->Flags & DSROLE_PRIMARY_DS_MIXED_MODE)) ? true : false;

	if (ppdib->DomainNameDns)
	{
		m_strDomainNameDns = ppdib->DomainNameDns;
	}
	else
	{
		m_strDomainNameDns = _bstr_t();
	}

	if (ppdib->DomainNameFlat)
	{
		m_strDomainNameFlat = ppdib->DomainNameFlat;
	}
	else
	{
		m_strDomainNameFlat = _bstr_t();
	}

	if (ppdib->DomainForestName)
	{
		m_strForestName = ppdib->DomainForestName;
	}
	else
	{
		m_strForestName = _bstr_t();
	}

	DsRoleFreeMemory(ppdib);

	// initialize ADsPath

	if (m_bUpLevel)
	{
		m_strADsPath = _T("LDAP://") + m_strDomainNameDns;

		// retrieve global catalog server name for uplevel domains

//		m_strGcName = GetGcName();
	}
	else
	{
		m_strADsPath = _T("WinNT://") + m_strDomainNameFlat;
	}

	// retrieve domain sid

	m_strDomainSid = GetSid();

	// initialize dispatch interface pointer to active directory object

	m_sp = GetADsObject(m_strADsPath);

    m_bInitialized = true;
}


// GetDcName Method
//
// Retrieves name of domain controller in the given domain.

void CDomain::GetDcName(_bstr_t strDomainName, _bstr_t& strDnsName, _bstr_t& strFlatName)
{
    DWORD dwError = GetDcName5(strDomainName, DS_DIRECTORY_SERVICE_PREFERRED, strDnsName, strFlatName);

    if (dwError != NO_ERROR)
    {
        AdmtThrowError(
            GUID_NULL, GUID_NULL,
            HRESULT_FROM_WIN32(dwError),
            IDS_E_CANT_GET_DOMAIN_CONTROLLER,
            (LPCTSTR)strDomainName
        );
    }
}


// GetGcName Method
//
// Retrieves name of global catalog server.

_bstr_t CDomain::GetGcName()
{
	_bstr_t strName;

	PDOMAIN_CONTROLLER_INFO pdci;

	DWORD dwError = DsGetDcName(NULL, m_strForestName, NULL, NULL, DS_GC_SERVER_REQUIRED, &pdci);

	if (dwError == NO_ERROR)
	{
		strName = pdci->DomainControllerName;

		NetApiBufferFree(pdci);
	}
	else
	{
		AdmtThrowError(
			GUID_NULL, GUID_NULL,
			HRESULT_FROM_WIN32(dwError),
			IDS_E_CANT_GET_GLOBAL_CATALOG_SERVER,
			(LPCTSTR)m_strForestName
		);
	}

	return strName;
}


// GetSid Method

_bstr_t CDomain::GetSid()
{
	_bstr_t strSid;

	PUSER_MODALS_INFO_2 pumi2;

	if (NetUserModalsGet(DomainControllerName(), 2, (LPBYTE*)&pumi2) == NERR_Success)
	{
		if (IsValidSid(pumi2->usrmod2_domain_id))
		{
			LPTSTR pszSid;

			if (ConvertSidToStringSid(pumi2->usrmod2_domain_id, &pszSid))
			{
				strSid = pszSid;

				LocalFree(LocalHandle(pszSid));
			}
		}

		NetApiBufferFree(pumi2);
	}

	return strSid;
}


// GetContainer Method
//
// Retrieves a container given it's relative canonical path. Will
// optionally create container if create parameter is true and container
// does not already exist.

CContainer CDomain::GetContainer(_bstr_t strRelativeCanonicalPath, bool bCreate)
{
	CContainer aContainer;

	// return a non-empty container only if the domain is uplevel and a
	// relative canonical path is supplied

	if (m_bUpLevel && (strRelativeCanonicalPath.length() > 0))
	{
		if (bCreate)
		{
			tstring strPath = strRelativeCanonicalPath;

			// initialize parent container
			// if path separator is specified than initialize parent
			// container from ADsPath otherwise this container is the
			// parent container

			CContainer aParent;

			UINT pos = strPath.find_last_of(_T("/\\"));

			if (pos != tstring::npos)
			{
				aParent = GetLDAPPath(GetDistinguishedName(strPath.substr(0, pos).c_str()));
			}
			else
			{
				aParent = *this;
			}

			tstring strName = strPath.substr(pos + 1);

			CADsPathName aPathName(aParent.GetPath());

			tstring strRDN = _T("CN=") + strName;

			aPathName.AddLeafElement(strRDN.c_str());

			IDispatchPtr spDispatch;

			HRESULT hr = ADsGetObject(aPathName.Retrieve(ADS_FORMAT_X500), __uuidof(IDispatch), (void**)&spDispatch);

			if (SUCCEEDED(hr))
			{
				aContainer = CContainer(spDispatch);
			}
			else
			{
				strRDN = _T("OU=") + strName;
				aContainer = aParent.CreateContainer(strRDN.c_str());
			}
		}
		else
		{
			try
			{
				aContainer = GetLDAPPath(GetDistinguishedName(strRelativeCanonicalPath));
			}
			catch (_com_error& ce)
			{
				AdmtThrowError(GUID_NULL, GUID_NULL, ce, IDS_E_CANNOT_GET_CONTAINER, (LPCTSTR)strRelativeCanonicalPath);
			}
		}
	}

	return aContainer;
}


// GetLDAPPath

_bstr_t CDomain::GetLDAPPath(_bstr_t strDN)
{
	_bstr_t strPath = _T("LDAP://") + m_strDomainNameDns;

	if (strDN.length() > 0)
	{
		strPath += _T("/") + strDN;
	}

	return strPath;
}


// GetWinNTPath

_bstr_t CDomain::GetWinNTPath(_bstr_t strName)
{
    const _TCHAR c_chEscape = _T('\\');
    static _TCHAR s_chSpecial[] = _T("\",/<>");

    tstring strPath;

    _TCHAR* pchOld = strName;

    if (pchOld)
    {
        std::auto_ptr<_TCHAR> spEscapedName(new _TCHAR[strName.length() * 2 + 1]);

        if (spEscapedName.get() == NULL)
        {
            _com_issue_error(E_OUTOFMEMORY);
        }

        _TCHAR* pchNew = spEscapedName.get();

        while (*pchOld)
        {
            if (_tcschr(s_chSpecial, *pchOld))
            {
                *pchNew++ = c_chEscape;
            }

            *pchNew++ = *pchOld++;
        }

        *pchNew = _T('\0');

        strPath += _T("WinNT://");
        strPath += m_strDomainNameFlat;
        strPath += _T("/");
        strPath += spEscapedName.get();
    }

    return strPath.c_str();
}


// GetDistinguishedName Method

_bstr_t CDomain::GetDistinguishedName(_bstr_t strRelativeCanonicalPath)
{
	_bstr_t strDN;

	HRESULT hr = S_OK;

	HANDLE hDS;

	DWORD dwError = DsBind(DomainControllerName(), NULL, &hDS);

	if (dwError == NO_ERROR)
	{
		_bstr_t strCanonicalName = m_strDomainNameDns + _T("/") + strRelativeCanonicalPath;

		LPTSTR psz = strCanonicalName;

		PDS_NAME_RESULT pnr;

		dwError = DsCrackNames(hDS, DS_NAME_NO_FLAGS, DS_CANONICAL_NAME, DS_FQDN_1779_NAME, 1, &psz, &pnr);

		if (dwError == NO_ERROR)
		{
			if (pnr->rItems[0].status == DS_NAME_NO_ERROR)
			{
				strDN = pnr->rItems[0].pName;
			}
			else
			{
				hr = AdmtSetError(
					GUID_NULL, GUID_NULL,
					E_INVALIDARG,
					IDS_E_CANT_GET_DISTINGUISHED_NAME,
					(LPCTSTR)strCanonicalName
				);
			}

			DsFreeNameResult(pnr);
		}
		else
		{
			hr = AdmtSetError(
				GUID_NULL, GUID_NULL,
				HRESULT_FROM_WIN32(dwError),
				IDS_E_CANT_GET_DISTINGUISHED_NAME,
				(LPCTSTR)strCanonicalName
			);
		}

		DsUnBind(&hDS);
	}
	else
	{
		hr = AdmtSetError(
			GUID_NULL, GUID_NULL,
			HRESULT_FROM_WIN32(dwError),
			IDS_E_CANT_CONNECT_TO_DIRECTORY_SERVICE,
			(LPCTSTR)m_strDomainNameDns
		);
	}

	if (hr != S_OK)
	{
		_com_issue_error(hr);
	}

	return strDN;
}


// CreateContainer Method

CContainer CDomain::CreateContainer(_bstr_t strRDN)
{
	CContainer aContainer;

	if (m_bUpLevel)
	{
	    aContainer = CContainer::CreateContainer(strRDN);
	}
	else
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, E_FAIL, IDS_E_CANT_CREATE_CONTAINER_NT4);
	}

	return aContainer;
}

// QueryContainers Method

void CDomain::QueryContainers(ContainerVector& rContainers)
{
	if (m_bUpLevel)
	{
		CContainer::QueryContainers(rContainers);
	}
}


// QueryUsers Method

void CDomain::QueryUsers(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rUsers)
{
	if (m_bUpLevel)
	{
		CContainer::QueryUsers(bRecurse, setExcludeNames, rUsers);
	}
	else
	{
		QueryUsers4(setExcludeNames, rUsers);
	}
}


// QueryUsers Method

void CDomain::QueryUsers(CContainer& rContainer, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rUsers)
{
	if (m_bUpLevel)
	{
		QueryObjects(rContainer, setIncludeNames, setExcludeNames, _T("user,inetOrgPerson"), rUsers);
	}
	else
	{
		QueryUsers4(setIncludeNames, setExcludeNames, rUsers);
	}
}


// QueryGroups Method

void CDomain::QueryGroups(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rGroups)
{
	if (m_bUpLevel)
	{
		CContainer::QueryGroups(bRecurse, setExcludeNames, rGroups);
	}
	else
	{
		QueryGroups4(setExcludeNames, rGroups);
	}
}


// QueryGroups Method

void CDomain::QueryGroups(CContainer& rContainer, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rGroups)
{
	if (m_bUpLevel)
	{
		QueryObjects(rContainer, setIncludeNames, setExcludeNames, _T("group"), rGroups);
	}
	else
	{
		QueryGroups4(setIncludeNames, setExcludeNames, rGroups);
	}
}


// QueryComputers Method

void CDomain::QueryComputers(bool bIncludeDCs, bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rComputers)
{
	if (m_bUpLevel)
	{
		CContainer::QueryComputers(bIncludeDCs, bRecurse, setExcludeNames, rComputers);
	}
	else
	{
		QueryComputers4(bIncludeDCs, setExcludeNames, rComputers);
	}
}


// QueryComputers Method

void CDomain::QueryComputers(CContainer& rContainer, bool bIncludeDCs, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rComputers)
{
	if (m_bUpLevel)
	{
		QueryObjects(rContainer, setIncludeNames, setExcludeNames, _T("computer"), rComputers);

		if (!bIncludeDCs)
		{
			for (CDomainAccounts::iterator it = rComputers.begin(); it != rComputers.end();)
			{
				long lUserAccountControl = it->GetUserAccountControl();

				if (lUserAccountControl & ADS_UF_SERVER_TRUST_ACCOUNT)
				{
					_Module.Log(ErrW, IDS_E_CANNOT_MIGRATE_DOMAIN_CONTROLLERS, (LPCTSTR)it->GetADsPath());

					it = rComputers.erase(it);
				}
				else
				{
					it++;
				}
			}
		}
	}
	else
	{
		QueryComputers4(bIncludeDCs, setIncludeNames, setExcludeNames, rComputers);
	}
}


// QueryComputersAcrossDomains Method

void CDomain::QueryComputersAcrossDomains(CContainer& rContainer, bool bIncludeDCs, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rComputers)
{
	CDomainToPathMap mapDomainToPath;

	mapDomainToPath.Initialize(m_strDomainNameDns, m_strDomainNameFlat, setIncludeNames);

	for (CDomainToPathMap::iterator it = mapDomainToPath.begin(); it != mapDomainToPath.end(); it++)
	{
		_bstr_t strDomainName = it->first;

		try
		{
			CDomain domain;
			domain.Initialize(strDomainName);
			domain.QueryComputers(rContainer, bIncludeDCs, it->second, setExcludeNames, rComputers);
		}
		catch (_com_error& ce)
		{
			_Module.Log(ErrE, IDS_E_CANNOT_PROCESS_ACCOUNTS_IN_DOMAIN, (LPCTSTR)strDomainName, ce.ErrorMessage(), ce.Error());
		}
		catch (...)
		{
			_Module.Log(ErrE, IDS_E_CANNOT_PROCESS_ACCOUNTS_IN_DOMAIN, (LPCTSTR)strDomainName, _com_error(E_FAIL).ErrorMessage(), E_FAIL);
		}
	}
}


// QueryObjects Method

void CDomain::QueryObjects(CContainer& rContainer, StringSet& setIncludeNames, StringSet& setExcludeNames, LPCTSTR pszClass, CDomainAccounts& rAccounts)
{
    // copy specified include names to vector

    StringVector vecNames;

    for (StringSet::const_iterator itInclude = setIncludeNames.begin(); itInclude != setIncludeNames.end(); itInclude++)
    {
        vecNames.push_back(tstring(*itInclude));
    }

    // crack names

    CNameCracker cracker;

    cracker.SetDomainNames(m_strDomainNameDns, m_strDomainNameFlat, DomainControllerName());
    cracker.SetDefaultContainer(IADsContainerPtr(rContainer.GetInterface()));

    cracker.CrackNames(vecNames);

    // log un-resolved names

    const StringVector& vecUnResolved = cracker.GetUnResolvedNames();

    for (StringVector::const_iterator itUnResolved = vecUnResolved.begin(); itUnResolved != vecUnResolved.end(); itUnResolved++)
    {
        _Module.Log(ErrW, IDS_E_CANNOT_RESOLVE_NAME, itUnResolved->c_str());
    }

    // retrieve naming attributes for classes being migrated

    StringSet setNamingAttributes;
    GetNamingAttribute(m_strDomainNameDns, pszClass, setNamingAttributes);

    // initialize compare exclude names
    // we need to separate name and samaccountname excluding lists
    StringSet setExcludeRDNs;
    StringSet setExcludeSamAccountNames;
    cracker.SiftExcludeNames(setExcludeNames, setNamingAttributes, setExcludeRDNs, setExcludeSamAccountNames);

    CCompareRDNs csExcludeRDNs(setExcludeRDNs);
    CCompareStrings csExcludeSamAccountNames(setExcludeSamAccountNames);

    // add resolved accounts

    const CStringSet& setResolved = cracker.GetResolvedNames();

    CADsPathName pathname;
    pathname.Set(_T("LDAP"), ADS_SETTYPE_PROVIDER);
    pathname.Set(m_strDomainNameDns, ADS_SETTYPE_SERVER);

    CDirectoryObject doObject;

    doObject.AddAttribute(ATTRIBUTE_OBJECT_CLASS);
    doObject.AddAttribute(ATTRIBUTE_OBJECT_SID);
    doObject.AddAttribute(ATTRIBUTE_NAME);
    doObject.AddAttribute(ATTRIBUTE_USER_PRINCIPAL_NAME);
    doObject.AddAttribute(ATTRIBUTE_SAM_ACCOUNT_NAME);

    if (_tcsicmp(pszClass, _T("computer")) == 0)
    {
        doObject.AddAttribute(_T("dNSHostName"));
    }

    doObject.AddAttribute(ATTRIBUTE_USER_ACCOUNT_CONTROL);

    for (CStringSet::const_iterator itResolved = setResolved.begin(); itResolved != setResolved.end(); itResolved++)
    {
        try
        {
            // get active directory service path
            // Note: the pathname component will, if necessary, escape any special characters
            pathname.Set(itResolved->c_str(), ADS_SETTYPE_DN);
            _bstr_t strADsPath = pathname.Retrieve(ADS_FORMAT_X500);
            _bstr_t strRDN = pathname.GetElement(0L);

            // get object attributes
            doObject = (LPCTSTR)strADsPath;
            doObject.GetAttributes();

            // if the object is of the specified account class...

            _variant_t vntClass = doObject.GetAttributeValue(ATTRIBUTE_OBJECT_CLASS);

            if (IsClass(pszClass, vntClass))
            {
                // and it does not represent a built-in account...

                _variant_t vntSid = doObject.GetAttributeValue(ATTRIBUTE_OBJECT_SID);

                if (IsUserRid(vntSid))
                {
                    // then if name is not in exclusion list...

                    _bstr_t strName = doObject.GetAttributeValue(ATTRIBUTE_NAME);
                    _variant_t vntSamAccountName = doObject.GetAttributeValue(ATTRIBUTE_SAM_ACCOUNT_NAME);

                    if (csExcludeRDNs.IsMatch(strRDN) == false &&
                        (V_VT(&vntSamAccountName) == VT_EMPTY || 
                        csExcludeSamAccountNames.IsMatch(_bstr_t(vntSamAccountName)) == false))
                    {
                        //
                        // then add account to account list
                        //

                        CDomainAccount daAccount;

                        // active directory service path
                        daAccount.SetADsPath(strADsPath);

                        // name attribute
                        daAccount.SetName(strName);

                        // user principal name attribute

                        _variant_t vntUserPrincipalName = doObject.GetAttributeValue(ATTRIBUTE_USER_PRINCIPAL_NAME);

                        if (V_VT(&vntUserPrincipalName) != VT_EMPTY)
                        {
                            daAccount.SetUserPrincipalName(_bstr_t(vntUserPrincipalName));
                        }

                        // sam account name attribute

                        if (V_VT(&vntSamAccountName) != VT_EMPTY)
                        {
                            daAccount.SetSamAccountName(_bstr_t(vntSamAccountName));
                        }

                        // DNS host name attribute

                        _variant_t vntDnsHostName = doObject.GetAttributeValue(_T("dNSHostName"));

                        if (V_VT(&vntDnsHostName) != VT_EMPTY)
                        {
                            daAccount.SetDnsHostName(_bstr_t(vntDnsHostName));
                        }

                        // user account control attribute

                        _variant_t vntUserAccountControl = doObject.GetAttributeValue(ATTRIBUTE_USER_ACCOUNT_CONTROL);

                        if (V_VT(&vntUserAccountControl) != VT_EMPTY)
                        {
                            daAccount.SetUserAccountControl(vntUserAccountControl);
                        }

                        rAccounts.insert(daAccount);
                    }
                    else
                    {
                        _Module.Log(ErrW, IDS_E_ACCOUNT_EXCLUDED, itResolved->c_str());
                    }
                }
                else
                {
                    _Module.Log(ErrW, IDS_E_CANT_DO_BUILTIN, itResolved->c_str());
                }
            }
            else
            {
                _Module.Log(ErrW, IDS_E_OBJECT_NOT_OF_CLASS, itResolved->c_str());
            }
        }
        catch (_com_error& ce)
        {
            ATLTRACE(_T("'%s' : %s : 0x%08lX\n"), itResolved->c_str(), ce.ErrorMessage(), ce.Error());
        }
        catch (...)
        {
            ATLTRACE(_T("'%s' : %s : 0x%08lX\n"), itResolved->c_str(), _com_error(E_FAIL).ErrorMessage(), E_FAIL);
        }
    }
}


// QueryUsers4 Method

void CDomain::QueryUsers4(StringSet& setExcludeNames, CDomainAccounts& rUsers)
{
	CCompareStrings aExclude(setExcludeNames);

	DWORD dwIndex = 0;
	NET_API_STATUS status;

	CDomainAccount aUser;

	do
	{
		DWORD dwCount = 0;
		PNET_DISPLAY_USER pdu = NULL;

		status = NetQueryDisplayInformation(m_strDcNameFlat, 1, dwIndex, 1000, 32768, &dwCount, (PVOID*)&pdu);

		if ((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA))
		{
			for (PNET_DISPLAY_USER p = pdu; dwCount > 0; dwCount--, p++)
			{
				if (p->usri1_user_id >= MIN_NON_RESERVED_RID)
				{
					_bstr_t strName(p->usri1_name);

					if (aExclude.IsMatch(strName) == false)
					{
						aUser.SetADsPath(GetWinNTPath(strName));
						aUser.SetName(strName);

						rUsers.insert(aUser);
					}
				}

				dwIndex = p->usri1_next_index;
			}
		}

		if (pdu)
		{
			NetApiBufferFree(pdu);
		}
	}
	while (status == ERROR_MORE_DATA);
}


// QueryUsers4 Method

void CDomain::QueryUsers4(StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rUsers)
{
	CCompareStrings aExclude(setExcludeNames);

	CDomainAccount aUser;

	for (StringSet::iterator it = setIncludeNames.begin(); it != setIncludeNames.end(); it++)
	{
		_bstr_t strName = *it;

		if (aExclude.IsMatch(strName) == false)
		{
			_bstr_t strADsPath = GetWinNTPath(strName) + _T(",user");

			IADsPtr spADs;
			HRESULT hr = ADsGetObject(strADsPath, IID_IADs, (VOID**)&spADs);

			if (SUCCEEDED(hr))
			{
				BSTR bstr;

// The WinNT: provider does not return all ADsPaths correctly escaped
// (ie. it does not escape the double quote (") character)
// The member method GetWinNTPath does escape all known special characters.
#if 0
				spADs->get_ADsPath(&bstr);
				aUser.SetADsPath(_bstr_t(bstr, false));
#else
				aUser.SetADsPath(GetWinNTPath(strName));
#endif
				spADs->get_Name(&bstr);
				aUser.SetName(_bstr_t(bstr, false));

				rUsers.insert(aUser);
			}
			else
			{
				_Module.Log(ErrE, IDS_E_CANT_ADD_USER, (LPCTSTR)strADsPath, _com_error(hr).ErrorMessage());
			}
		}
	}
}


// QueryGroups4 Method

void CDomain::QueryGroups4(StringSet& setExcludeNames, CDomainAccounts& rGroups)
{
    //
    // Construct container helper class.
    //

    CADsContainer container(m_sp);

    //
    // Set container filter property so that only groups will be enumerated.
    //

    LPWSTR pszFilter[] = { L"Group" };
    VARIANT varFilter;
    VariantInit(&varFilter);
    CheckError(ADsBuildVarArrayStr(pszFilter, sizeof(pszFilter) / sizeof(pszFilter[0]), &varFilter));
    container.SetFilter(_variant_t(varFilter, false));

    //
    // Retrieve enumerator interface.
    //

    IEnumVARIANTPtr spEnum = container.GetEnumerator();

    //
    // Declare and initialize variables for enumerator next method.
    //

    VARIANT varGroup;
    VariantInit(&varGroup);
    ULONG ulFetched = 0;

    //
    // Declare other variables.
    //

    _bstr_t strAttrObjectSid(L"ObjectSid");

    CCompareStrings aExclude(setExcludeNames);
    CDomainAccount aGroup;

    //
    // For each group...
    //

    while ((spEnum->Next(1L, &varGroup, &ulFetched) == S_OK) && (ulFetched > 0))
    {
        CADs group(IADsPtr(_variant_t(varGroup, false)));

        //
        // If not a built-in group.
        //

        if (IsUserRid(group.Get(strAttrObjectSid)))
        {
            //
            // If name pattern has not been excluded.
            //

            _bstr_t strName = group.GetName();

            if (aExclude.IsMatch(strName) == false)
            {
                //
                // Add group to set of groups to migrate.
                //

                aGroup.SetADsPath(GetWinNTPath(strName));
                aGroup.SetName(strName);

                rGroups.insert(aGroup);
            }
        }
    }
}


// QueryGroups4 Method

void CDomain::QueryGroups4(StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rGroups)
{
	CCompareStrings aExclude(setExcludeNames);

	CDomainAccount aGroup;

	for (StringSet::iterator it = setIncludeNames.begin(); it != setIncludeNames.end(); it++)
	{
		_bstr_t strName = *it;

		if (aExclude.IsMatch(strName) == false)
		{
			_bstr_t strADsPath = GetWinNTPath(strName) + _T(",group");

			IADsPtr spADs;
			HRESULT hr = ADsGetObject(strADsPath, IID_IADs, (VOID**)&spADs);

			if (SUCCEEDED(hr))
			{
				BSTR bstr;

				spADs->get_ADsPath(&bstr);
				aGroup.SetADsPath(_bstr_t(bstr, false));

				spADs->get_Name(&bstr);
				aGroup.SetName(_bstr_t(bstr, false));

				rGroups.insert(aGroup);
			}
			else
			{
				_Module.Log(ErrE, IDS_E_CANT_ADD_GROUP, (LPCTSTR)strADsPath, _com_error(hr).ErrorMessage());
			}
		}
	}
}


// QueryComputers4 Method

void CDomain::QueryComputers4(bool bIncludeDCs, StringSet& setExcludeNames, CDomainAccounts& rComputers)
{
	CCompareStrings aExclude(setExcludeNames);

	DWORD dwIndex = 0;
	NET_API_STATUS status;

	CDomainAccount aComputer;

	DWORD dwflags = bIncludeDCs ? UF_WORKSTATION_TRUST_ACCOUNT|UF_SERVER_TRUST_ACCOUNT : UF_WORKSTATION_TRUST_ACCOUNT;

	do
	{
		DWORD dwCount = 0;
		PNET_DISPLAY_MACHINE pdm = NULL;

		status = NetQueryDisplayInformation(m_strDcNameFlat, 2, dwIndex, 1000, 32768, &dwCount, (PVOID*)&pdm);

		if ((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA))
		{
			for (PNET_DISPLAY_MACHINE p = pdm; dwCount > 0; dwCount--, p++)
			{
				if ((p->usri2_user_id >= MIN_NON_RESERVED_RID) && (p->usri2_flags & dwflags))
				{
					_bstr_t strName(p->usri2_name);

					if (aExclude.IsMatch(strName) == false)
					{
						aComputer.SetADsPath(GetWinNTPath(strName));
						aComputer.SetName(strName);
						aComputer.SetSamAccountName(strName);

						rComputers.insert(aComputer);
					}
				}

				dwIndex = p->usri2_next_index;
			}
		}

		if (pdm)
		{
			NetApiBufferFree(pdm);
		}
	}
	while (status == ERROR_MORE_DATA);
}


// QueryComputers4 Method

void CDomain::QueryComputers4(bool bIncludeDCs, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rComputers)
{
	typedef std::map<_bstr_t, DWORD, IgnoreCaseStringLess> CMachineMap;

	PNET_DISPLAY_MACHINE pndmMachine = NULL;

	try
	{
		CMachineMap map;

		DWORD dwIndex = 0;
		NET_API_STATUS nasStatus;

		do
		{
			DWORD dwCount = 0;

			nasStatus = NetQueryDisplayInformation(m_strDcNameFlat, 2, dwIndex, 256, 32768, &dwCount, (PVOID*)&pndmMachine);

			if ((nasStatus == ERROR_SUCCESS) || (nasStatus == ERROR_MORE_DATA))
			{
				for (PNET_DISPLAY_MACHINE p = pndmMachine; dwCount > 0; dwCount--, p++)
				{
					map.insert(CMachineMap::value_type(p->usri2_name, p->usri2_flags));

					dwIndex = p->usri2_next_index;
				}
			}

			if (pndmMachine)
			{
				NetApiBufferFree(pndmMachine);
				pndmMachine = NULL;
			}
		}
		while (nasStatus == ERROR_MORE_DATA);

		if (nasStatus != ERROR_SUCCESS)
		{
			AdmtThrowError(
				GUID_NULL,
				GUID_NULL,
				HRESULT_FROM_WIN32(nasStatus),
				IDS_E_CANT_ENUMERATE_COMPUTERS,
				(LPCTSTR)m_strDomainNameFlat
			);
		}

		CCompareStrings aExclude(setExcludeNames);

		for (StringSet::iterator it = setIncludeNames.begin(); it != setIncludeNames.end(); it++)
		{
			tstring str = *it;

			if ((str[0] == _T('\\')) || (str[0] == _T('/')))
			{
				str = str.substr(1);
			}

			_bstr_t strName = str.c_str();

			if (aExclude.IsMatch(strName) == false)
			{
				_bstr_t strPath = GetWinNTPath(strName);

				CMachineMap::iterator it = map.find(strName + _T("$"));

				if (it != map.end())
				{
					if (bIncludeDCs || !(it->second & UF_SERVER_TRUST_ACCOUNT))
					{
						CDomainAccount aComputer;

						aComputer.SetADsPath(strPath);
						aComputer.SetName(strName);
						aComputer.SetSamAccountName(strName + _T("$"));

						rComputers.insert(aComputer);
					}
					else
					{
						_Module.Log(ErrW, IDS_E_CANT_MIGRATE_DOMAIN_CONTROLLERS, (LPCTSTR)strPath);
					}
				}
				else
				{
					_Module.Log(ErrW, IDS_E_CANT_FIND_COMPUTER, (LPCTSTR)strPath);
				}
			}
		}
	}
	catch (...)
	{
		if (pndmMachine)
		{
			NetApiBufferFree(pndmMachine);
		}

		throw;
	}
}


//---------------------------------------------------------------------------
// Container Class
//---------------------------------------------------------------------------


// Constructors and Destructor ----------------------------------------------


CContainer::CContainer()
{
}


CContainer::CContainer(IDispatchPtr sp) :
	m_sp(sp)
{
}


CContainer::CContainer(_bstr_t strPath)
{
	HRESULT hr = ADsGetObject(strPath, __uuidof(IDispatch), (void**)&m_sp);

	if (FAILED(hr))
	{
		ReportADsError(hr);

		_com_issue_error(hr);
	}
}


CContainer::CContainer(const CContainer& r) :
	m_sp(r.m_sp)
{
}


CContainer::~CContainer()
{
	if (m_sp)
	{
		m_sp.Release();
	}
}


// Implementation -----------------------------------------------------------


// operator =

CContainer& CContainer::operator =(_bstr_t strPath)
{
	HRESULT hr = ADsGetObject(strPath, __uuidof(IDispatch), (void**)&m_sp);

	if (FAILED(hr))
	{
		ReportADsError(hr);

		_com_issue_error(hr);
	}

	return *this;
}


// operator =

CContainer& CContainer::operator =(const CContainer& r)
{
	m_sp = r.m_sp;

	return *this;
}


// GetPath Method

_bstr_t CContainer::GetPath()
{
	IDirectoryObjectPtr spObject(m_sp);

	PADS_OBJECT_INFO poi;

	CheckError(spObject->GetObjectInformation(&poi));

	// the ADS_OBJECT_INFO member pszObjectDN actually
	// specifies the ADsPath not the distinguished name

	_bstr_t strPath = poi->pszObjectDN;

	FreeADsMem(poi);

	return strPath;
}


// GetDomain Method

_bstr_t CContainer::GetDomain()
{
	CADsPathName aPathName(GetPath());

	return aPathName.Retrieve(ADS_FORMAT_SERVER);
}


// GetName Method

_bstr_t CContainer::GetName()
{
	CDirectoryObject aObject(m_sp);

	aObject.AddAttribute(ATTRIBUTE_NAME);
	aObject.GetAttributes();

	return aObject.GetAttributeValue(ATTRIBUTE_NAME);
}


// GetRDN Method

_bstr_t CContainer::GetRDN()
{
	IDirectoryObjectPtr spObject(m_sp);

	PADS_OBJECT_INFO poi;

	CheckError(spObject->GetObjectInformation(&poi));

	_bstr_t strRDN = poi->pszRDN;

	FreeADsMem(poi);

	return strRDN;
}


// CreateContainerHierarchy Method

// this version serves as a wrapper around the next version
// it converts DOMAINCONTAINER_E_TOOMANYLEVELS back to E_NOTIMPL

void CContainer::CreateContainerHierarchy(CContainer& rSource)
{
    try
    {
        CreateContainerHierarchy(rSource, false);
    }
    catch (_com_error& ce) 
    {
        if (ce.Error() == DOMAINCONTAINER_E_TOOMANYLEVELS)
        {
            // restore the original HRESULT
            _com_raise_error(E_NOTIMPL, ce.ErrorInfo());
        }
        else
            throw;
    }
}
        
// this version does the clean-up in case the hierarchy gets too deep

void CContainer::CreateContainerHierarchy(CContainer& rSource, bool bParentIsCreated)
{
	ContainerVector cvContainers;
    ContainerVector createdContainers;
	rSource.QueryContainers(cvContainers);
	bool bCreated;

	for (ContainerVector::iterator it = cvContainers.begin(); it != cvContainers.end(); it++)
	{
	    try
	    {
	        // always assume that the container exists in the first place
	        bCreated = false;
		    CContainer aTarget = CreateContainer(_T("OU=") + it->GetName(), bCreated);

		    // if the container is actually created, we need to make a note so that
		    // we could clean it up if necessary
		    if (bCreated) {
		        createdContainers.push_back(aTarget);
		    }

		    // now build the hierarchy under the container just created
            aTarget.CreateContainerHierarchy(*it, bCreated);
	    }
	    catch (_com_error& ce) {

	        // if the parent container is not created, we have to clean up all
	        // those containers just created right now; otherwise, we can throw
	        // the exception and expect cleanup to happen at the parent level
	        if (ce.Error() == DOMAINCONTAINER_E_TOOMANYLEVELS
	            && bParentIsCreated == false) {
	            
	            for (ContainerVector::iterator cleanUpIterator = createdContainers.begin();
	                cleanUpIterator != createdContainers.end();
	                cleanUpIterator++) 
	            {
	                // use a recursive delete
	                cleanUpIterator->DeleteContainersRecursively();
	            }
	        }
	                
	        throw;
	    }
	}
}


// GetContainer Method

CContainer CContainer::GetContainer(_bstr_t strName)
{
	IDispatchPtr spDispatch;

	CADsPathName aPathName(GetPath());

	// try organizational unit first

	aPathName.AddLeafElement(_T("OU=") + strName);

	HRESULT hr = ADsGetObject(aPathName.Retrieve(ADS_FORMAT_X500), __uuidof(IDispatch), (void**)&spDispatch);

	if (FAILED(hr))
	{
	//	if (hr == ?)
	//	{
			// then try container

			aPathName.RemoveLeafElement();
			aPathName.AddLeafElement(_T("CN=") + strName);

			CheckError(ADsGetObject(aPathName.Retrieve(ADS_FORMAT_X500), __uuidof(IDispatch), (void**)&spDispatch));
	//	}
	//	else
	//	{
	//		_com_issue_error(hr);
	//	}
	}

	return CContainer(spDispatch);
}

// CreateContainer method
//  use this version if you don't use it for CreateContainerHierarchy
CContainer CContainer::CreateContainer(_bstr_t strRDN)
{
    bool bCreated = false;
    CContainer aContainer(NULL);
    try
    {
        aContainer = CreateContainer(strRDN, bCreated);
    }
    catch (_com_error& ce)
    {
        if (ce.Error() == DOMAINCONTAINER_E_TOOMANYLEVELS)
        {
            // restore the original HRESULT
            _com_raise_error(E_NOTIMPL, ce.ErrorInfo());
        }
        else
            throw;
    }
    
    return aContainer;
}
    
// CreateContainer Method
//  this version is used with CreateContainerHierarchy
//  the flag bCreated tells whether the returned container is created or not
//  this method returns DOMAINCONTAINER_E_TOOMANYLEVELS if the hierarchy is too deep

CContainer CContainer::CreateContainer(_bstr_t strRDN, bool& bCreated)
{
	IDispatchPtr spDispatch;

	CADsPathName aPathName(GetPath());

	bCreated = false;

	try 
	{
	    aPathName.AddLeafElement(strRDN);
	}
	catch (_com_error& ce)
    {
        // E_NOTIMPL returned by IADsPathname::AddLeafElement means
        // too many nested levels
        // we throw DOMAINCONTAINER_E_TOOMANYLEVELS
        if (E_NOTIMPL == ce.Error())
        {
            // we catch the error we throw and replace the HRESULT
            try {
                AdmtThrowError(GUID_NULL, GUID_NULL, ce,
                                IDS_E_CANT_CREATE_CONTAINER_THAT_DEEPLY_NESTED,
                                (LPCTSTR) strRDN, (LPCTSTR) aPathName.Retrieve(ADS_FORMAT_LEAF));
            }
            catch (_com_error& newCE) {
                _com_raise_error(DOMAINCONTAINER_E_TOOMANYLEVELS, newCE.ErrorInfo());
            }
        }
        else
            throw;
            
    }

    _bstr_t strPath = aPathName.Retrieve(ADS_FORMAT_X500);
    
	HRESULT hr = ADsGetObject(strPath, __uuidof(IDispatch), (void**)&spDispatch);

	if (FAILED(hr))
	{
		ADSVALUE valueClass;
		valueClass.dwType = ADSTYPE_CASE_IGNORE_STRING;
		valueClass.CaseIgnoreString = L"organizationalUnit";

		ADS_ATTR_INFO aiAttrs[] =
		{
			{ L"objectClass", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING, &valueClass, 1 },
		};
		DWORD dwAttrCount = sizeof(aiAttrs) / sizeof(aiAttrs[0]);

		IDirectoryObjectPtr spObject(m_sp);

		HRESULT hr = spObject->CreateDSObject(strRDN, aiAttrs, dwAttrCount, &spDispatch);

		if (FAILED(hr))
		{
            AdmtThrowError(GUID_NULL, GUID_NULL, hr, IDS_E_CANNOT_CREATE_CONTAINER, (LPCTSTR)strRDN, (LPCTSTR)GetPath());
		}
		else
		{
            // indicate that this container is actually created
		    bCreated = true;
	    }
	}

	return CContainer(spDispatch);
}

// delete the container
void CContainer::DeleteContainersRecursively()
{
    IADsDeleteOpsPtr deleteObject(m_sp);
    HRESULT hr = deleteObject->DeleteObject(0);
    if (FAILED(hr)) 
    {
        ReportADsError(hr, IID_IDirectoryObject);
        _com_issue_error(hr);

    }
}

// QueryContainers Method

void CContainer::QueryContainers(ContainerVector& rContainers)
{
	CDirectorySearch aSearch(m_sp);
	aSearch.SetFilter(_T("(|(objectCategory=OrganizationalUnit)(&(objectCategory=Container)(|(cn=Computers)(cn=Users))))"));
	aSearch.SetPreferences(ADS_SCOPE_ONELEVEL);
	aSearch.AddAttribute(ATTRIBUTE_ADS_PATH);
	aSearch.Search();

	for (bool bGet = aSearch.GetFirstRow(); bGet; bGet = aSearch.GetNextRow())
	{
		CContainer aContainer(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_ADS_PATH)));

		rContainers.push_back(aContainer);
	}
}


// QueryUsers Method

void CContainer::QueryUsers(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rUsers)
{
    // retrieve naming attributes for user and inetOrgPerson classes

    StringSet setNamingAttributes;
    GetNamingAttribute(GetDomain(), _T("user,inetOrgPerson"), setNamingAttributes);

    tstring strFilter = CreateFilter(
        _T("(objectCategory=Person)(|(objectClass=user)(objectClass=inetOrgPerson))")
        _T("(userAccountControl:") LDAP_MATCHING_RULE_BIT_OR_W _T(":=512)"),
        setNamingAttributes,
        setExcludeNames
        );

    CDirectorySearch aSearch(m_sp);
    aSearch.SetFilter(strFilter.c_str());
    aSearch.SetPreferences(bRecurse ? ADS_SCOPE_SUBTREE : ADS_SCOPE_ONELEVEL);
    aSearch.AddAttribute(ATTRIBUTE_OBJECT_SID);
    aSearch.AddAttribute(ATTRIBUTE_ADS_PATH);
    aSearch.AddAttribute(ATTRIBUTE_NAME);
    aSearch.AddAttribute(ATTRIBUTE_USER_PRINCIPAL_NAME);
    aSearch.Search();

    CDomainAccount aUser;

    for (bool bGet = aSearch.GetFirstRow(); bGet; bGet = aSearch.GetNextRow())
    {
        // if not a built-in or well known account

        if (IsUserRid(aSearch.GetAttributeValue(ATTRIBUTE_OBJECT_SID)))
        {
            // add user

            aUser.SetADsPath(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_ADS_PATH)));
            aUser.SetName(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_NAME)));

            _variant_t vntUserPrincipalName = aSearch.GetAttributeValue(ATTRIBUTE_USER_PRINCIPAL_NAME);

            if (V_VT(&vntUserPrincipalName) != VT_EMPTY)
            {
                aUser.SetUserPrincipalName(_bstr_t(vntUserPrincipalName));
            }

            rUsers.insert(aUser);
        }
    }
}


// QueryGroups Method

void CContainer::QueryGroups(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rGroups)
{
    // retrieve naming attribute for group

    StringSet setNamingAttributes;
    GetNamingAttribute(GetDomain(), _T("group"), setNamingAttributes);

    tstring strFilter = CreateFilter(_T("(objectCategory=Group)"), setNamingAttributes, setExcludeNames);

    CDirectorySearch aSearch(m_sp);
    aSearch.SetFilter(strFilter.c_str());
    aSearch.SetPreferences(bRecurse ? ADS_SCOPE_SUBTREE : ADS_SCOPE_ONELEVEL);
    aSearch.AddAttribute(ATTRIBUTE_OBJECT_SID);
    aSearch.AddAttribute(ATTRIBUTE_ADS_PATH);
    aSearch.AddAttribute(ATTRIBUTE_NAME);
    aSearch.Search();

    CDomainAccount aGroup;

    for (bool bGet = aSearch.GetFirstRow(); bGet; bGet = aSearch.GetNextRow())
    {
        // if not a built-in or well known account

        if (IsUserRid(aSearch.GetAttributeValue(ATTRIBUTE_OBJECT_SID)))
        {
            // add group

            aGroup.SetADsPath(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_ADS_PATH)));
            aGroup.SetName(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_NAME)));

            rGroups.insert(aGroup);
        }
    }
}


// QueryComputers Method

void CContainer::QueryComputers(bool bIncludeDCs, bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rComputers)
{
    // retrieve naming attribute for computer

    StringSet setNamingAttributes;
    GetNamingAttribute(GetDomain(), _T("computer"), setNamingAttributes);

    tstring strFilter;

    // ADS_UF_WORKSTATION_TRUST_ACCOUNT = 0x1000
    // ADS_UF_SERVER_TRUST_ACCOUNT      = 0x2000

    if (bIncludeDCs)
    {
        strFilter = CreateFilter(
            _T("(objectCategory=Computer)")
            _T("(userAccountControl:") LDAP_MATCHING_RULE_BIT_OR_W _T(":=4096)"),
            setNamingAttributes,
            setExcludeNames
            );
    }
    else
    {
        strFilter = CreateFilter(
            _T("(objectCategory=Computer)")
            _T("(|(userAccountControl:") LDAP_MATCHING_RULE_BIT_OR_W _T(":=4096)")
            _T("(userAccountControl:") LDAP_MATCHING_RULE_BIT_OR_W _T(":=8192))"),
            setNamingAttributes,
            setExcludeNames
            );
    }

    CDirectorySearch aSearch(m_sp);
    aSearch.SetFilter(strFilter.c_str());
    aSearch.SetPreferences(bRecurse ? ADS_SCOPE_SUBTREE : ADS_SCOPE_ONELEVEL);
    aSearch.AddAttribute(ATTRIBUTE_OBJECT_SID);
    aSearch.AddAttribute(ATTRIBUTE_ADS_PATH);
    aSearch.AddAttribute(ATTRIBUTE_NAME);
    aSearch.AddAttribute(ATTRIBUTE_SAM_ACCOUNT_NAME);
    aSearch.AddAttribute(_T("dNSHostName"));
    aSearch.Search();

    for (bool bGet = aSearch.GetFirstRow(); bGet; bGet = aSearch.GetNextRow())
    {
        // if not a built-in or well known account

        if (IsUserRid(aSearch.GetAttributeValue(ATTRIBUTE_OBJECT_SID)))
        {
            // add computer

            CDomainAccount aComputer;

            aComputer.SetADsPath(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_ADS_PATH)));
            aComputer.SetName(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_NAME)));
            aComputer.SetSamAccountName(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_SAM_ACCOUNT_NAME)));

            _variant_t vntDnsHostName = aSearch.GetAttributeValue(_T("dNSHostName"));

            if (V_VT(&vntDnsHostName) != VT_EMPTY)
            {
                aComputer.SetDnsHostName(_bstr_t(vntDnsHostName));
            }

            rComputers.insert(aComputer);
        }
    }
}


//---------------------------------------------------------------------------


namespace _DomainContainer
{


//------------------------------------------------------------------------------
// GetNamingAttribute Function
//
// Synopsis
// Retrieves naming attributes for specified classes from specified domain.
//
// Arguments
// pszDomain     - specifies which domain's schema to retrieve the attributes
// pszClasses    - a comma separated list of classes
// setAttributes - the set of naming attributes which this function fills in
//
// Return
// None - an exception is thrown if any errors occur.
//------------------------------------------------------------------------------

void __stdcall GetNamingAttribute(PCTSTR pszDomain, PCTSTR pszClasses, StringSet& setAttributes)
{
    _ASSERT(pszDomain != NULL);
    _ASSERT(pszClasses != NULL);

    tstring strADsPath;

    //
    // Bind to rootDSE.
    //

    IADsPtr spRootDSE;
    strADsPath = _T("LDAP://");
    strADsPath += pszDomain;
    strADsPath += _T("/rootDSE");
    CheckError(ADsGetObject(strADsPath.c_str(), __uuidof(IADs), (VOID**)&spRootDSE));

    //
    // Retrieve schema naming context.
    //

    VARIANT var;
    VariantInit(&var);
    CheckError(spRootDSE->Get(_bstr_t(L"schemaNamingContext"), &var));
    _bstr_t strSchemaNamingContext = _variant_t(var, false);

    //
    // Bind to schema naming context.
    //

    IDispatchPtr spDispatch;
    strADsPath = _T("LDAP://");
    strADsPath += pszDomain;
    strADsPath += _T("/");
    strADsPath += strSchemaNamingContext;
    CheckError(ADsGetObject(strADsPath.c_str(), __uuidof(IDispatch), (VOID**)&spDispatch));

    //
    // Search for specified classes and retrieve rDNAttID attribute for each class.
    //

    // generate search filter string

    int nCount;
    tstring strClass;
    tstring strClassFilter;
    tstring strClasses = pszClasses;

    for (nCount = 0; strClasses.empty() == false; nCount++)
    {
        UINT uDelimiter = strClasses.find_first_of(_T(','));

        if  (uDelimiter != tstring::npos)
        {
            strClass = strClasses.substr(0, uDelimiter);
            strClasses = strClasses.substr(uDelimiter + 1);
        }
        else
        {
            strClass = strClasses;
            strClasses.erase();
        }

        strClassFilter += _T("(lDAPDisplayName=") + strClass + _T(")");
    }

    _ASSERT(nCount > 0);

    tstring strSearchFilter;

    if (nCount == 1)
    {
        strSearchFilter = _T("(&(objectClass=classSchema)") + strClassFilter + _T("(!isDefunct=TRUE))");
    }
    else
    {
        strSearchFilter = _T("(&(objectClass=classSchema)(|") + strClassFilter + _T(")(!isDefunct=TRUE))");
    }

    // search

    CDirectorySearch search(spDispatch);

    search.SetFilter(strSearchFilter.c_str());
    search.SetPreferences(ADS_SCOPE_SUBTREE);
    search.AddAttribute(_T("rDNAttID"));

    search.Search();

    // for each class add naming attribute to returned set

    if (search.GetFirstRow())
    {
        do
        {
            setAttributes.insert(_bstr_t(search.GetAttributeValue(_T("rDNAttID"))));
        }
        while (search.GetNextRow());
    }
}


// CreateFilter Method

tstring __stdcall CreateFilter(LPCTSTR pszFilter, const StringSet& setNamingAttributes, const StringSet& setExcludeNames)
{
    tstring strFilter;

    strFilter += _T("(&");

    strFilter += pszFilter;

    if (!setExcludeNames.empty())
    {
        strFilter += _T("(!(|");

        for (StringSet::const_iterator it = setExcludeNames.begin(); it != setExcludeNames.end(); it++)
        {
            const _bstr_t& strPattern = *it;
            PCTSTR pszPattern = strPattern;

            if (pszPattern)
            {
                //
                // If the exclude pattern contains an RDN delimiter character
                // then assume RDN exclude pattern otherwise assume sAMAccountName
                // exclude pattern.
                //

                tstring str = pszPattern;
                UINT uDelimiter = str.find_first_of(RDN_DELIMITER);

                if (uDelimiter == 0)
                {
                    //
                    // The RDN delimiter character must follow a valid naming attribute
                    // therefore if the delimiter occurs at the beginning of the pattern
                    // then an error must be generated.
                    //

                    AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, pszPattern);
                }
                else if (uDelimiter != tstring::npos)
                {
                    //
                    // Verify exclude pattern contains a valid naming attribute. The naming attribute
                    // must match the naming attribute(s) for the class(es) of objects being migrated.
                    //

                    tstring strNamingAttribute = str.substr(0, uDelimiter);

                    bool bValidNamingAttribute = false;
                    StringSet::const_iterator itNA;

                    for (itNA = setNamingAttributes.begin(); itNA != setNamingAttributes.end(); itNA++)
                    {
                        if (_tcsicmp(strNamingAttribute.c_str(), *itNA) == 0)
                        {
                            bValidNamingAttribute = true;
                            break;
                        }
                    }

                    if (bValidNamingAttribute == false)
                    {
                        AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, pszPattern);
                    }

                    strFilter += _T("(");
                    strFilter += str;
                    strFilter += _T(")");
                }
                else
                {
                    strFilter += _T("(sAMAccountName=");
                    strFilter += str;
                    strFilter += _T(")");
                }
            }
        }

        strFilter += _T("))");
    }

    strFilter += _T(")");

    return strFilter;
}


// IsClass

bool __stdcall IsClass(LPCTSTR pszClass, const _variant_t& vntClass)
{
	bool bIs = false;

	BSTR bstrObjectClass = NULL;

	if (V_VT(&vntClass) == VT_BSTR)
	{
		bstrObjectClass = V_BSTR(&vntClass);
	}
	else if (V_VT(&vntClass) == (VT_ARRAY|VT_BSTR))
	{
		SAFEARRAY* psa = V_ARRAY(&vntClass);

		if (psa->cDims == 1)
		{
			BSTR* pbstr = reinterpret_cast<BSTR*>(psa->pvData);
			DWORD cbstr = psa->rgsabound[0].cElements;

			if (pbstr)
			{
				bstrObjectClass = pbstr[cbstr - 1];
			}
		}
	}
	else
	{
		_ASSERT(FALSE);
	}

	if (bstrObjectClass)
	{
		LPCTSTR pszBeg = pszClass;

		while (pszBeg)
		{
			LPCTSTR pszEnd = _tcschr(pszBeg, _T(','));

			if (pszEnd)
			{
				if (_tcsnicmp(pszBeg, bstrObjectClass, pszEnd - pszBeg) == 0)
				{
					bIs = true;
					break;
				}

				pszBeg = pszEnd + 1;
			}
			else
			{
				if (_tcsicmp(pszBeg, bstrObjectClass) == 0)
				{
					bIs = true;
				}

				pszBeg = NULL;
			}
		}
	}

	return bIs;
}


// GetADsObject

IDispatchPtr GetADsObject(_bstr_t strPath)
{
	IDispatch* pdisp;

	HRESULT hr = ADsGetObject(strPath, __uuidof(IDispatch), (void**)&pdisp);

	if (FAILED(hr))
	{
		ReportADsError(hr);

		_com_issue_error(hr);
	}

	return IDispatchPtr(pdisp, false);
}


// ReportADsError

void ReportADsError(HRESULT hr, const IID& iid)
{
	DWORD dwError;
	WCHAR szName[256];
	WCHAR szError[256];

	ADsGetLastError(&dwError, szError, sizeof(szError) / sizeof(szError[0]), szName, sizeof(szName) / sizeof(szName[0]));

	AtlReportError(GUID_NULL, szError, iid, hr);
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\computermigration.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "ComputerMigration.h"

#include "Error.h"
#include "VarSetOptions.h"
#include "VarSetAccountOptions.h"
#include "VarSetSecurity.h"


//---------------------------------------------------------------------------
// Computer Migration Class
//---------------------------------------------------------------------------


CComputerMigration::CComputerMigration() :
    m_lTranslationOption(admtTranslateReplace),
    m_bTranslateFilesAndFolders(false),
    m_bTranslateLocalGroups(false),
    m_bTranslatePrinters(false),
    m_bTranslateRegistry(false),
    m_bTranslateShares(false),
    m_bTranslateUserProfiles(false),
    m_bTranslateUserRights(false),
    m_lRestartDelay(5)
{
}


CComputerMigration::~CComputerMigration()
{
}


// IComputerMigration Implementation ----------------------------------------


// TranslationOption Property

STDMETHODIMP CComputerMigration::put_TranslationOption(long lOption)
{
    HRESULT hr = S_OK;

    if (IsTranslationOptionValid(lOption))
    {
        m_lTranslationOption = lOption;
    }
    else
    {
        hr = AdmtSetError(CLSID_Migration, IID_IComputerMigration, E_INVALIDARG, IDS_E_TRANSLATION_OPTION_INVALID);
    }

    return hr;
}

STDMETHODIMP CComputerMigration::get_TranslationOption(long* plOption)
{
    *plOption = m_lTranslationOption;

    return S_OK;
}


// TranslateFilesAndFolders Property

STDMETHODIMP CComputerMigration::put_TranslateFilesAndFolders(VARIANT_BOOL bTranslate)
{
    m_bTranslateFilesAndFolders = bTranslate ? true : false;

    return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslateFilesAndFolders(VARIANT_BOOL* pbTranslate)
{
    *pbTranslate = m_bTranslateFilesAndFolders ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// TranslateLocalGroups Property

STDMETHODIMP CComputerMigration::put_TranslateLocalGroups(VARIANT_BOOL bTranslate)
{
    m_bTranslateLocalGroups = bTranslate ? true : false;

    return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslateLocalGroups(VARIANT_BOOL* pbTranslate)
{
    *pbTranslate = m_bTranslateLocalGroups ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// TranslatePrinters Property

STDMETHODIMP CComputerMigration::put_TranslatePrinters(VARIANT_BOOL bTranslate)
{
    m_bTranslatePrinters = bTranslate ? true : false;

    return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslatePrinters(VARIANT_BOOL* pbTranslate)
{
    *pbTranslate = m_bTranslatePrinters ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// TranslateRegistry Property

STDMETHODIMP CComputerMigration::put_TranslateRegistry(VARIANT_BOOL bTranslate)
{
    m_bTranslateRegistry = bTranslate ? true : false;

    return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslateRegistry(VARIANT_BOOL* pbTranslate)
{
    *pbTranslate = m_bTranslateRegistry ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// TranslateShares Property

STDMETHODIMP CComputerMigration::put_TranslateShares(VARIANT_BOOL bTranslate)
{
    m_bTranslateShares = bTranslate ? true : false;

    return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslateShares(VARIANT_BOOL* pbTranslate)
{
    *pbTranslate = m_bTranslateShares ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// TranslateUserProfiles Property

STDMETHODIMP CComputerMigration::put_TranslateUserProfiles(VARIANT_BOOL bTranslate)
{
    m_bTranslateUserProfiles = bTranslate ? true : false;

    return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslateUserProfiles(VARIANT_BOOL* pbTranslate)
{
    *pbTranslate = m_bTranslateUserProfiles ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// TranslateUserRights Property

STDMETHODIMP CComputerMigration::put_TranslateUserRights(VARIANT_BOOL bTranslate)
{
    m_bTranslateUserRights = bTranslate ? true : false;

    return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslateUserRights(VARIANT_BOOL* pbTranslate)
{
    *pbTranslate = m_bTranslateUserRights ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// RestartDelay Property

STDMETHODIMP CComputerMigration::put_RestartDelay(long lTime)
{
    HRESULT hr = S_OK;

    if ((lTime >= 1) && (lTime <= 10))
    {
        m_lRestartDelay = lTime;
    }
    else
    {
        hr = AdmtSetError(CLSID_Migration, IID_IComputerMigration, E_INVALIDARG, IDS_E_RESTART_DELAY_INVALID);
    }

    return hr;
}

STDMETHODIMP CComputerMigration::get_RestartDelay(long* plTime)
{
    *plTime = m_lRestartDelay;

    return S_OK;
}


// Migrate Method

STDMETHODIMP CComputerMigration::Migrate(long lOptions, VARIANT vntInclude, VARIANT vntExclude)
{
    HRESULT hr = S_OK;

    MutexWait();

    bool bLogOpen = _Module.OpenLog();

    try
    {
        _Module.Log(ErrI, IDS_STARTED_COMPUTER_MIGRATION);

        InitSourceDomainAndContainer();
        InitTargetDomainAndContainer();

        SetDefaultExcludedSystemProperties();

        VerifyInterIntraForest();
        VerifyCallerDelegated();
        ValidateMigrationParameters();

        DoOption(lOptions, vntInclude, vntExclude);
    }
    catch (_com_error& ce)
    {
        _Module.Log(ErrE, IDS_E_CANT_MIGRATE_COMPUTERS, ce);
        hr = AdmtSetError(CLSID_Migration, IID_IComputerMigration, ce, IDS_E_CANT_MIGRATE_COMPUTERS);
    }
    catch (...)
    {
        _Module.Log(ErrE, IDS_E_CANT_MIGRATE_COMPUTERS, _com_error(E_FAIL));
        hr = AdmtSetError(CLSID_Migration, IID_IComputerMigration, E_FAIL, IDS_E_CANT_MIGRATE_COMPUTERS);
    }

    if (bLogOpen)
    {
        _Module.CloseLog();
    }

    MutexRelease();

    return hr;
}


// Implementation -----------------------------------------------------------


// ValidateMigrationParameters Method

void CComputerMigration::ValidateMigrationParameters()
{
    bool bIntraForest = m_spInternal->IntraForest ? true : false;

    if (bIntraForest)
    {
        // validate conflict option

        long lConflictOptions = m_spInternal->ConflictOptions;
        long lConflictOption = lConflictOptions & 0x0F;

        if (lConflictOption == admtReplaceConflicting)
        {
            AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INTRA_FOREST_REPLACE);
        }
    }
}


// DoNames Method

void CComputerMigration::DoNames()
{
    CDomainAccounts aComputers;

    m_SourceDomain.QueryComputers(GetSourceContainer(), false, m_setIncludeNames, m_setExcludeNames, aComputers);

    DoComputers(aComputers, GetTargetContainer());
}


// DoDomain Method

void CComputerMigration::DoDomain()
{
    CContainer& rSource = GetSourceContainer();
    CContainer& rTarget = GetTargetContainer();

    if (m_nRecurseMaintain == 2)
    {
        rTarget.CreateContainerHierarchy(rSource);
    }

    DoContainers(rSource, rTarget);
}


// DoContainers Method

void CComputerMigration::DoContainers(CContainer& rSource, CContainer& rTarget)
{
    DoComputers(rSource, rTarget);

    if (m_nRecurseMaintain == 2)
    {
        ContainerVector aContainers;
        rSource.QueryContainers(aContainers);

        for (ContainerVector::iterator it = aContainers.begin(); it != aContainers.end(); it++)
        {
            DoContainers(*it, rTarget.GetContainer(it->GetName()));
        }
    }
}


// DoComputers Method

void CComputerMigration::DoComputers(CContainer& rSource, CContainer& rTarget)
{
    CDomainAccounts aComputers;
    rSource.QueryComputers(false, m_nRecurseMaintain == 1, m_setExcludeNames, aComputers);

    DoComputers(aComputers, rTarget);
}


// DoComputers Method

void CComputerMigration::DoComputers(CDomainAccounts& rComputers, CContainer& rTarget)
{
    if (rComputers.size() > 0)
    {
        CVarSet aVarSet;

        SetOptions(rTarget.GetPath(), aVarSet);
        SetAccountOptions(aVarSet);
        SetSecurity(aVarSet);

        VerifyRenameConflictPrefixSuffixValid();

        FillInVarSetForComputers(rComputers, false, true, true, m_lRestartDelay, aVarSet);

        rComputers.clear();

        aVarSet.Put(_T("PlugIn.%ld"), 0, _T("None"));

#ifdef _DEBUG
        aVarSet.Dump();
#endif

        PerformMigration(aVarSet);

        SaveSettings(aVarSet);
    }
}


// SetOptions Method

void CComputerMigration::SetOptions(_bstr_t strTargetOu, CVarSet& rVarSet)
{
    CVarSetOptions aOptions(rVarSet);

    aOptions.SetTest(m_spInternal->TestMigration ? true : false);

    aOptions.SetUndo(false);
    aOptions.SetWizard(_T("computer"));

    aOptions.SetIntraForest(m_spInternal->IntraForest ? true : false);
    aOptions.SetSourceDomain(m_SourceDomain.NameFlat(), m_SourceDomain.NameDns(), m_SourceDomain.Sid());
    aOptions.SetTargetDomain(m_TargetDomain.NameFlat(), m_TargetDomain.NameDns());
    aOptions.SetTargetOu(strTargetOu);

    aOptions.SetRenameOptions(m_spInternal->RenameOption, m_spInternal->RenamePrefixOrSuffix);
    aOptions.SetRestartDelay(m_lRestartDelay);
}


// SetAccountOptions Method

void CComputerMigration::SetAccountOptions(CVarSet& rVarSet)
{
    CVarSetAccountOptions aOptions(rVarSet);

    // naming conflict options
    // removing existing members of groups being replaced is not applicable

    aOptions.SetConflictOptions(
        m_spInternal->ConflictOptions & ~admtRemoveExistingMembers,
        m_spInternal->ConflictPrefixOrSuffix
    );

    aOptions.SetMigrateSids(false);
    aOptions.SetComputerMigrationOptions();

    aOptions.SetExcludedComputerProps(m_spInternal->ComputerPropertiesToExclude);
}


// SetSecurity Method

void CComputerMigration::SetSecurity(CVarSet& rVarSet)
{
    CVarSetSecurity aSecurity(rVarSet);

    aSecurity.SetTranslationOption(m_lTranslationOption);
    aSecurity.SetTranslateContainers(false);
    aSecurity.SetTranslateFiles(m_bTranslateFilesAndFolders);
    aSecurity.SetTranslateLocalGroups(m_bTranslateLocalGroups);
    aSecurity.SetTranslatePrinters(m_bTranslatePrinters);
    aSecurity.SetTranslateRegistry(m_bTranslateRegistry);
    aSecurity.SetTranslateShares(m_bTranslateShares);
    aSecurity.SetTranslateUserProfiles(m_bTranslateUserProfiles);
    aSecurity.SetTranslateUserRights(m_bTranslateUserRights);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\domainaccount.h ===
#pragma once

#include <set>


//---------------------------------------------------------------------------
// Domain Account Class
//---------------------------------------------------------------------------


class CDomainAccount
{
public:

	CDomainAccount() :
		m_lUserAccountControl(0)
	{
	}

	CDomainAccount(const CDomainAccount& r) :
		m_strADsPath(r.m_strADsPath),
		m_strName(r.m_strName),
		m_strUserPrincipalName(r.m_strUserPrincipalName),
		m_strSamAccountName(r.m_strSamAccountName),
	    m_strDnsHostName(r.m_strDnsHostName),
		m_lUserAccountControl(r.m_lUserAccountControl)
	{
	}

	~CDomainAccount()
	{
	}

	//

	_bstr_t GetADsPath() const
	{
		return m_strADsPath;
	}

	void SetADsPath(_bstr_t strPath)
	{
		m_strADsPath = strPath;
	}

	_bstr_t GetName() const
	{
		return m_strName;
	}

	void SetName(_bstr_t strName)
	{
		m_strName = strName;
	}

	_bstr_t GetUserPrincipalName() const
	{
		return m_strUserPrincipalName;
	}

	void SetUserPrincipalName(_bstr_t strName)
	{
		m_strUserPrincipalName = strName;
	}

	_bstr_t GetSamAccountName() const
	{
		return m_strSamAccountName;
	}

	void SetSamAccountName(_bstr_t strName)
	{
		m_strSamAccountName = strName;
	}

	_bstr_t GetDnsHostName() const
	{
		return m_strDnsHostName;
	}

	void SetDnsHostName(_bstr_t strName)
	{
		m_strDnsHostName = strName;
	}

	long GetUserAccountControl() const
	{
		return m_lUserAccountControl;
	}

	void SetUserAccountControl(long lUserAccountControl)
	{
		m_lUserAccountControl = lUserAccountControl;
	}

	//

	bool operator <(const CDomainAccount& r) const
	{
		return (m_strADsPath < r.m_strADsPath);
	}

protected:

	_bstr_t m_strADsPath;
	_bstr_t m_strName;
	_bstr_t m_strUserPrincipalName;
	_bstr_t m_strSamAccountName;
	_bstr_t m_strDnsHostName;
	long m_lUserAccountControl;
};


//---------------------------------------------------------------------------
// Domain Accounts Class
//---------------------------------------------------------------------------


class CDomainAccounts :
	public std::set<CDomainAccount>
{
public:

	CDomainAccounts() {}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\error.h ===
#pragma once

#include "Resource.h"


//---------------------------------------------------------------------------
// Error Methods
//---------------------------------------------------------------------------


HRESULT __cdecl AdmtSetError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...);
HRESULT __cdecl AdmtSetError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat = NULL, ...);

void __cdecl AdmtThrowError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...);
void __cdecl AdmtThrowError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat = NULL, ...);

//_bstr_t __cdecl FormatError(_com_error ce, UINT uId, ...);
//_bstr_t __cdecl FormatError(_com_error ce, LPCTSTR pszFormat = NULL, ...);

//_bstr_t __stdcall FormatResult(HRESULT hr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\domaincontainer.h ===
#pragma once

#include <set>
#include <vector>
#include "DomainAccount.h"
#include "VarSetBase.h"
#include <IsAdmin.hpp>

#ifndef StringSet
typedef std::set<_bstr_t> StringSet;
#endif


//---------------------------------------------------------------------------
// Container Class
//
// This class encapsulates the properties of a domain container and the
// operations that may be performed on a domain container.
//---------------------------------------------------------------------------


class CContainer
{
public:

	CContainer();
	CContainer(_bstr_t strPath);
	CContainer(IDispatchPtr sp);
	CContainer(const CContainer& r);
	virtual ~CContainer();

	// assignment operator

	CContainer& operator =(_bstr_t strPath);
	CContainer& operator =(const CContainer& r);

	// boolean operator
	// returns true if dispatch interface is not null

	operator bool()
	{
		return m_sp;
	}

	IDispatchPtr GetInterface() const
	{
		return m_sp;
	}

	_bstr_t GetPath();
	_bstr_t GetDomain();
	_bstr_t GetName();
	_bstr_t GetRDN();

	// duplicates container hierarchy given a source container
	void CreateContainerHierarchy(CContainer& rSource);

	// create a child container given a relative distinguished name
	virtual CContainer CreateContainer(_bstr_t strRDN);

	// retrieve a child container given a relative distinguished name
	virtual CContainer GetContainer(_bstr_t strRDN);

	virtual void QueryContainers(std::vector<CContainer>& rContainers);
	virtual void QueryUsers(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rUsers);
	virtual void QueryGroups(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rGroups);
	virtual void QueryComputers(bool bIncludeDCs, bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rComputers);

protected:

	// duplicates container hierarchy given a source container
	void CreateContainerHierarchy(CContainer& rSource, bool bParentCreated);

	// create a child container given a relative distinguished name
	virtual CContainer CreateContainer(_bstr_t strRDN, bool& bCreated);

	// recursively delete this container
	virtual void DeleteContainersRecursively();

protected:

	IDispatchPtr m_sp;
};


typedef std::vector<CContainer> ContainerVector;


//---------------------------------------------------------------------------
// Domain Class
//---------------------------------------------------------------------------


class CDomain : public CContainer
{
public:

	CDomain();
	~CDomain();

	bool Initialized() const
	{
		return m_bInitialized;
	}

	bool UpLevel() const
	{
		return m_bUpLevel;
	}

	bool NativeMode() const
	{
		return m_bNativeMode;
	}

	_bstr_t Name() const
	{
		_bstr_t strName = m_strDomainNameDns;

		if (!strName)
		{
			strName = m_strDomainNameFlat;
		}

		return strName;
	}

	_bstr_t NameDns() const
	{
		return m_strDomainNameDns;
	}

	_bstr_t NameFlat() const
	{
		return m_strDomainNameFlat;
	}

	_bstr_t ForestName() const
	{
		return m_strForestName;
	}

	_bstr_t Sid() const
	{
		return m_strDomainSid;
	}

	_bstr_t DomainControllerName() const
	{
		return m_strDcNameDns.length() ? (LPCTSTR)m_strDcNameDns : (LPCTSTR)m_strDcNameFlat;
	}

	_bstr_t DomainControllerNameDns() const
	{
		return m_strDcNameDns;
	}

	_bstr_t DomainControllerNameFlat() const
	{
		return m_strDcNameFlat;
	}

	void Initialize(_bstr_t strDomainName);

	DWORD IsAdministrator()
	{
		return IsAdminRemote(DomainControllerName());
	}

	virtual CContainer CreateContainer(_bstr_t strRDN);
	CContainer GetContainer(_bstr_t strRelativeCanonicalPath, bool bCreate = false);
	virtual void QueryContainers(ContainerVector& rContainers);

	void QueryUsers(CContainer& rContainer, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rUsers);
	void QueryGroups(CContainer& rContainer, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rGroups);
	void QueryComputers(CContainer& rContainer, bool bIncludeDCs, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rComputers);
	void QueryComputersAcrossDomains(CContainer& rContainer, bool bIncludeDCs, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rComputers);

	virtual void QueryUsers(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rUsers);
	virtual void QueryGroups(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rGroups);
	virtual void QueryComputers(bool bIncludeDCs, bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rComputers);

protected:

	CDomain(const CDomain& r) {}

	void GetDcName(_bstr_t strDomainName, _bstr_t& strDnsName, _bstr_t& strFlatName);
	_bstr_t GetGcName();
	_bstr_t GetSid();

	_bstr_t GetLDAPPath(_bstr_t strDN);
	_bstr_t GetWinNTPath(_bstr_t strName);
	_bstr_t GetDistinguishedName(_bstr_t strRelativeCanonicalPath);

	void QueryObjects(CContainer& rContainer, StringSet& setIncludeNames, StringSet& setExcludeNames, LPCTSTR pszClass, CDomainAccounts& rAccounts);

	void QueryUsers4(StringSet& setExcludeNames, CDomainAccounts& rUsers);
	void QueryUsers4(StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rUsers);
	void QueryGroups4(StringSet& setExcludeNames, CDomainAccounts& rGroups);
	void QueryGroups4(StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rGroups);
	void QueryComputers4(bool bIncludeDCs, StringSet& setExcludeNames, CDomainAccounts& rComputers);
	void QueryComputers4(bool bIncludeDCs, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rComputers);

protected:

    bool m_bInitialized;
	bool m_bUpLevel;
	bool m_bNativeMode;

	_bstr_t m_strADsPath;

	_bstr_t m_strDcNameDns;
	_bstr_t m_strDcNameFlat;
	_bstr_t m_strGcName;
	_bstr_t m_strForestName;
	_bstr_t m_strDomainNameDns;
	_bstr_t m_strDomainNameFlat;
	_bstr_t m_strDomainSid;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\error.cpp ===
#include "StdAfx.h"
#include "Error.h"
#include <ComDef.h>
using namespace _com_util;

#define COUNT_OF(a) (sizeof(a) / sizeof(a[0]))

namespace Error_cpp
{


IErrorInfoPtr __stdcall AdmtCreateErrorInfo(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription);


// AdmtSetErrorImpl Method

inline HRESULT __stdcall AdmtSetErrorImpl(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription)
{
	SetErrorInfo(0, AdmtCreateErrorInfo(clsid, iid, ce, pszDescription));

	return ce.Error();
}


// AdmtThrowErrorImpl Method

inline void __stdcall AdmtThrowErrorImpl(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription)
{
	IErrorInfoPtr spErrorInfo = AdmtCreateErrorInfo(clsid, iid, ce, pszDescription);

	if (spErrorInfo)
	{
		_com_raise_error(ce.Error(), spErrorInfo.Detach());
	}
	else
	{
		_com_raise_error(ce.Error());
	}
}


}

using namespace Error_cpp;


//---------------------------------------------------------------------------
// Error Methods
//---------------------------------------------------------------------------


// AdmtSetError Methods -------------------------------------------------


HRESULT __cdecl AdmtSetError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...)
{
	_TCHAR szFormat[512];
	_TCHAR szDescription[1024];

	if (LoadString(_Module.GetResourceInstance(), uId, szFormat, 512))
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szDescription, COUNT_OF(szDescription), szFormat, args);
		szDescription[COUNT_OF(szDescription) - 1] = _T('\0');
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	return AdmtSetErrorImpl(clsid, iid, ce, szDescription);
}


HRESULT __cdecl AdmtSetError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat, ...)
{
	_TCHAR szDescription[1024];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szDescription, COUNT_OF(szDescription), pszFormat, args);
		szDescription[COUNT_OF(szDescription) - 1] = _T('\0');
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	return AdmtSetErrorImpl(clsid, iid, ce, szDescription);
}


// AdmtThrowError Methods -----------------------------------------------


void __cdecl AdmtThrowError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...)
{
	_TCHAR szFormat[512];
	_TCHAR szDescription[1024];

	if (LoadString(_Module.GetResourceInstance(), uId, szFormat, 512))
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szDescription, COUNT_OF(szDescription), szFormat, args);
		szDescription[COUNT_OF(szDescription) - 1] = _T('\0');
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	AdmtThrowErrorImpl(clsid, iid, ce, szDescription);
}


void __cdecl AdmtThrowError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat, ...)
{
	_TCHAR szDescription[1024];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szDescription, COUNT_OF(szDescription), pszFormat, args);
		szDescription[COUNT_OF(szDescription) - 1] = _T('\0');
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	AdmtThrowErrorImpl(clsid, iid, ce, szDescription);
}


// Implementation -----------------------------------------------------------


namespace Error_cpp
{


// AdmtCreateErrorInfo Method

IErrorInfoPtr __stdcall AdmtCreateErrorInfo(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription)
{
	ICreateErrorInfoPtr spCreateErrorInfo;

	CreateErrorInfo(&spCreateErrorInfo);

	if (spCreateErrorInfo)
	{
		IErrorInfoPtr spErrorInfo = ce.ErrorInfo();

		if (spErrorInfo == NULL)
		{
			GetErrorInfo(0, &spErrorInfo);
		}

		// source

		if (IsEqualCLSID(clsid, GUID_NULL) == FALSE)
		{
			LPOLESTR pszProgId;

			if (ProgIDFromCLSID(clsid, &pszProgId) == S_OK)
			{
				spCreateErrorInfo->SetSource(pszProgId);
				CoTaskMemFree(pszProgId);
			}
			else
			{
				spCreateErrorInfo->SetSource(L"");
			}
		}
		else if (spErrorInfo)
		{
			BSTR bstrSource;
			spErrorInfo->GetSource(&bstrSource);
			spCreateErrorInfo->SetSource(bstrSource);
			SysFreeString(bstrSource);
		}
		else
		{
			spCreateErrorInfo->SetSource(L"");
		}

		// GUID

		if (IsEqualIID(iid, GUID_NULL) == FALSE)
		{
			spCreateErrorInfo->SetGUID(iid);
		}
		else if (spErrorInfo)
		{
			GUID guid;
			spErrorInfo->GetGUID(&guid);
			spCreateErrorInfo->SetGUID(guid);
		}
		else
		{
			spCreateErrorInfo->SetGUID(GUID_NULL);
		}

		// description

		_bstr_t strDescription = pszDescription;

		if (spErrorInfo)
		{
			BSTR bstrSource;
			spErrorInfo->GetSource(&bstrSource);

			if (SysStringLen(bstrSource) > 0)
			{
				if (strDescription.length() > 0)
				{
					strDescription += _T(" : ");
				}

				strDescription += bstrSource;
			}

			SysFreeString(bstrSource);

			BSTR bstrDescription;
			spErrorInfo->GetDescription(&bstrDescription);

			if (SysStringLen(bstrDescription) > 0)
			{
				if (strDescription.length() > 0)
				{
					strDescription += _T(" ");
				}

				strDescription += bstrDescription;
			}
			else
			{
				LPCTSTR pszErrorMessage = ce.ErrorMessage();

				if (pszErrorMessage)
				{
					if (strDescription.length() > 0)
					{
						strDescription += _T(" : ");
					}

					strDescription += pszErrorMessage;
				}
			}

			SysFreeString(bstrDescription);
		}
		else
		{
			LPCTSTR pszErrorMessage = ce.ErrorMessage();

			if (pszErrorMessage)
			{
				if (strDescription.length() > 0)
				{
					strDescription += _T(" ");
				}

				strDescription += pszErrorMessage;
			}
		}

		spCreateErrorInfo->SetDescription(strDescription);

		// help file

		if (spErrorInfo)
		{
			BSTR bstrHelpFile;
			spErrorInfo->GetHelpFile(&bstrHelpFile);
			spCreateErrorInfo->SetHelpFile(bstrHelpFile);
			SysFreeString(bstrHelpFile);
		}
		else
		{
			spCreateErrorInfo->SetHelpFile(L"");
		}

		// help context

		DWORD dwHelpContext = 0;

		if (spErrorInfo)
		{
			spErrorInfo->GetHelpContext(&dwHelpContext);
		}

		spCreateErrorInfo->SetHelpContext(dwHelpContext);
	}

	return IErrorInfoPtr(spCreateErrorInfo);
}


}	// namespace Error_cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\fixhierarchy.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "FixHierarchy.h"


//---------------------------------------------------------------------------
// Fix Objects in Hierarchy Class Implementation
//---------------------------------------------------------------------------


CFixObjectsInHierarchy::CFixObjectsInHierarchy() :
	m_bIntraForest(false),
	m_bFixReplaced(false)
{
}


CFixObjectsInHierarchy::~CFixObjectsInHierarchy()
{
}


void CFixObjectsInHierarchy::FixObjects()
{
	m_Migrated.RetrieveMigratedObjects();

	int nCount = m_Migrated.GetCount();

	if (nCount > 0)
	{
		m_TargetPath.SetContainerPaths(m_strSourceContainerPath, m_strTargetContainerPath);

		for (int nIndex = 0; nIndex < nCount; nIndex++)
		{
			int nStatus = m_Migrated.GetObjectStatus(nIndex);

			if (m_bIntraForest || ((nStatus & CMigrated::STATUS_CREATED) || (m_bFixReplaced && (nStatus & CMigrated::STATUS_REPLACED))))
			{
				_bstr_t strType = m_Migrated.GetObjectType(nIndex);

				if ((strType.length() > 0) && (_tcsicmp(strType, m_strObjectType) == 0))
				{
					if (m_TargetPath.NeedsToMove(m_Migrated.GetObjectSourcePath(nIndex), m_Migrated.GetObjectTargetPath(nIndex)))
					{
						m_Containers.InsertObject(m_TargetPath.GetTargetContainerPath(), nIndex, m_TargetPath.GetTargetObjectCurrentPath());
					}
				}
			}
		}

		for (CContainers::iterator itContainer = m_Containers.begin(); itContainer != m_Containers.end(); itContainer++)
		{
			try
			{
				CADsContainer cContainer((LPCTSTR)itContainer->first);

				CObjects& ovObjects = itContainer->second;

				for (CObjects::iterator itObject = ovObjects.begin(); itObject != ovObjects.end(); itObject++)
				{
					try
					{
						SObject& oObject = *itObject;

						CADs account(IADsPtr(cContainer.MoveHere(oObject.m_strPath, _bstr_t())));

						m_Migrated.UpdateObjectTargetPath(oObject.m_nIndex, account.GetADsPath());
					}
					catch (_com_error& ce)
					{
						_Module.Log(ErrW, IDS_E_FIX_HIERARCHY_MOVE_OBJECT, (LPCTSTR)itObject->m_strPath, (LPCTSTR)itContainer->first, ce.ErrorMessage());
					}
					catch (...)
					{
						_Module.Log(ErrW, IDS_E_FIX_HIERARCHY_MOVE_OBJECT, (LPCTSTR)itObject->m_strPath, (LPCTSTR)itContainer->first, _com_error(E_FAIL).ErrorMessage());
					}
				}
			}
			catch (_com_error& ce)
			{
				_Module.Log(ErrW, IDS_E_FIX_HIERARCHY_BIND_TO_CONTAINER, (LPCTSTR)itContainer->first, ce.ErrorMessage());
			}
			catch (...)
			{
				_Module.Log(ErrW, IDS_E_FIX_HIERARCHY_BIND_TO_CONTAINER, (LPCTSTR)itContainer->first, _com_error(E_FAIL).ErrorMessage());
			}
		}
	}
}


//---------------------------------------------------------------------------
// Migrated Objects Class Implementation
//---------------------------------------------------------------------------


CFixObjectsInHierarchy::CMigrated::CMigrated() :
	m_lActionId(-1),
	m_spDB(__uuidof(IManageDB))
{
}


CFixObjectsInHierarchy::CMigrated::~CMigrated()
{
}


int CFixObjectsInHierarchy::CMigrated::GetCount()
{
	return long(m_vsObjects.Get(_T("MigratedObjects")));
}


_bstr_t CFixObjectsInHierarchy::CMigrated::GetObjectKey(int nIndex)
{
	_TCHAR szKey[64];
	_stprintf(szKey, _T("MigratedObjects.%d"), nIndex);
	return szKey;
}


_bstr_t CFixObjectsInHierarchy::CMigrated::GetObjectType(int nIndex)
{
	return m_vsObjects.Get(_T("MigratedObjects.%d.Type"), nIndex);
}


int CFixObjectsInHierarchy::CMigrated::GetObjectStatus(int nIndex)
{
	return long(m_vsObjects.Get(_T("MigratedObjects.%d.status"), nIndex));
}


_bstr_t CFixObjectsInHierarchy::CMigrated::GetObjectSourcePath(int nIndex)
{
	return m_vsObjects.Get(_T("MigratedObjects.%d.SourceAdsPath"), nIndex);
}


_bstr_t CFixObjectsInHierarchy::CMigrated::GetObjectTargetPath(int nIndex)
{
	return m_vsObjects.Get(_T("MigratedObjects.%d.TargetAdsPath"), nIndex);
}


void CFixObjectsInHierarchy::CMigrated::RetrieveMigratedObjects(int nActionId)
{
	if (nActionId > 0)
	{
		m_lActionId = nActionId;
	}
	else
	{
		m_spDB->GetCurrentActionID(&m_lActionId);
	}

	IUnknownPtr spUnknown(m_vsObjects.GetInterface());
	IUnknown* punk = spUnknown;

	m_spDB->GetMigratedObjects(m_lActionId, &punk);
}


void CFixObjectsInHierarchy::CMigrated::UpdateObjectTargetPath(int nIndex, _bstr_t strPath)
{
	IVarSetPtr spVarSet(__uuidof(VarSet));

	spVarSet->ImportSubTree(_bstr_t(), IVarSetPtr(m_vsObjects.GetInterface()->getReference(GetObjectKey(nIndex))));
	spVarSet->put(_T("TargetAdsPath"), strPath);

	m_spDB->SaveMigratedObject(m_lActionId, IUnknownPtr(spVarSet));
}


//---------------------------------------------------------------------------
// Target Path Class Implementation
//---------------------------------------------------------------------------


CFixObjectsInHierarchy::CTargetPath::CTargetPath()
{
}


CFixObjectsInHierarchy::CTargetPath::~CTargetPath()
{
}


void CFixObjectsInHierarchy::CTargetPath::SetContainerPaths(_bstr_t strSourceContainerPath, _bstr_t strTargetContainerPath)
{
	m_pnSourceContainerPath.Set(strSourceContainerPath, ADS_SETTYPE_FULL);
	m_pnTargetContainerPath.Set(strTargetContainerPath, ADS_SETTYPE_FULL);
}


bool CFixObjectsInHierarchy::CTargetPath::NeedsToMove(_bstr_t strSourceObjectPath, _bstr_t strTargetObjectPath)
{
	bool bNeedsToMove = false;

	// if the source object exists within the source root container hierarchy...

	CADsPathName pn(strSourceObjectPath);

	long lCount = pn.GetNumElements() - m_pnSourceContainerPath.GetNumElements();

	while (lCount-- > 0)
	{
		pn.RemoveLeafElement();
	}

	if (IsMatch(pn.Retrieve(ADS_FORMAT_X500_DN), m_pnSourceContainerPath.Retrieve(ADS_FORMAT_X500_DN)))
	{
		m_pnTargetObjectOldPath.Set(strTargetObjectPath, ADS_SETTYPE_FULL);

		// construct expected target object path

		m_pnTargetObjectNewPath.Set(m_pnTargetContainerPath.Retrieve(ADS_FORMAT_X500), ADS_SETTYPE_FULL);

		pn.Set(strSourceObjectPath, ADS_SETTYPE_FULL);

		long lIndex = pn.GetNumElements() - m_pnSourceContainerPath.GetNumElements();

		while (--lIndex >= 0)
		{
			m_pnTargetObjectNewPath.AddLeafElement(pn.GetElement(lIndex));
		}

		// compare expected target path with current target path

		if (!IsMatch(m_pnTargetObjectNewPath.Retrieve(ADS_FORMAT_X500_DN), m_pnTargetObjectOldPath.Retrieve(ADS_FORMAT_X500_DN)))
		{
			m_pnTargetObjectNewPath.Set(m_pnTargetObjectOldPath.Retrieve(ADS_FORMAT_SERVER), ADS_SETTYPE_SERVER);

			bNeedsToMove = true;
		}
	}

	return bNeedsToMove;
}


_bstr_t CFixObjectsInHierarchy::CTargetPath::GetTargetContainerPath()
{
	CADsPathName pn(m_pnTargetObjectNewPath.Retrieve(ADS_FORMAT_X500));

	pn.RemoveLeafElement();

	return pn.Retrieve(ADS_FORMAT_X500);
}


_bstr_t CFixObjectsInHierarchy::CTargetPath::GetTargetObjectCurrentPath()
{
	return m_pnTargetObjectOldPath.Retrieve(ADS_FORMAT_X500_NO_SERVER);
}


bool CFixObjectsInHierarchy::CTargetPath::IsMatch(LPCTSTR pszA, LPCTSTR pszB)
{
	bool bMatch = false;

	if (pszA && pszB)
	{
		bMatch = (_tcsicmp(pszA, pszB) == 0) ? true : false;
	}

	return bMatch;
}


//---------------------------------------------------------------------------
// Containers Class Implementation
//---------------------------------------------------------------------------


void CFixObjectsInHierarchy::CContainers::InsertObject(_bstr_t strContainerPath, int nObjectIndex, _bstr_t strObjectPathOld)
{
	iterator it = find(strContainerPath);

	if (it == end())
	{
		_Pairib pair = insert(value_type(strContainerPath, CObjects()));

		it = pair.first;
	}

	CObjects& ov = it->second;

	ov.push_back(SObject(nObjectIndex, strObjectPathOld));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\fixhierarchy.h ===
#pragma once

#include <map>
#include <vector>
#include <AdsiHelpers.h>
#include "VarSetBase.h"


class CFixObjectsInHierarchy
{
public:

	CFixObjectsInHierarchy();
	~CFixObjectsInHierarchy();

	_bstr_t GetObjectType() const
	{
		return m_strObjectType;
	}

	void SetObjectType(LPCTSTR pszType)
	{
		m_strObjectType = pszType;
	}

	bool GetIntraForest() const
	{
		return m_bIntraForest;
	}

	void SetIntraForest(bool bIntraForest)
	{
		m_bIntraForest = bIntraForest;
	}

	bool GetFixReplaced() const
	{
		return m_bFixReplaced;
	}

	void SetFixReplaced(bool bFix)
	{
		m_bFixReplaced = bFix;
	}

	_bstr_t GetSourceContainerPath() const
	{
		return m_strSourceContainerPath;
	}

	void SetSourceContainerPath(_bstr_t strPath)
	{
		m_strSourceContainerPath = strPath;
	}

	_bstr_t GetTargetContainerPath() const
	{
		return m_strTargetContainerPath;
	}

	void SetTargetContainerPath(_bstr_t strPath)
	{
		m_strTargetContainerPath = strPath;
	}

	void FixObjects();

private:

	class CMigrated
	{
	public:

		CMigrated();
		~CMigrated();

		void RetrieveMigratedObjects(int nActionId = -1);

		int GetCount();
		_bstr_t GetObjectType(int nIndex);
		int GetObjectStatus(int nIndex);
		_bstr_t GetObjectSourcePath(int nIndex);
		_bstr_t GetObjectTargetPath(int nIndex);

		void UpdateObjectTargetPath(int nIndex, _bstr_t strPath);

	public:

		enum EStatus
		{
			STATUS_CREATED  = 0x00000001,
			STATUS_REPLACED = 0x00000002,
			STATUS_EXISTED  = 0x00000004,
		};

	private:

		_bstr_t GetObjectKey(int nIndex);

	private:

		long m_lActionId;
		IIManageDBPtr m_spDB;
		CVarSet m_vsObjects;
	};

	class CTargetPath
	{
	public:

		CTargetPath();
		~CTargetPath();

		void SetContainerPaths(_bstr_t strSourceContainerPath, _bstr_t strTargetContainerPath);

		bool NeedsToMove(_bstr_t strSourceObjectPath, _bstr_t strTargetObjectPath);

		_bstr_t GetTargetContainerPath();
		_bstr_t GetTargetObjectCurrentPath();

	private:

		bool IsMatch(LPCTSTR pszA, LPCTSTR pszB);

	private:

		CADsPathName m_pnSourceContainerPath;
		CADsPathName m_pnTargetContainerPath;
		CADsPathName m_pnTargetObjectOldPath;
		CADsPathName m_pnTargetObjectNewPath;
	};

	class CContainers;

	struct SObject
	{
		SObject(int nIndex, _bstr_t strPath) :
			m_nIndex(nIndex),
			m_strPath(strPath)
		{
		}

		SObject(const SObject& r) :
			m_nIndex(r.m_nIndex),
			m_strPath(r.m_strPath)
		{
		}

		SObject& operator =(const SObject& r)
		{
			m_nIndex = r.m_nIndex;
			m_strPath = r.m_strPath;
			return *this;
		}

		int m_nIndex;
		_bstr_t m_strPath;

		friend CContainers;
	};

	typedef std::vector<SObject> CObjects;

	class CContainers : public std::map<_bstr_t, CObjects>
	{
	public:

		CContainers() {}

		void InsertObject(_bstr_t strContainerPath, int nObjectIndex, _bstr_t strObjectPathOld);
	};

private:

	_bstr_t m_strObjectType;
	bool m_bIntraForest;
	bool m_bFixReplaced;
	_bstr_t m_strSourceContainerPath;
	_bstr_t m_strTargetContainerPath;

	CMigrated m_Migrated;
	CTargetPath m_TargetPath;
	CContainers m_Containers;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\groupmigration.h ===
#pragma once

#include "MigrationBase.h"


//---------------------------------------------------------------------------
// GroupMigration Class
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CGroupMigration :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IGroupMigration, &IID_IGroupMigration, &LIBID_ADMT>,
	public CMigrationBase
{
public:

	CGroupMigration();
	~CGroupMigration();

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CGroupMigration)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IGroupMigration)
	END_COM_MAP()

public:

	// IGroupMigration

	STDMETHOD(put_MigrateSIDs)(VARIANT_BOOL bMigrate);
	STDMETHOD(get_MigrateSIDs)(VARIANT_BOOL* pbMigrate);
	STDMETHOD(put_UpdateGroupRights)(VARIANT_BOOL bUpdate);
	STDMETHOD(get_UpdateGroupRights)(VARIANT_BOOL* pbUpdate);
	STDMETHOD(put_UpdatePreviouslyMigratedObjects)(VARIANT_BOOL bUpdate);
	STDMETHOD(get_UpdatePreviouslyMigratedObjects)(VARIANT_BOOL* pbUpdate);
	STDMETHOD(put_FixGroupMembership)(VARIANT_BOOL bFix);
	STDMETHOD(get_FixGroupMembership)(VARIANT_BOOL* pbFix);
	STDMETHOD(put_MigrateMembers)(VARIANT_BOOL bMigrate);
	STDMETHOD(get_MigrateMembers)(VARIANT_BOOL* pbMigrate);
	STDMETHOD(put_DisableOption)(long lOption);
	STDMETHOD(get_DisableOption)(long* plOption);
	STDMETHOD(put_SourceExpiration)(long lExpiration);
	STDMETHOD(get_SourceExpiration)(long* plExpiration);
	STDMETHOD(put_TranslateRoamingProfile)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateRoamingProfile)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(Migrate)(long lOptions, VARIANT vntInclude, VARIANT vntExclude);

protected:

	void ValidateMigrationParameters();

	virtual void DoNames();
	virtual void DoDomain();

	void DoContainers(CContainer& rSource, CContainer& rTarget);
	void DoGroups(CContainer& rSource, CContainer& rTarget);
	void DoGroups(CDomainAccounts& rGroups, CContainer& rTarget);

	void SetOptions(_bstr_t strTargetOu, CVarSet& rVarSet);
	void SetAccountOptions(CVarSet& rVarSet);

protected:

	bool m_bMigrateSids;
	bool m_bUpdateGroupRights;
	bool m_bUpdateMigrated;
	bool m_bFixGroupMembership;
	bool m_bMigrateMembers;
	long m_lDisableOption;
	long m_lSourceExpiration;
	bool m_bTranslateRoamingProfile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\groupmigration.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "GroupMigration.h"

#include "Error.h"
#include "VarSetOptions.h"
#include "VarSetAccountOptions.h"
#include "VarSetSecurity.h"


//---------------------------------------------------------------------------
// Group Migration Class
//---------------------------------------------------------------------------


CGroupMigration::CGroupMigration() :
    m_bMigrateSids(false),
    m_bUpdateGroupRights(false),
    m_bUpdateMigrated(false),
    m_bFixGroupMembership(true),
    m_bMigrateMembers(false),
    m_lDisableOption(admtEnableTarget),
    m_lSourceExpiration(admtNoExpiration),
    m_bTranslateRoamingProfile(false)
{
}


CGroupMigration::~CGroupMigration()
{
}


// IGroupMigration Implementation -------------------------------------------


// MigrateSIDs Property

STDMETHODIMP CGroupMigration::put_MigrateSIDs(VARIANT_BOOL bMigrate)
{
    m_bMigrateSids = bMigrate ? true : false;

    return S_OK;
}

STDMETHODIMP CGroupMigration::get_MigrateSIDs(VARIANT_BOOL* pbMigrate)
{
    *pbMigrate = m_bMigrateSids ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// UpdateGroupRights Property

STDMETHODIMP CGroupMigration::put_UpdateGroupRights(VARIANT_BOOL bUpdate)
{
    m_bUpdateGroupRights = bUpdate ? true : false;

    return S_OK;
}

STDMETHODIMP CGroupMigration::get_UpdateGroupRights(VARIANT_BOOL* pbUpdate)
{
    *pbUpdate = m_bUpdateGroupRights ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// UpdatePreviouslyMigratedObjects Property

STDMETHODIMP CGroupMigration::put_UpdatePreviouslyMigratedObjects(VARIANT_BOOL bUpdate)
{
    m_bUpdateMigrated = bUpdate ? true : false;

    return S_OK;
}

STDMETHODIMP CGroupMigration::get_UpdatePreviouslyMigratedObjects(VARIANT_BOOL* pbUpdate)
{
    *pbUpdate = m_bUpdateMigrated ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// FixGroupMembership Property

STDMETHODIMP CGroupMigration::put_FixGroupMembership(VARIANT_BOOL bFix)
{
    m_bFixGroupMembership = bFix ? true : false;

    return S_OK;
}

STDMETHODIMP CGroupMigration::get_FixGroupMembership(VARIANT_BOOL* pbFix)
{
    *pbFix = m_bFixGroupMembership ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// MigrateMembers Property

STDMETHODIMP CGroupMigration::put_MigrateMembers(VARIANT_BOOL bMigrate)
{
    m_bMigrateMembers = bMigrate ? true : false;

    return S_OK;
}

STDMETHODIMP CGroupMigration::get_MigrateMembers(VARIANT_BOOL* pbMigrate)
{
    *pbMigrate = m_bMigrateMembers ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// DisableOption Property

STDMETHODIMP CGroupMigration::put_DisableOption(long lOption)
{
    HRESULT hr = S_OK;

    if (IsDisableOptionValid(lOption))
    {
        m_lDisableOption = lOption;
    }
    else
    {
        hr = AdmtSetError(CLSID_Migration, IID_IGroupMigration, E_INVALIDARG, IDS_E_DISABLE_OPTION_INVALID);
    }

    return hr;
}

STDMETHODIMP CGroupMigration::get_DisableOption(long* plOption)
{
    *plOption = m_lDisableOption;

    return S_OK;
}


// SourceExpiration Property

STDMETHODIMP CGroupMigration::put_SourceExpiration(long lExpiration)
{
    HRESULT hr = S_OK;

    if (IsSourceExpirationValid(lExpiration))
    {
        m_lSourceExpiration = lExpiration;
    }
    else
    {
        hr = AdmtSetError(CLSID_Migration, IID_IGroupMigration, E_INVALIDARG, IDS_E_SOURCE_EXPIRATION_INVALID);
    }

    return hr;
}

STDMETHODIMP CGroupMigration::get_SourceExpiration(long* plExpiration)
{
    *plExpiration = m_lSourceExpiration;

    return S_OK;
}


// TranslateRoamingProfile Property

STDMETHODIMP CGroupMigration::put_TranslateRoamingProfile(VARIANT_BOOL bTranslate)
{
    m_bTranslateRoamingProfile = bTranslate ? true : false;

    return S_OK;
}

STDMETHODIMP CGroupMigration::get_TranslateRoamingProfile(VARIANT_BOOL* pbTranslate)
{
    *pbTranslate = m_bTranslateRoamingProfile ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// Migrate Method

STDMETHODIMP CGroupMigration::Migrate(long lOptions, VARIANT vntInclude, VARIANT vntExclude)
{
    HRESULT hr = S_OK;

    MutexWait();

    bool bLogOpen = _Module.OpenLog();

    try
    {
        _Module.Log(ErrI, IDS_STARTED_GROUP_MIGRATION);

        InitSourceDomainAndContainer();
        InitTargetDomainAndContainer();

        SetDefaultExcludedSystemProperties();

        VerifyInterIntraForest();
        VerifyCallerDelegated();
        ValidateMigrationParameters();

        if (m_bMigrateSids)
        {
            VerifyCanAddSidHistory();
        }

        VerifyPasswordOption();

        DoOption(lOptions, vntInclude, vntExclude);
    }
    catch (_com_error& ce)
    {
        _Module.Log(ErrE, IDS_E_CANT_MIGRATE_GROUPS, ce);
        hr = AdmtSetError(CLSID_Migration, IID_IGroupMigration, ce, IDS_E_CANT_MIGRATE_GROUPS);
    }
    catch (...)
    {
        _Module.Log(ErrE, IDS_E_CANT_MIGRATE_GROUPS, _com_error(E_FAIL));
        hr = AdmtSetError(CLSID_Migration, IID_IGroupMigration, E_FAIL, IDS_E_CANT_MIGRATE_GROUPS);
    }

    if (bLogOpen)
    {
        _Module.CloseLog();
    }

    MutexRelease();

    return hr;
}


// Implementation -----------------------------------------------------------


// ValidateMigrationParameters Method

void CGroupMigration::ValidateMigrationParameters()
{
    bool bIntraForest = m_spInternal->IntraForest ? true : false;

    if (bIntraForest)
    {
        // validate conflict option

        long lConflictOptions = m_spInternal->ConflictOptions;
        long lConflictOption = lConflictOptions & 0x0F;

        if (lConflictOption == admtReplaceConflicting)
        {
            AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INTRA_FOREST_REPLACE);
        }
    }
}


// DoNames Method

void CGroupMigration::DoNames()
{
    CDomainAccounts aGroups;

    m_SourceDomain.QueryGroups(GetSourceContainer(), m_setIncludeNames, m_setExcludeNames, aGroups);

    DoGroups(aGroups, GetTargetContainer());
}


// DoDomain Method

void CGroupMigration::DoDomain()
{
    CContainer& rSource = GetSourceContainer();
    CContainer& rTarget = GetTargetContainer();

    if (m_nRecurseMaintain == 2)
    {
        rTarget.CreateContainerHierarchy(rSource);
    }

    DoContainers(rSource, rTarget);
}


// DoContainers Method

void CGroupMigration::DoContainers(CContainer& rSource, CContainer& rTarget)
{
    DoGroups(rSource, rTarget);

    if (m_nRecurseMaintain == 2)
    {
        ContainerVector aContainers;
        rSource.QueryContainers(aContainers);

        for (ContainerVector::iterator it = aContainers.begin(); it != aContainers.end(); it++)
        {
            DoContainers(*it, rTarget.GetContainer(it->GetName()));
        }
    }
}


// DoGroups Method

void CGroupMigration::DoGroups(CContainer& rSource, CContainer& rTarget)
{
    CDomainAccounts aGroups;
    rSource.QueryGroups(m_nRecurseMaintain == 1, m_setExcludeNames, aGroups);

    DoGroups(aGroups, rTarget);
}


// DoGroups Method

void CGroupMigration::DoGroups(CDomainAccounts& rGroups, CContainer& rTarget)
{
    if (rGroups.size() > 0)
    {
        CVarSet aVarSet;

        SetOptions(rTarget.GetPath(), aVarSet);
        SetAccountOptions(aVarSet);

        VerifyRenameConflictPrefixSuffixValid();

        FillInVarSetForGroups(rGroups, aVarSet);

        rGroups.clear();

#ifdef _DEBUG
        aVarSet.Dump();
#endif

        PerformMigration(aVarSet);

        SaveSettings(aVarSet);

        if ((m_nRecurseMaintain == 2) && m_bMigrateMembers)
        {
            FixObjectsInHierarchy(_T("user"));
        }
    }
}


// SetOptions Method

void CGroupMigration::SetOptions(_bstr_t strTargetOu, CVarSet& rVarSet)
{
    CVarSetOptions aOptions(rVarSet);

    aOptions.SetTest(m_spInternal->TestMigration ? true : false);

    aOptions.SetUndo(false);
    aOptions.SetWizard(_T("group"));

    aOptions.SetIntraForest(m_spInternal->IntraForest ? true : false);
    aOptions.SetSourceDomain(m_SourceDomain.NameFlat(), m_SourceDomain.NameDns(), m_SourceDomain.Sid());
    aOptions.SetTargetDomain(m_TargetDomain.NameFlat(), m_TargetDomain.NameDns());
    aOptions.SetTargetOu(strTargetOu);

    if (m_bMigrateSids || (m_spInternal->PasswordOption == admtCopyPassword))
    {
        aOptions.SetTargetServer(
            m_TargetDomain.DomainControllerNameFlat(),
            m_TargetDomain.DomainControllerNameDns()
        );
    }

    aOptions.SetRenameOptions(m_spInternal->RenameOption, m_spInternal->RenamePrefixOrSuffix);
}


// SetAccountOptions Method

void CGroupMigration::SetAccountOptions(CVarSet& rVarSet)
{
    CVarSetAccountOptions aOptions(rVarSet);

    aOptions.SetPasswordOption(m_spInternal->PasswordOption, m_spInternal->PasswordServer);
    aOptions.SetPasswordFile(m_spInternal->PasswordFile);
    aOptions.SetConflictOptions(m_spInternal->ConflictOptions, m_spInternal->ConflictPrefixOrSuffix);

    aOptions.SetDisableOption(m_lDisableOption);
    aOptions.SetSourceExpiration(m_lSourceExpiration);
    aOptions.SetMigrateSids(m_bMigrateSids);
    aOptions.SetGroupMigrationOptions(m_bMigrateMembers, m_bUpdateMigrated);
    aOptions.SetFixGroupMembership(m_bFixGroupMembership);
    aOptions.SetUpdateUserRights(m_bUpdateGroupRights);
    aOptions.SetTranslateRoamingProfile(m_bTranslateRoamingProfile);

    if (m_bMigrateMembers)
    {
        aOptions.SetExcludedUserProps(m_spInternal->UserPropertiesToExclude);
        aOptions.SetExcludedInetOrgPersonProps(m_spInternal->InetOrgPersonPropertiesToExclude);
    }

    aOptions.SetExcludedGroupProps(m_spInternal->GroupPropertiesToExclude);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\migration.h ===
#pragma once

#include "Resource.h"


//---------------------------------------------------------------------------
// CMigration
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CMigration : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMigration, &CLSID_Migration>,
	public ISupportErrorInfoImpl<&IID_IMigration>,
	public IDispatchImpl<IMigration, &IID_IMigration, &LIBID_ADMT>,
	public IMigrationInternal
{
public:

	CMigration();
	~CMigration();

	HRESULT FinalConstruct();
	void FinalRelease();
	
	DECLARE_REGISTRY_RESOURCEID(IDR_MIGRATION)
	DECLARE_NOT_AGGREGATABLE(CMigration)

	BEGIN_COM_MAP(CMigration)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IMigration)
		COM_INTERFACE_ENTRY(IMigrationInternal)
		COM_INTERFACE_ENTRY(ISupportErrorInfo)
	END_COM_MAP()

public:

	// IMigration

	STDMETHOD(put_TestMigration)(VARIANT_BOOL bTest);
	STDMETHOD(get_TestMigration)(VARIANT_BOOL* pbTest);
	STDMETHOD(put_IntraForest)(VARIANT_BOOL bIntraForest);
	STDMETHOD(get_IntraForest)(VARIANT_BOOL* pbIntraForest);
	STDMETHOD(put_SourceDomain)(BSTR bstrDomain);
	STDMETHOD(get_SourceDomain)(BSTR* pbstrDomain);
	STDMETHOD(put_SourceOu)(BSTR bstrOu);
	STDMETHOD(get_SourceOu)(BSTR* pbstrOu);
	STDMETHOD(put_TargetDomain)(BSTR bstrDomain);
	STDMETHOD(get_TargetDomain)(BSTR* pbstrDomain);
	STDMETHOD(put_TargetOu)(BSTR bstrOu);
	STDMETHOD(get_TargetOu)(BSTR* pbstrOu);
	STDMETHOD(put_RenameOption)(long lOption);
	STDMETHOD(get_RenameOption)(long* plOption);
	STDMETHOD(put_RenamePrefixOrSuffix)(BSTR bstrPrefixOrSuffix);
	STDMETHOD(get_RenamePrefixOrSuffix)(BSTR* pbstrPrefixOrSuffix);
	STDMETHOD(put_PasswordOption)(long lOption);
	STDMETHOD(get_PasswordOption)(long* plOption);
	STDMETHOD(put_PasswordServer)(BSTR bstrServer);
	STDMETHOD(get_PasswordServer)(BSTR* pbstrServer);
	STDMETHOD(put_PasswordFile)(BSTR bstrPath);
	STDMETHOD(get_PasswordFile)(BSTR* pbstrPath);
	STDMETHOD(put_ConflictOptions)(long lOptions);
	STDMETHOD(get_ConflictOptions)(long* plOptions);
	STDMETHOD(put_ConflictPrefixOrSuffix)(BSTR bstrPrefixOrSuffix);
	STDMETHOD(get_ConflictPrefixOrSuffix)(BSTR* pbstrPrefixOrSuffix);
	STDMETHOD(put_UserPropertiesToExclude)(BSTR bstrProperties);
	STDMETHOD(get_UserPropertiesToExclude)(BSTR* pbstrProperties);
	STDMETHOD(put_InetOrgPersonPropertiesToExclude)(BSTR bstrProperties);
	STDMETHOD(get_InetOrgPersonPropertiesToExclude)(BSTR* pbstrProperties);
	STDMETHOD(put_GroupPropertiesToExclude)(BSTR bstrProperties);
	STDMETHOD(get_GroupPropertiesToExclude)(BSTR* pbstrProperties);
	STDMETHOD(put_ComputerPropertiesToExclude)(BSTR bstrProperties);
	STDMETHOD(get_ComputerPropertiesToExclude)(BSTR* pbstrProperties);
	STDMETHOD(put_SystemPropertiesToExclude)(BSTR bstrProperties);
	STDMETHOD(get_SystemPropertiesToExclude)(BSTR* pbstrProperties);
	STDMETHOD(CreateUserMigration)(IUserMigration** pitfUserMigration);
	STDMETHOD(CreateGroupMigration)(IGroupMigration** pitfGroupMigration);
	STDMETHOD(CreateComputerMigration)(IComputerMigration** pitfComputerMigration);
	STDMETHOD(CreateSecurityTranslation)(ISecurityTranslation** pitfSecurityTranslation);
	STDMETHOD(CreateServiceAccountEnumeration)(IServiceAccountEnumeration** pitfServiceAccountEnumeration);
	STDMETHOD(CreateReportGeneration)(IReportGeneration** pitfReportGeneration);

	// IMigrationInternal
	// Note: properties implemented by IMigration interface implementation

//	STDMETHOD(get_TestMigration)(VARIANT_BOOL* pbTest);
//	STDMETHOD(get_IntraForest)(VARIANT_BOOL* pbIntraForest);
//	STDMETHOD(get_SourceOu)(BSTR* pbstrOu);
//	STDMETHOD(get_TargetOu)(BSTR* pbstrOu);
//	STDMETHOD(get_RenameOption)(long* plOption);
//	STDMETHOD(get_RenamePrefixOrSuffix)(BSTR* pbstrPrefixOrSuffix);
//	STDMETHOD(get_PasswordOption)(long* plOption);
//	STDMETHOD(get_PasswordFile)(BSTR* pbstrPath);
//	STDMETHOD(get_ConflictOptions)(long* plOptions);
//	STDMETHOD(get_ConflictPrefixOrSuffix)(BSTR* pbstrPrefixOrSuffix);
//	STDMETHOD(get_UserPropertiesToExclude)(BSTR* pbstrProperties);
//	STDMETHOD(get_InetOrgPersonPropertiesToExclude)(BSTR* pbstrProperties);
//	STDMETHOD(get_GroupPropertiesToExclude)(BSTR* pbstrProperties);
//	STDMETHOD(get_ComputerPropertiesToExclude)(BSTR* pbstrProperties);

protected:

	static _bstr_t GetValidDcName(_bstr_t strDcName);

	static void UpdateDatabase();
	static _bstr_t GetParsedExcludeProperties(LPCTSTR pszOld);

protected:

	bool m_bTestMigration;
	bool m_bIntraForest;
	_bstr_t m_bstrSourceDomain;
	_bstr_t m_bstrSourceOu;
	_bstr_t m_bstrTargetDomain;
	_bstr_t m_bstrTargetOu;
	long m_lRenameOption;
	_bstr_t m_bstrRenamePrefixOrSuffix;
	long m_lPasswordOption;
	_bstr_t m_bstrPasswordServer;
	_bstr_t m_bstrPasswordFile;
	long m_lConflictOptions;
	_bstr_t m_bstrConflictPrefixOrSuffix;
	_bstr_t m_bstrUserPropertiesToExclude;
	_bstr_t m_bstrInetOrgPersonPropertiesToExclude;
	_bstr_t m_bstrGroupPropertiesToExclude;
	_bstr_t m_bstrComputerPropertiesToExclude;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\migrationbase.h ===
#pragma once

#include <set>
#include "DomainAccount.h"
#include "DomainContainer.h"
#include "VarSetBase.h"
#include <MigrationMutex.h>

#ifndef StringSet
typedef std::set<_bstr_t> StringSet;
#endif

#define MAXIMUM_PREFIX_SUFFIX_LENGTH 8


//---------------------------------------------------------------------------
// MigrationBase Class
//---------------------------------------------------------------------------


class CMigrationBase
{
public:

    void SetInternalInterface(IMigrationInternal* pInternal)
    {
        m_spInternal = pInternal;
    }

protected:

    CMigrationBase();
    ~CMigrationBase();

    void InitSourceDomainAndContainer(bool bMustExist = true);
    void InitTargetDomainAndContainer();

    void VerifyInterIntraForest();
    void VerifyCallerDelegated();

    CContainer& GetSourceContainer()
    {
        if (m_SourceContainer)
        {
            return m_SourceContainer;
        }
        else
        {
            return m_SourceDomain;
        }
    }

    CContainer& GetTargetContainer()
    {
        if (m_TargetContainer)
        {
            return m_TargetContainer;
        }
        else
        {
            return m_TargetDomain;
        }
    }

    void DoOption(long lOptions, VARIANT& vntInclude, VARIANT& vntExclude);

    virtual void DoNone();
    virtual void DoNames();
    virtual void DoDomain();

    void FillInVarSetForUsers(CDomainAccounts& rUsers, CVarSet& rVarSet);
    void FillInVarSetForGroups(CDomainAccounts& rGroups, CVarSet& rVarSet);
    void FillInVarSetForComputers(CDomainAccounts& rComputers, bool bMigrateOnly, bool bMoveToTarget, bool bReboot, long lRebootDelay, CVarSet& rVarSet);

    void MutexWait()
    {
        m_Mutex.ObtainOwnership();
    }

    void MutexRelease()
    {
        m_Mutex.ReleaseOwnership();
    }

    void VerifyRenameConflictPrefixSuffixValid();
    void VerifyCanAddSidHistory();
    void VerifyTargetContainerPathLength();
    void VerifyPasswordOption();
    void SetDefaultExcludedSystemProperties();

    void PerformMigration(CVarSet& rVarSet);

    void SaveSettings(CVarSet& rVarSet)
    {
        IIManageDBPtr spDatabase(__uuidof(IManageDB));
        spDatabase->SaveSettings(IUnknownPtr(rVarSet.GetInterface()));
    }

    void FixObjectsInHierarchy(LPCTSTR pszType);

protected:

    void InitRecurseMaintainOption(long lOptions);
    void GetExcludeNames(VARIANT& vntExclude, StringSet& setExcludeNames);

protected:

    IMigrationInternalPtr m_spInternal;

    CDomain m_SourceDomain;
    CContainer m_SourceContainer;

    CDomain m_TargetDomain;
    CContainer m_TargetContainer;

    int m_nRecurseMaintain;

    StringSet m_setIncludeNames;
    StringSet m_setExcludeNames;

    CMigrationMutex m_Mutex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\migrationbase.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "MigrationBase.h"

#include <LM.h>
#include <DsGetDc.h>
#include <NtSecApi.h>
#include <Sddl.h>
#include <dsrole.h>
#include "SidHistoryFlags.h"
#include "VerifyConfiguration.h"

#include "Error.h"
#include "VarSetAccounts.h"
#include "VarSetServers.h"
#include "FixHierarchy.h"
#include "GetDcName.h"

using namespace _com_util;

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS               ((NTSTATUS)0x00000000L)
#define STATUS_ACCESS_DENIED         ((NTSTATUS)0xC0000022L)
#define STATUS_OBJECT_NAME_NOT_FOUND ((NTSTATUS)0xC0000034L)
#endif

namespace MigrationBase
{

    bool __stdcall IsInboundTrustDefined(PCWSTR pszDomain);
    bool __stdcall IsOutboundTrustDefined(PCWSTR pszDomainController, PCWSTR pszDomainSid);
    DWORD __stdcall GetOutboundTrustStatus(PCWSTR pszDomainController, PCWSTR pszDomain);

    void GetNamesFromData(VARIANT& vntData, StringSet& setNames);
    void GetNamesFromVariant(VARIANT* pvnt, StringSet& setNames);
    void GetNamesFromString(BSTR bstr, StringSet& setNames);
    void GetNamesFromStringArray(SAFEARRAY* psa, StringSet& setNames);
    void GetNamesFromVariantArray(SAFEARRAY* psa, StringSet& setNames);

    void GetNamesFromFile(VARIANT& vntData, StringSet& setNames);
    void GetNamesFromFile(LPCTSTR pszFileName, StringSet& setNames);
    void GetNamesFromStringA(LPCSTR pchString, DWORD cchString, StringSet& setNames);
    void GetNamesFromStringW(LPCWSTR pchString, DWORD cchString, StringSet& setNames);

    _bstr_t RemoveTrailingDollarSign(LPCTSTR pszName);


    void __stdcall AdmtCheckError(HRESULT hr)
    {
        if (FAILED(hr))
        {
            IErrorInfo* pErrorInfo = NULL;

            if (GetErrorInfo(0, &pErrorInfo) == S_OK)
            {
                _com_raise_error(hr, pErrorInfo);
            }
            else
            {
                AdmtThrowError(GUID_NULL, GUID_NULL, hr);
            }
        }
    }

}


using namespace MigrationBase;


//---------------------------------------------------------------------------
// MigrationBase Class
//---------------------------------------------------------------------------


// Constructor

CMigrationBase::CMigrationBase() :
    m_nRecurseMaintain(0),
    m_Mutex(ADMT_MUTEX)
{
}


// Destructor

CMigrationBase::~CMigrationBase()
{
}


// InitSourceDomainAndContainer Method

void CMigrationBase::InitSourceDomainAndContainer(bool bMustExist)
{
    try
    {
        m_SourceDomain.Initialize(m_spInternal->SourceDomain);
        m_SourceContainer = m_SourceDomain.GetContainer(m_spInternal->SourceOu);
    }
    catch (_com_error& ce)
    {
        //
        // if the domain must exist then throw error
        // otherwise at least the domain name must be specified
        //

        if (bMustExist || (ce.Error() == E_INVALIDARG))
        {
            throw;
        }
    }
}


// InitTargetDomainAndContainer Method

void CMigrationBase::InitTargetDomainAndContainer()
{
    m_TargetDomain.Initialize(m_spInternal->TargetDomain);
    m_TargetContainer = m_TargetDomain.GetContainer(m_spInternal->TargetOu);

    // verify target domain is in native mode

    if (m_TargetDomain.NativeMode() == false)
    {
        AdmtThrowError(
            GUID_NULL, GUID_NULL,
            E_INVALIDARG, IDS_E_TARGET_DOMAIN_NOT_NATIVE_MODE,
            (LPCTSTR)m_TargetDomain.Name()
        );
    }

    VerifyTargetContainerPathLength();
}


// VerifyInterIntraForest Method

void CMigrationBase::VerifyInterIntraForest()
{
    // if the source and target domains have the same forest name then they are intra-forest

    bool bIntraForest = m_spInternal->IntraForest ? true : false;

    if (m_SourceDomain.ForestName() == m_TargetDomain.ForestName())
    {
        // intra-forest must be set to true to match the domains

        if (!bIntraForest)
        {
            AdmtThrowError(
                GUID_NULL, GUID_NULL,
                E_INVALIDARG, IDS_E_NOT_INTER_FOREST,
                (LPCTSTR)m_SourceDomain.Name(), (LPCTSTR)m_TargetDomain.Name()
            );
        }
    }
    else
    {
        // intra-forest must be set to false to match the domains

        if (bIntraForest)
        {
            AdmtThrowError(
                GUID_NULL, GUID_NULL,
                E_INVALIDARG, IDS_E_NOT_INTRA_FOREST,
                (LPCTSTR)m_SourceDomain.Name(), (LPCTSTR)m_TargetDomain.Name()
            );
        }
    }
}


//-----------------------------------------------------------------------------
// VerifyCallerDelegated Method
//
// Synopsis
// If an intra-forest move operation is being performed then verify that the
// calling user's account has not been marked as sensitive and therefore
// cannot be delegated. As the move operation is performed on the domain
// controller which has the RID master role in the source domain it is
// necessary to delegate the user's security context.
//
// Note that a failure to verify whether the caller's account is marked
// sensitive or whether we are running on the source domain controller
// holding the RID master role will not generate an error.
//
// Arguments
// None
//
// Return Value
// None. An exception with rich error information is thrown if the caller's
// account is marked as sensitive.
//-----------------------------------------------------------------------------

void CMigrationBase::VerifyCallerDelegated()
{
    //
    // It is only necessary to check this for intra-forest.
    //

    bool bIntraForest = m_spInternal->IntraForest ? true : false;

    if (bIntraForest)
    {
        bool bDelegatable = false;

        HRESULT hr = IsCallerDelegatable(bDelegatable);

        if (SUCCEEDED(hr))
        {
            if (bDelegatable == false)
            {
                //
                // Caller's account is not delegatable. Retrieve name of domain controller
                // in the source domain that holds the RID master role and the name of this
                // computer.
                //

                _bstr_t strDnsName;
                _bstr_t strFlatName;

                hr = GetRidPoolAllocator4(m_SourceDomain.Name(), strDnsName, strFlatName);

                if (SUCCEEDED(hr))
                {
                    _TCHAR szComputerName[MAX_PATH];
                    DWORD cchComputerName = sizeof(szComputerName) / sizeof(szComputerName[0]);

                    if (GetComputerNameEx(ComputerNameDnsFullyQualified, szComputerName, &cchComputerName))
                    {
                        //
                        // If this computer is not the domain controller holding the
                        // RID master role in the source domain then generate error.
                        //

                        if (_tcsicmp(szComputerName, strDnsName) != 0)
                        {
                            AdmtThrowError(GUID_NULL, GUID_NULL, E_FAIL, IDS_E_CALLER_NOT_DELEGATED);
                        }
                    }
                    else
                    {
                        DWORD dwError = GetLastError();
                        hr = HRESULT_FROM_WIN32(dwError);
                    }
                }
            }
        }

        if (FAILED(hr))
        {
            _Module.Log(ErrW, IDS_E_UNABLE_VERIFY_CALLER_NOT_DELEGATED, _com_error(hr));
        }
    }
}


//-----------------------------------------------------------------------------
// SetDefaultExcludedSystemProperties
//
// Synopsis
// Sets the default system property exclusion list if the list has not already
// been set. Note that the default system property exclusion list consists of
// the mail, proxyAddresses and all attributes not marked as being part of the
// base schema.
//
// Arguments
// None
//
// Return Value
// None - generate warning message in log if a failure occurs.
//-----------------------------------------------------------------------------

void CMigrationBase::SetDefaultExcludedSystemProperties()
{
    try
    {
        //
        // Only perform if inter-forest migration and
        // system properties exclusion set value is zero.
        //

        if (m_spInternal->IntraForest == VARIANT_FALSE)
        {
            IIManageDBPtr spIManageDB(__uuidof(IManageDB));

            IVarSetPtr spSettings(__uuidof(VarSet));
            IUnknownPtr spUnknown(spSettings);
            IUnknown* punk = spUnknown;

            spIManageDB->GetSettings(&punk);

            long lSet = spSettings->get(GET_BSTR(DCTVS_AccountOptions_ExcludedSystemPropsSet));

            if (lSet == 0)
            {
                IObjPropBuilderPtr spObjPropBuilder(__uuidof(ObjPropBuilder));

                _bstr_t strNonBaseProperties = spObjPropBuilder->GetNonBaseProperties(m_TargetDomain.Name());
                _bstr_t strProperties = _T("mail,proxyAddresses,") + strNonBaseProperties;

                spSettings->put(GET_BSTR(DCTVS_AccountOptions_ExcludedSystemProps), strProperties);

                spIManageDB->SaveSettings(punk);
            }
        }
    }
    catch (_com_error& ce)
    {
        _Module.Log(ErrW, IDS_E_UNABLE_SET_EXCLUDED_SYSTEM_PROPERTIES, ce);
    }
}


// DoOption Method

void CMigrationBase::DoOption(long lOptions, VARIANT& vntInclude, VARIANT& vntExclude)
{
    m_setIncludeNames.clear();
    m_setExcludeNames.clear();

    InitRecurseMaintainOption(lOptions);

    GetExcludeNames(vntExclude, m_setExcludeNames);

    switch (lOptions & 0xFF)
    {
        case admtNone:
        {
            DoNone();
            break;
        }
        case admtData:
        {
            GetNamesFromData(vntInclude, m_setIncludeNames);
            DoNames();
            break;
        }
        case admtFile:
        {
            GetNamesFromFile(vntInclude, m_setIncludeNames);
            DoNames();
            break;
        }
        case admtDomain:
        {
            m_setIncludeNames.clear();
            DoDomain();
            break;
        }
        default:
        {
            AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_OPTION);
            break;
        }
    }
}


// DoNone Method

void CMigrationBase::DoNone()
{
}


// DoNames Method

void CMigrationBase::DoNames()
{
}


// DoDomain Method

void CMigrationBase::DoDomain()
{
}


// InitRecurseMaintainOption Method

void CMigrationBase::InitRecurseMaintainOption(long lOptions)
{
    switch (lOptions & 0xFF)
    {
        case admtData:
        case admtFile:
        {
            if (lOptions & 0xFF00)
            {
                AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_DATA_OPTION_FLAGS_NOT_ALLOWED);
            }

            m_nRecurseMaintain = 0;
            break;
        }
        case admtDomain:
        {
            m_nRecurseMaintain = 0;

            if (lOptions & admtRecurse)
            {
                ++m_nRecurseMaintain;

                if (lOptions & admtMaintainHierarchy)
                {
                    ++m_nRecurseMaintain;
                }
            }
            break;
        }
        default:
        {
            m_nRecurseMaintain = 0;
            break;
        }
    }
}


// GetExcludeNames Method

void CMigrationBase::GetExcludeNames(VARIANT& vntExclude, StringSet& setExcludeNames)
{
    try
    {
        switch (V_VT(&vntExclude))
        {
            case VT_EMPTY:
            case VT_ERROR:
            {
                setExcludeNames.clear();
                break;
            }
            case VT_BSTR:
            {
                GetNamesFromFile(V_BSTR(&vntExclude), setExcludeNames);
                break;
            }
            case VT_BSTR|VT_BYREF:
            {
                BSTR* pbstr = V_BSTRREF(&vntExclude);

                if (pbstr)
                {
                    GetNamesFromFile(*pbstr, setExcludeNames);
                }
                break;
            }
            case VT_BSTR|VT_ARRAY:
            {
                GetNamesFromStringArray(V_ARRAY(&vntExclude), setExcludeNames);
                break;
            }
            case VT_BSTR|VT_ARRAY|VT_BYREF:
            {
                SAFEARRAY** ppsa = V_ARRAYREF(&vntExclude);

                if (ppsa)
                {
                    GetNamesFromStringArray(*ppsa, setExcludeNames);
                }
                break;
            }
            case VT_VARIANT|VT_BYREF:
            {
                VARIANT* pvnt = V_VARIANTREF(&vntExclude);

                if (pvnt)
                {
                    GetExcludeNames(*pvnt, setExcludeNames);
                }
                break;
            }
            case VT_VARIANT|VT_ARRAY:
            {
                GetNamesFromVariantArray(V_ARRAY(&vntExclude), setExcludeNames);
                break;
            }
            case VT_VARIANT|VT_ARRAY|VT_BYREF:
            {
                SAFEARRAY** ppsa = V_ARRAYREF(&vntExclude);

                if (ppsa)
                {
                    GetNamesFromVariantArray(*ppsa, setExcludeNames);
                }
                break;
            }
            default:
            {
                _com_issue_error(E_INVALIDARG);
                break;
            }
        }
    }
    catch (_com_error& ce)
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, ce.Error(), IDS_E_INVALID_EXCLUDE_DATA_TYPE);
    }
    catch (...)
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, E_FAIL, IDS_E_INVALID_EXCLUDE_DATA_TYPE);
    }
}


// FillInVarSetForUsers Method

void CMigrationBase::FillInVarSetForUsers(CDomainAccounts& rUsers, CVarSet& rVarSet)
{
    CVarSetAccounts aAccounts(rVarSet);

    for (CDomainAccounts::iterator it = rUsers.begin(); it != rUsers.end(); it++)
    {
        aAccounts.AddAccount(_T("User"), it->GetADsPath(), it->GetName(), it->GetUserPrincipalName());
    }
}


// FillInVarSetForGroups Method

void CMigrationBase::FillInVarSetForGroups(CDomainAccounts& rGroups, CVarSet& rVarSet)
{
    CVarSetAccounts aAccounts(rVarSet);

    for (CDomainAccounts::iterator it = rGroups.begin(); it != rGroups.end(); it++)
    {
        aAccounts.AddAccount(_T("Group"), it->GetADsPath(), it->GetName());
    }
}


// FillInVarSetForComputers Method

void CMigrationBase::FillInVarSetForComputers(CDomainAccounts& rComputers, bool bMigrateOnly, bool bMoveToTarget, bool bReboot, long lRebootDelay, CVarSet& rVarSet)
{
    CVarSetAccounts aAccounts(rVarSet);
    CVarSetServers aServers(rVarSet);

    for (CDomainAccounts::iterator it = rComputers.begin(); it != rComputers.end(); it++)
    {
        // remove trailing '$'
        // ADMT doesn't accept true SAM account name

        _bstr_t strName = RemoveTrailingDollarSign(it->GetSamAccountName());

        aAccounts.AddAccount(_T("Computer"), strName);
        aServers.AddServer(strName, it->GetDnsHostName(), bMigrateOnly, bMoveToTarget, bReboot, lRebootDelay);
    }
}


// VerifyRenameConflictPrefixSuffixValid Method

void CMigrationBase::VerifyRenameConflictPrefixSuffixValid()
{
    int nTotalPrefixSuffixLength = 0;

    long lRenameOption = m_spInternal->RenameOption;

    if ((lRenameOption == admtRenameWithPrefix) || (lRenameOption == admtRenameWithSuffix))
    {
        _bstr_t strPrefixSuffix = m_spInternal->RenamePrefixOrSuffix;

        nTotalPrefixSuffixLength += strPrefixSuffix.length();
    }

    long lConflictOption = m_spInternal->ConflictOptions & 0x0F;

    if ((lConflictOption == admtRenameConflictingWithSuffix) || (lConflictOption == admtRenameConflictingWithPrefix))
    {
        _bstr_t strPrefixSuffix = m_spInternal->ConflictPrefixOrSuffix;

        nTotalPrefixSuffixLength += strPrefixSuffix.length();
    }

    if (nTotalPrefixSuffixLength > MAXIMUM_PREFIX_SUFFIX_LENGTH)
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_PREFIX_SUFFIX_TOO_LONG, MAXIMUM_PREFIX_SUFFIX_LENGTH);
    }
}


// VerifyCanAddSidHistory Method

void CMigrationBase::VerifyCanAddSidHistory()
{
    bool bMessageDefined = false;

    try
    {
        long lErrorFlags = 0;

        IAccessCheckerPtr spAccessChecker(__uuidof(AccessChecker));

        spAccessChecker->CanUseAddSidHistory(
            m_SourceDomain.Name(),
            m_TargetDomain.Name(),
            m_TargetDomain.DomainControllerName(),
            &lErrorFlags
        );

        if (lErrorFlags != 0)
        {
            _bstr_t strError;

            CComBSTR str;

            if (lErrorFlags & F_NO_AUDITING_SOURCE)
            {
                str.LoadString(IDS_E_NO_AUDITING_SOURCE);
                strError += str.operator BSTR();
            }

            if (lErrorFlags & F_NO_AUDITING_TARGET)
            {
                str.LoadString(IDS_E_NO_AUDITING_TARGET);
                strError += str.operator BSTR();
            }

            if (lErrorFlags & F_NO_LOCAL_GROUP)
            {
                str.LoadString(IDS_E_NO_SID_HISTORY_LOCAL_GROUP);
                strError += str.operator BSTR();
            }

            if (lErrorFlags & F_NO_REG_KEY)
            {
                str.LoadString(IDS_E_NO_SID_HISTORY_REGISTRY_ENTRY);
                strError += str.operator BSTR();
            }

            if (lErrorFlags & F_NOT_DOMAIN_ADMIN)
            {
                str.LoadString(IDS_E_NO_SID_HISTORY_DOMAIN_ADMIN);
                strError += str.operator BSTR();
            }

            bMessageDefined = true;
            AdmtThrowError(GUID_NULL, GUID_NULL, E_FAIL, IDS_E_SID_HISTORY_CONFIGURATION, (LPCTSTR)strError);
        }

        //
        // If adding SID history from a downlevel (Windows NT 4 or earlier) domain and not using
        // explicit credentials then DsAddSidHistory requires that the call be made on a domain
        // controller in the target domain and that the source domain trusts the target domain.
        //
        // No credentials are supplied only when using scripting or the command-line therefore
        // this check is only performed here.
        //

        if (m_SourceDomain.UpLevel() == false)
        {
            //
            // The source domain is downlevel.
            //

            //
            // Verify that this computer is in the target domain.
            //

            CADsADSystemInfo siSystemInfo;
            _bstr_t strThisDomain = siSystemInfo.GetDomainDNSName();
            _bstr_t strTargetDomain = m_TargetDomain.NameDns();

            if (!strThisDomain || !strTargetDomain)
            {
                _com_issue_error(E_OUTOFMEMORY);
            }

            if (_wcsicmp((PCWSTR)strThisDomain, (PCWSTR)strTargetDomain) != 0)
            {
                bMessageDefined = true;
                AdmtThrowError(GUID_NULL, GUID_NULL, HRESULT_FROM_WIN32(ERROR_DS_MUST_BE_RUN_ON_DST_DC), IDS_E_SID_HISTORY_MUST_RUN_ON_DOMAIN_CONTROLLER);
            }

            //
            // Verify that this computer is a domain controller.
            //

            PSERVER_INFO_101 psiInfo = NULL;
            NET_API_STATUS nasStatus = NetServerGetInfo(NULL, 101, (LPBYTE*)&psiInfo);

            if (nasStatus != ERROR_SUCCESS)
            {
                _com_issue_error(HRESULT_FROM_WIN32(nasStatus));
            }

            bool bIsDC = (psiInfo->sv101_type & (SV_TYPE_DOMAIN_CTRL|SV_TYPE_DOMAIN_BAKCTRL)) != 0;
            NetApiBufferFree(psiInfo);

            if (!bIsDC)
            {
                bMessageDefined = true;
                AdmtThrowError(GUID_NULL, GUID_NULL, HRESULT_FROM_WIN32(ERROR_DS_MUST_BE_RUN_ON_DST_DC), IDS_E_SID_HISTORY_MUST_RUN_ON_DOMAIN_CONTROLLER);
            }

            //
            // Verify trusted domain object exists in target domain
            // for source domain and that an inbound trust is defined.
            //

            if (IsInboundTrustDefined(m_SourceDomain.NameFlat()) == false)
            {
                bMessageDefined = true;
                AdmtThrowError(GUID_NULL, GUID_NULL, HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), IDS_E_SID_HISTORY_SOURCE_MUST_TRUST_TARGET);
            }

            //
            // Verify trusted domain object exists in source domain for
            // target domain which specifies an outbound trust.
            //

            if (IsOutboundTrustDefined(m_SourceDomain.DomainControllerName(), m_TargetDomain.Sid()) == false)
            {
                bMessageDefined = true;
                AdmtThrowError(GUID_NULL, GUID_NULL, HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), IDS_E_SID_HISTORY_SOURCE_MUST_TRUST_TARGET);
            }

            //
            // Check outbound trust status on source domain controller.
            //

            DWORD dwError = GetOutboundTrustStatus(m_SourceDomain.DomainControllerName(), m_TargetDomain.NameFlat());

            if (dwError != ERROR_SUCCESS)
            {
                bMessageDefined = true;
                AdmtThrowError(GUID_NULL, GUID_NULL, HRESULT_FROM_WIN32(dwError), IDS_E_SID_HISTORY_SOURCE_MUST_TRUST_TARGET);
            }
        }
    }
    catch (_com_error& ce)
    {
        if (bMessageDefined)
        {
            throw;
        }
        else
        {
            AdmtThrowError(GUID_NULL, GUID_NULL, ce, IDS_E_CAN_ADD_SID_HISTORY);
        }
    }
    catch (...)
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, E_FAIL, IDS_E_CAN_ADD_SID_HISTORY);
    }
}


// VerifyTargetContainerPathLength Method

void CMigrationBase::VerifyTargetContainerPathLength()
{
    _bstr_t strPath = GetTargetContainer().GetPath();

    if (strPath.length() > 999)
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_TARGET_CONTAINER_PATH_TOO_LONG);
    }
}


// VerifyPasswordServer Method

void CMigrationBase::VerifyPasswordOption()
{
    if (m_spInternal->PasswordOption == admtCopyPassword)
    {
        _bstr_t strServer = m_spInternal->PasswordServer;

        // a password server must be specified for copy password option

        if (strServer.length() == 0)
        {
            AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_PASSWORD_DC_NOT_SPECIFIED);
        }

        //
        // verify that password server exists and is a domain controller
        //

        _bstr_t strPrefixedServer;
        _bstr_t strUnprefixedServer;
        

        if (_tcsncmp(strServer, _T("\\\\"), 2) == 0)
        {
            strPrefixedServer = strServer;
            strUnprefixedServer = &(((const wchar_t*)strServer)[2]);
        }
        else
        {
            strPrefixedServer = _T("\\\\") + strServer;
            strUnprefixedServer = strServer;
        }

        PSERVER_INFO_101 psiInfo;

        NET_API_STATUS nasStatus = NetServerGetInfo(strPrefixedServer, 101, (LPBYTE*)&psiInfo);

        if (nasStatus != NERR_Success)
        {
            AdmtThrowError(GUID_NULL, GUID_NULL, HRESULT_FROM_WIN32(nasStatus), IDS_E_PASSWORD_DC_NOT_FOUND, (LPCTSTR)strServer);
        }

        UINT uMsgId = 0;

        if (psiInfo->sv101_platform_id != PLATFORM_ID_NT)
        {
            uMsgId = IDS_E_PASSWORD_DC_NOT_NT;
        }
        else if (!(psiInfo->sv101_type & SV_TYPE_DOMAIN_CTRL) && !(psiInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL))
        {
            uMsgId = IDS_E_PASSWORD_DC_NOT_DC;
        }

        NetApiBufferFree(psiInfo);

        if (uMsgId)
        {
            AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, uMsgId, (LPCTSTR)strServer);
        }


        //
        // Verify that the password server is in fact a domain controller for
        // the source domain.
        //
        DSROLE_PRIMARY_DOMAIN_INFO_BASIC * pDomInfo = NULL;


        DWORD err = DsRoleGetPrimaryDomainInformation(strUnprefixedServer,
                                                      DsRolePrimaryDomainInfoBasic,
                                                      (PBYTE*)&pDomInfo);

        if (err != NO_ERROR)
        {
            AdmtThrowError(GUID_NULL, GUID_NULL, HRESULT_FROM_WIN32(err), IDS_E_PASSWORD_DC_NOT_FOUND, (LPCTSTR)strServer);
        }



        // compare them
        if ( ( (pDomInfo->DomainNameFlat != NULL)  &&
               ((const wchar_t*)m_SourceDomain.NameFlat() != NULL) &&
               (_wcsicmp(pDomInfo->DomainNameFlat, (const wchar_t*)m_SourceDomain.NameFlat())==0) ) ||

             ( (pDomInfo->DomainNameDns != NULL)  &&
               ((const wchar_t*)m_SourceDomain.NameDns() != NULL) &&
               (_wcsicmp(pDomInfo->DomainNameDns, (const wchar_t*)m_SourceDomain.NameDns())==0) ) )
             
        {
            // at least one of them matches
            uMsgId = 0;
        }
        else
        {
            // no match
            uMsgId = IDS_E_PASSWORD_DC_WRONG_DOMAIN;
        }
        

        DsRoleFreeMemory(pDomInfo);


        if (uMsgId)
        {
            AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, uMsgId, (LPCTSTR)strServer);
        }

        //
        // verify that password server is configured properly
        //

        IPasswordMigrationPtr spPasswordMigration(__uuidof(PasswordMigration));

        spPasswordMigration->EstablishSession(strPrefixedServer, m_TargetDomain.DomainControllerName());
    }
}


// PerformMigration Method

void CMigrationBase::PerformMigration(CVarSet& rVarSet)
{
    IPerformMigrationTaskPtr spMigrator(__uuidof(Migrator));

    try
    {
        AdmtCheckError(spMigrator->raw_PerformMigrationTask(IUnknownPtr(rVarSet.GetInterface()), 0));
    }
    catch (_com_error& ce)
    {
        if (ce.Error() == MIGRATOR_E_PROCESSES_STILL_RUNNING)
        {
            AdmtThrowError(GUID_NULL, GUID_NULL, ce.Error(), IDS_E_ADMT_PROCESS_RUNNING);
        }
        else
        {
            throw;
        }
    }
}


// FixObjectsInHierarchy Method

void CMigrationBase::FixObjectsInHierarchy(LPCTSTR pszType)
{
    CFixObjectsInHierarchy fix;

    fix.SetObjectType(pszType);
    fix.SetIntraForest(m_spInternal->IntraForest ? true : false);

    long lOptions = m_spInternal->ConflictOptions;
    long lOption = lOptions & 0x0F;
    long lFlags = lOptions & 0xF0;

    fix.SetFixReplaced((lOption == admtReplaceConflicting) && (lFlags & admtMoveReplacedAccounts));

    fix.SetSourceContainerPath(m_SourceContainer.GetPath());
    fix.SetTargetContainerPath(m_TargetContainer.GetPath());

    fix.FixObjects();
}


//---------------------------------------------------------------------------


namespace MigrationBase
{


// GetNamesFromData Method

void GetNamesFromData(VARIANT& vntData, StringSet& setNames)
{
    try
    {
        GetNamesFromVariant(&vntData, setNames);
    }
    catch (_com_error& ce)
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, ce.Error(), IDS_E_INVALID_DATA_OPTION_DATA_TYPE);
    }
    catch (...)
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, E_FAIL, IDS_E_INVALID_DATA_OPTION_DATA_TYPE);
    }
}


// GetNamesFromVariant Method

void GetNamesFromVariant(VARIANT* pvntData, StringSet& setNames)
{
    switch (V_VT(pvntData))
    {
        case VT_BSTR:
        {
            GetNamesFromString(V_BSTR(pvntData), setNames);
            break;
        }
        case VT_BSTR|VT_BYREF:
        {
            BSTR* pbstr = V_BSTRREF(pvntData);

            if (pbstr)
            {
                GetNamesFromString(*pbstr, setNames);
            }
            break;
        }
        case VT_BSTR|VT_ARRAY:
        {
            GetNamesFromStringArray(V_ARRAY(pvntData), setNames);
            break;
        }
        case VT_BSTR|VT_ARRAY|VT_BYREF:
        {
            SAFEARRAY** ppsa = V_ARRAYREF(pvntData);

            if (ppsa)
            {
                GetNamesFromStringArray(*ppsa, setNames);
            }
            break;
        }
        case VT_VARIANT|VT_BYREF:
        {
            VARIANT* pvnt = V_VARIANTREF(pvntData);

            if (pvnt)
            {
                GetNamesFromVariant(pvnt, setNames);
            }
            break;
        }
        case VT_VARIANT|VT_ARRAY:
        {
            GetNamesFromVariantArray(V_ARRAY(pvntData), setNames);
            break;
        }
        case VT_VARIANT|VT_ARRAY|VT_BYREF:
        {
            SAFEARRAY** ppsa = V_ARRAYREF(pvntData);

            if (ppsa)
            {
                GetNamesFromVariantArray(*ppsa, setNames);
            }
            break;
        }
        case VT_EMPTY:
        {
            // ignore empty variants
            break;
        }
        default:
        {
            _com_issue_error(E_INVALIDARG);
            break;
        }
    }
}


// GetNamesFromString Method

void GetNamesFromString(BSTR bstr, StringSet& setNames)
{
    if (bstr)
    {
        UINT cch = SysStringLen(bstr);

        if (cch > 0)
        {
            GetNamesFromStringW(bstr, cch, setNames);
        }
    }
}


// GetNamesFromStringArray Method

void GetNamesFromStringArray(SAFEARRAY* psa, StringSet& setNames)
{
    BSTR* pbstr;

    HRESULT hr = SafeArrayAccessData(psa, (void**)&pbstr);

    if (SUCCEEDED(hr))
    {
        try
        {
            UINT uDimensionCount = psa->cDims;

            for (UINT uDimension = 0; uDimension < uDimensionCount; uDimension++)
            {
                UINT uElementCount = psa->rgsabound[uDimension].cElements;

                for (UINT uElement = 0; uElement < uElementCount; uElement++)
                {
                    setNames.insert(_bstr_t(*pbstr++));
                }
            }

            SafeArrayUnaccessData(psa);
        }
        catch (...)
        {
            SafeArrayUnaccessData(psa);
            throw;
        }
    }
}


// GetNamesFromVariantArray Method

void GetNamesFromVariantArray(SAFEARRAY* psa, StringSet& setNames)
{
    VARIANT* pvnt;

    HRESULT hr = SafeArrayAccessData(psa, (void**)&pvnt);

    if (SUCCEEDED(hr))
    {
        try
        {
            UINT uDimensionCount = psa->cDims;

            for (UINT uDimension = 0; uDimension < uDimensionCount; uDimension++)
            {
                UINT uElementCount = psa->rgsabound[uDimension].cElements;

                for (UINT uElement = 0; uElement < uElementCount; uElement++)
                {
                    GetNamesFromVariant(pvnt++, setNames);
                }
            }

            SafeArrayUnaccessData(psa);
        }
        catch (...)
        {
            SafeArrayUnaccessData(psa);
            throw;
        }
    }
}


// GetNamesFromFile Method
//
// - the maximum file size this implementation can handle is 4,294,967,295 bytes

void GetNamesFromFile(VARIANT& vntData, StringSet& setNames)
{
    bool bInvalidArg = false;

    switch (V_VT(&vntData))
    {
        case VT_BSTR:
        {
            BSTR bstr = V_BSTR(&vntData);

            if (bstr)
            {
                GetNamesFromFile(bstr, setNames);
            }
            else
            {
                bInvalidArg = true;
            }
            break;
        }
        case VT_BSTR|VT_BYREF:
        {
            BSTR* pbstr = V_BSTRREF(&vntData);

            if (pbstr && *pbstr)
            {
                GetNamesFromFile(*pbstr, setNames);
            }
            else
            {
                bInvalidArg = true;
            }
            break;
        }
        case VT_VARIANT|VT_BYREF:
        {
            VARIANT* pvnt = V_VARIANTREF(&vntData);

            if (pvnt)
            {
                GetNamesFromFile(*pvnt, setNames);
            }
            else
            {
                bInvalidArg = true;
            }
            break;
        }
        default:
        {
            bInvalidArg = true;
            break;
        }
    }

    if (bInvalidArg)
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILE_OPTION_DATA_TYPE);
    }
}


// GetNamesFromFile Method
//
// - the maximum file size this implementation can handle is 4,294,967,295 bytes

void GetNamesFromFile(LPCTSTR pszFileName, StringSet& setNames)
{
    HRESULT hr = S_OK;

    if (pszFileName)
    {
        HANDLE hFile = CreateFile(pszFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD dwFileSize = GetFileSize(hFile, NULL);

            if (dwFileSize > 0)
            {
                HANDLE hFileMappingObject = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

                if (hFileMappingObject != NULL)
                {
                    LPVOID pvBase = MapViewOfFile(hFileMappingObject, FILE_MAP_READ, 0, 0, 0);

                    if (pvBase != NULL)
                    {
                        // if Unicode signature assume Unicode file
                        // otherwise it must be an ANSI file

                        LPCWSTR pwcs = (LPCWSTR)pvBase;

                        if ((dwFileSize >= 2) && (*pwcs == L'\xFEFF'))
                        {
                            GetNamesFromStringW(pwcs + 1, dwFileSize / sizeof(WCHAR) - 1, setNames);
                        }
                        else
                        {
                            GetNamesFromStringA((LPCSTR)pvBase, dwFileSize, setNames);
                        }

                        UnmapViewOfFile(pvBase);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }

                    CloseHandle(hFileMappingObject);
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }

            CloseHandle(hFile);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (FAILED(hr))
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, hr, IDS_E_INCLUDE_NAMES_FILE, pszFileName);
    }
}


// GetNamesFromStringA Method

void GetNamesFromStringA(LPCSTR pchString, DWORD cchString, StringSet& setNames)
{
    static const CHAR chSeparators[] = "\t\n\r";

    LPSTR pszName = NULL;
    size_t cchName = 0;

    try
    {
        LPCSTR pchStringEnd = &pchString[cchString];

        for (LPCSTR pch = pchString; pch < pchStringEnd; pch++)
        {
            // skip space characters

            while ((pch < pchStringEnd) && (*pch == ' '))
            {
                ++pch;
            }

            // beginning of name

            LPCSTR pchBeg = pch;

            // scan for separator saving pointer to last non-whitespace character

            LPCSTR pchEnd = pch;

            while ((pch < pchStringEnd) && (strchr(chSeparators, *pch) == NULL))
            {
                if (*pch++ != ' ')
                {
                    pchEnd = pch;
                }
            }

            // insert name which doesn't contain any leading or trailing whitespace characters

            if (pchEnd > pchBeg)
            {
                size_t cch = pchEnd - pchBeg;

                //
                // If potential size of buffer does not exceed maximum value of size_t.
                //

                if (cch < (cch + 256))
                {
                    //
                    // If buffer size is less than or equal to the number
                    // of characters in the name then reallocate the buffer.
                    // Note that this accounts for the final null character.
                    //

                    if (cchName <= cch)
                    {
                        //
                        // Delete current buffer. Increase buffer size to a multiple
                        // of 256 characters greater than the length of the current
                        // name. Note that this allows for the final null character.
                        // Allocate a new buffer.
                        //

                        delete [] pszName;

                        while (cchName <= cch)
                        {
                            cchName += 256;
                        }

                        pszName = new CHAR[cchName];

                        if (pszName == NULL)
                        {
                            _com_issue_error(E_OUTOFMEMORY);
                        }
                    }

                    strncpy(pszName, pchBeg, cch);
                    pszName[cch] = '\0';

                    setNames.insert(_bstr_t(pszName));
                }
                else
                {
                    //
                    // Should never get here as this means the pointer
                    // difference is within 256 characters of the maximum
                    // value of the size_t data type.
                    //

                    _com_issue_error(E_FAIL);
                }
            }
        }
    }
    catch (...)
    {
        delete [] pszName;
        throw;
    }

    delete [] pszName;
}


// GetNamesFromStringW Method

void GetNamesFromStringW(LPCWSTR pchString, DWORD cchString, StringSet& setNames)
{
    static const WCHAR chSeparators[] = L"\t\n\r";

    LPCWSTR pchStringEnd = &pchString[cchString];

    for (LPCWSTR pch = pchString; pch < pchStringEnd; pch++)
    {
        // skip space characters

        while ((pch < pchStringEnd) && (*pch == L' '))
        {
            ++pch;
        }

        // beginning of name

        LPCWSTR pchBeg = pch;

        // scan for separator saving pointer to last non-whitespace character

        LPCWSTR pchEnd = pch;

        while ((pch < pchStringEnd) && (wcschr(chSeparators, *pch) == NULL))
        {
            if (*pch++ != L' ')
            {
                pchEnd = pch;
            }
        }

        // insert name which doesn't contain any leading or trailing whitespace characters

        if (pchEnd > pchBeg)
        {
            _bstr_t strName(SysAllocStringLen(pchBeg, pchEnd - pchBeg), false);

            setNames.insert(strName);
        }
    }
}


// RemoveTrailingDollarSign Method

_bstr_t RemoveTrailingDollarSign(LPCTSTR pszName)
{
    LPTSTR psz = _T("");

    if (pszName)
    {
        size_t cch = _tcslen(pszName);

        if (cch > 0)
        {
            psz = reinterpret_cast<LPTSTR>(_alloca((cch + 1) * sizeof(_TCHAR)));

            _tcscpy(psz, pszName);

            LPTSTR p = &psz[cch - 1];

            if (*p == _T('$'))
            {
                *p = _T('\0');
            }
        }
    }

    return psz;
}


//---------------------------------------------------------------------------
// IsInboundTrustDefined Function
//
// Synopsis
// Verifies that a trusted domain object exists for the specified domain and
// that an inbound trust is defined (i.e. the specified domain trusts this
// domain).
//
// Arguments
// IN pszDomain - the name of the trusting domain
//
// Return
// True  - trusted domain object exists and an inbound trust is defined
// False - either trusted domain object does not exist or an inbound trust
//         is not defined
//---------------------------------------------------------------------------

bool __stdcall IsInboundTrustDefined(PCWSTR pszDomain)
{
    bool bTrust = false;

    LSA_HANDLE lsahPolicy = NULL;
    PTRUSTED_DOMAIN_INFORMATION_EX ptdieInfo = NULL;

    try
    {
        //
        // Open local policy object with view local information access.
        //

        LSA_OBJECT_ATTRIBUTES lsaoa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

        NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &lsaoa, POLICY_VIEW_LOCAL_INFORMATION, &lsahPolicy);

        if (ntsStatus != STATUS_SUCCESS)
        {
            _com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
        }

        //
        // Query for trusted domain object for specified domain.
        //

        PWSTR pwsDomain = const_cast<PWSTR>(pszDomain);
        USHORT cbDomain = wcslen(pszDomain) * sizeof(WCHAR);

        LSA_UNICODE_STRING lsausDomain = { cbDomain, cbDomain, pwsDomain };

        ntsStatus = LsaQueryTrustedDomainInfoByName(
            lsahPolicy,
            &lsausDomain,
            TrustedDomainInformationEx,
            (PVOID*)&ptdieInfo
        );

        if (ntsStatus == STATUS_SUCCESS)
        {
            //
            // Trusted domain object exists. Verify
            // that an inbound trust is defined.
            //

            ULONG ulDirection = ptdieInfo->TrustDirection;

            if ((ulDirection == TRUST_DIRECTION_INBOUND) || (ulDirection == TRUST_DIRECTION_BIDIRECTIONAL))
            {
                bTrust = true;
            }
        }
        else
        {
            //
            // If error is not that trusted domain object
            // does not exist then generate exception.
            //

            if (ntsStatus != STATUS_OBJECT_NAME_NOT_FOUND)
            {
                _com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
            }
        }

        //
        // Clean up.
        //

        if (ptdieInfo)
        {
            LsaFreeMemory(ptdieInfo);
        }

        if (lsahPolicy)
        {
            LsaClose(lsahPolicy);
        }
    }
    catch (...)
    {
        if (ptdieInfo)
        {
            LsaFreeMemory(ptdieInfo);
        }

        if (lsahPolicy)
        {
            LsaClose(lsahPolicy);
        }

        throw;
    }

    return bTrust;
}


//---------------------------------------------------------------------------
// IsOutboundTrustDefined Function
//
// Synopsis
// Verifies that a trusted domain object exists for the specified domain on
// the specified domain controller (i.e. the domain of the specified domain
// controller trusts the specified domain).
//
// Note that this function should only be used for downlevel (NT4 or earlier)
// domains and that simply the presence of a trusted domain object is
// sufficient in this case to indicate an outbound trust.
//
// Arguments
// IN pszDomainController - the name of a domain controller in the trusting
//                          domain
// IN pszDomainSid        - the SID of the trusted domain in string format
//
// Return
// True  - trusted domain object exists
// False - trusted domain object does not exist
//---------------------------------------------------------------------------

bool __stdcall IsOutboundTrustDefined(PCWSTR pszDomainController, PCWSTR pszDomainSid)
{
    bool bTrust = false;

    LSA_HANDLE lsahPolicy = NULL;
    PSID psidDomain = NULL;
    PTRUSTED_DOMAIN_NAME_INFO ptdniDomainNameInfo = NULL;

    try
    {
        //
        // Open policy object on specified domain controller
        // with view local information access.
        //

        PWSTR pwsDomainController = const_cast<PWSTR>(pszDomainController);
        USHORT cbDomainController = wcslen(pszDomainController) * sizeof(WCHAR);

        LSA_UNICODE_STRING lsausDomainController = { cbDomainController, cbDomainController, pwsDomainController };
        LSA_OBJECT_ATTRIBUTES lsaoa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

        NTSTATUS ntsStatus = LsaOpenPolicy(&lsausDomainController, &lsaoa, POLICY_VIEW_LOCAL_INFORMATION, &lsahPolicy);

        if (ntsStatus != STATUS_SUCCESS)
        {
            _com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
        }

        //
        // Convert SID from string format to binary format.
        //

        if (!ConvertStringSidToSid(pszDomainSid, &psidDomain))
        {
            DWORD dwError = GetLastError();
            _com_issue_error(HRESULT_FROM_WIN32(dwError));
        }

        //
        // Query for trusted domain object. Note that LsaQueryTrustedDomainInfo is
        // used because LsaQueryTrustedDomainInfoByName is only supported on
        // Windows 2000 or later.
        //

        ntsStatus = LsaQueryTrustedDomainInfo(
            lsahPolicy,
            psidDomain,
            TrustedDomainNameInformation,
            (PVOID*)&ptdniDomainNameInfo
        );

        switch (ntsStatus)
        {
            case STATUS_SUCCESS:
            {
                //
                // The trusted domain object exists.
                //
                bTrust = true;
                break;
            }
            case STATUS_OBJECT_NAME_NOT_FOUND:
            {
                //
                // The trusted domain object does not exist.
                //
                break;
            }
            default:
            {
                //
                // Another error has occurred therefore generate an exception.
                //
                _com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
                break;
            }
        }

        //
        // Clean up.
        //

        if (ptdniDomainNameInfo)
        {
            LsaFreeMemory(ptdniDomainNameInfo);
        }

        if (psidDomain)
        {
            LocalFree(psidDomain);
        }

        if (lsahPolicy)
        {
            LsaClose(lsahPolicy);
        }
    }
    catch (...)
    {
        if (ptdniDomainNameInfo)
        {
            LsaFreeMemory(ptdniDomainNameInfo);
        }

        if (psidDomain)
        {
            LocalFree(psidDomain);
        }

        if (lsahPolicy)
        {
            LsaClose(lsahPolicy);
        }

        throw;
    }

    return bTrust;
}


//---------------------------------------------------------------------------
// GetOutboundTrustStatus Function
//
// Synopsis
// Retrieves the trust connection status for the specified domain on the
// specified domain controller. The status represents the last connection
// status of the secure channel but does not quarantee that a future request
// will succeed. The only way to really verify the secure channel is to
// reset the secure channel which should not be done arbitrarily.
//
// Arguments
// IN pszDomainController - the name of a domain controller in the trusting
//                          domain
// IN pszDomain           - the name of the trusted domain
//
// Return
// ERROR_SUCCESS - the last connection status is okay otherwise the last
//                 connection status error
//---------------------------------------------------------------------------

DWORD __stdcall GetOutboundTrustStatus(PCWSTR pszDomainController, PCWSTR pszDomain)
{
    PNETLOGON_INFO_2 pni2Info = NULL;

    NET_API_STATUS nasStatus = I_NetLogonControl2(
        pszDomainController,
        NETLOGON_CONTROL_TC_QUERY,
        2,
        (LPBYTE)&pszDomain,
        (LPBYTE*)&pni2Info
    );

    if (nasStatus == ERROR_SUCCESS)
    {
        nasStatus = pni2Info->netlog2_tc_connection_status;
    }

    if (pni2Info)
    {
        NetApiBufferFree(pni2Info);
    }

    return nasStatus;
}


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\migration.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "Migration.h"

#include "Error.h"
#include "UserMigration.h"
#include "GroupMigration.h"
#include "ComputerMigration.h"
#include "SecurityTranslation.h"
#include "ServiceAccountEnumeration.h"
#include "ReportGeneration.h"
#include "RegistryHelper.h"

#include <LM.h>
#include <DsGetDC.h>

#import <DBMgr.tlb> no_namespace
#import <UpdateMOT.tlb> no_namespace

using namespace _com_util;

#ifndef tstring
#include <string>
typedef std::basic_string<_TCHAR> tstring;
#endif


//---------------------------------------------------------------------------
// CMigration
//---------------------------------------------------------------------------


// Construction -------------------------------------------------------------


// Constructor

CMigration::CMigration() :
	m_bTestMigration(false),
	m_bIntraForest(false),
	m_lRenameOption(admtDoNotRename),
	m_lPasswordOption(admtComplexPassword),
	m_lConflictOptions(admtIgnoreConflicting)
{
}


// Destructor

CMigration::~CMigration()
{
}


HRESULT CMigration::FinalConstruct()
{
    HRESULT hr = S_OK;

    try
        {
            DWORD lRet = IsAdminLocal();
            if (lRet != ERROR_SUCCESS)
                AdmtThrowError(GUID_NULL, GUID_NULL, HRESULT_FROM_WIN32(lRet), IDS_E_LOCAL_ADMIN_CHECK_FAILED);

            lRet = MoveRegistry();
            if (lRet != ERROR_SUCCESS)
                AdmtThrowError(GUID_NULL, GUID_NULL, HRESULT_FROM_WIN32(lRet), IDS_E_UPDATE_REGISTRY_FAILED);

            UpdateDatabase();
        }
    catch (_com_error& ce)
        {
            hr = AdmtSetError(GUID_NULL, GUID_NULL, ce);
        }

    return hr;
}


void CMigration::FinalRelease()
{
}


// IMigration Implementation ------------------------------------------------


// TestMigration Property

STDMETHODIMP CMigration::put_TestMigration(VARIANT_BOOL bTest)
{
	m_bTestMigration = bTest ? true : false;

	return S_OK;
}

STDMETHODIMP CMigration::get_TestMigration(VARIANT_BOOL* pbTest)
{
	*pbTest = m_bTestMigration ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// IntraForest Property

STDMETHODIMP CMigration::put_IntraForest(VARIANT_BOOL bIntraForest)
{
	m_bIntraForest = bIntraForest ? true : false;

	return S_OK;
}

STDMETHODIMP CMigration::get_IntraForest(VARIANT_BOOL* pbIntraForest)
{
	*pbIntraForest = m_bIntraForest ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// SourceDomain Property

STDMETHODIMP CMigration::put_SourceDomain(BSTR bstrDomain)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrSourceDomain = bstrDomain;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_SourceDomain(BSTR* pbstrDomain)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrDomain = m_bstrSourceDomain.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// SourceOu Property

STDMETHODIMP CMigration::put_SourceOu(BSTR bstrOu)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrSourceOu = bstrOu;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_SourceOu(BSTR* pbstrOu)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrOu = m_bstrSourceOu.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// TargetDomain Property

STDMETHODIMP CMigration::put_TargetDomain(BSTR bstrDomain)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrTargetDomain = bstrDomain;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_TargetDomain(BSTR* pbstrDomain)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrDomain = m_bstrTargetDomain.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// TargetOu Property

STDMETHODIMP CMigration::put_TargetOu(BSTR bstrOu)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrTargetOu = bstrOu;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_TargetOu(BSTR* pbstrOu)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrOu = m_bstrTargetOu.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// RenameOption Property

STDMETHODIMP CMigration::put_RenameOption(long lOption)
{
	HRESULT hr = S_OK;

	if ((lOption >= admtDoNotRename) && (lOption <= admtRenameWithSuffix))
	{
		m_lRenameOption = lOption;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_INVALIDARG, IDS_E_RENAME_OPTION_INVALID);
	}

	return hr;
}

STDMETHODIMP CMigration::get_RenameOption(long* plOption)
{
	*plOption = m_lRenameOption;

	return S_OK;
}


// RenamePrefixOrSuffix Property

STDMETHODIMP CMigration::put_RenamePrefixOrSuffix(BSTR bstrPrefixOrSuffix)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrRenamePrefixOrSuffix = bstrPrefixOrSuffix;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_RenamePrefixOrSuffix(BSTR* pbstrPrefixOrSuffix)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrPrefixOrSuffix = m_bstrRenamePrefixOrSuffix.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// PasswordOption Property

STDMETHODIMP CMigration::put_PasswordOption(long lOption)
{
	HRESULT hr = S_OK;

	if ((lOption >= admtPasswordFromName) && (lOption <= admtCopyPassword))
	{
		m_lPasswordOption = lOption;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_INVALIDARG, IDS_E_PASSWORD_OPTION_INVALID);
	}

	return hr;
}

STDMETHODIMP CMigration::get_PasswordOption(long* plOption)
{
	*plOption = m_lPasswordOption;

	return S_OK;
}


// PasswordServer Property

STDMETHODIMP CMigration::put_PasswordServer(BSTR bstrServer)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrPasswordServer = bstrServer;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_PasswordServer(BSTR* pbstrServer)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrServer = m_bstrPasswordServer.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// GetValidDcName Method
//
// Retrieves name of domain controller in the given domain.

_bstr_t CMigration::GetValidDcName(_bstr_t strDcName)
{
	_bstr_t strName;

	PDOMAIN_CONTROLLER_INFO pdci;

	// attempt to retrieve DNS name of domain controller

	// Note: requires NT 4.0 SP6a

	DWORD dwError = DsGetDcName(strDcName, NULL, NULL, NULL, DS_RETURN_DNS_NAME, &pdci);

	// if domain controller not found, attempt to retrieve flat name of domain controller

	if (dwError == ERROR_NO_SUCH_DOMAIN)
	{
		dwError = DsGetDcName(strDcName, NULL, NULL, NULL, DS_RETURN_FLAT_NAME, &pdci);
	}

	// if domain controller found then save name otherwise generate error

	if (dwError == NO_ERROR)
	{
		// remove double backslash prefix to remain consistent with wizard

		strName = pdci->DomainControllerName + 2;

		NetApiBufferFree(pdci);
	}
	else
	{
		_com_issue_error(HRESULT_FROM_WIN32(dwError));
	}

	return strName;
}


// PasswordFile Property

STDMETHODIMP CMigration::put_PasswordFile(BSTR bstrPath)
{
    HRESULT hr = S_OK;

    try
    {
        _bstr_t strFile = bstrPath;

        if (strFile.length() > 0)
        {
            _TCHAR szPath[_MAX_PATH];
            LPTSTR pszFilePart;

            DWORD cchPath = GetFullPathName(strFile, _MAX_PATH, szPath, &pszFilePart);

            if ((cchPath == 0) || (cchPath >= _MAX_PATH))
            {
                //
                // If GetFullPathName returns 0 then extended error may be found by
                // calling GetLastError. If cchPath is greater than or equal to the
                // maximum supported path length set error equal to 'The file name
                // is too long' (ERROR_BUFFER_OVERFLOW). If GetLastError returns
                // ERROR_SUCCESS then set the error to 'The specified path is
                // invalid' (ERROR_BAD_PATHNAME).
                //

                DWORD dwError = (cchPath == 0) ? GetLastError() : ERROR_BUFFER_OVERFLOW;

                if (dwError == ERROR_SUCCESS)
                {
                    dwError = ERROR_BAD_PATHNAME;
                }

                AdmtThrowError(
                    GUID_NULL,
                    GUID_NULL,
                    HRESULT_FROM_WIN32(dwError),
                    IDS_E_PASSWORD_FILE,
                    (LPCTSTR)strFile
                );
            }

            HANDLE hFile = CreateFile(
                szPath,
                GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );

            if (hFile == INVALID_HANDLE_VALUE)
            {
                AdmtThrowError(
                    GUID_NULL,
                    GUID_NULL,
                    HRESULT_FROM_WIN32(GetLastError()), 
                    IDS_E_PASSWORD_FILE,
                    (LPCTSTR)strFile
                );
            }

            CloseHandle(hFile);

            m_bstrPasswordFile = szPath;
        }
        else
        {
            m_bstrPasswordFile = strFile;
        }
    }
    catch (_com_error& ce)
    {
        hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
    }
    catch (...)
    {
        hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
    }

    return hr;
}

STDMETHODIMP CMigration::get_PasswordFile(BSTR* pbstrPath)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrPath = m_bstrPasswordFile.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// ConflictOptions Property

STDMETHODIMP CMigration::put_ConflictOptions(long lOptions)
{
	HRESULT hr = S_OK;

	long lOption = lOptions & 0x0F;
	long lFlags = lOptions & 0xF0;

	if ((lOption >= admtIgnoreConflicting) && (lOption <= admtRenameConflictingWithSuffix))
	{
		if ((lOption == admtReplaceConflicting) || (lFlags == 0))
		{
			m_lConflictOptions = lOptions;
		}
		else
		{
			hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_INVALIDARG, IDS_E_CONFLICT_FLAGS_NOT_ALLOWED);
		}
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_INVALIDARG, IDS_E_CONFLICT_OPTION_INVALID);
	}

	return hr;
}

STDMETHODIMP CMigration::get_ConflictOptions(long* plOptions)
{
	*plOptions = m_lConflictOptions;

	return S_OK;
}


// ConflictPrefixOrSuffix Property

STDMETHODIMP CMigration::put_ConflictPrefixOrSuffix(BSTR bstrPrefixOrSuffix)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrConflictPrefixOrSuffix = bstrPrefixOrSuffix;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_ConflictPrefixOrSuffix(BSTR* pbstrPrefixOrSuffix)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrPrefixOrSuffix = m_bstrConflictPrefixOrSuffix.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// UserPropertiesToExclude Property

STDMETHODIMP CMigration::put_UserPropertiesToExclude(BSTR bstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrUserPropertiesToExclude = GetParsedExcludeProperties(bstrProperties);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_UserPropertiesToExclude(BSTR* pbstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrProperties = m_bstrUserPropertiesToExclude.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// InetOrgPersonPropertiesToExclude Property

STDMETHODIMP CMigration::put_InetOrgPersonPropertiesToExclude(BSTR bstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrInetOrgPersonPropertiesToExclude = GetParsedExcludeProperties(bstrProperties);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_InetOrgPersonPropertiesToExclude(BSTR* pbstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrProperties = m_bstrInetOrgPersonPropertiesToExclude.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// GroupPropertiesToExclude Property

STDMETHODIMP CMigration::put_GroupPropertiesToExclude(BSTR bstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrGroupPropertiesToExclude = GetParsedExcludeProperties(bstrProperties);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_GroupPropertiesToExclude(BSTR* pbstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrProperties = m_bstrGroupPropertiesToExclude.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// ComputerPropertiesToExclude Property

STDMETHODIMP CMigration::put_ComputerPropertiesToExclude(BSTR bstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrComputerPropertiesToExclude = GetParsedExcludeProperties(bstrProperties);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_ComputerPropertiesToExclude(BSTR* pbstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrProperties = m_bstrComputerPropertiesToExclude.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// SystemPropertiesToExclude Property

STDMETHODIMP CMigration::put_SystemPropertiesToExclude(BSTR bstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		IIManageDBPtr spIManageDB(__uuidof(IManageDB));

        IVarSetPtr spVarSet(__uuidof(VarSet));

        IUnknownPtr spUnknown(spVarSet);
        IUnknown* punk = spUnknown;

        spIManageDB->GetSettings(&punk);

        spVarSet->put(
            GET_BSTR(DCTVS_AccountOptions_ExcludedSystemProps),
            _variant_t(GetParsedExcludeProperties(bstrProperties))
        );

        spIManageDB->SaveSettings(punk);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_SystemPropertiesToExclude(BSTR* pbstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		IIManageDBPtr spIManageDB(__uuidof(IManageDB));

        IVarSetPtr spVarSet(__uuidof(VarSet));

        IUnknownPtr spUnknown(spVarSet);
        IUnknown* punk = spUnknown;

        spIManageDB->GetSettings(&punk);

        _bstr_t str = spVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedSystemProps));

		*pbstrProperties = str.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// CreateUserMigration Method

STDMETHODIMP CMigration::CreateUserMigration(IUserMigration** pitfUserMigration)
{
	HRESULT hr = S_OK;

	try
	{
		CComObject<CUserMigration>* pUserMigration;
		CheckError(CComObject<CUserMigration>::CreateInstance(&pUserMigration));
		CheckError(pUserMigration->QueryInterface(__uuidof(IUserMigration), (void**)pitfUserMigration));
		pUserMigration->SetInternalInterface(this);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce, IDS_E_CREATE_USER_MIGRATION);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL, IDS_E_CREATE_USER_MIGRATION);
	}

	return hr;
}


// CreateGroupMigration Method

STDMETHODIMP CMigration::CreateGroupMigration(IGroupMigration** pitfGroupMigration)
{
	HRESULT hr = S_OK;

	try
	{
		CComObject<CGroupMigration>* pGroupMigration;
		CheckError(CComObject<CGroupMigration>::CreateInstance(&pGroupMigration));
		CheckError(pGroupMigration->QueryInterface(__uuidof(IGroupMigration), (void**)pitfGroupMigration));
		pGroupMigration->SetInternalInterface(this);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce, IDS_E_CREATE_GROUP_MIGRATION);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL, IDS_E_CREATE_GROUP_MIGRATION);
	}

	return hr;
}


// CreateComputerMigration Method

STDMETHODIMP CMigration::CreateComputerMigration(IComputerMigration** pitfComputerMigration)
{
	HRESULT hr = S_OK;

	try
	{
		CComObject<CComputerMigration>* pComputerMigration;
		CheckError(CComObject<CComputerMigration>::CreateInstance(&pComputerMigration));
		CheckError(pComputerMigration->QueryInterface(__uuidof(IComputerMigration), (void**)pitfComputerMigration));
		pComputerMigration->SetInternalInterface(this);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce, IDS_E_CREATE_COMPUTER_MIGRATION);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL, IDS_E_CREATE_COMPUTER_MIGRATION);
	}

	return hr;
}


// CreateSecurityTranslation Method

STDMETHODIMP CMigration::CreateSecurityTranslation(ISecurityTranslation** pitfSecurityTranslation)
{
	HRESULT hr = S_OK;

	try
	{
		CComObject<CSecurityTranslation>* pSecurityTranslation;
		CheckError(CComObject<CSecurityTranslation>::CreateInstance(&pSecurityTranslation));
		CheckError(pSecurityTranslation->QueryInterface(__uuidof(ISecurityTranslation), (void**)pitfSecurityTranslation));
		pSecurityTranslation->SetInternalInterface(this);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce, IDS_E_CREATE_SECURITY_TRANSLATION);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL, IDS_E_CREATE_SECURITY_TRANSLATION);
	}

	return hr;
}


// CreateServiceAccountEnumeration Method

STDMETHODIMP CMigration::CreateServiceAccountEnumeration(IServiceAccountEnumeration** pitfServiceAccountEnumeration)
{
	HRESULT hr = S_OK;

	try
	{
		CComObject<CServiceAccountEnumeration>* pServiceAccountEnumeration;
		CheckError(CComObject<CServiceAccountEnumeration>::CreateInstance(&pServiceAccountEnumeration));
		CheckError(pServiceAccountEnumeration->QueryInterface(__uuidof(IServiceAccountEnumeration), (void**)pitfServiceAccountEnumeration));
		pServiceAccountEnumeration->SetInternalInterface(this);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce, IDS_E_CREATE_SERVICE_ACCOUNT_ENUMERATION);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL, IDS_E_CREATE_SERVICE_ACCOUNT_ENUMERATION);
	}

	return hr;
}


// CreateReportGeneration Method

STDMETHODIMP CMigration::CreateReportGeneration(IReportGeneration** pitfReportGeneration)
{
	HRESULT hr = S_OK;

	try
	{
		CComObject<CReportGeneration>* pReportGeneration;
		CheckError(CComObject<CReportGeneration>::CreateInstance(&pReportGeneration));
		CheckError(pReportGeneration->QueryInterface(__uuidof(IReportGeneration), (void**)pitfReportGeneration));
		pReportGeneration->SetInternalInterface(this);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce, IDS_E_CREATE_REPORT_GENERATION);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL, IDS_E_CREATE_REPORT_GENERATION);
	}

	return hr;
}


// UpdateDatabase

void CMigration::UpdateDatabase()
{
	try
	{
		// verify and create if necessary a source domain
		// sid column in the migrated objects table

		ISrcSidUpdatePtr spSrcSidUpdate(__uuidof(SrcSidUpdate));

		if (spSrcSidUpdate->QueryForSrcSidColumn() == VARIANT_FALSE)
		{
			spSrcSidUpdate->CreateSrcSidColumn(VARIANT_TRUE);
		}

		// verify and create if necessary an account
		// sid column in the account references table

		IIManageDBPtr spIManageDB(__uuidof(IManageDB));

		if (spIManageDB->SidColumnInARTable() == VARIANT_FALSE)
		{
			spIManageDB->CreateSidColumnInAR();
		}
	}
	catch (_com_error& ce)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, ce, IDS_E_UNABLE_TO_UPDATE_DATABASE);
	}
	catch (...)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, E_FAIL, IDS_E_UNABLE_TO_UPDATE_DATABASE);
	}
}


//---------------------------------------------------------------------------
// GetParsedExcludeProperties Method
//
// Trims whitespace from comma delimited properties.
//
// 2001-02-06 Mark Oluper - initial
//---------------------------------------------------------------------------

_bstr_t CMigration::GetParsedExcludeProperties(LPCTSTR pszOld)
{
	tstring strNew;

	if (pszOld)
	{
		bool bInProperty = false;

		// for each character in input string

		for (LPCTSTR pch = pszOld; *pch; pch++)
		{
			// if not whitespace or comma

			if (!(_istspace(*pch) || (*pch == _T(','))))
			{
				// if not 'in property'

				if (!bInProperty)
				{
					// set 'in property'

					bInProperty = true;

					// if not first property add comma delimiter

					if (!strNew.empty())
					{
						strNew += _T(',');
					}
				}

				// add character to property

				strNew += *pch;
			}
			else
			{
				// if 'in property' reset

				if (bInProperty)
				{
					bInProperty = false;
				}
			}
		}
	}

	return strNew.c_str();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\namecracker.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "NameCracker.h"
#include <LM.h>
#include <NtDsApi.h>
#pragma comment(lib, "NtDsApi.lib")
#include <DsGetDC.h>
#include "Error.h"
#include "AdsiHelpers.h"


using namespace NAMECRACKER;

namespace NAMECRACKER
{

const _TCHAR CANONICAL_DELIMITER = _T('/');
const _TCHAR RDN_DELIMITER = _T('=');
const _TCHAR SAM_DELIMITER = _T('\\');
const _TCHAR SAM_INVALID_CHARACTERS[] = _T("\"*+,./:;<=>?[\\]|");
const _TCHAR EXCLUDE_SAM_INVALID_CHARACTERS[] = _T("\"+,./:;<=>?[\\]|");

}


//---------------------------------------------------------------------------
// Name Cracker Class
//---------------------------------------------------------------------------


CNameCracker::CNameCracker()
{
}


CNameCracker::~CNameCracker()
{
}


void CNameCracker::CrackNames(const StringVector& vecNames)
{
	// separate the names into canonical names,
	// SAM account names and relative distinguished names

	StringVector vecCanonicalNames;
	StringVector vecSamAccountNames;
	StringVector vecRelativeDistinguishedNames;

	Separate(vecNames, vecCanonicalNames, vecSamAccountNames, vecRelativeDistinguishedNames);

	// then crack canonical names

	CrackCanonicalNames(vecCanonicalNames, vecRelativeDistinguishedNames);

	// then crack relative distinguished names

	CrackRelativeDistinguishedNames(vecRelativeDistinguishedNames, vecSamAccountNames);

	// then crack SAM account names

	CrackSamAccountNames(vecSamAccountNames, m_vecUnResolvedNames);
}


void CNameCracker::SiftExcludeNames(const StringSet& setExcludeNames, const StringSet& setNamingAttributes, StringSet& setExcludeRDNs, StringSet& setExcludeSamAccountNames) const
{
    //
    // For each specified exclude name pattern.
    //

    for (StringSet::const_iterator it = setExcludeNames.begin(); it != setExcludeNames.end(); it++)
    {
        const _bstr_t& strPattern = *it;

        PCTSTR pszPattern = strPattern;

        if (pszPattern)
        {
            //
            // If the exclude pattern contains an RDN delimiter character
            // then assume RDN exclude pattern otherwise assume sAMAccountName
            // exclude pattern.
            //

            tstring str = pszPattern;

            UINT uDelimiter = str.find_first_of(RDN_DELIMITER);

            if (uDelimiter == 0)
            {
                //
                // The RDN delimiter character must follow a valid naming attribute
                // therefore if the delimiter occurs at the beginning of the pattern
                // then an error must be generated.
                //

		        AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, pszPattern);
            }
            else if (uDelimiter != tstring::npos)
            {
                //
                // Verify exclude pattern contains a valid naming attribute. The naming attribute
                // must match the naming attribute(s) for the class(es) of objects being migrated.
                //

                tstring strNamingAttribute = str.substr(0, uDelimiter);

                bool bValidNamingAttribute = false;
                StringSet::const_iterator itNA;

                for (itNA = setNamingAttributes.begin(); itNA != setNamingAttributes.end(); itNA++)
                {
                    if (_tcsicmp(strNamingAttribute.c_str(), *itNA) == 0)
                    {
                        bValidNamingAttribute = true;
                        break;
                    }
                }

                if (bValidNamingAttribute == false)
                {
		            AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, pszPattern);
                }

                setExcludeRDNs.insert(strPattern);
            }
            else
            {
                setExcludeSamAccountNames.insert(strPattern);
            }
        }
    }
}


void CNameCracker::Separate(
	const StringVector& vecNames,
	StringVector& vecCanonicalNames,
	StringVector& vecSamAccountNames,
	StringVector& vecRelativeDistinguishedNames
)
{
	// for each name in vector...

	for (StringVector::const_iterator it = vecNames.begin(); it != vecNames.end(); it++)
	{
		const tstring& strName = *it;

		// if non empty name...

		if (strName.empty() == false)
		{
			LPCTSTR pszName = strName.c_str();

			// then if name contains a solidus '/' character assume canonical name
            // else if name contains a ? '=' character assume relative distinguished name
            // else assume SAM account name

			if (_tcschr(pszName, CANONICAL_DELIMITER))
			{
				// assuming canonical name
				vecCanonicalNames.push_back(strName);
			}
			else if (_tcschr(pszName, RDN_DELIMITER))
			{
				// assuming relative distinguished name
				vecRelativeDistinguishedNames.push_back(strName);
			}
			else
			{
				// assuming SAM account name
				vecSamAccountNames.push_back(strName);
			}
		}
	}
}


void CNameCracker::CrackCanonicalNames(const StringVector& vecCanonicalNames, StringVector& vecUnResolvedNames)
{
	//
	// for each name generate a complete canonical name
	//

	CNameVector vecNames;
	tstring strCanonical;

	for (StringVector::const_iterator it = vecCanonicalNames.begin(); it != vecCanonicalNames.end(); it++)
	{
		const tstring& strName = *it;

		// if first character is the solidus '/' character...

		if (strName[0] == CANONICAL_DELIMITER)
		{
			// then generate complete canonical name
			strCanonical = m_strDnsName + strName;
		}
		else
		{
			// otherwise if already complete canonical name for this domain...

			if (_tcsnicmp(m_strDnsName.c_str(), strName.c_str(), m_strDnsName.length()) == 0)
			{
				// then add complete canonical name
				strCanonical = strName;
			}
			else
			{
				// otherwise prefix DNS domain name with solidus and add
				strCanonical = m_strDnsName + CANONICAL_DELIMITER + strName;
			}
		}

		vecNames.push_back(SName(strName.c_str(), strCanonical.c_str()));
	}

	//
	// crack canonical names
	//

	CrackNames(CANONICAL_NAME, vecNames);

	for (size_t i = 0; i < vecNames.size(); i++)
	{
		const SName& name = vecNames[i];

		if (name.strResolved.empty() == false)
		{
			m_setResolvedNames.insert(name.strResolved);
		}
		else
		{
			vecUnResolvedNames.push_back(name.strPartial);
		}
	}
}


void CNameCracker::CrackSamAccountNames(const StringVector& vecSamAccountNames, StringVector& vecUnResolvedNames)
{
	//
	// for each name generate a NT4 account name
	//

	CNameVector vecNames;
	tstring strNT4Account;

	for (StringVector::const_iterator it = vecSamAccountNames.begin(); it != vecSamAccountNames.end(); it++)
	{
		const tstring& strName = *it;

		// if first character is the reverse solidus '\' character...

		if (strName[0] == SAM_DELIMITER)
		{
			// then generate downlevel name
			strNT4Account = m_strFlatName + strName;
		}
		else
		{
			// otherwise if already downlevel name for this domain...

			if (_tcsnicmp(m_strFlatName.c_str(), strName.c_str(), m_strFlatName.length()) == 0)
			{
				// then add downlevel name
				strNT4Account = strName;
			}
			else
			{
				// otherwise prefix flat domain name with reverse solidus and add
				strNT4Account = m_strFlatName + SAM_DELIMITER + strName;
			}
		}

		vecNames.push_back(SName(strName.c_str(), strNT4Account.c_str()));
	}

	//
	// crack names
	//

	CrackNames(NT4_ACCOUNT_NAME, vecNames);

	for (size_t i = 0; i < vecNames.size(); i++)
	{
		const SName& name = vecNames[i];

		if (name.strResolved.empty() == false)
		{
			m_setResolvedNames.insert(name.strResolved);
		}
		else
		{
			vecUnResolvedNames.push_back(name.strPartial);
		}
	}
}


void CNameCracker::CrackRelativeDistinguishedNames(const StringVector& vecRelativeDistinguishedNames, StringVector& vecUnResolvedNames)
{
	CADsContainer adscContainer(m_spDefaultContainer);

	CADsPathName adspnPath(adscContainer.GetADsPath());

	for (StringVector::const_iterator it = vecRelativeDistinguishedNames.begin(); it != vecRelativeDistinguishedNames.end(); it++)
	{
		adspnPath.AddLeafElement(it->c_str());

		bool bFound = false;

		try
		{
			CADs adsObject((LPCTSTR)adspnPath.Retrieve(ADS_FORMAT_X500));

			m_setResolvedNames.insert(tstring(_bstr_t(adsObject.Get(ATTRIBUTE_DISTINGUISHED_NAME))));

			bFound = true;
		}
		catch (_com_error& ce)
		{
		#ifdef _DEBUG
			_TCHAR sz[2048];
			_stprintf(sz, _T("'%s' : %s : 0x%08lX\n"), it->c_str(), ce.ErrorMessage(), ce.Error());
			OutputDebugString(sz);
		#endif
			bFound = false;
		}
		catch (...)
		{
			bFound = false;
		}

		if (!bFound)
		{
			vecUnResolvedNames.push_back(*it);
		}

		adspnPath.RemoveLeafElement();
	}
}


void CNameCracker::CrackNames(NAME_FORMAT eFormat, CNameVector& vecNames)
{
	HANDLE hDs = NULL;
	LPTSTR apszNames = NULL;
	PDS_NAME_RESULT pdnrResult = NULL;

	try
	{
		if (vecNames.size() > 0)
		{
			DWORD dwError = DsBind(m_strDomainController.c_str(), NULL, &hDs);

			if (dwError == NO_ERROR)
			{
				DWORD dwCount = vecNames.size();
				LPCTSTR* apszNames = new LPCTSTR[dwCount];

				if (apszNames != NULL)
				{
					for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++)
					{
						apszNames[dwIndex] = vecNames[dwIndex].strComplete.c_str();
					}

					dwError = DsCrackNames(
						hDs,
						DS_NAME_NO_FLAGS,
						(eFormat == CANONICAL_NAME) ? DS_CANONICAL_NAME : (eFormat == NT4_ACCOUNT_NAME) ? DS_NT4_ACCOUNT_NAME : DS_UNKNOWN_NAME,
						DS_FQDN_1779_NAME,
						dwCount,
						const_cast<LPTSTR*>(apszNames),
						&pdnrResult
					);

					if (dwError == NO_ERROR)
					{
						DWORD c = pdnrResult->cItems;

						for (DWORD i = 0; i < c; i++)
						{
							DS_NAME_RESULT_ITEM& dnriItem = pdnrResult->rItems[i];

							if (dnriItem.status == DS_NAME_NO_ERROR)
							{
								vecNames[i].strResolved = dnriItem.pName;
							}
						}

						DsFreeNameResult(pdnrResult);
					}
					else
					{
						_com_issue_error(HRESULT_FROM_WIN32(dwError));
					}

					delete [] apszNames;
				}
				else
				{
					_com_issue_error(E_OUTOFMEMORY);
				}

				DsUnBind(&hDs);
			}
			else
			{
				_com_issue_error(HRESULT_FROM_WIN32(dwError));
			}
		}
	}
	catch (...)
	{
		if (pdnrResult)
		{
			DsFreeNameResult(pdnrResult);
		}

		delete [] apszNames;

		if (hDs)
		{
			DsUnBind(&hDs);
		}

		throw;
	}
}


namespace
{

// SplitCanonicalName Method
//
// Given 'a.company.com/Sales/West/Name' this method splits the complete
// canonical name into its component parts Domain='a.company.com',
// Path='/Sales/West/', Name='Name'.
//
// Given 'Sales/West/Name' this method splits the partial canonical name
// into its component parts Domain='', Path='/Sales/West/', Name='Name'.
//
// Given 'Name' this method splits the partial canonical name into its
// component parts Domain='', Path='/', Name='Name'.

void SplitCanonicalName(LPCTSTR pszName, _bstr_t& strDomain, _bstr_t& strPath, _bstr_t& strName)
{
	strDomain = (LPCTSTR)NULL;
	strPath = (LPCTSTR)NULL;
	strName = (LPCTSTR)NULL;

	if (pszName)
	{
		tstring str = pszName;

		UINT posA = 0;
		UINT posB = tstring::npos;

		do
		{
			posA = str.find_first_of(_T('/'), posA ? posA + 1 : posA);
		}
		while ((posA != 0) && (posA != tstring::npos) && (str[posA - 1] == _T('\\')));

		do
		{
			posB = str.find_last_of(_T('/'), (posB != tstring::npos) ? posB - 1 : posB);
		}
		while ((posB != 0) && (posB != tstring::npos) && (str[posB - 1] == _T('\\')));

		strDomain = str.substr(0, posA).c_str();
		strPath = str.substr(posA, posB - posA).c_str();
		strName = str.substr(posB).c_str();
	}
}

void SplitPath(LPCTSTR pszPath, _bstr_t& strPath, _bstr_t& strName)
{
	strPath = (LPCTSTR)NULL;
	strName = (LPCTSTR)NULL;

	if (pszPath)
	{
		tstring str = pszPath;

		UINT pos = str.find_first_of(_T('\\'));

		if (pos != tstring::npos)
		{
			strName = pszPath;
		}
		else
		{
			UINT posA = str.find_first_of(_T('/'));

			if (posA == tstring::npos)
			{
				strName = (_T("/") + str).c_str();
			}
			else
			{
				UINT posB = str.find_last_of(_T('/'));

				strPath = str.substr(posA, posB - posA).c_str();
				strName = str.substr(posB).c_str();
			}
		}
	}
}

}


//---------------------------------------------------------------------------
// Ignore Case String Less
//---------------------------------------------------------------------------

struct SIgnoreCaseStringLess :
	public std::binary_function<tstring, tstring, bool>
{
	bool operator()(const tstring& x, const tstring& y) const
	{
		bool bLess;

		LPCTSTR pszX = x.c_str();
		LPCTSTR pszY = y.c_str();

		if (pszX == pszY)
		{
			bLess = false;
		}
		else if (pszX == NULL)
		{
			bLess = true;
		}
		else if (pszY == NULL)
		{
			bLess = false;
		}
		else
		{
			bLess = _tcsicmp(pszX, pszY) < 0;
		}

		return bLess;
	}
};


//---------------------------------------------------------------------------
// CDomainMap Implementation
//---------------------------------------------------------------------------


class CDomainMap :
	public std::map<_bstr_t, StringSet, IgnoreCaseStringLess>
{
public:

	CDomainMap()
	{
	}

	void Initialize(const StringSet& setNames)
	{
		_bstr_t strDefaultDns(_T("/"));
		_bstr_t strDefaultFlat(_T("\\"));

		for (StringSet::const_iterator it = setNames.begin(); it != setNames.end(); it++)
		{
			tstring strName = *it;

			// if not an empty name...

			if (strName.empty() == false)
			{
				// if name contains a canonical name delimiter...

				UINT posDelimiter = strName.find(CANONICAL_DELIMITER);

				if (posDelimiter != tstring::npos)
				{
					// then assume canonical name

					if (posDelimiter == 0)
					{
						// then generate complete canonical name
						Insert(strDefaultDns, *it);
					}
					else
					{
						// otherwise if path component before delimiter contains
						// a period

						UINT posDot = strName.find(_T('.'));

						if (posDot < posDelimiter)
						{
							// then assume a complete canonical name with DNS domain name prefix
							Insert(strName.substr(0, posDelimiter).c_str(), *it);
						}
						else
						{
							// otherwise assume domain name has not been specified
							Insert(strDefaultDns, *it);
						}
					}
				}
				else
				{
					// otherwise if name contains a NT account name delimiter
					// character and no invalid SAM account name characters...

					UINT posDelimiter = strName.find(SAM_DELIMITER);

					if (posDelimiter != tstring::npos)
					{
						if (strName.find_first_of(SAM_INVALID_CHARACTERS, posDelimiter + 1) == tstring::npos)
						{
							if (posDelimiter == 0)
							{
								Insert(strDefaultFlat, *it);
							}
							else
							{
								// then assume SAM account name
								Insert(strName.substr(0, posDelimiter).c_str(), strName.substr(posDelimiter).c_str());
							}
						}
						else
						{
							// otherwise assume relative distinguished name
							Insert(strDefaultDns, *it);
						}
					}
					else
					{
						Insert(strDefaultDns, *it);
					}
				}
			}
		}
	}

protected:

	void Insert(_bstr_t strDomain, _bstr_t strName)
	{
		iterator it = find(strDomain);

		if (it == end())
		{
			std::pair<iterator, bool> pair = insert(value_type(strDomain, StringSet()));
			it = pair.first;
		}

		it->second.insert(strName);
	}
};


//---------------------------------------------------------------------------
// CDomainToPathMap Implementation
//---------------------------------------------------------------------------


// Initialize Method

void CDomainToPathMap::Initialize(LPCTSTR pszDefaultDomainDns, LPCTSTR pszDefaultDomainFlat, const StringSet& setNames)
{
	CDomainMap map;

	map.Initialize(setNames);

	for (CDomainMap::const_iterator itDomain = map.begin(); itDomain != map.end(); itDomain++)
	{
		_bstr_t strDomainName = itDomain->first;

		LPCTSTR pszDomainName = strDomainName;

		if (pszDomainName && ((*pszDomainName == _T('/')) || (*pszDomainName == _T('\\'))))
		{
			strDomainName = (pszDefaultDomainDns && (_tcslen(pszDefaultDomainDns) > 0)) ? pszDefaultDomainDns : pszDefaultDomainFlat;
		}
		else
		{
			if (GetValidDomainName(strDomainName) == false)
			{
				strDomainName = (pszDefaultDomainDns && (_tcslen(pszDefaultDomainDns) > 0)) ? pszDefaultDomainDns : pszDefaultDomainFlat;
			}
		}

		iterator it = find(strDomainName);

		if (it == end())
		{
			std::pair<iterator, bool> pair = insert(value_type(strDomainName, StringSet()));
			it = pair.first;
		}

		StringSet& setNames = it->second;

		const StringSet& set = itDomain->second;

		for (StringSet::const_iterator itSet = set.begin(); itSet != set.end(); itSet++)
		{
			setNames.insert(*itSet);
		}
	}
}


// GetValidDomainName Method

bool CDomainToPathMap::GetValidDomainName(_bstr_t& strDomainName)
{
	bool bValid = false;

	PDOMAIN_CONTROLLER_INFO pdci;

	// attempt to retrieve DNS name of domain controller supporting active directory service

	DWORD dwError = DsGetDcName(NULL, strDomainName, NULL, NULL, DS_RETURN_DNS_NAME, &pdci);

	// if domain controller not found, attempt to retrieve flat name of domain controller

	if (dwError == ERROR_NO_SUCH_DOMAIN)
	{
		dwError = DsGetDcName(NULL, strDomainName, NULL, NULL, DS_RETURN_FLAT_NAME, &pdci);
	}

	// if domain controller found then save name otherwise generate error

	if (dwError == NO_ERROR)
	{
		strDomainName = pdci->DomainName;

		NetApiBufferFree(pdci);

		bValid = true;
	}

	return bValid;
}


//
// CNameToPathMap Implementation
//


CNameToPathMap::CNameToPathMap()
{
}

CNameToPathMap::CNameToPathMap(StringSet& setNames)
{
	Initialize(setNames);
}

void CNameToPathMap::Initialize(StringSet& setNames)
{
	_bstr_t strDomain;
	_bstr_t strPath;
	_bstr_t strName;

	for (StringSet::iterator it = setNames.begin(); it != setNames.end(); it++)
	{
	//	SplitPath(*it, strPath, strName);
		SplitCanonicalName(*it, strDomain, strPath, strName);

		Add(strName, strPath);
	}
}

void CNameToPathMap::Add(_bstr_t& strName, _bstr_t& strPath)
{
	iterator it = find(strName);

	if (it == end())
	{
		std::pair<iterator, bool> pair = insert(value_type(strName, StringSet()));

		it = pair.first;
	}

	it->second.insert(strPath);
}


//
// IgnoreCaseStringLess Implementation
//


bool IgnoreCaseStringLess::operator()(const _bstr_t& x, const _bstr_t& y) const
{
	bool bLess;

	LPCTSTR pszThis = x;
	LPCTSTR pszThat = y;

	if (pszThis == pszThat)
	{
		bLess = false;
	}
	else if (pszThis == NULL)
	{
		bLess = true;
	}
	else if (pszThat == NULL)
	{
		bLess = false;
	}
	else
	{
		bLess = _tcsicmp(pszThis, pszThat) < 0;
	}

	return bLess;
}


//
// CCompareStrings Implementation
//


CCompareStrings::CCompareStrings()
{
}

CCompareStrings::CCompareStrings(StringSet& setNames)
{
	Initialize(setNames);
}

void CCompareStrings::Initialize(StringSet& setNames)
{
	for (StringSet::iterator it = setNames.begin(); it != setNames.end(); it++)
	{
		m_vecCompareStrings.push_back(CCompareString(*it));
	}
}

bool CCompareStrings::IsMatch(LPCTSTR pszName)
{
	bool bIs = false;

	CompareStringVector::iterator itBeg = m_vecCompareStrings.begin();
	CompareStringVector::iterator itEnd = m_vecCompareStrings.end();

	for (CompareStringVector::iterator it = itBeg; it != itEnd; it++)
	{
		if (it->IsMatch(pszName))
		{
			bIs = true;

			break;
		}
	}

	return bIs;
}


//
// CCompareString Implementation
//


CCompareStrings::CCompareString::CCompareString(LPCTSTR pszCompare)
{
	if (pszCompare)
	{
		Initialize(pszCompare);
	}
}

CCompareStrings::CCompareString::CCompareString(const CCompareString& r) :
	m_nType(r.m_nType),
	m_strCompare(r.m_strCompare)
{
}

void CCompareStrings::CCompareString::Initialize(LPCTSTR pszCompare)
{
	if (pszCompare)
	{
		tstring str = pszCompare;

		UINT uLength = str.length();

        if (uLength == 0)
        {
		    AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, pszCompare);
        }

		bool bBeg = (str[0] == _T('*'));
        bool bEnd = ((uLength > 1) && (str[uLength - 1] == _T('*'))) ? true : false;

		if (bBeg && bEnd)
		{
			// contains
			m_nType = 3;
			str = str.substr(1, uLength - 2);
		}
		else if (bBeg)
		{
			// ends with
			m_nType = 2;
			str = str.substr(1, uLength - 1);
		}
		else if (bEnd)
		{
			// begins with
			m_nType = 1;
			str = str.substr(0, uLength - 1);
		}
		else
		{
			// equals
			m_nType = 0;
		}

		if (str.length() > 0)
		{
            m_strCompare = str.c_str();
		}
		else
		{
			AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, pszCompare);
		}
	}
	else
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, _T(""));
	}
}

bool CCompareStrings::CCompareString::IsMatch(LPCTSTR psz)
{
    bool bIs = false;

    if (psz)
    {
        switch (m_nType)
        {
        case 0: // equals
            {
                bIs = (_tcsicmp(psz, m_strCompare) == 0);
                break;
            }
        case 1: // begins with
            {
                bIs = (_tcsnicmp(psz, m_strCompare, m_strCompare.length()) == 0);
                break;
            }
        case 2: // ends with
            {
                UINT cchT = _tcslen(psz);
                UINT cchC = m_strCompare.length();

                if (cchT >= cchC)
                {
                    bIs = (_tcsnicmp(psz + cchT - cchC, m_strCompare, cchC) == 0);
                }
                break;
            }
        case 3: // contains
            {
                PTSTR pszT = NULL;
                PTSTR pszC = NULL;

                try
                {
                    pszT = new _TCHAR[_tcslen(psz) + 1];
                    pszC = new _TCHAR[m_strCompare.length() + 1];

                    if (pszT && pszC)
                    {
                        _tcscpy(pszT, psz);
                        _tcscpy(pszC, m_strCompare);

                        _tcslwr(pszT);
                        _tcslwr(pszC);

                        bIs = (_tcsstr(pszT, pszC) != NULL);
                    }
                    else
                    {
                        _com_issue_error(E_OUTOFMEMORY);
                    }
                }
                catch (...)
                {
                    delete [] pszC;
                    delete [] pszT;
                    throw;
                }

                delete [] pszC;
                delete [] pszT;
                break;
            }
        }
    }

    return bIs;
}


//
// CCompareRDNs Implementation
//


CCompareRDNs::CCompareRDNs()
{
}

CCompareRDNs::CCompareRDNs(StringSet& setNames)
{
    Initialize(setNames);
}

void CCompareRDNs::Initialize(StringSet& setNames)
{
    for (StringSet::iterator it = setNames.begin(); it != setNames.end(); it++)
    {
        m_vecCompare.push_back(CCompareRDN(*it));
    }
}

bool CCompareRDNs::IsMatch(LPCTSTR pszName)
{
    bool bIs = false;

    CompareVector::iterator itBeg = m_vecCompare.begin();
    CompareVector::iterator itEnd = m_vecCompare.end();

    for (CompareVector::iterator it = itBeg; it != itEnd; it++)
    {
        if (it->IsMatch(pszName))
        {
            bIs = true;

            break;
        }
    }

    return bIs;
}


//
// CCompareRDN Implementation
//


CCompareRDNs::CCompareRDN::CCompareRDN(LPCTSTR pszCompare)
{
    if (pszCompare)
    {
        Initialize(pszCompare);
    }
}

CCompareRDNs::CCompareRDN::CCompareRDN(const CCompareRDN& r) :
    m_nPatternType(r.m_nPatternType),
    m_strType(r.m_strType),
    m_strValue(r.m_strValue)
{
}

void CCompareRDNs::CCompareRDN::Initialize(LPCTSTR pszCompare)
{
    if (pszCompare == NULL)
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, _T(""));
    }

    tstring str = pszCompare;

    UINT uDelimiter = str.find_first_of(_T('='));

    //
    // The pattern must include the RDN delimiter character.
    //

    if ((uDelimiter == 0) || (uDelimiter == tstring::npos))
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, pszCompare);
    }

    //
    // Retrieve the naming attribute portion.
    //

    m_strType = str.substr(0, uDelimiter).c_str();

    //
    // Retrieve the naming attribute value portion.
    //

    tstring strValue = str.substr(uDelimiter + 1);

    UINT uLength = strValue.length();

    if (uLength == 0)
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, pszCompare);
    }

    //
    // Determine pattern type.
    //

    bool bBeg = (strValue[0] == _T('*'));
    bool bEnd = ((uLength > 1) && (strValue[uLength - 1] == _T('*'))) ? true : false;

    if (bBeg && bEnd)
    {
        // contains
        m_nPatternType = 3;
        strValue = strValue.substr(1, uLength - 2);
    }
    else if (bBeg)
    {
        // ends with
        m_nPatternType = 2;
        strValue = strValue.substr(1, uLength - 1);
    }
    else if (bEnd)
    {
        // begins with
        m_nPatternType = 1;
        strValue = strValue.substr(0, uLength - 1);
    }
    else
    {
        // equals
        m_nPatternType = 0;
    }

    if (strValue.length() > 0)
    {
        m_strValue = strValue.c_str();
    }
    else
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, pszCompare);
    }
}

bool CCompareRDNs::CCompareRDN::IsMatch(LPCTSTR psz)
{
    bool bIs = false;

    if (psz)
    {
        PCTSTR pszDelimiter = _tcschr(psz, _T('='));

        if (pszDelimiter)
        {
            if (_tcsnicmp(m_strType, psz, pszDelimiter - psz) == 0)
            {
                PCTSTR pszValue = pszDelimiter + 1;

                switch (m_nPatternType)
                {
                case 0: // equals
                    {
                        bIs = (_tcsicmp(pszValue, m_strValue) == 0);
                        break;
                    }
                case 1: // begins with
                    {
                        bIs = (_tcsnicmp(pszValue, m_strValue, m_strValue.length()) == 0);
                        break;
                    }
                case 2: // ends with
                    {
                        UINT cchT = _tcslen(pszValue);
                        UINT cchC = m_strValue.length();

                        if (cchT >= cchC)
                        {
                            bIs = (_tcsnicmp(pszValue + cchT - cchC, m_strValue, cchC) == 0);
                        }
                        break;
                    }
                case 3: // contains
                    {
                        PTSTR pszT = NULL;
                        PTSTR pszC = NULL;

                        try
                        {
                            pszT = new _TCHAR[_tcslen(pszValue) + 1];
                            pszC = new _TCHAR[m_strValue.length() + 1];

                            if (pszT && pszC)
                            {
                                _tcscpy(pszT, pszValue);
                                _tcscpy(pszC, m_strValue);

                                _tcslwr(pszT);
                                _tcslwr(pszC);

                                bIs = (_tcsstr(pszT, pszC) != NULL);
                            }
                            else
                            {
                                _com_issue_error(E_OUTOFMEMORY);
                            }
                        }
                        catch (...)
                        {
                            delete [] pszC;
                            delete [] pszT;
                            throw;
                        }

                        delete [] pszC;
                        delete [] pszT;
                        break;
                    }
                }
            }
        }
    }

    return bIs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\reportgeneration.h ===
#pragma once

#include "MigrationBase.h"


//---------------------------------------------------------------------------
// ReportGeneration Class
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CReportGeneration :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IReportGeneration, &IID_IReportGeneration, &LIBID_ADMT>,
	public CMigrationBase
{
public:

	CReportGeneration();
	~CReportGeneration();

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CReportGeneration)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IReportGeneration)
	END_COM_MAP()

public:

	// IReport

	STDMETHOD(put_Type)(long lType);
	STDMETHOD(get_Type)(long* plType);
	STDMETHOD(put_Folder)(BSTR bstrFolder);
	STDMETHOD(get_Folder)(BSTR* pbstrFolder);
	STDMETHOD(Generate)(long lOption, VARIANT vntInclude, VARIANT vntExclude);

protected:

	virtual void DoNone();
	virtual void DoNames();
	virtual void DoDomain();

	void DoContainers(CContainer& rSource);
	void DoComputers(CContainer& rSource);
	void DoComputers(CDomainAccounts& rComputers);

	void SetOptions(CVarSet& rVarSet);
	void SetReports(CVarSet& rVarSet);

protected:

	long m_lType;
	_bstr_t m_bstrFolder;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\namecracker.h ===
#pragma once

#include <map>

#ifndef tstring
#include <string>
typedef std::basic_string<_TCHAR> tstring;
#endif
#ifndef StringVector
#include <vector>
typedef std::vector<tstring> StringVector;
#endif
#ifndef CStringSet
#include <set>
typedef std::set<tstring> CStringSet;
#endif
#ifndef IADsContainerPtr
#include <ComDef.h>
#include <ActiveDS.h>
_COM_SMARTPTR_TYPEDEF(IADsContainer, IID_IADsContainer);
#endif
#ifndef StringSet
#include <set>
typedef std::set<_bstr_t> StringSet;
#endif

namespace NAMECRACKER
{

extern const _TCHAR CANONICAL_DELIMITER;
extern const _TCHAR RDN_DELIMITER;
extern const _TCHAR SAM_DELIMITER;
extern const _TCHAR SAM_INVALID_CHARACTERS[];
extern const _TCHAR EXCLUDE_SAM_INVALID_CHARACTERS[];

}

//---------------------------------------------------------------------------
// Name Cracker Class
//---------------------------------------------------------------------------

class CNameCracker
{
public:

	CNameCracker();
	~CNameCracker();

	void SetDomainNames(LPCTSTR pszDnsName, LPCTSTR pszFlatName, LPCTSTR pszDomainController)
	{
		m_strDnsName = pszDnsName;
		m_strFlatName = pszFlatName;
		m_strDomainController = pszDomainController;
	}

	void SetDefaultContainer(IADsContainerPtr& spContainer)
	{
		m_spDefaultContainer = spContainer;
	}

	void CrackNames(const StringVector& vecNames);

	const CStringSet& GetResolvedNames() const
	{
		return m_setResolvedNames;
	}

	const StringVector& GetUnResolvedNames() const
	{
		return m_vecUnResolvedNames;
	}

	void SiftExcludeNames(const StringSet& setExcludeNames, const StringSet& setNamingAttributes, StringSet& setExcludeRDNs, StringSet& setExcludeSamAccountNames) const;
	

protected:

	void Separate(
		const StringVector& vecNames,
		StringVector& vecCanonicalNames,
		StringVector& vecSamAccountNames,
		StringVector& vecRelativeDistinguishedNames
	);
	void CrackCanonicalNames(const StringVector& vecCanonicalNames, StringVector& vecUnResolvedNames);
	void CrackSamAccountNames(const StringVector& vecSamAccountNames, StringVector& vecUnResolvedNames);
	void CrackRelativeDistinguishedNames(const StringVector& vecRelativeDistinguishedNames, StringVector& vecUnResolvedNames);

	typedef enum
	{
		CANONICAL_NAME,
		NT4_ACCOUNT_NAME,
	}
	NAME_FORMAT;

	struct SName
	{
		SName(LPCTSTR pszPartial, LPCTSTR pszComplete) :
			strPartial(pszPartial),
			strComplete(pszComplete)
		{
		}

		SName(const SName& r) :
			strPartial(r.strPartial),
			strComplete(r.strComplete),
			strResolved(r.strResolved)
		{
		}

		SName& operator =(const SName& r)
		{
			strPartial = r.strPartial;
			strComplete = r.strComplete;
			strResolved = r.strResolved;
			return *this;
		}

		tstring strPartial;
		tstring strComplete;
		tstring strResolved;
	};

	typedef std::vector<SName> CNameVector;

	void CrackNames(NAME_FORMAT eFormat, CNameVector& vecNames);

protected:

	tstring m_strDnsName;
	tstring m_strFlatName;
	tstring m_strDomainController;
	IADsContainerPtr m_spDefaultContainer;

	CStringSet m_setResolvedNames;
	StringVector m_vecUnResolvedNames;
};


//---------------------------------------------------------------------------
// Ignore Case String Less
//---------------------------------------------------------------------------

struct IgnoreCaseStringLess :
	public std::binary_function<_bstr_t, _bstr_t, bool>
{
	bool operator()(const _bstr_t& x, const _bstr_t& y) const;
};


//---------------------------------------------------------------------------
// Domain To Path Map Class
//---------------------------------------------------------------------------

class CDomainToPathMap :
	public std::map<_bstr_t, StringSet, IgnoreCaseStringLess>
{
public:

	CDomainToPathMap()
	{
	}

	void Initialize(LPCTSTR pszDefaultDomainDns, LPCTSTR pszDefaultDomainFlat, const StringSet& setNames);

protected:

	static bool GetValidDomainName(_bstr_t& strDomainName);
};


//---------------------------------------------------------------------------
// Name To Path Map Class
//---------------------------------------------------------------------------

class CNameToPathMap :
	public std::map<_bstr_t, StringSet, IgnoreCaseStringLess>
{
public:

	CNameToPathMap();
	CNameToPathMap(StringSet& setNames);

	void Initialize(StringSet& setNames);

	void Add(_bstr_t& strName, _bstr_t& strPath);
};


//---------------------------------------------------------------------------
// Compare Strings Class
//---------------------------------------------------------------------------

class CCompareStrings
{
public:

	CCompareStrings();
	CCompareStrings(StringSet& setNames);

	void Initialize(StringSet& setNames);
	bool IsMatch(LPCTSTR pszName);

protected:

	class CCompareString
	{
	public:

		CCompareString(LPCTSTR pszCompare = NULL);
		CCompareString(const CCompareString& r);

		void Initialize(LPCTSTR pszCompare);
		bool IsMatch(LPCTSTR psz);

	protected:

		int m_nType;
		_bstr_t m_strCompare;
	};

	typedef std::vector<CCompareString> CompareStringVector;

	CompareStringVector m_vecCompareStrings;
};


//---------------------------------------------------------------------------
// Compare RDNs Class
//---------------------------------------------------------------------------

class CCompareRDNs
{
public:

    CCompareRDNs();
    CCompareRDNs(StringSet& setNames);

    void Initialize(StringSet& setNames);
    bool IsMatch(LPCTSTR pszName);

protected:

    class CCompareRDN
    {
    public:

        CCompareRDN(LPCTSTR pszCompare = NULL);
        CCompareRDN(const CCompareRDN& r);

        void Initialize(LPCTSTR pszCompare);
        bool IsMatch(LPCTSTR psz);

    protected:

        int m_nPatternType;
        _bstr_t m_strType;
        _bstr_t m_strValue;
    };

    typedef std::vector<CCompareRDN> CompareVector;

    CompareVector m_vecCompare;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\reportgeneration.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "ReportGeneration.h"

#include "Error.h"
#include "VarSetOptions.h"
#include "VarSetReports.h"


//---------------------------------------------------------------------------
// Report Class
//---------------------------------------------------------------------------


CReportGeneration::CReportGeneration() :
	m_lType(admtReportMigratedAccounts)
{
}


CReportGeneration::~CReportGeneration()
{
}


// IReport Implementation ----------------------------------------


// Type Property

STDMETHODIMP CReportGeneration::put_Type(long lType)
{
	HRESULT hr = S_OK;

	if (IsReportTypeValid(lType))
	{
		m_lType = lType;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, E_INVALIDARG, IDS_E_REPORT_TYPE_INVALID);
	}

	return hr;
}

STDMETHODIMP CReportGeneration::get_Type(long* plType)
{
	*plType = m_lType;

	return S_OK;
}


// Folder Property

STDMETHODIMP CReportGeneration::put_Folder(BSTR bstrFolder)
{
	HRESULT hr = S_OK;

	try
	{
		_bstr_t strFolder = bstrFolder;

		if (strFolder.length() > 0)
		{
			_TCHAR szPath[_MAX_PATH];
			LPTSTR pszFilePart;

			DWORD cchPath = GetFullPathName(strFolder, _MAX_PATH, szPath, &pszFilePart);

			if ((cchPath == 0) || (cchPath >= _MAX_PATH))
			{
				AdmtThrowError(
					GUID_NULL,
					GUID_NULL,
					HRESULT_FROM_WIN32(GetLastError()), 
					IDS_E_REPORT_FOLDER,
					(LPCTSTR)strFolder
				);
			}

			DWORD dwAttributes = GetFileAttributes(szPath);

			if (dwAttributes == DWORD(-1))
			{
				AdmtThrowError(
					GUID_NULL,
					GUID_NULL,
					HRESULT_FROM_WIN32(GetLastError()),
					IDS_E_REPORT_FOLDER,
					(LPCTSTR)strFolder
				);
			}

			if (!(dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
			{
				AdmtThrowError(
					GUID_NULL,
					GUID_NULL,
					HRESULT_FROM_WIN32(ERROR_DIRECTORY),
					IDS_E_REPORT_FOLDER,
					(LPCTSTR)strFolder
				);
			}

			m_bstrFolder = szPath;
		}
		else
		{
			m_bstrFolder = strFolder;
		}
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CReportGeneration::get_Folder(BSTR* pbstrFolder)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrFolder = m_bstrFolder.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, E_FAIL);
	}

	return hr;
}


// Generate Method

STDMETHODIMP CReportGeneration::Generate(long lOptions, VARIANT vntInclude, VARIANT vntExclude)
{
	HRESULT hr = S_OK;

	MutexWait();

	bool bLogOpen = _Module.OpenLog();

	try
	{
		_Module.Log(ErrI, IDS_STARTED_REPORT_GENERATION);

		InitSourceDomainAndContainer();
		InitTargetDomainAndContainer();

		DoOption(lOptions, vntInclude, vntExclude);
	}
	catch (_com_error& ce)
	{
		_Module.Log(ErrE, IDS_E_CANT_GENERATE_REPORT, ce);
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, ce, IDS_E_CANT_GENERATE_REPORT);
	}
	catch (...)
	{
		_Module.Log(ErrE, IDS_E_CANT_GENERATE_REPORT, _com_error(E_FAIL));
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, E_FAIL, IDS_E_CANT_GENERATE_REPORT);
	}

	if (bLogOpen)
	{
		_Module.CloseLog();
	}

	MutexRelease();

	return hr;
}


// Implementation -----------------------------------------------------------


// DoNone Method

void CReportGeneration::DoNone()
{
	CVarSet aVarSet;

	SetOptions(aVarSet);
	SetReports(aVarSet);

	aVarSet.Put(_T("PlugIn.%ld"), 0, _T("None"));

	PerformMigration(aVarSet);

	SaveSettings(aVarSet);
}


// DoNames Method

void CReportGeneration::DoNames()
{
	CDomainAccounts aComputers;

	m_SourceDomain.QueryComputersAcrossDomains(GetSourceContainer(), true, m_setIncludeNames, m_setExcludeNames, aComputers);

	DoComputers(aComputers);
}


// DoDomain Method

void CReportGeneration::DoDomain()
{
	DoContainers(GetSourceContainer());
}


// DoContainers Method

void CReportGeneration::DoContainers(CContainer& rSource)
{
	DoComputers(rSource);
}


// DoComputers Method

void CReportGeneration::DoComputers(CContainer& rSource)
{
	CDomainAccounts aComputers;

	rSource.QueryComputers(true, m_nRecurseMaintain >= 1, m_setExcludeNames, aComputers);

	DoComputers(aComputers);
}


// DoComputers Method

void CReportGeneration::DoComputers(CDomainAccounts& rComputers)
{
	if (rComputers.size() > 0)
	{
		CVarSet aVarSet;

		SetOptions(aVarSet);
		SetReports(aVarSet);

		FillInVarSetForComputers(rComputers, false, false, false, 0, aVarSet);

		aVarSet.Put(_T("PlugIn.%ld"), 0, _T("None"));

		rComputers.clear();

		PerformMigration(aVarSet);

		aVarSet.Put(DCTVS_GatherInformation, false);

		SaveSettings(aVarSet);
	}
}


// SetOptions Method

void CReportGeneration::SetOptions(CVarSet& rVarSet)
{
	CVarSetOptions aOptions(rVarSet);

	aOptions.SetWizard(_T("reporting"));
	aOptions.SetIntraForest(m_spInternal->IntraForest ? true : false);
	aOptions.SetSourceDomain(m_SourceDomain.NameFlat(), m_SourceDomain.NameDns());
	aOptions.SetTargetDomain(m_TargetDomain.NameFlat(), m_TargetDomain.NameDns());
}


// SetReports Method

void CReportGeneration::SetReports(CVarSet& rVarSet)
{
	CVarSetReports aReports(rVarSet);

	aReports.SetType(m_lType);
	aReports.SetReportsDirectory(m_bstrFolder);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ADMTScript.rc
//
#define IDS_PROJNAME                    100
#define IDR_MIGRATION                   101
#define IDS_STARTED_USER_MIGRATION      102
#define IDS_STARTED_GROUP_MIGRATION     103
#define IDS_STARTED_COMPUTER_MIGRATION  104
#define IDS_STARTED_SECURITY_TRANSLATION 105
#define IDS_STARTED_SERVICE_ACCOUNT_ENUMERATION 106
#define IDS_E_CREATE_USER_MIGRATION     107
#define IDS_E_CREATE_GROUP_MIGRATION    108
#define IDS_E_CREATE_COMPUTER_MIGRATION 109
#define IDS_E_CREATE_SECURITY_TRANSLATION 110
#define IDS_E_CREATE_SERVICE_ACCOUNT_ENUMERATION 111
#define IDS_E_CANT_MIGRATE_USERS        112
#define IDS_E_CANT_MIGRATE_GROUPS       113
#define IDS_E_CANT_MIGRATE_COMPUTERS    114
#define IDS_E_CANT_TRANSLATE_SECURITY   115
#define IDS_E_CANT_ENUMERATE_SERVICE_ACCOUNTS 116
#define IDS_E_CONFLICT_OPTION_INVALID   117
#define IDS_E_CONFLICT_FLAGS_NOT_ALLOWED 118
#define IDS_E_DISABLE_OPTION_INVALID    119
#define IDS_E_PASSWORD_OPTION_INVALID   120
#define IDS_E_RENAME_OPTION_INVALID     121
#define IDS_E_RESTART_DELAY_INVALID     122
#define IDS_E_SOURCE_EXPIRATION_INVALID 123
#define IDS_E_TRANSLATION_OPTION_INVALID 124
#define IDS_E_DOMAIN_SPECIFIED          125
#define IDS_E_NOT_SOURCE_DOMAIN         126
#define IDS_E_INVALID_FILTER_STRING     127
#define IDS_E_CANT_GET_DOMAIN_INFORMATION 128
#define IDS_E_CANT_GET_DOMAIN_CONTROLLER 129
#define IDS_E_CANT_GET_GLOBAL_CATALOG_SERVER 130
#define IDS_E_CANT_GET_DISTINGUISHED_NAME 131
#define IDS_E_CANT_CONNECT_TO_DIRECTORY_SERVICE 132
#define IDS_E_CANT_CREATE_CONTAINER_NT4 133
#define IDS_E_CANT_ADD_GROUP            134
#define IDS_E_CANT_ADD_USER             135
#define IDS_E_CANT_CONNECT_TO_DOMAIN    136
#define IDS_E_CANT_ADD_COMPUTER         137
#define IDS_E_CANT_EXECUTE_SEARCH       138
#define IDS_E_NOT_INTER_FOREST          139
#define IDS_E_NOT_INTRA_FOREST          140
#define IDS_E_INVALID_OPTION            141
#define IDS_E_INVALID_EXCLUDE_DATA_TYPE 142
#define IDS_E_INVALID_DATA_OPTION_DATA_TYPE 143
#define IDS_E_INVALID_FILE_OPTION_DATA_TYPE 144
#define IDS_E_DATA_OPTION_FLAGS_NOT_ALLOWED 145
#define IDS_E_PASSWORD_DC_INVALID       146
#define IDS_E_PASSWORD_DC_NOT_SPECIFIED 147
#define IDS_E_USER_NOT_FOUND            148
#define IDS_E_GROUP_NOT_FOUND           149
#define IDS_E_COMPUTER_NOT_FOUND        150
#define IDS_E_CANT_DO_BUILTIN           151
#define IDS_E_DOMAIN_NOT_VALID          152
#define IDS_STARTED_REPORT_GENERATION   153
#define IDS_E_REPORT_TYPE_INVALID       154
#define IDS_E_CANT_GENERATE_REPORT      155
#define IDS_E_CREATE_REPORT_GENERATION  156
#define IDS_E_PASSWORD_DC_NOT_NT        157
#define IDS_E_PASSWORD_DC_NOT_DC        158
#define IDS_E_PASSWORD_DC_DLL_NOT_RUNNING 159
#define IDS_E_PASSWORD_MIGRATION_DISABLED 160
#define IDS_E_PASSWORD_GENERATE_SESSION_KEY_FAILED 161
#define IDS_E_PASSWORD_CANT_GENERATE_PASSWORD 162
#define IDS_E_PASSWORD_ENCRYPTION_KEY_INVALID 163
#define IDS_E_INTRA_FOREST_REPLACE      164
#define IDS_E_PASSWORD_ENCRYPTION_PACK_INVALID 165
#define IDS_E_ADMT_PROCESS_RUNNING      166
#define IDS_E_PASSWORD_DC_NOT_FOUND     167
#define IDS_E_SID_MAPPING_FILE          168
#define IDS_E_NO_RENAME_PREFIX          169
#define IDS_E_RENAME_NO_SUFFIX          170
#define IDS_E_NO_CONFLICT_PREFIX        171
#define IDS_E_NO_CONFLICT_SUFFIX        172
#define IDS_E_PREFIX_SUFFIX_TOO_LONG    173
#define IDS_E_NOT_ADMINISTRATOR         174
#define IDS_E_INVALID_RENAME_PREFIX_SUFFIX 175
#define IDS_E_INVALID_CONFLICT_PREFIX_SUFFIX 176
#define IDS_E_UNABLE_TO_UPDATE_DATABASE 177
#define IDS_E_CANT_MIGRATE_DOMAIN_CONTROLLERS 178
#define IDS_E_CANT_FIND_COMPUTER        179
#define IDS_E_CANT_ENUMERATE_COMPUTERS  180
#define IDS_E_DOMAIN_NAME_NOT_SPECIFIED 181
#define IDS_E_CAN_ADD_SID_HISTORY       182
#define IDS_E_SID_HISTORY_CONFIGURATION 183
#define IDS_E_NO_AUDITING_SOURCE        184
#define IDS_E_NO_AUDITING_TARGET        185
#define IDS_E_NO_SID_HISTORY_LOCAL_GROUP 186
#define IDS_E_NO_SID_HISTORY_REGISTRY_ENTRY 187
#define IDS_E_REPORT_FOLDER             188
#define IDS_E_TARGET_CONTAINER_PATH_TOO_LONG 189
#define IDS_E_PASSWORD_FILE             190
#define IDS_E_INCLUDE_NAMES_FILE        191
#define IDS_E_REMOVING_SERVICE_ACCOUNTS 192
#define IDS_E_FIX_HIERARCHY_MOVE_OBJECT 193
#define IDS_E_FIX_HIERARCHY_BIND_TO_CONTAINER 194
#define IDS_E_CANNOT_GET_CONTAINER      195
#define IDS_E_CANNOT_MIGRATE_DOMAIN_CONTROLLERS 196
#define IDS_E_CANNOT_PROCESS_ACCOUNTS_IN_DOMAIN 197
#define IDS_E_CANNOT_RESOLVE_NAME       198
#define IDS_E_ACCOUNT_EXCLUDED          199
#define IDS_E_OBJECT_NOT_OF_CLASS       200
#define IDS_E_TARGET_DOMAIN_NOT_NATIVE_MODE 201
#define IDS_E_CANT_CREATE_CONTAINER_THAT_DEEPLY_NESTED 202
#define IDS_E_CANNOT_CREATE_CONTAINER 203
#define IDS_E_SID_HISTORY_MUST_RUN_ON_DOMAIN_CONTROLLER 204
#define IDS_E_SID_HISTORY_SOURCE_MUST_TRUST_TARGET 205
#define IDS_E_LOCAL_ADMIN_CHECK_FAILED   206
#define IDS_E_UPDATE_REGISTRY_FAILED    207
#define IDS_E_NO_SID_HISTORY_DOMAIN_ADMIN 208
#define IDS_E_CALLER_NOT_DELEGATED      209
#define IDS_E_UNABLE_VERIFY_CALLER_NOT_DELEGATED 210
#define IDS_E_PASSWORD_DC_WRONG_DOMAIN  211
#define IDS_E_UNABLE_SET_EXCLUDED_SYSTEM_PROPERTIES  212

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         204
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\securitytranslation.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "SecurityTranslation.h"

#include "Error.h"
#include "VarSetOptions.h"
#include "VarSetAccountOptions.h"
#include "VarSetSecurity.h"

#ifndef tstring
#include <string>
typedef std::basic_string<_TCHAR> tstring;
#endif


//---------------------------------------------------------------------------
// Security Translation Class
//---------------------------------------------------------------------------


CSecurityTranslation::CSecurityTranslation() :
	m_lTranslationOption(admtTranslateReplace),
	m_bTranslateFilesAndFolders(false),
	m_bTranslateLocalGroups(false),
	m_bTranslatePrinters(false),
	m_bTranslateRegistry(false),
	m_bTranslateShares(false),
	m_bTranslateUserProfiles(false),
	m_bTranslateUserRights(false)
{
}


CSecurityTranslation::~CSecurityTranslation()
{
}


// ISecurityTranslation Implementation ----------------------------------------


// TranslationOption Property

STDMETHODIMP CSecurityTranslation::put_TranslationOption(long lOption)
{
	HRESULT hr = S_OK;

	if (IsTranslationOptionValid(lOption))
	{
		m_lTranslationOption = lOption;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, E_INVALIDARG, IDS_E_TRANSLATION_OPTION_INVALID);
	}

	return hr;
}

STDMETHODIMP CSecurityTranslation::get_TranslationOption(long* plOption)
{
	*plOption = m_lTranslationOption;

	return S_OK;
}


// TranslateFilesAndFolders Property

STDMETHODIMP CSecurityTranslation::put_TranslateFilesAndFolders(VARIANT_BOOL bTranslate)
{
	m_bTranslateFilesAndFolders = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslateFilesAndFolders(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateFilesAndFolders ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateLocalGroups Property

STDMETHODIMP CSecurityTranslation::put_TranslateLocalGroups(VARIANT_BOOL bTranslate)
{
	m_bTranslateLocalGroups = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslateLocalGroups(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateLocalGroups ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslatePrinters Property

STDMETHODIMP CSecurityTranslation::put_TranslatePrinters(VARIANT_BOOL bTranslate)
{
	m_bTranslatePrinters = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslatePrinters(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslatePrinters ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateRegistry Property

STDMETHODIMP CSecurityTranslation::put_TranslateRegistry(VARIANT_BOOL bTranslate)
{
	m_bTranslateRegistry = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslateRegistry(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateRegistry ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateShares Property

STDMETHODIMP CSecurityTranslation::put_TranslateShares(VARIANT_BOOL bTranslate)
{
	m_bTranslateShares = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslateShares(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateShares ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateUserProfiles Property

STDMETHODIMP CSecurityTranslation::put_TranslateUserProfiles(VARIANT_BOOL bTranslate)
{
	m_bTranslateUserProfiles = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslateUserProfiles(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateUserProfiles ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateUserRights Property

STDMETHODIMP CSecurityTranslation::put_TranslateUserRights(VARIANT_BOOL bTranslate)
{
	m_bTranslateUserRights = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslateUserRights(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateUserRights ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// SidMappingFile Property

STDMETHODIMP CSecurityTranslation::put_SidMappingFile(BSTR bstrFile)
{
	HRESULT hr = S_OK;

	try
	{
		_bstr_t strFile = bstrFile;

		if (strFile.length() > 0)
		{
			_TCHAR szPath[_MAX_PATH];
			LPTSTR pszFilePart;

			DWORD cchPath = GetFullPathName(strFile, _MAX_PATH, szPath, &pszFilePart);

			if ((cchPath == 0) || (cchPath >= _MAX_PATH))
			{
				AdmtThrowError(
					GUID_NULL,
					GUID_NULL,
					HRESULT_FROM_WIN32(GetLastError()), 
					IDS_E_SID_MAPPING_FILE,
					(LPCTSTR)strFile
				);
			}

			HANDLE hFile = CreateFile(
				szPath,
				GENERIC_READ,
				FILE_SHARE_READ|FILE_SHARE_WRITE,
				NULL,
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL,
				NULL
			);

			if (hFile == INVALID_HANDLE_VALUE)
			{
				AdmtThrowError(
					GUID_NULL,
					GUID_NULL,
					HRESULT_FROM_WIN32(GetLastError()), 
					IDS_E_SID_MAPPING_FILE,
					(LPCTSTR)strFile
				);
			}

			CloseHandle(hFile);

			m_bstrSidMappingFile = szPath;
		}
		else
		{
			m_bstrSidMappingFile = strFile;
		}
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CSecurityTranslation::get_SidMappingFile(BSTR* pbstrFile)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrFile = m_bstrSidMappingFile.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, E_FAIL);
	}

	return hr;
}


// Translate Method

STDMETHODIMP CSecurityTranslation::Translate(long lOptions, VARIANT vntInclude, VARIANT vntExclude)
{
	HRESULT hr = S_OK;

	MutexWait();

	bool bLogOpen = _Module.OpenLog();

	try
	{
		_Module.Log(ErrI, IDS_STARTED_SECURITY_TRANSLATION);

		InitSourceDomainAndContainer(false);
		InitTargetDomainAndContainer();

		DoOption(lOptions, vntInclude, vntExclude);
	}
	catch (_com_error& ce)
	{
		_Module.Log(ErrE, IDS_E_CANT_TRANSLATE_SECURITY, ce);
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, ce, IDS_E_CANT_TRANSLATE_SECURITY);
	}
	catch (...)
	{
		_Module.Log(ErrE, IDS_E_CANT_TRANSLATE_SECURITY, _com_error(E_FAIL));
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, E_FAIL, IDS_E_CANT_TRANSLATE_SECURITY);
	}

	if (bLogOpen)
	{
		_Module.CloseLog();
	}

	MutexRelease();

	return hr;
}


// Implementation -----------------------------------------------------------


// DoNames Method

void CSecurityTranslation::DoNames()
{
	CDomainAccounts aComputers;

	m_TargetDomain.QueryComputersAcrossDomains(GetTargetContainer(), true, m_setIncludeNames, m_setExcludeNames, aComputers);

	DoComputers(aComputers);
}


// DoDomain Method

void CSecurityTranslation::DoDomain()
{
	DoContainers(GetTargetContainer());
}


// DoContainers Method

void CSecurityTranslation::DoContainers(CContainer& rContainer)
{
	DoComputers(rContainer);
}


// DoComputers Method

void CSecurityTranslation::DoComputers(CContainer& rContainer)
{
	CDomainAccounts aComputers;

	rContainer.QueryComputers(true, m_nRecurseMaintain >= 1, m_setExcludeNames, aComputers);

	DoComputers(aComputers);
}


// DoComputers Method

void CSecurityTranslation::DoComputers(CDomainAccounts& rComputers)
{
	if (rComputers.size() > 0)
	{
		CVarSet aVarSet;

		SetOptions(aVarSet);
		SetAccountOptions(aVarSet);
		SetSecurity(aVarSet);

		FillInVarSetForComputers(rComputers, false, false, false, 0, aVarSet);

		rComputers.clear();

		aVarSet.Put(_T("PlugIn.%ld"), 0, _T("None"));

		PerformMigration(aVarSet);

		SaveSettings(aVarSet);
	}
}


// SetOptions Method

void CSecurityTranslation::SetOptions(CVarSet& rVarSet)
{
	CVarSetOptions aOptions(rVarSet);

	aOptions.SetTest(m_spInternal->TestMigration ? true : false);
	aOptions.SetUndo(false);
	aOptions.SetWizard(_T("security"));
	aOptions.SetIntraForest(m_spInternal->IntraForest ? true : false);

	// if source domain exists...

	if (m_SourceDomain.Initialized())
	{
		// then set domain information
		aOptions.SetSourceDomain(m_SourceDomain.NameFlat(), m_SourceDomain.NameDns(), m_SourceDomain.Sid());
	}
	else
	{
		// otherwise attempt to retrieve source domain information from database

		_bstr_t strName = m_spInternal->SourceDomain;

		// if name specified

		if (strName.length())
		{
			IIManageDBPtr spDatabase(__uuidof(IManageDB));

			IVarSetPtr spVarSet = spDatabase->GetSourceDomainInfo(strName);

			// if able to retrieve source domain information...

			if (spVarSet)
			{
				// then set domain information retrieved from database

				_bstr_t strFlatName = spVarSet->get(_T("Options.SourceDomain"));
				_bstr_t strDnsName = spVarSet->get(_T("Options.SourceDomainDns"));
				_bstr_t strSid = spVarSet->get(_T("Options.SourceDomainSid"));

				aOptions.SetSourceDomain(strFlatName, strDnsName, strSid);
			}
			else
			{
				// otherwise specify given name for flat name
                // this may occur if SID mapping file is being used
				aOptions.SetSourceDomain(strName, NULL);
			}
		}
	}

	aOptions.SetTargetDomain(m_TargetDomain.NameFlat(), m_TargetDomain.NameDns());
}


// SetAccountOptions Method

void CSecurityTranslation::SetAccountOptions(CVarSet& rVarSet)
{
	CVarSetAccountOptions aOptions(rVarSet);

	aOptions.SetSecurityTranslationOptions();
	aOptions.SetSecurityMapFile(m_bstrSidMappingFile);
}


// SetSecurity Method

void CSecurityTranslation::SetSecurity(CVarSet& rVarSet)
{
	CVarSetSecurity aSecurity(rVarSet);

	aSecurity.SetTranslationOption(m_lTranslationOption);
	aSecurity.SetTranslateContainers(false);
	aSecurity.SetTranslateFiles(m_bTranslateFilesAndFolders);
	aSecurity.SetTranslateLocalGroups(m_bTranslateLocalGroups);
	aSecurity.SetTranslatePrinters(m_bTranslatePrinters);
	aSecurity.SetTranslateRegistry(m_bTranslateRegistry);
	aSecurity.SetTranslateShares(m_bTranslateShares);
	aSecurity.SetTranslateUserProfiles(m_bTranslateUserProfiles);
	aSecurity.SetTranslateUserRights(m_bTranslateUserRights);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\securitytranslation.h ===
#pragma once

#include "MigrationBase.h"


//---------------------------------------------------------------------------
// SecurityTranslation Class
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CSecurityTranslation :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ISecurityTranslation, &IID_ISecurityTranslation, &LIBID_ADMT>,
	public CMigrationBase
{
public:

	CSecurityTranslation();
	~CSecurityTranslation();

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CSecurityTranslation)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(ISecurityTranslation)
	END_COM_MAP()

public:

	// ISecurityTranslation

	STDMETHOD(put_TranslationOption)(long lOption);
	STDMETHOD(get_TranslationOption)(long* plOption);
	STDMETHOD(put_TranslateFilesAndFolders)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateFilesAndFolders)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateLocalGroups)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateLocalGroups)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslatePrinters)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslatePrinters)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateRegistry)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateRegistry)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateShares)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateShares)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateUserProfiles)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateUserProfiles)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateUserRights)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateUserRights)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_SidMappingFile)(BSTR bstrFile);
	STDMETHOD(get_SidMappingFile)(BSTR* pbstrFile);
	STDMETHOD(Translate)(long lOption, VARIANT vntInclude, VARIANT vntExclude);

protected:

	virtual void DoNames();
	virtual void DoDomain();

	void DoContainers(CContainer& rContainer);
	void DoComputers(CContainer& rContainer);
	void DoComputers(CDomainAccounts& rComputers);

	void SetOptions(CVarSet& rVarSet);
	void SetAccountOptions(CVarSet& rVarSet);
	void SetSecurity(CVarSet& rVarSet);

protected:

	long m_lTranslationOption;
	bool m_bTranslateFilesAndFolders;
	bool m_bTranslateLocalGroups;
	bool m_bTranslatePrinters;
	bool m_bTranslateRegistry;
	bool m_bTranslateShares;
	bool m_bTranslateUserProfiles;
	bool m_bTranslateUserRights;
	_bstr_t m_bstrSidMappingFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\serviceaccountenumeration.h ===
#pragma once

#include "MigrationBase.h"


//---------------------------------------------------------------------------
// CServiceAccountEnumeration
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CServiceAccountEnumeration :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IServiceAccountEnumeration, &IID_IServiceAccountEnumeration, &LIBID_ADMT>,
	public CMigrationBase
{
public:

	CServiceAccountEnumeration();
	~CServiceAccountEnumeration();

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CServiceAccountEnumeration)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IServiceAccountEnumeration)
	END_COM_MAP()

public:

	// IServiceAccountEnumeration

	STDMETHOD(Enumerate)(long lOption, VARIANT vntInclude, VARIANT vntExclude);

protected:

	virtual void DoNames();
	virtual void DoDomain();

	void DoContainers(CContainer& rSource);
	void DoComputers(CContainer& rSource);
	void DoComputers(CDomainAccounts& rComputers);

	void SetOptions(CVarSet& rVarSet);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\serviceaccountenumeration.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "ServiceAccountEnumeration.h"

#include "Error.h"
#include "VarSetOptions.h"
#include "VarSetAccountOptions.h"
#include "VarSetSecurity.h"


//---------------------------------------------------------------------------
// Service Account Enumeration Class
//---------------------------------------------------------------------------


CServiceAccountEnumeration::CServiceAccountEnumeration()
{
}


CServiceAccountEnumeration::~CServiceAccountEnumeration()
{
}


// IServiceAccountEnumeration Implementation --------------------------------


// Enumerate Method

STDMETHODIMP CServiceAccountEnumeration::Enumerate(long lOptions, VARIANT vntInclude, VARIANT vntExclude)
{
	HRESULT hr = S_OK;

	MutexWait();

	bool bLogOpen = _Module.OpenLog();

	try
	{
		_Module.Log(ErrI, IDS_STARTED_SERVICE_ACCOUNT_ENUMERATION);

		InitSourceDomainAndContainer();

		DoOption(lOptions, vntInclude, vntExclude);
	}
	catch (_com_error& ce)
	{
		_Module.Log(ErrE, IDS_E_CANT_ENUMERATE_SERVICE_ACCOUNTS, ce);
		hr = AdmtSetError(CLSID_Migration, IID_IServiceAccountEnumeration, ce, IDS_E_CANT_ENUMERATE_SERVICE_ACCOUNTS);
	}
	catch (...)
	{
		_Module.Log(ErrE, IDS_E_CANT_ENUMERATE_SERVICE_ACCOUNTS, _com_error(E_FAIL));
		hr = AdmtSetError(CLSID_Migration, IID_IServiceAccountEnumeration, E_FAIL, IDS_E_CANT_ENUMERATE_SERVICE_ACCOUNTS);
	}

	if (bLogOpen)
	{
		_Module.CloseLog();
	}

	MutexRelease();

	return hr;
}


// Implementation -----------------------------------------------------------


// DoNames Method

void CServiceAccountEnumeration::DoNames()
{
	CDomainAccounts aComputers;

	m_SourceDomain.QueryComputersAcrossDomains(GetSourceContainer(), true, m_setIncludeNames, m_setExcludeNames, aComputers);

	DoComputers(aComputers);
}


// DoDomain Method

void CServiceAccountEnumeration::DoDomain()
{
	DoContainers(GetSourceContainer());
}


// DoContainers Method

void CServiceAccountEnumeration::DoContainers(CContainer& rSource)
{
	DoComputers(rSource);
}


// DoComputers Method

void CServiceAccountEnumeration::DoComputers(CContainer& rSource)
{
	CDomainAccounts aComputers;

	rSource.QueryComputers(true, m_nRecurseMaintain >= 1, m_setExcludeNames, aComputers);

	DoComputers(aComputers);
}


// DoComputers Method

void CServiceAccountEnumeration::DoComputers(CDomainAccounts& rComputers)
{
	if (rComputers.size() > 0)
	{
		CVarSet aVarSet;

		SetOptions(aVarSet);

		FillInVarSetForComputers(rComputers, false, false, false, 0, aVarSet);

		rComputers.clear();

		aVarSet.Put(_T("PlugIn.%ld"), 0, _T("{9CC87460-461D-11D3-99F3-0010A4F77383}"));

		PerformMigration(aVarSet);

		SaveSettings(aVarSet);
	}
}


// SetOptions Method

void CServiceAccountEnumeration::SetOptions(CVarSet& rVarSet)
{
	CVarSetOptions aOptions(rVarSet);

	aOptions.SetTest(m_spInternal->TestMigration ? true : false);
	aOptions.SetUndo(false);
	aOptions.SetWizard(_T("service"));
	aOptions.SetIntraForest(m_spInternal->IntraForest ? true : false);
	aOptions.SetSourceDomain(m_SourceDomain.NameFlat(), m_SourceDomain.NameDns());
	aOptions.SetTargetDomain(m_TargetDomain.NameFlat(), m_TargetDomain.NameDns());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#define COUNT_OF(a) (sizeof(a) / sizeof(a[0]))


//---------------------------------------------------------------------------
// CAdmtModule Class
//---------------------------------------------------------------------------


CAdmtModule::CAdmtModule()
{
}


CAdmtModule::~CAdmtModule()
{
}


// OpenLog Method

bool CAdmtModule::OpenLog()
{
//	CloseLog(); // error class doesn't reset file pointer to NULL when closing file

	return m_Error.LogOpen(GetMigrationLogPath(), 0, 0, true) ? true : false;
}


// CloseLog Method

void CAdmtModule::CloseLog()
{
	m_Error.LogClose();
}


// Log Method

void __cdecl CAdmtModule::Log(UINT uLevel, UINT uId, ...)
{
	_TCHAR szFormat[512];
	_TCHAR szMessage[1024];

	if (LoadString(GetResourceInstance(), uId, szFormat, 512))
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szMessage, COUNT_OF(szMessage), szFormat, args);
		va_end(args);

		szMessage[1023] = _T('\0');
	}
	else
	{
		szMessage[0] = _T('\0');
	}

	m_Error.MsgProcess(uLevel | uId, szMessage);
}


// Log Method

void __cdecl CAdmtModule::Log(UINT uLevel, UINT uId, _com_error& ce)
{
	try
	{
		_bstr_t strMessage;

		_TCHAR szMessage[512];

		if (LoadString(GetResourceInstance(), uId, szMessage, 512) == FALSE)
		{
			szMessage[0] = _T('\0');
		}

		strMessage = szMessage;

		_bstr_t strDescription = ce.Description();

		if (strDescription.length())
		{
			strMessage += _T(" ") + strDescription;
		}

		_TCHAR szError[32];
		_stprintf(szError, _T(" (0x%08lX)"), ce.Error());
		strMessage += szError;

		m_Error.MsgProcess(uLevel | uId, strMessage);
	}
	catch (...)
	{
	}
}


// Log Method

void __cdecl CAdmtModule::Log(LPCTSTR pszFormat, ...)
{
	_TCHAR szMessage[1024];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szMessage, COUNT_OF(szMessage), pszFormat, args);
		va_end(args);

		szMessage[1023] = _T('\0');
	}
	else
	{
		szMessage[0] = _T('\0');
	}

	m_Error.MsgProcess(0, szMessage);
}

StringLoader gString;

//#import <ActiveDs.tlb> no_namespace implementation_only exclude("_LARGE_INTEGER","_SYSTEMTIME")

#import <DBMgr.tlb> no_namespace implementation_only
#import <MigDrvr.tlb> no_namespace implementation_only
#import <VarSet.tlb> no_namespace rename("property", "aproperty") implementation_only
#import <WorkObj.tlb> no_namespace implementation_only
#import <MsPwdMig.tlb> no_namespace implementation_only
#import <adsprop.tlb> no_namespace implementation_only

#import "Internal.tlb" no_namespace implementation_only
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\stdafx.h ===
#pragma once

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>

#include <ErrDct.hpp>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

//---------------------------------------------------------------------------
// CAdmtModule Class
//---------------------------------------------------------------------------

class CAdmtModule : public CComModule
{
public:

	CAdmtModule();
	~CAdmtModule();

	bool OpenLog();
	void CloseLog();

	void __cdecl Log(UINT uLevel, UINT uId, ...);
	void __cdecl Log(UINT uLevel, UINT uId, _com_error& ce);
	void __cdecl Log(LPCTSTR pszFormat, ...);

protected:

	TErrorDct m_Error;
};

extern CAdmtModule _Module;

#include <atlcom.h>

#include <ComDef.h>
#include <ResStr.h>
#include <Folders.h>

//#pragma warning(disable: 4192) // automatically excluding

//#import <ActiveDs.tlb> no_namespace no_implementation exclude("_LARGE_INTEGER","_SYSTEMTIME")

#import <DBMgr.tlb> no_namespace no_implementation
#import <MigDrvr.tlb> no_namespace no_implementation
#import <VarSet.tlb> no_namespace rename("property", "aproperty") no_implementation
#import <WorkObj.tlb> no_namespace no_implementation
#import <MsPwdMig.tlb> no_namespace no_implementation
#import <adsprop.tlb> no_namespace no_implementation

#import "Internal.tlb" no_namespace no_implementation

//{{AFX_INSERT_LOCATION}}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\usermigration.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "UserMigration.h"

#include "Error.h"
#include "VarSetOptions.h"
#include "VarSetAccountOptions.h"
#include "VarSetSecurity.h"


//---------------------------------------------------------------------------
// CUserMigration
//---------------------------------------------------------------------------


CUserMigration::CUserMigration() :
    m_lDisableOption(admtEnableTarget),
    m_lSourceExpiration(-1),
    m_bMigrateSids(false),
    m_bTranslateRoamingProfile(false),
    m_bUpdateUserRights(false),
    m_bMigrateGroups(false),
    m_bUpdatePreviouslyMigratedObjects(false),
    m_bFixGroupMembership(true),
    m_bMigrateServiceAccounts(false)
{
}


CUserMigration::~CUserMigration()
{
}


// IUserMigration Implementation --------------------------------------------


// DisableOption Property

STDMETHODIMP CUserMigration::put_DisableOption(long lOption)
{
    HRESULT hr = S_OK;

    if (IsDisableOptionValid(lOption))
    {
        m_lDisableOption = lOption;
    }
    else
    {
        hr = AdmtSetError(CLSID_Migration, IID_IUserMigration, E_INVALIDARG, IDS_E_DISABLE_OPTION_INVALID);
    }

    return hr;
}

STDMETHODIMP CUserMigration::get_DisableOption(long* plOption)
{
    *plOption = m_lDisableOption;

    return S_OK;
}


// SourceExpiration Property

STDMETHODIMP CUserMigration::put_SourceExpiration(long lExpiration)
{
    HRESULT hr = S_OK;

    if (IsSourceExpirationValid(lExpiration))
    {
        m_lSourceExpiration = lExpiration;
    }
    else
    {
        hr = AdmtSetError(CLSID_Migration, IID_IUserMigration, E_INVALIDARG, IDS_E_SOURCE_EXPIRATION_INVALID);
    }

    return hr;
}

STDMETHODIMP CUserMigration::get_SourceExpiration(long* plExpiration)
{
    *plExpiration = m_lSourceExpiration;

    return S_OK;
}


// MigrateSIDs Property

STDMETHODIMP CUserMigration::put_MigrateSIDs(VARIANT_BOOL bMigrate)
{
    m_bMigrateSids = bMigrate ? true : false;

    return S_OK;
}

STDMETHODIMP CUserMigration::get_MigrateSIDs(VARIANT_BOOL* pbMigrate)
{
    *pbMigrate = m_bMigrateSids ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// TranslateRoamingProfile Property

STDMETHODIMP CUserMigration::put_TranslateRoamingProfile(VARIANT_BOOL bTranslate)
{
    m_bTranslateRoamingProfile = bTranslate ? true : false;

    return S_OK;
}

STDMETHODIMP CUserMigration::get_TranslateRoamingProfile(VARIANT_BOOL* pbTranslate)
{
    *pbTranslate = m_bTranslateRoamingProfile ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// UpdateUserRights Property

STDMETHODIMP CUserMigration::put_UpdateUserRights(VARIANT_BOOL bUpdate)
{
    m_bUpdateUserRights = bUpdate ? true : false;

    return S_OK;
}

STDMETHODIMP CUserMigration::get_UpdateUserRights(VARIANT_BOOL* pbUpdate)
{
    *pbUpdate = m_bUpdateUserRights ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// MigrateGroups Property

STDMETHODIMP CUserMigration::put_MigrateGroups(VARIANT_BOOL bMigrate)
{
    m_bMigrateGroups = bMigrate ? true : false;

    return S_OK;
}

STDMETHODIMP CUserMigration::get_MigrateGroups(VARIANT_BOOL* pbMigrate)
{
    *pbMigrate = m_bMigrateGroups ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// UpdatePreviouslyMigratedObjects Property

STDMETHODIMP CUserMigration::put_UpdatePreviouslyMigratedObjects(VARIANT_BOOL bUpdate)
{
    m_bUpdatePreviouslyMigratedObjects = bUpdate ? true : false;

    return S_OK;
}

STDMETHODIMP CUserMigration::get_UpdatePreviouslyMigratedObjects(VARIANT_BOOL* pbUpdate)
{
    *pbUpdate = m_bUpdatePreviouslyMigratedObjects ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// FixGroupMembership Property

STDMETHODIMP CUserMigration::put_FixGroupMembership(VARIANT_BOOL bFix)
{
    m_bFixGroupMembership = bFix ? true : false;

    return S_OK;
}

STDMETHODIMP CUserMigration::get_FixGroupMembership(VARIANT_BOOL* pbFix)
{
    *pbFix = m_bFixGroupMembership ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// MigrateServiceAccounts Property

STDMETHODIMP CUserMigration::put_MigrateServiceAccounts(VARIANT_BOOL bMigrate)
{
    m_bMigrateServiceAccounts = bMigrate ? true : false;

    return S_OK;
}

STDMETHODIMP CUserMigration::get_MigrateServiceAccounts(VARIANT_BOOL* pbMigrate)
{
    *pbMigrate = m_bMigrateServiceAccounts ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


// Migrate Method

STDMETHODIMP CUserMigration::Migrate(long lOptions, VARIANT vntInclude, VARIANT vntExclude)
{
    HRESULT hr = S_OK;

    MutexWait();

    bool bLogOpen = _Module.OpenLog();

    try
    {
        _Module.Log(ErrI, IDS_STARTED_USER_MIGRATION);

        InitSourceDomainAndContainer();
        InitTargetDomainAndContainer();

        SetDefaultExcludedSystemProperties();

        VerifyInterIntraForest();
        VerifyCallerDelegated();
        ValidateMigrationParameters();

        if (m_bMigrateSids)
        {
            VerifyCanAddSidHistory();
        }

        VerifyPasswordOption();

        DoOption(lOptions, vntInclude, vntExclude);
    }
    catch (_com_error& ce)
    {
        _Module.Log(ErrE, IDS_E_CANT_MIGRATE_USERS, ce);
        hr = AdmtSetError(CLSID_Migration, IID_IUserMigration, ce, IDS_E_CANT_MIGRATE_USERS);
    }
    catch (...)
    {
        _Module.Log(ErrE, IDS_E_CANT_MIGRATE_USERS, _com_error(E_FAIL));
        hr = AdmtSetError(CLSID_Migration, IID_IUserMigration, E_FAIL, IDS_E_CANT_MIGRATE_USERS);
    }

    if (bLogOpen)
    {
        _Module.CloseLog();
    }

    MutexRelease();

    return hr;
}


// Implementation -----------------------------------------------------------


// ValidateMigrationParameters Method

void CUserMigration::ValidateMigrationParameters()
{
    bool bIntraForest = m_spInternal->IntraForest ? true : false;

    if (bIntraForest)
    {
        // validate conflict option

        long lConflictOptions = m_spInternal->ConflictOptions;
        long lConflictOption = lConflictOptions & 0x0F;

        if (lConflictOption == admtReplaceConflicting)
        {
            AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INTRA_FOREST_REPLACE);
        }
    }
}


// DoNames Method

void CUserMigration::DoNames()
{
    CDomainAccounts aUsers;

    m_SourceDomain.QueryUsers(GetSourceContainer(), m_setIncludeNames, m_setExcludeNames, aUsers);

    DoUsers(aUsers, GetTargetContainer());
}


// DoDomain Method

void CUserMigration::DoDomain()
{
    CContainer& rSource = GetSourceContainer();
    CContainer& rTarget = GetTargetContainer();

    if (m_nRecurseMaintain == 2)
    {
        rTarget.CreateContainerHierarchy(rSource);
    }

    DoContainers(rSource, rTarget);
}


// DoContainers Method

void CUserMigration::DoContainers(CContainer& rSource, CContainer& rTarget)
{
    DoUsers(rSource, rTarget);

    if (m_nRecurseMaintain == 2)
    {
        ContainerVector aContainers;
        rSource.QueryContainers(aContainers);

        for (ContainerVector::iterator it = aContainers.begin(); it != aContainers.end(); it++)
        {
            DoContainers(*it, rTarget.GetContainer(it->GetName()));
        }
    }
}


// DoUsers Method

void CUserMigration::DoUsers(CContainer& rSource, CContainer& rTarget)
{
    CDomainAccounts aUsers;
    rSource.QueryUsers(m_nRecurseMaintain == 1, m_setExcludeNames, aUsers);

    DoUsers(aUsers, rTarget);
}


// DoUsers Method

void CUserMigration::DoUsers(CDomainAccounts& rUsers, CContainer& rTarget)
{
    if (rUsers.size() > 0)
    {
        if (!m_bMigrateServiceAccounts)
        {
            RemoveServiceAccounts(rUsers);
        }

        if (rUsers.size() > 0)
        {
            CVarSet aVarSet;

            SetOptions(rTarget.GetPath(), aVarSet);
            SetAccountOptions(aVarSet);

            VerifyRenameConflictPrefixSuffixValid();

            FillInVarSetForUsers(rUsers, aVarSet);

            rUsers.clear();

#ifdef _DEBUG
            aVarSet.Dump();
#endif

            PerformMigration(aVarSet);

            SaveSettings(aVarSet);

            if ((m_nRecurseMaintain == 2) && m_bMigrateGroups)
            {
                FixObjectsInHierarchy(_T("group"));
            }
        }
    }
}


// RemoveServiceAccounts Method

void CUserMigration::RemoveServiceAccounts(CDomainAccounts& rUsers)
{
    try
    {
        CVarSet varset;

        IIManageDBPtr spDatabase(__uuidof(IManageDB));
        IUnknownPtr spunkVarSet(varset.GetInterface());
        IUnknown* punkVarset = spunkVarSet;
        spDatabase->GetServiceAccount(_bstr_t(_T("")), &punkVarset);

        long lCount = varset.Get(_T("ServiceAccountEntries"));

        if (lCount > 0)
        {
            StringSet setNames;

            for (long lIndex = 0; lIndex < lCount; lIndex++)
            {
                setNames.insert(_bstr_t(varset.Get(_T("ServiceAccount.%ld"), lIndex)));
            }

            _bstr_t strDomain = m_SourceDomain.NameFlat();

            for (CDomainAccounts::iterator itUser = rUsers.begin(); itUser != rUsers.end(); )
            {
                bool bFound = false;

                _bstr_t strAccountName = strDomain + _T("\\") + itUser->GetSamAccountName();
                _bstr_t strUserPrincipalName = itUser->GetUserPrincipalName();

                PCTSTR pszAccountName = strAccountName;
                PCTSTR pszUserPrincipalName = strUserPrincipalName;

                for (StringSet::iterator itName = setNames.begin(); itName != setNames.end(); itName++)
                {
                    PCTSTR pszName = *itName;

                    if (pszName)
                    {
                        if (pszAccountName && (_tcsicmp(pszName, pszAccountName) == 0))
                        {
                            bFound = true;
                            break;
                        }

                        if (pszUserPrincipalName && (_tcsicmp(pszName, pszUserPrincipalName) == 0))
                        {
                            bFound = true;
                            break;
                        }
                    }
                }

                if (bFound)
                {
                    itUser = rUsers.erase(itUser);
                }
                else
                {
                    ++itUser;
                }
            }
        }
    }
    catch (_com_error& ce)
    {
        AdmtThrowError(GUID_NULL, GUID_NULL, ce, IDS_E_REMOVING_SERVICE_ACCOUNTS);
    }
}


// SetOptions Method

void CUserMigration::SetOptions(_bstr_t strTargetOu, CVarSet& rVarSet)
{
    CVarSetOptions aOptions(rVarSet);

    aOptions.SetTest(m_spInternal->TestMigration ? true : false);

    aOptions.SetUndo(false);
    aOptions.SetWizard(_T("user"));

    aOptions.SetIntraForest(m_spInternal->IntraForest ? true : false);
    aOptions.SetSourceDomain(m_SourceDomain.NameFlat(), m_SourceDomain.NameDns(), m_SourceDomain.Sid());
    aOptions.SetTargetDomain(m_TargetDomain.NameFlat(), m_TargetDomain.NameDns());
    aOptions.SetTargetOu(strTargetOu);

    if (m_bMigrateSids || (m_spInternal->PasswordOption == admtCopyPassword))
    {
        aOptions.SetTargetServer(
            m_TargetDomain.DomainControllerNameFlat(),
            m_TargetDomain.DomainControllerNameDns()
        );
    }

    aOptions.SetRenameOptions(m_spInternal->RenameOption, m_spInternal->RenamePrefixOrSuffix);
}


// SetAccountOptions Method

void CUserMigration::SetAccountOptions(CVarSet& rVarSet)
{
    CVarSetAccountOptions aOptions(rVarSet);

    aOptions.SetPasswordOption(m_spInternal->PasswordOption, m_spInternal->PasswordServer);
    aOptions.SetPasswordFile(m_spInternal->PasswordFile);
    aOptions.SetConflictOptions(m_spInternal->ConflictOptions, m_spInternal->ConflictPrefixOrSuffix);

    aOptions.SetDisableOption(m_lDisableOption);
    aOptions.SetSourceExpiration(m_lSourceExpiration);
    aOptions.SetMigrateSids(m_bMigrateSids);
    aOptions.SetUserMigrationOptions(m_bMigrateGroups, m_bUpdatePreviouslyMigratedObjects);
    aOptions.SetFixGroupMembership(m_bFixGroupMembership);
    aOptions.SetUpdateUserRights(m_bUpdateUserRights);
    aOptions.SetTranslateRoamingProfile(m_bTranslateRoamingProfile);

    aOptions.SetExcludedUserProps(m_spInternal->UserPropertiesToExclude);
    aOptions.SetExcludedInetOrgPersonProps(m_spInternal->InetOrgPersonPropertiesToExclude);

    if (m_bMigrateGroups)
    {
        aOptions.SetExcludedGroupProps(m_spInternal->GroupPropertiesToExclude);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\usermigration.h ===
#pragma once

#include "MigrationBase.h"


//---------------------------------------------------------------------------
// CUserMigration
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CUserMigration :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IUserMigration, &IID_IUserMigration, &LIBID_ADMT>,
	public CMigrationBase
{
public:

	CUserMigration();
	~CUserMigration();

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CUserMigration)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IUserMigration)
	END_COM_MAP()

public:

	// IUserMigration

	STDMETHOD(put_DisableOption)(long lOption);
	STDMETHOD(get_DisableOption)(long* plOption);
	STDMETHOD(put_SourceExpiration)(long lExpiration);
	STDMETHOD(get_SourceExpiration)(long* plExpiration);
	STDMETHOD(put_MigrateSIDs)(VARIANT_BOOL bMigrate);
	STDMETHOD(get_MigrateSIDs)(VARIANT_BOOL* pbMigrate);
	STDMETHOD(put_TranslateRoamingProfile)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateRoamingProfile)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_UpdateUserRights)(VARIANT_BOOL bUpdate);
	STDMETHOD(get_UpdateUserRights)(VARIANT_BOOL* pbUpdate);
	STDMETHOD(put_MigrateGroups)(VARIANT_BOOL bMigrate);
	STDMETHOD(get_MigrateGroups)(VARIANT_BOOL* pbMigrate);
	STDMETHOD(put_UpdatePreviouslyMigratedObjects)(VARIANT_BOOL bUpdate);
	STDMETHOD(get_UpdatePreviouslyMigratedObjects)(VARIANT_BOOL* pbUpdate);
	STDMETHOD(put_FixGroupMembership)(VARIANT_BOOL bFix);
	STDMETHOD(get_FixGroupMembership)(VARIANT_BOOL* pbFix);
	STDMETHOD(put_MigrateServiceAccounts)(VARIANT_BOOL bMigrate);
	STDMETHOD(get_MigrateServiceAccounts)(VARIANT_BOOL* pbMigrate);
	STDMETHOD(Migrate)(long lOptions, VARIANT vntInclude, VARIANT vntExclude);

protected:

	void ValidateMigrationParameters();

	virtual void DoNames();
	virtual void DoDomain();

	void DoContainers(CContainer& rSource, CContainer& rTarget);
	void DoUsers(CContainer& rSource, CContainer& rTarget);
	void DoUsers(CDomainAccounts& rUsers, CContainer& rTarget);

	void RemoveServiceAccounts(CDomainAccounts& rUsers);

	void SetOptions(_bstr_t strTargetOu, CVarSet& rVarSet);
	void SetAccountOptions(CVarSet& rVarSet);

protected:

	long m_lDisableOption;
	long m_lSourceExpiration;
	bool m_bMigrateSids;
	bool m_bTranslateRoamingProfile;
	bool m_bUpdateUserRights;
	bool m_bMigrateGroups;
	bool m_bUpdatePreviouslyMigratedObjects;
	bool m_bFixGroupMembership;
	bool m_bMigrateServiceAccounts;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\varsetaccounts.h ===
#pragma once

#include "VarSetBase.h"


//---------------------------------------------------------------------------
// VarSet Accounts Class
//---------------------------------------------------------------------------


class CVarSetAccounts : public CVarSet
{
public:

	CVarSetAccounts(const CVarSet& rVarSet) :
		CVarSet(rVarSet),
		m_lIndex(0)
	{
	}

	long GetCount()
	{
		return m_lIndex;
	}

	void AddAccount(LPCTSTR pszType, LPCTSTR pszPath, LPCTSTR pszName = NULL, LPCTSTR pszUPName = NULL)
	{
		_TCHAR szValueBase[64];
		_TCHAR szValueName[128];

		_stprintf(szValueBase, _T("Accounts.%ld"), m_lIndex);

		// ADsPath

		Put(szValueBase, pszPath);

		// type

		_tcscpy(szValueName, szValueBase);
		_tcscat(szValueName, _T(".Type"));

		Put(szValueName, pszType);

		// name

		if (pszName)
		{
			_tcscpy(szValueName, szValueBase);
			_tcscat(szValueName, _T(".Name"));

			Put(szValueName, pszName);
		}

		// user principal name

		if (pszUPName)
		{
			_tcscpy(szValueName, szValueBase);
			_tcscat(szValueName, _T(".UPNName"));

			Put(szValueName, pszUPName);
		}

		// target name

	//	_tcscpy(szValueName, szValueBase);
	//	_tcscat(szValueName, _T(".TargetName"));

	//	Put(szValueName, (LPCTSTR)NULL);

		Put(DCTVS_Accounts_NumItems, ++m_lIndex);
	}

protected:

	long m_lIndex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\varsetoptions.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "Options.h"

#include "ADMTCommon.h"


//---------------------------------------------------------------------------
// Options Class
//---------------------------------------------------------------------------


// Constructor

COptions::COptions(const CVarSet& rVarSet) :
	CVarSet(rVarSet)
{
	Put(DCTVS_Options_AppendToLogs, true);
	Put(DCTVS_Options_Logfile, GetMigrationLogPath());
	Put(DCTVS_Options_DispatchLog, GetDispatchLogPath());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\varsetaccountoptions.h ===
#pragma once

#include "Error.h"
#include "Resource.h"
#include "VarSetBase.h"


//---------------------------------------------------------------------------
// VarSet AccountOptions Class
//---------------------------------------------------------------------------


class CVarSetAccountOptions : public CVarSet
{
public:

	CVarSetAccountOptions(const CVarSet& rVarSet) :
		CVarSet(rVarSet)
	{
		// must specify that security translation uses the migrated objects
		// table for all cases except when using a sid mapping file

		Put(DCTVS_AccountOptions_SecurityInputMOT, true);
	}

	//

	void SetPasswordOption(long lOption, LPCTSTR pszDc = NULL)
	{
		Put(DCTVS_AccountOptions_GenerateStrongPasswords, (lOption != admtPasswordFromName));
		Put(DCTVS_AccountOptions_CopyPasswords, (lOption == admtCopyPassword));

		if (lOption == admtCopyPassword)
		{
			if (pszDc)
			{
				Put(DCTVS_AccountOptions_PasswordDC, pszDc);
			}
			else
			{
				AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_PASSWORD_DC_NOT_SPECIFIED);
			}
		}
	}

	void SetPasswordFile(LPCTSTR pszFile)
	{
		if (pszFile && (_tcslen(pszFile) > 0))
		{
			Put(DCTVS_AccountOptions_PasswordFile, pszFile);
		}
		else
		{
			Put(DCTVS_AccountOptions_PasswordFile, GetLogsFolder() + _T("Passwords.txt"));
		}
	}

	void SetConflictOptions(long lOptions, LPCTSTR pszPrefixOrSuffix);

	void SetDisableOption(long lOption)
	{
		long lTarget = lOption & (admtDisableTarget|admtTargetSameAsSource);
		Put(DCTVS_AccountOptions_DisableCopiedAccounts, lTarget == admtDisableTarget);
		Put(DCTVS_AccountOptions_TgtStateSameAsSrc, lTarget == admtTargetSameAsSource);
		Put(DCTVS_AccountOptions_DisableSourceAccounts, (lOption & admtDisableSource) != 0);
	}

	void SetSourceExpiration(long lExpiration);

	// SetUserMigrationOptions is for user migration only

	void SetUserMigrationOptions(bool bMigrateGroups, bool bUpdateMigrated)
	{
		Put(DCTVS_AccountOptions_CopyUsers, true);
		Put(DCTVS_AccountOptions_CopyLocalGroups, bMigrateGroups);
		Put(DCTVS_AccountOptions_CopyMemberOf, bMigrateGroups);
		Put(DCTVS_AccountOptions_CopyComputers, false);
		Put(DCTVS_AccountOptions_CopyContainerContents, false);
		Put(DCTVS_AccountOptions_IncludeMigratedAccts, bMigrateGroups ? bUpdateMigrated : false);
	}

	// SetGroupMigrationOptions is for group migration only

	void SetGroupMigrationOptions(bool bMigrateMembers, bool bUpdateMigrated)
	{
		Put(DCTVS_AccountOptions_CopyUsers, bMigrateMembers);
		Put(DCTVS_AccountOptions_CopyLocalGroups, true);
		Put(DCTVS_AccountOptions_CopyComputers, false);
		Put(DCTVS_AccountOptions_CopyContainerContents, bMigrateMembers);
		Put(DCTVS_AccountOptions_CopyMemberOf, false);
		Put(DCTVS_AccountOptions_IncludeMigratedAccts, bMigrateMembers ? bUpdateMigrated : false);
	}

	// SetComputerMigrationOptions is for computer migration only

	void SetComputerMigrationOptions()
	{
		Put(DCTVS_AccountOptions_CopyUsers, false);
		Put(DCTVS_AccountOptions_CopyLocalGroups, false);
		Put(DCTVS_AccountOptions_CopyComputers, true);
		Put(DCTVS_AccountOptions_CopyContainerContents, false);
		Put(DCTVS_AccountOptions_CopyMemberOf, false);
	}

	// SetSecurityTranslationOptions is for security translation only

	void SetSecurityTranslationOptions()
	{
		Put(DCTVS_AccountOptions_CopyUsers, false);
		Put(DCTVS_AccountOptions_CopyLocalGroups, false);
		Put(DCTVS_AccountOptions_CopyComputers, false);
		Put(DCTVS_AccountOptions_CopyContainerContents, false);
	//	Put(DCTVS_AccountOptions_CopyMemberOf, false);
	}

	void SetMigrateSids(bool bMigrate)
	{
		Put(DCTVS_AccountOptions_AddSidHistory, bMigrate);
	}

	void SetFixGroupMembership(bool bFix)
	{
		Put(DCTVS_AccountOptions_FixMembership, bFix);
	}

	void SetUpdateUserRights(bool bUpdate)
	{
		Put(DCTVS_AccountOptions_UpdateUserRights, bUpdate);
	}

	void SetTranslateRoamingProfile(bool bTranslate)
	{
		Put(DCTVS_AccountOptions_TranslateRoamingProfiles, bTranslate);
	}

	void SetExcludedUserProps(LPCTSTR pszProperties)
	{
		if (pszProperties && (_tcslen(pszProperties) > 0))
		{
			Put(DCTVS_AccountOptions_ExcludeProps, true);
			Put(DCTVS_AccountOptions_ExcludedUserProps, pszProperties);
		}
	}

	void SetExcludedInetOrgPersonProps(LPCTSTR pszProperties)
	{
		if (pszProperties && (_tcslen(pszProperties) > 0))
		{
			Put(DCTVS_AccountOptions_ExcludeProps, true);
			Put(DCTVS_AccountOptions_ExcludedInetOrgPersonProps, pszProperties);
		}
	}

	void SetExcludedGroupProps(LPCTSTR pszProperties)
	{
		if (pszProperties && (_tcslen(pszProperties) > 0))
		{
			Put(DCTVS_AccountOptions_ExcludeProps, true);
			Put(DCTVS_AccountOptions_ExcludedGroupProps, pszProperties);
		}
	}

	void SetExcludedComputerProps(LPCTSTR pszProperties)
	{
		if (pszProperties && (_tcslen(pszProperties) > 0))
		{
			Put(DCTVS_AccountOptions_ExcludeProps, true);
			Put(DCTVS_AccountOptions_ExcludedComputerProps, pszProperties);
		}
	}

	void SetSecurityMapFile(LPCTSTR pszFile)
	{
		if (pszFile && (_tcslen(pszFile) > 0))
		{
			Put(DCTVS_AccountOptions_SecurityInputMOT, false);
			Put(DCTVS_AccountOptions_SecurityMapFile, pszFile);
		}
	}

protected:

	void SetReplaceExistingAccounts(bool bReplace)
	{
		Put(DCTVS_AccountOptions_ReplaceExistingAccounts, bReplace);
	}

	void SetRemoveExistingUserRights(bool bRemove)
	{
		Put(DCTVS_AccountOptions_RemoveExistingUserRights, bRemove);
	}

	void SetReplaceExistingGroupMembers(bool bReplace)
	{
		Put(DCTVS_AccountOptions_ReplaceExistingGroupMembers, bReplace);
	}

	void SetMoveReplacedAccounts(bool bMove)
	{
		Put(DCTVS_AccountOptions_MoveReplacedAccounts, bMove);
	}

	void SetPrefix(LPCTSTR pszPrefix)
	{
		Put(DCTVS_AccountOptions_Prefix, pszPrefix);
	}

	void SetSuffix(LPCTSTR pszSuffix)
	{
		Put(DCTVS_AccountOptions_Suffix, pszSuffix);
	}
};


//---------------------------------------------------------------------------
// Validation Functions
//---------------------------------------------------------------------------


inline bool IsDisableOptionValid(long lOption)
{
	bool bIs = false;

	// if only valid option bits are set...

	if (!(lOption & ~(admtEnableTarget|admtDisableSource|admtDisableTarget|admtTargetSameAsSource)))
	{
		// and not both disable target and target same as source options...

		if (!((lOption & admtDisableTarget) && (lOption & admtTargetSameAsSource)))
		{
			// then valid
			bIs = true;
		}
	}

	return bIs;
}


inline bool IsSourceExpirationValid(long lExpiration)
{
	return ((lExpiration == -1) || ((lExpiration >= 0) && (lExpiration <= 1095)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\varsetbase.h ===
#pragma once

#include "Error.h"


//---------------------------------------------------------------------------
// VarSet Class
//---------------------------------------------------------------------------


class CVarSet
{
public:

	CVarSet() :
		m_sp(__uuidof(VarSet)),
		m_vntYes(GET_STRING(IDS_YES)),
		m_vntNo(GET_STRING(IDS_No))
	{
	}

	CVarSet(const CVarSet& r) :
		m_sp(r.m_sp),
		m_vntYes(r.m_vntYes),
		m_vntNo(r.m_vntNo)
	{
	}

	//

	IVarSetPtr GetInterface()
	{
		return m_sp;
	}

	//

	void Put(UINT uId, bool bValue)
	{
		m_sp->put(GET_BSTR(uId), bValue ? m_vntYes : m_vntNo);
	}

	void Put(UINT uId, long lValue)
	{
		m_sp->put(GET_BSTR(uId), _variant_t(lValue));
	}

	void Put(UINT uId, LPCTSTR pszValue)
	{
		m_sp->put(GET_BSTR(uId), _variant_t(pszValue));
	}

	void Put(UINT uId, _bstr_t strValue)
	{
		m_sp->put(GET_BSTR(uId), _variant_t(strValue));
	}

	void Put(UINT uId, const _variant_t& vntValue)
	{
		m_sp->put(GET_BSTR(uId), vntValue);
	}

	//

	void Put(LPCTSTR pszName, bool bValue)
	{
		m_sp->put(_bstr_t(pszName), bValue ? m_vntYes : m_vntNo);
	}

	void Put(LPCTSTR pszName, long lValue)
	{
		m_sp->put(_bstr_t(pszName), _variant_t(lValue));
	}

	void Put(LPCTSTR pszName, LPCTSTR pszValue)
	{
		m_sp->put(_bstr_t(pszName), _variant_t(pszValue));
	}

	void Put(LPCTSTR pszName, _bstr_t strValue)
	{
		m_sp->put(_bstr_t(pszName), _variant_t(strValue));
	}

	void Put(LPCTSTR pszName, const _variant_t& vntValue)
	{
		m_sp->put(_bstr_t(pszName), vntValue);
	}

	//

	void Put(LPCTSTR pszFormat, long lIndex, bool bValue)
	{
		_TCHAR szName[256];
		_stprintf(szName, pszFormat, lIndex);
		m_sp->put(_bstr_t(szName), bValue ? m_vntYes : m_vntNo);
	}

	void Put(LPCTSTR pszFormat, long lIndex, long lValue)
	{
		_TCHAR szName[256];
		_stprintf(szName, pszFormat, lIndex);
		m_sp->put(_bstr_t(szName), _variant_t(lValue));
	}

	void Put(LPCTSTR pszFormat, long lIndex, LPCTSTR pszValue)
	{
		_TCHAR szName[256];
		_stprintf(szName, pszFormat, lIndex);
		m_sp->put(_bstr_t(szName), _variant_t(pszValue));
	}

	//

	_variant_t Get(UINT uId)
	{
		return m_sp->get(GET_BSTR(uId));
	}

	//

	_variant_t Get(LPCTSTR pszName)
	{
		return m_sp->get(_bstr_t(pszName));
	}

	bool GetBool(LPCTSTR pszName)
	{
		bool bValue = false;

		_variant_t vnt = m_sp->get(_bstr_t(pszName));

		if (vnt == m_vntYes)
		{
			bValue = true;
		}

		return bValue;
	}

	//

	_variant_t Get(LPCTSTR pszFormat, long lIndex)
	{
		_TCHAR szName[256];
		_stprintf(szName, pszFormat, lIndex);
		return m_sp->get(_bstr_t(szName));
	}

	bool GetBool(LPCTSTR pszFormat, long lIndex)
	{
		_TCHAR szName[256];
		_stprintf(szName, pszFormat, lIndex);
		return GetBool(szName);
	}

	//

	void Dump(LPCTSTR pszFile = _T("\\VarSetDump.txt"))
	{
		m_sp->DumpToFile(pszFile);
	}

protected:

	IVarSetPtr m_sp;

	_variant_t m_vntYes;
	_variant_t m_vntNo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\varsetaccountoptions.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "VarSetAccountOptions.h"
#include <Validation.h>


//---------------------------------------------------------------------------
// VarSet Account Options Class
//---------------------------------------------------------------------------


// SetConflictOptions Method

void CVarSetAccountOptions::SetConflictOptions(long lOptions, LPCTSTR pszPrefixOrSuffix)
{
	long lOption = lOptions & 0x0F;
	long lFlags = lOptions & 0xF0;

	_bstr_t c_bstrEmpty;

	switch (lOption)
	{
		case admtRenameConflictingWithSuffix:
		{
			if (pszPrefixOrSuffix && (_tcslen(pszPrefixOrSuffix) > 0))
			{
				if (IsValidPrefixOrSuffix(pszPrefixOrSuffix))
				{
					SetReplaceExistingAccounts(false);
					SetPrefix(c_bstrEmpty);
					SetSuffix(pszPrefixOrSuffix);
				}
				else
				{
					AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_CONFLICT_PREFIX_SUFFIX);
				}
			}
			else
			{
				AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_NO_CONFLICT_PREFIX);
			}
			break;
		}
		case admtRenameConflictingWithPrefix:
		{
			if (pszPrefixOrSuffix && (_tcslen(pszPrefixOrSuffix) > 0))
			{
				if (IsValidPrefixOrSuffix(pszPrefixOrSuffix))
				{
					SetReplaceExistingAccounts(false);
					SetPrefix(pszPrefixOrSuffix);
					SetSuffix(c_bstrEmpty);
				}
				else
				{
					AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_CONFLICT_PREFIX_SUFFIX);
				}
			}
			else
			{
				AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_NO_CONFLICT_SUFFIX);
			}
			break;
		}
		case admtReplaceConflicting:
		{
			SetReplaceExistingAccounts(true);
			SetRemoveExistingUserRights((lFlags & admtRemoveExistingUserRights) ? true : false);
			SetReplaceExistingGroupMembers((lFlags & admtRemoveExistingMembers) ? true : false);
			SetMoveReplacedAccounts((lFlags & admtMoveReplacedAccounts) ? true : false);
			SetPrefix(c_bstrEmpty);
			SetSuffix(c_bstrEmpty);
			break;
		}
		default: // admtIgnoreConflicting
		{
			SetReplaceExistingAccounts(false);
			SetPrefix(c_bstrEmpty);
			SetSuffix(c_bstrEmpty);
			break;
		}
	}
}


// SetSourceExpiration Method

void CVarSetAccountOptions::SetSourceExpiration(long lExpiration)
{
	_variant_t vntExpiration;

	if (lExpiration >= 0)
	{
		vntExpiration = lExpiration;
	}

	Put(DCTVS_AccountOptions_ExpireSourceAccounts, vntExpiration);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\varsetoptions.h ===
#pragma once

#include <Validation.h>
#include "VarSetBase.h"


//---------------------------------------------------------------------------
// VarSet Options Class
//---------------------------------------------------------------------------


class CVarSetOptions : public CVarSet
{
public:

	CVarSetOptions(const CVarSet& rVarSet) :
		CVarSet(rVarSet)
	{
		Put(DCTVS_Options_AppendToLogs, true);
		Put(DCTVS_Options_DontBeginNewLog, true);
		Put(DCTVS_Options_Logfile, GetMigrationLogPath());
		Put(DCTVS_Options_DispatchLog, GetDispatchLogPath());
		Put(DCTVS_Options_AutoCloseHideDialogs, 2L);
	}

	//

	void SetTest(bool bTest)
	{
		Put(DCTVS_Options_NoChange, bTest);
	}

	void SetUndo(bool bUndo)
	{
		Put(DCTVS_Options_Undo, bUndo);
	}

	void SetWizard(LPCTSTR pszWizard)
	{
		Put(DCTVS_Options_Wizard, pszWizard);
	}

	void SetIntraForest(bool bIntraForest)
	{
		Put(DCTVS_Options_IsIntraforest, bIntraForest);
	}

	void SetSourceDomain(LPCTSTR pszNameFlat, LPCTSTR pszNameDns, LPCTSTR pszSid = NULL)
	{
		Put(DCTVS_Options_SourceDomain, (pszNameDns && pszNameDns[0]) ? pszNameDns : pszNameFlat);
		Put(DCTVS_Options_SourceDomainDns, (pszNameDns && pszNameDns[0]) ? pszNameDns : (LPCTSTR)NULL);
		Put(DCTVS_Options_SourceDomainFlat, pszNameFlat);

		if (pszSid)
		{
			Put(DCTVS_Options_SourceDomainSid, pszSid);
		}
	}

	void SetTargetDomain(LPCTSTR pszNameFlat, LPCTSTR pszNameDns)
	{
		Put(DCTVS_Options_TargetDomain, pszNameDns);
		Put(DCTVS_Options_TargetDomainDns, pszNameDns);
		Put(DCTVS_Options_TargetDomainFlat, pszNameFlat);
	}

	void SetTargetOu(LPCTSTR pszOu)
	{
		Put(DCTVS_Options_OuPath, pszOu);
	}

	void SetTargetServer(LPCTSTR pszServerFlat, LPCTSTR pszServerDns)
	{
		Put(DCTVS_Options_TargetServerOverride, pszServerFlat);
		Put(DCTVS_Options_TargetServerOverrideDns, pszServerDns);
	}

	void SetRenameOptions(long lOption, LPCTSTR pszPrefixOrSuffix)
	{
		switch (lOption)
		{
			case admtRenameWithPrefix:
			{
				if (pszPrefixOrSuffix && (_tcslen(pszPrefixOrSuffix) > 0))
				{
					if (IsValidPrefixOrSuffix(pszPrefixOrSuffix))
					{
						Put(DCTVS_Options_Prefix, pszPrefixOrSuffix);
						Put(DCTVS_Options_Suffix, (LPCTSTR)NULL);
					}
					else
					{
						AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_RENAME_PREFIX_SUFFIX);
					}
				}
				else
				{
					AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_NO_RENAME_PREFIX);
				}
				break;
			}
			case admtRenameWithSuffix:
			{
				if (pszPrefixOrSuffix && (_tcslen(pszPrefixOrSuffix) > 0))
				{
					if (IsValidPrefixOrSuffix(pszPrefixOrSuffix))
					{
						Put(DCTVS_Options_Prefix, (LPCTSTR)NULL);
						Put(DCTVS_Options_Suffix, pszPrefixOrSuffix);
					}
					else
					{
						AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_RENAME_PREFIX_SUFFIX);
					}
				}
				else
				{
					AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_RENAME_NO_SUFFIX);
				}
				break;
			}
		}
	}

	void SetRestartDelay(long lTime)
	{
		Put(DCTVS_Options_GuiOnlyRebootSaver, lTime);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\varsetreports.h ===
#pragma once

#include "VarSetBase.h"

#include <time.h>


//---------------------------------------------------------------------------
// VarSet Reports Class
//---------------------------------------------------------------------------


class CVarSetReports : public CVarSet
{
public:

	CVarSetReports(const CVarSet& rVarSet) :
		CVarSet(rVarSet)
	{
		Put(DCTVS_GatherInformation, true);
		Put(DCTVS_Reports_Generate, true);
	}

	//

	void SetType(int nType)
	{
		UINT uIdType;
		UINT uIdTime;

		switch (nType)
		{
			case admtReportMigratedAccounts:
				uIdType = DCTVS_Reports_MigratedAccounts;
				uIdTime = DCTVS_Reports_MigratedAccounts_TimeGenerated;
				break;
			case admtReportMigratedComputers:
				uIdType = DCTVS_Reports_MigratedComputers;
				uIdTime = DCTVS_Reports_MigratedComputers_TimeGenerated;
				break;
			case admtReportExpiredComputers:
				uIdType = DCTVS_Reports_ExpiredComputers;
				uIdTime = DCTVS_Reports_ExpiredComputers_TimeGenerated;
				break;
			case admtReportAccountReferences:
				uIdType = DCTVS_Reports_AccountReferences;
				uIdTime = DCTVS_Reports_AccountReferences_TimeGenerated;
				break;
			case admtReportNameConflicts:
				uIdType = DCTVS_Reports_NameConflicts;
				uIdTime = DCTVS_Reports_NameConflicts_TimeGenerated;
				break;
			default:
				_ASSERT(FALSE);
				break;
		}

		Put(uIdType, true);
		Put(uIdTime, _bstr_t(_variant_t(time(NULL))));
	}

	void SetReportsDirectory(LPCTSTR pszDirectory)
	{
		_bstr_t strDirectory;

		if (pszDirectory && pszDirectory[0])
		{
			strDirectory = pszDirectory;
		}
		else
		{
			strDirectory = GetReportsFolder();
		}

		Put(DCTVS_Reports_Directory, strDirectory);
	}
};


//---------------------------------------------------------------------------
// Validation Functions
//---------------------------------------------------------------------------


inline bool IsReportTypeValid(long lType)
{
	return ((lType >= admtReportMigratedAccounts) && (lType <= admtReportNameConflicts));
}


/*

Migrated Users & Groups

2000-11-20 12:05:27 VarSet
2000-11-20 12:05:27 Case Sensitive: Yes, Indexed: Yes
2000-11-20 12:05:27 User Data ( 25 ) items
2000-11-20 12:05:27  [] <Empty>
2000-11-20 12:05:27  [GatherInformation] Yes
2000-11-20 12:05:27  [Options] <Empty>
2000-11-20 12:05:27  [Options.AppendToLogs] Yes
2000-11-20 12:05:27  [Options.DispatchLog] E:\Program Files\Active Directory Migration Tool\Logs\dispatch.log
2000-11-20 12:05:27  [Options.IsIntraforest] No
2000-11-20 12:05:27  [Options.Logfile] E:\Program Files\Active Directory Migration Tool\Logs\Migration.log
2000-11-20 12:05:27  [Options.MaxThreads] 20
2000-11-20 12:05:27  [Options.SourceDomain] HAY-BUV
2000-11-20 12:05:27  [Options.SourceDomainDns] hay-buv.nttest.microsoft.com
2000-11-20 12:05:27  [Options.TargetDomain] HAY-BUV-MPO
2000-11-20 12:05:27  [Options.TargetDomainDns] hay-buv-mpo.nttest.microsoft.com
2000-11-20 12:05:27  [Options.Wizard] reporting
2000-11-20 12:05:27  [PlugIn] <Empty>
2000-11-20 12:05:27  [PlugIn.0] None
2000-11-20 12:05:27  [Reports] <Empty>
2000-11-20 12:05:27  [Reports.AccountReferences] No
2000-11-20 12:05:27  [Reports.Directory] E:\Program Files\Active Directory Migration Tool\Reports
2000-11-20 12:05:27  [Reports.ExpiredComputers] No
2000-11-20 12:05:27  [Reports.Generate] Yes
2000-11-20 12:05:27  [Reports.MigratedAccounts] Yes
2000-11-20 12:05:27  [Reports.MigratedAccounts.TimeGenerated] 974750727
2000-11-20 12:05:27  [Reports.MigratedComputers] No
2000-11-20 12:05:27  [Reports.NameConflicts] No
2000-11-20 12:05:27  [Security] <Empty>
2000-11-20 12:05:27  [Security.TranslateContainers] 

Migrated Computers

2000-11-20 12:21:13 VarSet
2000-11-20 12:21:13 Case Sensitive: Yes, Indexed: Yes
2000-11-20 12:21:13 User Data ( 25 ) items
2000-11-20 12:21:13  [] <Empty>
2000-11-20 12:21:13  [GatherInformation] Yes
2000-11-20 12:21:13  [Options] <Empty>
2000-11-20 12:21:13  [Options.AppendToLogs] Yes
2000-11-20 12:21:13  [Options.DispatchLog] E:\Program Files\Active Directory Migration Tool\Logs\dispatch.log
2000-11-20 12:21:13  [Options.IsIntraforest] No
2000-11-20 12:21:13  [Options.Logfile] E:\Program Files\Active Directory Migration Tool\Logs\Migration.log
2000-11-20 12:21:13  [Options.MaxThreads] 20
2000-11-20 12:21:13  [Options.SourceDomain] HAY-BUV
2000-11-20 12:21:13  [Options.SourceDomainDns] hay-buv.nttest.microsoft.com
2000-11-20 12:21:13  [Options.TargetDomain] HAY-BUV-MPO
2000-11-20 12:21:13  [Options.TargetDomainDns] hay-buv-mpo.nttest.microsoft.com
2000-11-20 12:21:13  [Options.Wizard] reporting
2000-11-20 12:21:13  [PlugIn] <Empty>
2000-11-20 12:21:13  [PlugIn.0] None
2000-11-20 12:21:13  [Reports] <Empty>
2000-11-20 12:21:13  [Reports.AccountReferences] No
2000-11-20 12:21:13  [Reports.Directory] E:\Program Files\Active Directory Migration Tool\Reports
2000-11-20 12:21:13  [Reports.ExpiredComputers] No
2000-11-20 12:21:13  [Reports.Generate] Yes
2000-11-20 12:21:13  [Reports.MigratedAccounts] No
2000-11-20 12:21:13  [Reports.MigratedComputers] Yes
2000-11-20 12:21:13  [Reports.MigratedComputers.TimeGenerated] 974751673
2000-11-20 12:21:13  [Reports.NameConflicts] No
2000-11-20 12:21:13  [Security] <Empty>
2000-11-20 12:21:13  [Security.TranslateContainers] 

Expired Computer Accounts

2000-11-20 12:22:49 VarSet
2000-11-20 12:22:49 Case Sensitive: Yes, Indexed: Yes
2000-11-20 12:22:49 User Data ( 25 ) items
2000-11-20 12:22:49  [] <Empty>
2000-11-20 12:22:49  [GatherInformation] Yes
2000-11-20 12:22:49  [Options] <Empty>
2000-11-20 12:22:49  [Options.AppendToLogs] Yes
2000-11-20 12:22:49  [Options.DispatchLog] E:\Program Files\Active Directory Migration Tool\Logs\dispatch.log
2000-11-20 12:22:49  [Options.IsIntraforest] No
2000-11-20 12:22:49  [Options.Logfile] E:\Program Files\Active Directory Migration Tool\Logs\Migration.log
2000-11-20 12:22:49  [Options.MaxThreads] 20
2000-11-20 12:22:49  [Options.SourceDomain] HAY-BUV
2000-11-20 12:22:49  [Options.SourceDomainDns] hay-buv.nttest.microsoft.com
2000-11-20 12:22:49  [Options.TargetDomain] HAY-BUV-MPO
2000-11-20 12:22:49  [Options.TargetDomainDns] hay-buv-mpo.nttest.microsoft.com
2000-11-20 12:22:49  [Options.Wizard] reporting
2000-11-20 12:22:49  [PlugIn] <Empty>
2000-11-20 12:22:49  [PlugIn.0] None
2000-11-20 12:22:49  [Reports] <Empty>
2000-11-20 12:22:49  [Reports.AccountReferences] No
2000-11-20 12:22:49  [Reports.Directory] E:\Program Files\Active Directory Migration Tool\Reports
2000-11-20 12:22:49  [Reports.ExpiredComputers] Yes
2000-11-20 12:22:49  [Reports.ExpiredComputers.TimeGenerated] 974751769
2000-11-20 12:22:49  [Reports.Generate] Yes
2000-11-20 12:22:49  [Reports.MigratedAccounts] No
2000-11-20 12:22:49  [Reports.MigratedComputers] No
2000-11-20 12:22:49  [Reports.NameConflicts] No
2000-11-20 12:22:49  [Security] <Empty>
2000-11-20 12:22:49  [Security.TranslateContainers] 

Account Reference

2000-11-20 12:25:16 VarSet
2000-11-20 12:25:16 Case Sensitive: Yes, Indexed: Yes
2000-11-20 12:25:16 User Data ( 43 ) items
2000-11-20 12:25:16  [] <Empty>
2000-11-20 12:25:16  [Accounts] <Empty>
2000-11-20 12:25:16  [Accounts.0] HAY-BUV3-DC1
2000-11-20 12:25:16  [Accounts.0.TargetName] 
2000-11-20 12:25:16  [Accounts.0.Type] computer
2000-11-20 12:25:16  [Accounts.1] HB-RES-MEM
2000-11-20 12:25:16  [Accounts.1.TargetName] 
2000-11-20 12:25:16  [Accounts.1.Type] computer
2000-11-20 12:25:16  [Accounts.NumItems] 2
2000-11-20 12:25:16  [GatherInformation] Yes
2000-11-20 12:25:16  [Options] <Empty>
2000-11-20 12:25:16  [Options.AppendToLogs] Yes
2000-11-20 12:25:16  [Options.Credentials] <Empty>
2000-11-20 12:25:16  [Options.Credentials.Domain] HAY-BUV
2000-11-20 12:25:16  [Options.Credentials.Password] xyz
2000-11-20 12:25:16  [Options.Credentials.UserName] Administrator
2000-11-20 12:25:16  [Options.DispatchLog] E:\Program Files\Active Directory Migration Tool\Logs\dispatch.log
2000-11-20 12:25:16  [Options.IsIntraforest] No
2000-11-20 12:25:16  [Options.Logfile] E:\Program Files\Active Directory Migration Tool\Logs\Migration.log
2000-11-20 12:25:16  [Options.MaxThreads] 20
2000-11-20 12:25:16  [Options.SourceDomain] HAY-BUV
2000-11-20 12:25:16  [Options.SourceDomainDns] hay-buv.nttest.microsoft.com
2000-11-20 12:25:16  [Options.TargetDomain] HAY-BUV-MPO
2000-11-20 12:25:16  [Options.TargetDomainDns] hay-buv-mpo.nttest.microsoft.com
2000-11-20 12:25:16  [Options.Wizard] reporting
2000-11-20 12:25:16  [PlugIn] <Empty>
2000-11-20 12:25:16  [PlugIn.0] None
2000-11-20 12:25:16  [Reports] <Empty>
2000-11-20 12:25:16  [Reports.AccountReferences] Yes
2000-11-20 12:25:16  [Reports.AccountReferences.TimeGenerated] 974751916
2000-11-20 12:25:16  [Reports.Directory] E:\Program Files\Active Directory Migration Tool\Reports
2000-11-20 12:25:16  [Reports.ExpiredComputers] No
2000-11-20 12:25:16  [Reports.Generate] Yes
2000-11-20 12:25:16  [Reports.MigratedAccounts] No
2000-11-20 12:25:16  [Reports.MigratedComputers] No
2000-11-20 12:25:16  [Reports.NameConflicts] No
2000-11-20 12:25:16  [Security] <Empty>
2000-11-20 12:25:16  [Security.TranslateContainers] 
2000-11-20 12:25:16  [Servers] <Empty>
2000-11-20 12:25:16  [Servers.0] \\HAY-BUV3-DC1
2000-11-20 12:25:16  [Servers.0.MigrateOnly] No
2000-11-20 12:25:16  [Servers.1] \\HB-RES-MEM
2000-11-20 12:25:16  [Servers.1.MigrateOnly] No
2000-11-20 12:25:16  [Servers.NumItems] 2

Account Name Conflict

2000-11-20 12:40:05 VarSet
2000-11-20 12:40:05 Case Sensitive: Yes, Indexed: Yes
2000-11-20 12:40:05 User Data ( 25 ) items
2000-11-20 12:40:05  [] <Empty>
2000-11-20 12:40:05  [GatherInformation] Yes
2000-11-20 12:40:05  [Options] <Empty>
2000-11-20 12:40:05  [Options.AppendToLogs] Yes
2000-11-20 12:40:05  [Options.DispatchLog] E:\Program Files\Active Directory Migration Tool\Logs\dispatch.log
2000-11-20 12:40:05  [Options.IsIntraforest] No
2000-11-20 12:40:05  [Options.Logfile] E:\Program Files\Active Directory Migration Tool\Logs\Migration.log
2000-11-20 12:40:05  [Options.MaxThreads] 20
2000-11-20 12:40:05  [Options.SourceDomain] HAY-BUV
2000-11-20 12:40:05  [Options.SourceDomainDns] hay-buv.nttest.microsoft.com
2000-11-20 12:40:05  [Options.TargetDomain] HAY-BUV-MPO
2000-11-20 12:40:05  [Options.TargetDomainDns] hay-buv-mpo.nttest.microsoft.com
2000-11-20 12:40:05  [Options.Wizard] reporting
2000-11-20 12:40:05  [PlugIn] <Empty>
2000-11-20 12:40:05  [PlugIn.0] None
2000-11-20 12:40:05  [Reports] <Empty>
2000-11-20 12:40:05  [Reports.AccountReferences] No
2000-11-20 12:40:05  [Reports.Directory] E:\Program Files\Active Directory Migration Tool\Reports
2000-11-20 12:40:05  [Reports.ExpiredComputers] No
2000-11-20 12:40:05  [Reports.Generate] Yes
2000-11-20 12:40:05  [Reports.MigratedAccounts] No
2000-11-20 12:40:05  [Reports.MigratedComputers] No
2000-11-20 12:40:05  [Reports.NameConflicts] Yes
2000-11-20 12:40:05  [Reports.NameConflicts.TimeGenerated] 974752805
2000-11-20 12:40:05  [Security] <Empty>
2000-11-20 12:40:05  [Security.TranslateContainers] 

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\varsetsecurity.h ===
#pragma once

#include "VarSetBase.h"


//---------------------------------------------------------------------------
// VarSet Security Class
//---------------------------------------------------------------------------


class CVarSetSecurity : public CVarSet
{
public:

	CVarSetSecurity(CVarSet& rVarSet) :
		CVarSet(rVarSet),
		m_strReplace(GET_STRING(IDS_Replace)),
		m_strAdd(GET_STRING(IDS_Add)),
		m_strRemove(GET_STRING(IDS_Remove))
	{
	}

	//

	void SetGatherInformation(bool bGather)
	{
		Put(DCTVS_Security_GatherInformation, bGather);
	}

	void SetTranslateContainers(bool bTranslate)
	{
		if (bTranslate)
		{
			Put(DCTVS_Security_TranslateContainers, true);
		}
		else
		{
			Put(DCTVS_Security_TranslateContainers, (LPCTSTR)NULL);
		}
	}

	void SetTranslateFiles(bool bTranslate)
	{
		Put(DCTVS_Security_TranslateFiles, bTranslate);
	}

	void SetTranslateLocalGroups(bool bTranslate)
	{
		Put(DCTVS_Security_TranslateLocalGroups, bTranslate);
	}

	void SetTranslatePrinters(bool bTranslate)
	{
		Put(DCTVS_Security_TranslatePrinters, bTranslate);
	}

	void SetTranslateRegistry(bool bTranslate)
	{
		Put(DCTVS_Security_TranslateRegistry, bTranslate);
	}

	void SetTranslateShares(bool bTranslate)
	{
		Put(DCTVS_Security_TranslateShares, bTranslate);
	}

	void SetTranslateUserProfiles(bool bTranslate)
	{
		Put(DCTVS_Security_TranslateUserProfiles, bTranslate);
	}

	void SetTranslateUserRights(bool bTranslate)
	{
		Put(DCTVS_Security_TranslateUserRights, bTranslate);
	}

	void SetTranslationOption(long lOption)
	{
		LPCTSTR pszOption;

		switch (lOption)
		{
			case admtTranslateReplace:
				pszOption = m_strReplace;
				break;
			case admtTranslateAdd:
				pszOption = m_strAdd;
				break;
			case admtTranslateRemove:
				pszOption = m_strRemove;
				break;
			default:
				pszOption = NULL;
				break;
		}

		Put(DCTVS_Security_TranslationMode, pszOption);
	}

protected:

	_bstr_t m_strReplace;
	_bstr_t m_strAdd;
	_bstr_t m_strRemove;
};


//---------------------------------------------------------------------------
// Validation Functions
//---------------------------------------------------------------------------


inline bool IsTranslationOptionValid(long lOption)
{
	return ((lOption >= admtTranslateReplace) && (lOption <= admtTranslateRemove));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\script\varsetservers.h ===
#pragma once

#include "VarSetBase.h"


//---------------------------------------------------------------------------
// VarSet Servers Class
//---------------------------------------------------------------------------


class CVarSetServers : public CVarSet
{
public:

	CVarSetServers(const CVarSet& rVarSet) :
		CVarSet(rVarSet),
		m_lIndex(0)
	{
	}

	long GetCount()
	{
		return m_lIndex;
	}

	void AddServer(_bstr_t strServer, _bstr_t strServerDns, bool bMigrateOnly, bool bMoveToTarget, bool bReboot, long lRebootDelay)
    {
        _TCHAR szValueBase[64];
        _TCHAR szValueName[128];

        _stprintf(szValueBase, _T("Servers.%ld"), m_lIndex);

        // ADsPath
        // ADMT expects computer name to be prefixed with '\\'

        Put(szValueBase, _T("\\\\") + strServer);

        // DNS name

        if (strServerDns.length())
        {
            _tcscpy(szValueName, szValueBase);
            _tcscat(szValueName, _T(".DnsName"));

            Put(szValueName, _T("\\\\") + strServerDns);
        }

        // migrate only

        _tcscpy(szValueName, szValueBase);
        _tcscat(szValueName, _T(".MigrateOnly"));

        Put(szValueName, bMigrateOnly);

        // move to target

        _tcscpy(szValueName, szValueBase);
        _tcscat(szValueName, _T(".MoveToTarget"));

        Put(szValueName, bMoveToTarget);

        // reboot

        _tcscpy(szValueName, szValueBase);
        _tcscat(szValueName, _T(".Reboot"));

        Put(szValueName, bReboot);

        // reboot delay

        _tcscpy(szValueName, szValueBase);
        _tcscat(szValueName, _T(".RebootDelay"));

        Put(szValueName, lRebootDelay * 60L);

        //

        Put(DCTVS_Servers_NumItems, ++m_lIndex);
    }

protected:

	long m_lIndex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\setup\admtmsi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by ADMTMSI.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE	1000
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		1000
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif

#define IDS_SETUP_UPGRADE_TITLE 1
#define IDS_SETUP_UPGRADE_MESSAGE  2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\setup\admtmsi\admtmsi.h ===
// ADMTMsi.h : main header file for the ADMTMSI DLL
//

#if !defined(AFX_ADMTMSI_H__BFA3C95E_AF45_4B19_B62D_0D2927CB826C__INCLUDED_)
#define AFX_ADMTMSI_H__BFA3C95E_AF45_4B19_B62D_0D2927CB826C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CADMTMsiApp
// See ADMTMsi.cpp for the implementation of this class
//

class CADMTMsiApp : public CWinApp
{
public:
	CADMTMsiApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CADMTMsiApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CADMTMsiApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADMTMSI_H__BFA3C95E_AF45_4B19_B62D_0D2927CB826C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\setup\admtmsi\admtmsi.cpp ===
// ADMTMsi.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <stdio.h>
#include <windows.h> 
#include <winuser.h>
#include <lm.h>
#include <msi.h>
#include <msiquery.h>
#include "ADMTMsi.h"
#include "folders.h"

using namespace nsFolders;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CADMTMsiApp

BEGIN_MESSAGE_MAP(CADMTMsiApp, CWinApp)
	//{{AFX_MSG_MAP(CADMTMsiApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CADMTMsiApp construction

CADMTMsiApp::CADMTMsiApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CADMTMsiApp object

CADMTMsiApp theApp;
HWND installWnd = 0;

/********************
 * Helper Functions *
 ********************/


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 25 JAN 2001                                                 *
 *                                                                   *
 *     This function is a callback function used by GetWndFromInstall*
 * to compare titles and store the found HWND globally.              *
 *                                                                   *
 *********************************************************************/

//BEGIN CheckTitle
BOOL CALLBACK CheckTitle(HWND hwnd, LPARAM lParam)
{
/* local variables */
   WCHAR		sText[MAX_PATH];
   WCHAR	  * pTitle;
   BOOL			bSuccess;
   int			len;

/* function body */
   pTitle = (WCHAR*)lParam; //get the title to compare

      //get the title of this window
   len = GetWindowText(hwnd, sText, MAX_PATH);

   if ((len) && (pTitle))
   {
	  if (wcsstr(sText, pTitle))
	  {
		 installWnd = hwnd;
	     return FALSE;
	  }
   }
   return TRUE;
}
//END CheckTitle


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 25 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for getting the HWND of the      *
 * current installation to be used to display a MessageBox tied to   *
 * the install GUI.                                                  *
 *                                                                   *
 *********************************************************************/

//BEGIN GetWndFromInstall
void GetWndFromInstall(MSIHANDLE hInstall)
{
/* local variables */
   WCHAR				szPropName[MAX_PATH];
   UINT					lret = ERROR_SUCCESS;
   WCHAR				sTitle[MAX_PATH];
   DWORD				nCount = MAX_PATH;

/* function body */
      //get the installation's title
   wcscpy(szPropName, L"ProductName");
   lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
   if (lret != ERROR_SUCCESS)
      wcscpy(sTitle, L"ADMT Password Migration DLL");

      //get the window handle for the install GUI
   EnumChildWindows(NULL, CheckTitle, (LPARAM)sTitle);
   if (!installWnd)
	  installWnd = GetForegroundWindow();
}
//END GetWndFromInstall


/**********************
 * exported functions *
 **********************/


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 DEC 2000                                                 *
 *                                                                   *
 *     This function is responsible for saving current ADMT files in *
 * the %TEMP% folder prior to installing the new version.  The       *
 * installation will later call the restore function to restore the  *
 * saved file.  Currently this mechanism is used for saving the      *
 * current protar.mdb database.                                      *
 *                                                                   *
 *********************************************************************/

//BEGIN SaveCurrentFiles
UINT __stdcall SaveCurrentFiles(MSIHANDLE hInstall)
{
/* local constants */
   const int GETENVVAR_ERROR = 0;    //this indicates an error from the "GetEnvironmentVariable" function
   const WCHAR	sDCValue[2] = L"1";

/* local variables */
   WCHAR				tempdir[MAX_PATH];
   WCHAR				filename[MAX_PATH];
   WCHAR				newfilename[MAX_PATH];
   int					length;
   UINT					lret = ERROR_SUCCESS;
   WCHAR				sPropName[MAX_PATH];
   WCHAR				sDir[MAX_PATH];
   DWORD				nCount = MAX_PATH;
   HANDLE               hFile;
   WIN32_FIND_DATA      fDat;
   BOOL					bSuccess;

/* function body */
      //initialize these strings
   wcscpy(sPropName, L"INSTALLDIR");

      //if INSTALLDIR was not retrieved, set to default
   if (MsiGetProperty(hInstall, sPropName, sDir, &nCount) != ERROR_SUCCESS)
   {
      length = GetEnvironmentVariable( L"ProgramFiles", sDir, MAX_PATH);
      if (length != GETENVVAR_ERROR)
	     wcscat(sDir, L"\\Active Directory Migration Tool\\");
	  else
         return ERROR_INSTALL_FAILURE;
   }

      //find the temp dir
   length = GetTempPath(MAX_PATH, tempdir);
   if (length == 0)
   {
	  return ERROR_INSTALL_FAILURE;
   }

      //copy files to temp
   wcscpy(filename, sDir);
   wcscat(filename, L"Protar.mdb");
   wcscpy(newfilename, tempdir);
   wcscat(newfilename, L"Protar.mdb");
   hFile = FindFirstFile(filename, &fDat);
      //if found, copy it
   if (hFile != INVALID_HANDLE_VALUE)
   {
      FindClose(hFile);
      bSuccess = CopyFile(filename, newfilename, FALSE);

      if (bSuccess)
	  {
	     lret = ERROR_SUCCESS;
         wcscpy(sPropName, L"bMDBSaved");
         lret = MsiSetProperty(hInstall, sPropName, sDCValue);
	  }
      else
	     lret = ERROR_INSTALL_FAILURE;
   }
   else
   {
      wcscpy(sPropName, L"bMDBNotPresent");
      lret = MsiSetProperty(hInstall, sPropName, sDCValue);
   }


   return lret;
}
//END SaveCurrentFiles


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 DEC 2000                                                 *
 *                                                                   *
 *     This function is responsible for restoring ADMT files         *
 * previously stored by a call to "SaveCurrentFiles".  Currently this*
 * mechanism is used for saving the current protar.mdb database.     *
 *                                                                   *
 *********************************************************************/

//BEGIN RestoreFiles
UINT __stdcall RestoreFiles(MSIHANDLE hInstall)
{
/* local constants */
   const int GETENVVAR_ERROR = 0;    //this indicates an error from the "GetEnvironmentVariable" function
   const WCHAR	sDCValue[2] = L"1";

/* local variables */
   WCHAR				sDir[MAX_PATH];
   WCHAR				tempdir[MAX_PATH];
   WCHAR				filename[MAX_PATH];
   WCHAR				newfilename[MAX_PATH];
   UINT					lret = ERROR_SUCCESS;
   BOOL					bSuccess;
   WCHAR				sPropName[MAX_PATH];
   DWORD				nCount = MAX_PATH;
   int					length;

/* function body */
      //get the dir where we saved the files previously
   wcscpy(sPropName, L"INSTALLDIR");

      //if not retrieved, set to default
   if (MsiGetProperty(hInstall, sPropName, sDir, &nCount) != ERROR_SUCCESS)
   {
      length = GetEnvironmentVariable( L"ProgramFiles", sDir, MAX_PATH);
      if (length != GETENVVAR_ERROR)
	     wcscat(sDir, L"\\Active Directory Migration Tool\\");
	  else
         return ERROR_INSTALL_FAILURE;
   }

         //get the dir where we saved the files previously
   length = GetTempPath(MAX_PATH, tempdir);
   if (length == 0)
   {
	  return ERROR_INSTALL_FAILURE;
   }


      //copy files back
   wcscpy(filename, tempdir);
   wcscat(filename, L"Protar.mdb");
   wcscpy(newfilename, sDir);
   wcscat(newfilename, L"Protar.mdb");
   bSuccess = CopyFile(filename, newfilename, FALSE);

   if (bSuccess)
   {
      wcscpy(sPropName, L"bMDBRestored");
      lret = MsiSetProperty(hInstall, sPropName, sDCValue);

      DeleteFile(filename);
   }
   else
   {
   	  lret = ERROR_INSTALL_FAILURE;
   }
 
   return lret;
}
//END RestoreFiles

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 12 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for displaying a message box.    *
 *                                                                   *
 *********************************************************************/

//BEGIN DisplayExiting
UINT __stdcall DisplayExiting(MSIHANDLE hInstall)
{
/* local variables */
   WCHAR				sPropName[MAX_PATH];
   UINT					lret = ERROR_SUCCESS;
   WCHAR				sTitle[MAX_PATH] = L"";
   WCHAR				sMsg[MAX_PATH] = L"";
   DWORD				nCount = MAX_PATH;

/* function body */
      //initialize these strings
   wcscpy(sPropName, L"bMDBSaved");

      //if this is not a DC, get its messages
   if (MsiGetProperty(hInstall, sPropName, sMsg, &nCount) == ERROR_SUCCESS)
   {
      if (!wcscmp(sMsg, L"0"))
	  {
            //get the leave messagebox msg string and title for not being able to save protar.mdb
         wcscpy(sPropName, L"MDBLeaveMsg");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sMsg, L"ADMT's internal database, protar.mdb, could not be saved. The installation cannot continue.");
        
         wcscpy(sPropName, L"MDBLeaveTitle");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sTitle, L"Protar.mdb Not Saved!");
	  }
	  else
	  {
            //get the leave messagebox msg string and title for not being able to restore protar.mdb
         wcscpy(sPropName, L"MDB2LeaveMsg");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
         if (lret != ERROR_SUCCESS)
		 {
            wcscpy(sMsg, L"ADMT's internal database, protar.mdb, could not be restored. Manually restore");
		    wcscat(sMsg, L" it from the, environment variable, TEMP directory.");
		 }
        
         wcscpy(sPropName, L"MDB2LeaveTitle");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sTitle, L"Protar.mdb Not Restored!");
	  }
   }

   GetWndFromInstall(hInstall);
   MessageBox(installWnd, sMsg, sTitle, MB_ICONSTOP | MB_OK);
   return lret;
}
//END DisplayExiting


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 14 JAN 2000                                                 *
 *                                                                   *
 *     This function is responsible for displaying a message box.    *
 *                                                                   *
 *********************************************************************/

//BEGIN IsUpgrade
UINT __stdcall IsUpgrade(MSIHANDLE hInstall)
{
/* local constants */
   const int GETENVVAR_ERROR = 0;    //this indicates an error from the "GetEnvironmentVariable" function
   const WCHAR	sExit[2] = L"1";

/* local variables */
   WCHAR				sPropName[MAX_PATH];
   UINT					lret = ERROR_SUCCESS;
   WCHAR				sTitle[MAX_PATH] = L"";
   WCHAR				sMsg[MAX_PATH] = L"";
   WCHAR				sDir[MAX_PATH] = L"";
   WCHAR				sKey[MAX_PATH] = L"";
   DWORD				nCount = MAX_PATH;
   long					lrtn = ERROR_SUCCESS;
   HKEY					hADMTKey;
   int					length;

/* function body */
   /* see if ADMT V1.0 is installed by looking at the registry and find
      out where it is installed at */
      
    bool bNewVersionInstalled = false;
    bool bToUpgrade = false;  // indicates whether to check upgrade or not
    bool bADMTKeyOpened = false;

    // open the ADMT Registry key under Software\Microsoft and check RegistryUpdated key value
    // if the RegistryUpdated value exists and is REG_DWORD, the new version is installed
    lret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_ADMT, 0, KEY_READ, &hADMTKey);
    if (lret == ERROR_SUCCESS)
    {
        DWORD type;
        DWORD value;
        DWORD valueSize = sizeof(value);
        lret = RegQueryValueEx(hADMTKey, REGVAL_REGISTRYUPDATED, NULL, &type, (LPBYTE)&value, &valueSize);

        if (lret != ERROR_SUCCESS)
        {
            lret = ERROR_SUCCESS;   // we ignore all errors
        }
        else if (type == REG_DWORD)
        {
            bNewVersionInstalled = true;
        }
        RegCloseKey(hADMTKey);
    }
    else if (lret == ERROR_FILE_NOT_FOUND)
    {
        // if this key cannot be found, it is Ok
        lret = ERROR_SUCCESS;
    }

    // if the new version is not installed, it is necessary to check whether to upgrade
    if (lret == ERROR_SUCCESS && !bNewVersionInstalled)
    {
        lret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_MCSADMT, 0, KEY_READ, &hADMTKey);
        if (lret == ERROR_SUCCESS)
        {
            // we need to attempt to upgrade from v1 to v2
            bToUpgrade = true;
            bADMTKeyOpened = true;
        }
        else if (lret == ERROR_FILE_NOT_FOUND)
        {
            lret = ERROR_SUCCESS;
        }
    }

    // check if to upgrade
    if (bToUpgrade)
    {
          //get the current install path
       wcscpy(sPropName, L"Directory");
       nCount = MAX_PATH;
       if (RegQueryValueEx(hADMTKey, sPropName, NULL, NULL, 
    	                   (LPBYTE)sDir, &nCount) != ERROR_SUCCESS)
       {
          length = GetEnvironmentVariable( L"ProgramFiles", sDir, MAX_PATH);
          if (length != GETENVVAR_ERROR)
          {
    	     wcscat(sDir, L"\\Active Directory Migration Tool\\");
    	     lret = ERROR_SUCCESS;
    	  }
    	  else
             lret = ERROR_INSTALL_FAILURE;

       }
       RegCloseKey(hADMTKey);
       bADMTKeyOpened = false;

       if (lret == ERROR_SUCCESS)
       {
            //now see if V1.0 is really installed (key exists)
            wcscpy(sKey, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{76789332-34CD-11D3-9E6A-00A0C9AFE10F}");
            lret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sKey, 0, KEY_READ, &hADMTKey);
            if (lret == ERROR_SUCCESS)
            {
                 bADMTKeyOpened = true;
                
                //get the upgrade messagebox msg string and title
                AFX_MANAGE_STATE(AfxGetStaticModuleState());  // make sure we can get the right resource
                CString szMsg;
                CString szTitle;
                wcscpy(sPropName, L"UpgradeMsg");
                nCount = MAX_PATH;
                lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
                if (lret != ERROR_SUCCESS)
                    szMsg.LoadString(IDS_SETUP_UPGRADE_MESSAGE);
                else
                    szMsg = sMsg;
                        
                nCount = MAX_PATH;
                wcscpy(sPropName, L"UpgradeTitle");
                lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
                if (lret != ERROR_SUCCESS)
                    szTitle.LoadString(IDS_SETUP_UPGRADE_TITLE);
                else
                    szTitle = sTitle;

                //if they want to upgrade, save the install path
                GetWndFromInstall(hInstall);
                if (MessageBox(installWnd, szMsg, szTitle, MB_ICONQUESTION | MB_YESNO) == IDYES)
                {
                    wcscpy(sPropName, L"INSTALLDIR");
                    lret = MsiSetProperty(hInstall, sPropName, sDir);
                }
                else //else, set the flag to exit the install
                {
                    wcscpy(sPropName, L"bUpgradeExit");
                    lret = MsiSetProperty(hInstall, sPropName, sExit);
                }
            }
            else if (lret == ERROR_FILE_NOT_FOUND)
                lret = ERROR_SUCCESS;
       }
    }

    // if the ADMT key is still opened, close it
    if (bADMTKeyOpened)
        RegCloseKey(hADMTKey);
    
    return lret;
}
//END IsUpgrade
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\setup\admtmsi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ADMTMsi.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\setup\admtmsi\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__45FD9CD9_F9CE_4A4D_9BED_ACC54B3C5F56__INCLUDED_)
#define AFX_STDAFX_H__45FD9CD9_F9CE_4A4D_9BED_ACC54B3C5F56__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC Automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__45FD9CD9_F9CE_4A4D_9BED_ACC54B3C5F56__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\setup\pwdmsi\pwdmsi.cpp ===
// PwdMsi.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include <winuser.h>
#include <stdio.h>
#include <lm.h>
#include <msi.h>
#include <msiquery.h>
#include <comdef.h>
#include <commdlg.h>
#include <Dsgetdc.h>
#include <eh.h>
#include "pwdfuncs.h"
#include "ADMTCrypt.h"
#include "PwdMsi.h"

bool b3DESNotInstalled = false;
bool bPESFileFound = false;
bool bPasswordNeeded = false;
HWND installWnd = 0;

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}


// This is the constructor of a class that has been exported.
// see PwdMsi.h for the class definition
CPwdMsi::CPwdMsi()
{ 
	return; 
}


void LoadOLEAUT32OnNT4()
{
    static BOOL    bDone = FALSE;
    static HMODULE hDllOleAut32 = NULL;
    BOOL   bIsNT4 = FALSE;
    
    // only do this once
    if (!bDone)
    {
        bDone = TRUE;
        
        // test OS version
        DWORD rc = NERR_Success;
        SERVER_INFO_101 * servInfo = NULL;

         // Check version info
        rc = NetServerGetInfo(NULL, 101, (LPBYTE *)&servInfo);
        if (rc == NERR_Success)
        {
            bIsNT4 = (servInfo->sv101_version_major < 5) ? TRUE : FALSE;
          	NetApiBufferFree(servInfo);
        }

        // if it is NT4, load oleaut32.dll
        if (bIsNT4)
        {
            hDllOleAut32 = LoadLibrary(L"oleaut32.dll");
        }
    }
}
    
/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 25 JAN 2001                                                 *
 *                                                                   *
 *     This function is a callback function used by GetWndFromInstall*
 * to compare titles and store the found HWND globally.              *
 *                                                                   *
 *********************************************************************/

//BEGIN CheckTitle
BOOL CALLBACK CheckTitle(HWND hwnd, LPARAM lParam)
{
   // call LoadOLEAUT32OnNT4 to keep ref count of OLEAUT32
   // greater than zero
   LoadOLEAUT32OnNT4();
    
/* local variables */
   WCHAR		sText[MAX_PATH];
   WCHAR	  * pTitle;
   BOOL			bSuccess;
   int			len;

/* function body */
   pTitle = (WCHAR*)lParam; //get the title to compare

      //get the title of this window
   len = GetWindowText(hwnd, sText, MAX_PATH);

   if ((len) && (pTitle))
   {
	  if (wcsstr(sText, pTitle))
	  {
		 installWnd = hwnd;
	     return FALSE;
	  }
   }
   return TRUE;
}
//END CheckTitle


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 25 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for getting the HWND of the      *
 * current installation to be used to display a MessageBox tied to   *
 * the install GUI.                                                  *
 *                                                                   *
 *********************************************************************/

//BEGIN GetWndFromInstall
void GetWndFromInstall(MSIHANDLE hInstall)
{
   // call LoadOLEAUT32OnNT4 to keep ref count of OLEAUT32
   // greater than zero
   LoadOLEAUT32OnNT4();

/* local variables */
   WCHAR				szPropName[MAX_PATH];
   UINT					lret = ERROR_SUCCESS;
   WCHAR				sTitle[MAX_PATH];
   DWORD				nCount = MAX_PATH;

/* function body */
      //get the installation's title
   wcscpy(szPropName, L"ProductName");
   lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
   if (lret != ERROR_SUCCESS)
      wcscpy(sTitle, L"ADMT Password Migration DLL");

      //get the window handle for the install GUI
   EnumChildWindows(NULL, CheckTitle, (LPARAM)sTitle);
   if (!installWnd)
	  installWnd = GetForegroundWindow();
}
//END GetWndFromInstall

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 11 DEC 2000                                                 *
 *                                                                   *
 *     This function is responsible for retrieving a password        *
 * encryption key from the given path.                               *
 *                                                                   *
 *********************************************************************/

//BEGIN RetrieveAndStorePwdKey
bool RetrieveAndStorePwdKey(WCHAR * sPwd, _bstr_t sPath)
{
   // call LoadOLEAUT32OnNT4 to keep ref count of OLEAUT32
   // greater than zero
   LoadOLEAUT32OnNT4();

/* local variables */
   bool					bRetrieved = false;
   WCHAR			  * pDrive;
   HANDLE               hFile;
   WIN32_FIND_DATA      fDat;
   _variant_t           varData;

/* function body */
   hFile = FindFirstFile((WCHAR*)sPath, &fDat);
      //if found, retrieve and store the key
   if (hFile != INVALID_HANDLE_VALUE)
   {
      FindClose(hFile);
	  try
	  {
         bPESFileFound = true;
		    //get the data
         varData = GetDataFromFloppy((WCHAR*)sPath);
		 if (varData.vt == (VT_UI1 | VT_ARRAY))
		 {
		    long uUBound;
			LPBYTE pByte = NULL;
            SafeArrayAccessData(varData.parray,(void**)&pByte);
			BYTE byteKey = pByte[0];
            SafeArrayUnaccessData(varData.parray);

			   //the first byte tells us if this key is password encrypted
			   //if password needed, return and have install display the UI
			if (byteKey != 0)
			{
			   if (sPwd)
			   {
				     //try saving the key with this password
				  try
				  {
			         CSourceCrypt aCryptObj;  //create a crypt object

                        //try to store the key. If fails, it throws a com error caught below
                     aCryptObj.ImportEncryptionKey(varData, sPwd);
					 bRetrieved = true;
				  }
                  catch (_com_error& ce)
				  {
                        //if HES not installed, set flag
	                 if (ce.Error() == NTE_KEYSET_NOT_DEF)
	                    b3DESNotInstalled = true;
				  }
			   }
			   else
                  bPasswordNeeded = true;
			}
			else
			{
               bPasswordNeeded = false;
			   try
			   { 
			      CSourceCrypt aCryptObj;  //create a crypt object

			          //try to store the key. If fails, it throws a com error caught below
				  aCryptObj.ImportEncryptionKey(varData, NULL);
				  bRetrieved = true;
			   }
               catch (_com_error& ce)
			   {
                     //if HES not installed, set flag
	              if (ce.Error() == NTE_KEYSET_NOT_DEF)
	                 b3DESNotInstalled = true;
			   }
			}
		 }
	  }
	  catch (...)
	  {
	  }
   }

   return bRetrieved;
}
//END RetrieveAndStorePwdKey


/**********************
 * exported functions *
 **********************/

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 12 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for adding the PWMIG dll name to *
 * the Multi-string value "Notification Packages" under the Lsa key. *
 *                                                                   *
 *********************************************************************/

//BEGIN IsDC
PWDMSI_API UINT __stdcall IsDC(MSIHANDLE hInstall)
{
   // call LoadOLEAUT32OnNT4 to keep ref count of OLEAUT32
   // greater than zero
   LoadOLEAUT32OnNT4();

/* local constants */
   const WCHAR	sDCValue[2] = L"1";

/* local variables */
   bool					bDC = false;
   DWORD				dwLevel = 101;
   LPSERVER_INFO_101	pBuf = NULL;
   NET_API_STATUS		nStatus;
   WCHAR				szPropName[MAX_PATH] = L"DC";
   UINT					lret = ERROR_SUCCESS;

/* function body */

   nStatus = NetServerGetInfo(NULL,
                              dwLevel,
                              (LPBYTE *)&pBuf);
   if (nStatus == NERR_Success)
   {
      //
      // Check for the type of server.
      //
      if ((pBuf->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
         (pBuf->sv101_type & SV_TYPE_DOMAIN_BAKCTRL))
         bDC = true;

      NetApiBufferFree(pBuf);
   }

   if (bDC)
      lret = MsiSetProperty(hInstall, szPropName, sDCValue);

   return lret;
}
//END IsDC

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 12 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for displaying a message box.    *
 *                                                                   *
 *********************************************************************/

//BEGIN DisplayExiting
PWDMSI_API UINT __stdcall DisplayExiting(MSIHANDLE hInstall)
{
   // call LoadOLEAUT32OnNT4 to keep ref count of OLEAUT32
   // greater than zero
   LoadOLEAUT32OnNT4();

/* local variables */
   WCHAR				sPropName[MAX_PATH];
   UINT					lret = ERROR_SUCCESS;
   WCHAR				sTitle[MAX_PATH];
   WCHAR				sMsg[MAX_PATH];
   DWORD				nCount = MAX_PATH;
   bool					bMsgGot = false;

/* function body */
      //get the DC property
   wcscpy(sPropName, L"DC");
      //if this is not a DC, get its messages
   if (MsiGetProperty(hInstall, sPropName, sMsg, &nCount) == ERROR_SUCCESS)
   {
      if (!wcscmp(sMsg, L"0"))
	  {
            //get the leave messagebox msg string and title for not being a DC
         wcscpy(sPropName, L"DCLeaveMsg");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sMsg, L"ADMT's Password Migration Filter DLL can only be installed on a DC, PDC, or BDC!");
        
         wcscpy(sPropName, L"DCLeaveTitle");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sTitle, L"Invalid Machine!");

	     bMsgGot = true;
	  }
   }
   
      //if this is a DC then see if the High Encryption pack was not installed
   if (!bMsgGot)
   {
         //get the HES flag property
      wcscpy(sPropName, L"b3DESNotInstalled");
      nCount = MAX_PATH;
         //if HEP is not installed, get its messages
      if (MsiGetProperty(hInstall, sPropName, sMsg, &nCount) == ERROR_SUCCESS)
	  {
         if (!wcscmp(sMsg, L"1"))
		 {
		       //get the leave messagebox msg string and title for not getting a key
            wcscpy(sPropName, L"HEPLeaveMsg");
            nCount = MAX_PATH;
            lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
            if (lret != ERROR_SUCCESS)
			{
               wcscpy(sMsg, L"The high encryption pack has not been installed on this machine.  ADMT's ");
			   wcscat(sMsg, L"Password Migration Filter DLL will not install without the high encryption pack.");
			}
        
            wcscpy(sPropName, L"HEPLeaveTitle");
            nCount = MAX_PATH;
            lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
            if (lret != ERROR_SUCCESS)
               wcscpy(sTitle, L"High Encryption Pack Required!");

			bMsgGot = true;
		 }
	  }
   }
   
/*      //see if an encryption key file was not found on a local drive
   if (!bMsgGot)
   {
         //get the File flag property
      wcscpy(sPropName, L"bPESFileNotFound");
      nCount = MAX_PATH;
         //if file not found, get its messages
      if (MsiGetProperty(hInstall, sPropName, sMsg, &nCount) == ERROR_SUCCESS)
	  {
         if (!wcscmp(sMsg, L"1"))
		 {
		       //get the leave messagebox msg string and title for not getting a key
            wcscpy(sPropName, L"PESLeaveMsg");
            nCount = MAX_PATH;
            lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
            if (lret != ERROR_SUCCESS)
			{
               wcscpy(sMsg, L"An encryption key file (.pes) could not be found on any of the floppy drives.");
			}
        
            wcscpy(sPropName, L"PESLeaveTitle");
            nCount = MAX_PATH;
            lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
            if (lret != ERROR_SUCCESS)
               wcscpy(sTitle, L"File Not Found!");

			bMsgGot = true;
		 }
	  }
   }
*/
      //else password was bad
   if (!bMsgGot)
   {
         //get the leave messagebox msg string and title for not getting a key
      wcscpy(sPropName, L"PwdLeaveMsg");
      nCount = MAX_PATH;
      lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
      if (lret != ERROR_SUCCESS)
	  {
         wcscpy(sMsg, L"The supplied password does not match this encryption key's password.  ADMT's ");
		 wcscat(sMsg, L"Password Migration Filter DLL will not install without a valid encryption key.");
	  }
        
      wcscpy(sPropName, L"PwdLeaveTitle");
      nCount = MAX_PATH;
      lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
      if (lret != ERROR_SUCCESS)
         wcscpy(sTitle, L"Invalid Password!");
   }

   GetWndFromInstall(hInstall);
   MessageBox(installWnd, sMsg, sTitle, MB_ICONSTOP | MB_OK);
   return lret;
}
//END DisplayExiting


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 20 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for trying to delete any files,  *
 * that will be installed, that may have been left around by previous*
 * installations.                                                    *
 *                                                                   *
 *********************************************************************/

//BEGIN DeleteOldFiles
PWDMSI_API UINT __stdcall DeleteOldFiles(MSIHANDLE hInstall)
{
   // call LoadOLEAUT32OnNT4 to keep ref count of OLEAUT32
   // greater than zero
   LoadOLEAUT32OnNT4();

/* local constants */
   const int GETENVVAR_ERROR = 0;    //this indicates an error from the "GetEnvironmentVariable" function

/* local variables */
   WCHAR				systemdir[MAX_PATH];
   WCHAR				filename[MAX_PATH];
   int					length;
   UINT					lret = ERROR_SUCCESS;

/* function body */
      //try deleting previously installed files
   length = GetEnvironmentVariable( L"windir", systemdir, MAX_PATH);
   if (length != GETENVVAR_ERROR)
   {
      wcscat(systemdir, L"\\system32\\");  //go from windir to winsysdir
	  wcscpy(filename, systemdir);
	  wcscat(filename, L"PwMig.dll");
	  DeleteFile(filename);

	  wcscpy(filename, systemdir);
	  wcscat(filename, L"mschapp.dll");
	  DeleteFile(filename);
   }

   return lret;
}
//END DeleteOldFiles

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 6 DEC 2000                                                  *
 *                                                                   *
 *     This function is responsible for displaying the necessary     *
 * dialogs to prompt for and retrieve a password encryption key off  *
 * of a floppy disk.  This key is placed on a floppy disk via a      *
 * command line option on the ADMT machine.                          *
 *                                                                   *
 *********************************************************************/

//BEGIN GetInstallEncryptionKey
PWDMSI_API UINT __stdcall GetInstallEncryptionKey(MSIHANDLE hInstall)
{
   // call LoadOLEAUT32OnNT4 to keep ref count of OLEAUT32
   // greater than zero
   LoadOLEAUT32OnNT4();

/* local constants */
   const int			ADRIVE_SIZE = 3;  //length of a drive in the string (i.e "a:\")

/* local variables */
   UINT					lret = ERROR_SUCCESS;
   WCHAR				szPropName[MAX_PATH];
   WCHAR				sTitle[MAX_PATH];
   WCHAR				sMsg[MAX_PATH];
   WCHAR				sTemp[MAX_PATH];
   DWORD				nCount = MAX_PATH;
   int					nRet;
   bool					bRetrieved = false;
   WCHAR				sRetrieved[2] = L"0";
   WCHAR				sFlagSet[2] = L"1";
   WCHAR				sFlagClear[2] = L"0";
   _bstr_t				sDrives;
   _bstr_t				sPath;
   WCHAR				sADrive[ADRIVE_SIZE+1];

/* function body */
      //if no path to file, return
   wcscpy(szPropName, L"SENCRYPTIONFILEPATH");
   lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
   if (lret != ERROR_SUCCESS)
      return lret;

   sPath = sMsg;  //save the given path
   _wcslwr(sMsg);  // convert the path to lower case for later comparison

   //get the drive of the given path
   wcsncpy(sADrive, sMsg, ADRIVE_SIZE);
   sADrive[ADRIVE_SIZE] = L'\0';

   //enumerate all local drives
   sDrives = EnumLocalDrives();
   _wcslwr(sDrives);  // convert local drives to lower case for later comparison

      //if the given file is not on a local drive, set a flag and return
   WCHAR* pFound = wcsstr(sDrives, sADrive);
    
   if ((!pFound) || (wcslen(sADrive) == 0) || (wcsstr(sMsg, L".pes") == NULL))
   {
	      //set the bad path flag
      wcscpy(szPropName, L"bBadKeyPath");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);

	     //if starts with "\\" then tell them it must be a local drive
      if ((!pFound) && (wcsstr(sMsg, L"\\\\") == sMsg))
	  {
	        //get the bad path messagebox msg string and title
         wcscpy(szPropName, L"BadDriveMsg");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
         if (lret != ERROR_SUCCESS)
		 {
            wcscpy(sMsg, L"The given path is not on a local drive and is therefore invalid.");
		    wcscat(sMsg, L"  Please supply the path to a valid encryption key file on a local drive.");
		 }
      
		 wcscpy(szPropName, L"BadPathTitle");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sTitle, L"Invalid Local Drive!");
	  }
	     //else if the given file does end with ".pes", tell them it must
      else if ((pFound) && (wcsstr(sMsg, L".pes") == NULL))
	  {
	        //get the bad file extension messagebox msg string
         wcscpy(szPropName, L"BadFileExtMsg");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
         if (lret != ERROR_SUCCESS)
		 {
            wcscpy(sMsg, L"The given file must be a valid encryption key file ending with the \".pes\" extension.");
		 }
      
		 wcscpy(szPropName, L"BadFileExtTitle");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sTitle, L"Invalid File Extension!");
	  }
	     //else, tell them it is not a local drive
      else
	  {
	        //get the bad path messagebox msg string and title
         wcscpy(szPropName, L"BadPathMsg");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, szPropName, sTemp, &nCount);
         if (lret != ERROR_SUCCESS)
		 {
            wcscpy(sTemp, L"The given drive, %s, is not a local drive and is therefore invalid.");
		    wcscat(sTemp, L"  Please supply the path to a valid encryption key file on a local drive.");
		 }
	     swprintf(sMsg, sTemp, sADrive);
      
		 wcscpy(szPropName, L"BadPathTitle");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sTitle, L"Invalid Local Drive!");
	  }
        
      GetWndFromInstall(hInstall);
      MessageBox(installWnd, sMsg, sTitle, MB_ICONSTOP | MB_OK);

      return lret;
   }
   else
   {
	      //else clear the bad path flag
      wcscpy(szPropName, L"bBadKeyPath");
      lret = MsiSetProperty(hInstall, szPropName, sFlagClear);
   }

      //try to retrieve the encryption key
   if (RetrieveAndStorePwdKey(NULL, sPath))
      wcscpy(sRetrieved, L"1");
   else if (bPasswordNeeded)
   {
      wcscpy(szPropName, L"bPwdNeeded");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);
   }

      //set the key retrieved flag
   wcscpy(szPropName, L"bKeyRetrieved");
   lret = MsiSetProperty(hInstall, szPropName, sRetrieved);

      //if file not found at the given path, prompt the user for a new one
   if (!bPESFileFound)
   {
	      //set the bad path flag
      wcscpy(szPropName, L"bBadKeyPath");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);

         //get the bad path messagebox msg string and title
      wcscpy(szPropName, L"PESLeaveMsg");
      nCount = MAX_PATH;
      lret = MsiGetProperty(hInstall, szPropName, sTemp, &nCount);
      if (lret != ERROR_SUCCESS)
	  {
         wcscpy(sTemp, L"The given encryption key file, %s, could not be found.");
		 wcscat(sTemp, L"  Please enter the path to a valid encryption key file.");
	  }
	  swprintf(sMsg, sTemp, (WCHAR*)sPath);
        
      wcscpy(szPropName, L"PESLeaveTitle");
      nCount = MAX_PATH;
      lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
      if (lret != ERROR_SUCCESS)
         wcscpy(sTitle, L"File Not Found!");

      GetWndFromInstall(hInstall);
      MessageBox(installWnd, sMsg, sTitle, MB_ICONSTOP | MB_OK);

      return lret;
   }

      //if HES is not installed, set that flag
   if (b3DESNotInstalled)
   {
      wcscpy(szPropName, L"b3DESNotInstalled");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);
   }

   return lret;
}
//END GetInstallEncryptionKey


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 12 SEPT 2000                                                *
 *                                                                   *
 *     This function is used by the installation routine and is      *
 * responsible for adding the PWMIG dll name to the Multi-string     *
 * value "Notification Packages" under the Lsa key.                  *
 *                                                                   *
 *********************************************************************/

//BEGIN AddToLsaNotificationPkgValue
PWDMSI_API UINT __stdcall AddToLsaNotificationPkgValue(MSIHANDLE hInstall)
{
   // call LoadOLEAUT32OnNT4 to keep ref count of OLEAUT32
   // greater than zero
   LoadOLEAUT32OnNT4();

/* local constants */
   const WCHAR sLsaKey[40] = L"SYSTEM\\CurrentControlSet\\Control\\Lsa";
   const WCHAR sLsaValue[25] = L"Notification Packages";
   const WCHAR sNewAddition[10] = L"PWMIG";

/* local variables */
   bool				bSuccess = false;
   bool				bFound = false;
   bool				bAlreadyThere = false;
   DWORD			rc;
   DWORD			type;   
   HKEY				hKey;
   WCHAR			sString[MAX_PATH];
   DWORD			len = sizeof(sString);
   WCHAR			sTemp[MAX_PATH];
   int				currentPos = 0;
   UINT				lret = ERROR_SUCCESS;

/* function body */
      //open the Lsa registry key
   rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     sLsaKey,
                     0,
                     KEY_ALL_ACCESS,
                     &hKey);
   if (rc == ERROR_SUCCESS)
   {
	     //get the current value string
      rc = RegQueryValueEx(hKey, sLsaValue, NULL, &type, (LPBYTE)sString, &len);      
      if ((rc == ERROR_SUCCESS) && (type == REG_MULTI_SZ))
	  {
         sString[MAX_PATH - 1] = L'\0';
	     
		    //copy each string in the multi-string until the end is reached
         while (!bFound)
		 {
			if (!wcscmp(sString+currentPos, sNewAddition))
			   bAlreadyThere = true;
		    wcscpy(sTemp+currentPos, sString+currentPos);
		    currentPos += wcslen(sTemp+currentPos) + 1;
		    if (sString[currentPos] == L'\0')
			   bFound = true;
		 }
		 if (!bAlreadyThere)
		 {
	           //now add our new text and terminate the string
			wcscpy(sTemp+currentPos, sNewAddition);
		    currentPos += wcslen(sNewAddition) + 1;
			sTemp[currentPos] = L'\0';

			   //save the new value in the registry
			len = (currentPos + 1) * sizeof(WCHAR);
            rc = RegSetValueEx(hKey, sLsaValue, 0, type, (LPBYTE)sTemp, len);
			if (rc == ERROR_SUCCESS)
			   bSuccess = true;
		 }
	  }
      RegCloseKey(hKey);
   }
   
      //tell installer we want to reboot
   MsiSetMode(hInstall, MSIRUNMODE_REBOOTATEND, TRUE);

   return lret;
}
//END AddToLsaNotificationPkgValue

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 12 SEPT 2000                                                *
 *                                                                   *
 *     This function is used by the installation routine and is      *
 * responsible for deleting the PWMIG dll name from the Multi-string *
 * value "Notification Packages" under the Lsa key.                  *
 *                                                                   *
 *********************************************************************/

//BEGIN DeleteFromLsaNotificationPkgValue
PWDMSI_API UINT __stdcall DeleteFromLsaNotificationPkgValue(MSIHANDLE hInstall)
{
   // call LoadOLEAUT32OnNT4 to keep ref count of OLEAUT32
   // greater than zero
   LoadOLEAUT32OnNT4();

/* local constants */
   const WCHAR sLsaKey[40] = L"SYSTEM\\CurrentControlSet\\Control\\Lsa";
   const WCHAR sLsaValue[25] = L"Notification Packages";
   const WCHAR sNewAddition[10] = L"PWMIG";

/* local variables */
   bool				bSuccess = false;
   DWORD			rc;
   DWORD			type;
   HKEY				hKey;
   WCHAR			sString[MAX_PATH];
   DWORD			len = sizeof(sString);
   WCHAR			sTemp[MAX_PATH];
   int				currentPos = 0;
   int				tempPos = 0;
   UINT				lret = ERROR_SUCCESS;

/* function body */
      //open the Lsa registry key
   rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     sLsaKey,
                     0,
                     KEY_ALL_ACCESS,
                     &hKey);
   if (rc == ERROR_SUCCESS)
   {
	     //get the current value string
      rc = RegQueryValueEx(hKey, sLsaValue, NULL, &type, (LPBYTE)sString, &len);      
      if ((rc == ERROR_SUCCESS) && (type == REG_MULTI_SZ))
	  {
         sString[MAX_PATH - 1] = L'\0';
         
		    //copy each string in the multi-string until the desired string
         while (sString[currentPos] != L'\0')
		 {
			  //if not string wanted, copy to destination string
		    if (wcscmp(sString+currentPos, sNewAddition))
			{
		       wcscpy(sTemp+tempPos, sString+currentPos);
			   tempPos += wcslen(sString+currentPos) + 1;
		       currentPos += wcslen(sString+currentPos) + 1;
			}
			else //else this is our string, skip it
			{
				currentPos += wcslen(sString+currentPos) + 1;
			}
		 }
		    //add the ending NULL
		 sTemp[tempPos] = L'\0';

		    //save the new value in the registry
		 len = (tempPos + 1) * sizeof(WCHAR);
         rc = RegSetValueEx(hKey, sLsaValue, 0, type, (LPBYTE)sTemp, len);
		 if (rc == ERROR_SUCCESS)
		    bSuccess = true;
	  }
      RegCloseKey(hKey);
   }

      //tell installer we want to reboot
   MsiSetMode(hInstall, MSIRUNMODE_REBOOTATEND, TRUE);

   return lret;
}
//END DeleteFromLsaNotificationPkgValue


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 23 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for displaying the necessary     *
 * dialogs to prompt for and retrieve a password encryption key off  *
 * of a floppy disk.  This key is placed on a floppy disk via a      *
 * command line option on the ADMT machine.                          *
 *                                                                   *
 *********************************************************************/

//BEGIN FinishWithPassword
PWDMSI_API UINT __stdcall FinishWithPassword(MSIHANDLE hInstall)
{
   // call LoadOLEAUT32OnNT4 to keep ref count of OLEAUT32
   // greater than zero
   LoadOLEAUT32OnNT4();

/* local variables */
   UINT					lret = ERROR_SUCCESS;
   WCHAR				szPropName[MAX_PATH];
   WCHAR				sPwd[MAX_PATH];
   WCHAR				sMsg[MAX_PATH];
   DWORD				nCount = MAX_PATH;
   _bstr_t				sPath;
   WCHAR				sFlagSet[2] = L"1";

/* function body */
      //get the password to try
   wcscpy(szPropName, L"sKeyPassword");
   lret = MsiGetProperty(hInstall, szPropName, sPwd, &nCount);
   if (lret != ERROR_SUCCESS)
      return lret;

      //if no path to file, return
   nCount = MAX_PATH;
   wcscpy(szPropName, L"SENCRYPTIONFILEPATH");
   lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
   if (lret != ERROR_SUCCESS)
      return lret;

   sPath = sMsg;  //save the given path

      //try saving the key with this password
   if (RetrieveAndStorePwdKey(sPwd, sPath))
   {
      wcscpy(szPropName, L"bKeyRetrieved");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);
   }

      //if HES is not installed, set that flag
   if (b3DESNotInstalled)
   {
      wcscpy(szPropName, L"b3DESNotInstalled");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);
   }

/*      //if file not found on the floppy, set that flag
   if (!bPESFileFound)
   {
      wcscpy(szPropName, L"bPESFileNotFound");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);
   }
*/
   return lret;
}
//END FinishWithPassword

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 24 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for displaying a MesasgeBox      *
 * the user that the passwords did not match.                        *
 *                                                                   *
 *********************************************************************/

//BEGIN PwdsDontMatch
PWDMSI_API UINT __stdcall PwdsDontMatch(MSIHANDLE hInstall)
{
   // call LoadOLEAUT32OnNT4 to keep ref count of OLEAUT32
   // greater than zero
   LoadOLEAUT32OnNT4();

/* local variables */
   UINT					lret = ERROR_SUCCESS;
   WCHAR				szPropName[MAX_PATH];
   WCHAR				sMsg[MAX_PATH];
   WCHAR				sTitle[MAX_PATH];
   DWORD				nCount = MAX_PATH;
   WCHAR				sEmpty[2] = L"";

/* function body */
      //get the message to display
   wcscpy(szPropName, L"PwdMatchMsg");
   lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
   if (lret != ERROR_SUCCESS)
      wcscpy(sMsg, L"The passwords entered do not match each other.  Please try again!");
        
      //get the title string
   nCount = MAX_PATH;
   wcscpy(szPropName, L"PwdMatchTitle");
   lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
   if (lret != ERROR_SUCCESS)
      wcscpy(sTitle, L"Password Mismatch");

   GetWndFromInstall(hInstall);
   MessageBox(installWnd, sMsg, sTitle, MB_ICONSTOP | MB_OKCANCEL);
   return lret;
}
//END PwdsDontMatch

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 28 MAR 2001                                                 *
 *                                                                   *
 *     This function is responsible for displaying a browse dialog to*
 * aid the install user in finding a password encryption key file,   *
 * which has a .PES extension.                                       *
 *                                                                   *
 *********************************************************************/

//BEGIN BrowseForEncryptionKey
PWDMSI_API UINT __stdcall BrowseForEncryptionKey(MSIHANDLE hInstall)
{
   // call LoadOLEAUT32OnNT4 to keep ref count of OLEAUT32
   // greater than zero
   LoadOLEAUT32OnNT4();

/* local variables */
   UINT					lret = ERROR_SUCCESS;
   WCHAR				szPropName[MAX_PATH];
   WCHAR				sMsg[2*MAX_PATH];
   WCHAR				sFile[2*MAX_PATH];
   DWORD				nCount = 2*MAX_PATH;
   _bstr_t				sPath = L"";
   int					nRet;
   OPENFILENAME         ofn;
   HANDLE               hFile;
   WCHAR				sFilter[MAX_PATH];
   bool					bFile, bFolder = false;

/* function body */
      //get the starting location
   wcscpy(szPropName, L"SENCRYPTIONFILEPATH");
   lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
   if (lret != ERROR_SUCCESS)
   {
      wcscpy(sMsg, L"");
	  bFile = false;
   }
   else
   {
	  WCHAR* pFound = wcsstr(sMsg, L".pes");
	  if (pFound)
	     bFile = true;
	  else
	  {
	     WCHAR* pFound = wcsrchr(sMsg, L'\\');
		 if (pFound)
		 {
//		    *pFound = L'\0';
			bFolder = true;
		 }
	     bFile = false;
	  }
   }
    
      //get a handle to the install
   GetWndFromInstall(hInstall);

      // Initialize OPENFILENAME
   ZeroMemory(&ofn, sizeof(OPENFILENAME));
   ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
   ofn.hwndOwner = installWnd;
   if (bFile)
      ofn.lpstrFile = sMsg;
   else
   {
      wcscpy(sFile, L"");
      ofn.lpstrFile = sFile;
   }
   if (bFolder)
      ofn.lpstrInitialDir = sMsg;
   ofn.nMaxFile = 2*MAX_PATH;
   ofn.lpstrFilter = L"Password Encryption Files (*.pes)\0*.pes\0";
   ofn.nFilterIndex = 0;
   ofn.lpstrFileTitle = NULL;
   ofn.nMaxFileTitle = 0;
   ofn.lpstrInitialDir = NULL;
   ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_LONGNAMES | 
	           OFN_NONETWORKBUTTON;

      // Display the Open dialog box. 
   if (GetOpenFileName(&ofn))
   {
	     //get the given file path
	  sPath = ofn.lpstrFile;
         //set the filepath property
      wcscpy(szPropName, L"sFilePath");
      lret = MsiSetProperty(hInstall, szPropName, sPath);
   }

   return lret;
}
//END BrowseForEncryptionKey

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 28 MAR 2001                                                 *
 *                                                                   *
 *     This function is responsible for setting the                  *
 * "sEncryptionFilePath" property to a default location.  If the     *
 * property is not "None" then we will not set the property.         *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDefaultPathToEncryptionKey
PWDMSI_API UINT __stdcall GetDefaultPathToEncryptionKey(MSIHANDLE hInstall)
{
   // call LoadOLEAUT32OnNT4 to keep ref count of OLEAUT32
   // greater than zero
   LoadOLEAUT32OnNT4();

/* local constants */
   const WCHAR TOKENS[3] = L",\0";

/* local variables */
   _bstr_t				sFloppies;
   WCHAR			  * pDrive;
   HANDLE               hFile;
   WIN32_FIND_DATA      fDat;
   _bstr_t				sPath;
   _bstr_t				sPathSaved = L"";
   _bstr_t				sDrive = L"";
   int					ndx = 0;
   int					ndx2 = 0;
   UINT					lret = ERROR_SUCCESS;
   WCHAR				szPropName[MAX_PATH];
   WCHAR				sMsg[2*MAX_PATH];
   DWORD				nCount = 2*MAX_PATH;

/* function body */
      //if already set don't get again
   wcscpy(szPropName, L"SENCRYPTIONFILEPATH");
   lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
   if ((lret == ERROR_SUCCESS) && (wcscmp(sMsg, L"None")))
      return lret;

      //enumerate all local drives
   sDrive = EnumLocalDrives();
      //check each drive for the file
   pDrive = wcstok((WCHAR*)sDrive, TOKENS);
   while (pDrive != NULL)
   {
      if (ndx == 0)
         sPathSaved = pDrive;
      ndx++;

	     //see if a .pes file is on this drive
	  sPath = pDrive;
	  sPath += L"*.pes";
	  hFile = FindFirstFile((WCHAR*)sPath, &fDat);
         //if found, store the file path
	  if (hFile != INVALID_HANDLE_VALUE)
	  {
         FindClose(hFile);
			//get the data
	     sPath = pDrive;
	     sPath += fDat.cFileName;
		 if (ndx2 == 0)
		    sPathSaved = sPath;
		 ndx2++;
	  }
         //get the next drive
      pDrive = wcstok(NULL, TOKENS);
   }

      //set the filepath property
   wcscpy(szPropName, L"SENCRYPTIONFILEPATH");
   lret = MsiSetProperty(hInstall, szPropName, sPathSaved);

   return lret;
}
//END GetDefaultPathToEncryptionKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\setup\pwdmsi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	PwdMsi.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\setup\pwdmsi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PwdMsi.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\setup\pwdmsi\pwdmsi.h ===
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the PWDMSI_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// PWDMSI_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef PWDMSI_EXPORTS
#define PWDMSI_API __declspec(dllexport)
#else
#define PWDMSI_API __declspec(dllimport)
#endif

// This class is exported from the PwdMsi.dll
class PWDMSI_API CPwdMsi {
public:
	CPwdMsi(void);
	// TODO: add your methods here.
};

// the function LoadOLEAUT32OnNT4 has to be called at the beginning of each function
// in this dll in order to provide a workaround for the buggy implementation of 
// SysAllocString on NT4
// this buggy implementation of SysAllocString will cause the OLEAUT32.dll to unload
// prematurely, which results in an AV when any other dll references any function
// in OLEAUT32.dll
void LoadOLEAUT32OnNT4();

PWDMSI_API UINT __stdcall IsDC(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall DisplayExiting(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall DeleteOldFiles(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall GetInstallEncryptionKey(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall AddToLsaNotificationPkgValue(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall DeleteFromLsaNotificationPkgValue(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall FinishWithPassword(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall PwdsDontMatch(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall BrowseForEncryptionKey(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall GetDefaultPathToEncryptionKey(MSIHANDLE hInstall);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\setup\pwdmsi\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__55E9DEC0_A79C_4159_8A49_117749D82CF4__INCLUDED_)
#define AFX_STDAFX_H__55E9DEC0_A79C_4159_8A49_117749D82CF4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__55E9DEC0_A79C_4159_8A49_117749D82CF4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\introdlg.h ===
#if !defined(AFX_INTRODLG_H__1F3FDB56_7F34_4051_8A50_F8910DC93498__INCLUDED_)
#define AFX_INTRODLG_H__1F3FDB56_7F34_4051_8A50_F8910DC93498__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// IntroDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CIntroDlg dialog

class CIntroDlg : public CDialog
{
// Construction
public:
	CIntroDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CIntroDlg)
	enum { IDD = IDD_UPDATEMOT_INTRO };
	CButton	m_NextBtn;
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CIntroDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CIntroDlg)
	virtual void OnCancel();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INTRODLG_H__1F3FDB56_7F34_4051_8A50_F8910DC93498__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\introdlg.cpp ===
// IntroDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "IntroDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CIntroDlg dialog


CIntroDlg::CIntroDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CIntroDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CIntroDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CIntroDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIntroDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	DDX_Control(pDX, IDOK, m_NextBtn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CIntroDlg, CDialog)
	//{{AFX_MSG_MAP(CIntroDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIntroDlg message handlers

void CIntroDlg::OnCancel() 
{
	// TODO: Add extra cleanup here
	CString msg, title;
	title.LoadString(IDS_EXIT_TITLE);
	msg.LoadString(IDS_EXIT_MSG);
	if (MessageBox(msg, title, MB_YESNO | MB_ICONQUESTION) == IDYES)
	   CDialog::OnCancel();
}

void CIntroDlg::OnOK() 
{
	// TODO: Add extra validation here
	CDialog::OnOK();
}

BOOL CIntroDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\domainlistdlg.h ===
#if !defined(AFX_DOMAINLISTDLG_H__7BEF53AE_FF9A_4626_9DF5_669D2190E700__INCLUDED_)
#define AFX_DOMAINLISTDLG_H__7BEF53AE_FF9A_4626_9DF5_669D2190E700__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DomainListDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDomainListDlg dialog

class CDomainListDlg : public CDialog
{
// Construction
public:
	CDomainListDlg(CWnd* pParent = NULL);   // standard constructor

	void SetDomainListPtr(CStringList * pList) {pDomainList = pList;}
	void SetExcludeListPtr(CStringList * pList) {pExcludeList = pList;}

// Dialog Data
	//{{AFX_DATA(CDomainListDlg)
	enum { IDD = IDD_DOMAINLIST_DLG };
	CTreeCtrl	m_domainTree;
	CButton	m_NextBtn;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainListDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CStringList * pDomainList; //pointer to a list of domains in the table 
	CStringList * pExcludeList; //pointer to a list of domains excluded 
	BOOL	bExcludeOne; 

	// Generated message map functions
	//{{AFX_MSG(CDomainListDlg)
	virtual BOOL OnInitDialog();
	virtual void OnCancel();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void FillTreeControl();
    void ModifyDomainList(); 
	HTREEITEM AddOneItem(HTREEITEM hParent, LPTSTR szText);
	void AddExclutedBackToList();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DOMAINLISTDLG_H__7BEF53AE_FF9A_4626_9DF5_669D2190E700__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\domainlistdlg.cpp ===
// DomainListDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "DomainListDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDomainListDlg dialog


CDomainListDlg::CDomainListDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDomainListDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDomainListDlg)
	//}}AFX_DATA_INIT
	bExcludeOne = FALSE;
}


void CDomainListDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDomainListDlg)
	DDX_Control(pDX, IDC_DOMAINTREE, m_domainTree);
	DDX_Control(pDX, IDOK, m_NextBtn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDomainListDlg, CDialog)
	//{{AFX_MSG_MAP(CDomainListDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDomainListDlg message handlers

BOOL CDomainListDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
		//fill the tree control
	FillTreeControl();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDomainListDlg::OnCancel() 
{
	// TODO: Add extra cleanup here
	CString msg, title;
	title.LoadString(IDS_EXIT_TITLE);
	msg.LoadString(IDS_EXIT_MSG);
	if (MessageBox(msg, title, MB_YESNO | MB_ICONQUESTION) == IDYES)
	   CDialog::OnCancel();
}

void CDomainListDlg::OnOK() 
{
	CString msg, title;
	// TODO: Add extra validation here
	   //remove deselected items from the domain list
    ModifyDomainList();
	   //if at least one domain was deselected, post a warning message
	if (bExcludeOne)
	{
	   title.LoadString(IDS_EXCLUDE_TITLE);
	   msg.LoadString(IDS_EXCLUDE_MSG);
	   if (MessageBox(msg, title, MB_YESNO | MB_ICONQUESTION) == IDYES)
	      CDialog::OnOK();
	   else
		   AddExclutedBackToList();
	}
	else
	   CDialog::OnOK();
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 17 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CDomainListDlg class is *
 * responsible for displaying all domains in the Protar database's   *
 * MigratedObjects table.                                            *
 *                                                                   *
 *********************************************************************/

//BEGIN FillTreeControl
void CDomainListDlg::FillTreeControl() 
{
/* local variables */
	POSITION currentPos;    //current position in the list
	CString domainName;     //name of domain from the list
	WCHAR sName[MAX_PATH];  //name in string format to pass to tree control

/* function body */
	CWaitCursor wait; //Put up a wait cursor

	    //make sure the checkbox sytle is set for this tree control
	long lStyles = GetWindowLong(m_domainTree.m_hWnd, GWL_STYLE);
	   //if checkbox style is not set, set it
	if (!(lStyles & TVS_CHECKBOXES))
	{
	   lStyles = lStyles | TVS_CHECKBOXES;
	   SetWindowLong(m_domainTree.m_hWnd, GWL_STYLE, lStyles);
	}

		//get the position and string of the first name in the list
	currentPos = pDomainList->GetHeadPosition();

		//while there is another entry to retrieve from the list, then 
		//get a name from the list and add it to the tree control
	while (currentPos != NULL)
	{
			//get the next string in the list, starts with the first
		domainName = pDomainList->GetNext(currentPos);
		wcscpy(sName, (LPCTSTR)domainName);
  	    AddOneItem((HTREEITEM)TVI_ROOT, sName);
	}

	wait.~CWaitCursor();  //remove the wait cursor
}
//END FillTreeControl


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 17 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CDomainListDlg class is *
 * responsible for adding one item to the tree control in the        *
 * specified place.                                                  *
 *                                                                   *
 *********************************************************************/

//BEGIN AddOneItem
HTREEITEM CDomainListDlg::AddOneItem(HTREEITEM hParent, LPTSTR szText)
{
/* local variables */
	HTREEITEM hItem;
	TV_INSERTSTRUCT tvstruct;

/* function body */
	// fill the tree control
	tvstruct.hParent				= hParent;
	tvstruct.hInsertAfter			= TVI_SORT;
	tvstruct.item.pszText			= szText;
	tvstruct.item.cchTextMax		= MAX_PATH;
	tvstruct.item.mask				= TVIF_TEXT | TVIF_STATE;
	tvstruct.item.state				= INDEXTOSTATEIMAGEMASK(2);
	tvstruct.item.stateMask			= TVIS_STATEIMAGEMASK;
	hItem = m_domainTree.InsertItem(&tvstruct);

		//make sure item is checked
	m_domainTree.SetCheck(hItem, TRUE);

	return (hItem);
}
//END AddOneItem


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 17 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CDomainListDlg class is *
 * responsible for removing list entries if they where deselected in *
 * the tree control.                                                 *
 *                                                                   *
 *********************************************************************/

//BEGIN ModifyDomainList
void CDomainListDlg::ModifyDomainList() 
{
/* local variables */
    HTREEITEM hItem;        //current tree control item
	POSITION currentPos;    //current position in the list
	CString domainName;     //name of domain from the list
	UINT ndx;               //for loop counter

/* function body */
	CWaitCursor wait; //Put up a wait cursor

		//get the number of entries in the tree control
	for (ndx=0; ndx < m_domainTree.GetCount(); ndx++)
	{
	   if (ndx == 0)
          hItem = m_domainTree.GetNextItem(NULL, TVGN_CHILD);
	   else
          hItem = m_domainTree.GetNextItem(hItem, TVGN_NEXT);

	   domainName = m_domainTree.GetItemText(hItem);
	      //if deselected, remove from the list and add to the excluded list
	   if (m_domainTree.GetCheck(hItem) == 0)
	   {
	         //if we find the string in the list, remove it
		  currentPos = pDomainList->Find(domainName);
		  if (currentPos != NULL)
		  {
			  pDomainList->RemoveAt(currentPos);
			  pExcludeList->AddTail(domainName);
		  }
          bExcludeOne = TRUE; //set class flag to tell one is excluded
	   }
	}

	wait.~CWaitCursor();  //remove the wait cursor
}
//END ModifyDomainList


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CDomainListDlg class is *
 * responsible for taking the domain names out of the excluded list  *
 * and placing it back into the domain list.                         *
 *                                                                   *
 *********************************************************************/

//BEGIN AddExclutedBackToList
void CDomainListDlg::AddExclutedBackToList() 
{
/* local variables */
	POSITION currentPos;    //current position in the list
	CString domainName;     //name of domain from the list
/* function body */
    currentPos = pExcludeList->GetHeadPosition();
	while (currentPos != NULL)
	{
	   domainName = pExcludeList->GetNext(currentPos);
	   pDomainList->AddTail(domainName);
	}
	pExcludeList->RemoveAll();
}
//END AddExclutedBackToList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UpdateMOT.rc
//
#define IDS_PROJNAME                    100
#define IDS_EXIT_MSG                    101
#define IDR_SRCSIDUPDATE                102
#define IDS_EXIT_TITLE                  102
#define IDS_EXCLUDE_TITLE               103
#define IDS_EXCLUDE_MSG                 104
#define IDS_POP_YES                     105
#define IDS_POP_NO                      106
#define IDS_DOMAIN_COLUMN_TITLE         107
#define IDS_POPULATED_COLUMN_TITLE      108
#define IDS_EXCLUDED_COLUMN_TITLE       109
#define IDD_UPDATEMOT_INTRO             201
#define IDD_DOMAINLIST_DLG              202
#define IDC_DOMAINTREE                  202
#define IDC_PROGRESS1                   203
#define IDD_PROGRESSDLG                 203
#define IDC_DOMAIN_NAME                 204
#define IDD_SUMMARYDLG                  204
#define IDC_BACK                        205
#define IDC_STATIC1                     207
#define IDC_BUTTON2                     209
#define IDC_LIST1                       210
#define IDC_DOMAINLIST                  210
#define IDC_PROGRESS2                   211

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         212
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\progressdlg.cpp ===
// ProgressDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "ProgressDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog


CProgressDlg::CProgressDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CProgressDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CProgressDlg)
	m_domainName = _T("");
	//}}AFX_DATA_INIT

	m_pParent = pParent;
	m_nID = CProgressDlg::IDD;
}


void CProgressDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProgressDlg)
	DDX_Control(pDX, IDC_PROGRESS1, m_progressCtrl);
	DDX_Control(pDX, IDC_DOMAIN_NAME, m_DomainCtrl);
	DDX_Text(pDX, IDC_DOMAIN_NAME, m_domainName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProgressDlg, CDialog)
	//{{AFX_MSG_MAP(CProgressDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg message handlers

BOOL CProgressDlg::OnInitDialog() 
{
	const int START = 0;

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
    lowerLimit = 0;
	upperLimit = 100;
    bCanceled = FALSE;	//clear the "has the user canceled" flag
    m_progressCtrl.SetPos(START); //start the progress control at the beginning
	m_domainName = L"";
    UpdateData(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CProgressDlg::OnCancel() 
{
	// TODO: Add extra cleanup here
    bCanceled = TRUE;  //set the "has the user canceled" flag	
//	CDialog::OnCancel();
}

BOOL CProgressDlg::Create()
{
	return CDialog::Create(m_nID, m_pParent);
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This public member function of the CProgressDlg class is      *
 * responsible for trying to grab this dialog's messages from the    *
 * message queue and dispatch them.  We are having to do this in     *
 * order to receive a hit on the Cancel button.                      *
 *                                                                   *
 *********************************************************************/

//BEGIN CheckForCancel
void CProgressDlg::CheckForCancel(void)
{
/* local constants */

/* local variables */
   MSG aMsg;

/* function body */
   while (PeekMessage(&aMsg, m_hWnd, 0, 0, PM_REMOVE))
   {
	   if (!PreTranslateMessage(&aMsg))
	   {
		   TranslateMessage(&aMsg);
		   DispatchMessage(&aMsg);
	   }
   }
}//END CheckForCancel

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This public member function of the CProgressDlg class is      *
 * responsible for setting the amount the progress control will      *
 * advance per single step based on the number of domains to process.*
 *                                                                   *
 *********************************************************************/

//BEGIN SetIncrement
void CProgressDlg::SetIncrement(int numDomains)
{
/* local constants */
	const short MIN_STEPS = 10;

/* local variables */

/* function body */
   lowerLimit = 0;
   upperLimit = (short)numDomains * MIN_STEPS;
   m_progressCtrl.SetRange(lowerLimit, upperLimit);
   m_progressCtrl.SetStep(MIN_STEPS);

   UpdateWindow(); //force a paint of the dialog
}//END SetIncrement
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\progressdlg.h ===
#if !defined(AFX_PROGRESSDLG_H__226A22DA_6109_406B_9532_8BAB28EE559F__INCLUDED_)
#define AFX_PROGRESSDLG_H__226A22DA_6109_406B_9532_8BAB28EE559F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ProgressDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

class CProgressDlg : public CDialog
{
// Construction
public:
	CProgressDlg(CWnd* pParent = NULL);   // standard constructor
	BOOL Create();
	void SetIncrement(int numDomains);
	void Increment() {m_progressCtrl.StepIt();UpdateData(FALSE);Sleep(2000);};
	void Done() {m_progressCtrl.SetPos(upperLimit);UpdateData(FALSE);Sleep(2000);};
	void SetDomain(CString domainName) {m_domainName = domainName;UpdateData(FALSE);};
	BOOL Canceled() {return bCanceled;};
	void CheckForCancel(void);

// Dialog Data
	//{{AFX_DATA(CProgressDlg)
	enum { IDD = IDD_PROGRESSDLG };
	CProgressCtrl	m_progressCtrl;
	CStatic	m_DomainCtrl;
	CString	m_domainName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProgressDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	CWnd* m_pParent;
	int m_nID;
	short upperLimit, lowerLimit;

	// Generated message map functions
	//{{AFX_MSG(CProgressDlg)
	virtual BOOL OnInitDialog();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	BOOL bCanceled;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROGRESSDLG_H__226A22DA_6109_406B_9532_8BAB28EE559F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\srcsidupdate.cpp ===
// SrcSidUpdate.cpp : Implementation of CSrcSidUpdate
#include "stdafx.h"
#include "UpdateMOT.h"
#include "SrcSidUpdate.h"
#include "IntroDlg.h"
#include "DomainListDlg.h"
#include "ProgressDlg.h"
#include "SummaryDlg.h"

#import "DBMgr.tlb" no_namespace,named_guids
#import "VarSet.tlb" no_namespace , named_guids rename("property", "aproperty")

/////////////////////////////////////////////////////////////////////////////
// CSrcSidUpdate


STDMETHODIMP CSrcSidUpdate::QueryForSrcSidColumn(VARIANT_BOOL *pbFound)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   HRESULT                   hr = S_OK;
   
   try 
   {
      IIManageDBPtr   pDB(CLSID_IManageDB);
	    //see if column is already in the database
      *pbFound = pDB->SrcSidColumnInMigratedObjectsTable();
   }
   catch(_com_error& e)
   {
      hr = e.Error();
   }
   catch(...)
   {
      hr = E_FAIL;
   }

   return hr;
}

STDMETHODIMP CSrcSidUpdate::CreateSrcSidColumn(VARIANT_BOOL bHide, VARIANT_BOOL *pbCreated)
{
	HRESULT hr = S_OK;
	BOOL bAgain = TRUE; //flag used to redo upon cancel

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	   //retrieve a list of domains from the MigratedObjects table
	hr = FillDomainListFromMOT();
    if ( FAILED(hr) )
	{
	   *pbCreated = VARIANT_FALSE;
	   return E_FAIL;
	}

	   //if the MOT is empty, just add the new column without the GUI
	if (domainList.IsEmpty())
	{
       try 
	   {
          IIManageDBPtr   pDB(CLSID_IManageDB);
	         //create the new column in the MigratedObjects table
          hr = pDB->raw_CreateSrcSidColumnInMOT(pbCreated);
          if ( FAILED(hr) )
	         *pbCreated = VARIANT_FALSE; //column not created
		  else
             *pbCreated = VARIANT_TRUE; //column is created

	   }//end try
       catch(_com_error& e)
	   {
          hr = e.Error();
       }
       catch(...)
	   {
          hr = E_FAIL;
	   }

	   return hr;
	}

	   //if hide the GUI, try populating for all domains in the MOT
	if (bHide)
	{
       try 
	   {
          IIManageDBPtr   pDB(CLSID_IManageDB);
	         //create the new column in the MigratedObjects table
          hr = pDB->raw_CreateSrcSidColumnInMOT(pbCreated);
          if ( FAILED(hr) )
		  {
	         *pbCreated = VARIANT_FALSE;
	         return hr;
		  }

          *pbCreated = VARIANT_TRUE; //column is created

	      CString domainName;

	      POSITION pos = domainList.GetHeadPosition();
	        //while we have domains to process, populate that domain
	      while (pos != NULL)
		  {
		        //get the next domain name
             domainName = domainList.GetNext(pos);

		        //populate the new column for this domain
             pDB->PopulateSrcSidColumnByDomain(domainName.AllocSysString(), L"");
		  }
	   }//end try
       catch(_com_error& e)
	   {
          hr = e.Error();
       }
       catch(...)
	   {
          hr = E_FAIL;
	   }

	   return hr;
	}//end if hide

	   //display the intro dialog
    CIntroDlg  introDlg;
    if (introDlg.DoModal() == IDCANCEL)
	{
	   *pbCreated = VARIANT_FALSE;
	   return S_OK;
	}

	   //do atleast once and again if cancel on the progress dialog
	while (bAgain)
	{
	   bAgain = FALSE; //clear flag so we don't do this again
	   
          //pass the list to the dialog for display
       CDomainListDlg  domainListDlg;
       domainListDlg.SetDomainListPtr(&domainList);
       domainListDlg.SetExcludeListPtr(&excludeList);

	      //now display the domain selection dialog
       if (domainListDlg.DoModal() == IDCANCEL)
	   {
	      *pbCreated = VARIANT_FALSE;
	      return S_OK;
	   }

       try 
	   {
          IIManageDBPtr   pDB(CLSID_IManageDB);
	         //create the new column in the MigratedObjects table
          hr = pDB->raw_CreateSrcSidColumnInMOT(pbCreated);
          if ( FAILED(hr) )
		  {
	         *pbCreated = VARIANT_FALSE;
	         return hr;
		  }

          *pbCreated = VARIANT_TRUE; //column is created

		     //display the progress dialog
	      CProgressDlg progressDlg;
          progressDlg.Create();
		  progressDlg.ShowWindow(SW_SHOW);
	      progressDlg.SetIncrement((int)(domainList.GetCount())); //init the progress dialog

	      CString domainName;
	      VARIANT_BOOL bPopulated;

	      POSITION pos = domainList.GetHeadPosition();
			 //process dialog's messages (looking specifically for Cancel message)
		  progressDlg.CheckForCancel();
	        //while we have domains to process and user has not canceled,
	        //process each domain and control the progress dialog
	      while ((pos != NULL) && (!progressDlg.Canceled()))
		  {
		        //get the next domain name
             domainName = domainList.GetNext(pos);
		        //set the domain name on the progress dialog
		     progressDlg.SetDomain(domainName);

			 CWaitCursor wait; //Put up a wait cursor
		        //populate the new column for this domain
             bPopulated = pDB->PopulateSrcSidColumnByDomain(domainName.AllocSysString(), L"");
	         wait.~CWaitCursor();//remove the wait cursor

		        //if populate of the column was successful, add the domain
			    //name to the populate list
		     if (bPopulated)
		        populatedList.AddTail(domainName);

			    //process dialog's messages (looking specifically for Cancel message)
		     progressDlg.CheckForCancel();

			    //increment the progress dialog regardless of success
		     if (pos == NULL)
			 {
		        progressDlg.Done();
			    progressDlg.DestroyWindow();
			 }
		     else
                progressDlg.Increment();
		  }
		     //if canceled, delete the new column, clear the lists, and
		     //start over
	      if (progressDlg.Canceled())
		  {
		        //remove the column and return to the domain list dialog
			 VARIANT_BOOL bDeleted = pDB->DeleteSrcSidColumnInMOT();
			 
			    //reinitalize the lists
		     ReInitializeLists();

	         bAgain = TRUE; //set flag to try again
		  }
	   }//end try
       catch(_com_error& e)
	   {
          hr = e.Error();
       }
       catch(...)
	   {
          hr = E_FAIL;
	   }
	}//end while cancel

	   //display the summary dialog
    CSummaryDlg summaryDlg;
    summaryDlg.SetDomainListPtr(&domainList);
    summaryDlg.SetExcludeListPtr(&excludeList);
    summaryDlg.SetPopulatedListPtr(&populatedList);
    summaryDlg.DoModal();

	return hr;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 18 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CSrcSidUpdate class is  *
 * responsible for adding domains from the Protar database's         *
 * MigratedObjects table into the domain list.                       *
 *                                                                   *
 *********************************************************************/

//BEGIN FillDomainListFromMOT
HRESULT CSrcSidUpdate::FillDomainListFromMOT()
{
/* local variables */
   HRESULT                   hr = S_OK;
   IUnknown                * pUnk = NULL;
   long						 ndx, numObjects;
   _bstr_t                   srcDom;
   CString					 domainName;
   POSITION					 currentPos; 
   WCHAR                     strKey[MAX_PATH];

/* function body */
   try 
   {
      IVarSetPtr      pVarSet(CLSID_VarSet);
      IIManageDBPtr   pDB(CLSID_IManageDB);

      hr = pVarSet->QueryInterface(IID_IUnknown,(void**)&pUnk);
      if ( SUCCEEDED(hr) )
      {
		    //get all migrated objects into a varset
         hr = pDB->raw_GetMigratedObjectsFromOldMOT(-1,&pUnk);
      }
      if ( SUCCEEDED(hr) )
      {
         pVarSet = pUnk;
         pUnk->Release();

		 numObjects = pVarSet->get(L"MigratedObjects");

			//for each migrated object, save its source domain in the list
         for ( ndx = 0; ndx < numObjects; ndx++ )
         {
			   //get the source domain name
            swprintf(strKey,L"MigratedObjects.%ld.%s",ndx,L"SourceDomain");
            srcDom = pVarSet->get(strKey);
			   //add the name to the list, if not already in it
			domainName = (WCHAR*)srcDom;
		    currentPos = domainList.Find(domainName);
		    if (currentPos == NULL)
			   domainList.AddTail(domainName);
         }
	  }//end if got objects
   }
   catch(_com_error& e)
   {
      hr = e.Error();
   }
   catch(...)
   {
      hr = E_FAIL;
   }

   return hr;

}//END FillDomainListFromMOT


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CDomainListDlg class is *
 * responsible for taking the domain names out of the excluded list  *
 * and placing it back into the domain list.                         *
 *                                                                   *
 *********************************************************************/

//BEGIN ReInitializeLists
void CSrcSidUpdate::ReInitializeLists() 
{
/* local variables */
	POSITION currentPos;    //current position in the list
	CString domainName;     //name of domain from the list
/* function body */
    currentPos = excludeList.GetHeadPosition();
	while (currentPos != NULL)
	{
	   domainName = excludeList.GetNext(currentPos);
	   domainList.AddTail(domainName);
	}
	excludeList.RemoveAll();
	populatedList.RemoveAll();
}
//END ReInitializeLists
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A2BDC2E3_2144_478D_947D_D1671A5BA298__INCLUDED_)
#define AFX_STDAFX_H__A2BDC2E3_2144_478D_947D_D1671A5BA298__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A2BDC2E3_2144_478D_947D_D1671A5BA298__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\srcsidupdate.h ===
// SrcSidUpdate.h : Declaration of the CSrcSidUpdate

#ifndef __SRCSIDUPDATE_H_
#define __SRCSIDUPDATE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSrcSidUpdate
class ATL_NO_VTABLE CSrcSidUpdate : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSrcSidUpdate, &CLSID_SrcSidUpdate>,
	public IDispatchImpl<ISrcSidUpdate, &IID_ISrcSidUpdate, &LIBID_UPDATEMOTLib>
{
public:
	CSrcSidUpdate()
	{
		domainList.RemoveAll();
		excludeList.RemoveAll();
		populatedList.RemoveAll();
	}

    ~CSrcSidUpdate()
	{
		domainList.RemoveAll();
		excludeList.RemoveAll();
		populatedList.RemoveAll();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SRCSIDUPDATE)
DECLARE_NOT_AGGREGATABLE(CSrcSidUpdate)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSrcSidUpdate)
	COM_INTERFACE_ENTRY(ISrcSidUpdate)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISrcSidUpdate
public:
	STDMETHOD(CreateSrcSidColumn)(/*[in]*/ VARIANT_BOOL bHide, /*[out, retval]*/ VARIANT_BOOL * pbCreated);
	STDMETHOD(QueryForSrcSidColumn)(/*[out, retval]*/ VARIANT_BOOL * pbFound);
private:
	CStringList domainList;
	CStringList excludeList;
	CStringList populatedList;
	HRESULT FillDomainListFromMOT();
	void ReInitializeLists();
};

#endif //__SRCSIDUPDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
//#include "McsVarSetMin_p.c"
#include "VarSet_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\updatemot.cpp ===
// UpdateMOT.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f UpdateMOTps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "UpdateMOT.h"

#include "UpdateMOT_i.c"
#include "SrcSidUpdate.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SrcSidUpdate, CSrcSidUpdate)
END_OBJECT_MAP()

class CUpdateMOTApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUpdateMOTApp)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CUpdateMOTApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CUpdateMOTApp, CWinApp)
	//{{AFX_MSG_MAP(CUpdateMOTApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CUpdateMOTApp theApp;

BOOL CUpdateMOTApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance, &LIBID_UPDATEMOTLib);
    return CWinApp::InitInstance();
}

int CUpdateMOTApp::ExitInstance()
{
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\summarydlg.h ===
#if !defined(AFX_SUMMARYDLG_H__0AFEFC3C_9E2B_4988_8FF8_618EFA4F99C3__INCLUDED_)
#define AFX_SUMMARYDLG_H__0AFEFC3C_9E2B_4988_8FF8_618EFA4F99C3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SummaryDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSummaryDlg dialog

class CSummaryDlg : public CDialog
{
// Construction
public:
	CSummaryDlg(CWnd* pParent = NULL);   // standard constructor

	void SetDomainListPtr(CStringList * pList) {pDomainList = pList;}
	void SetExcludeListPtr(CStringList * pList) {pExcludeList = pList;}
	void SetPopulatedListPtr(CStringList * pList) {pPopulatedList = pList;}

// Dialog Data
	//{{AFX_DATA(CSummaryDlg)
	enum { IDD = IDD_SUMMARYDLG };
	CListCtrl	m_listCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSummaryDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CStringList * pDomainList; //pointer to a list of domains in the table 
	CStringList * pExcludeList; //pointer to a list of domains excluded 
	CStringList * pPopulatedList; //pointer to a list of domains successfully populated 

	// Generated message map functions
	//{{AFX_MSG(CSummaryDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void AddDomainsToList(void);
    void CreateListCtrlColumns(void);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SUMMARYDLG_H__0AFEFC3C_9E2B_4988_8FF8_618EFA4F99C3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__8B94B5D4_FE44_11D2_A1E8_00A0C9AFE114__INCLUDED_)
#define AFX_DLLDATAX_H__8B94B5D4_FE44_11D2_A1E8_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__8B94B5D4_FE44_11D2_A1E8_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\updatemot\summarydlg.cpp ===
// SummaryDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "SummaryDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSummaryDlg dialog


CSummaryDlg::CSummaryDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSummaryDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSummaryDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CSummaryDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSummaryDlg)
	DDX_Control(pDX, IDC_DOMAINLIST, m_listCtrl);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSummaryDlg, CDialog)
	//{{AFX_MSG_MAP(CSummaryDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSummaryDlg message handlers

BOOL CSummaryDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	   //Add columns and information to the list control
    CreateListCtrlColumns();
	AddDomainsToList();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CSummaryDlg class is    *
 * responsible for adding the domains in the 3 lists into the list   *
 * control.  Those domains in the populated list are also in the     *
 * domain list, therefore they are ignored in the domain list        *
 * processing.                                                       *
 *                                                                   *
 *********************************************************************/

//BEGIN AddDomainsToList
void CSummaryDlg::AddDomainsToList() 
{
/* local constants */
    const int POPULATE_COLUMN = 1;
    const int EXCLUDE_COLUMN = 2;

/* local variables */
	POSITION currentPos;    //current position in the list
	POSITION pos;           //position in the domain list
	CString domainName;     //name of domain from the list
	CString Text;           //CString holder
	int nlistNum = 0;       //current list item being added
	int ndx = 0;            //while loop counter
	LVITEM aItem;           //list control item to insert
	WCHAR sText[MAX_PATH];  //holds string to add

/* function body */
	  //add the domains that were successfully populated (and remove
	  //from the domain list)
    currentPos = pPopulatedList->GetHeadPosition();
	while (ndx < pPopulatedList->GetCount())
	{
		  //get domain name
	   domainName = pPopulatedList->GetNext(currentPos);
	      //insert in list control
	   aItem.iItem = ndx;
	   aItem.iSubItem = 0;
	   aItem.mask = LVIF_TEXT;
	   wcscpy(sText, (LPCTSTR)domainName);
	   aItem.pszText = sText;
       m_listCtrl.InsertItem(&aItem);
		  //add populated status
	   Text.LoadString(IDS_POP_YES);
	   wcscpy(sText, (LPCTSTR)Text);
	   m_listCtrl.SetItemText(ndx, POPULATE_COLUMN, sText);
		  //add excluded status
	   Text.LoadString(IDS_POP_NO);
	   wcscpy(sText, (LPCTSTR)Text);
	   m_listCtrl.SetItemText(ndx, EXCLUDE_COLUMN, sText);
		  //remove from the domain list
	   if ((pos = pDomainList->Find(domainName)) != NULL)
		  pDomainList->RemoveAt(pos);
	   ndx++;
	}

	  //add the domains that were not successfully populated and remain
	  //in the domain list
	nlistNum = ndx;
	ndx = 0;
    currentPos = pDomainList->GetHeadPosition();
	while (ndx < pDomainList->GetCount())
	{
		  //get domain name
	   domainName = pDomainList->GetNext(currentPos);
	      //insert in list control
	   aItem.iItem = nlistNum + ndx;
	   aItem.iSubItem = 0;
	   aItem.mask = LVIF_TEXT;
	   wcscpy(sText, (LPCTSTR)domainName);
	   aItem.pszText = sText;
       m_listCtrl.InsertItem(&aItem);
		  //add populated status
	   Text.LoadString(IDS_POP_NO);
	   wcscpy(sText, (LPCTSTR)Text);
	   m_listCtrl.SetItemText(nlistNum+ndx, POPULATE_COLUMN, sText);
		  //add excluded status
	   m_listCtrl.SetItemText(nlistNum+ndx, EXCLUDE_COLUMN, sText);
	   ndx++;
	}

	  //add the domains that were excluded
	nlistNum += ndx;
	ndx = 0;
    currentPos = pExcludeList->GetHeadPosition();
	while (ndx < pExcludeList->GetCount())
	{
		  //get domain name
	   domainName = pExcludeList->GetNext(currentPos);
	      //insert in list control
	   aItem.iItem = nlistNum + ndx;
	   aItem.iSubItem = 0;
	   aItem.mask = LVIF_TEXT;
	   wcscpy(sText, (LPCTSTR)domainName);
	   aItem.pszText = sText;
       m_listCtrl.InsertItem(&aItem);
		  //add populated status
	   Text.LoadString(IDS_POP_NO);
	   wcscpy(sText, (LPCTSTR)Text);
	   m_listCtrl.SetItemText(nlistNum+ndx, POPULATE_COLUMN, sText);
		  //add excluded status
	   Text.LoadString(IDS_POP_YES);
	   wcscpy(sText, (LPCTSTR)Text);
	   m_listCtrl.SetItemText(nlistNum+ndx, EXCLUDE_COLUMN, sText);
	   ndx++;
	}
}
//END AddDomainsToList


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CSummaryDlg class is    *
 * responsible for adding the columns to the summary's list control. *
 *                                                                   *
 *********************************************************************/

//BEGIN CreateListCtrlColumns
void CSummaryDlg::CreateListCtrlColumns() 
{
/* local constants */

/* local variables */
   CString Text;
   CRect rect;
   int columnWidth;

/* function body */
      //get the width in pixels of the CListCtrl
   m_listCtrl.GetWindowRect(&rect);
   
	  //create the domain name column
   Text.LoadString(IDS_DOMAIN_COLUMN_TITLE);
   columnWidth = (int)(rect.Width() * 0.6);
   m_listCtrl.InsertColumn(0, Text, LVCFMT_LEFT, columnWidth);

      //create the populated Yes/No column
   Text.LoadString(IDS_POPULATED_COLUMN_TITLE);
   columnWidth = (int)((rect.Width() - columnWidth) / 2);
   columnWidth -= 1; //make it fit in the control without a scrollbar
   m_listCtrl.InsertColumn(1, Text, LVCFMT_CENTER, columnWidth);

      //create the populated Yes/No column
   Text.LoadString(IDS_EXCLUDED_COLUMN_TITLE);
   columnWidth -= 1; //make it fit in the control without a scrollbar
   m_listCtrl.InsertColumn(2, Text, LVCFMT_CENTER, columnWidth);

   UpdateData(FALSE);
}
//END CreateListCtrlColumns
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\dotstr.cpp ===
/*---------------------------------------------------------------------------
  File: DottedString.cpp

  Comments: Utility class used to parse dot-delimited strings

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 17:23:47

 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "DotStr.hpp"

/////////////////////////////////////////////////////
// Utility class used to parse dot-delimited strings
/////////////////////////////////////////////////////


void 
   CDottedString::Init()
{
   // count the number of segments
   m_nSegments = 1;
   for ( int i = 0 ; i < m_name.GetLength() ; i++ )
   {
      if ( m_name[i] == _T('.') )
      {
         m_nSegments++;
      }
   }
   // special case for empty string
   if ( m_name.IsEmpty() )
   {
      m_nSegments = 0;
   }
}

void 
   CDottedString::GetSegment(
      int                    ndx,          // in - which segment to get (first=0)
      CString              & str           // out- segment, or empty string if ndx is not valid
   )
{
   int                       n = ndx;
   int                       x;
   
   str = _T("");

   if ( ndx >= 0 && ndx < m_nSegments )
   {
      str = m_name;

      while ( n )
      {
//         x = str.Find(_T("."),0);
         x = str.Find(_T("."));
         str = str.Right(str.GetLength() - x - 1);
         n--;
      }
//      x = str.Find(_T("."),0);
      x = str.Find(_T("."));
      if ( x >= 0 )
      {
         str = str.Left(x);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "StdAfx.h"
#ifdef _WIN64
#include "McsDebug.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\dotstr.hpp ===
/*---------------------------------------------------------------------------
  File: DottedString.hpp

  Comments: Utility class used by VarSet to parse dot-delimited strings.
  Uses CString.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 17:24:11

 ---------------------------------------------------------------------------
*/

#ifndef __CDOTTEDSTRING_HPP__
#define __CDOTTEDSTRING_HPP__

/////////////////////////////////////////////////////
// Utility class used to parse dot-delimited strings
/////////////////////////////////////////////////////
class CDottedString
{
   CString                    m_name;
   int                       m_nSegments;

public:
            CDottedString(BSTR str)    { m_name = str; Init(); }
            CDottedString(TCHAR const * str) { m_name = str; Init();}

   int      NumSegments() { return m_nSegments; }
   void     GetSegment(int ndx,CString & str);

protected:
   void     Init();  // counts the number of segments
};

#endif //__CPROPSTRING_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include <ResStr.h>

StringLoader gString;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VSMin.rc
//
#define IDS_PROJNAME                    100
#define IDR_VSET                        101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\nomcs.h ===
#ifndef __NOMCSCOMMON_H__
#define __NOMCSCOMMON_H__
/*---------------------------------------------------------------------------
  File: NoMcsCommon.h

  Comments: A minimal set of definitions for code which cannot depend on McsCommon.
  This is a temporary hack, to allow the McsVarSet COM object to be installed without requiring 
  a reboot.  McsCommon requires MSVCP60.DLL, which requires an updated version of MSVCRT.DLL, 
  which is in use by NETAPI32.DLL, and thus requires a reboot to update.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 04/28/99 16:18:12

 ---------------------------------------------------------------------------
*/


#define MC_LOGGING(level) false
#define MC_LogBlockPtrIf(level, str)
#define MC_LOGBLOCKIF(level, str) 
#define MC_LOGBLOCK(str) 
#define MC_LogBlockPtr(str)
#define MC_LOGIF(level, info) do {}while(0)
#define MC_LOGALWAYS(info) do {}while(0)
#define MC_LOG(info) do {}while(0)
#define MC_LOGTEMPCONTEXT(new_context) 

#include <assert.h>

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// ------------------------------- 
#define MCSASSERT(expr) assert(expr)

#define MCSASSERTSZ(expr,msg) assert(expr)

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#define MCSEXCEPTION(expr) MCSASSERT(expr)

#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#define MCSVERIFY(expr) MCSASSERT(expr)

#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)

#define MCSINC_Mcs_h

#endif //__NOMCSCOMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8B94B5CC_FE44_11D2_A1E8_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__8B94B5CC_FE44_11D2_A1E8_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0351
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
//#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
//#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#define VARSET_LOGLEVEL_CLIENT      3
#define VARSET_LOGLEVEL_INTERNAL    4


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8B94B5CC_FE44_11D2_A1E8_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\vardata.cpp ===
/*---------------------------------------------------------------------------
  File: VarData.cpp

  Comments: CVarData represents one level in the VarSet.  It has a variant
  value, and a map containing one or more subvalues.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 17:24:56

 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "VarData.h"
#include "VarMap.h"
#include "DotStr.hpp"

#ifdef STRIPPED_VARSET
   #include "Varset.h"
   #include "NoMcs.h"  
#else
   #include <VarSet.h>
   #include "McString.h"
   #include "McLog.h"
   using namespace McString;
#endif
#include "VSet.h"
#include <comdef.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


int    
   CVarData::SetData(
      CString                key,          // in - key value
      VARIANT              * var,          // in - data value
      BOOL                   bCoerce,      // in - flag, whether to coerce to a persistable value
      HRESULT              * pResult       // out- optional return code
   )
{
   int                       nCreated = 0;
   _variant_t                newVal(var);
   HRESULT                   hr = S_OK;

   if ( key.IsEmpty() )
   {
      m_cs.Lock();
      // set my data value
      if ( ! bCoerce )
      {
         m_var.Copy(&newVal);   
      }
      else
      {
         // need to coerce the value to an appropriate type
      
         if ( var->vt == VT_DISPATCH  || var->vt == VT_UNKNOWN )
         {
            // if it's an IUnknown, see if it supports IDispatch
            IDispatchPtr               pDisp;

            pDisp = newVal;

            if ( pDisp != NULL )
            {
               // the object supports IDispatch
               // try to get the default property
               _variant_t              defPropVar;
               DISPPARAMS              dispParamsNoArgs = {NULL, NULL, 0, 0};

               hr = pDisp->Invoke(0,
                                  IID_NULL,
                                  LOCALE_USER_DEFAULT,
                                  DISPATCH_PROPERTYGET,
                                  &dispParamsNoArgs,
                                  &defPropVar,
                                  NULL,
                                  NULL);
               if ( SUCCEEDED(hr) )
               {
                  // we got the default property
                  newVal = defPropVar;
               }
               else
               {
                  MC_LOG("VarSet::put - unable to retrieve default property for IDispatch object.  Put operation failed, hr=" << hr << "returning E_INVALIDARG");
                  hr = E_INVALIDARG;
               }
            }
         }
         if ( SUCCEEDED(hr) )
         {
            if ( newVal.vt & VT_BYREF )
            {
               if ( newVal.vt == (VT_VARIANT | VT_BYREF) )
               {
                  m_var.Copy(newVal.pvarVal);   
               }
               else
               {
                  hr = ::VariantChangeType(&newVal,&newVal,0,newVal.vt & ~VT_BYREF);
                  if ( SUCCEEDED(hr) )
                  {
                     m_var.Copy(&newVal);   
                  }
                  else
                  {
                     MC_LOG("VarSet::put - failed to dereference variant of type " << newVal.vt << ".  Put operation failed, hr=" <<hr);
                     hr = E_INVALIDARG;
                  }
               }
            }
            else 
            {
               m_var.Copy(&newVal);
            }
         }
      }
      m_cs.Unlock();
   }
   else
   {
      // set the value for a child

      CDottedString          s(key);
      CString                seg;
      CVarData             * pObj;
      CVarData             * pChild;

      s.GetSegment(0,seg);
   
      m_cs.Lock();
      if ( ! m_children )
      {
         // create the child map if it does not exist
         m_children = new CMapStringToVar(IsCaseSensitive(),IsIndexed(), AllowRehashing() );
         if (!m_children)
		 {
            m_cs.Unlock();
            return nCreated;
		 }
      }
      // look for the first segment of the entry in the child map
      if ( ! m_children->Lookup(seg,pObj) )
      {
         // add it if it doesn't exist
         pChild = new CVarData;
         if (!pChild)
		 {
            m_cs.Unlock();
            return nCreated;
		 }
         try {
             pChild->SetCaseSensitive(IsCaseSensitive());
             pChild->SetAllowRehashing(AllowRehashing());
             pChild->SetIndexed(IsIndexed());
             m_children->SetAt(seg,pChild);
             nCreated++; // we added a new node
         }
         catch(...) {
            delete pChild;
            pChild = NULL;
            m_cs.Unlock();
            throw;
         }
      }
      else
      {
         pChild = (CVarData*)pObj;
      }
      // strip off the first segment from the property name, and call SetData
      // recursively on the child item
      nCreated += pChild->SetData(key.Right(key.GetLength() - seg.GetLength()-1),var,bCoerce,&hr);
      m_cs.Unlock();
   }
   if ( pResult )
   {
      (*pResult) = hr;
   }
   return nCreated;
}

void 
   CVarData::RemoveAll()
{
   // remove all children from the map
   m_cs.Lock();
   if ( m_children && ! m_children->IsEmpty() )
   {
      // Enumerate the MAP and delete each object
      POSITION               pos;
      CString                key;
      CVarData             * pObj;

      pos = m_children->GetStartPosition();

      while ( pos )
      {
         m_children->GetNextAssoc(pos,key,pObj);
         if ( pObj )
         {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
            delete pObj;
         }
      }
      m_children->RemoveAll();
   }
   if ( m_children )
   {
      delete m_children;
      m_children = NULL;
   }
   m_cs.Unlock();
}

BOOL                                         // ret- TRUE if key exists in the map
   CVarData::Lookup(
      LPCTSTR                key,            // in - key to search for
      CVarData            *& rValue          // out- value
   ) 
{ 
   if ( m_children ) 
   { 
      return m_children->Lookup(key,rValue); 
   } 
   else 
   {
      return FALSE; 
   }
}

BOOL                                        // ret- TRUE if there are sub-items for this node
   CVarData::HasChildren() 
{ 
   return m_children && !m_children->IsEmpty(); 
}

void 
   CVarData::SetAt(
      LPCTSTR                key,            // in - key 
      CVarData             * newValue        // in - new value
   ) 
{ 
   if ( ! m_children ) 
   { 
      // create map to hold children if it doesn't already exist
      m_children = new CMapStringToVar(IsCaseSensitive(),IsIndexed(),AllowRehashing()); 
      if (!m_children)
         return;
   }
   m_children->SetAt(key,newValue); 
}

void 
   CVarData::SetIndexed(
      BOOL                   nVal
   )
{
   if ( m_children )
   {
      m_children->SetIndexed(nVal);
   }
   if ( nVal )
   {
      m_options |= CVARDATA_INDEXED;
   }
   else
   {
      m_options &= ~CVARDATA_INDEXED;
   }
}
                           
void 
   CVarData::SetCaseSensitive(
      BOOL                   nVal           // in - whether to make lookups case-sensitive
  )
{ 
   if ( m_children ) 
   {
      m_children->SetCaseSensitive(nVal); 
   }
   if ( nVal )
   {
      m_options |= CVARDATA_CASE_SENSITIVE;
   }
   else
   {
      m_options &= ~CVARDATA_CASE_SENSITIVE;
   }
}

void 
   CVarData::SetAllowRehashing(
      BOOL                   nVal           // in - whether to allow the table to be rehashed for better performance
  )
{ 
   if ( m_children ) 
   {
      m_children->SetAllowRehash(nVal); 
   }
   if ( nVal )
   {
      m_options |= CVARDATA_ALLOWREHASH;
   }
   else
   {
      m_options &= ~CVARDATA_ALLOWREHASH;
   }
}




HRESULT 
   CVarData::WriteToStream(
      LPSTREAM               pS            // in - stream to write data to
   )
{
    HRESULT hr = S_OK;
    BOOL     hasChildren = (m_children != NULL);

    // save the variant
    hr = m_var.WriteToStream(pS);

    if (SUCCEEDED(hr) )
    {
        // save children, if any
        ULONG                result;
        hr = pS->Write(&hasChildren,(sizeof hasChildren),&result);
        if ( SUCCEEDED(hr) )
        {
            if ( m_children )
            {
                hr = m_children->WriteToStream(pS);
            }
        }
    }

    return hr;
}

HRESULT 
   CVarData::ReadFromStream(
      LPSTREAM               pS            // in - stream to read data from
   )
{
   HRESULT                   hr = S_OK;
   BOOL                      hasChildren;
   ULONG                     result;

   // read the variant
   hr = m_var.ReadFromStream(pS);
   if ( SUCCEEDED(hr) )
   {
      hr = pS->Read(&hasChildren,(sizeof hasChildren),&result);
      if ( SUCCEEDED(hr) )
      {
         if ( hasChildren )
         {
            // create the child array
            m_children = new CMapStringToVar(IsCaseSensitive(),IsIndexed(),AllowRehashing());
            if (!m_children)
               return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            hr = m_children->ReadFromStream(pS);
         }
      }

   }
   return hr;
}

DWORD                                      // ret- Length, in bytes to write the data to a stream
   CVarData::CalculateStreamedLength()
{
   HRESULT                   hr =S_OK;
   DWORD                     len = sizeof (VARTYPE);
   
   // Calculate size needed for root data value

   int cbWrite = 0;
	switch (m_var.vt)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
	   {
         CComQIPtr<IPersistStream> spStream = m_var.punkVal;
         if( spStream )                
         {
            len += sizeof(CLSID);
            ULARGE_INTEGER  uiSize = { 0 };
            hr = spStream->GetSizeMax(&uiSize);
            if (FAILED(hr))                        
               return hr;
            len += uiSize.LowPart;                
         }            
      }
      break;
   case VT_UI1:
	case VT_I1:
		cbWrite = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbWrite = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbWrite = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbWrite = sizeof(double);
		break;
	default:
		break;
	}
	
   CComBSTR bstrWrite;
	CComVariant varBSTR;
	
   if (m_var.vt != VT_BSTR)
	{
		hr = VariantChangeType(&varBSTR, &m_var, VARIANT_NOVALUEPROP, VT_BSTR);
		if (FAILED(hr))
			return hr;
		bstrWrite = varBSTR.bstrVal;
	}
	else
   {
      bstrWrite = m_var.bstrVal;
   }
   len += 4 + (static_cast<BSTR>(bstrWrite) ? SysStringByteLen(bstrWrite) : 0) + 2;
   if ( SUCCEEDED(hr) )
   {
      len += cbWrite;
   }
   
   // Add sizes of children
   len += (sizeof BOOL); // has children?
   if ( m_children )
   {
      len += m_children->CalculateStreamedLength();
   }

   return len;
}

long                                       // ret- number of data items
   CVarData::CountItems()
{
   long                      count = 1;

   if ( m_children )
   {
      count += m_children->CountItems();
   }

   return count;
}

void 
   CVarData::McLogInternalDiagnostics(
      CString                keyname       // in - Key name for this subtree, so the complete name can be displayed
   )
{
   CString value;

   switch ( m_var.vt )
   {
      case VT_EMPTY:      
         value = _T("<Empty>");
         break;
      case VT_NULL:
         value = _T("<Null>");
         break;
      case VT_I2:
      case VT_I4:
         value.Format(_T("%ld"),m_var.iVal);
         break;
      case VT_BSTR:
         value = m_var.bstrVal;
         break;
      default:
         value.Format(_T("variant type=0x%lx"),m_var.vt);
         break;
   }
   MC_LOG(String(keyname) << "-->"<< String(value) << (m_children ? " (Has Children)" : " (No Children)") << " Options = " << makeStr(m_options) << " CaseSensitive=" << ( IsCaseSensitive()?"TRUE":"FALSE") << " Indexed=" << (IsIndexed()?"TRUE":"FALSE") );

   if ( m_children )
   {
      m_children->McLogInternalDiagnostics(keyname);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\vardata.h ===
/*---------------------------------------------------------------------------
  File: VarData.h

  Comments: This class makes up one level of data in the VarSet.  
            A CVarData consists of a variant value, and a (possibly empty) set of children.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 17:29:30

 ---------------------------------------------------------------------------
*/

#ifndef __CBBVAROBJ_HPP__
#define __CBBVAROBJ_HPP__

#define CVARDATA_CASE_SENSITIVE (0x01)
#define CVARDATA_INDEXED        (0x02)
#define CVARDATA_ALLOWREHASH    (0x04)

#include <atlbase.h>

class CMapStringToVar;

class CVarData //: public CObject
{
   CComAutoCriticalSection   m_cs;
   CComVariant               m_var;
   CMapStringToVar         * m_children; 
   BYTE                      m_options;
public:
//   CVarData() : m_children(NULL) {m_options = CVARDATA_CASE_SENSITIVE | CVARDATA_INDEXED | CVARDATA_ALLOWREHASH; };
// Gene Allen 99.04.22  Changed default from Case sensitive to case insensitive
  CVarData() : m_children(NULL) {m_options = CVARDATA_INDEXED | CVARDATA_ALLOWREHASH; };
   ~CVarData() { RemoveAll(); } 
   
   // Variant data functions
   CComVariant * GetData() { return &m_var; }         
   int           SetData(CString name,VARIANT * var,BOOL bCoerce, HRESULT * pReturnCode);  // returns the number of new items (& subitems) added to the VarSet
   
   // Property settings
   BOOL          IsCaseSensitive() { return m_options & CVARDATA_CASE_SENSITIVE; }
   BOOL          IsIndexed() { return m_options & CVARDATA_INDEXED; }
   BOOL          AllowRehashing() { return m_options & CVARDATA_ALLOWREHASH; }

   void          SetIndexed(BOOL v);
   void          SetCaseSensitive(BOOL nVal);  // only applies to child items
   void          SetAllowRehashing(BOOL v);    // only applies to child items
   // sub-element map functions
   BOOL                    HasChildren();
   BOOL                    HasData() { return m_var.vt != VT_EMPTY; }
   CMapStringToVar       * GetChildren() { return m_children; }
   void                    RemoveAll();   // deletes all children
   
   BOOL                    Lookup(LPCTSTR key,CVarData *& rValue);
   void                    SetAt(LPCTSTR key, CVarData * newValue);
   
   long                    CountItems();
   
   // Stream i/o functions
   HRESULT                 ReadFromStream(LPSTREAM pStr);
   HRESULT                 WriteToStream(LPSTREAM pStr);

   DWORD                   CalculateStreamedLength();

   void                    McLogInternalDiagnostics(CString keyName);
   
   //DECLARE_SERIAL(CVarData)
};

#endif //__CBBVAROBJ_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\varmap.h ===
/*---------------------------------------------------------------------------
  File: VarMap.h

  Comments: A map string=>Variant, used by VarSet.  It is implemented as a hash 
  table, win and optional red-black tree index.

  Added features include:  
      CaseSensitive property - The case of each key is preserved as it was when
      the key was first added to the map.  The hash function is not case sensitive,
      so the CaseSensitive property can be toggled on and off without rehashing the data.
      
      Optional indexing to allow for fast enumeration in alphabetical order by key.
      This will add overhead to insert operations.  Without indexing, the contents of 
      the map can be enumerated, but they will be in arbitrary order.

      Stream I/O functions for persistance.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 18:03:19

 ---------------------------------------------------------------------------
*/



#ifndef __VARSETMAP_H
#define __VARSETMAP_H

#include "VarData.h"
#include "VarNdx.h"

class CHashItem // used internally by hash table
{
   friend class CMapStringToVar;
   friend class CIndexItem;

   CHashItem() { pNext = NULL; value = NULL; pIndex = NULL; }
   
   CHashItem*      pNext;       // used in hash table
	UINT            nHashValue;  // needed for efficient iteration
	CString         key;
   CVarData*       value;
   CIndexItem*     pIndex;      // pointer to index, or NULL
};

class CMapStringToVar : public CObject
{
   DECLARE_SERIAL(CMapStringToVar)
public:
   
// Construction
	CMapStringToVar(BOOL isCaseSensitive,BOOL isIndexed, BOOL allowRehash, int nBlockSize = 10);
protected:
   CMapStringToVar() {};
public:
// Attributes
	// number of elements
	int GetCount() const 	{ return m_nCount; }
	BOOL IsEmpty() const    { return m_nCount == 0; }

	// Lookup
	BOOL Lookup(LPCTSTR key, CVarData*& rValue) const;
	BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
	// Lookup and add if not there
	CVarData*& operator[](LPCTSTR key);

	// add a new (key, value) pair
	void SetAt(LPCTSTR key, CVarData* newValue)	{ (*this)[key] = newValue; }


	BOOL RemoveKey(LPCTSTR key);
	void RemoveAll();

	POSITION GetStartPosition() const { return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
	void GetNextAssoc(POSITION& rNextPosition, CString& rKey, CVarData*& rValue) const;
   POSITION GetPositionAt(LPCTSTR key) { UINT hash; return (POSITION)GetAssocAt(key,hash); }
   CIndexItem * GetIndexAt(LPCTSTR key) { UINT hash; CHashItem * h = GetAssocAt(key,hash); if ( h ) return h->pIndex; else return NULL; }

   UINT GetHashTableSize() const 	{ return m_nHashTableSize; }
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

	UINT HashKey(LPCTSTR key) const;

   void SetCaseSensitive(BOOL val) { m_CaseSensitive = val; 
                                     m_Index.SetCompareFunctions(val? &CompareItems : &CompareItemsNoCase,
                                                                 val? CompareStringToItem : CompareStringToItemNoCase); }
   
   void SetIndexed(BOOL val);

   void SetAllowRehash(BOOL val) { m_AllowRehash = val; }

   HRESULT ReadFromStream(LPSTREAM pStm);
   HRESULT WriteToStream(LPSTREAM pStm);
   DWORD   CalculateStreamedLength();
   long    CountItems();

   CIndexTree * GetIndex() { if ( m_Indexed ) return &m_Index; else return NULL; }
   
   void McLogInternalDiagnostics(CString keyName);

   
   // Implementation
protected:
	// Hash table stuff
   CHashItem**       m_pHashTable;
	UINT              m_nHashTableSize;
	UINT              m_nCount;
	CHashItem*        m_pFreeList;
	struct CPlex*     m_pBlocks;
	int               m_nBlockSize;

	CHashItem* NewAssoc();
	void FreeAssoc(CHashItem*);
   CHashItem* GetAssocAt(LPCTSTR, UINT&) const;
   void BuildIndex();
   void ResizeTable();
   
   BOOL              m_CaseSensitive;
   BOOL              m_Indexed;
   BOOL              m_AllowRehash;
   CIndexTree        m_Index;

public:
	~CMapStringToVar();

   void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};




////////////////////////////////////////////////////////////////
#endif // __VARSETMAP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\vset.cpp ===
/*---------------------------------------------------------------------------
  File: VSet.cpp

  Comments: Implementation of IVarSet interface.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 19:44:06

 ---------------------------------------------------------------------------
*/

// VSet.cpp : Implementation of CVSet
#include "stdafx.h"

#ifdef STRIPPED_VARSET
   #include "NoMcs.h"
   #include <comdef.h>
   #include "Err.hpp"
   #include "Varset.h"
#else
#endif 

#include "VarSetI.h"
#include "VSet.h"
#include "VarMap.h"
#include "DotStr.hpp"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVSet

  
/////////////////////////////////////////////////////////////////////
// IVarSet
/////////////////////////////////////////////////////////////////////
// Gets the number of items in the map and all sub-maps
STDMETHODIMP CVSet::get_Count(/* [retval][out] */long* retval)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get_Count");
   
   if (retval == NULL)
   {
      MCSVERIFYSZ(FALSE,"get_Count:  output pointer was null, returning E_POINTER");
      return E_POINTER;
   }

	m_cs.Lock();
   *retval = m_nItems;
   MCSASSERTSZ(! m_nItems || m_nItems == m_data->CountItems() - (m_data->HasData()?0:1),"get_Count:Item count consistency check failed.");
   m_cs.Unlock();
	
   return S_OK;
}

STDMETHODIMP CVSet::get_NumChildren(/* [in] */BSTR parentKey,/* [out,retval] */long*count)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get_NumChildren");

   HRESULT                   hr = S_OK;
   CVarData                * pVar;
   CString                   parent;

   parent = parentKey;
   if ( count == NULL )
   {
      MCSVERIFYSZ(FALSE,"get_NumChildren:  output pointer was null, returning E_POINTER");
      hr = E_POINTER;
   }
   else
   {
      m_cs.Lock();
      pVar = GetItem(parent,FALSE);
      if ( pVar )
      {
         if ( pVar->HasChildren() )
         {
            (*count) = pVar->GetChildren()->GetCount();
         }
         else
         {
            (*count) = 0;
         }
      }
      else
      {
         // The parent key does not exist
         (*count) = 0;
      }
      m_cs.Unlock();
   }
   return hr;
}

  
// Adds or changes a value in the map
STDMETHODIMP CVSet::putObject(/* [in] */BSTR property,/* [in] */VARIANT value)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::putObject");
   
   CVarData                * pVar = NULL;
   HRESULT                   hr = S_OK;

   if ( m_Restrictions & VARSET_RESTRICT_NOCHANGEDATA )
   {
      hr = E_ACCESSDENIED;
   }
   else
   {
      m_cs.Lock();
      m_bNeedToSave = TRUE;
      pVar = GetItem(property,TRUE);
      if ( pVar )
      {
         MC_LOG("set value for " << McString::String(property));
         m_nItems+=pVar->SetData("",&value,FALSE,&hr);
      }
      else
      {
         MCSASSERTSZ(FALSE,"VarSet internal error creating or retrieving node");   
         // GetItem failed - cannot add item to property
         hr = E_FAIL;
      }
      m_cs.Unlock();
   }
   return hr;
}

  
// Adds or changes a value in the map
STDMETHODIMP CVSet::put(/* [in] */BSTR property,/* [in] */VARIANT value)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::put");
   
   CVarData                * pVar = NULL;
   HRESULT                   hr = S_OK;

   if ( m_Restrictions & VARSET_RESTRICT_NOCHANGEDATA )
   {
      hr = E_ACCESSDENIED;
   }
   else
   {
      m_cs.Lock();
      m_bNeedToSave = TRUE;
      pVar = GetItem(property,TRUE);
      if ( pVar )
      {
         MC_LOG("set value for " << McString::String(property));
         m_nItems+=pVar->SetData("",&value,TRUE,&hr);
      }
      else
      {
         MCSASSERTSZ(FALSE,"VarSet internal error creating or retrieving node");   
         // GetItem failed - cannot add item to property
         hr = E_FAIL;
      }
      m_cs.Unlock();
   }
   return hr;
}

CVarData *                                 // ret- pointer to item in varset
   CVSet::GetItem(
      CString                str,          // in - key to look for
      BOOL                   addToMap,     // in - if TRUE, adds the key to the map if it does not exist 
      CVarData             * base          // in - starting point
   )
{
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_INTERNAL,"CVSet::GetItem");
   
   CVarData                * curr = base;
   CVarData                * result = NULL;
   CDottedString             s(str);
   CString                   seg;
   CString                   next;

   if ( ! curr )
   {
      curr = m_data;
      MC_LOG("No basepoint provided, using root element");
   }

   if ( str.IsEmpty() )
   {
      result = curr;
      MC_LOG("Returning current node");
   }
   else
   {
      for ( int i = 0 ; curr && i < s.NumSegments(); i++ )
      {
         s.GetSegment(i,seg);
         MC_LOG("Looking for key segment "<< McString::String(seg) );
         curr->SetCaseSensitive(m_CaseSensitive);
         if  ( ! curr->Lookup(seg,result) )
         {
            if ( addToMap )
            {
               MC_LOG(McString::String(seg) << " not found, creating new node");
               result = new CVarData;
			   if (!result)
				  break;
               try {
                   result->SetCaseSensitive(m_CaseSensitive);
                   result->SetIndexed(m_Indexed);
                   curr->SetAt(seg,result);
                   m_nItems++;
               }
               catch(...)
               {
                   delete result;
                   result = NULL;
                   throw;
               }
            }
            else
            {
               MC_LOG(McString::String(seg) << " not found, aborting");
               result = NULL;
               break;
            }
         }
         curr = result;
      }
   }
   return result;      
}

// Retrieves a value from the map
STDMETHODIMP CVSet::get(/* [in] */BSTR property,/* [retval][out] */VARIANT * value)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get");

   CVarData                * pVar;
   HRESULT                   hr = S_OK;
   CComVariant               var;
   CString                   s;
                       
   if (property == NULL )
   {
      MCSVERIFYSZ(FALSE,"CVSet::get - output pointer is NULL, returning E_POINTER");
      hr = E_POINTER; 
   }
   else
   {
      m_cs.Lock();
      s = property;
      pVar = GetItem(s);
      var.Attach(value);
      if ( pVar )
      {
         MC_LOG("got value for " << McString::String(property));
         var.Copy(pVar->GetData());
      }
      else
      {
         MC_LOG("CVSet::get " << McString::String(property) << " was not found, returning empty variant");
      }
      // if the item was not found, set the variant to VT_EMPTY
      var.Detach(value);
      m_cs.Unlock();
   }
   return hr;
}

STDMETHODIMP CVSet::put_CaseSensitive(/* [in] */BOOL newVal)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::put_CaseSensitive");
   
   HRESULT                   hr = S_OK;

   if ( m_Restrictions & VARSET_RESTRICT_NOCHANGEPROPS )
   {
      hr = E_ACCESSDENIED;
   }
   else
   {
      m_cs.Lock();
      m_bNeedToSave = TRUE;
      m_CaseSensitive = newVal;
      m_cs.Unlock();
   }
   return hr;
}

STDMETHODIMP CVSet::get_CaseSensitive(/* [retval][out] */BOOL * isCaseSensitive)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get_CaseSensitive");
   
   if ( ! isCaseSensitive )
   {
      MCSVERIFYSZ(FALSE,"CVSet::get_CaseSensitive - output pointer is NULL, returning E_POINTER");
      return E_POINTER;
   }
   else
   {
      m_cs.Lock();
      (*isCaseSensitive) = m_CaseSensitive;
      m_cs.Unlock();
   }
   return S_OK;
}


// This function is used to sort the keys being returned from an enum.
 int __cdecl SortComVariantStrings(const void * v1, const void * v2)
{
   CComVariant             * var1 = (CComVariant*)v1;
   CComVariant             * var2 = (CComVariant*)v2;

   if ( var1->vt == VT_BSTR && var2->vt == VT_BSTR )
   {
      return wcscmp(var1->bstrVal,var2->bstrVal);
   }
   return 0;
}


// This returns an IEnumVARIANT interface.  It is used by the VB For Each command.
// This enumerates only the keys, not the values.  It is not very efficient, especially for large sets.
STDMETHODIMP CVSet::get__NewEnum(/* [retval][out] */IUnknown** retval)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get_NewEnum");
   
   if (retval == NULL)
   {
      MCSVERIFYSZ(FALSE,"CVSet::get_NewEnum - output pointer is NULL, returning E_POINTER");
      return E_POINTER;
   }

	// initialize output parameter
   (*retval) = NULL;

	typedef CComObject<CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT,
		_Copy<VARIANT> > > enumvar;

	HRESULT                   hRes = S_OK;

   enumvar * p = new enumvar;
   
	if (p == NULL)
   {
      MCSVERIFYSZ(FALSE,"CVSet::get_NewEnum - Could not create IEnumVARIANT object");
      hRes = E_OUTOFMEMORY;
   }
	else
	{
		hRes = p->FinalConstruct();
		if (hRes == S_OK)
		{
			m_cs.Lock();
         
         CVarData                 * map = m_data;
         CString                    start;
         CString                    seg;
       
                  // Build an array of variants to hold the keys
         CComVariant       * pVars = new CComVariant[m_data->CountItems()+1];
         CString             key;
         int                 offset = 0;

         key = _T("");
         if ( map->GetData() && map->GetData()->vt != VT_EMPTY )
         {
            pVars[offset] = key;
            offset++;
         }
         if ( map->HasChildren() )
         {
            BuildVariantKeyArray(key,map->GetChildren(),pVars,&offset);
         }
      
         if ( ! m_Indexed )
         {
            // Sort the results
            qsort(pVars,offset,(sizeof CComVariant),&SortComVariantStrings);
         }

         hRes = p->Init(pVars, &pVars[offset], NULL,AtlFlagCopy);
			if (hRes == S_OK)
				hRes = p->QueryInterface(IID_IUnknown, (void**)retval);
         
         delete [] pVars;
         m_cs.Unlock();
   	}
	}
	if (hRes != S_OK)
		delete p;
   
   return hRes;
}

// Helper function for get__NewEnum
// copies all the keys in the map, and all sub-maps, into a CComVariant array.
// the values are then sorted if necessary.
void 
   CVSet::BuildVariantKeyArray(
      CString                prefix,       // in - string to tack on to the beginning of each key (used when enumerating subkeys)
      CMapStringToVar      * map,          // in - map containing data
      CComVariant          * pVars,        // i/o- array that will contain all the keys
      int                  * offset        // i/o- number of keys copied to pVars (index to use for next insertion)
   )
{
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_INTERNAL,"CVSet::BuildVariantKeyArray");
  
   int                       i;
   int                       nItems;
   CVarData                * pObj;
   CString                   key;
   CComVariant               var;
   CString                   val;

   if ( ! map )
      return;  // no data =>no work to do

   nItems = map->GetCount();
   
   if ( ! m_Indexed )
   {
      POSITION                  pos;
      
      pos = map->GetStartPosition();
      for ( i = 0 ; pos &&  i < nItems ; i++ )
      {
         map->GetNextAssoc(pos,key,pObj);
         if ( ! prefix.IsEmpty() )
         {
            var = prefix + L"." + key;
         }
         else
         {
            var = key;
         }
         // add each key to the array
         var.Detach(&pVars[(*offset)]);
         (*offset)++;
         if ( pObj->HasChildren() )
         {
            // Recursively do the sub-map
            if ( ! prefix.IsEmpty() )
            {
               BuildVariantKeyArray(prefix+L"."+key,pObj->GetChildren(),pVars,offset);
            }
            else
            {
               BuildVariantKeyArray(key,pObj->GetChildren(),pVars,offset);
            }
         }
      }
   }
   else
   {
      CIndexItem           * item;
      CIndexTree           * index = map->GetIndex();

      ASSERT(index);
      
      if ( ! index )
         return;
      
      item = index->GetFirstItem();

      for ( i = 0 ; item &&  i < nItems ; i++ )
      {
         key = item->GetKey();
         pObj = item->GetValue();

         if ( ! prefix.IsEmpty() )
         {
            var = prefix + L"." + key;
         }
         else
         {
            var = key;
         }
         // add each key to the array
         var.Detach(&pVars[(*offset)]);
         (*offset)++;
         if ( pObj->HasChildren() )
         {
            // Recursively do the sub-map
            if ( ! prefix.IsEmpty() )
            {
               BuildVariantKeyArray(prefix+L"."+key,pObj->GetChildren(),pVars,offset);
            }
            else
            {
               BuildVariantKeyArray(key,pObj->GetChildren(),pVars,offset);
            }
         }
         item = index->GetNextItem(item);
      }
   }
   
}

STDMETHODIMP 
   CVSet::getItems2(
      /* [in] */VARIANT      basepoint,     // in - if specified, only children of this node will be enumerated
      /* [in] */VARIANT      startAfter,    // in - the enumeration will begin with the next item in the map following this key.
      /* [in] */VARIANT      bRecursive,    // in - TRUE includes all sub-items, FALSE enumerates one level only.
      /* [in] */VARIANT      bSize,         // in - max number of elements to return (the size of the arrays)
      /* [out] */VARIANT   * keyVar,        // out- array of keys
      /* [out] */VARIANT   * valVar,        // out- array of values
      /* [in,out] */VARIANT* nReturned      // out- number of items copied
   )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::getItems2");
  
   HRESULT                   hr = S_OK;
   LONG                      n = 0;
   LONG                      size = bSize.pvarVal->iVal;
   
   // TODO:  Verify that all the arguments are the correct type!

   // Allocate SAFEARRAYs for the keys and values
   SAFEARRAY               * keys = NULL; 
   SAFEARRAY               * values= NULL;
   _variant_t                key;
   _variant_t                val;
   _variant_t                num;

   if ( ! keys || !values )
   {
      hr = E_OUTOFMEMORY;      
   }
   else
   {
      hr = getItems(basepoint.bstrVal,startAfter.bstrVal,bRecursive.boolVal,size,&keys,&values,&n);
      key.vt = VT_ARRAY | VT_VARIANT;
      key.parray = keys;
      val.vt = VT_ARRAY | VT_VARIANT;
      val.parray = values;
      num.vt = VT_I4;
      num.lVal = n;
      (*keyVar) = key.Detach();
      (*valVar) = val.Detach();
      (*nReturned) = num.Detach();
   }
   return hr;

}

STDMETHODIMP 
   CVSet::getItems(
      /* [in] */BSTR          basepoint,     // in - if specified, only children of this node will be enumerated
      /* [in] */BSTR          startAfter,    // in - the enumeration will begin with the next item in the map following this key.
      /* [in] */BOOL          bRecursive,    // in - TRUE includes all sub-items, FALSE enumerates one level only.
      /* [in] */ULONG         bSize,         // in - max number of elements to return (the size of the arrays)
      /* [out] */SAFEARRAY ** keys,          // out- array of keys
      /* [out] */SAFEARRAY ** values,        // out- array of values
      /* [out] */LONG       * nReturned      // out- number of items copied
   )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::getItems");
  
   HRESULT                   hr = S_OK;

   (*nReturned) = 0;
   (*keys) = 0;
   (*values) = 0;

   m_cs.Lock();
   
   CVarData                * map = m_data;
   CString                   base;
   CString                   start;
   CString                   seg;
 

   // Find the map to enumerate
   base = basepoint;
   if ( base.GetLength() > 0 )
   {
      map = GetItem(base);
   }
   
   if ( ! map )
   {
         // not found
      (*nReturned) = 0;
   }
   else
   {
      // Build an array of variants to hold the keys
      int                 offset = 0;

      SAFEARRAYBOUND            bound[1];
      LONG                      n = 0;
      LONG                      size = bSize;
   
      bound[0].lLbound = 0;
      bound[0].cElements = size;

      
      // Allocate SAFEARRAYs for the keys and values
      (*keys) = SafeArrayCreate(VT_VARIANT, 1, bound);
      (*values) = SafeArrayCreate(VT_VARIANT, 1, bound);
  
      start = startAfter;
      
      if ( base.GetLength() && start.GetLength() )
      {
         // ASSERT( that LEFT(start,LEN(base)) = base
         //start = start.Right(start.GetLength() - base.GetLength() - 1);
      }
      
      if ( base.IsEmpty() && start.IsEmpty() )
      {
         if ( map->GetData() && map->GetData()->vt != VT_EMPTY )
         {
            long             index[1];

            index[0] = 0;
            // add the root element to the results
            if ( (*keys)->fFeatures & FADF_BSTR  )
            {
               SafeArrayPutElement((*keys),index,_T(""));
            }
            else
            {
               // VBScript can only use VARIANT arrays (see getItems2)
               _variant_t tempKey;
               tempKey = _T("");
               SafeArrayPutElement((*keys),index,&tempKey);
            }
         
            SafeArrayPutElement((*values),index,map->GetData());
            offset++;
         }
         
      }
      if ( map->HasChildren() )
      {
         BuildVariantKeyValueArray(base,start,map->GetChildren(),(*keys),
            (*values),&offset,bSize,bRecursive);
      }
      (*nReturned) = offset;
   }
   m_cs.Unlock();
	

	return hr;
}

// helper function for getItems.  Fills SAFEARRAYs of keys and values
// if the varset is indexed, the items will be returned in sorted order, o.w. they will be in arbitrary (but consistent) order.
void 
   CVSet::BuildVariantKeyValueArray(
      CString                prefix,         // in - string to tack on to the beginning of each key (used when enumerating subkeys)
      CString                startAfter,     // in - optional, enumerates only those items that alphabetically follow this one.
      CMapStringToVar      * map,            // in - map containing the data
      SAFEARRAY            * keys,           // i/o- array that will contain the key values for the requested items
      SAFEARRAY            * pVars,          // i/o- array that will contain the data values for the requested items
      int                  * offset,         // i/o- number of items copied to the arrays (index to use for next insertion)
      int                    maxOffset,      // in - allocated size of the arrays
      BOOL                   bRecurse        // in - whether to recursively process children
   )
{
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_INTERNAL,"CVSet::BuildVariantKeyValueArray");
  
   int                 i;
   int                 nItems;
   CVarData          * pObj;
   CString             key;   // last segment of key name 
   POSITION            pos;
   
   CComBSTR            val;   // fully qualified key name to add to array (val = prefix.key)
   CComVariant         var;   // value to add to array
   BOOL                includeSomeChildrenOnly;

   CDottedString       dBase(prefix);
   CDottedString       dStartItem(startAfter);
   
   int                 depth = dBase.NumSegments();
    
   if ( ! map )   
      return; // no data => nothing to do

   if ( (*offset) >= maxOffset )
      return; // the arrays are full
   
   includeSomeChildrenOnly = dStartItem.NumSegments() > depth;

   nItems = map->GetCount();
   // If we're not using an index, the items will be returned in arbitrary order
   if ( ! m_Indexed )
   {
      if ( includeSomeChildrenOnly && bRecurse )
      {
         // the startAfter item is in a subtree.  Find the appropriate element at this level and recursively continue the search   
         dStartItem.GetSegment(depth,key);
         if ( map->Lookup(key,pObj) )
         {
            // found the object
            if ( ! prefix.IsEmpty() )
            {
               BuildVariantKeyValueArray(prefix+_T(".")+key,startAfter,pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
            else
            {
               BuildVariantKeyValueArray(key,startAfter,pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
         }
         // we've included the children of this item that come after 'startAfter',
         // now process the rest of the items at this level
         // make sure there's still room
         if ( (*offset) >= maxOffset )
            return; // the arrays are full
      }
      
      // this is the usual case.  process the items at this level, starting with the element following StartAfter.
      
      // Get a pointer to that first element
      if ( startAfter.GetLength() > prefix.GetLength())
      {
         CString startItem;
         dStartItem.GetSegment(depth,startItem);
         // this returns the position before startItem
         pos = (POSITION)map->GetPositionAt(startItem);
		 if (!pos)
	        return;
         map->GetNextAssoc(pos,key,pObj);
      }
      else 
      {
         pos = map->GetStartPosition();
      }

      for ( i = 0 ; pos &&  i < nItems ; i++ )
      {
         map->GetNextAssoc(pos,key,pObj);
         if ( ! prefix.IsEmpty() )
         {
            val = prefix + L"." + key;
         }
         else
         {
            val = key;
         }
         // copy each item into the arrays
         ASSERT((*offset) < maxOffset);
         var.Copy(pObj->GetData());
         LONG                index[1];
         index[0] = (*offset);
         SafeArrayPutElement(pVars,index,&var);
         if ( keys->fFeatures & FADF_BSTR  )
         {
            SafeArrayPutElement(keys,index,val);
         }
         else
         {
            // VBScript can only use VARIANT arrays (see getItems2)
            _variant_t tempKey;
            tempKey = val;
            SafeArrayPutElement(keys,index,&tempKey);
         }

         var.Clear();
         (*offset)++;
         if ( *offset >= maxOffset )
            break; // arrays are full - stop
      
         if ( bRecurse && pObj->HasChildren() )
         {
            // Recursively do the sub-map
            if ( ! prefix.IsEmpty() )
            {
               BuildVariantKeyValueArray(prefix+L"."+key,"",pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
            else
            {
               BuildVariantKeyValueArray(key,"",pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
            if ( *offset >= maxOffset )
               break; // arrays are full - stop
         }
      }
   }
   else
   {
      // Use the index to enumerate the items in alphabetical order
      
      CIndexItem           * curr;
      CIndexTree           * ndx = map->GetIndex();
      
      ASSERT (ndx != NULL);

      if ( includeSomeChildrenOnly && bRecurse )
      {
         // the startAfter item is in a subtree.  Find the appropriate element at this level and recursively continue the search   
         dStartItem.GetSegment(depth,key);
         if ( map->Lookup(key,pObj) )
         {
            // found the object
            if ( ! prefix.IsEmpty() )
            {
               BuildVariantKeyValueArray(prefix+_T(".")+key,startAfter,pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
            else
            {
               BuildVariantKeyValueArray(key,startAfter,pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
         }
         // we've included the children of this item that come after 'startAfter',
         // now process the rest of the items at this level
         // make sure there's still room
         if ( (*offset) >= maxOffset )
            return; // the arrays are full
      }
      
      // Get a pointer to the first item at this level AFTER startAfter
      if ( startAfter.GetLength() > prefix.GetLength() )
      {
         CString startItem;
         dStartItem.GetSegment(depth,startItem);
         // if a starting item is specified, try using the hash function to find it in the table
         curr = map->GetIndexAt(startItem);
         if ( curr )
         {
            curr = ndx->GetNextItem(curr);
         }
         else
         {
            // The startAfter item is not in the table.  Search the tree to find 
            // the first item that would follow it if it were there
            curr = ndx->GetFirstAfter(startItem);
         }
      }
      else
      {
         curr = ndx->GetFirstItem();  
      }
      // Process all the items
      while ( curr )
      {
         pObj = curr->GetValue();
         key = curr->GetKey();

         curr = ndx->GetNextItem(curr);
         if ( ! prefix.IsEmpty() )
         {
            val = prefix + L"." + key;
         }
         else
         {
            val = key;
         }
         // add each item to the arrays
         ASSERT((*offset) < maxOffset);
         
         var.Copy(pObj->GetData());
         
         LONG                index[1];
         
         index[0] = (*offset);
         SafeArrayPutElement(pVars,index,&var);
         if ( keys->fFeatures & FADF_BSTR  )
         {
            SafeArrayPutElement(keys,index,val);
         }
         else
         {
            // VBScript can only use VARIANT arrays (see getItems2)
            _variant_t tempKey;
            tempKey = val;
            SafeArrayPutElement(keys,index,&tempKey);
         }

         var.Clear();         
         (*offset)++;
         
         if ( *offset >= maxOffset )
            break; // arrays are full - stop
         
         if ( bRecurse && pObj->HasChildren() )
         {
            // Recursively do the sub-map
            if ( ! prefix.IsEmpty() )
            {
               BuildVariantKeyValueArray(prefix+L"."+key,"",pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
            else
            {
               BuildVariantKeyValueArray(key,"",pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
            if ( *offset >= maxOffset )
               break; // arrays are full - stop
         }
      }
   }
}

        
STDMETHODIMP CVSet::Clear()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::Clear");
  
   HRESULT                   hr = S_OK;
   
   if ( m_Restrictions & VARSET_RESTRICT_NOCHANGEDATA )
   {
      hr = E_ACCESSDENIED;
   }
   else
   {
      m_cs.Lock();
      m_bNeedToSave = TRUE;
      m_data->RemoveAll();
      m_data->GetData()->Clear();
      m_data->GetData()->ChangeType(VT_EMPTY);
      m_nItems = 0;
      m_cs.Unlock();
   }
   
   return hr;
}

//////////////IPersistStreamInit//////////////////////////////////////////////////////

STDMETHODIMP CVSet::GetClassID(CLSID __RPC_FAR *pClassID)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   (*pClassID) = CLSID_VarSet;
   
   return S_OK;
}

STDMETHODIMP CVSet::IsDirty()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   if ( m_bNeedToSave )
   {
      return S_OK;
   }
   else
   {
      return S_FALSE;
   }
}
     
STDMETHODIMP CVSet::Load(LPSTREAM pStm)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   ULONG                result = 0;
   HRESULT              hr;

   m_cs.Lock();

   do {  // once

      hr = pStm->Read(&m_nItems,(sizeof m_nItems),&result);
      if ( FAILED(hr) )
         break;
      hr = pStm->Read(&m_CaseSensitive,(sizeof m_CaseSensitive),&result);
      if ( FAILED(hr) )
         break;
      hr = pStm->Read(&m_Indexed,(sizeof m_Indexed),&result);
      if ( FAILED(hr) )
         break;
      hr = m_data->ReadFromStream(pStm);
      m_bNeedToSave = FALSE;
      m_bLoaded = TRUE;
   }
   while (FALSE);

   m_cs.Unlock();

   return hr;
}
     
STDMETHODIMP CVSet::Save(LPSTREAM pStm,BOOL fClearDirty)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   ULONG             result = 0;
   HRESULT           hr;

   m_cs.Lock();

   do {   // once
      hr = pStm->Write(&m_nItems,(sizeof m_nItems),&result);
      if ( FAILED(hr) )
         break;
      hr = pStm->Write(&m_CaseSensitive,(sizeof m_CaseSensitive),&result);
      if ( FAILED(hr) )
         break;
      hr = pStm->Write(&m_Indexed,(sizeof m_Indexed),&result);
      if ( FAILED(hr) )
         break;
      hr = m_data->WriteToStream(pStm);
      if ( fClearDirty )
      {
         m_bNeedToSave = FALSE;
      }
   }while (FALSE);

   m_cs.Unlock();
   return hr;
}

STDMETHODIMP CVSet::GetSizeMax(ULARGE_INTEGER __RPC_FAR *pCbSize)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_INTERNAL,"VarSet GetSizeMax");

   HRESULT                   hr = S_OK;

   if ( pCbSize == NULL )
   {
      return E_POINTER;
   }
   else
   {
      LPSTREAM               pStr = NULL;
      DWORD                  rc;
      STATSTG                stats;
      DWORD                  requiredLength = 0; 


      rc = CreateStreamOnHGlobal(NULL,TRUE,&pStr);
      if ( ! rc )
      {
         hr = Save(pStr,FALSE);
         if (SUCCEEDED(hr) )
         {
            hr = pStr->Stat(&stats,STATFLAG_NONAME);
            if (SUCCEEDED(hr) )
            {
               requiredLength = stats.cbSize.LowPart;
            }
         }
         pStr->Release();
      }

      pCbSize->LowPart = requiredLength;
      MC_LOG("Size is " << McString::makeStr(requiredLength) );
      pCbSize->HighPart = 0;
   }
   
   return hr;
}
    
STDMETHODIMP CVSet::InitNew()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   if ( m_bLoaded )
   {
      return E_UNEXPECTED;
   }
   else
   {
      m_cs.Lock();
      InitProperties();
      m_cs.Unlock();
      return S_OK;
   }
}

STDMETHODIMP CVSet::ImportSubTree(/*[in] */ BSTR key, /* [in] */ IVarSet * pVarSet)
{

   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::ImportSubTree");

   HRESULT                   hr = S_OK;
   VARIANT                   value;
   ULONG                     nGot;
   _bstr_t                   keyB;
   _bstr_t                   newkey;
   // make sure the varset is valid
                   
   // enumerate the varset, inserting each item into the tree as key.item
   IEnumVARIANT            * varEnum = NULL;
   IUnknown                * pUnk = NULL;

   // TODO:  need to speed this up by using getItems
   hr = pVarSet->get__NewEnum(&pUnk);
   if ( SUCCEEDED(hr) )
   {
      hr = pUnk->QueryInterface(IID_IEnumVARIANT,(void**)&varEnum);
      pUnk->Release();
   }
   if ( SUCCEEDED(hr))
   {
      value.vt = VT_EMPTY;
      while ( SUCCEEDED(hr = varEnum->Next(1,&value,&nGot)) )
      {
         if ( nGot==1 )
         {
            keyB = value.bstrVal;
            newkey = key;
            if ( newkey.length() )
            {
               newkey += _T(".");
            }
            newkey += keyB;
            hr = pVarSet->get(keyB,&value);
            if ( SUCCEEDED(hr )  )
            {
               hr = put(newkey,value);
            }
         }
         else
         {
            break;
         }
         if ( FAILED(hr) )
            break;
      }
      if ( varEnum )
         varEnum->Release();
   }
   varEnum = NULL;
  // clean up
   return hr;
}

STDMETHODIMP CVSet::getReference( /* [in] */ BSTR key, /* [out,retval] */IVarSet ** ppVarSet)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::getReference");

   HRESULT                   hr = S_OK;
   CVarData                * item = GetItem(key);
   
   typedef CComObject<CVSet> myvset;

   myvset                  * pVarSet;

   if ( ! ppVarSet )
   {
      hr = E_POINTER;
   }
   else
   {
      if ( item )
      {
         pVarSet = new myvset; 
         AddRef();
         ((CVSet*)pVarSet)->SetData(this,item,m_Restrictions);
         hr = pVarSet->QueryInterface(IID_IVarSet,(void**)ppVarSet);
      }
      else
      {
         hr = TYPE_E_ELEMENTNOTFOUND;
      }
   }
   return hr;
}

STDMETHODIMP CVSet::DumpToFile(BSTR filename)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())

   HRESULT                   hr = S_OK;

#ifdef STRIPPED_VARSET
   
   USES_CONVERSION;
   
   TError                    errLog;
   
   errLog.LogOpen((WCHAR*)filename,1,0);

   errLog.MsgWrite(0,L"VarSet");
   errLog.MsgWrite(0,L"Case Sensitive: %s, Indexed: %s",(m_CaseSensitive ? L"Yes" : L"No"),(m_Indexed ? L"Yes" : L"No") );
   errLog.MsgWrite(0,L"User Data ( %ld ) items",m_nItems);
#else
  
#endif     
   m_cs.Lock();
         
   CVarData                * map = m_data;
   CString                   start;
   CString                   seg;
 
                  // Build an array of variants to hold the keys
   CComVariant             * pVars = new CComVariant[m_data->CountItems()+1];
   CString                   key;
   int                       offset = 1;
   
   key = _T("");
   
   if (!pVars)
   {
      m_cs.Unlock();
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   }

   // include the root item in the list
   
   pVars[0] = key;
   if ( map->HasChildren() )
   {
      BuildVariantKeyArray(key,map->GetChildren(),pVars,&offset);
   }
   
   m_cs.Unlock();

   if ( ! m_Indexed )
   {
       // Sort the results
      qsort(pVars,offset,(sizeof CComVariant),&SortComVariantStrings);
   }

   
   for ( int i = 0 ; i < offset ; i++ )
   {
      CVarData             * data;
      CString                value;
      CString                key;

      key = pVars[i].bstrVal;

      data = GetItem(key);

      if ( data )
      {
         switch ( data->GetData()->vt )
         {
         case VT_EMPTY:      
            value = _T("<Empty>");
            break;
         case VT_NULL:
            value = _T("<Null>");
            break;
         case VT_I2:
            value.Format(_T("%ld"),data->GetData()->iVal);
            break;
         case VT_I4:
            value.Format(_T("%ld"),data->GetData()->lVal);
            break;
         case VT_BSTR:
            value = data->GetData()->bstrVal;
            break;
         default:
            value.Format(_T("variant type=0x%lx"),data->GetData()->vt);
            break;
         }
#ifdef STRIPPED_VARSET
         errLog.MsgWrite(0,L" [%ls] %ls",key.GetBuffer(0),value.GetBuffer(0));
#else
 
#endif
      }
      else
      {
#ifdef STRIPPED_VARSET
         errLog.MsgWrite(0,L" [%ls] <No Value>",key.GetBuffer(0));
#else
#endif 
      }
   }
   delete [] pVars;
   return hr;
}

STDMETHODIMP CVSet::get_Indexed(BOOL *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get_Indexed");
   if ( pVal == NULL )
      return E_POINTER;
   
   m_cs.Lock();
   (*pVal) = m_Indexed;
   m_cs.Unlock();

   return S_OK;
}

STDMETHODIMP CVSet::put_Indexed(BOOL newVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::put_Indexed");
   
   HRESULT                   hr = S_OK;
   
   if ( m_Restrictions & VARSET_RESTRICT_NOCHANGEPROPS )
   {
      hr = E_ACCESSDENIED;
   }
   else
   {
      m_cs.Lock();
      m_bNeedToSave = TRUE;
      m_Indexed = newVal;  
      m_data->SetIndexed(m_Indexed);
      m_cs.Unlock();
   }
   return hr;
}


STDMETHODIMP CVSet::get_AllowRehashing(BOOL *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get_AllowRehashing");
   if ( pVal == NULL )
      return E_POINTER;
   
   m_cs.Lock();
   (*pVal) = m_AllowRehashing;
   m_cs.Unlock();

   return S_OK;
}

STDMETHODIMP CVSet::put_AllowRehashing(BOOL newVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::put_AllowRehashing");
   
   HRESULT                   hr = S_OK;
   
   if ( m_Restrictions & VARSET_RESTRICT_NOCHANGEPROPS )
   {
      hr = E_ACCESSDENIED;
   }
   else
   {

      m_cs.Lock();
   
      m_bNeedToSave = TRUE;
   
      m_AllowRehashing = newVal;
      m_data->SetAllowRehashing(newVal);

      m_cs.Unlock();
   }   
   return hr;
}         

STDMETHODIMP CVSet::get_Restrictions(DWORD * restrictions)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   HRESULT                   hr = S_OK;

   if ( restrictions == NULL )
   {
      hr = E_POINTER;
   }
   else
   {
      (*restrictions) = m_Restrictions;
   }
   return hr;
}

STDMETHODIMP CVSet::put_Restrictions(DWORD newRestrictions)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   HRESULT                   hr = S_OK;
   DWORD                     rAdding = newRestrictions & ~m_Restrictions;
   DWORD                     rRemoving = ~newRestrictions & m_Restrictions;


   // Can't remove any restrictions passed down from parent.
   if ( ( rRemoving & m_ImmutableRestrictions) )
   {
      hr = E_ACCESSDENIED;
   }
   else if ( rAdding & ! VARSET_RESTRICT_ALL )
   {
      hr = E_NOTIMPL;
   }
   else
   {
      // the change is OK.
      m_Restrictions = newRestrictions;
   }
   return hr;
}

// IMarshal implemention
// This marshals the varset to a stream that is then sent across the wire
STDMETHODIMP CVSet::GetUnmarshalClass(REFIID riid, void *pv, DWORD dwDestContext, void *pvDestContext, DWORD mshlflags, CLSID *pCid)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   *pCid = GetObjectCLSID();
   
   return S_OK;
}
 
STDMETHODIMP CVSet::GetMarshalSizeMax(REFIID riid, void *pv, DWORD dwDestContext, void *pvDestContext, DWORD mshlflags, DWORD *pSize)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   HRESULT                   hr = S_OK; 
   ULARGE_INTEGER            uli;
   
   hr = GetSizeMax(&uli);

   if (SUCCEEDED(hr))
   {
      *pSize = uli.LowPart;
   }
   
   return hr;
}
 
STDMETHODIMP CVSet::MarshalInterface(IStream *pStm, REFIID riid, void *pv, DWORD dwDestContext, void *pvDestCtx, DWORD mshlflags)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   HRESULT                   hr = S_OK;
   
   // Save the varset's data to a stream
   hr = Save(pStm, FALSE);
     
   return hr;
}
 
STDMETHODIMP CVSet::UnmarshalInterface(IStream *pStm, REFIID riid, void **ppv)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   HRESULT                 hr = S_OK;
     
   // Load up the data from the stream using our IPersistStream implementation
   hr = Load(pStm);

   if ( SUCCEEDED(hr) )
   {
      hr = QueryInterface(riid,ppv);
   }
     
   return hr;
}
 
STDMETHODIMP CVSet::ReleaseMarshalData(IStream * /*pStmNotNeeded*/)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   // we don't keep any state data, so there's nothing to release
   // since we just read the object from the stream, the stream's pointer should already be at the end,
   // so there's nothing left for us to do here
   return S_OK;
}
 
STDMETHODIMP CVSet::DisconnectObject(DWORD /*dwReservedNotUsed*/)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\varmap.cpp ===
/*---------------------------------------------------------------------------
  File: VarMap.cpp

  Comments: This class implements a hash table which contains the keys stored in the varset,
      along with their values.

      CaseSensitive property - The case of each key is preserved as it was when
      the key was first added to the map.  The hash function is not case sensitive,
      so the CaseSensitive property can be toggled on and off without rehashing the data.
      
      Optional indexing to allow for fast enumeration in alphabetical order by key.
      This will add overhead to insert operations.  Without indexing, the contents of 
      the map can be enumerated, but they will be in arbitrary order.

      Stream I/O functions for persistance.



  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 18:31:57

 ---------------------------------------------------------------------------
*/


#include "stdafx.h"
#include <afx.h>
#include <afxplex_.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "VarMap.h"

#ifdef STRIPPED_VARSET
   #include "NoMcs.h"
#else
   #pragma warning (push,3)
   #include "McString.h" 
   #include "McLog.h"
   #pragma warning (pop)
   using namespace McString;
#endif

static inline void FreeString(CString* pOldData)
{
	pOldData->~CString();
}


const UINT HashSizes[] = { 17, 251, 1049, 10753, 100417, 1299673 , 0 };


CMapStringToVar::CMapStringToVar(BOOL isCaseSensitive, BOOL isIndexed, BOOL allowRehash,int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_pHashTable = NULL;
	m_nHashTableSize = HashSizes[0];  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
   m_CaseSensitive = isCaseSensitive;
   m_Indexed = isIndexed;
   m_AllowRehash = allowRehash;
}

inline UINT CMapStringToVar::HashKey(LPCTSTR key) const
{
	UINT nHash = 0;
	while (*key)
   {
      nHash = (nHash<<5) + nHash + toupper(*key++);
   }
	return nHash;
}

void CMapStringToVar::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CHashItem* [nHashSize];
		if (!m_pHashTable)
		   return;
		memset(m_pHashTable, 0, sizeof(CHashItem*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

void CMapStringToVar::ResizeTable()
{
   // get the new size
   UINT                      nHashSize = 0;
   
   // find the current hash size in the array
   for ( int i = 0 ; HashSizes[i] <= m_nHashTableSize ; i++ )
   {
      if ( HashSizes[i] == m_nHashTableSize )
      {
         nHashSize = HashSizes[i+1];
         break;
      }
   }
   if ( nHashSize )
   {
      MC_LOGIF(VARSET_LOGLEVEL_INTERNAL,"Increasing hash size to "<< makeStr(nHashSize) );
      CHashItem ** oldHashTable = m_pHashTable;
      m_pHashTable = new CHashItem* [nHashSize];
	  if (!m_pHashTable)
	     return;
      memset(m_pHashTable,0, sizeof(CHashItem*) * nHashSize );
      // Rehash the existing items into the new table
      for ( UINT bucket = 0 ; bucket < m_nHashTableSize ; bucket++ )
      {
         CHashItem* pAssoc;
         CHashItem* pNext;

			for (pAssoc = oldHashTable[bucket]; pAssoc != NULL; pAssoc = pNext)
			{
			   pNext = pAssoc->pNext;
            // Re-hash, and insert into new table
            pAssoc->nHashValue = HashKey(pAssoc->key) % nHashSize;
            pAssoc->pNext = m_pHashTable[pAssoc->nHashValue];
            m_pHashTable[pAssoc->nHashValue] = pAssoc;
         }
			
      }
      // cleanup the old table 
      delete [] oldHashTable;
      m_nHashTableSize = nHashSize;
   }
   else
   {
      MC_LOG("Table size is "<< makeStr(m_nHashTableSize) << ".  Larger hash size not found, disabling rehashing.");
      m_AllowRehash = FALSE;
   }

}

void CMapStringToVar::RemoveAll()
{

	if ( m_Indexed )
   {
      m_Index.RemoveAll();
   }
	if (m_pHashTable != NULL)
	{
		// remove and destroy each element
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CHashItem* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				FreeString(&pAssoc->key);  

			}
		}

		// free hash table
		delete [] m_pHashTable;
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CMapStringToVar::~CMapStringToVar()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers

CHashItem*
CMapStringToVar::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
							sizeof(CHashItem));
		// chain them into free list
		CHashItem* pAssoc = (CHashItem*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CHashItem* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
	memcpy(&pAssoc->key, &afxEmptyString, sizeof(CString));

	pAssoc->value = 0;

	return pAssoc;
}

void CMapStringToVar::FreeAssoc(CHashItem* pAssoc)
{
	FreeString(&pAssoc->key);  // free up string data

	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	MCSASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

CHashItem*
CMapStringToVar::GetAssocAt(LPCTSTR key, UINT& nHash) const
// find association (or return NULL)
{
	nHash = HashKey(key) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CHashItem* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
	   if ( m_CaseSensitive )
      {
         if (pAssoc->key == key)
			   return pAssoc;
      }
      else
      {
         if ( ! pAssoc->key.CompareNoCase(key) )
            return pAssoc;
      }
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////

BOOL CMapStringToVar::Lookup(LPCTSTR key, CVarData*& rValue) const
{
	ASSERT_VALID(this);

	UINT nHash;
   CHashItem* pAssoc = GetAssocAt(key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

BOOL CMapStringToVar::LookupKey(LPCTSTR key, LPCTSTR& rKey) const
{
	ASSERT_VALID(this);

	UINT nHash;
	CHashItem* pAssoc = GetAssocAt(key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rKey = pAssoc->key;
	return TRUE;
}

CVarData*& CMapStringToVar::operator[](LPCTSTR key)
{
	ASSERT_VALID(this);

	UINT nHash;
	CHashItem* pAssoc;
   // Grow the hash table, if necessary	
   if ( m_AllowRehash && ( m_nCount > 2 * m_nHashTableSize )  )
   {
      ResizeTable();
   }
   if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHash;
		pAssoc->key = key;
		

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;
      if ( m_Indexed )
      {
         pAssoc->pIndex = m_Index.Insert(pAssoc);
      }
      else
      {
         pAssoc->pIndex = NULL;
      }
	}
	
   return pAssoc->value;  // return new reference
}

void CMapStringToVar::SetIndexed(BOOL val)
{
   POSITION                  pos = GetStartPosition();
   CString                   key;
   CVarData                * value;
   
   
   if ( ! m_Indexed && val ) 
   {
       BuildIndex(); 
   }
   m_Indexed = val;  
   
   // recursively update children
   while ( pos )
   {
      GetNextAssoc(pos,key,value);
      if ( value )
      {
         value->SetIndexed(val);
      }   
   }
}


void CMapStringToVar::BuildIndex()
{
   // delete any old entries
   m_Index.RemoveAll();
   
   CHashItem               * pAssoc;
   POSITION                  pos = GetStartPosition();
   CString                   key;
   CVarData                * value;
   UINT                      hash;
   
   while ( pos )
   {
      GetNextAssoc(pos,key,value);
      pAssoc = GetAssocAt(key,hash);
      if ( pAssoc )
      {
         pAssoc->pIndex = m_Index.Insert(pAssoc);
         if ( value->HasChildren() )
         {
            value->GetChildren()->SetIndexed(TRUE);
         }
      }   
   }

}

BOOL CMapStringToVar::RemoveKey(LPCTSTR key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CHashItem** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey(key) % m_nHashTableSize];

	CHashItem* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
      if ( (m_CaseSensitive && (pAssoc->key == key) || !m_CaseSensitive && pAssoc->key.CompareNoCase(key) ) )
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

/////////////////////////////////////////////////////////////////////////////
// Iterating

void CMapStringToVar::GetNextAssoc(POSITION& rNextPosition,
	CString& rKey, CVarData*& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CHashItem* pAssocRet = (CHashItem*)rNextPosition;
	ASSERT(pAssocRet != NULL);

	if (pAssocRet == (CHashItem*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		ASSERT(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CHashItem)));
	CHashItem* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}


/////////////////////////////////////////////////////////////////////////////
// Serialization

void CMapStringToVar::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nCount);
		if (m_nCount == 0)
			return;  // nothing more to do

		ASSERT(m_pHashTable != NULL);
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CHashItem* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
//				ar << pAssoc->key;
			//	ar << pAssoc->value;
			}
		}
	}
	else
	{
//		DWORD nNewCount = ar.ReadCount();
//		CString newKey;
//		CVarData* newValue;
//		while (nNewCount--)
//		{
	//		ar >> newKey;
		//	ar >> newValue;
		//	SetAt(newKey, newValue);
//		}
	}
}

void CMapStringToVar::McLogInternalDiagnostics(CString keyName)
{
   MC_LOGBLOCK("HashTable");
   MC_LOG("   " << String(keyName) << "Count="<<makeStr(m_nCount) << " Case Sensitive="<< (m_CaseSensitive?"TRUE":"FALSE") << " Indexed="<<(m_Indexed?"TRUE":"FALSE") );
   
   MC_LOG("TableSize="<<makeStr(m_nHashTableSize));
   for ( UINT i = 0 ; i < m_nHashTableSize ; i++ )
   {
      CHashItem            * pAssoc;
      MC_LOG("Bucket " << makeStr(i));
      for ( pAssoc = m_pHashTable[i] ; pAssoc != NULL ; pAssoc=pAssoc->pNext)
      {
         if ( pAssoc->value )
         {
            CString subKey;
            subKey = keyName;
            if ( ! subKey.IsEmpty() )
            {
               subKey += _T(".");
            }
            subKey += pAssoc->key;
            pAssoc->value->McLogInternalDiagnostics(subKey);
         }

         if ( keyName.IsEmpty() )
         {
            MC_LOG("   Address="<< makeStr(pAssoc,L"0x%lx") << " Key="<< String(pAssoc->key));
         }
         else
         {
            MC_LOG("   Address="<< makeStr(pAssoc,L"0x%lx") << " Key="<< String(keyName) << "."<< String(pAssoc->key));
         }


         MC_LOG("   ValueAddress=" << makeStr(pAssoc->value,L"0x%lx") << " IndexAddress="<<makeStr(pAssoc->pIndex,L"0x%lx"));
         
      }
   }
   if ( m_Indexed )
   {
      m_Index.McLogInternalDiagnostics(keyName);
   }
}
HRESULT CMapStringToVar::WriteToStream(LPSTREAM pS)
{
   HRESULT                   hr;
   ULONG                     result;
   CComBSTR                  str;

   do {
      hr = pS->Write(&m_nCount,(sizeof m_nCount),&result);
      if ( FAILED(hr) ) 
         break;
      if ( m_nCount )
      {
         for ( UINT nHash = 0 ; nHash < m_nHashTableSize ; nHash++ )
         {
            CHashItem         * pAssoc;
            
            for ( pAssoc = m_pHashTable[nHash]; pAssoc != NULL ; pAssoc=pAssoc->pNext)
            {
               // write the key
               str = pAssoc->key;
               hr = str.WriteToStream(pS);
               if ( FAILED(hr) )
                  break;
               // then the value
               hr = pAssoc->value->WriteToStream(pS);
               if ( FAILED(hr) )
                  break;
            }
            if ( FAILED(hr) )
               break;
         }
      }
   }while ( FALSE );

   return hr;
}


HRESULT CMapStringToVar::ReadFromStream(LPSTREAM pS)
{
   HRESULT                   hr;
   ULONG                     result;
   CComBSTR                  str;
   int                       count;
   do {
      hr = pS->Read(&count,(sizeof count),&result);
      if ( FAILED(hr) ) 
         break;
      
      if ( count )
      {
         // Find the closest hash table size to our count
         UINT                nHashSize = HashSizes[0];
   
      
         for ( int size = 0 ; HashSizes[size] != 0 && nHashSize < (UINT)count ; size++ )
         {
            nHashSize = HashSizes[size];
         }
   
         InitHashTable(nHashSize);
         for ( int i = 0 ; i < count ; i++ )
         {
            CString             key;
            CVarData          * pObj = new CVarData;
			if (!pObj)
	           return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

            pObj->SetCaseSensitive(m_CaseSensitive);
            pObj->SetIndexed(m_Indexed);
            hr = str.ReadFromStream(pS);
            if ( FAILED(hr) )
               break;
            key = str;      
            str.Empty();
            hr = pObj->ReadFromStream(pS);
            if ( FAILED(hr) )
               break;
            SetAt(key,pObj);
         }
      }
   }while ( FALSE );
   return hr;
}

DWORD 
   CMapStringToVar::CalculateStreamedLength()
{
   DWORD                     len = (sizeof m_nCount);

   if ( m_nCount )
   {
      for ( UINT nHash = 0 ; nHash < m_nHashTableSize ; nHash++ )
      {
         CHashItem         * pAssoc;
         
         for ( pAssoc = m_pHashTable[nHash]; pAssoc != NULL ; pAssoc=pAssoc->pNext)
         {
            // add the length of the string
            len += (sizeof TCHAR)*(pAssoc->key.GetLength() + 2);
            
            // and the value
            if ( pAssoc->value)
            {
               len += pAssoc->value->CalculateStreamedLength();
            }
         }
      }
   }

   return len;
}

long 
   CMapStringToVar::CountItems()
{
   long                      count = 0;

   if ( m_nCount )
   {
      for ( UINT nHash = 0 ; nHash < m_nHashTableSize ; nHash++ )
      {
         CHashItem         * pAssoc;
         
         for ( pAssoc = m_pHashTable[nHash]; pAssoc != NULL ; pAssoc=pAssoc->pNext)
         {
            // add the length of the string
            count += pAssoc->value->CountItems();
         }
      }
   }
   return count;   
}
/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CMapStringToVar::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nCount << " elements";
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		CString   key;
		CVarData* val;

		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			GetNextAssoc(pos, key, val);
			dc << "\n\t[" << key << "] = " << val;
		}
	}

	dc << "\n";
}

void CMapStringToVar::AssertValid() const
{
	CObject::AssertValid();

	if ( m_Indexed )
   {
      //m_Index.AssertValid(m_nCount);
   }
   ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif


IMPLEMENT_SERIAL(CMapStringToVar, CObject, 0)

// BEGIN - STUFF FROM PLEX.CPP
/////////////////////////////////////////////////////////////////////////////
// CPlex

CPlex* PASCAL CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
	ASSERT(nMax > 0 && cbElement > 0);
	CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
	if (!p)
	   return NULL;
			// may throw exception
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
	CPlex* p = this;
	while (p != NULL)
	{
		BYTE* bytes = (BYTE*) p;
		CPlex* pNext = p->pNext;
		delete[] bytes;
		p = pNext;
	}
}

// END - STUFF FROM PLEX.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\varndx.h ===
#ifndef __VARMAPINDEX_H__
#define __VARMAPINDEX_H__
/*---------------------------------------------------------------------------
  File: VarMapIndex.h

  Comments: Helper class for CMapStringToVar.

  CIndexTree implements a sorted, balanced binary tree.  This is used by CMapStringToVar
  to provide enumeration in sorted order by key.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 18:01:34

 ---------------------------------------------------------------------------
*/

#include "VarData.h"

class CHashItem;
class CIndexTree;

class CIndexItem
{
friend class CIndexTree;
   CHashItem               * pData;
   CIndexItem              * pLeft;
   CIndexItem              * pRight;
   CIndexItem              * pParent;
   BOOL                      red;
public:
   CVarData*      GetValue(); 
   CString        GetKey();   

protected:
   CIndexItem(CHashItem*pd) { pData = pd; pLeft = NULL; pRight = NULL; pParent = NULL; red = FALSE;}
   CHashItem*    Data() { return pData; }   
   CIndexItem*   Left() { return pLeft; }
   CIndexItem*   Right() { return pRight; }
   CIndexItem*   Parent() { return pParent; } 
   BOOL     IsRed() { return red; }
   void     Left(CIndexItem* l) { pLeft = l; }
   void     Right(CIndexItem* r) { pRight = r; }
   void     Parent(CIndexItem* par) { pParent = par; }
   void     Data(CHashItem* p) { pData=p; }
   void     Red(BOOL rd = TRUE) { red = rd; }
   void     Black(BOOL blk = TRUE) { red = !blk; }
   void     McLogInternalDiagnostics(CString keyName,int depth);
};


typedef int CompareFunction(CIndexItem* i1,CIndexItem* i2);

typedef int CompareKeyFunction(CString s, CIndexItem* i);

extern CompareFunction CompareItems;
extern CompareKeyFunction CompareStringToItem;

extern CompareFunction CompareItemsNoCase;
extern CompareKeyFunction CompareStringToItemNoCase;

class CIndexTree
{
   friend class CMapStringToVar;

   CIndexItem*          m_root;
   CompareFunction*     m_Compare;
   CompareKeyFunction*  m_CompareKey;
   BOOL                 m_CaseSensitive;


protected:
   CIndexTree(CompareFunction * comp = &CompareItems, CompareKeyFunction * kc = &CompareStringToItem) 
   { 
      m_root = NULL; 
      m_Compare = comp; 
      m_CompareKey = kc; 
      m_CaseSensitive = TRUE;
   }
   ~CIndexTree() { RemoveAll(); }
   
public:
   
   CIndexItem* GetFirstItem() const { CIndexItem * curr = m_root; while ( curr && curr->Left() ) curr = curr->Left(); return curr; }
   CIndexItem* GetPrevItem(CIndexItem*curr) const;
   CIndexItem* GetNextItem(CIndexItem*curr) const;
   CIndexItem* GetFirstAfter(CString value) const;

   void McLogInternalDiagnostics(CString keyName);
#ifdef _DEBUG
   BOOL AssertValid(int nItems) const;
#endif


protected:
   // functions called by CMapStringToVar to add/remove items from the tree
   void RemoveAll();
   CIndexItem * Insert(CHashItem* data);
   void SetCompareFunctions(CompareFunction * f, CompareKeyFunction * kc) { m_Compare = f; m_CompareKey = kc; }
   
   // Helper functions to maintain tree structure
   void LeftRotate(CIndexItem* item);
   void RightRotate(CIndexItem* item);
   void RemoveHelper(CIndexItem* item);
};



#endif //__VARMAPINDEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\vset.h ===
/*---------------------------------------------------------------------------
  File: VSet.h

  Comments: Class definition for CVSet, which implements the IVarSet interface.

  (c) Copyright 1995-1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 19:44:31

 ---------------------------------------------------------------------------
*/

	
// VSet.h : Declaration of the CVSet

#ifndef __VSET_H_
#define __VSET_H_

#include "resource.h"       // main symbols

#ifdef STRIPPED_VARSET 
   #include "NoMcs.h"
#else
   #include "Mcs.h"
#endif
#include "VarData.h"

#define VARSET_RESTRICT_NOCHANGEDATA      (0x00000001)
#define VARSET_RESTRICT_NOCHANGEPROPS     (0x00000002)
#define VARSET_RESTRICT_ALL               (0x00000003)

/////////////////////////////////////////////////////////////////////////////
// CVSet
class ATL_NO_VTABLE CVSet : 
	public CComObjectRootEx<CComMultiThreadModel>,
   public CComCoClass<CVSet, &CLSID_VarSet>,
	public ISupportErrorInfoImpl<&IID_IVarSet>,
#ifdef STRIPPED_VARSET
	public IDispatchImpl<IVarSet, &IID_IVarSet, &LIBID_MCSVARSETMINLib>,
#else
	public IDispatchImpl<IVarSet, &IID_IVarSet, &LIBID_MCSVARSETLib>,
#endif 
   public IPersistStorageImpl<CVSet>,
   public IPersistStreamInit,
   public IPersistStream,
   public IMarshal
{
public:
	CVSet()
	{
		m_data = new CVarData;
      m_pUnkMarshaler = NULL;
      m_nItems = 0;
      m_bLoaded = FALSE;
      m_parent = NULL;
      m_Restrictions = 0;
      m_ImmutableRestrictions = 0;
      InitProperties();
   }
   
   ~CVSet()
   {
      if ( m_parent )
      {
         m_parent->Release();
      }
      else
      {
         Clear();
         delete m_data;
      }
   }
DECLARE_REGISTRY_RESOURCEID(IDR_VSET)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CVSet)
	COM_INTERFACE_ENTRY(IVarSet)
   COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
  	COM_INTERFACE_ENTRY(IPersistStreamInit)
   COM_INTERFACE_ENTRY(IPersistStream)
   COM_INTERFACE_ENTRY(IMarshal)
   COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
  	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
   {
		return CoCreateFreeThreadedMarshaler(
		GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
   
// IVSet
public:
   
   STDMETHOD(get)(/* [in] */BSTR property,/* [retval][out] */VARIANT * value);
   STDMETHOD(put)(/* [in] */BSTR property,/* [in] */VARIANT value);
   STDMETHOD(putObject)(/* [in] */BSTR property,/* [in] */VARIANT value);

   STDMETHOD(Clear)();
   
   // Enum methods
   STDMETHOD(get__NewEnum)(/* [retval][out] */IUnknown** retval);
 	STDMETHOD(getItems)(/* [in] */BSTR basepoint,
                       /* [in] */BSTR startAfter, 
                       /* [in] */BOOL bRecursive,
                       /* [in] */ULONG bSize, 
                       /* [out] */SAFEARRAY ** keys, 
                       /* [out] */SAFEARRAY ** values, 
                       /* [out][in] */LONG * nReturned);

   STDMETHOD(getItems2)(/* [in] */VARIANT basepoint,
                       /* [in] */VARIANT startAfter, 
                       /* [in] */VARIANT bRecursive,
                       /* [in] */VARIANT bSize, 
                       /* [out] */VARIANT * keys, 
                       /* [out] */VARIANT * values, 
                       /* [out][in] */VARIANT * nReturned);

   
   // properties
   STDMETHOD(get_NumChildren)(/* [in] */BSTR parentKey,/* [out,retval] */long*count);
   STDMETHOD(get_Count)(/* [retval][out] */long* retval);
   
   STDMETHOD(get_CaseSensitive)(/* [retval][out] */BOOL * isCaseSensitive);
   STDMETHOD(put_CaseSensitive)( /* [in] */BOOL newVal);
   STDMETHOD(get_Indexed)(/* [out, retval]*/ BOOL *pVal);
	STDMETHOD(put_Indexed)(/* [in] */ BOOL newVal);
   STDMETHOD(get_AllowRehashing)(/* [out, retval]*/ BOOL *pVal);
	STDMETHOD(put_AllowRehashing)(/* [in] */ BOOL newVal);
   STDMETHOD(DumpToFile)( /* [in] */ BSTR filename);
   STDMETHOD(ImportSubTree)(/*[in] */ BSTR key, /* [in] */ IVarSet * pVarSet);
   STDMETHOD(getReference)( /* [in] */ BSTR key, /* [out,retval] */IVarSet** cookie);
   STDMETHOD(get_Restrictions)(/* [out,retval] */ DWORD * restrictions);
   STDMETHOD(put_Restrictions)(/* [in] */ DWORD newRestrictions);

protected:
   CComAutoCriticalSection       m_cs;
   LONG                          m_nItems;
   
   // Properties
   BOOL                          m_CaseSensitive;
   BOOL                          m_Indexed;
   BOOL                          m_AllowRehashing;
   BOOL                          m_bNeedToSave;
   BOOL                          m_bLoaded;
   
   IVarSet                     * m_parent;
   CVarData                    * m_data;
   CComBSTR                      m_prefix;
   DWORD                         m_Restrictions;
   DWORD                         m_ImmutableRestrictions;
   // Helper functions
   void BuildVariantKeyArray(CString prefix,CMapStringToVar * map,CComVariant * pVars,int * offset);
   void BuildVariantKeyValueArray(CString prefix,CString startAfter,CMapStringToVar * map,
                     SAFEARRAY * keys,SAFEARRAY * pVars,int * offset,int maxOffset, BOOL bRecurse);
   CVarData * GetItem(CString str,BOOL addToMap = FALSE, CVarData * starting = NULL);
   void InitProperties()
   {
      m_CaseSensitive = TRUE;
      m_Indexed = TRUE;
      m_AllowRehashing = TRUE;
      m_bNeedToSave = TRUE;
   }

   void SetData(IVarSet * parent,CVarData * data,DWORD restrictions)
   {
      if ( m_parent )
      {
         m_parent->Release();
         m_parent = NULL;
      }
      if (m_data)
      {
         delete m_data;
      }
      m_data = data;
      m_parent = parent;
      m_bNeedToSave = TRUE;
      m_Indexed = m_data->IsIndexed();
      m_CaseSensitive = m_data->IsCaseSensitive();
      m_nItems = m_data->CountItems();
      m_Restrictions = restrictions;
      m_ImmutableRestrictions = restrictions;
      if ( ! m_data->HasData() )
      {
         // Don't count the root key "" if it does not have a value.
         m_nItems--;
      }
   }
    // IPersistStorage
public:
	
   STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID);

   STDMETHOD(IsDirty)();
        
   STDMETHOD(Load)(LPSTREAM pStm);
        
   STDMETHOD(Save)(LPSTREAM pStm,BOOL fClearDirty);
        
   STDMETHOD(GetSizeMax)(ULARGE_INTEGER __RPC_FAR *pCbSize);
        
   STDMETHOD(InitNew)();

  
   // IMarshal
public:
   STDMETHODIMP GetUnmarshalClass(REFIID riid, void *pv, DWORD dwDestContext, void *pvDestContext, DWORD mshlflags, CLSID *pCid);
   STDMETHODIMP GetMarshalSizeMax(REFIID riid, void *pv, DWORD dwDestContext, void *pvDestContext, DWORD mshlflags, DWORD *pSize);
   STDMETHODIMP MarshalInterface(IStream *pStm, REFIID riid, void *pv, DWORD dwDestContext, void *pvDestCtx, DWORD mshlflags);
   STDMETHODIMP UnmarshalInterface(IStream *pStm, REFIID riid, void **ppv);
   STDMETHODIMP ReleaseMarshalData(IStream *pStm);
   STDMETHODIMP DisconnectObject(DWORD dwReserved);
    
    
     
    
    

};

#endif //__VSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\varndx.cpp ===
/*---------------------------------------------------------------------------
  File: VarMapIndex.cpp

  Comments: Helper class for CMapStringToVar.

  CIndexTree implements a sorted, balanced binary tree.  This is used by CMapStringToVar
  to provide enumeration in sorted order by key.

  CIndexTree is currently implemented as a Red-Black tree.


  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 18:17:47

 ---------------------------------------------------------------------------
*/




#include "stdafx.h"
#include "VarMap.h"
#include "VarNdx.h"


#ifdef STRIPPED_VARSET
   #include "NoMcs.h"
#else
   #pragma warning (push,3)
   #include "McString.h" 
   #include "McLog.h"
   #pragma warning (pop)

   using namespace McString;
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Comparison functions used for sorting and searching
int CompareItems(CIndexItem* i1, CIndexItem* i2)
{
   ASSERT(i1 && i2);
   int result;

   result = i1->GetKey().Compare(i2->GetKey());
   
   return result;
}

int CompareStringToItem(CString s, CIndexItem *i)
{
   ASSERT(i);
   int result;

   result = s.Compare(i->GetKey());

   return result;
}

int CompareItemsNoCase(CIndexItem* i1, CIndexItem* i2)
{
   ASSERT(i1 && i2);
   int result;

   result = i1->GetKey().CompareNoCase(i2->GetKey());
   
   return result;
}

int CompareStringToItemNoCase(CString s, CIndexItem *i)
{
   ASSERT(i);
   int result;

   // this assumes i->Data is not null

   result = s.CompareNoCase(i->GetKey());

   return result;
}

CVarData *
   CIndexItem::GetValue()
{ 
   if ( pData ) 
   {
      return pData->value; 
   }
   else 
   {
      return NULL; 
   }
}

CString 
   CIndexItem::GetKey()
{ 
   if ( pData ) 
   {
      return pData->key; 
   }
   else
   {
      return _T(""); 
   }
}
/////////////////////////////////////////////////////////////////////////////


/// Implementation of Red-Black Tree

CIndexItem *                               // ret- pointer to node in index
   CIndexTree::Insert(
      CHashItem            * data          // in - item from hash table
   )
{
   CIndexItem              * item = new CIndexItem(data);
   CIndexItem              * curr;
   CIndexItem              * parent;
   int                       compResult=0;
   
   if ( ! m_root )
   {
      m_root = item;
   }
   else
   {
      curr = m_root;
      parent = NULL;
      while ( curr )
      {
         parent = curr;
         compResult = (*m_Compare)(item,curr);
         if  ( compResult < 0 )
         {
            curr = curr->Left();
         }
         else if ( compResult > 0 )
         {
            curr = curr->Right();
         }
         else
         {
            // The same key should not appear multiple times in the hash table
            // this is a bug
            ASSERT(FALSE);
            delete item;
            curr->Data(data);
         }
      }
      if ( ! curr )
      {
         // The item was not in the tree
         ASSERT(compResult!=0);
         
         item->Parent(parent);
         // Add the item in the appropriate place
         if ( compResult < 0 )
         {
            parent->Left(item);
         }
         else
         {
            parent->Right(item);
         }
         // now rebalance the tree  
         CIndexItem        * uncle;
         BOOL                uncleIsRight;

         item->Black();
         while ( item != m_root && parent->IsRed() )
         {
            // we don't have to worry about grandparent being null, since parent is red, and 
            // the root is always black.

            // is the parent a left or right child? (algorithm is symmetric)
            if ( parent == parent->Parent()->Left() )
            {
               uncle = parent->Parent()->Right();
               uncleIsRight = TRUE;
            }
            else
            {
               uncle = parent->Parent()->Left();
               uncleIsRight = FALSE;
            }
            
            if ( uncleIsRight )
            {
               if ( uncle && uncle->IsRed() )
               {
                  parent->Black();
                  uncle->Black();
                  item = parent->Parent();
                  item->Red();
               }
               else if ( item == parent->Right() )
               {
                  item = parent;
                  LeftRotate(item);
               }
               parent->Black();
               parent->Parent()->Red();
               RightRotate(parent->Parent());
            }
            else // same as above, except swap left and right
            {
               if ( uncle && uncle->IsRed() )
               {
                  parent->Black();
                  uncle->Black();
                  item = parent->Parent();
                  item->Red();
               }
               else if ( item == parent->Left() )
               {
                  item = parent;
                  RightRotate(item);
               }
               parent->Black();
               parent->Parent()->Red();
               LeftRotate(parent->Parent());
            }
         }
      }
   }
   m_root->Black(); // see, the root is always black

   return item;
}
      
   
void 
   CIndexTree::RightRotate(
      CIndexItem           * item          // in - item to rotate from
   )
{
   CIndexItem              * y = item->Right();

   if ( y )
   {
      // turn y's left subtree into x's right subtree
      item->Right(y->Left());
      if ( y->Left() )
      {
         y->Left()->Parent(item);
      }
      y->Parent(item->Parent()); // link item's parent to y
      if (! item->Parent() )
      {
         m_root = y;
      }
      else if ( item == item->Parent()->Left() )
      {
         item->Parent()->Left(y);
      }
      else
      {
         item->Parent()->Right(y);
      }
      // put item on y's left
      y->Left(item);
      item->Parent(y);
   }
}

void 
   CIndexTree::LeftRotate(
      CIndexItem           * item          // in - item to rotate from
   )
{
   CIndexItem              * y = item->Left();

   if ( y )
   {
      // turn y's right subtree into x's left subtree
      item->Left(y->Right());
      if ( y->Right() )
      {
         y->Right()->Parent(item);
      }
      // link item's parent to y
      y->Parent(item->Parent());
      if ( ! item->Parent() )
      {
         m_root = y;
      }
      else if ( item == item->Parent()->Right() )
      {
         item->Parent()->Right(y);
      }
      else
      {
         item->Parent()->Left(y);
      }
      // put item on y's right
      y->Right(item);
      item->Parent(y);
   }
}

CIndexItem *                               // ret- the node immediately preceding the given node
   CIndexTree::GetPrevItem(      
      CIndexItem           * item          // in - a node in the index tree
   ) const
{
   CIndexItem              * curr;

   if ( item->Left() )
   {
      curr = item->Left();
      while ( curr->Right() )
      {
         curr = curr->Right();
      }
   }
   else
   {
      curr = item;
      while ( curr->Parent() && curr->Parent()->Left() == curr )
      {
         curr = curr->Parent();
      }
      curr = curr->Parent();
   }
   return curr;
}

CIndexItem *                               // ret- the node immediately following the given node
   CIndexTree::GetNextItem(
      CIndexItem           * item          // in - a node in the index tree 
   ) const
{                                               
   CIndexItem              * curr;

   if ( item->Right() )
   {
      curr = item->Right();
      while ( curr->Left() )
      {
         curr = curr->Left();
      }
   }
   else
   {
      curr = item;
      while ( curr->Parent() && curr->Parent()->Right() == curr )
      {
         curr = curr->Parent();
      }
      curr = curr->Parent();
   }
   return curr;
}

void 
   CIndexTree::RemoveAll()
{
   // do a post-order traversal, removing each node
   if ( m_root )
   {
      RemoveHelper(m_root);
      m_root = NULL;
   }
}

// helper function for removing all items in the tree
void 
   CIndexTree::RemoveHelper(
      CIndexItem           * curr          // in - current node
   )
{
   // our tree currently does not support removing a single item, so we'll use a brute force method
   // recursively delete children, then delete the current node
   if ( curr->Left() )
   {
      RemoveHelper(curr->Left());
   }
   if ( curr->Right() )
   {
      RemoveHelper(curr->Right());
   }
   delete curr;
}

void 
   CIndexItem::McLogInternalDiagnostics(CString keyName, int depth)
{
   CString key;
   CString strLeft;
   CString strRight;
   CString strParent;

   if ( ! keyName.IsEmpty() )
   {
      key = keyName + ".";
   }
   if ( pData )
   {
      key = key + pData->key;
   }
   else
   {
      MC_LOG("data is NULL");
   }
   MC_LOG("address="<<makeStr(this,L"0x%lx") << " pData="<< makeStr(pData,L"0x%lx") << " pLeft="<<makeStr(pLeft,L"0x%lx")<<" pRight="<<makeStr(pRight,L"0x%lx")<< " pParent="<<makeStr(pParent,L"0x%lx") << " red="<<makeStr(red,L"0x%lx") << " depth="<<makeStr(depth));
   if ( pLeft )
      strLeft = pLeft->GetKey();
   if ( pRight )
      strRight = pRight->GetKey();
   if ( pParent )
      strParent = pParent->GetKey();
   MC_LOG("       Key=" << String(key) << " Left=" << String(strLeft) << " Right=" << String(strRight) << " Parent="<< String(strParent) );
   if ( pLeft )
      pLeft->McLogInternalDiagnostics(keyName,depth+1);
   if ( pRight )
      pRight->McLogInternalDiagnostics(keyName,depth+1);
}

CIndexItem *                               // ret- smallest node in the index that is >= value
   CIndexTree::GetFirstAfter(
      CString                value         // in - string to compare keys to
   ) const
{
   CIndexItem              * item = m_root;
   CIndexItem              * result = NULL;
   int                       cRes;

   while ( item )
   {
      cRes = m_CompareKey(value,item);
      if ( ! cRes )
      {
         break;
      }
      if ( cRes > 0 )
      {
         item = item->Left();
      }
      else
      {
         result = item;
         item = item->Right();
      }
   }
   return result;
}


void CIndexTree::McLogInternalDiagnostics(CString keyName)
{
   CString blockname;
   blockname = "Index of "+ keyName;
   CString compareFn;
   CString compareKey;

   if ( m_Compare == &CompareItems )
   {
      compareFn = "CompareItems";
   }
   else if ( m_Compare == &CompareItemsNoCase )
   {
      compareFn = "CompareItemsNoCase";
   }
   else 
   {
      compareFn.Format(_T("Unknown function, address=%lx"),m_Compare);
   }

   if ( m_CompareKey == &CompareStringToItem )
   {
      compareKey = "CompareStringToItem";
   }
   else if ( m_CompareKey == &CompareStringToItemNoCase )
   {
      compareKey = "CompareStringToItemNoCase";
   }
   else
   {
      compareKey.Format(_T("Unknown function, address=%lx"),m_CompareKey);
   }

   MC_LOG(String(blockname) << "  CaseSensitive=" << makeStr(m_CaseSensitive) << " Compare Function="<<String(compareFn)<< "Compare Key Function=" << String(compareKey) );

   if ( m_root )
   {
      MC_LOG("Beginning preorder dump of index");
      m_root->McLogInternalDiagnostics(keyName,0);
   }
   else
   {
      MC_LOG("Root of index is NULL");
   }
}

#ifdef _DEBUG
BOOL CIndexTree::AssertValid(int nItems) const
{
   BOOL                      bValid = TRUE;
   int                       i;
   CIndexItem              * curr = GetFirstItem();
   CIndexItem              * prev = NULL;

   for ( i = 0 ; i < nItems ; i++ )
   {
      ASSERT(curr);
      if ( prev && curr )
      {
         ASSERT(m_Compare(prev,curr) <= 0 );
      }
      prev = curr;
      curr = GetNextItem(curr);
   }
   ASSERT(curr == NULL);  // we should have reached the end

   for ( i = 0 ; i < nItems -1 ; i++ )
   {
      prev = GetPrevItem(prev);
      ASSERT(prev);
   }
   ASSERT(prev == GetFirstItem());

   return bValid;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\vsmin.cpp ===
// McsVarSetMin.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for McsVarSetMin.idl by adding the following 
//      files to the Outputs.
//          McsVarSetMin_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f McsVarSetMinps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "Varset.h"
#include "dlldatax.h"

#include "VarSet_i.c"
#include "VarSetI_i.c"
#include "VSet.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_VarSet, CVSet)
END_OBJECT_MAP()

class CVarSetApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVarSetApp)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CVarSetApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CVarSetApp, CWinApp)
	//{{AFX_MSG_MAP(CVarSetApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CVarSetApp theApp;

BOOL CVarSetApp::InitInstance()
{
	ATLTRACE(_T("{McsVarSetMin.dll}CVarSetApp::InitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _Module.Init(ObjectMap, m_hInstance, &LIBID_MCSVARSETMINLib);
	BOOL bInit = CWinApp::InitInstance();
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    return bInit;
}

int CVarSetApp::ExitInstance()
{
	ATLTRACE(_T("{McsVarSetMin.dll}CVarSetApp::ExitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\varset\varset\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1997

Module Name:

    makefile.inc.

!ENDIF

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "McsDebug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\callback.h ===
#pragma once
#include "GuiUtils.h"

INT_PTR CALLBACK
IntOptionsGroupMappingProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);	
INT_PTR CALLBACK
IntDomainSelectionProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);	
INT_PTR CALLBACK
IntTargetGroupProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);	

INT_PTR CALLBACK
IntTrustProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntCommitProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntHTMLLocationProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
NoncollisionRenamingProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntOptionsReportingProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntSelectionSecurityProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);

INT_PTR CALLBACK
IntRetryProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntDisableProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntUndoProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntPasswordProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntOptionsProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntExchangeSelectionProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntRebootProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntTranslationProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntTranslationModeProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntGroupOptionsProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntCredentialsProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntServiceRefreshProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntServiceInfoButtonProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntServiceInfoProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);

/*
INT_PTR CALLBACK
IntCredentials2Proc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
*/

INT_PTR CALLBACK
IntRenameProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntOuSelectionProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK 
IntroDlgProc(
    IN HWND     hwndDlg,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
INT_PTR CALLBACK 
IntOptionsFromUserProc(
    IN HWND     hwndDlg,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
INT_PTR CALLBACK 
IntSelectionProc(
    IN HWND     hwndDlg,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
INT_PTR CALLBACK 
EndDlgProc(
    IN HWND     hwndDlg,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
INT_PTR CALLBACK
IntTranslationInputProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntPropExclusionProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\callback.cpp ===
#include "stdafx.h"
#include "Callback.h"
#include "GetDcName.h"
 

#ifndef IADsContainerPtr
_COM_SMARTPTR_TYPEDEF(IADsContainer, IID_IADsContainer);
#endif
#ifndef IADsADSystemInfoPtr
_COM_SMARTPTR_TYPEDEF(IADsADSystemInfo, IID_IADsADSystemInfo);
#endif

extern BOOL GetDomainAndUserFromUPN(WCHAR const * UPNname,CString& domainNetbios, CString& user);

INT_PTR CALLBACK
IntServiceInfoButtonProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			HWND hLC6= GetDlgItem(hwndDlg,IDC_LIST_SERVICE);
			m_serviceBox.Attach(hLC6);

			CString column;
			column.LoadString(IDS_COLUMN_COMPUTER); m_serviceBox.InsertColumn( 1, column,LVCFMT_LEFT,100,1);
			column.LoadString(IDS_COLUMN_SERVICE); m_serviceBox.InsertColumn( 2, column,LVCFMT_LEFT,0,1);
			column.LoadString(IDS_COLUMN_ACCOUNT); m_serviceBox.InsertColumn( 3, column,LVCFMT_LEFT,100,1);
			column.LoadString(IDS_COLUMN_STATUS); m_serviceBox.InsertColumn( 4, column,LVCFMT_LEFT,85,1);
			//new
			column.LoadString(IDS_COLUMN_SERVICE_DISPLAY); m_serviceBox.InsertColumn( 5, column,LVCFMT_LEFT,75,1);
			getService();
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_TOGGLE:
				{
					OnTOGGLE(hwndDlg);
					break;
				}
			case IDC_UPDATE:
				{
					OnUPDATE(hwndDlg);
					break;
				}

			default :	
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case LVN_COLUMNCLICK:
				{
					LPNMLISTVIEW pnmv = (NM_LISTVIEW FAR *) lParam;
					pdata->sort[pnmv->iSubItem] = !pdata->sort[pnmv->iSubItem];
					sort(m_serviceBox,pnmv->iSubItem,pdata->sort[pnmv->iSubItem] );
//					SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
					break;
				}
	
			case NM_SETFOCUS :
			case NM_KILLFOCUS :
			case NM_CLICK:
				{
					activateServiceButtons(hwndDlg);
					break;
				}				
			case PSN_SETACTIVE :
				
			    disable(hwndDlg,IDC_UPDATE);
				disable(hwndDlg,IDC_TOGGLE);
				
				if (migration==w_service && (pdata->refreshing && !alreadyRefreshed))
				{
					refreshDB(hwndDlg);
					alreadyRefreshed = true;
					getService();
				}
			    if (pdata->refreshing) 
				   PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
				else
			       PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);				

				break;
			case PSN_WIZNEXT :
				{
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				CString	computer ,service,account,c;
				CString skip,include;
	            skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); 

				for (int i=0;i<m_serviceBox.GetItemCount();i++)
				{
					computer = m_serviceBox.GetItemText(i,0);
					service = m_serviceBox.GetItemText(i,1);
					account = m_serviceBox.GetItemText(i,2);
					c = m_serviceBox.GetItemText(i,3);
					if (c== skip)
					{
						db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account),SvcAcctStatus_DoNotUpdate);
					}
					else if (c==include)
					{
						db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account), SvcAcctStatus_NotMigratedYet);
					}
				}
				//find and remove from varset
				break;
				}
			case PSN_WIZBACK :
				if (!pdata->refreshing && migration==w_service)
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_REFRESH);
					return TRUE;
				}
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_RESET :
				break;	
			case PSN_HELP :
				{						
					SharedHelp(SERVICE_ACCOUNT_INFO, hwndDlg);
					break;
				}
				
			default :
				break;		
			}
			break;
		}
	case WM_HELP :
		{
			SharedHelp(SERVICE_ACCOUNT_INFO, hwndDlg);
			break;
		}		
		
	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK
IntServiceInfoProc(
				   IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			CheckRadioButton(hwndDlg,IDC_UPDATE,IDC_SKIP,IDC_UPDATE);
			HWND hLC6= GetDlgItem(hwndDlg,IDC_LIST_SERVICE);
			m_serviceBox.Attach(hLC6);

			CString column;
			column.LoadString(IDS_COLUMN_COMPUTER); m_serviceBox.InsertColumn( 1, column,LVCFMT_LEFT,100,1);
			column.LoadString(IDS_COLUMN_SERVICE); m_serviceBox.InsertColumn( 2, column,LVCFMT_LEFT,0,1);
			column.LoadString(IDS_COLUMN_ACCOUNT); m_serviceBox.InsertColumn( 3, column,LVCFMT_LEFT,100,1);
			column.LoadString(IDS_COLUMN_STATUS); m_serviceBox.InsertColumn( 4, column,LVCFMT_LEFT,85,1);
			//new
			column.LoadString(IDS_COLUMN_SERVICE_DISPLAY); m_serviceBox.InsertColumn( 5, column,LVCFMT_LEFT,75,1);

			getService();
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_TOGGLE:
				{
					OnTOGGLE(hwndDlg);
					break;
				}
			case IDC_SKIP:
				{
					disable(hwndDlg,IDC_TOGGLE);
					disable(hwndDlg,IDC_LIST_SERVICE);					
					break;
				}
			case IDC_UPDATE:
				{
					enable(hwndDlg,IDC_LIST_SERVICE);					
					break;
				}
			default :
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{

			case LVN_COLUMNCLICK:
				{
					LPNMLISTVIEW pnmv = (NM_LISTVIEW FAR *) lParam;
					pdata->sort[pnmv->iSubItem] = !pdata->sort[pnmv->iSubItem];
					sort(m_serviceBox,pnmv->iSubItem,pdata->sort[pnmv->iSubItem] );
//					SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
				break;
				}
	
			case NM_SETFOCUS :
			case NM_KILLFOCUS :
			case NM_CLICK:
				{

					activateServiceButtons2(hwndDlg);
					break;
				}				

			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				disable(hwndDlg,IDC_TOGGLE);

				if (pdata->refreshing && !alreadyRefreshed)
				{
					put(DCTVS_Options_Wizard, L"service");
					refreshDB(hwndDlg);
					put(DCTVS_Options_Wizard, L"user");
					alreadyRefreshed = true;
				}
				getService();
	
				break;
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					if(IsDlgButtonChecked(hwndDlg,IDC_SKIP))
					{
						setDBStatusSkip();
					}
					else if(IsDlgButtonChecked(hwndDlg,IDC_UPDATE))
					{
						if (setDBStatusInclude(hwndDlg))
						{
							CString message,title;
							message.LoadString(IDS_MSG_LOCAL);title.LoadString(IDS_MSG_WARNING);
							MessageBox(hwndDlg,message,title,MB_OK|MB_ICONINFORMATION);
						}
					}					
	
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_RESET :
				break;		
			case PSN_HELP :
				{						
					SharedHelp(USER_SERVICE_ACCOUNT, hwndDlg);
					break;
				}
			default :
				break;		
			}
			break;
		}
			case WM_HELP :
		{
			SharedHelp(USER_SERVICE_ACCOUNT, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK
IntServiceRefreshProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			
			IUnknown * pUnk;
			pVarSetService->QueryInterface(IID_IUnknown, (void**) &pUnk);
			db->GetServiceAccount(L"",&pUnk);
			pUnk->Release();
			
			_bstr_t text;
			text = pVarSetService->get(L"ServiceAccountEntries");
			int numItems=_ttoi((WCHAR const *)text);
			if (numItems==0 )
			{
				CheckRadioButton(hwndDlg,IDC_REFRESH,IDC_NO_REFRESH,IDC_REFRESH) ;
				disable(hwndDlg,IDC_NO_REFRESH);
			}
			else
				CheckRadioButton(hwndDlg,IDC_REFRESH,IDC_NO_REFRESH,IDC_NO_REFRESH);
			
			
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				
				if (IsDlgButtonChecked(hwndDlg,IDC_REFRESH) )
				{
					pdata->refreshing = true;
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
//					SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SELECTION1);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION1);
					return TRUE;
				}
				else
				{
					pdata->refreshing = false;
//					SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SA_INFO_BUTTON);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_INFO_BUTTON);
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					return TRUE;
				}	
				
				break;
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(REFRESH_INFO_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}
			case WM_HELP :
		{
			SharedHelp(REFRESH_INFO_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

//this function is no longer used
INT_PTR CALLBACK 
IntOptionsFromUserProc(
    IN HWND     hwndDlg,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{
	CString editHeader;
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);

		    CString toformat;
			toformat.LoadString(IDS_30);
			calculateDate(hwndDlg,toformat);
			SetDlgItemText(hwndDlg,IDC_yo,toformat);
			disable(hwndDlg,IDC_yo);
			disable(hwndDlg,IDC_DATE);
			disable(hwndDlg,IDC_TEXT);

			initcheckbox( hwndDlg,IDC_TRANSLATE_ROAMING_PROFILES,DCTVS_AccountOptions_TranslateRoamingProfiles);
		
//			initdisablebox(hwndDlg,IDC_DISABLE_SOURCE_ACCOUNTS,IDC_DISABLE_COPIED_ACCOUNTS,IDC_DISABLE_NEITHER_ACCOUNT,
//				L"AccountOptions.DisableSourceAccounts",L"AccountOptions.DisableCopiedAccounts");		

			if (IsDlgButtonChecked(hwndDlg,IDC_DISABLE_SOURCE_ACCOUNTS))
			{
			   disable(hwndDlg,IDC_SET_EXPIRATION);
			   disable(hwndDlg,IDC_yo);
			}
			else
			{
			   enable(hwndDlg,IDC_SET_EXPIRATION);
			   if (IsDlgButtonChecked(hwndDlg,IDC_SET_EXPIRATION))
			      enable(hwndDlg,IDC_yo);
			}

			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_SET_EXPIRATION :
				{
			        if (IsDlgButtonChecked(hwndDlg,IDC_SET_EXPIRATION))
					{     
						enable(hwndDlg,IDC_yo);
						enable(hwndDlg,IDC_DATE);
						enable(hwndDlg,IDC_TEXT);
				}
					else
					{
						disable(hwndDlg,IDC_yo);
						disable(hwndDlg,IDC_DATE);
						disable(hwndDlg,IDC_TEXT);
					}
					break;
				}
			case IDC_DISABLE_SOURCE_ACCOUNTS :
				{
					disable(hwndDlg,IDC_SET_EXPIRATION);
					disable(hwndDlg,IDC_yo);
					break;
				}
			case IDC_DISABLE_COPIED_ACCOUNTS :
				{
					enable(hwndDlg,IDC_SET_EXPIRATION);
					if (IsDlgButtonChecked(hwndDlg,IDC_SET_EXPIRATION))
					   enable(hwndDlg,IDC_yo);
					break;
				}
			case IDC_DISABLE_NEITHER_ACCOUNT :
				{
					enable(hwndDlg,IDC_SET_EXPIRATION);
					if (IsDlgButtonChecked(hwndDlg,IDC_SET_EXPIRATION))
					   enable(hwndDlg,IDC_yo);
					break;
				}
			default :
				break;
			}
			
			switch(HIWORD (wParam)){
			case EN_SETFOCUS :
			    bChangeOnFly=true;
				break;
			case EN_KILLFOCUS :
			    bChangeOnFly=false;
				break;
			case EN_CHANGE:	
				{
					if ((!bChangeOnFly) || (LOWORD(wParam) != IDC_yo))
						break;
					CString s;
					GetDlgItemText(hwndDlg,IDC_yo,s.GetBuffer(1000),1000);
					s.ReleaseBuffer();
					   //make sure all chars are digits
					bool bInvalid = false;
					int ndx=0;
					while ((ndx < s.GetLength()) && (!bInvalid))
					{
						if (!iswdigit(s[ndx]))
						   bInvalid = true;
						ndx++;
					}
					if (bInvalid)
					{
						  //for invalid days, blank out the date
					   SetDlgItemText(hwndDlg,IDC_DATE,L"");
					}
					else //else continue checking for validity
					{
					   long ndays = _wtol(s);
					   if (((ndays <= THREE_YEARS) && (ndays >= 1)) ||
						   (!UStrICmp(s,L"0")))
					      calculateDate(hwndDlg,s);
					   else
					   {
						     //for invalid days, blank out the date
					      SetDlgItemText(hwndDlg,IDC_DATE,L"");
					   }
					}
					break;
				}
			default :
				break;
			}

			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					
					checkbox( hwndDlg,IDC_DISABLE_SOURCE_ACCOUNTS,DCTVS_AccountOptions_DisableSourceAccounts);
					checkbox( hwndDlg,IDC_DISABLE_COPIED_ACCOUNTS,DCTVS_AccountOptions_DisableCopiedAccounts);
					_variant_t varX;
					if ((IsWindowEnabled(GetDlgItem(hwndDlg, IDC_SET_EXPIRATION))) && 
						(IsDlgButtonChecked( hwndDlg,IDC_SET_EXPIRATION)))
					{
						time_t t;
						if (timeInABox(hwndDlg,t))
						{
							varX =t;
							put(DCTVS_AccountOptions_ExpireSourceAccounts,varX);
						}
						else 
						{
							MessageBoxWrapper(hwndDlg,IDS_MSG_TIME,IDS_MSG_ERROR);
//							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DISABLE);
						    SetFocus(GetDlgItem(hwndDlg, IDC_yo));
						    SendDlgItemMessage(hwndDlg, IDC_yo, EM_SETSEL, 
											  (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						    return TRUE;
						}
					}
					else
					{
						varX = L"";
						put(DCTVS_AccountOptions_ExpireSourceAccounts,varX);
					}
					
					checkbox( hwndDlg,IDC_TRANSLATE_ROAMING_PROFILES,DCTVS_AccountOptions_TranslateRoamingProfiles);
					
					if (someServiceAccounts(pdata->accounts,hwndDlg))
					{
						pdata->someService=true;
//						SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SA_INFO);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_INFO);
						return TRUE;
					}
					else
					{
						pdata->someService=false;
//						SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_END_GROUP);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_GROUP);
						return TRUE;
					}
					
					
					break;
				}
			case PSN_WIZBACK :
				break;							
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(GROUP_MEMBER_OPTION, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(GROUP_MEMBER_OPTION, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK
IntOptionsProc(
			   IN HWND hwndDlg,
			   IN UINT uMsg,
			   IN WPARAM wParam,
			   IN LPARAM lParam
			   ){
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initnoncollisionrename(hwndDlg);
			initcheckbox( hwndDlg,IDC_TRANSLATE_ROAMING_PROFILES,DCTVS_AccountOptions_TranslateRoamingProfiles);
			initcheckbox( hwndDlg,IDC_UPDATE_USER_RIGHTS,DCTVS_AccountOptions_UpdateUserRights);
			initcheckbox( hwndDlg,IDC_MIGRATE_GROUPS_OF_USERS,DCTVS_AccountOptions_CopyMemberOf);
			initcheckbox( hwndDlg,IDC_REMIGRATE_OBJECTS,DCTVS_AccountOptions_IncludeMigratedAccts);
			initcheckbox( hwndDlg,IDC_FIX_MEMBERSHIP,DCTVS_AccountOptions_FixMembership);
			if (IsDlgButtonChecked(hwndDlg,IDC_MIGRATE_GROUPS_OF_USERS))
			{
				pdata->memberSwitch=true;
				enable(hwndDlg,IDC_REMIGRATE_OBJECTS);
			}
			else
				disable(hwndDlg,IDC_REMIGRATE_OBJECTS);

			if (pdata->sameForest)
			{
				CheckDlgButton(hwndDlg,IDC_FIX_MEMBERSHIP,true);
				disable(hwndDlg,IDC_FIX_MEMBERSHIP);
			}

			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_MIGRATE_GROUPS_OF_USERS:
				{
					pdata->memberSwitch=(!pdata->memberSwitch);
					pdata->memberSwitch ? enable(hwndDlg,IDC_REMIGRATE_OBJECTS):disable(hwndDlg,IDC_REMIGRATE_OBJECTS);
					bChangedMigrationTypes=true;
					break;
				}
			case IDC_RADIO_NONE :
				{
					disable(hwndDlg,IDC_PRE);
					disable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_PRE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_SUF,false);
					break;
				}	
			case IDC_RADIO_PRE :
				{
					enable(hwndDlg,IDC_PRE);
					disable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_NONE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_SUF,false);
				    SetFocus(GetDlgItem(hwndDlg, IDC_PRE));
					SendDlgItemMessage(hwndDlg, IDC_PRE, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
					break;
				}	
			case IDC_RADIO_SUF :
				{
					disable(hwndDlg,IDC_PRE);
					enable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_PRE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_NONE,false);
					SetFocus(GetDlgItem(hwndDlg, IDC_SUF));
					SendDlgItemMessage(hwndDlg, IDC_SUF, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
					break;
				}	
			default :
				break;
			}
			break;
		}

	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
			{
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				checkbox( hwndDlg,IDC_TRANSLATE_ROAMING_PROFILES,DCTVS_AccountOptions_TranslateRoamingProfiles);
				checkbox( hwndDlg,IDC_UPDATE_USER_RIGHTS,DCTVS_AccountOptions_UpdateUserRights);
				checkbox( hwndDlg,IDC_MIGRATE_GROUPS_OF_USERS,DCTVS_AccountOptions_CopyMemberOf);
				checkbox( hwndDlg,IDC_MIGRATE_GROUPS_OF_USERS,DCTVS_AccountOptions_CopyLocalGroups);		
				checkbox( hwndDlg,IDC_FIX_MEMBERSHIP,DCTVS_AccountOptions_FixMembership);

				if (IsDlgButtonChecked(hwndDlg,IDC_MIGRATE_GROUPS_OF_USERS))
					checkbox( hwndDlg,IDC_REMIGRATE_OBJECTS,DCTVS_AccountOptions_IncludeMigratedAccts);
				else if (pdata->sameForest)
				{
					CString yo;
					yo.LoadString(IDS_GRATUITIOUS_MESSAGE);
					CString warning;
					warning.LoadString(IDS_MSG_WARNING);
					MessageBox(hwndDlg,yo,warning,MB_OK| MB_ICONINFORMATION);
				} 	
			
				if ( !noncollisionrename(hwndDlg))
				{
					int nID = IDC_PRE;
					MessageBoxWrapperFormat1(hwndDlg,IDS_MSG_INVALIDCHARS,IDS_INVALID_STRING,IDS_MSG_INPUT);
					   //set focus on invalid string
	                if (IsDlgButtonChecked(hwndDlg,IDC_RADIO_SUF))
					   nID = IDC_SUF;
					SetFocus(GetDlgItem(hwndDlg, nID));
					SendDlgItemMessage(hwndDlg, nID, EM_SETSEL, 
									  (WPARAM)0, (LPARAM)-1); 
				    SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
					return TRUE;
				}
					
			    if ((pdata->sourceIsNT4))
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_RENAMING);
					return TRUE;
				}
				if (pdata->sameForest && migration==w_account)
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENAMING);
					return TRUE;
				}
				break;
			}
			case PSN_WIZBACK :
                if (pdata->sameForest && migration==w_account)
                {
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OU_SELECTION);
					return TRUE;
                }
				if (!pdata->sameForest && pdata->IsSidHistoryChecked)
				{								
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
					return TRUE;
				}
				else
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DISABLE);
					return TRUE;
				}
				break;							
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(USER_OPTION_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(USER_OPTION_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK
IntOptionsReportingProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			HWND hLC7= GetDlgItem(hwndDlg,IDC_LIST_REPORTING);
			m_reportingBox.Attach(hLC7);
			CString column;
			column.LoadString(IDS_COLUMN_REPORT); m_reportingBox.InsertColumn( 1, column,LVCFMT_LEFT,150,1);
			column.LoadString(IDS_COLUMN_LASTGENERATEDON); m_reportingBox.InsertColumn( 2,column,LVCFMT_LEFT,280,1);
			getReporting();			
			break;
		}	

	 	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
//			(m_reportingBox.GetFirstSelectedItemPosition())? 
			(m_reportingBox.GetNextItem(-1, LVNI_SELECTED) != -1)? 
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT):
			    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);				
				break;
			case NM_SETFOCUS :
			case NM_KILLFOCUS :
				break;
			case NM_CLICK :
				{
//					(m_reportingBox.GetFirstSelectedItemPosition())? 
					(m_reportingBox.GetNextItem(-1, LVNI_SELECTED) != -1)? 
						PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT):
    				PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK);
					break;
				}
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					putReporting();
					_bstr_t text= get(DCTVS_Reports_AccountReferences);
					if (!UStrICmp(text ,(WCHAR const *) yes))
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION1);
						return TRUE;
					}
					else
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_END_REPORTING);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_REPORTING);
						return TRUE;
					}				
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(REPORT_SELECTION_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(REPORT_SELECTION_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK
IntRetryProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			CWaitCursor w;
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			HWND hLC= GetDlgItem(hwndDlg,IDC_LIST_RETRY);
			m_cancelBox.Attach(hLC);
			
			CString column;
			column.LoadString(IDS_COLUMN_SERVER); m_cancelBox.InsertColumn( 1, column,LVCFMT_LEFT,90,1);
			column.LoadString(IDS_COLUMN_JOBFILE); m_cancelBox.InsertColumn( 2, column,LVCFMT_LEFT,0,1);
			column.LoadString(IDS_COLUMN_STATUS); m_cancelBox.InsertColumn( 3, column,LVCFMT_LEFT,140,1);
			column.LoadString(IDS_COLUMN_ACTION); m_cancelBox.InsertColumn( 4, column,LVCFMT_LEFT,115,1);
			column.LoadString(IDS_COLUMN_ACTIONID); m_cancelBox.InsertColumn( 5, column,LVCFMT_LEFT,0,1);
			column.LoadString(IDS_COLUMN_SKIPINCLUDE); m_cancelBox.InsertColumn( 6, column,LVCFMT_LEFT,80,1);
			getFailed(hwndDlg);
			disable(hwndDlg,IDC_CANCEL);
			disable(hwndDlg,IDC_TOGGLE);
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_CANCEL :
				{
					CWaitCursor w;
					CString toggleWarning,title;
					title.LoadString(IDS_MSG_WARNING);
					toggleWarning.LoadString(IDS_MSG_PERMANENT_REMOVE);
					if (MessageBox(hwndDlg,toggleWarning,title,MB_OKCANCEL|MB_ICONEXCLAMATION)==IDOK)
					{
						handleCancel(hwndDlg);
						if (m_cancelBox.GetItemCount()==0) 	PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
					}
					
					!SomethingToRetry() ? 
						PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK ):
					PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
					break;
				}
			case IDC_TOGGLE :
				{
					OnRetryToggle();
					!SomethingToRetry() ? 
						PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK ):
					PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
					break;
				}
			default :
				break;
			}
			activateCancelIfNecessary(hwndDlg);
			break;
		}
		
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
						case LVN_COLUMNCLICK:
				{
					LPNMLISTVIEW pnmv = (NM_LISTVIEW FAR *) lParam;
					pdata->sort[pnmv->iSubItem] = !pdata->sort[pnmv->iSubItem];
					//sort(m_cancelBox,pnmv->iSubItem,pdata->sort[pnmv->iSubItem] );
//					SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
				break;
				}
	
			case NM_SETFOCUS :
			case NM_KILLFOCUS :
			case NM_CLICK:
				{
					activateCancelIfNecessary(hwndDlg);
					break;
				}				
				
			case PSN_SETACTIVE :
				!SomethingToRetry() ? 
					PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK):
					PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				if (!SomethingToRetry())
				{
					MessageBoxWrapper(hwndDlg,IDS_MSG_CANCEL,IDS_MSG_ERROR);
//					SetWindowLong(hwndDlg,DWL_MSGRESULT,IDD_RETRY);
					SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_RETRY);
					return TRUE;
				}
				else
				{
						//get the name of any server that has more than one task selected for it
					CString sServer = GetServerWithMultipleTasks();
						//if no machine with more than one task included, then retry those tasks
					if (sServer.IsEmpty())
                    {
						if (!OnRETRY(hwndDlg))
                        {
						    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
						    return TRUE;
                        }
                    }
					else  //else, print error message
					{
						MessageBoxWrapperFormat1P(hwndDlg,IDS_MSG_DUP_RETRY_SERVER,IDS_MSG_DUP_TITLE,sServer);
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}
				}
						
				break;
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{	
					SharedHelp(TASK_SELECTION_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(TASK_SELECTION_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK
IntPasswordProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
	CString editHeader;
	bool bPopulated = true;
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initpasswordbox(hwndDlg,IDC_GENERATE_STRONG_PASSWORDS,IDC_GENERATE_STRONG_PASSWORDS_NOT, IDC_MIG_PASSWORDS,
							L"AccountOptions.GenerateStrongPasswords", L"AccountOptions.CopyPasswords");
            bPopulated = populatePasswordDCs(hwndDlg, IDC_PASSWORD_DC, pdata->sourceIsNT4);
			
		    if (IsDlgButtonChecked(hwndDlg,IDC_MIG_PASSWORDS))
			{
			   disable(hwndDlg,IDC_BROWSE);
			   switchboxes(hwndDlg, IDC_PASSWORD_FILE, IDC_PASSWORD_DC);
			   editHeader.LoadString(IDS_PASSWORD_DC_HDR);
			   SetDlgItemText(hwndDlg,IDC_PASSWORD_EDIT,editHeader);
			   
			   if (!bPopulated)
				  addStringToComboBox(hwndDlg,IDC_PASSWORD_DC,sourceDC);
			   initDCcombobox( hwndDlg,IDC_PASSWORD_DC,DCTVS_AccountOptions_PasswordDC);
			}
			else
			{
			   enable(hwndDlg,IDC_BROWSE);
			   switchboxes(hwndDlg, IDC_PASSWORD_DC, IDC_PASSWORD_FILE);
			   editHeader.LoadString(IDS_PASSWORD_FILE_HDR);
			   SetDlgItemText(hwndDlg,IDC_PASSWORD_EDIT,editHeader);
			   initeditbox( hwndDlg,IDC_PASSWORD_FILE,DCTVS_AccountOptions_PasswordFile);
			
			   if (IsDlgItemEmpty(hwndDlg,IDC_PASSWORD_FILE))
			   {
				  CString toinsert;
				  GetDirectory(toinsert.GetBuffer(1000));
				  toinsert.ReleaseBuffer();
				  toinsert+="Logs\\passwords.txt";
				  SetDlgItemText(hwndDlg,IDC_PASSWORD_FILE,toinsert);
			   }
			}
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{			
			case IDC_BROWSE :
				OnFileBrowse(hwndDlg,IDC_PASSWORD_FILE);
				break;
			case IDC_MIG_PASSWORDS :
			    disable(hwndDlg,IDC_BROWSE);
			    switchboxes(hwndDlg, IDC_PASSWORD_FILE, IDC_PASSWORD_DC);
			    editHeader.LoadString(IDS_PASSWORD_DC_HDR);
			    SetDlgItemText(hwndDlg,IDC_PASSWORD_EDIT,editHeader);
			   
			    if (!populatePasswordDCs(hwndDlg, IDC_PASSWORD_DC, pdata->sourceIsNT4))
				   addStringToComboBox(hwndDlg,IDC_PASSWORD_DC,sourceDC);
			    initDCcombobox( hwndDlg,IDC_PASSWORD_DC,DCTVS_AccountOptions_PasswordDC);
				break;
			case IDC_GENERATE_STRONG_PASSWORDS :
			case IDC_GENERATE_STRONG_PASSWORDS_NOT :
			    enable(hwndDlg,IDC_BROWSE);
			    switchboxes(hwndDlg, IDC_PASSWORD_DC, IDC_PASSWORD_FILE);
			    editHeader.LoadString(IDS_PASSWORD_FILE_HDR);
			    SetDlgItemText(hwndDlg,IDC_PASSWORD_EDIT,editHeader);
			    initeditbox( hwndDlg,IDC_PASSWORD_FILE,DCTVS_AccountOptions_PasswordFile);
			
			    if (IsDlgItemEmpty(hwndDlg,IDC_PASSWORD_FILE))
				{
				   CString toinsert;
				   GetDirectory(toinsert.GetBuffer(1000));
				   toinsert.ReleaseBuffer();
				   toinsert+="Logs\\passwords.txt";
				   SetDlgItemText(hwndDlg,IDC_PASSWORD_FILE,toinsert);
				}
			    break;
			default:
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
                bPopulated = populatePasswordDCs(hwndDlg, IDC_PASSWORD_DC, pdata->sourceIsNT4);
			    initDCcombobox( hwndDlg,IDC_PASSWORD_DC,DCTVS_AccountOptions_PasswordDC);
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				{
					BOOL bMigPwd = FALSE;
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					checkbox( hwndDlg,IDC_GENERATE_STRONG_PASSWORDS,DCTVS_AccountOptions_GenerateStrongPasswords);
					checkbox( hwndDlg,IDC_MIG_PASSWORDS,DCTVS_AccountOptions_CopyPasswords);
					if (IsDlgButtonChecked(hwndDlg,IDC_MIG_PASSWORDS))
					{
						_variant_t varX = yes;
						pVarSet->put(GET_BSTR(DCTVS_AccountOptions_GenerateStrongPasswords), varX);
						bMigPwd = TRUE;
					}

					if ((!bMigPwd) && (!checkFile(hwndDlg)))
					{	
						MessageBoxWrapper(hwndDlg,IDS_MSG_FILE,IDS_MSG_INPUT);
//						SetWindowLong(hwndDlg,DWL_MSGRESULT,IDD_PASSWORD);
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_PASSWORD);
						return TRUE;
					}

					if (IsDlgButtonChecked(hwndDlg,IDC_MIG_PASSWORDS))
					    editbox( hwndDlg,IDC_PASSWORD_DC,DCTVS_AccountOptions_PasswordDC);					
					else
					    editbox( hwndDlg,IDC_PASSWORD_FILE,DCTVS_AccountOptions_PasswordFile);
					
					   //check to see if the password DC has the DLL installed and ready
					if (bMigPwd)
					{
					   CString msg, title;
					   UINT msgtype;
					   _bstr_t sTemp;
					   sTemp = _bstr_t(get(DCTVS_AccountOptions_PasswordDC));
					   CString srcSvr = (WCHAR*)sTemp;
					   if (!IsPasswordDCReady(srcSvr, msg, title, &msgtype))
					   {
						   if (MessageBox(hwndDlg, msg, title, msgtype) != IDNO)
						   {
						      SetFocus(GetDlgItem(hwndDlg, IDC_PASSWORD_DC));
						      SendDlgItemMessage(hwndDlg, IDC_PASSWORD_DC, EM_SETSEL, 
											     (WPARAM)0, (LPARAM)-1); 
				              SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						      return TRUE;
						   }
					   }
					   else  //else, store this tgtDC used in this check for use during the migration
                       {
						  pVarSet->put(GET_BSTR(DCTVS_Options_TargetServerOverride), GetTargetDcNameFlat());
						  pVarSet->put(GET_BSTR(DCTVS_Options_TargetServerOverrideDns), GetTargetDcNameDns());
                       }
					}

					if (IsDlgButtonChecked(hwndDlg,IDC_GENERATE_STRONG_PASSWORDS_NOT))
					{
						ShowWarning(hwndDlg);
					}
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(PASSWORD_OPTION_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(PASSWORD_OPTION_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK
IntTargetGroupProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_BROWSE:
				{
					HRESULT hr = pDsObjectPicker2->InvokeDialog(hwndDlg, &pdo2);
					if (FAILED(hr)) return 0;	 
					if (hr == S_OK) {
						ProcessSelectedObjects2(pdo2,hwndDlg);
						pdo2->Release();
					}
					break;
				}
			default :
				break;
			}
			switch(HIWORD(wParam))
			{
			case EN_CHANGE :
				enableNextIfNecessary(hwndDlg,IDC_TARGET_GROUP);
				break;
			default: 
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				enableNextIfNecessary(hwndDlg,IDC_TARGET_GROUP);
				break;
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					_bstr_t text = get(DCTVS_Accounts_NumItems);
					int count = _ttoi((WCHAR * const) text);
					CString base=L"",toadd;
					_variant_t varX;
					for (int i = 0;i<count;i++)
					{
						base.Format(L"Accounts.%ld.TargetName",i);
						GetDlgItemText(hwndDlg,IDC_TARGET_GROUP,toadd.GetBuffer(1000),1000);
						toadd.ReleaseBuffer();
						varX = toadd;
						pVarSet->put(_bstr_t(base),varX);
					}
					break;
					}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(TARGET_GROUP_SELECTION, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(TARGET_GROUP_SELECTION, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK
IntTrustProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{CWaitCursor w;
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			HWND hLC= GetDlgItem(hwndDlg,IDC_LIST_SERVICE);
			m_trustBox.Attach(hLC);
			CString column;
			column.LoadString(IDS_COLUMN_DOMAIN); m_trustBox.InsertColumn( 1, column,LVCFMT_LEFT,155,1);
			column.LoadString(IDS_COLUMN_DIRECTION); m_trustBox.InsertColumn( 2, column,LVCFMT_LEFT,80,1);
			column.LoadString(IDS_COLUMN_ATTRIBUTES); m_trustBox.InsertColumn( 3, column,LVCFMT_LEFT,80,1);
			column.LoadString(IDS_COLUMN_EXISTSFORTARGET); m_trustBox.InsertColumn( 4, column,LVCFMT_LEFT,90,1);
			disable(hwndDlg,IDC_MIGRATE);
			
			if (pdata->newSource)
			{
				m_trustBox.DeleteAllItems();
				getTrust();
				pdata->newSource=false;
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
			}
        break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_MIGRATE:
				{
					bool atleast1succeeded=false;
					CString errDomain;
					HRESULT hr = MigrateTrusts(hwndDlg,atleast1succeeded,errDomain);
					if (SUCCEEDED(hr))
					{
						if (atleast1succeeded)
						{
							PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
							pdata->proceed= true;
						}
					}
					else
					{
					    if (errDomain.IsEmpty())
						    ErrorWrapper(hwndDlg,hr);
					    else
					        ErrorWrapper3(hwndDlg, hr, errDomain);
					}


					  activateTrustButton(hwndDlg);

					
					break;
				}
			default :
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
						case LVN_COLUMNCLICK:
				{
					LPNMLISTVIEW pnmv = (NM_LISTVIEW FAR *) lParam;
					pdata->sort[pnmv->iSubItem] = !pdata->sort[pnmv->iSubItem];
					//sort(m_trustBox,pnmv->iSubItem,pdata->sort[pnmv->iSubItem] );
//					SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
				break;
				}
	

			case NM_SETFOCUS :
			case NM_KILLFOCUS :
			case NM_CLICK:
				{
					activateTrustButton(hwndDlg);
					break;
				}				

			case PSN_SETACTIVE :				
				if (pdata->newSource)
				{
					m_trustBox.DeleteAllItems();
					getTrust();
					pdata->newSource=false;
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				}
				
				pdata->proceed ? 
					PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT):
				PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK);
				break;
			case PSN_WIZNEXT :
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				if (!pdata->proceed)
				{
					MessageBoxWrapper(hwndDlg,IDS_MSG_SELECT_TRUST,IDS_MSG_INPUT);
//					SetWindowLong(hwndDlg,DWL_MSGRESULT,IDD_TRUST_INFO);
					SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_TRUST_INFO);
					return TRUE;
				}		
				break;
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(TRUST_INFO_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(TRUST_INFO_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK
IntRebootProc(
			  IN HWND hwndDlg,
			  IN UINT uMsg,
			  IN WPARAM wParam,
			  IN LPARAM lParam
			  )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initnoncollisionrename(hwndDlg);
			addrebootValues(hwndDlg);
			initeditbox(hwndDlg,IDC_COMBO2,DCTVS_Options_GuiOnlyRebootSaver);
			if (IsDlgItemEmpty(hwndDlg,IDC_COMBO2))
			{
				CString s;
		
				s.LoadString(IDS_FIVE);
				SetDlgItemText(hwndDlg,IDC_COMBO2,s);
			}
			break;
		}
		
	case WM_COMMAND :
		{
			switch(LOWORD(wParam))
			{
			case IDC_RADIO_NONE :
				{
					disable(hwndDlg,IDC_PRE);
					disable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_PRE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_SUF,false);
					break;
				}	
			case IDC_RADIO_PRE :
				{
					enable(hwndDlg,IDC_PRE);
					disable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_NONE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_SUF,false);
				    SetFocus(GetDlgItem(hwndDlg, IDC_PRE));
					SendDlgItemMessage(hwndDlg, IDC_PRE, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
					break;
				}	
			case IDC_RADIO_SUF :
				{
					disable(hwndDlg,IDC_PRE);
					enable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_NONE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_PRE,false);
				    SetFocus(GetDlgItem(hwndDlg, IDC_SUF));
					SendDlgItemMessage(hwndDlg, IDC_SUF, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
					break;
				}	
			default:
				{
					break;
				}
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				enableNextIfNecessary(hwndDlg,IDC_COMBO2);
				break;
			case PSN_WIZNEXT :
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				if (validReboot(hwndDlg,IDC_COMBO2))
				{
					editbox(hwndDlg,IDC_COMBO2,DCTVS_Options_GuiOnlyRebootSaver);
					pdata->rebootDelay=rebootbox( hwndDlg,IDC_COMBO2);
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				}
				else
				{
					MessageBoxWrapper(hwndDlg,IDS_MSG_REBOOT,IDS_MSG_INPUT);
//					SetWindowLong(hwndDlg,DWL_MSGRESULT,IDD_REBOOT);
					SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_REBOOT);
					return TRUE;
				}
				if ( !noncollisionrename(hwndDlg))
				{
					int nID = IDC_PRE;
					MessageBoxWrapperFormat1(hwndDlg,IDS_MSG_INVALIDCHARS,IDS_INVALID_STRING,IDS_MSG_INPUT);
					   //set focus on invalid string
	                if (IsDlgButtonChecked(hwndDlg,IDC_RADIO_SUF))
					   nID = IDC_SUF;
					SetFocus(GetDlgItem(hwndDlg, nID));
					SendDlgItemMessage(hwndDlg, nID, EM_SETSEL, 
									  (WPARAM)0, (LPARAM)-1); 
				    SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
					return TRUE;
//					SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_REBOOT);
				}

				if (pdata->sourceIsNT4)
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENAMING);
					return TRUE;
				}
				break;
			case PSN_WIZBACK :
				{
					if (migration==w_computer)
					{
						if (!pdata->translateObjects)
						{
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_TRANSLATION);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION);
							return TRUE;
						}
						else
						{					
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_TRANSLATION_MODE);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION_MODE);
							return TRUE;
						}
					}
				}
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(COMPUTER_OPTION, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(COMPUTER_OPTION, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}
INT_PTR CALLBACK
IntTranslationProc(
				   IN HWND hwndDlg,
				   IN UINT uMsg,
				   IN WPARAM wParam,
				   IN LPARAM lParam
				   )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initcheckbox( hwndDlg,IDC_FILES,DCTVS_Security_TranslateFiles);
			initcheckbox( hwndDlg,IDC_SHARES,DCTVS_Security_TranslateShares);
			initcheckbox( hwndDlg,IDC_PRINTERS,DCTVS_Security_TranslatePrinters);
			initcheckbox( hwndDlg,IDC_USER_RIGHTS,DCTVS_Security_TranslateUserRights);
			initcheckbox( hwndDlg,IDC_LOCAL_GROUPS,DCTVS_Security_TranslateLocalGroups);
			initcheckbox( hwndDlg,IDC_USER_PROFILES,DCTVS_Security_TranslateUserProfiles);
			initcheckbox( hwndDlg,IDC_REGISTRY,DCTVS_Security_TranslateRegistry);
			if ((IsDlgButtonChecked(hwndDlg,IDC_FILES)) ||
			    (IsDlgButtonChecked(hwndDlg,IDC_SHARES)) ||
			    (IsDlgButtonChecked(hwndDlg,IDC_PRINTERS)) ||
			    (IsDlgButtonChecked(hwndDlg,IDC_USER_RIGHTS)) ||
 			    (IsDlgButtonChecked(hwndDlg,IDC_LOCAL_GROUPS)) ||
			    (IsDlgButtonChecked(hwndDlg,IDC_USER_PROFILES)) ||
			    (IsDlgButtonChecked(hwndDlg,IDC_REGISTRY)) ||
				(migration==w_computer))
			{
			   PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
			}
			else
			   PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);

			break;
		}
	case WM_COMMAND:
		{
			bool bCheck = false;
			switch(LOWORD (wParam))
			{
			case IDC_FILES :
				bCheck = true;
				break;
			case IDC_SHARES :		
				bCheck = true;
				break;
			case IDC_PRINTERS :
				bCheck = true;
				break;
			case IDC_USER_RIGHTS :
				bCheck = true;
				break;
			case IDC_LOCAL_GROUPS :
				bCheck = true;
				break;
			case IDC_USER_PROFILES :
				bCheck = true;
				break;
			case IDC_REGISTRY :
				bCheck = true;
				break;
			default:
				break;
			}

			if (bCheck)
			{
			    if ((IsDlgButtonChecked(hwndDlg,IDC_FILES)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_SHARES)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_PRINTERS)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_USER_RIGHTS)) ||
 			       (IsDlgButtonChecked(hwndDlg,IDC_LOCAL_GROUPS)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_USER_PROFILES)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_REGISTRY)) ||
				   (migration==w_computer))
				{
			       PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				}
			    else
			       PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
			    if ((IsDlgButtonChecked(hwndDlg,IDC_FILES)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_SHARES)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_PRINTERS)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_USER_RIGHTS)) ||
 			       (IsDlgButtonChecked(hwndDlg,IDC_LOCAL_GROUPS)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_USER_PROFILES)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_REGISTRY)) ||
				   (migration==w_computer))
				{
			       PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				}
			    else
			       PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
			    break;
			case PSN_WIZNEXT :
				checkbox( hwndDlg,IDC_FILES,DCTVS_Security_TranslateFiles);
				checkbox( hwndDlg,IDC_SHARES,DCTVS_Security_TranslateShares);
				checkbox( hwndDlg,IDC_PRINTERS,DCTVS_Security_TranslatePrinters);
				checkbox( hwndDlg,IDC_USER_RIGHTS,DCTVS_Security_TranslateUserRights);
				checkbox( hwndDlg,IDC_LOCAL_GROUPS,DCTVS_Security_TranslateLocalGroups);
				checkbox( hwndDlg,IDC_USER_PROFILES,DCTVS_Security_TranslateUserProfiles);
				checkbox( hwndDlg,IDC_REGISTRY,DCTVS_Security_TranslateRegistry);
				if (IsDlgButtonChecked(hwndDlg,IDC_FILES) ||
					(IsDlgButtonChecked(hwndDlg,IDC_SHARES) ||
					(IsDlgButtonChecked(hwndDlg,IDC_PRINTERS) ||
					(IsDlgButtonChecked(hwndDlg,IDC_USER_RIGHTS) ||
 					(IsDlgButtonChecked(hwndDlg,IDC_LOCAL_GROUPS) ||
					(IsDlgButtonChecked(hwndDlg,IDC_USER_PROFILES) ||
					(IsDlgButtonChecked(hwndDlg,IDC_REGISTRY))))))))
				{
					pdata->translateObjects=true;

//					SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_TRANSLATION_MODE);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION_MODE);
					return TRUE;
				}
				else
				{
					pdata->translateObjects=false;
				    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_REBOOT);
				    return TRUE;
				}
					
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				break;
			case PSN_WIZBACK :
			
	break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(TRANSLATE_OBJECTS_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(TRANSLATE_OBJECTS_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK
IntUndoProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
	IPerformMigrationTaskPtr      w;  

	HRESULT hr = w.CreateInstance(CLSID_Migrator);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			CString s;
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			BSTR desc = NULL;
			w->GetTaskDescription(IUnknownPtr(pVarSetUndo), &desc);
			s = desc;
			SysFreeString(desc);
			SetDlgItemText(hwndDlg, IDC_UNDO_TASK,s);			
			break;
		}
	case WM_HELP :
		{			
			SharedHelp(UNDO_HELP, hwndDlg);
			break;
		}	
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				{
						PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);						

				break;
				}
			case PSN_WIZNEXT :
				{
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					//set up the undo task
					IUnknownPtr pUnk;
					w->GetUndoTask(IUnknownPtr(pVarSetUndo), &pUnk);
					if (pVarSet)
					{
						pVarSet->Release();
						pVarSet = NULL;
					}
					pUnk->QueryInterface(IID_IVarSet,(void**)&pVarSet);
					
					put(DCTVS_Options_AppendToLogs,yes);
					_bstr_t s1=get(DCTVS_Options_SourceDomain);
					_bstr_t t1=get(DCTVS_Options_TargetDomain);
					
					CString s= (WCHAR const*) s1;
					CString t= (WCHAR const*) t1;
					HRESULT hr=S_OK;
		
					_bstr_t text=get(DCTVS_Options_Wizard);
			
					pdata->sameForest=CheckSameForest(t,s,hr);
					if (FAILED(hr))
					{
							ErrorWrapper4(hwndDlg,hr,s);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_UNDO);						
							return TRUE;
					}
					else
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_UNDO);
						return TRUE;
					}
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{	
					SharedHelp(UNDO_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK EndDlgProc (
						  HWND hwndDlg,
						  UINT uMsg,
						  WPARAM wParam,
						  LPARAM lParam
						  )
{
	
	IPerformMigrationTaskPtr      w;  
	CString s;
	HRESULT hr = w.CreateInstance(CLSID_Migrator);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{	pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
		SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
		HWND hwndControl = GetDlgItem(hwndDlg, IDC_END_TITLE);
		SetWindowFont(hwndControl,pdata->hTitleFont, TRUE);				
		break;
		}
	case WM_HELP :
		{			
			SharedHelp(CONFIRMATION_HELP, hwndDlg);
			break;
		}		
	
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code) 
			{				
			case PSN_SETACTIVE : 
				{
					BSTR desc = NULL;
					w->GetTaskDescription(IUnknownPtr(pVarSet), &desc);
					s= desc;
					SysFreeString(desc);
					SetDlgItemText(hwndDlg,IDC_SETTINGS,s);					
					PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_FINISH);
					break;
				}
			case PSN_WIZBACK :{
				if (migration==w_reporting)
				{
					_bstr_t text= get(DCTVS_Reports_AccountReferences);
					if (!UStrICmp(text ,(WCHAR const *) yes))
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION1);
						return TRUE;
					}
					else
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OPTIONS_REPORTING);
						return TRUE;
					}
				}
				else if (migration==w_account)
				{
					if (pdata->someService)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_INFO);
						return TRUE;
					}
					else
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENAMING);
						return TRUE;
					}
				}
				else if (migration==w_security)
				{
					if (pdata->translateObjects)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION_MODE);
						return TRUE;
					}
					else
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION);
						return TRUE;
					}
				}
				else if (migration==w_groupmapping)
				{
					if (!pdata->IsSidHistoryChecked)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OPTIONS_GROUPMAPPING);
						return TRUE;
					}
				}
				else if (migration==w_group)
				{
					if (pdata->migratingGroupMembers && !pdata->sameForest)
					{
						if (pdata->someService)
						{
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_INFO);
							return TRUE;
						}
						else 
						{
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DISABLE);
							return TRUE;
						}						
					}
					else
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENAMING);
						return TRUE;
					}
				}
				
				else if (migration==w_undo)
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_UNDO);
					return TRUE;
				}
				break;
				}
			case PSN_WIZFINISH :
				{
					
					if (migration == w_computer)
						populateTime(pdata->rebootDelay,pdata->servers);
					if (migration == w_reporting)
						populateReportingTime();
				
					
					if (migration!=w_service)
					{
						try
						{CWaitCursor w2;
						    w->PerformMigrationTask(IUnknownPtr(pVarSet),(LONG_PTR)hwndDlg);
						}	
						catch (const _com_error& e)
						{
							if (e.Error() == MIGRATOR_E_PROCESSES_STILL_RUNNING)
							{
								CString str;
								str.LoadString(IDS_ADMT_PROCESSES_STILL_RUNNING);
								::AfxMessageBox(str);
							}
							else
							{
							    _bstr_t bstrDescription;
							    try
							    {
    							    bstrDescription = e.Description();
							    }
							    catch (_com_error& ce)
							    {
							    }
							    if (bstrDescription.length())
							        ::AfxMessageBox(bstrDescription);
							    else
								    ::AfxMessageBox(e.ErrorMessage());
							}
							break;
						}
					}
					if (migration!=w_undo)
						handleDB();
					break;					
				}
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_RESET :
				break;
			case PSN_HELP :
				{	
					SharedHelp(CONFIRMATION_HELP, hwndDlg);
					break;
				}
			default :
				break;	
			}
			break;
		}	
	default:
		break;
	}
	return 0;
}
INT_PTR CALLBACK IntroDlgProc (
							HWND hwndDlg,
							UINT uMsg,
							WPARAM wParam,
							LPARAM lParam
							)
{	IPerformMigrationTaskPtr      w;  
	CString s;
	HRESULT hr = w.CreateInstance(CLSID_Migrator);

//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
			HWND hwndControl = GetDlgItem(hwndDlg, IDC_BEGIN_TITLE);
			SetWindowFont(hwndControl,pdata->hTitleFont, TRUE);
			break;
		}
	case WM_HELP :
		{
			SharedHelp(WELCOME_HELP, hwndDlg);
			break;
		}		

	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE : 
			{
					BSTR desc = NULL;
					w->GetTaskDescription(IUnknownPtr(pVarSet), &desc);
					s= desc;
					SysFreeString(desc);
					SetDlgItemText(hwndDlg,IDC_SETTINGS,s);				
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
				break;
			}
			case PSN_WIZNEXT :
				{
					if (migration==w_undo)
					{
						_bstr_t b=pVarSetUndo->get(GET_BSTR(DCTVS_Options_SourceDomain));
						CString s=(WCHAR *) b;
                        _bstr_t strDc;
						CString sourceDomainController; 
						DWORD res = GetAnyDcName5(s, strDc); 
						if (res!=NO_ERROR)
						{
							ErrorWrapper3(hwndDlg,HRESULT_FROM_WIN32(res),s);
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_INTRO_UNDO);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_INTRO_UNDO);
							return TRUE;
						}
						else
						{
							sourceDomainController = (LPCTSTR)strDc;
						}
						bool isNt4;
						hr =validDomain(sourceDomainController,isNt4);
						if (!SUCCEEDED(hr))
						{
							ErrorWrapper4(hwndDlg,hr,s);
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_INTRO_UNDO);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_INTRO_UNDO);
							return TRUE;
						}
						if(!isNt4)
						{HRESULT hr;
							if (!targetNativeMode(b,hr))
							{	
								MessageBoxWrapper(hwndDlg,IDS_MSG_MESSAGE9,IDS_MSG_ERROR);
//								SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_INTRO_UNDO);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_INTRO_UNDO);
								return TRUE;
							}
						}						
					}
					break;
				}
			case PSN_QUERYCANCEL :
				{
					GetError(0); //clear any old com errors
					break;
				}
			case PSN_RESET :
				break;
			case PSN_HELP :
				{	
					SharedHelp(WELCOME_HELP, hwndDlg);
					break;
				}
			default :
				break;
			}
			break;
		}
		
	default:
		break;
	}
	return 0;
}

INT_PTR CALLBACK IntDomainSelectionProc (
                                    HWND hwndDlg,
                                    UINT uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam
                                    )
{
    HRESULT hr;	
    // LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
    LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    //TRACE1("Message:%ld\n",uMsg);
    switch (uMsg)
    {
    case WM_INITDIALOG :
        {
            pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
            // SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
            HWND hLC4= GetDlgItem(hwndDlg,IDC_EDIT_DOMAIN);
            sourceDrop.Attach(hLC4);
            HWND hLC5= GetDlgItem(hwndDlg,IDC_EDIT_DOMAIN2);
            targetDrop.Attach(hLC5);
            populateList(sourceDrop);
            populateList(targetDrop);
            initeditbox( hwndDlg,IDC_EDIT_DOMAIN,DCTVS_Options_SourceDomain);
            initeditbox( hwndDlg, IDC_EDIT_DOMAIN2,DCTVS_Options_TargetDomain);
            // SetDlgItemText(hwndDlg,IDC_EDIT_DOMAIN,L"MCSDEV");
            // SetDlgItemText(hwndDlg,IDC_EDIT_DOMAIN2,L"DEVRAPTORW2K");
            break;
        }
    case WM_NOTIFY :
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;
            switch (lpnm->code)
            {
            case PSN_SETACTIVE :
                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                break;
            case PSN_WIZNEXT :
                {
                    // SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
                    SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
                    CString sourceDomainController=L"";
                    CString targetDomainController=L""; 

                    if (IsDlgItemEmpty(hwndDlg,IDC_EDIT_DOMAIN) ||
                        IsDlgItemEmpty(hwndDlg,IDC_EDIT_DOMAIN2) )
                    {
                        MessageBoxWrapper(hwndDlg,IDS_MSG_DOMAIN,IDS_MSG_INPUT);
                        // SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_DOMAIN_SELECTION);
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DOMAIN_SELECTION);
                        return TRUE;
                    }
                    else if ((migration!=w_security) && (!verifyprivs(hwndDlg,sourceDomainController,targetDomainController,pdata)))
                    {
                        // SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
                        SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
                        // SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_DOMAIN_SELECTION);
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DOMAIN_SELECTION);
                        return TRUE;
                    }
                    else if ((migration==w_security) && (!verifyprivsSTW(hwndDlg,sourceDomainController,targetDomainController,pdata)))
                    {
                        // SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
                        SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
                        // SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_DOMAIN_SELECTION);
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DOMAIN_SELECTION);
                        return TRUE;
                    }
                    else
                    {
                        //
                        // If performing an intra-forest task.
                        //

                        if (pdata->sameForest)
                        {
                            //
                            // If performing an intra-forest move operation verify
                            // caller's account may be delegated.
                            //

                            switch (migration)
                            {
                            case w_account:
                            case w_group:
                            case w_computer:
                            case w_groupmapping:
                            case w_undo:
                                {
                                    if (VerifyCallerDelegated(hwndDlg, pdata) == false)
                                    {
                                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DOMAIN_SELECTION);
                                        return TRUE;
                                    }
                                    break;
                                }
                            default:
                                break;
                            }

                            //
                            // Remove SID history credentials to prevent intra-forest operations
                            // from attempting to use old credentials especially without a password.
                            //

                            put(DCTVS_AccountOptions_SidHistoryCredentials_Domain, L"");
                            put(DCTVS_AccountOptions_SidHistoryCredentials_UserName, L"");
                        }

                        if (sourceDC != sourceDomainController)
                        {
                            sourceDC = sourceDomainController;
                            DCList.RemoveAll();
                        }

                        // SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
                        SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
                        if (migration==w_groupmapping && pdata->sameForest)
                        {
                            MessageBoxWrapper(hwndDlg,IDS_MSG_GROUPMAPPING,IDS_MSG_ERROR);
                            // SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_DOMAIN_SELECTION);
                            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DOMAIN_SELECTION);
                            return TRUE;
                        }
                        put(DCTVS_Options_SourceDomain, GetSourceDomainName());
                        put(DCTVS_Options_SourceDomainDns, GetSourceDomainNameDns());
                        put(DCTVS_Options_SourceDomainFlat, GetSourceDomainNameFlat());
                        put(DCTVS_Options_TargetDomain, GetTargetDomainName());
                        put(DCTVS_Options_TargetDomainDns, GetTargetDomainNameDns());
                        put(DCTVS_Options_TargetDomainFlat, GetTargetDomainNameFlat());
                        clearCredentialsName = pdata->newSource;

                        //
                        // If inter-forest account migration then verify that the
                        // default system properties exclusion list has been set.
                        //

                        if (pdata->sameForest == false)
                        {
                            switch (migration)
                            {
                            case w_account:
                            case w_group:
                            case w_computer:
                            case w_groupmapping:
                                {
                                    SetDefaultExcludedSystemProperties(hwndDlg);
                                    break;
                                }
                            default:
                                break;
                            }
                        }

                        if (migration!=w_trust &&
                            (migration!=w_retry &&
                            (migration!=w_undo &&
                            (migration!=w_exchangeDir &&
                            (migration!=w_exchangeSrv)))))
                        {
                            if ((migration==w_service) || (migration==w_reporting))
                            {
                                hr =InitObjectPicker2(pDsObjectPicker,true,sourceDomainController,pdata->sourceIsNT4);
                            }
                            else if (migration==w_security)
                            {
                                hr =InitObjectPicker2(pDsObjectPicker,true,targetDomainController,false);
                            }
                            else
                            {
                                hr =InitObjectPicker(pDsObjectPicker,true,sourceDomainController,pdata->sourceIsNT4);
                            }

                            if (FAILED(hr)) 
                            {
                                MessageBoxWrapper(hwndDlg,IDS_MSG_OBJECTPICKER_SOURCE,IDS_MSG_ERROR);
                                // SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_DOMAIN_SELECTION);
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DOMAIN_SELECTION);
                                return TRUE;
                            }

                            if (migration==w_groupmapping)
                            {
                                hr = InitObjectPicker(pDsObjectPicker2,false,targetDomainController,pdata->sourceIsNT4);							
                                if (FAILED(hr)) 
                                {
                                    MessageBoxWrapper(hwndDlg,IDS_MSG_OBJECTPICKER_TARGET,IDS_MSG_ERROR);		
                                    // SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_DOMAIN_SELECTION);
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DOMAIN_SELECTION);
                                    return TRUE;
                                }
                            }
                        }
                    }
                    break;
                }
            case PSN_WIZBACK :
                break;
            case PSN_QUERYCANCEL :
                {
                    if (!ReallyCancel(hwndDlg))
                    {
                        SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
                        return TRUE;
                    }

                    GetError(0); //clear any old com errors
                    break;
                }
            case PSN_HELP :
                {
                    SharedHelp(DOMAIN_SELECTION_HELP, hwndDlg);
                    break;
                }
            case PSN_RESET :
                break;
            default :
                break;
            }
            break;
        }   case WM_HELP :
        {
            SharedHelp(DOMAIN_SELECTION_HELP, hwndDlg);
            break;
        }

    default:
        break;
    }
    return 0;
}

INT_PTR CALLBACK IntDisableProc (
							  HWND hwndDlg,
							  UINT uMsg,
							  WPARAM wParam,
							  LPARAM lParam
							  )
{
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);

			   //init the sidhistory checkbox
            if (migration==w_account)
			{
			   CString toformat;
			   toformat.LoadString(IDS_SIDHISTORY_CTRL_TEXT);
		       SetDlgItemText(hwndDlg,IDC_ROAMING_OR_SIDHISTORY,toformat);
	           initcheckbox( hwndDlg,IDC_ROAMING_OR_SIDHISTORY,DCTVS_AccountOptions_AddSidHistory);
			   if (pdata->sameForest)
			   {
				  CheckDlgButton(hwndDlg,IDC_ROAMING_OR_SIDHISTORY,true);
				  disable(hwndDlg,IDC_ROAMING_OR_SIDHISTORY);
			   }
			}
			else //else init the box for roaming profile
			{
			   CString toformat;
			   toformat.LoadString(IDS_ROAMING_PROFILE_CTRL_TEXT);
			   SetDlgItemText(hwndDlg,IDC_ROAMING_OR_SIDHISTORY,toformat);
			   initcheckbox( hwndDlg,IDC_ROAMING_OR_SIDHISTORY,DCTVS_AccountOptions_TranslateRoamingProfiles);
			}

			initdisablesrcbox(hwndDlg);		

			inittgtstatebox(hwndDlg);		

			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_SRC_EXPIRE_ACCOUNTS :
				{
			        if (IsDlgButtonChecked(hwndDlg,IDC_SRC_EXPIRE_ACCOUNTS))
					{     
						enable(hwndDlg,IDC_yo);
						enable(hwndDlg,IDC_DATE);
						enable(hwndDlg,IDC_TEXT);
					}
					else
					{
						disable(hwndDlg,IDC_yo);
						disable(hwndDlg,IDC_DATE);
						disable(hwndDlg,IDC_TEXT);
					}
					break;
				}
			default :
				break;
			}
			
			switch(HIWORD (wParam)){
			case EN_SETFOCUS :
			    bChangeOnFly=true;
				break;
			case EN_KILLFOCUS :
			    bChangeOnFly=false;
				break;
			case EN_CHANGE:	
				{
					if ((!bChangeOnFly) || (LOWORD(wParam) != IDC_yo))
						break;
					CString s;
					GetDlgItemText(hwndDlg,IDC_yo,s.GetBuffer(1000),1000);
					s.ReleaseBuffer();
					   //make sure all chars are digits
					bool bInvalid = false;
					int ndx=0;
					while ((ndx < s.GetLength()) && (!bInvalid))
					{
						if (!iswdigit(s[ndx]))
						   bInvalid = true;
						ndx++;
					}
					if (bInvalid)
					{
						  //for invalid days, blank out the date
					   SetDlgItemText(hwndDlg,IDC_DATE,L"");
					}
					else //else continue checking for validity
					{
					   long ndays = _wtol(s);
					   if (((ndays <= THREE_YEARS) && (ndays >= 1)) ||
						   (!UStrICmp(s,L"0")))
					      calculateDate(hwndDlg,s);
					   else
					   {
						     //for invalid days, blank out the date
					      SetDlgItemText(hwndDlg,IDC_DATE,L"");
					   }
					}
					break;
				}
			default :
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{			

			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				{
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					checkbox(hwndDlg,IDC_SRC_DISABLE_ACCOUNTS,DCTVS_AccountOptions_DisableSourceAccounts);
					checkbox(hwndDlg,IDC_TGT_DISABLE_ACCOUNTS,DCTVS_AccountOptions_DisableCopiedAccounts);
					checkbox(hwndDlg,IDC_TGT_SAME_AS_SOURCE,DCTVS_AccountOptions_TgtStateSameAsSrc);
					_variant_t varX;
					if (IsDlgButtonChecked(hwndDlg,IDC_SRC_EXPIRE_ACCOUNTS))
					{
					    CString s;
					    GetDlgItemText(hwndDlg,IDC_yo,s.GetBuffer(1000),1000);
					    s.ReleaseBuffer();
							//make sure all chars are digits
						int ndx=0;
						while (ndx < s.GetLength())
						{
							if (!iswdigit(s[ndx]))
							{
								MessageBoxWrapper(hwndDlg,IDS_MSG_TIME,IDS_MSG_ERROR);
								SetFocus(GetDlgItem(hwndDlg, IDC_yo));
								SendDlgItemMessage(hwndDlg, IDC_yo, EM_SETSEL, 
												  (WPARAM)0, (LPARAM)-1); 
								SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
								return TRUE;
							}
							ndx++;
						}
					    long ndays = _wtol(s);
					    if (((ndays <= THREE_YEARS) && (ndays >= 1)) ||
						    (!UStrICmp(s,L"0")))
						{
						    varX = (LPCTSTR)s;
						    put(DCTVS_AccountOptions_ExpireSourceAccounts,varX);
						}
						else 
						{
						    MessageBoxWrapper(hwndDlg,IDS_MSG_TIME,IDS_MSG_ERROR);
						    SetFocus(GetDlgItem(hwndDlg, IDC_yo));
						    SendDlgItemMessage(hwndDlg, IDC_yo, EM_SETSEL, 
											  (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						    return TRUE;
						}
					}
					else
					{
						varX = L"";
						put(DCTVS_AccountOptions_ExpireSourceAccounts,varX);
					}

					if (migration==w_account)
					{
					   if (IsDlgButtonChecked(hwndDlg,IDC_ROAMING_OR_SIDHISTORY) && !pdata->sameForest)
					   {
                           HRESULT hr = doSidHistory(hwndDlg);

                           if (SUCCEEDED(hr))
                           {
                               pVarSet->put(GET_BSTR(DCTVS_Options_TargetServerOverride), GetTargetDcNameFlat());
                               pVarSet->put(GET_BSTR(DCTVS_Options_TargetServerOverrideDns), GetTargetDcNameDns());
                           }
                           else
                           {
                               if (hr != E_ABORT)
                               {
                                   ErrorWrapper(hwndDlg, hr);
                               }

                               CheckDlgButton(hwndDlg, IDC_ROAMING_OR_SIDHISTORY, false);
                           }
					   }
					
					   checkbox(hwndDlg,IDC_ROAMING_OR_SIDHISTORY,DCTVS_AccountOptions_AddSidHistory);										
					   pdata->IsSidHistoryChecked =(IsDlgButtonChecked( hwndDlg,IDC_ROAMING_OR_SIDHISTORY)==BST_CHECKED)?true:false;
					   if (!pdata->sameForest && pdata->IsSidHistoryChecked)
					   {
						  SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
						  return TRUE;
					   }
					   else
					   {
						  SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_OPTIONS);
						  return TRUE;
					   }
					}//end if user migration
					else //else set or clear the translate roaming profile key
					   checkbox( hwndDlg,IDC_ROAMING_OR_SIDHISTORY,DCTVS_AccountOptions_TranslateRoamingProfiles);

					if (someServiceAccounts(pdata->accounts,hwndDlg))
					{
						pdata->someService=true;
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_INFO);
						return TRUE;
					}
					else
					{
						pdata->someService=false;
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_GROUP);
						return TRUE;
					}
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(ACCOUNTTRANSITION_OPTION, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(ACCOUNTTRANSITION_OPTION, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK IntTranslationModeProc (
									  HWND hwndDlg,
									  UINT uMsg,
									  WPARAM wParam,
									  LPARAM lParam
									  )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			break;
		}

	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
			    inittranslationbox( hwndDlg,
				    IDC_TRANSLATION_MODE_REPLACE,IDC_TRANSLATION_MODE_ADD,IDC_TRANSLATION_MODE_REMOVE,
				    DCTVS_Security_TranslationMode,pdata->sameForest);
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
			{
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				
				translationbox( hwndDlg,
					IDC_TRANSLATION_MODE_REPLACE,IDC_TRANSLATION_MODE_ADD,IDC_TRANSLATION_MODE_REMOVE,
					DCTVS_Security_TranslationMode);

					//if not add mode and user rights translation selected previously, them
					//post an informational message
				_bstr_t TransUserRights = get(DCTVS_Security_TranslateUserRights);
                if ((!IsDlgButtonChecked( hwndDlg, IDC_TRANSLATION_MODE_ADD)) &&
					(!UStrCmp(TransUserRights,(WCHAR const *) yes)))
				{
					CString message;
					CString title;
					message.LoadString(IDS_MSG_TRANSUR_ADDONLY);
					title.LoadString(IDS_MSG_TRANSUR_TITLE);
					MessageBox(hwndDlg,message,title,MB_OK | MB_ICONINFORMATION);
				}
				break;
			}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(SECURITY_OPTION_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(SECURITY_OPTION_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}
INT_PTR CALLBACK IntOptionsGroupMappingProc(
								   HWND hwndDlg,
								   UINT uMsg,
								   WPARAM wParam,
								   LPARAM lParam
								   )
{
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			
			initcheckbox( hwndDlg,IDC_COPY_USER_RIGHTS,DCTVS_AccountOptions_UpdateUserRights);
			initcheckbox( hwndDlg,IDC_ADD_SID_HISTORY,DCTVS_AccountOptions_AddSidHistory);

			if (pdata->sameForest)
			{
				CheckDlgButton(hwndDlg,IDC_ADD_SID_HISTORY,true);
				disable(hwndDlg,IDC_ADD_SID_HISTORY);
			}
	
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				checkbox( hwndDlg,IDC_COPY_USER_RIGHTS,DCTVS_AccountOptions_UpdateUserRights);
				
				if (IsDlgButtonChecked(hwndDlg,IDC_ADD_SID_HISTORY) && !pdata->sameForest)
				{
                    HRESULT hr = doSidHistory(hwndDlg);

                    if (SUCCEEDED(hr))
                    {
                        pVarSet->put(GET_BSTR(DCTVS_Options_TargetServerOverride), GetTargetDcNameFlat());
                        pVarSet->put(GET_BSTR(DCTVS_Options_TargetServerOverrideDns), GetTargetDcNameDns());
                    }
                    else
                    {
                        if (hr != E_ABORT)
                        {
                            ErrorWrapper(hwndDlg, hr);
                        }

                        CheckDlgButton(hwndDlg, IDC_ADD_SID_HISTORY, false);
                    }
				}
				
				checkbox( hwndDlg,IDC_ADD_SID_HISTORY,DCTVS_AccountOptions_AddSidHistory);
				pdata->IsSidHistoryChecked =(IsDlgButtonChecked( hwndDlg,IDC_ADD_SID_HISTORY)==BST_CHECKED)?true:false;
				
				if (!pdata->sameForest && pdata->IsSidHistoryChecked)
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
					return TRUE;
				}
				else
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_END_GROUPMAPPING);
					return TRUE;
				}				
				break;
			case PSN_WIZBACK :
					
	break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(GROUP_OPTION_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(GROUP_OPTION_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK IntGroupOptionsProc (
								   HWND hwndDlg,
								   UINT uMsg,
								   WPARAM wParam,
								   LPARAM lParam
								   )
{
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			
			initnoncollisionrename(hwndDlg);

			initcheckbox( hwndDlg,IDC_COPY_GROUP_MEMBERS,DCTVS_AccountOptions_CopyContainerContents);
			initcheckbox( hwndDlg,IDC_COPY_USER_RIGHTS,DCTVS_AccountOptions_UpdateUserRights);
			initcheckbox( hwndDlg,IDC_ADD_SID_HISTORY,DCTVS_AccountOptions_AddSidHistory);
			initcheckbox( hwndDlg,IDC_REMIGRATE_OBJECTS,DCTVS_AccountOptions_IncludeMigratedAccts);
			initcheckbox( hwndDlg,IDC_FIX_MEMBERSHIP,DCTVS_AccountOptions_FixMembership);
			if (IsDlgButtonChecked(hwndDlg,IDC_COPY_GROUP_MEMBERS))
			{
				pdata->memberSwitch=true;
				enable(hwndDlg,IDC_REMIGRATE_OBJECTS);
			}
			else
			{
				disable(hwndDlg,IDC_REMIGRATE_OBJECTS);
			}
			if (pdata->sameForest)
			{
				CheckDlgButton(hwndDlg,IDC_ADD_SID_HISTORY,true);
				disable(hwndDlg,IDC_ADD_SID_HISTORY);
				CheckDlgButton(hwndDlg,IDC_FIX_MEMBERSHIP,true);
				disable(hwndDlg,IDC_FIX_MEMBERSHIP);
			}
			if (migration==w_group && pdata->sameForest)
			{
				CheckDlgButton(hwndDlg,IDC_REMIGRATE_OBJECTS,false);
				disable(hwndDlg,IDC_REMIGRATE_OBJECTS);
			}
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_COPY_GROUP_MEMBERS:
				{
					pdata->memberSwitch=(!pdata->memberSwitch);
		            if (migration!=w_group)
			           pdata->memberSwitch ? enable(hwndDlg,IDC_REMIGRATE_OBJECTS):disable(hwndDlg,IDC_REMIGRATE_OBJECTS);
                    else if (migration==w_group && !pdata->sameForest)
			           pdata->memberSwitch ? enable(hwndDlg,IDC_REMIGRATE_OBJECTS):disable(hwndDlg,IDC_REMIGRATE_OBJECTS);
					bChangedMigrationTypes=true;
					break;
				}
			case IDC_RADIO_NONE :
				{
					disable(hwndDlg,IDC_PRE);
					disable(hwndDlg,IDC_SUF);
					break;
				}	
			case IDC_RADIO_PRE :
				{
					enable(hwndDlg,IDC_PRE);
					disable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_NONE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_SUF,false);
				    SetFocus(GetDlgItem(hwndDlg, IDC_PRE));
					SendDlgItemMessage(hwndDlg, IDC_PRE, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
					break;
				}	
			case IDC_RADIO_SUF :
				{
					disable(hwndDlg,IDC_PRE);
					enable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_NONE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_PRE,false);
				    SetFocus(GetDlgItem(hwndDlg, IDC_SUF));
					SendDlgItemMessage(hwndDlg, IDC_SUF, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
					break;
				}	
			default :
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				checkbox( hwndDlg,IDC_COPY_GROUP_MEMBERS,DCTVS_AccountOptions_CopyContainerContents);
				checkbox( hwndDlg,IDC_COPY_GROUP_MEMBERS,DCTVS_AccountOptions_CopyUsers);
				checkbox( hwndDlg,IDC_COPY_USER_RIGHTS,DCTVS_AccountOptions_UpdateUserRights);
				checkbox( hwndDlg,IDC_FIX_MEMBERSHIP,DCTVS_AccountOptions_FixMembership);
				
				if (IsDlgButtonChecked(hwndDlg,IDC_COPY_GROUP_MEMBERS) && pdata->sameForest)
				{
					CString yo;
					yo.LoadString(IDS_GRATUITIOUS_MESSAGE2);
					CString warning;
					warning.LoadString(IDS_MSG_WARNING);
					MessageBox(hwndDlg,yo,warning,MB_OK| MB_ICONINFORMATION);
				} 	

				
				if (IsDlgButtonChecked(hwndDlg,IDC_ADD_SID_HISTORY) && !pdata->sameForest)
				{	
                    HRESULT hr = doSidHistory(hwndDlg);

                    if (SUCCEEDED(hr))
                    {
                        pVarSet->put(GET_BSTR(DCTVS_Options_TargetServerOverride), GetTargetDcNameFlat());
                        pVarSet->put(GET_BSTR(DCTVS_Options_TargetServerOverrideDns), GetTargetDcNameDns());
                    }
                    else
                    {
                        if (hr != E_ABORT)
                        {
                            ErrorWrapper(hwndDlg, hr);
                        }

                        CheckDlgButton(hwndDlg, IDC_ADD_SID_HISTORY, false);
                    }
				}
				
				checkbox( hwndDlg,IDC_ADD_SID_HISTORY,DCTVS_AccountOptions_AddSidHistory);
				pdata->IsSidHistoryChecked =(IsDlgButtonChecked( hwndDlg,IDC_ADD_SID_HISTORY)==BST_CHECKED)?true:false;
				if (IsDlgButtonChecked(hwndDlg,IDC_COPY_GROUP_MEMBERS))
				{
					checkbox( hwndDlg,IDC_REMIGRATE_OBJECTS,DCTVS_AccountOptions_IncludeMigratedAccts);
					pdata->migratingGroupMembers=true;				
				}
				else
				{
					pdata->migratingGroupMembers=false;				
				}
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				
				if ( !noncollisionrename(hwndDlg))
				{
					int nID = IDC_PRE;
					MessageBoxWrapperFormat1(hwndDlg,IDS_MSG_INVALIDCHARS,IDS_INVALID_STRING,IDS_MSG_INPUT);
					   //set focus on invalid string
	                if (IsDlgButtonChecked(hwndDlg,IDC_RADIO_SUF))
					   nID = IDC_SUF;
					SetFocus(GetDlgItem(hwndDlg, nID));
					SendDlgItemMessage(hwndDlg, nID, EM_SETSEL, 
									  (WPARAM)0, (LPARAM)-1); 
				    SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
					return TRUE;
				}
				
				if (pdata->sourceIsNT4 || pdata->sameForest)
				{
					if (!pdata->sameForest && pdata->IsSidHistoryChecked)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
						return TRUE;
					}
					else
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_RENAMING);
						return TRUE;
					}				
				}
				break;
			case PSN_WIZBACK :
	

				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{					
					SharedHelp(GROUP_OPTION_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(GROUP_OPTION_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}
INT_PTR CALLBACK IntExchangeSelectionProc (
								   HWND hwndDlg,
								   UINT uMsg,
								   WPARAM wParam,
								   LPARAM lParam
								   )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initeditbox( hwndDlg,IDC_EXCHANGE_SERVER,DCTVS_Security_TranslateContainers);
			break;
		}
				
	case WM_COMMAND:
		{
			switch(HIWORD(wParam))
			{
			case EN_CHANGE :
				{
					enableNextIfNecessary(hwndDlg,IDC_EXCHANGE_SERVER);
					break;
				}
			default: 
				break;
			}
			break;
		}

	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :

				IsDlgItemEmpty(hwndDlg,IDC_EXCHANGE_SERVER) ?
					PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK):
				PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				{
					CWaitCursor ex;
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					CString so;GetDlgItemText(hwndDlg,IDC_EXCHANGE_SERVER,so.GetBuffer(1000),1000);so.ReleaseBuffer();
					SERVER_INFO_100         * servInfo = NULL;
					so.TrimLeft();so.TrimRight();
					if (NetServerGetInfo(so.GetBuffer(1000),100,(LPBYTE *)&servInfo)!=NERR_Success)
					{
						so.ReleaseBuffer();
						MessageBoxWrapper(hwndDlg,IDS_MSG_INVALIDEXCHANGE,IDS_MSG_ERROR);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_EXCHANGE_SELECTION);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_EXCHANGE_SELECTION);
						if ( servInfo )
						{
							NetApiBufferFree(servInfo);
						}
						return TRUE;
					}
					else
					so.ReleaseBuffer();
					if ( servInfo )
					{
						NetApiBufferFree(servInfo);
					}					
					editbox( hwndDlg,IDC_EXCHANGE_SERVER,DCTVS_Security_TranslateContainers);
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(EXCHANGE_SERVER_SELECTION, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(EXCHANGE_SERVER_SELECTION, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK IntCommitProc (
								   HWND hwndDlg,
								   UINT uMsg,
								   WPARAM wParam,
								   LPARAM lParam
								   )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			CheckRadioButton(hwndDlg,IDC_CHANGEIT,IDC_DONTCHANGE,IDC_DONTCHANGE);
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :					

				PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				checkbox( hwndDlg,IDC_DONTCHANGE,DCTVS_Options_NoChange);
				break;
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(COMMIT_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(COMMIT_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK IntOuSelectionProc (
								  HWND hwndDlg,
								  UINT uMsg,
								  WPARAM wParam,
								  LPARAM lParam
								  )
{
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			break; 
		}
		
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
				
			case IDC_BROWSE :
				{
                   HMODULE           hMod = NULL;
                   hMod = LoadLibrary(L"dsuiext.dll");
                   if ( hMod )
				   {
                      WCHAR               sDomPath[320];
                      wsprintf(sDomPath, L"LDAP://%s", GetTargetDomainNameDns());
                      DsBrowseForContainerX = (DSBROWSEFORCONTAINER)GetProcAddress(hMod, "DsBrowseForContainerW");
                      WCHAR             * sContPath, * sContName;
                      if (DsBrowseForContainerX && !BrowseForContainer(hwndDlg, sDomPath, &sContPath, &sContName) )
					  {
                         SetDlgItemText(hwndDlg, IDC_TARGET_OU, sContPath);
                         CoTaskMemFree(sContPath);
                         CoTaskMemFree(sContName);
					  }
			          FreeLibrary(hMod);
				   }
				   break;
				}
			default:
				break;
			}
			switch(HIWORD(wParam))
			{
			case EN_CHANGE :
				{
					enableNextIfNecessary(hwndDlg,IDC_TARGET_OU);
					break;
				}
			default: 
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				pdata->resetOUPATH ? SetDlgItemText( hwndDlg,IDC_TARGET_OU,L""): initeditbox( hwndDlg,IDC_TARGET_OU,DCTVS_Options_OuPath);
				pdata->resetOUPATH =false;
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
				
				enableNextIfNecessary(hwndDlg,IDC_TARGET_OU);
				break;
			case PSN_WIZNEXT :
				{CWaitCursor ex;
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
 
					   //since group, user, and computer migrations only bring up this dialog, we will
					   //use this occasion to clear the exclude properties flag if the source
					   //domain is NT 4.0
					if (pdata->sourceIsNT4)
					   put(DCTVS_AccountOptions_ExcludeProps, no);

					CString c,d,toenter;
					GetDlgItemText(hwndDlg,IDC_TARGET_OU,c.GetBuffer(1000),1000);
					c.ReleaseBuffer();
					d=c.Left(7);d.TrimLeft();d.TrimRight();
					if (!d.CompareNoCase(L"LDAP://"))
					{
						toenter=c;
					}
					else
					{
						toenter.Format(L"LDAP://%s/%s",GetTargetDomainNameDns(),c);
                        SetDlgItemText(hwndDlg, IDC_TARGET_OU, (LPCTSTR)toenter);
					}
                    IADsObjectOptions *pOps;
                    BOOL bFromTargetDomain = FALSE;
                    HRESULT hr = ADsGetObject(
                                    toenter,
                                    IID_IADsObjectOptions,
                                    (void**)&pOps);
                    if (SUCCEEDED(hr))
                    {
                        VARIANT var;
                        VariantInit(&var);
                        hr = pOps->GetOption(ADS_OPTION_SERVERNAME, &var);

                        if (SUCCEEDED(hr))
                        {
                            _bstr_t serverName = V_BSTR(&var);
                            
                            // make sure that the server name is from target domain
                            DOMAIN_CONTROLLER_INFO *pDomCtrlInfo = NULL;
                            GUID zeroGuid = { 0 };

                            DWORD rc = DsGetDcName(
                                            (WCHAR*)serverName,
                                            NULL,
                                            NULL,
                                            NULL,
                                            DS_DIRECTORY_SERVICE_PREFERRED,
                                            &pDomCtrlInfo);
                            if (rc == NO_ERROR 
                                && pDomCtrlInfo->DomainGuid != zeroGuid)
                            {
                                DOMAIN_CONTROLLER_INFO *pTargetDomCtrlInfo = NULL;
                                rc = DsGetDcName(
                                        NULL,
                                        GetTargetDomainName(),
                                        NULL,
                                        NULL,
                                        DS_DIRECTORY_SERVICE_PREFERRED,
                                        &pTargetDomCtrlInfo);
                                if (rc == NO_ERROR
                                    && pTargetDomCtrlInfo->DomainGuid != zeroGuid)
                                {
                                    if (pDomCtrlInfo->DomainGuid == pTargetDomCtrlInfo->DomainGuid)
                                        bFromTargetDomain = TRUE;
                                }

                                if (pTargetDomCtrlInfo != NULL)
                                    NetApiBufferFree(pTargetDomCtrlInfo);
                            }

                            if (pDomCtrlInfo != NULL)
                                NetApiBufferFree(pDomCtrlInfo);
                        }

                        VariantClear(&var);
                        pOps->Release();
                    }
                            
                    if (!bFromTargetDomain)
					{ 
						  //if buffer was big enough, say invalid OU
						long len = toenter.GetLength();
						if (len < 999)
						{
						   MessageBoxWrapper(hwndDlg,IDS_MSG_INVALIDOU,IDS_MSG_ERROR);
						   SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OU_SELECTION);
						   pdata->resetOUPATH =true;
					       SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					       return TRUE;
						}
						else //else if buffer too small, tell user OU path too long
						{
						   MessageBoxWrapper(hwndDlg,IDS_OU_TOO_LONG,IDS_MSG_ERROR);
						   SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OU_SELECTION);
						   pdata->resetOUPATH =true;
					       SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					       return TRUE;
						}
					}
				
					editbox( hwndDlg,IDC_TARGET_OU,DCTVS_Options_OuPath);
					if (pdata->sameForest&& migration==w_account)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OPTIONS);
						return TRUE;
					}
					break;
				}
			case PSN_WIZBACK :
				editbox( hwndDlg,IDC_TARGET_OU,DCTVS_Options_OuPath);
				
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(OU_SELECTION_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(OU_SELECTION_HELP, hwndDlg);
			break;
		}		
		
	default:
		break;
	}
	return 0;				
}

		
INT_PTR CALLBACK IntCredentialsProc (
								  HWND hwndDlg,
								  UINT uMsg,
								  WPARAM wParam,
								  LPARAM lParam
								  )
{
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initeditbox( hwndDlg,IDC_CREDENTIALS_DOMAIN,DCTVS_AccountOptions_SidHistoryCredentials_Domain);
			
			if (!clearCredentialsName)			initeditbox( hwndDlg, IDC_CREDENTIALS_USERNAME,DCTVS_AccountOptions_SidHistoryCredentials_UserName );
            initeditboxPassword(hwndDlg, IDC_CREDENTIALS_PASSWORD, DCTVS_AccountOptions_SidHistoryCredentials_Password);
			enable(hwndDlg,IDC_CREDENTIALS_DOMAIN);
			enable(hwndDlg,IDC_CREDENTIALS_USERNAME);
			enable(hwndDlg,IDC_CREDENTIALS_PASSWORD);
			SetDlgItemText(hwndDlg,IDC_CREDENTIALS_DOMAIN,GetSourceDomainNameFlat());
			if (pdata->sameForest)
			{
				SetDlgItemText(hwndDlg,IDC_MYTITLE,GET_CSTRING(IDS_MYTITLE2));
			SetDlgItemText(hwndDlg,IDC_CREDENTIALS_DOMAIN,GetTargetDomainNameFlat());
			}
			if (migration==w_exchangeDir)
				SetDlgItemText(hwndDlg,IDC_MYTITLE,GET_CSTRING(IDS_MYTITLE3));
			break;
		}
	case WM_COMMAND:
		{
			switch(HIWORD(wParam))
			{
			case EN_CHANGE :
				{
					if (enableNextIfNecessary(hwndDlg,IDC_CREDENTIALS_DOMAIN))
						enableNextIfNecessary(hwndDlg,IDC_CREDENTIALS_USERNAME);
					break;
				}
			case EN_KILLFOCUS:	
				{
					if (GetDlgItem(hwndDlg,IDC_CREDENTIALS_USERNAME) == (HWND)lParam)
					{
						CString aUPNName, aUser=L"", aDomain=L"";
						int index;
						GetDlgItemText(hwndDlg,IDC_CREDENTIALS_USERNAME,aUPNName.GetBuffer(1000),1000);
						aUPNName.ReleaseBuffer();
							//if possibly listed in UPN format, extract username and domain from that UPN
							//and convert to DNS domain name to its netbios name
						if ((index = aUPNName.Find(L'@')) != -1)
						{
							if (GetDomainAndUserFromUPN(&*aUPNName, aDomain, aUser))
							{
								SetDlgItemText(hwndDlg,IDC_CREDENTIALS_DOMAIN,aDomain);
								SetDlgItemText(hwndDlg,IDC_CREDENTIALS_USERNAME,aUser);
							}
						}
					}
					break;
				}
			default: 
				break;
			}
			break;
		}
		
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				if (enableNextIfNecessary(hwndDlg,IDC_CREDENTIALS_DOMAIN))
					enableNextIfNecessary(hwndDlg,IDC_CREDENTIALS_USERNAME);
				break;
			case PSN_WIZNEXT :
				{
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);					
					CString dom,user,pass;
					GetDlgItemText(hwndDlg,IDC_CREDENTIALS_DOMAIN,dom.GetBuffer(1000),1000);
					GetDlgItemText(hwndDlg,IDC_CREDENTIALS_USERNAME,user.GetBuffer(1000),1000);
					GetDlgItemText(hwndDlg,IDC_CREDENTIALS_PASSWORD,pass.GetBuffer(1000),1000);
					dom.ReleaseBuffer(); user.ReleaseBuffer(); pass.ReleaseBuffer();
					
					DWORD returncode = ERROR_SUCCESS;
					// for exchange migration, we don't need to call VerifyPassword
					// instead, we call VerifyExchangeServerCredential
                    if (migration != w_exchangeDir)
					    returncode = VerifyPassword(user, pass, dom);
                    else
                    {
                        returncode = VerifyExchangeServerCredential(hwndDlg, user, pass, dom);
                    }

                    SecureZeroMemory(pass.GetBuffer(pass.GetLength()), pass.GetLength() * sizeof(_TCHAR));

					if (returncode == ERROR_SUCCESS)
					{
						editbox( hwndDlg,IDC_CREDENTIALS_DOMAIN,DCTVS_AccountOptions_SidHistoryCredentials_Domain);
						editbox( hwndDlg, IDC_CREDENTIALS_USERNAME,DCTVS_AccountOptions_SidHistoryCredentials_UserName );
                        editboxPassword(hwndDlg, IDC_CREDENTIALS_PASSWORD, DCTVS_AccountOptions_SidHistoryCredentials_Password);
					}
					else
					{
					    if (migration == w_exchangeDir)
					    {
					        // The VerifyExchangeServerCredential function displays a message box if an error occurs.
					    }
                        else if (returncode == ERROR_ACCESS_DENIED)
                        {
                            MessageBoxWrapper(hwndDlg, IDS_MSG_INVALID_SID_HISTORY_CREDENTIALS, IDS_MSG_ERROR);
                        }
                        else if (returncode == ERROR_INVALID_HANDLE)
                        {
                            MessageBoxWrapper(hwndDlg, IDS_MSG_INVALID_HANDLE, IDS_MSG_ERROR);
                        }
                        else
                        {
						    ErrorWrapper(hwndDlg,returncode);
                        }

						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);

						return TRUE;
					}

					if (migration==w_undo)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_UNDO);
						return TRUE;
					}
					break;
				}
			case PSN_WIZBACK :
				{
					if (pdata->sameForest && migration==w_account)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OU_SELECTION);
						return TRUE;
					}
					else if (migration==w_account)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DISABLE);
						return TRUE;
					}
					else if ((pdata->sourceIsNT4 || pdata->sameForest) && migration==w_group)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_OPTIONS_GROUP);
						return TRUE;
					}				
					break;
				}
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(CREDENTIALS_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(CREDENTIALS_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}



INT_PTR CALLBACK IntRenameProc (
							 HWND hwndDlg,
							 UINT uMsg,
							 WPARAM wParam,
							 LPARAM lParam
							 )
{
		//find out if copy user's groups are being copied. If not then disable the
		//replace existing group member checkbox
	bool bCopyGroups = true;
	_bstr_t strCopyGroups = get(DCTVS_AccountOptions_CopyMemberOf);
	if (((!UStrCmp(strCopyGroups,(WCHAR const *) yes)) && (migration==w_account)) || 
		(migration==w_group))
		bCopyGroups = true;
	else
		bCopyGroups = false;

	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
    		handleInitRename(hwndDlg, pdata->sameForest, bCopyGroups);
			if (migration==w_computer)
			{
				CString yo;
				yo.LoadString(IDS_COMPUTER_RENAME_TITLE);
				SetDlgItemText(hwndDlg,IDC_THERENAMINGTITLE,yo);
			}
			if (IsDlgButtonChecked(hwndDlg, IDC_SKIP_CONFLICTING_ACCOUNTS))
			{
				pdata->renameSwitch=1;
				disable(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS);
				disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
				disable(hwndDlg,IDC_REMOVE_EXISTING_LOCATION);
				disable(hwndDlg,IDC_PREFIX);
				disable(hwndDlg,IDC_SUFFIX);
				disable(hwndDlg,IDC_RADIO_PREFIX);
				disable(hwndDlg,IDC_RADIO_SUFFIX);
			}
			else if (IsDlgButtonChecked(hwndDlg, IDC_REPLACE_CONFLICTING_ACCOUNTS))
			{
				pdata->renameSwitch=2;
				enable(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS);
				enable(hwndDlg,IDC_REMOVE_EXISTING_LOCATION);
				if ((migration!=w_computer) && (bCopyGroups)) 
					enable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
				else
				{
					disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
					CheckDlgButton( hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,false);
				}

				disable(hwndDlg,IDC_PREFIX);
				disable(hwndDlg,IDC_SUFFIX);
				disable(hwndDlg,IDC_RADIO_PREFIX);
				disable(hwndDlg,IDC_RADIO_SUFFIX);
			}
			else 
			{
				CheckDlgButton( hwndDlg,IDC_RENAME_CONFLICTING_ACCOUNTS,true);
				pdata->renameSwitch=3;
				disable(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS);
				disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
				disable(hwndDlg,IDC_REMOVE_EXISTING_LOCATION);
				enable(hwndDlg,IDC_RADIO_PREFIX);
				enable(hwndDlg,IDC_RADIO_SUFFIX);
				
				_bstr_t text2 = get(DCTVS_AccountOptions_Prefix);
				_bstr_t text3 = get(DCTVS_AccountOptions_Suffix);
				
				if (UStrICmp(text3,L""))
				{
					disable(hwndDlg,IDC_PREFIX);
					enable(hwndDlg,IDC_SUFFIX);				
					CheckRadioButton(hwndDlg,IDC_RADIO_PREFIX,IDC_RADIO_SUFFIX,IDC_RADIO_SUFFIX);
				}
				else 
				{
					enable(hwndDlg,IDC_PREFIX);
					disable(hwndDlg,IDC_SUFFIX);				
					CheckRadioButton(hwndDlg,IDC_RADIO_PREFIX,IDC_RADIO_SUFFIX,IDC_RADIO_PREFIX);
				}				 	
			}
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_SKIP_CONFLICTING_ACCOUNTS :
				pdata->renameSwitch=1;
				disable(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS);
				disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
				disable(hwndDlg,IDC_REMOVE_EXISTING_LOCATION);
				disable(hwndDlg,IDC_PREFIX);
				disable(hwndDlg,IDC_SUFFIX);
				disable(hwndDlg,IDC_RADIO_PREFIX);
				disable(hwndDlg,IDC_RADIO_SUFFIX);
				break;
			case IDC_REPLACE_CONFLICTING_ACCOUNTS :		
				pdata->renameSwitch=2;
				enable(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS);
				enable(hwndDlg,IDC_REMOVE_EXISTING_LOCATION);
				if ((migration!=w_computer) && (bCopyGroups))
					enable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
				else
				{
					disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
					CheckDlgButton( hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,false);
				}
				disable(hwndDlg,IDC_PREFIX);
				disable(hwndDlg,IDC_SUFFIX);
				disable(hwndDlg,IDC_RADIO_PREFIX);
				disable(hwndDlg,IDC_RADIO_SUFFIX);
				break;
			case IDC_RENAME_CONFLICTING_ACCOUNTS :
				pdata->renameSwitch=3;
				disable(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS);
				disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
				disable(hwndDlg,IDC_REMOVE_EXISTING_LOCATION);
				enable(hwndDlg,IDC_RADIO_PREFIX);
				enable(hwndDlg,IDC_RADIO_SUFFIX);
				if (IsDlgButtonChecked(hwndDlg,IDC_RADIO_SUFFIX))
				{
				   enable(hwndDlg,IDC_SUFFIX);
				   CheckRadioButton(hwndDlg,IDC_RADIO_PREFIX,IDC_RADIO_SUFFIX,IDC_RADIO_SUFFIX);
				}
				else
				{
				   enable(hwndDlg,IDC_PREFIX);
				   CheckRadioButton(hwndDlg,IDC_RADIO_PREFIX,IDC_RADIO_SUFFIX,IDC_RADIO_PREFIX);
				}
				break;
			case IDC_RADIO_SUFFIX :
				enable(hwndDlg,IDC_SUFFIX);
				disable(hwndDlg,IDC_PREFIX);
				CheckDlgButton(hwndDlg,IDC_RADIO_PREFIX,false);
				SetFocus(GetDlgItem(hwndDlg, IDC_SUFFIX));
				SendDlgItemMessage(hwndDlg, IDC_SUFFIX, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
				break;
			case IDC_RADIO_PREFIX :
				enable(hwndDlg,IDC_PREFIX);
				disable(hwndDlg,IDC_SUFFIX);
				CheckDlgButton(hwndDlg,IDC_RADIO_SUFFIX,false);
				SetFocus(GetDlgItem(hwndDlg, IDC_PREFIX));
				SendDlgItemMessage(hwndDlg, IDC_PREFIX, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
				break;
			default:
				break;
			}
			break;
		}
		
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				if (IsDlgButtonChecked(hwndDlg, IDC_REPLACE_CONFLICTING_ACCOUNTS))
				{
					if ((migration==w_computer) || (!bCopyGroups))
					{
						disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
						CheckDlgButton( hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,false);
					}
					else
					{
						enable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
						initcheckbox(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,DCTVS_AccountOptions_ReplaceExistingGroupMembers);
					}
				}
				break;
			case PSN_WIZNEXT :
				{
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);					
					if (IsDlgButtonChecked (hwndDlg,IDC_SKIP_CONFLICTING_ACCOUNTS))
					{
						put(DCTVS_AccountOptions_Prefix,L"");
						put(DCTVS_AccountOptions_Suffix,L"");
						put(DCTVS_AccountOptions_ReplaceExistingAccounts,L"");
						put(DCTVS_AccountOptions_RemoveExistingUserRights,L"");
						put(DCTVS_AccountOptions_ReplaceExistingGroupMembers,L"");
						put(DCTVS_AccountOptions_MoveReplacedAccounts,L"");
					}
					else if (IsDlgButtonChecked (hwndDlg,IDC_REPLACE_CONFLICTING_ACCOUNTS))
					{
						put(DCTVS_AccountOptions_Prefix,L"");
						put(DCTVS_AccountOptions_Suffix,L"");
						put(DCTVS_AccountOptions_ReplaceExistingAccounts,yes);
						checkbox( hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS,DCTVS_AccountOptions_RemoveExistingUserRights);
						checkbox( hwndDlg,IDC_REMOVE_EXISTING_LOCATION,DCTVS_AccountOptions_MoveReplacedAccounts);
						if (IsDlgButtonChecked(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS) && (migration==w_account))						
						{
							if (!bCopyGroups)
							{
								CheckDlgButton( hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,false);
							}
						}
						if (migration!=w_computer)
						    checkbox( hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,DCTVS_AccountOptions_ReplaceExistingGroupMembers);

					}
					else if (IsDlgButtonChecked (hwndDlg,IDC_RENAME_CONFLICTING_ACCOUNTS) && 
						IsDlgButtonChecked (hwndDlg,IDC_RADIO_PREFIX))
					{
						if (!validString(hwndDlg,IDC_PREFIX))
						{
							MessageBoxWrapperFormat1(hwndDlg,IDS_MSG_INVALIDCHARS,IDS_INVALID_STRING,IDS_MSG_INPUT);
					        SetFocus(GetDlgItem(hwndDlg, IDC_PREFIX));
					        SendDlgItemMessage(hwndDlg, IDC_PREFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
					        return TRUE;
						}
						else if (IsDlgItemEmpty(hwndDlg,IDC_PREFIX))
						{
							MessageBoxWrapper(hwndDlg,IDS_MSG_BLANK,IDS_MSG_INPUT);
					        SetFocus(GetDlgItem(hwndDlg, IDC_PREFIX));
					        SendDlgItemMessage(hwndDlg, IDC_PREFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
							return TRUE;
						}
						else if (tooManyChars(hwndDlg,IDC_PREFIX))
						{
							MessageBoxWrapper(hwndDlg,IDS_MSG_EXTENSION_MAX_PRE,IDS_MSG_INPUT);
					        SetFocus(GetDlgItem(hwndDlg, IDC_PREFIX));
					        SendDlgItemMessage(hwndDlg, IDC_PREFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
							return TRUE;
						}
						else
						{
							editbox( hwndDlg, IDC_PREFIX,DCTVS_AccountOptions_Prefix );
							put(DCTVS_AccountOptions_Suffix,L"");
							put(DCTVS_AccountOptions_ReplaceExistingAccounts,L"");					
							put(DCTVS_AccountOptions_RemoveExistingUserRights,L"");
							put(DCTVS_AccountOptions_ReplaceExistingGroupMembers,L"");
						    put(DCTVS_AccountOptions_MoveReplacedAccounts,L"");
						}
					
					
					}
					else if (IsDlgButtonChecked (hwndDlg,IDC_RENAME_CONFLICTING_ACCOUNTS) && 
						IsDlgButtonChecked (hwndDlg,IDC_RADIO_SUFFIX))
					{
						if (!validString(hwndDlg,IDC_SUFFIX))
						{
							MessageBoxWrapperFormat1(hwndDlg,IDS_MSG_INVALIDCHARS,IDS_INVALID_STRING,IDS_MSG_INPUT);
					        SetFocus(GetDlgItem(hwndDlg, IDC_SUFFIX));
					        SendDlgItemMessage(hwndDlg, IDC_SUFFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
							return TRUE;
						}					
						else if (IsDlgItemEmpty(hwndDlg,IDC_SUFFIX))
						{
							MessageBoxWrapper(hwndDlg,IDS_MSG_BLANK,IDS_MSG_INPUT);
					        SetFocus(GetDlgItem(hwndDlg, IDC_SUFFIX));
					        SendDlgItemMessage(hwndDlg, IDC_SUFFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
							return TRUE;
						}
						else if (tooManyChars(hwndDlg,IDC_SUFFIX))
						{
							MessageBoxWrapper(hwndDlg,IDS_MSG_EXTENSION_MAX_SUF,IDS_MSG_INPUT);
					        SetFocus(GetDlgItem(hwndDlg, IDC_SUFFIX));
					        SendDlgItemMessage(hwndDlg, IDC_SUFFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
							return TRUE;
						}

						else
						{
							editbox( hwndDlg, IDC_SUFFIX,DCTVS_AccountOptions_Suffix );
							put(DCTVS_AccountOptions_Prefix,L"");
							put(DCTVS_AccountOptions_ReplaceExistingAccounts,L"");					
							put(DCTVS_AccountOptions_RemoveExistingUserRights,L"");
							put(DCTVS_AccountOptions_ReplaceExistingGroupMembers,L"");
						    put(DCTVS_AccountOptions_MoveReplacedAccounts,L"");
						}
					}	


					if (migration==w_account)
					{
						if (someServiceAccounts(pdata->accounts,hwndDlg))
						{
							pdata->someService=true;
							SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_INFO);
							return TRUE;
						}
						else
						{
							pdata->someService=false;
							SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_ACCOUNT);
							return TRUE;
						}
					}
					else if (migration==w_group)
					{
						if (pdata->migratingGroupMembers && !pdata->sameForest)
						{
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_PASSWORD);
							return TRUE;
						}
						else
						{
							pdata->someService=false;
							SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_GROUP);
							return TRUE;
						}
					}


					break;
				}
			case PSN_WIZBACK :
				{
					if (!pdata->sameForest && pdata->IsSidHistoryChecked && migration==w_group)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
						return TRUE;
					}
					if (!pdata->sourceIsNT4 && !pdata->sameForest && migration==w_account)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_PROP_EXCLUSION);
						return TRUE;
					}
					else if (migration==w_account)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OPTIONS);
						return TRUE;
					}
					else if (migration==w_computer && pdata->sourceIsNT4)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_REBOOT);
						return TRUE;
					}
					else if (pdata->sourceIsNT4 || pdata->sameForest && migration==w_group)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OPTIONS_GROUP);
						return TRUE;
					}
					else if (migration==w_group)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_PROP_EXCLUSION);
						return TRUE;
					}

					break;		
				}
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(NAME_CONFLICT_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(NAME_CONFLICT_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK IntSelectionSecurityProc (
								HWND hwndDlg,
								UINT uMsg,
								WPARAM wParam,
								LPARAM lParam
								)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
			HWND hLC= GetDlgItem(hwndDlg,IDC_LIST_MEMBERS1);
			m_listBox.Attach(hLC);
			setupColumns(pdata->sourceIsNT4);
			m_listBox.DeleteAllItems();
			disable(hwndDlg,IDC_REMOVE_BUTTON);
			PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
			HWND hLC4= GetDlgItem(hwndDlg,IDC_ADDITIONAL_TRUSTING_DOMAIN);
			additionalDrop.Attach(hLC4);
			if ((migration==w_security) && (pdata->secWithMapFile))
			{
               IADsADSystemInfoPtr spSystemInfo(__uuidof(ADSystemInfo));

               BSTR bstr;

               HRESULT hr = spSystemInfo->get_DomainDNSName(&bstr);

               if (SUCCEEDED(hr))
               {
                   targetDNS = (LPCTSTR)_bstr_t(bstr, false);
               }
               else
               {
                   targetDNS.Empty();
               }

               hr = spSystemInfo->get_DomainShortName(&bstr);

               if (SUCCEEDED(hr))
               {
                   targetNetbios = (LPCTSTR)_bstr_t(bstr, false);
               }
               else
               {
                   targetNetbios.Empty();
               }
			}
			else if ((migration==w_security) && (!pdata->secWithMapFile))
                        lastInitializedTo=GetTargetDomainName();
			else
                        lastInitializedTo=GetSourceDomainName();
			populateTrustingList(GetTargetDomainName(), additionalDrop);
			break;
		}
	case WM_HELP :
		{
							
			SharedHelp(COMPUTER_SELECTION_HELP, hwndDlg);
			break;
		}		

	case WM_COMMAND :
		{
			switch(LOWORD (wParam))
			{
			case IDC_ADD_BUTTON :
				{CWaitCursor w;
					HRESULT hr=S_OK;
					CString tempTrustingDomain;
					GetDlgItemText(hwndDlg,IDC_ADDITIONAL_TRUSTING_DOMAIN,tempTrustingDomain.GetBuffer(1000),1000);
					tempTrustingDomain.ReleaseBuffer();
					tempTrustingDomain.TrimLeft();tempTrustingDomain.TrimRight();
					
					if (tempTrustingDomain.IsEmpty() && (lastInitializedTo.CompareNoCase(GetSourceDomainName())) && (migration!=w_security))
					{			
						_bstr_t strDc;
						DWORD res = GetAnyDcName5(GetSourceDomainName(), strDc); 
						if (res==NO_ERROR)								
						{
						lastInitializedTo=GetSourceDomainName();

							hr =InitObjectPicker2(pDsObjectPicker,true,(LPCTSTR)strDc,false);
						}else
							hr=E_UNEXPECTED;
					}
					else if (tempTrustingDomain.IsEmpty() && (migration==w_security))
					{			
						_bstr_t strDc;
						DWORD res = GetAnyDcName5(GetTargetDomainName(), strDc); 
						if (res==NO_ERROR)								
						{
						    lastInitializedTo=GetTargetDomainName();
							hr =InitObjectPicker2(pDsObjectPicker,true,(LPCTSTR)strDc,pdata->sourceIsNT4);
						}else
							hr=E_UNEXPECTED;
					}
					else if (lastInitializedTo.CompareNoCase(tempTrustingDomain) && !tempTrustingDomain.IsEmpty())
					{
						CString additionalDomainController;
						if (!verifyprivs2(hwndDlg,additionalDomainController,tempTrustingDomain))
						{
//							SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
							SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SELECTION4);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION4);
							return TRUE;
						}
                        lastInitializedTo=tempTrustingDomain;
						hr =ReInitializeObjectPicker(pDsObjectPicker,true,additionalDomainController,pdata->sourceIsNT4);
					}
				
					if (FAILED(hr)) 
					{
						MessageBoxWrapper(hwndDlg,IDS_MSG_OBJECTPICKER_SOURCE2,IDS_MSG_ERROR);		
						SetDlgItemText(hwndDlg,IDC_ADDITIONAL_TRUSTING_DOMAIN,L"");
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SELECTION4);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION4);
						return TRUE;
					}
					
//					if (migration==w_security)
//					   OnADD(hwndDlg,false);
//					else
					   OnADD(hwndDlg,pdata->sourceIsNT4);
					sort(m_listBox,0,pdata->sort[0]);
					enableNextIfObjectsSelected(hwndDlg);
					break;
				}
			case IDC_REMOVE_BUTTON :
				OnREMOVE(hwndDlg);
				enableNextIfObjectsSelected(hwndDlg);
				break;
			default :
				break;
			}		
					enableRemoveIfNecessary(hwndDlg);
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE : 
				{
					if (pdata->newSource)
					{
						m_listBox.DeleteAllItems();
						pdata->newSource=false;
//						SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					}
					if (m_listBox.GetItemCount()==0) 
						PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK);
					else
						PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
					break;	
				}
			case LVN_COLUMNCLICK:
				{
					LPNMLISTVIEW pnmv = (NM_LISTVIEW FAR *) lParam;
					pdata->sort[pnmv->iSubItem] = !pdata->sort[pnmv->iSubItem];
					sort(m_listBox,pnmv->iSubItem,pdata->sort[pnmv->iSubItem] );
//					SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
				break;
				}
			case NM_SETFOCUS :
			case NM_KILLFOCUS :
			case NM_CLICK:
				{
					enableRemoveIfNecessary(hwndDlg);
					break;
				}				
			case PSN_WIZNEXT :
				{CWaitCursor w;
					if (m_listBox.GetItemCount()==0)
				{
					MessageBoxWrapper(hwndDlg,IDS_MSG_OBJECT,IDS_MSG_INPUT);
					
//					SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SELECTION1);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION1);
					return TRUE;
				}
				OnMIGRATE(hwndDlg,pdata->accounts,pdata->servers);
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				break;
				}
			case PSN_WIZBACK :
				{
				   if (migration==w_security)
				   {
				      // clear the item selected previous in the "additional domain" combo box
				      SetDlgItemText(hwndDlg,IDC_ADDITIONAL_TRUSTING_DOMAIN, L"");
				      

					  _bstr_t text= get(DCTVS_AccountOptions_SecurityInputMOT);
					  if (UStrICmp(text ,(WCHAR const *) yes))
					  {
						 SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION_SRC);
						 return TRUE;
					  }
				   }
				   break;
				}
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{	
					SharedHelp(COMPUTER_SELECTION_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;
			default :
				break;
			}
			break;
		}
		
	default:
		break;
	}
	return 0;
}




INT_PTR CALLBACK IntSelectionProc (
								HWND hwndDlg,
								UINT uMsg,
								WPARAM wParam,
								LPARAM lParam
								)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
			HWND hLC= GetDlgItem(hwndDlg,IDC_LIST_MEMBERS1);
			m_listBox.Attach(hLC);
			setupColumns(pdata->sourceIsNT4);
			m_listBox.DeleteAllItems();
			disable(hwndDlg,IDC_REMOVE_BUTTON);
			PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
			break;
		}
	case WM_HELP :
		{
			int id=0;
			if (migration==w_computer || (migration==w_security || migration==w_reporting))
			{	
			    SharedHelp(COMPUTER_SELECTION_HELP, hwndDlg);
			}
			else if (migration==w_account)
			{	
			    SharedHelp(USER_SELECTION_HELP, hwndDlg);
			}
			else if (migration==w_group || migration==w_groupmapping)
			{
				SharedHelp(GROUP_SELECTION_HELP, hwndDlg);
			}
			else if (migration==w_service)
			{			    
			    SharedHelp(SERVICE_ACCOUNT_SELECTION, hwndDlg);
			}
			
			
			break;
		}		

	case WM_COMMAND :
		{
			switch(LOWORD (wParam))
			{
			case IDC_ADD_BUTTON :
				OnADD(hwndDlg,pdata->sourceIsNT4);
				//sort(m_listBox,0,pdata->sort[0]);
				enableNextIfObjectsSelected(hwndDlg);
				break;
			case IDC_REMOVE_BUTTON :
				OnREMOVE(hwndDlg);
				enableNextIfObjectsSelected(hwndDlg);
				break;
			default :
				break;
			}		
		    enableRemoveIfNecessary(hwndDlg);
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE : 
				{
					if (pdata->newSource)
					{
					    // might need to update the columns when the source is changed
					    setupColumns(pdata->sourceIsNT4);
					    
						m_listBox.DeleteAllItems();
						pdata->newSource=false;
//						SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					}PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
					if (m_listBox.GetItemCount()==0) 
						PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK);
					else
						PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
					break;	
				}
			case LVN_COLUMNCLICK:
				{
					LPNMLISTVIEW pnmv = (NM_LISTVIEW FAR *) lParam;
					pdata->sort[pnmv->iSubItem] = !pdata->sort[pnmv->iSubItem];
					//sort(m_listBox,pnmv->iSubItem,pdata->sort[pnmv->iSubItem] );
//					SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
				break;
				}
			case NM_SETFOCUS :
			case NM_KILLFOCUS :
			case NM_CLICK:
				{
					enableRemoveIfNecessary(hwndDlg);
					break;
				}				
			case PSN_WIZNEXT :
				{CWaitCursor w;

				if (m_listBox.GetItemCount()==0)
				{
					MessageBoxWrapper(hwndDlg,IDS_MSG_OBJECT,IDS_MSG_INPUT);
					
//					SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SELECTION1);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION1);
					return TRUE;
				}
				OnMIGRATE(hwndDlg,pdata->accounts,pdata->servers);
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				break;
				}
			case PSN_WIZBACK :
				break;
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{	
					int id=0;
			        if (migration==w_computer || (migration==w_security || migration==w_reporting))
         			{	
         			    SharedHelp(COMPUTER_SELECTION_HELP, hwndDlg);
			        }
        			else if (migration==w_account)
		        	{	
		        	    SharedHelp(USER_SELECTION_HELP, hwndDlg);
		        	}
        			else if (migration==w_group || migration==w_groupmapping)
        			{
		        		SharedHelp(GROUP_SELECTION_HELP, hwndDlg);
        			}
         			else if (migration==w_service)
		        	{
			            SharedHelp(SERVICE_ACCOUNT_SELECTION, hwndDlg);
		         	}
			
			  
			        break;
				}
			case PSN_RESET :
				break;
			default :
				break;
			}
			break;
		}
		
	default:
		break;
	}
	return 0;
}

INT_PTR CALLBACK
IntHTMLLocationProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initeditbox( hwndDlg,IDC_HTML_TARGET,DCTVS_Reports_Directory);
		if (IsDlgItemEmpty(hwndDlg,IDC_HTML_TARGET))
			{
				CString toinsert;
				GetDirectory(toinsert.GetBuffer(1000));
				toinsert.ReleaseBuffer();
				toinsert+="Reports";
				SetDlgItemText(hwndDlg,IDC_HTML_TARGET,toinsert);
			}

			//load the data from the database and display in the listbox.
			break;
		}

	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{			
			case IDC_BROWSE :
				OnBROWSE(hwndDlg,IDC_HTML_TARGET);
				break;
			default:
				break;
			}
			switch(HIWORD(wParam))
			{
			case EN_CHANGE :
				enableNextIfNecessary(hwndDlg,IDC_HTML_TARGET);
				break;
			default: 
				break;
			}
			break;
		}

	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
							IsDlgItemEmpty(hwndDlg,IDC_HTML_TARGET) ?
					PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK):
				PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					if (IsDlgItemEmpty(hwndDlg,IDC_HTML_TARGET))
					{
						MessageBoxWrapper(hwndDlg,IDS_MSG_DIRECTORY,IDS_MSG_INPUT);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_HTML_LOCATION);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_HTML_LOCATION);
						return TRUE;
					}
					else if (!validDirectoryString(hwndDlg,IDC_HTML_TARGET))
					{
						MessageBoxWrapper(hwndDlg,IDS_MSG_DIRECTORY,IDS_MSG_INPUT);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_HTML_LOCATION);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_HTML_LOCATION);
						return TRUE;
					}
					else
					{			
						editbox( hwndDlg,IDC_HTML_TARGET,DCTVS_Reports_Directory);
					}
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(DIRECTORY_SELECTION_HELP, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}
	case WM_HELP :
		{
			SharedHelp(DIRECTORY_SELECTION_HELP, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 3 OCT 2000                                                  *
 *                                                                   *
 *     This callback function is responsible for handling the windows*
 * messages for the new Translation Input dialog.                    *
 *                                                                   *
 *********************************************************************/

//BEGIN IntTranslationInputProc
INT_PTR CALLBACK
IntTranslationInputProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initsecinputbox(hwndDlg,IDC_TRANS_FROM_MOT,IDC_TRANS_FROM_FILE,DCTVS_AccountOptions_SecurityInputMOT);
			
		    if (IsDlgButtonChecked(hwndDlg,IDC_TRANS_FROM_MOT))
			{
			   disable(hwndDlg,IDC_BROWSE);
			   disable(hwndDlg,IDC_MAPPING_FILE);
			   disable(hwndDlg,IDC_SIDTEXT);
			}
			else
			{
			   enable(hwndDlg,IDC_BROWSE);
			   enable(hwndDlg,IDC_MAPPING_FILE);
			   enable(hwndDlg,IDC_SIDTEXT);
			   initeditbox( hwndDlg,IDC_MAPPING_FILE,DCTVS_AccountOptions_SecurityMapFile);
			}
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{			
			case IDC_BROWSE :
				OnMapFileBrowse(hwndDlg,IDC_MAPPING_FILE);
				break;
			case IDC_TRANS_FROM_MOT :
			    disable(hwndDlg,IDC_BROWSE);
			    disable(hwndDlg,IDC_MAPPING_FILE);
			    disable(hwndDlg,IDC_SIDTEXT);
			    break;
			case IDC_TRANS_FROM_FILE :
			    enable(hwndDlg,IDC_BROWSE);
			    enable(hwndDlg,IDC_MAPPING_FILE);
			    enable(hwndDlg,IDC_SIDTEXT);
			    initeditbox( hwndDlg,IDC_MAPPING_FILE,DCTVS_AccountOptions_SecurityMapFile);
			    break;
			default:
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				{
					  //set some data fields since we don't know source or target domains
				    pdata->sameForest = false;
					pdata->sourceIsNT4 = true;
					checkbox( hwndDlg,IDC_TRANS_FROM_MOT,DCTVS_AccountOptions_SecurityInputMOT);
					if (IsDlgButtonChecked(hwndDlg,IDC_TRANS_FROM_FILE))
					{
					    pdata->secWithMapFile = true;
						   //check if a file is given
			            if (IsDlgItemEmpty(hwndDlg,IDC_MAPPING_FILE))
						{	
						   MessageBoxWrapper(hwndDlg,IDS_MAPFILE_EMPTY,IDS_MAPFILE_TITLE);
						   SetFocus(GetDlgItem(hwndDlg, IDC_MAPPING_FILE));
						   SendDlgItemMessage(hwndDlg, IDC_MAPPING_FILE, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
				           SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						   return TRUE;
						}
			               //see if the given file exists
						else if (!checkMapFile(hwndDlg))
						{	
						   MessageBoxWrapper(hwndDlg,IDS_MAPFILE_MISSING,IDS_MAPFILE_TITLE);
						   SetFocus(GetDlgItem(hwndDlg, IDC_MAPPING_FILE));
						   SendDlgItemMessage(hwndDlg, IDC_MAPPING_FILE, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
				           SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						   return TRUE;
						}
						else
						{
							  //save sid mapping file specified
						   editbox(hwndDlg,IDC_MAPPING_FILE,DCTVS_AccountOptions_SecurityMapFile);
						      //if input from Sid mapping file, go to the security selection screen and do not
						      //retrieve domain information
				           SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_SELECTION4);
						   return TRUE;
						}
					}
					else
					    pdata->secWithMapFile = false;

					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(TRANSLATION_OPTION, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(TRANSLATION_OPTION, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}
//END IntTranslationInputProc

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 25 OCT 2000                                                 *
 *                                                                   *
 *     This callback function is responsible for handling the windows*
 * messages for the new Object Property Exclusion dialog.  This      *
 * dialog allows the user to exclude certain properties, on a W2K to *
 * W2K inter-forest migration, from being copied to the target       *
 * account.                                                          *
 *                                                                   *
 *********************************************************************/

//BEGIN IntPropExclusionProc
INT_PTR CALLBACK
IntPropExclusionProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);

			initpropdlg(hwndDlg);
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{			
			case IDC_EXCLUDEPROPS :
	            if (!IsDlgButtonChecked(hwndDlg,IDC_EXCLUDEPROPS))
				{
					disable(hwndDlg,IDC_OBJECTCMBO);
					disable(hwndDlg,IDC_INCLUDELIST);
					disable(hwndDlg,IDC_EXCLUDELIST);
					disable(hwndDlg,IDC_EXCLUDEBTN);
					disable(hwndDlg,IDC_INCLUDEBTN);
				}
				else
				{
					enable(hwndDlg,IDC_OBJECTCMBO);
					enable(hwndDlg,IDC_INCLUDELIST);
					enable(hwndDlg,IDC_EXCLUDELIST);
					enable(hwndDlg,IDC_EXCLUDEBTN);
					enable(hwndDlg,IDC_INCLUDEBTN);
				}
				break;
			case IDC_EXCLUDEBTN :
				moveproperties(hwndDlg, true);
				break;
			case IDC_INCLUDEBTN :
				moveproperties(hwndDlg, false);
				break;
			default:
				break;
			}
			switch(HIWORD (wParam))
			{
			case CBN_SELCHANGE :
				if (LOWORD (wParam) == IDC_OBJECTCMBO)
				   listproperties(hwndDlg);
				break;
			default:
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case NM_DBLCLK:
			      {
        			       UINT uId = (UINT) wParam;
        			       if (uId == IDC_INCLUDELIST)
        			           moveproperties(hwndDlg, true);
        			       else if (uId == IDC_EXCLUDELIST)
        			           moveproperties(hwndDlg, false);
			       }
			       break;
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				if (bChangedMigrationTypes)
				{
					initpropdlg(hwndDlg);
					bChangedMigrationTypes=false;
				}
				break;
			case PSN_WIZNEXT :
				checkbox(hwndDlg,IDC_EXCLUDEPROPS,DCTVS_AccountOptions_ExcludeProps);
				saveproperties(hwndDlg);
				if (migration==w_account)
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_RENAMING);
					return TRUE;
				}
				else if (migration==w_group)
				{
					if (!pdata->sameForest && pdata->IsSidHistoryChecked)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
						return TRUE;
					}
					else
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_RENAMING);
						return TRUE;
					}
				}				
				break;
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
					if (!ReallyCancel(hwndDlg))
					{
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						return TRUE;
					}

					GetError(0); //clear any old com errors
					break;
				}
			case PSN_HELP :
				{						
					SharedHelp(OBJECT_PROPERTY_EXCLUSION, hwndDlg);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			SharedHelp(OBJECT_PROPERTY_EXCLUSION, hwndDlg);
			break;
		}		

	default:
		break;
	}
	return 0;				
}
//END IntPropExclusionProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\guiutils.h ===
#pragma once
#include "Globals.h"

const int THREE_YEARS = 1095;

typedef enum {
    DOMAIN_SELECTION_HELP,
    GROUP_SELECTION_HELP,
    COMPUTER_SELECTION_HELP,
    OU_SELECTION_HELP,
    TRANSLATE_OBJECTS_HELP,
    GROUP_OPTION_HELP,
    SECURITY_OPTION_HELP,
    NAME_CONFLICT_HELP,
    CONFIRMATION_HELP,
    COMMIT_HELP,
    OBJECT_PROPERTY_EXCLUSION,
    CREDENTIALS_HELP,
    SERVICE_ACCOUNT_INFO,
    USER_SERVICE_ACCOUNT,
    REFRESH_INFO_HELP,
    GROUP_MEMBER_OPTION,
    USER_OPTION_HELP,
    REPORT_SELECTION_HELP,
    TASK_SELECTION_HELP,
    PASSWORD_OPTION_HELP,
    TARGET_GROUP_SELECTION,
    TRUST_INFO_HELP,
    COMPUTER_OPTION,
    UNDO_HELP,
    WELCOME_HELP,
    ACCOUNTTRANSITION_OPTION,
    EXCHANGE_SERVER_SELECTION,
    USER_SELECTION_HELP,
    SERVICE_ACCOUNT_SELECTION,
    DIRECTORY_SELECTION_HELP,
    TRANSLATION_OPTION
} ADMTSHAREDHELP;

BOOL CanSkipVerification();

void SetItemText(CListCtrl& yo, int nItem, int subItem,CString& text);
void SetItemText(CListCtrl& yo, int nItem, int subItem,TCHAR const * text);
void SetItemText(CListCtrl& yo, int nItem, int subItem,TCHAR * text);
void SetItemText(CListCtrl& yo, int nItem, int subItem,_bstr_t text);
bool GetCheck(CListCtrl & yo,int nItem);
void SetCheck(CListCtrl & yo,int nItem,bool checkit);
void setupColumns(bool sourceIsNT4);
void ShowWarning(HWND hwndDlg);
void ErrorWrapper2(HWND hwndDlg,HRESULT returncode);
void OnFileBrowse(HWND hwndDlg,int id);
void ErrorWrapper(HWND hwndDlg,HRESULT returncode);
void ErrorWrapper4(HWND hwndDlg,HRESULT returncode,CString domainName);
_bstr_t	GET_BSTR1(int id);
void doNothingToVarset();
bool enableNextIfNecessary(HWND hwndDlg,int id);
void enableNextIfObjectsSelected(HWND hwndDlg);
HRESULT InitObjectPicker2(IDsObjectPicker *pDsObjectPicker,bool multiselect,CString targetComputer,bool sourceIsNT4);
bool validString(HWND hwndDlg,int id);
void JobFileGetActionText(WCHAR const * filename,CString & text);
DWORD VerifyPassword(PCWSTR pszUser, PCWSTR pszPassword, PCWSTR pszDomain);
DWORD VerifyExchangeServerCredential(HWND hwndDlg, PCWSTR pszUser, PCWSTR pszPassword, PCWSTR pszDomain);
void obtainTrustCredentials(HWND hwdDlg);
void activateServiceButtons(HWND hwndDlg);
void activateTrustButton(HWND hwndDlg);
void activateServiceButtons2(HWND hwndDlg);
void activateCancelIfNecessary(HWND hwndDlg);
bool CheckSameForest(CString& domain1,CString& domain2,HRESULT& hr);
void initnoncollisionrename(HWND hwndDlg);
bool noncollisionrename(HWND hwndDlg);
void handleDB();
CString GET_CSTRING(int id);
bool number(CString num);
HRESULT doSidHistory(HWND hwndDlg);
bool administrator(CString m_Computer,HRESULT& hr);
bool targetNativeMode(_bstr_t b,HRESULT &hr);
HRESULT validDomain(CString m_Computer,bool &isNt4);
bool validDir(CString dir);
bool checkFile(HWND hwndDlg);
bool verifyprivs(HWND hwndDlg,CString &sourceDomainController,CString &targetDomainController,LPSHAREDWIZDATA& pdata);
bool someServiceAccounts(int accounts,HWND hwndDlg);
void swap(CString yo1,CString yo2);
void refreshDB(HWND hwndDlg);
void populateList(CComboBox&);
void populateTrustingList(CString domainName, CComboBox&);
void getReporting();
bool tooManyChars(HWND hwndDlg,int id);

void putReporting();
void populateReportingTime();
CString timeToCString(int varsetKey);			
void MessageBoxWrapper(HWND hwndDlg,int m,int t);
void getFailed(HWND hwndDlg);
void handleCancel(HWND hwndDlg);
void getService();
void OnADD(HWND hwndDlg,bool sourceIsNT4);
void enable(HWND hwndDlg,int id);
void disable(HWND hwndDlg,int id);
void OnREMOVE(HWND);
void OnMIGRATE(HWND,int & accounts,int& servers);
void initpasswordbox(HWND hwndDlg,int id1,int id2,int id3, BSTR bstr1, BSTR bstr2);
void initdisablesrcbox(HWND hwndDlg);
void inittgtstatebox(HWND hwndDlg);
bool DC(WCHAR*,CString);
bool IsDlgItemEmpty(HWND hwndDlg,int id);
HRESULT InitObjectPicker(IDsObjectPicker *pDsObjectPicker,bool multiselect,CString targetComputer,bool sourceIsNT4);
void ProcessSelectedObjects(IDataObject *pdo,HWND hwndDlg,bool sourceIsNT4);
void ProcessSelectedObjects2(IDataObject *pdo,HWND hwndDlg);
_variant_t get(int i);
void put(int i,_variant_t v);
void initcheckbox(HWND hwndDlg,int id,int varsetKey);
void initeditbox(HWND hwndDlg,int id,int varsetKey);
void initeditboxPassword(HWND hwndDlg, int id, int varsetKey);
void inittranslationbox(HWND hwndDlg,int id1,int id2,int id3,int varsetKey,bool sameForest);
void checkbox(HWND hwndDlg,int id,int varsetKey);
void editbox(HWND hwndDlg,int id,int varsetKey);
void editboxPassword(HWND hwndDlg, int id, int varsetKey);
void translationbox(HWND hwndDlg,int id1,int id2,int id3,int varsetKey);
long rebootbox(HWND hwndDlg,int id);
void handleInitRename(HWND hwndDlg,bool sameForest,bool bCopyGroups);
void addrebootValues(HWND hwndDlg);
BOOL GetDirectory(WCHAR* filename);
void populateTime(long rebootDelay,int servers);
void OnTOGGLE(HWND hwndDlg);
void OnRetryToggle();
bool OnRETRY(HWND hwndDlg);
void setDBStatusSkip();
bool setDBStatusInclude(HWND hwndDlg);
HRESULT MigrateTrusts(HWND hwndDlg,bool& atleast1succeeded,CString& errDomain);
void OnBROWSE(HWND hwndDlg,int id);
void OnUPDATE(HWND hwndDlg);
void enableRemoveIfNecessary(HWND hwndDlg);
bool validDirectoryString(HWND hwndDlg,int id);
bool validReboot(HWND hwndDlg,int id);
bool SomethingToRetry();
void helpWrapper(HWND hwndDlg, int t);
HRESULT GetHelpFileFullPath( BSTR *bstrHelp );
bool timeInABox(HWND hwndDlg,time_t& t);
void ErrorWrapper3(HWND hwndDlg,HRESULT returncode,CString domainName);
void MessageBoxWrapper3(HWND hwndDlg,int m,int t,CString domainName);
void MessageBoxWrapperFormat1(HWND hwndDlg,int f,int m, int t);
void MessageBoxWrapperFormat1P(HWND hwndDlg,int f, int t, CString sInsert1);
void getTrust();
HRESULT BrowseForContainer(HWND hWnd,//Handle to window that should own the browse dialog.
                    LPOLESTR szRootPath, //Root of the browse tree. NULL for entire forest.
                    LPOLESTR *ppContainerADsPath, //Return the ADsPath of the selected container.
                    LPOLESTR *ppContainerClass //Return the ldapDisplayName of the container's class.
                    );
void sort(CListCtrl & listbox,int col,bool order);
HRESULT ReInitializeObjectPicker(IDsObjectPicker *pDsObjectPicker,bool multiselect,CString additionalDomainController,bool sourceIsNT4) ;
bool verifyprivs2(HWND hwndDlg,CString& additionalDomainController,CString domainName);
bool __stdcall VerifyCallerDelegated(HWND hwndDlg, LPSHAREDWIZDATA pdata);

void calculateDate(HWND hwndDlg,CString s);
bool verifyprivsSTW(HWND hwndDlg,CString &sourceDomainController,CString &targetDomainController,LPSHAREDWIZDATA& pdata);
void switchboxes(HWND hwndDlg,int oldid, int newid);
bool populatePasswordDCs(HWND hwndDlg, int id, bool bNT4);
HRESULT QueryW2KDomainControllers(CString domainDNS, IEnumVARIANT*& pEnum);
HRESULT QueryNT4DomainControllers(CString domainDNS, IEnumVARIANT*& pEnum);
void addStringToComboBox(HWND hwndDlg, int id, CString s);
void initDCcombobox(HWND hwndDlg, int id, int varsetKey);
void initsecinputbox(HWND hwndDlg,int id1,int id2,int varsetKey);
void OnMapFileBrowse(HWND hwndDlg,int id);
bool checkMapFile(HWND hwndDlg);
void initpropdlg(HWND hwndDlg);
HRESULT BuildPropertyMap(CString Type, long lSrcVer, CPropertyNameToOIDMap * pPropMap);
void moveproperties(HWND hwndDlg,bool bExclude);
void listproperties(HWND hwndDlg);
void saveproperties(HWND hwndDlg);
bool IsPasswordDCReady(CString server, CString &msg, CString &title, UINT *msgtype);
CString CreatePath(CString sDirPath);
void GetValidPathPart(CString sFullPath, CString &sDirectory, CString &sFileName);
BOOL HasAccountBeenMigrated(CString sAccount, CString& sTgtAcct);
BOOL ReallyCancel(HWND hwndDlg);
CString GetServerWithMultipleTasks();
void SharedHelp(ADMTSHAREDHELP HelpTopic, HWND hwndDlg);
void __stdcall SetDefaultExcludedSystemProperties(HWND hwndDlg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\guiutils.cpp ===
#include "stdafx.h"
#include "GuiUtils.h"
#include "TxtSid.h"
#include "LSAUtils.h"
#include "ErrDct.hpp"
#include <ntdsapi.h>
#include <ntldap.h>   // LDAP_MATCHING_RULE_BIT_AND_W
#include <DsRole.h>
#include <lm.h>
#include "GetDcName.h"
#include <SamUtils.h>
#include "HtmlHelpUtil.h"
#include "VerifyConfiguration.h"
#include "exldap.h"
#include "StrHelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef UINT (CALLBACK* DSBINDFUNC)(TCHAR*, TCHAR*, HANDLE*);
typedef UINT (CALLBACK* DSUNBINDFUNC)(HANDLE*);

typedef NTDSAPI
DWORD
WINAPI
 DSCRACKNAMES(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCWSTR       *rpNames,           // in
    PDS_NAME_RESULTW    *ppResult);         // out


typedef NTDSAPI
void
WINAPI
 DSFREENAMERESULT(
  DS_NAME_RESULTW *pResult
);

#ifndef IADsPtr
_COM_SMARTPTR_TYPEDEF(IADs, IID_IADs);
#endif
#ifndef IADsUserPtr
_COM_SMARTPTR_TYPEDEF(IADsUser, IID_IADsUser);
#endif
#ifndef IADsContainerPtr
_COM_SMARTPTR_TYPEDEF(IADsContainer, IID_IADsContainer);
#endif


BOOL
   CanSkipVerification()
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;
   DWORD                     val = 0;

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);

   if (! rc )
   {
      rc = key.ValueGetDWORD(L"SkipGUIValidation",&val);
      if ( ! rc && ( val != 0 ) )
      {
         bFound = TRUE;
      }
   }
   return !bFound;
}


BOOL                                       // ret - TRUE if directory found
   GetDirectory(
      WCHAR                * filename      // out - string buffer to store directory name
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;


   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);


   if ( ! rc )
   {

	   rc = key.ValueGetStr(L"Directory",filename,MAX_PATH);

	   if ( ! rc )
      {
         if ( *filename ) 
            bFound = TRUE;
      }
   }


   return bFound;
}


void OnTOGGLE(HWND hwndDlg)
{
    int nItem;
    CString c,computer,account,service;
    CString skip,include;
    skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); 

    nItem = m_serviceBox.GetNextItem(-1, LVNI_SELECTED);
    while (nItem != -1)
    {
        computer = m_serviceBox.GetItemText(nItem,0);
        service = m_serviceBox.GetItemText(nItem,1);
        account = m_serviceBox.GetItemText(nItem,2);
        c = m_serviceBox.GetItemText(nItem,3);

        if (c==skip)
        {
            c = include;
            if (migration == w_service)
            {
                CString sTgtAcct;
                if (HasAccountBeenMigrated(account, sTgtAcct))
                {
                    enable(hwndDlg, IDC_UPDATE);
                }
                else
                {
                    disable(hwndDlg, IDC_UPDATE);
                }
            }
        }
        else if (c== include)
        {
            c = skip;
            if (migration == w_service)
            {
                disable(hwndDlg, IDC_UPDATE);
            }
        }

        SetItemText(m_serviceBox,nItem,3,c);
        nItem = m_serviceBox.GetNextItem(nItem, LVNI_SELECTED);
    }
}
void OnRetryToggle()
{
	int nItem;
	CString c;
	CString skip,include;
	skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); 

	nItem = m_cancelBox.GetNextItem(-1, LVNI_SELECTED);
	while (nItem != -1)
	{
		c = m_cancelBox.GetItemText(nItem,5);
		if (c== skip)
		{
			c = include;
		}
		else if (c== include)
		{
			c = skip;
		}
		SetItemText(m_cancelBox,nItem,5,c);
		nItem = m_cancelBox.GetNextItem(nItem, LVNI_SELECTED);
	}
}

void OnUPDATE(HWND hwndDlg)
{

    ISvcMgrPtr svcMgr;
    HRESULT hr = svcMgr.CreateInstance(CLSID_ServMigr);
    int nItem;

    CString updated,updatefailed,include;
    updated.LoadString(IDS_UPDATED);updatefailed.LoadString(IDS_UPDATEFAILED);
    include.LoadString(IDS_INCLUDE);

    CString computer,service,account,status;

    nItem = m_serviceBox.GetNextItem(-1, LVNI_SELECTED);
    while (nItem != -1)
    {
        status = m_serviceBox.GetItemText(nItem,3);
        if ((status == updatefailed) || (status == include))
        {
            CString sSrcAcct;

            computer = m_serviceBox.GetItemText(nItem,0);
            sSrcAcct= m_serviceBox.GetItemText(nItem,2);
            service = m_serviceBox.GetItemText(nItem,1);

            // get the target account
            if (HasAccountBeenMigrated(sSrcAcct, account))
            {

                hr = svcMgr->raw_TryUpdateSam(_bstr_t(computer),_bstr_t(service),_bstr_t(account));
                if (! SUCCEEDED(hr))
                {
                    if (HRESULT_CODE(hr) == HRESULT_CODE(DCT_MSG_UPDATE_SCM_ENTRY_UNMATCHED_SSD))
                    {
                        CString msg, title, sTemp;
                        sTemp.LoadString(IDS_MSG_SA_NO_MATCH);
                        msg.Format((LPCTSTR)sTemp, (LPCTSTR)computer, (LPCTSTR)service, (LPCTSTR)account);
                        title.LoadString(IDS_SA_MISMATCH_TITLE);
                        MessageBox(hwndDlg,msg,title,MB_OK|MB_ICONSTOP);
                    }
                    else if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
                    {
                        CString sMsg, sTitle, sTemp;
                        sTemp.LoadString(IDS_MSG_REMIGRATE_ACCOUNT);
                        sMsg.Format((LPCTSTR) sTemp, (LPCTSTR) sSrcAcct);
                        sTitle.LoadString(IDS_MSG_ERROR);
                        MessageBox(hwndDlg, sMsg, sTitle, MB_OK|MB_ICONSTOP);
                    }
                    else
                    {
                        db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(sSrcAcct), SvcAcctStatus_UpdateFailed);
                        SetItemText(m_serviceBox,nItem,3,updatefailed);
                        ErrorWrapper(hwndDlg,hr);
                    }
                }
                else
                {
                    db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account), SvcAcctStatus_Updated);
                    SetItemText(m_serviceBox,nItem,2,account);  // update to the target account
                    SetItemText(m_serviceBox,nItem,3,updated);
                }
            }
        }
        nItem = m_serviceBox.GetNextItem(nItem, LVNI_SELECTED);
    }
}

DWORD VerifyPassword(PCWSTR pszUser, PCWSTR pszPassword, PCWSTR pszDomain)
{
    DWORD dwError = ERROR_SUCCESS;

    if (gbNeedToVerify)
    {
        CWaitCursor wait;

        //
        // Verify that specified domain is valid.
        //

        //_bstr_t strDC;
        //dwError = GetAnyDcName5(pszDomain, strDC);

        //if (dwError == ERROR_SUCCESS)
        //{
            //
            // Obtain the name of the PDC in the source domain. The credentials must be validated
            // on the PDC as the underlying SamConnectWithCreds call requires SAM RPC calls over TCP
            // transport which is enabled by the TcpipClientSupport key. This is usually only enabled
            // on the PDC for DsAddSidHistory.
            //

            PCTSTR pszSourceDomain = GetSourceDomainName();
            _bstr_t strSourcePdc;

            dwError = GetDcName5(pszSourceDomain, DS_PDC_REQUIRED, strSourcePdc);

            if (dwError == ERROR_SUCCESS)
            {
                //
                // Verify that credentials are valid and have
                // administrative rights in the source domain.
                //

                dwError = VerifyAdminCredentials(pszSourceDomain, strSourcePdc, pszUser, pszPassword, pszDomain);
            }
        //}
    }

    return dwError;
}

//----------------------------------------------------------------------------
// Function:   VerifyExchangeServerCredential
//
// Synopsis:   This function tries to use the provided credential to connect
//             to the exchange server ldap port.  If successful, ERROR_SUCCESS
//             is returned; otherwise, some error code is returned
//
// Arguments:
//
// pszUser      the username string
// pszPassword  the password string
// pszDomain    the domain name string
//
// Returns:    ERROR_SUCCESS if successful; otherwise an error code
//
// Modifies:   None.
//
//----------------------------------------------------------------------------

DWORD VerifyExchangeServerCredential(HWND hwndDlg, PCWSTR pszUser, PCWSTR pszPassword, PCWSTR pszDomain)
{
    // for exchange migration, we use the credential to connect to
    // exchange server
    CLdapEnum e;
    DWORD ldapPort, sslPort;
    DWORD rc;
    _bstr_t server = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateContainers));
    
    GetLDAPPort(&ldapPort, &sslPort);

    WCHAR szIdentifier[256];

    rc = GeneratePasswordIdentifier(szIdentifier, countof(szIdentifier));

    if (rc == ERROR_SUCCESS)
    {
        rc = StorePassword(szIdentifier, pszPassword);

        if (rc == ERROR_SUCCESS)
        {
            e.m_connection.SetCredentials(pszDomain, pszUser, szIdentifier);

            BOOL sslEnabled = FALSE;

            // try SSL port first
            rc  = e.InitSSLConnection(server,&sslEnabled,sslPort);

            if (rc != ERROR_SUCCESS || sslEnabled == FALSE)
            {
                rc = e.InitConnection(server, ldapPort);
            }

            StorePassword(szIdentifier, NULL);

            if (rc != ERROR_SUCCESS)
            {
                MessageBoxWrapper(hwndDlg, IDS_MSG_INVALID_EXCHANGE_SERVER_CREDENTIALS, IDS_MSG_ERROR);
            }
        }
        else
        {
            MessageBoxWrapper(hwndDlg, IDS_MSG_UNABLE_RETRIEVE_STORE_PASSWORD, IDS_MSG_ERROR);
        }
    }
    else
    {
        MessageBoxWrapper(hwndDlg, IDS_MSG_UNABLE_RETRIEVE_STORE_PASSWORD, IDS_MSG_ERROR);
    }

    return rc;
}

void activateTrustButton(HWND hwndDlg)
{
//	int i = m_trustBox.GetSelectionMark();
	int i = m_trustBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	CString c;
	if (i==-1)
	{
		disable(hwndDlg,IDC_MIGRATE) ;
		return;
	}
	else if ((c = m_trustBox.GetItemText(i,3)) == (WCHAR const *) yes)
	{
		disable(hwndDlg,IDC_MIGRATE) ;
		return;
	}
	enable(hwndDlg,IDC_MIGRATE);
}


void activateServiceButtons(HWND hwndDlg)
{
    int nItem;
    CString checker;
    bool enableUpdate=false;
    bool enableToggle=false;
    CString skip,include,updated,updatefailed;
    skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); updated.LoadString(IDS_UPDATED);updatefailed.LoadString(IDS_UPDATEFAILED); 

    //	POSITION pos = m_serviceBox.GetFirstSelectedItemPosition();

    //	while (pos)
    //	{
    //		nItem = m_serviceBox.GetNextSelectedItem(pos);
    nItem = m_serviceBox.GetNextItem(-1, LVNI_SELECTED);//PRT
    while (nItem != -1)//PRT
    {
        checker = m_serviceBox.GetItemText(nItem,3);
        enableToggle = enableToggle || (checker==skip|| checker==include);
        if (checker == include)
        {
            CString sSrcAcct, sTgtAcct;
            sSrcAcct = m_serviceBox.GetItemText(nItem, 2);
            if (HasAccountBeenMigrated(sSrcAcct, sTgtAcct))
                enableUpdate = true;
        }
        enableUpdate = enableUpdate || (checker==updatefailed);
        nItem = m_serviceBox.GetNextItem(nItem, LVNI_SELECTED);//PRT
    }
    enableToggle ? enable(hwndDlg,IDC_TOGGLE) : disable(hwndDlg,IDC_TOGGLE);
    enableUpdate ? enable(hwndDlg,IDC_UPDATE) : disable(hwndDlg,IDC_UPDATE);
}

void activateServiceButtons2(HWND hwndDlg)
{
	int nItem;
	CString checker;
	bool enableToggle=false;
	CString skip,include;
	skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); 

	nItem = m_serviceBox.GetNextItem(-1, LVNI_SELECTED);
	while (nItem != -1)
	{
		checker = m_serviceBox.GetItemText(nItem,3);
		enableToggle = enableToggle || (checker==skip || checker==include);
		nItem = m_serviceBox.GetNextItem(nItem, LVNI_SELECTED);
	}
	enableToggle ? enable(hwndDlg,IDC_TOGGLE) : disable(hwndDlg,IDC_TOGGLE);
}	

void removeService(CString name)
{
	name = name.Right((name.GetLength()-name.ReverseFind(L'\\')) -1);
	name.TrimLeft();name.TrimRight();
	_bstr_t text=get(DCTVS_Accounts_NumItems);
	CString base,base2,tocompare;
	int count = _ttoi((WCHAR * const) text);
	for (int i=0;i<count;i++)
	{
		base.Format(L"Accounts.%d.Name",i);
		text =pVarSet->get(_bstr_t(base));
		tocompare = (WCHAR * const) text;
		tocompare.TrimLeft();tocompare.TrimRight();
		if (!name.CompareNoCase(tocompare))
		{
			count--;
			base.Format(L"Accounts.%d",count);
			base2.Format(L"Accounts.%d",i);

			pVarSet->put(_bstr_t(base2),pVarSet->get(_bstr_t(base)));
			pVarSet->put(_bstr_t(base2+L".Name"),pVarSet->get(_bstr_t(base+L".Name")));
			pVarSet->put(_bstr_t(base2+L".Type"),pVarSet->get(_bstr_t(base+L".Type")));
			pVarSet->put(_bstr_t(base2+L".TargetName"),pVarSet->get(_bstr_t(base+L".TargetName")));

			pVarSet->put(_bstr_t(base),L"");
			pVarSet->put(_bstr_t(base+L".Name"),L"");
			pVarSet->put(_bstr_t(base+L".Type"),L"");
			pVarSet->put(_bstr_t(base+L".TargetName"),L"");


			put(DCTVS_Accounts_NumItems,(long) count);
			return;
		}
	}
}
void setDBStatusSkip()
{
	CString computer,account,service;
	for (int i=0;i<m_serviceBox.GetItemCount();i++)
	{
		computer = m_serviceBox.GetItemText(i,0);
		service = m_serviceBox.GetItemText(i,1);
		account = m_serviceBox.GetItemText(i,2);
		db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account),SvcAcctStatus_DoNotUpdate);
		removeService(account);
	}
}
bool setDBStatusInclude(HWND hwndDlg)
{
	CString c,computer,account,service;
	CString skip,include;
	skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); 
	bool messageDisplayed=false;
	for (int i=0;i<m_serviceBox.GetItemCount();i++)
	{
		computer = m_serviceBox.GetItemText(i,0);
		service = m_serviceBox.GetItemText(i,1);
		account = m_serviceBox.GetItemText(i,2);
		c = m_serviceBox.GetItemText(i,3);
		if (c== skip)
		{
			db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account),SvcAcctStatus_DoNotUpdate);
		}
		else if (c==include)
		{
			messageDisplayed=true;
			db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account), SvcAcctStatus_NotMigratedYet);
		}
	}
	return messageDisplayed;
}

void getService()
{
	IUnknown * pUnk;
	CString skip,include,updated,updatefailed,cannotMigrate;
	skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); updated.LoadString(IDS_UPDATED); updatefailed.LoadString(IDS_UPDATEFAILED);
	cannotMigrate.LoadString(IDS_CANNOT);

	m_serviceBox.DeleteAllItems();
	if (migration!=w_account)
	{
		pVarSetService->QueryInterface(IID_IUnknown, (void**) &pUnk);
		db->GetServiceAccount(L"",&pUnk);
		pUnk->Release();
	}				
	//	pVarSetService is now containing all service acct information.
	_bstr_t text;
	text = pVarSetService->get(L"ServiceAccountEntries");
	int numItems=_ttoi((WCHAR const *)text);
	CString toLoad,temp;
	toLoad = (WCHAR const *)text;

	for (int i = 0; i< numItems;i++)
	{
		
		toLoad.Format(L"Computer.%d",i);
		text = 	pVarSetService->get(_bstr_t(toLoad));		
		m_serviceBox.InsertItem(0,(WCHAR const *)text);
		toLoad.Format(L"Service.%d",i);
		text = 	pVarSetService->get(_bstr_t(toLoad));
		SetItemText(m_serviceBox,0,1,(WCHAR const *)text);
		toLoad.Format(L"ServiceAccount.%d",i);
		text = 	pVarSetService->get(_bstr_t(toLoad));
		SetItemText(m_serviceBox,0,2,(WCHAR const *)text);
		toLoad.Format(L"ServiceAccountStatus.%d",i);
		text = 	pVarSetService->get(_bstr_t(toLoad));
		
		if (!UStrCmp(text,L"0"))  temp = include;
		else if (!UStrCmp(text,L"1")) temp = skip;
		else if (!UStrCmp(text,L"4")) temp = updatefailed;
		else if (!UStrCmp(text,L"2")) temp = updated;
		else if (!UStrCmp(text,L"8")) temp = cannotMigrate;
		else temp =L"~";
		SetItemText(m_serviceBox,0,3,temp);	
		
		//new
		toLoad.Format(L"ServiceDisplayName.%d",i);
		text = 	pVarSetService->get(_bstr_t(toLoad));
		SetItemText(m_serviceBox,0,4,(WCHAR const *)text);
	}
}

void refreshDB(HWND hwndDlg)
{
    // protect against re-entrancy which may occur
    // if wizard page button is clicked repeatedly

    static bool s_bInFunction = false;

    if (!s_bInFunction)
    {
        s_bInFunction = true;

        try
        {
            IPerformMigrationTaskPtr sp(__uuidof(Migrator));

            pVarSet->put(L"PlugIn.0", _variant_t(L"{9CC87460-461D-11D3-99F3-0010A4F77383}"));

            sp->PerformMigrationTask(IUnknownPtr(pVarSet), (LONG_PTR)hwndDlg);

            pVarSet->put(L"PlugIn.0", _variant_t(L""));
        }
        catch (const _com_error &ce)
        {
            // load the correct module state
            // for some reason the wrong module state may be current
            // which causes the LoadString to fail to find the string resource
            // this does occur if refreshDB is called a second time before the previous
            // call has returned from PerformMigrationTask

            AFX_MANAGE_STATE(AfxGetStaticModuleState());

            if (ce.Error() == MIGRATOR_E_PROCESSES_STILL_RUNNING)
            {
                CString str;

                if (str.LoadString(IDS_ADMT_PROCESSES_STILL_RUNNING))
                {
                    ::AfxMessageBox(str);
                }
            }
            else
            {
                _bstr_t bstrDescription;
                try 
                {
                    bstrDescription = ce.Description();
                }
                catch (_com_error &e)
                {
                }

                if (bstrDescription.length())
                    ::AfxMessageBox(bstrDescription);
                else
                    ::AfxMessageBox(ce.ErrorMessage());
            }
        }

        s_bInFunction = false;
    }
}

void initnoncollisionrename(HWND hwndDlg)
{
	_bstr_t     pre;
	_bstr_t     suf;
	
	pre = get(DCTVS_Options_Prefix);
	suf = get(DCTVS_Options_Suffix);
	
	if (UStrICmp(pre,L""))
	{
		CheckRadioButton(hwndDlg,IDC_RADIO_NONE,IDC_RADIO_PRE,IDC_RADIO_PRE);
		enable(hwndDlg,IDC_PRE);
		disable(hwndDlg,IDC_SUF);
	}
	else if (UStrICmp(suf,L""))
	{
		CheckRadioButton(hwndDlg,IDC_RADIO_NONE,IDC_RADIO_SUF,IDC_RADIO_SUF);
		enable(hwndDlg,IDC_SUF);
		disable(hwndDlg,IDC_PRE);
	}
	else
	{
		CheckRadioButton(hwndDlg,IDC_RADIO_NONE,IDC_RADIO_SUF,IDC_RADIO_NONE);
		disable(hwndDlg,IDC_SUF);
		disable(hwndDlg,IDC_PRE);
	}

	initeditbox(hwndDlg,IDC_PRE,DCTVS_Options_Prefix);
	initeditbox(hwndDlg,IDC_SUF,DCTVS_Options_Suffix);
}
bool noncollisionrename(HWND hwndDlg)
{	
	CString P;
	CString S;
	if (IsDlgButtonChecked(hwndDlg,IDC_RADIO_SUF))
	{
		if (!validString(hwndDlg,IDC_SUF)) return false;
		if (IsDlgItemEmpty(hwndDlg,IDC_SUF)) return false;
		GetDlgItemText(hwndDlg,IDC_SUF,S.GetBuffer(1000),1000);
		S.ReleaseBuffer();
		P=L"";		
	}
	else if (IsDlgButtonChecked(hwndDlg,IDC_RADIO_PRE))
	{
		if (!validString(hwndDlg,IDC_PRE)) return false;
		if (IsDlgItemEmpty(hwndDlg,IDC_PRE)) return false;
		GetDlgItemText(hwndDlg,IDC_PRE,P.GetBuffer(1000),1000);
		P.ReleaseBuffer();
		S=L"";
	}
	else
	{
		P=L"";
		S=L"";
	}
if (P.GetLength() > 8 || S.GetLength() >8) return false;
	put(DCTVS_Options_Prefix,_bstr_t(P));
	put(DCTVS_Options_Suffix,_bstr_t(S));
	return true;
}

bool tooManyChars(HWND hwndDlg,int id)
{
    _bstr_t     text;
	CString temp;
	_variant_t varX;
	int i;

	GetDlgItemText( hwndDlg, id, temp.GetBuffer(1000),1000);	
	temp.ReleaseBuffer();
	i=temp.GetLength();
	
	text = get(DCTVS_Options_Prefix);
	temp=(WCHAR const *) text;
	i+= temp.GetLength();
	text = get(DCTVS_Options_Suffix);
	temp=(WCHAR const *) text;
	i+= temp.GetLength();

	return (i>8);
}

bool someServiceAccounts(int accounts,HWND hwndDlg)
{
	CWaitCursor c;
	if (migration==w_group) return false;
	
	IVarSetPtr  pVarSetMerge(__uuidof(VarSet));
	
	IUnknown * pUnk;
	int count=0;
	
	pVarSetMerge->QueryInterface(IID_IUnknown, (void**) &pUnk);
	_bstr_t nameToCheck,text;
	CString parameterToCheck;
	bool some= false;
	pVarSetService->Clear();
	for (int i = 0;i<accounts;i++)
	{
		pVarSetMerge->Clear();
		parameterToCheck.Format(L"Accounts.%d",i);
		nameToCheck = pVarSet->get(_bstr_t(parameterToCheck));
		// Get the DOMAIN\Account form of the name
		WCHAR       domAcct[500];
		WCHAR       domAcctUPN[5000];
		
		domAcct[0] = 0;
		if ( ! wcsncmp(nameToCheck,L"WinNT://",UStrLen(L"WinNT://")) )
		{
			// the name is in the format: WinNT://DOMAIN/Account
			safecopy(domAcct,((WCHAR*)nameToCheck)+UStrLen(L"WinNT://"));
			
			// convert the / to a \ .
			WCHAR     * slash = wcschr(domAcct,L'/');
			if ( slash )
			{
				(*slash) = L'\\';
			}
		}
		else
		{
			// this is the LDAP form of the name.
			IADsUserPtr pUser;
			
			HRESULT hr = ADsGetObject(nameToCheck,IID_IADsUser,(void**)&pUser);
			if ( SUCCEEDED(hr) )
			{
				VARIANT        v;
				
				VariantInit(&v);
				
				hr = pUser->Get(_bstr_t(L"sAMAccountName"),&v);
				if ( SUCCEEDED(hr) )
				{
					if ( v.vt == VT_BSTR  )
					{
						// we got the account name!
						swprintf(domAcct,L"%ls\\%ls",GetSourceDomainNameFlat(),(WCHAR*)v.bstrVal);
					}
					VariantClear(&v);
				}
			}
			else
			{
				CString toload,title;toload.LoadString(IDS_MSG_SA_FAILED);
				title.LoadString(IDS_MSG_ERROR);
				MessageBox(hwndDlg,toload,title,MB_OK|MB_ICONSTOP);
				return false;
			}
		}
		
		if ( *domAcct ) // if we weren't able to get the account name, just skip the DB check
		{
			
			HRESULT hr=db->raw_GetServiceAccount(domAcct,&pUnk);
			if (FAILED(hr)) {
				CString toload,title;toload.LoadString(IDS_MSG_SA_FAILED);
				title.LoadString(IDS_MSG_ERROR);
				MessageBox(hwndDlg,toload,title,MB_OK|MB_ICONSTOP);
				return false;
			}
			text = pVarSetMerge->get(L"ServiceAccountEntries");

				//adding code to handle service accounts in the database that
				//may be listed by their UPN name
			if ((!UStrCmp(text,L"0")) || (!UStrCmp(text,L"")))
			{
               PDS_NAME_RESULT         pNamesOut = NULL;
               WCHAR                 * pNamesIn[1];
			   HINSTANCE               hLibrary = NULL;
			   DSCRACKNAMES          * DsCrackNames = NULL;
			   DSFREENAMERESULT      * DsFreeNameResult = NULL;
			   DSBINDFUNC              DsBind = NULL;
			   DSUNBINDFUNC            DsUnBind = NULL;
			   HANDLE                  hDs = NULL;

               pNamesIn[0] = (WCHAR*)domAcct;

               hLibrary = LoadLibrary(L"NTDSAPI.DLL"); 

               if ( hLibrary )
               {
                  DsBind = (DSBINDFUNC)GetProcAddress(hLibrary,"DsBindW");
                  DsUnBind = (DSUNBINDFUNC)GetProcAddress(hLibrary,"DsUnBindW");
                  DsCrackNames = (DSCRACKNAMES *)GetProcAddress(hLibrary,"DsCrackNamesW");
                  DsFreeNameResult = (DSFREENAMERESULT *)GetProcAddress(hLibrary,"DsFreeNameResultW");
               }
            
               if ( DsBind && DsUnBind && DsCrackNames && DsFreeNameResult)
               {
					//bind to that source domain
				  hr = (*DsBind)(NULL,const_cast<TCHAR*>(GetSourceDomainName()),&hDs);

				  if ( !hr )
				  {
				      //get UPN name of this account from DSCrackNames
			         hr = (*DsCrackNames)(hDs,DS_NAME_NO_FLAGS,DS_NT4_ACCOUNT_NAME,DS_USER_PRINCIPAL_NAME,1,pNamesIn,&pNamesOut);
				     if ( !hr )
					 {     //if got the UPN name, retry DB query for that account in the
					    	//service account database
					    if ( pNamesOut->rItems[0].status == DS_NAME_NO_ERROR )
						{
						    wcscpy(domAcctUPN, pNamesOut->rItems[0].pName);
						 
							   //see if account in database by its UPN name
						    hr=db->raw_GetServiceAccount(domAcctUPN,&pUnk);
						    if (!SUCCEEDED (hr)) 
							{
					  		   CString toload,title;toload.LoadString(IDS_MSG_SA_FAILED);
							   title.LoadString(IDS_MSG_ERROR);
							   MessageBox(hwndDlg,toload,title,MB_OK|MB_ICONSTOP);
							   return false;
							}
						    text = pVarSetMerge->get(L"ServiceAccountEntries");
						}
	                    (*DsFreeNameResult)(pNamesOut);
					 }
					 (*DsUnBind)(&hDs);
				  }
			   }
		       
			   if ( hLibrary )
			   {
		          FreeLibrary(hLibrary);
			   }
			}

			if (UStrCmp(text,L"0") && UStrCmp(text,L""))
			{	
				int number=_ttoi((WCHAR * const) text);
				CString base,loader;
				_bstr_t text;
				for (int i=0;i<number;i++)
				{
					some=true;
					
					base.Format(L"Computer.%d",i);			
					text= pVarSetMerge->get(_bstr_t(base));				 
					loader.Format(L"Computer.%d",count);
					pVarSetService->put(_bstr_t(loader),text);
					
					base.Format(L"Service.%d",i);			
					text= pVarSetMerge->get(_bstr_t(base));				 
					loader.Format(L"Service.%d",count);
					pVarSetService->put(_bstr_t(loader),text);
					
					base.Format(L"ServiceAccount.%d",i);			
					text= pVarSetMerge->get(_bstr_t(base));
						//store the sAMAccountName in the varset and database rather
						//than the UPN name
					wcscpy((WCHAR*)text, domAcct);
					loader.Format(L"ServiceAccount.%d",count);
					pVarSetService->put(_bstr_t(loader),text);
					
					base.Format(L"ServiceAccountStatus.%d",i);			
					text= pVarSetMerge->get(_bstr_t(base));				 
					loader.Format(L"ServiceAccountStatus.%d",count);
					pVarSetService->put(_bstr_t(loader),text);
					

					base.Format(L"ServiceDisplayName.%d",i);			
					text= pVarSetMerge->get(_bstr_t(base));				 
					loader.Format(L"ServiceDisplayName.%d",count);
					pVarSetService->put(_bstr_t(loader),text);

					count++;
					pVarSetService->put(L"ServiceAccountEntries",(long) count);
				}
			}
		}
		}
	pUnk->Release();
	return some;
}
CString timeToCString(int varsetKey)
{
	_bstr_t     text;
	time_t t;	
	CString s;
	CString t2;
	text = pVarSet->get(GET_BSTR(varsetKey));
	t2 = (WCHAR * ) text;
	t2.TrimLeft();t2.TrimRight();
	if ((t2.IsEmpty() != FALSE) || (!t2.CompareNoCase(L"0")))
	{
		s.LoadString(IDS_NOT_CREATED);
	}
	else
	{
//*		t = _ttoi((WCHAR const *)text);
//*		CTime T(t);
		
//*		s = T.Format( "%c" );
		t = _ttoi((WCHAR const *)text);

   		SYSTEMTIME        stime;
   		CTime             ctime;
   		ctime = t;

		stime.wYear = (WORD) ctime.GetYear();
		stime.wMonth = (WORD) ctime.GetMonth();
		stime.wDayOfWeek = (WORD) ctime.GetDayOfWeek();
		stime.wDay = (WORD) ctime.GetDay();
		stime.wHour = (WORD) ctime.GetHour();
		stime.wMinute = (WORD) ctime.GetMinute();
		stime.wSecond = (WORD) ctime.GetSecond();
		stime.wMilliseconds = 0;
//*	   	if ( ctime.GetAsSystemTime(stime) )
//*   		{
			   CString     t1;
            CString     t2;

            GetTimeFormat(LOCALE_USER_DEFAULT,0,&stime,NULL,t1.GetBuffer(500),500);
            GetDateFormat(LOCALE_USER_DEFAULT,0,&stime,NULL,t2.GetBuffer(500),500);
			
            t1.ReleaseBuffer();
            t2.ReleaseBuffer();

            s = t2 + " " + t1;
//*   		}

	}
	return s;
}
_variant_t get(int i)
{
	return pVarSet->get(GET_BSTR(i));
}
void put(int i,_variant_t v)
{
	pVarSet->put(GET_BSTR(i),v);
}
void getReporting()
{
	_bstr_t temp;
	CString c;
	c.LoadString(IDS_COLUMN_NAMECONFLICTS);
	m_reportingBox.InsertItem(0,c);
	SetItemText(m_reportingBox,0, 1, timeToCString(DCTVS_Reports_NameConflicts_TimeGenerated));

	c.LoadString(IDS_COLUMN_ACCOUNTREFERENCES);
	m_reportingBox.InsertItem(0,c);
	SetItemText(m_reportingBox,0, 1, timeToCString(DCTVS_Reports_AccountReferences_TimeGenerated));
	
	c.LoadString(IDS_COLUMN_EXPIREDCOMPUTERS);
	m_reportingBox.InsertItem(0,c);
	SetItemText(m_reportingBox,0, 1, timeToCString(DCTVS_Reports_ExpiredComputers_TimeGenerated));
	
	c.LoadString(IDS_COLUMN_MIGRATEDCOMPUTERS);
	m_reportingBox.InsertItem(0,c);
	SetItemText(m_reportingBox,0, 1, timeToCString(DCTVS_Reports_MigratedComputers_TimeGenerated));
	
	c.LoadString(IDS_COLUMN_MIGRATEDACCOUNTS);
	m_reportingBox.InsertItem(0,c);
	SetItemText(m_reportingBox,0, 1, timeToCString(DCTVS_Reports_MigratedAccounts_TimeGenerated));

}
void putReporting()
{
	_variant_t varX;
	int nItem;
	bool atleast1 =false;
//	POSITION pos = m_reportingBox.GetFirstSelectedItemPosition();
//	while (pos)
//	{
//		atleast1 = true;
//		nItem = m_reportingBox.GetNextSelectedItem(pos);
	nItem = m_reportingBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	while (nItem != -1)//PRT
	{
		atleast1 = true;
		SetCheck(m_reportingBox,nItem,false);
		nItem = m_reportingBox.GetNextItem(nItem, LVNI_SELECTED);//PRT
	}

	varX = (!GetCheck(m_reportingBox,0)) ? yes : no;
	put(DCTVS_Reports_MigratedAccounts,varX);
	varX = (!GetCheck(m_reportingBox,1)) ?  yes : no;
	put(DCTVS_Reports_MigratedComputers,varX);
	varX = (!GetCheck(m_reportingBox,2)) ?  yes : no;
	put(DCTVS_Reports_ExpiredComputers,varX);
	varX = (!GetCheck(m_reportingBox,3)) ?  yes : no;
	put(DCTVS_Reports_AccountReferences,varX);
	varX = (!GetCheck(m_reportingBox,4)) ?  yes : no;
	put(DCTVS_Reports_NameConflicts,varX);
	

	varX = atleast1 ?  yes : no;
	put(DCTVS_Reports_Generate,varX);

	for (int i = 0; i< m_reportingBox.GetItemCount();i++)
		SetCheck(m_reportingBox,i,true);
}
void populateReportingTime()
{
	_variant_t varX;
	_bstr_t text;
	CString temp;
	time_t ltime;	
	time(&ltime);
	temp.Format(L"%d",ltime);	
	varX = temp;

	if (!UStrICmp((text = get(DCTVS_Reports_MigratedAccounts)),(WCHAR const *) yes))
		put(DCTVS_Reports_MigratedAccounts_TimeGenerated,varX);
	if (!UStrICmp((text = get(DCTVS_Reports_MigratedComputers)),(WCHAR const *) yes))
		put(DCTVS_Reports_MigratedComputers_TimeGenerated,varX);
	if (!UStrICmp((text = get(DCTVS_Reports_ExpiredComputers)),(WCHAR const *) yes))
		put(DCTVS_Reports_ExpiredComputers_TimeGenerated,varX);
	if (!UStrICmp((text = get(DCTVS_Reports_AccountReferences)),(WCHAR const *) yes))
		put(DCTVS_Reports_AccountReferences_TimeGenerated,varX);
	if (!UStrICmp((text = get(DCTVS_Reports_NameConflicts)),(WCHAR const *) yes))
		put(DCTVS_Reports_NameConflicts_TimeGenerated,varX);
}



void getFailed(HWND hwndDlg)
{
	IVarSetPtr  pVarSetFailed(__uuidof(VarSet));
	IUnknown * pUnk;
	pVarSetFailed->QueryInterface(IID_IUnknown, (void**) &pUnk);
	HRESULT hr = db->GetFailedDistributedActions(-1, &pUnk);
	pUnk->Release();
	if (FAILED(hr))
		MessageBoxWrapper(hwndDlg,IDS_MSG_FAILED,IDS_MSG_ERROR);
	else
	{
		CString toLoad;
		CString holder;
		_bstr_t text;

		CString skip;
		skip.LoadString(IDS_SKIP);
		int i=0;
		_bstr_t numItemsText = pVarSetFailed->get(L"DA");
		CString jobHelper;
		if (UStrCmp(numItemsText,L"0") && UStrCmp(numItemsText,L""))
		{
			int numItems = _ttoi( (WCHAR const *) numItemsText);
			while (i<numItems)
			{
				holder.Format(L"DA.%d" ,i);

				toLoad = holder + L".Server";
				text = pVarSetFailed->get(_bstr_t(toLoad));
				m_cancelBox.InsertItem(0,(WCHAR const *)text);			
				
				toLoad = holder + L".JobFile";
				text = pVarSetFailed->get(_bstr_t(toLoad));
				SetItemText(m_cancelBox,0,1,(WCHAR const *)text);			
			
				JobFileGetActionText((WCHAR * const) text,jobHelper);
				SetItemText(m_cancelBox,0,3,jobHelper);

				toLoad = holder + L".StatusText";
				text = pVarSetFailed->get(_bstr_t(toLoad));
				SetItemText(m_cancelBox,0,2,(WCHAR const *)text);			

				toLoad = holder + L".ActionID";
				text = pVarSetFailed->get(_bstr_t(toLoad));
				SetItemText(m_cancelBox,0,4,(WCHAR const *)text);			

				SetItemText(m_cancelBox,0,5,skip);			

				i++;
			}
		}
	}
}

void handleCancel(HWND hwndDlg)
{
	int nItem;
	HRESULT hr=S_OK;
	long lActionID;
	CString computer;
	CString actionID;
//	POSITION pos = m_cancelBox.GetFirstSelectedItemPosition();
//	while (pos)
//	{
//		nItem = m_cancelBox.GetNextSelectedItem(pos);
	nItem = m_cancelBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	while (nItem != -1)//PRT
	{
		SetCheck(m_cancelBox,nItem,false);
		nItem = m_cancelBox.GetNextItem(nItem, LVNI_SELECTED);//PRT
	}
	

	for (int i=(m_cancelBox.GetItemCount()-1);i>=0;i--)
	{
		if (!GetCheck(m_cancelBox,i))
		{
			computer = m_cancelBox.GetItemText(i,0);
			actionID = m_cancelBox.GetItemText(i,4);
			
			lActionID = _ttol(actionID.GetBuffer(500));
			actionID.ReleaseBuffer();

			hr  = db->CancelDistributedAction(lActionID, _bstr_t(computer));
			if (FAILED(hr))
				MessageBoxWrapper(hwndDlg,IDC_MSG_CANCEL,IDS_MSG_ERROR);
			else
				m_cancelBox.DeleteItem(i);
		}
	}
}
	
bool OnRETRY(HWND hwndDlg)
{
    bool bRetry = true;

    int count =0;
    CString holder,c;
    _variant_t varX;
    CString include;
    include.LoadString(IDS_INCLUDE); 
    for (int i=0;i<m_cancelBox.GetItemCount();i++)
    {		
        c = m_cancelBox.GetItemText(i,5);
        if (c== include)
        {
            CString strActionId = m_cancelBox.GetItemText(i, 4);
            CString strName = L"\\\\" + m_cancelBox.GetItemText(i, 0);

            BSTR bstrDnsName = NULL;
            BSTR bstrFlatName = NULL;

            HRESULT hr = db->GetServerNamesFromActionHistory(
                _variant_t((PCWSTR)strActionId),
                _bstr_t((PCWSTR)strName),
                &bstrFlatName,
                &bstrDnsName
            );

            if (SUCCEEDED(hr))
            {
                if (hr == S_OK)
                {
                    if (bstrFlatName)
                    {
                        holder.Format(L"Servers.%d",count);
                        pVarSet->put(_bstr_t(holder),_bstr_t(bstrFlatName, false));

                        if (bstrDnsName)
                        {
                            holder.Format(L"Servers.%d.DnsName",count);
                            pVarSet->put(_bstr_t(holder),_bstr_t(bstrDnsName, false));
                        }

                        varX = m_cancelBox.GetItemText(i,1);
                        holder.Format(L"Servers.%d.JobFile",count);
                        pVarSet->put(_bstr_t(holder),varX);
                        count++;
                    }
                    else
                    {
                        MessageBoxWrapperFormat1P(hwndDlg, IDS_MSG_UNABLE_RETRIEVE_SERVER_INFO, IDS_MSG_ERROR, m_cancelBox.GetItemText(i, 0));
                        bRetry = false;
                        break;
                    }
                }
                else
                {
                    MessageBoxWrapperFormat1P(hwndDlg, IDS_MSG_UNABLE_RETRIEVE_SERVER_INFO, IDS_MSG_ERROR, m_cancelBox.GetItemText(i, 0));
                    bRetry = false;
                    break;
                }
            }
            else
            {
                ErrorWrapper(hwndDlg, hr);
                bRetry = false;
                break;
            }
        }
    }
    holder = L"Servers.NumItems";
    pVarSet->put(_bstr_t(holder),(long)count);

    return bRetry;
}


void JobFileGetActionText(WCHAR const * filename // in - job file name
				,CString & text      // in/out - text describing the action
)
{
   // load the varset into a file
    // Read the varset data from the file
   IVarSetPtr             pVarSet;
   IStorage             * store = NULL;
   HRESULT                hr;

   // Try to create the COM objects
   hr = pVarSet.CreateInstance(CLSID_VarSet);
   if ( SUCCEEDED(hr) )
   {
      // Read the VarSet from the data file
      hr = StgOpenStorage(filename,NULL,STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,NULL,0,&store);
      if ( SUCCEEDED(hr) )
      {                  
         // Load the data into a new varset
         hr = OleLoad(store,IID_IUnknown,NULL,(void **)&pVarSet);
         if ( SUCCEEDED(hr) )
         {
            _bstr_t     wizard = pVarSet->get(GET_BSTR(DCTVS_Options_Wizard));

//*            if ( !UStrICmp(wizard,(WCHAR const *) GET_BSTR1(IDS_WIZARD_COMPUTER) ))
            if ( !UStrICmp(wizard, L"computer"))
            {
               text = GET_CSTRING(IDS_MIGRATE_COMPUTER);
            }
//*            else if ( !UStrICmp(wizard,(WCHAR const *)GET_BSTR1(IDS_WIZARD_SERVICE) ))
            else if ( !UStrICmp(wizard, L"service"))
            {
               text = GET_CSTRING(IDS_GATHER_SERVICEACCOUNT);
            }
//*            else if ( ! UStrICmp(wizard,(WCHAR const *)GET_BSTR1(IDS_WIZARD_SECURITY) ))
            else if ( ! UStrICmp(wizard, L"security"))
            {
               text = GET_CSTRING(IDS_TRANSLATE_SECURITY);
            }
//*            else if (! UStrICmp(wizard,(WCHAR const *) GET_BSTR1(IDS_WIZARD_REPORTING)) )
            else if (! UStrICmp(wizard, L"reporting") )
            {
               text = GET_CSTRING(IDS_GATHER_INFORMATION);
            }
            else
            {
               text = (WCHAR*)wizard;
            }
         }
         store->Release();
      }
   }
}
_bstr_t GET_BSTR1(int id)
{
	CString yo;
	yo.LoadString(id);
	return (LPCTSTR)yo;
}

void activateCancelIfNecessary(HWND hwndDlg)
{
//	POSITION pos = m_cancelBox.GetFirstSelectedItemPosition();
//	if (pos)
	int nItem = m_cancelBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	if (nItem != -1)//PRT
	{
		enable(hwndDlg,IDC_CANCEL);
		enable(hwndDlg,IDC_TOGGLE);
	}
	else
	{
		disable(hwndDlg,IDC_CANCEL);
		disable(hwndDlg,IDC_TOGGLE);
	}
}

bool SomethingToRetry()
{
	if (m_cancelBox.GetItemCount()==0) return false;
	int count =0;
	CString include;
	include.LoadString(IDS_INCLUDE);

	CString c;
	for (int i=0;i<m_cancelBox.GetItemCount();i++)
	{		
		c = m_cancelBox.GetItemText(i,5);
		if (c== include)
		{
			return true;
		}
	}
	return false;
}

void OnFileBrowse(HWND hwndDlg,int id)
{
	CWnd yo;
	yo.Attach(hwndDlg);
	CString sDir = L"", sFile = L"", sPath = L"";
	
    CFileDialog f(FALSE,
		L"",
		GET_CSTRING(IDS_PASSWORDS),
		OFN_LONGNAMES | OFN_NOREADONLYRETURN,
		GET_CSTRING(IDS_MASKS),
		&yo);

	GetDlgItemText(hwndDlg, id, sPath.GetBuffer(1000), 1000);
	sPath.ReleaseBuffer();

	if (sPath.GetLength())
       GetValidPathPart(sPath, sDir, sFile);
       
	f.m_ofn.lpstrInitialDir = sDir.GetBuffer(1000);
    f.m_ofn.lpstrFile = sFile.GetBuffer(1000);
	
	if ( f.DoModal() == IDOK )
	{
		SetDlgItemText(hwndDlg,id,f.GetPathName());
	}
	yo.Detach();

	sFile.ReleaseBuffer();
	sDir.ReleaseBuffer();
}

void ShowWarning(HWND hwndDlg)
{
	CString warning,base,title;
	IAccessCheckerPtr          pAC;
	HRESULT hr = pAC.CreateInstance(CLSID_AccessChecker);
	long              length;
	hr = pAC->raw_GetPasswordPolicy(_bstr_t(GetTargetDomainName()),&length);
	if ( !SUCCEEDED(hr) )
	{
		ErrorWrapper2(hwndDlg,hr);
	}
	else 
	{
		if (length>0)
		{
		base.Format(L"%lu",length);
		warning.LoadString(IDS_MSG_WARNING_LENGTH);
		base+=warning;
		title.LoadString(IDS_MSG_WARNING);
		MessageBox(hwndDlg,base,title,MB_OK|MB_ICONINFORMATION);
	}
	}	
}

bool obtainTrustCredentials(HWND hwndDlg,int spot, CString & domain, CString & account, CString & password)
{
	bool toreturn;
	CWnd yo;
	yo.Attach(hwndDlg);
	CTrusterDlg truster(&yo);
	truster.len = MAX_PATH;

    _bstr_t strNameDns;
    _bstr_t strNameFlat;

    DWORD dwError = GetDomainNames5(m_trustBox.GetItemText(spot,0), strNameFlat, strNameDns);

    if (dwError == ERROR_SUCCESS)
    {
	    truster.m_strDomain = (LPCTSTR)strNameFlat;
    }
    else
    {
	    truster.m_strDomain = m_trustBox.GetItemText(spot,0);
    }

	truster.DoModal();
	toreturn = truster.toreturn;
	
	if ( toreturn )
	{
		domain = truster.m_strDomain;
		account = truster.m_strUser;
		password = truster.m_strPassword;
	}
	yo.Detach();
	return toreturn;
}
CString GET_CSTRING(int id)
{
	CString c;
	c.LoadString(id);
	return c;
}

HRESULT MigrateTrusts(HWND hwndDlg,bool& atleast1succeeded,CString& errorDomain)
{
	ITrustPtr      pTrusts;		
	IUnknown          * pUnk = NULL;
//	int i=m_trustBox.GetSelectionMark();
	int i=m_trustBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	CString trusted,trusting,direction;
	HRESULT hr = pTrusts.CreateInstance(CLSID_Trust);
	CString       strDomain,strAccount,strPassword;
	atleast1succeeded=false;
	BOOL bErrorFromTrusting;
	BOOL bErrorFromTrusted;
	errorDomain.Empty();
	
	if ( SUCCEEDED(hr) )
	{
		
		CWaitCursor s;
		direction = m_trustBox.GetItemText(i,1);
		direction.TrimLeft();
		direction.TrimRight();
		if (direction == GET_CSTRING(IDS_OUTBOUND))
		{
			trusting = GetTargetDomainName();
			trusted = m_trustBox.GetItemText(i,0);
			hr = pTrusts->raw_CreateTrust(_bstr_t(trusting),_bstr_t(trusted),FALSE,(long*)&bErrorFromTrusting,(long*)&bErrorFromTrusted);
			
			if (HRESULT_CODE(hr) == ERROR_ACCESS_DENIED)
				
				if (obtainTrustCredentials(hwndDlg,i,strDomain, strAccount, strPassword))
					
					hr = pTrusts->raw_CreateTrustWithCreds(_bstr_t(trusting),_bstr_t(trusted),
					NULL,NULL,NULL,_bstr_t(strDomain),_bstr_t(strAccount),
					_bstr_t(strPassword),FALSE,(long*)&bErrorFromTrusting,(long*)&bErrorFromTrusted);
				
				
		}
		
		else if (direction == GET_CSTRING(IDS_INBOUND))
		{
			trusting = m_trustBox.GetItemText(i,0);
			trusted = GetTargetDomainName();
			
			hr = pTrusts->raw_CreateTrust(_bstr_t(trusting),_bstr_t(trusted),FALSE,(long*)&bErrorFromTrusting,(long*)&bErrorFromTrusted);
			if (HRESULT_CODE(hr) == ERROR_ACCESS_DENIED)
				
				if (obtainTrustCredentials(hwndDlg,i,strDomain, strAccount, strPassword))
					
					hr = pTrusts->raw_CreateTrustWithCreds(_bstr_t(trusting),_bstr_t(trusted),
					_bstr_t(strDomain),_bstr_t(strAccount),
					_bstr_t(strPassword),NULL,NULL,NULL,FALSE,(long*)&bErrorFromTrusting,(long*)&bErrorFromTrusted);
		}
		else if (direction == GET_CSTRING(IDS_BIDIRECTIONAL))
		{
			trusting = m_trustBox.GetItemText(i,0);
			trusted = GetTargetDomainName();
			hr = pTrusts->raw_CreateTrust(_bstr_t(trusting),_bstr_t(trusted),TRUE,(long*)&bErrorFromTrusting,(long*)&bErrorFromTrusted);
			if (HRESULT_CODE(hr) == ERROR_ACCESS_DENIED)
				
				if (obtainTrustCredentials(hwndDlg,i,strDomain, strAccount, strPassword))
					
					
					hr = pTrusts->raw_CreateTrustWithCreds(_bstr_t(trusting),_bstr_t(trusted),
					_bstr_t(strDomain),_bstr_t(strAccount),
					_bstr_t(strPassword),NULL,NULL,NULL,TRUE,(long*)&bErrorFromTrusting,(long*)&bErrorFromTrusted);
		}
		
		if (direction == GET_CSTRING(IDS_DISABLED))
		{
			MessageBoxWrapper(hwndDlg,IDS_MSG_DISABLED_TRUST,IDS_MSG_ERROR);	
		}
		else if (direction.IsEmpty() != FALSE)
		{
			MessageBoxWrapper(hwndDlg,IDS_MSG_DIRECTION_TRUST,IDS_MSG_ERROR);	
		}
		
		else
		{
			if ( SUCCEEDED(hr) )
			{
				// update the UI to reflect that the trust now exists
				m_trustBox.SetItemText(i,3,GET_BSTR(IDS_YES));
				atleast1succeeded=true;   
			}
			else
			{
			    if (bErrorFromTrusting)
			        errorDomain = trusting;
			    else if (bErrorFromTrusted)
			        errorDomain = trusted;
			}			        
		}
	}
	return hr;
}
void getTrust()
{
				// get the trust relationship data
	ITrustPtr      pTrusts;
//	CWaitCursor wait;
	
	HRESULT hr = pTrusts.CreateInstance(CLSID_Trust);
	if ( SUCCEEDED(hr) )
	{
		IUnknown          * pUnk = NULL;
		CString dirname;
		GetDirectory(dirname.GetBuffer(1000));
		dirname.ReleaseBuffer();
		dirname+= L"Logs\\trust.log";
		hr = pTrusts->raw_QueryTrusts(_bstr_t(GetSourceDomainName()),_bstr_t(GetTargetDomainName()),_bstr_t(dirname),&pUnk);
		if ( SUCCEEDED(hr) )
		{
			IVarSetPtr        pVsTrusts;
			pVsTrusts = pUnk;
			pUnk->Release();
			long              nTrusts = pVsTrusts->get(L"Trusts");
			for ( long i = 0 ; i < nTrusts ; i++ )
			{
				CString     base;
				CString     sub;
				
				base.Format(L"Trusts.%ld",i);
				_bstr_t     value = pVsTrusts->get(_bstr_t(base));
				m_trustBox.InsertItem(0,value);
				
				sub = base + L".Direction";
				value = pVsTrusts->get(_bstr_t(sub));
				SetItemText(m_trustBox,0,1,value);
				
				sub = base + L".Type";
				value = pVsTrusts->get(_bstr_t(sub));
				SetItemText(m_trustBox,0,2,value);
				
				sub = base + L".ExistsForTarget";
				value = pVsTrusts->get(_bstr_t(sub));
				SetItemText(m_trustBox,0,3,value);
				
			}
		}
	}
}
bool number(CString num)
{
	if (num.GetLength()==0) return false;
	CString checker;
	checker.LoadString(IDS_VALID_DIGITS);
	for (int i=0;i<num.GetLength();i++)
	{
		if (checker.Find(num.GetAt(i)) == -1)
			return false;
	}
	return true;
}
bool timeInABox(HWND hwndDlg,time_t& t)
{
	CString s;
	GetDlgItemText(hwndDlg,IDC_yo,s.GetBuffer(1000),1000);
	s.ReleaseBuffer();
	s.TrimLeft();s.TrimRight();
	if (!number(s)) return false;
	int num=_ttoi((LPTSTR const) s.GetBuffer(1000));
	s.ReleaseBuffer();
	if (num > THREE_YEARS || num < 1) return false;
	DWORD             nDays = num;
	
	DWORD             oneDay = 24 * 60 * 60; // number of seconds in 1 day
	time_t            currentTime = time(NULL);
	time_t            expireTime;
	expireTime = currentTime + nDays * oneDay;
//expireTime-=currentTime%86400;
	t= expireTime;
	return true;
}

HRESULT GetHelpFileFullPath( BSTR *bstrHelp )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CString  strPath, strName;
   HRESULT  hr = S_OK;

   TCHAR szModule[2*_MAX_PATH];
   DWORD dwReturn = 0;

   GetDirectory(szModule);
   
   strPath = szModule;
   strPath += _T("\\");
   strName.LoadString(IDS_HELPFILE);
   strPath += strName;

   *bstrHelp = SysAllocString(LPCTSTR(strPath));
   return hr;
}

void helpWrapper(HWND hwndDlg, int t)
{
   
   CComBSTR    bstrTopic;
	HRESULT     hr = GetHelpFileFullPath( &bstrTopic);
   if ( SUCCEEDED(hr) )
   {
	    HWND h = HtmlHelp(hwndDlg,  bstrTopic,  HH_HELP_CONTEXT, t );
	    if (!IsInWorkArea(h))
	        PlaceInWorkArea(h);
   }
   else
   {
		CString r,e;
		r.LoadString(IDS_MSG_HELP);
		e.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,r,e,MB_OK|MB_ICONSTOP);
   }
}

bool IsDlgItemEmpty(HWND hwndDlg, int id)
{
	CString temp;
	GetDlgItemText( hwndDlg, id, temp.GetBuffer(1000),1000);
	temp.ReleaseBuffer();
	temp.TrimLeft();
	temp.TrimRight();
	return  (temp.IsEmpty()!= FALSE);
}

void calculateDate(HWND hwndDlg,CString s)
{
	s.TrimLeft();s.TrimRight();
	if (!number(s)) return;
	long nDays=_ttol((LPTSTR const) s.GetBuffer(1000));
	s.ReleaseBuffer();
	
	long              oneDay = 24 * 60 * 60; // number of seconds in 1 day
	time_t            currentTime = time(NULL);
	time_t            expireTime;
	CTime             ctime;
   	SYSTEMTIME        stime;
	CString strDate;
	expireTime = currentTime + nDays * oneDay;
	
	ctime = expireTime;

	stime.wYear = (WORD) ctime.GetYear();
	stime.wMonth = (WORD) ctime.GetMonth();
	stime.wDayOfWeek = (WORD) ctime.GetDayOfWeek();
	stime.wDay = (WORD) ctime.GetDay();
	stime.wHour = (WORD) ctime.GetHour();
	stime.wMinute = (WORD) ctime.GetMinute();
	stime.wSecond = (WORD) ctime.GetSecond();
	stime.wMilliseconds = 0;

	GetDateFormat(LOCALE_USER_DEFAULT,0,&stime,NULL,strDate.GetBuffer(500),500);
	strDate.ReleaseBuffer();
	
	SetDlgItemText(hwndDlg,IDC_DATE,strDate);
}

void ErrorWrapper(HWND hwndDlg,HRESULT returncode)
{
	CString y,e,text,title;
	if (HRESULT_FACILITY(returncode)==FACILITY_WIN32)
	{
		returncode=HRESULT_CODE(returncode);
		err.ErrorCodeToText(returncode,1000,y.GetBuffer(1000));
		y.ReleaseBuffer();	
		text.LoadString(IDS_MSG_ERRORBUF);
		e.Format(text,y,returncode);
		title.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,e,title,MB_OK|MB_ICONSTOP);
	}
	else
	{
		err.ErrorCodeToText(returncode,1000,y.GetBuffer(1000));
		y.ReleaseBuffer();	
		text.LoadString(IDS_MSG_ERRORBUF);
//		text.Replace(L"%u",L"%x");
		int index = text.Find(L"%u"); //PRT
		text.SetAt(index+1, L'x');    //PRT
		e.Format(text,y,returncode);
		title.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,e,title,MB_OK|MB_ICONSTOP);
	}
}
void ErrorWrapper2(HWND hwndDlg,HRESULT returncode)
{
	CString y,e,text,title,message;
	if (HRESULT_FACILITY(returncode)==FACILITY_WIN32)
	{
		returncode=HRESULT_CODE(returncode);
		err.ErrorCodeToText(returncode,1000,y.GetBuffer(1000));
		y.ReleaseBuffer();
		message.LoadString(IDS_MSG_PASSWORD_POLICY);
		
		text.LoadString(IDS_MSG_ERRORBUF20);
		e.Format(text,message,y,returncode);
		
		title.LoadString(IDS_MSG_WARNING);	
		MessageBox(hwndDlg,e,title,MB_OK|MB_ICONSTOP);
	}
	else
	{
		err.ErrorCodeToText(returncode,1000,y.GetBuffer(1000));
		y.ReleaseBuffer();
		message.LoadString(IDS_MSG_PASSWORD_POLICY);
		
		text.LoadString(IDS_MSG_ERRORBUF20);
//		text.Replace(L"%u",L"%x");
		int index = text.Find(L"%u"); //PRT
		text.SetAt(index+1, L'x');    //PRT
		e.Format(text,message,y,returncode);
		
		title.LoadString(IDS_MSG_WARNING);	
		MessageBox(hwndDlg,e,title,MB_OK|MB_ICONSTOP);
	}
}



void ErrorWrapper3(HWND hwndDlg,HRESULT returncode,CString domainName)
{
	CString y,e,text,title,formatter;
	if (HRESULT_FACILITY(returncode)==FACILITY_WIN32)
	{
		returncode=HRESULT_CODE(returncode);
		err.ErrorCodeToText(returncode,1000,e.GetBuffer(1000));
		e.ReleaseBuffer();
		formatter.LoadString(IDS_MSG_ERRORBUF3);
		text.Format(formatter,e,returncode,domainName);
		title.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,text,title,MB_OK|MB_ICONSTOP);
	}
	else
	{
		err.ErrorCodeToText(returncode,1000,e.GetBuffer(1000));
		e.ReleaseBuffer();
		formatter.LoadString(IDS_MSG_ERRORBUF3);
//		formatter.Replace(L"%u",L"%x");
		int index = formatter.Find(L"%u"); //PRT
		formatter.SetAt(index+1, L'x');    //PRT
		text.Format(formatter,e,returncode,domainName);
		title.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,text,title,MB_OK|MB_ICONSTOP);
	}
	
}
void ErrorWrapper4(HWND hwndDlg,HRESULT returncode,CString domainName)
{
	CString y,e,text,title,formatter;
	if (HRESULT_FACILITY(returncode)==FACILITY_WIN32)
	{
		returncode=HRESULT_CODE(returncode);
		
		err.ErrorCodeToText(returncode,1000,e.GetBuffer(1000));
		e.ReleaseBuffer();
		formatter.LoadString(IDS_MSG_ERRORBUF2);
		text.Format(formatter,e,returncode,domainName);
		title.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,text,title,MB_OK|MB_ICONSTOP);
	}
	else
	{	err.ErrorCodeToText(returncode,1000,e.GetBuffer(1000));
	e.ReleaseBuffer();
	formatter.LoadString(IDS_MSG_ERRORBUF2);
//	formatter.Replace(L"%u",L"%x");
	int index = formatter.Find(L"%u"); //PRT
	formatter.SetAt(index+1, L'x');    //PRT
	text.Format(formatter,e,returncode,domainName);
	title.LoadString(IDS_MSG_ERROR);
	MessageBox(hwndDlg,text,title,MB_OK|MB_ICONSTOP);
	}
}

bool validDir(CString str)
{
	CFileFind finder;

	// build a string with wildcards
   str += _T("\\*.*");

   // start working for files
   BOOL bWorking = finder.FindFile(str);
   if (bWorking==0) 
   {
	   finder.Close();
	   return false;
   }
   bWorking = finder.FindNextFile();
   
   bool toreturn = (finder.IsDirectory()? true:false);

	//some root drives do not have the directory flag set, so convert to
	//the root path and use it
   if (!toreturn)
   {
	  str = finder.GetRoot();
	  if (str.GetLength())
		toreturn = true;
   }

   finder.Close();
   return toreturn;
}

bool validDirectoryString(HWND hwndDlg,int id)
{
	CString str;
	GetDlgItemText(hwndDlg,id,str.GetBuffer(1000),1000);
	str.ReleaseBuffer();

	CString sResult = CreatePath(str);
	if (sResult.GetLength())
	{
	   SetDlgItemText(hwndDlg, id, (LPCTSTR)sResult);
	   return true;
	}
	else
	   return false;
}

bool validString(HWND hwndDlg,int id)
{
		//characters with ASCII values 1-31 are not allowed in addition to
		//the characters in IDS_INVALID_STRING.  ASCII characters, whose
		//value is 1-31, are hardcoded here since Visual C++ improperly 
		//converts some of these
//	WCHAR InvalidDownLevelChars[] = //TEXT("\"/\\[]:|<>+=;,?,*")
//                                TEXT("\001\002\003\004\005\006\007")
//                                TEXT("\010\011\012\013\014\015\016\017")
//                                TEXT("\020\021\022\023\024\025\026\027")
//								TEXT("\030\031\032\033\034\035\036\037");

	bool bValid;
	CHAR ANSIStr[1000];
	int numConverted;
	CString c;	
	GetDlgItemText(hwndDlg,id,c.GetBuffer(1000),1000);
	c.ReleaseBuffer();

	   //we now use the validation function in the common library that we share 
	   //with the scripting code
	bValid = IsValidPrefixOrSuffix(c);

/*	CString check;
	CHAR ANSIStr[1000];
//*	check.LoadString(IDS_VALID_STRING);
	check.LoadString(IDS_INVALID_STRING); //load viewable invalid characters
	if (c.GetLength() > 8) return false;
	for (int i=0;i<c.GetLength();i++)
	{
//*		if (check.Find(c.GetAt(i)) == -1)
			//if any characters enetered by the user ar in the viewable
			//invalid list, return false to display a messagebox
		if (check.Find(c.GetAt(i)) != -1)
			return false;
			//if any chars have a value between 1-31, return false
		for (UINT j=0; j<wcslen(InvalidDownLevelChars); j++)
		{
			if ((c.GetAt(i)) == (InvalidDownLevelChars[j]))
				return false;
		}
	}
*/
		//convert the same user input so we can guard against <ALT>1 
		//- <ALT>31, which cause problems in ADMT
	if (bValid)
	{
       numConverted = WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, (LPCTSTR)c, 
							-1, ANSIStr, 1000, NULL, NULL);
	   if (numConverted)
	   {
		  WCHAR sUnicodeStr[1000];
		  UStrCpy(sUnicodeStr, ANSIStr);
	      bValid = IsValidPrefixOrSuffix(sUnicodeStr);
	   }
	}

	return bValid;
}
bool validReboot(HWND hwndDlg,int id)
{
	const int REBOOT_MAX = 15;  //MAX minutes before computer reboot on migration

	CString c;
	GetDlgItemText(hwndDlg,id,c.GetBuffer(1000),1000);
	c.ReleaseBuffer();
	CString check;
	check.LoadString(IDS_VALID_REBOOT);
	for (int i=0;i<c.GetLength();i++)
	{
		if (check.Find(c.GetAt(i)) == -1)
			return false;
	}

	   //check to make sure it doesn't exceed the MAX (15 minutes) (will not integer
	   //overflow since combobox is small and not scrollable
	int num;
	int nRead = swscanf((LPCTSTR)c, L"%d", &num);
	if ((nRead == EOF) || (nRead == 0))
	    return false;
	if ((num >= 0) && (num > REBOOT_MAX))
	   return false;

	return true;
}

void enableRemoveIfNecessary(HWND hwndDlg)
{
//	POSITION pos = m_listBox.GetFirstSelectedItemPosition();
//	pos ? enable(hwndDlg,IDC_REMOVE_BUTTON) : disable(hwndDlg,IDC_REMOVE_BUTTON) ;
	int nItem = m_listBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	(nItem != -1) ? enable(hwndDlg,IDC_REMOVE_BUTTON) : disable(hwndDlg,IDC_REMOVE_BUTTON) ;//PRT
}
bool enableNextIfNecessary(HWND hwndDlg,int id)
{
	if (IsDlgItemEmpty(hwndDlg,id))
	{
		PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK);
	return false;
	}
	else
	{
		PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
		return true;
	}
}
void enableNextIfObjectsSelected(HWND hwndDlg)
{
	if (m_listBox.GetItemCount()==0)
	{
		PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
	}
	else
	{
		PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
	}
}


void setupColumns(bool sourceIsNT4)
{
    CString column;
    DWORD nColumnCount = 0;    
    
    // Get how many columns are in the list box
    nColumnCount = m_listBox.GetHeaderCtrl()->GetItemCount();
    
    if (migration == w_security || migration==w_service || migration==w_reporting)
    {
        if(nColumnCount == 0)
        {
            column.LoadString(IDS_COLUMN_NAME); m_listBox.InsertColumn( 1, column,LVCFMT_LEFT,125,1);
            column.LoadString(IDS_COLUMN_OBJECTPATH); m_listBox.InsertColumn( 2, column,LVCFMT_LEFT,0,1);
            column.LoadString(IDS_COLUMN_SAMNAME); m_listBox.InsertColumn( 3, column,LVCFMT_LEFT,0,1);
            column.LoadString(IDS_COLUMN_DESCRIPTION); m_listBox.InsertColumn( 4, column,LVCFMT_LEFT,125,1);
            column.LoadString(IDS_COLUMN_DNSNAME); m_listBox.InsertColumn( 5, column,LVCFMT_LEFT,0,1);
        }        
        	
    }
    else
    {
        if(nColumnCount != 0)
        {
            // Need to delete columns which are different between NT4 and upper domains (like win2k)
            for(int i = 2;i < nColumnCount;i++)
            {
                m_listBox.DeleteColumn(2);
            }            
        }
        else
        {
    
            column.LoadString(IDS_COLUMN_NAME); m_listBox.InsertColumn( 1, column,LVCFMT_LEFT,125,1);
            column.LoadString(IDS_COLUMN_OBJECTPATH); m_listBox.InsertColumn( 2, column,LVCFMT_LEFT,0,1);
        }

        if (sourceIsNT4)
        {
            if (migration==w_computer)
            {
                m_listBox.SetColumnWidth(0,455);
                column.LoadString(IDS_COLUMN_SAMNAME); m_listBox.InsertColumn( 3, column,LVCFMT_LEFT,0,1);
                column.LoadString(IDS_COLUMN_DESCRIPTION); m_listBox.InsertColumn( 4, column,LVCFMT_LEFT,0,1);
            }
            else if (migration==w_account)
            {
                column.LoadString(IDS_COLUMN_FULLNAME); m_listBox.InsertColumn( 3, column,LVCFMT_LEFT,125,1);
                column.LoadString(IDS_COLUMN_DESCRIPTION); m_listBox.InsertColumn( 4, column,LVCFMT_LEFT,125,1);
            }
            else if (migration==w_group || migration==w_groupmapping)
            {
                column.LoadString(IDS_COLUMN_DESCRIPTION); m_listBox.InsertColumn( 3, column,LVCFMT_LEFT,320,1);
            }
        }
        else
        {
            if (migration==w_computer)
            {
                m_listBox.SetColumnWidth(0, 126);
                column.LoadString(IDS_COLUMN_SAMNAME); m_listBox.InsertColumn( 3, column,LVCFMT_LEFT,0,1);
                column.LoadString(IDS_COLUMN_DESCRIPTION); m_listBox.InsertColumn( 4, column,LVCFMT_LEFT,125,1);
                column.LoadString(IDS_COLUMN_DNSNAME); m_listBox.InsertColumn( 5, column,LVCFMT_LEFT,0,1);
            }
            else if (migration==w_account)
            {
                column.LoadString(IDS_COLUMN_SAMNAME); m_listBox.InsertColumn( 3, column,LVCFMT_LEFT,125,1);
                column.LoadString(IDS_COLUMN_DESCRIPTION); m_listBox.InsertColumn( 4, column,LVCFMT_LEFT,125,1);
                column.LoadString(IDS_COLUMN_UPN); m_listBox.InsertColumn( 5, column,LVCFMT_LEFT,0,1);
            }
            else if (migration==w_group || migration==w_groupmapping)
            {
                column.LoadString(IDS_COLUMN_SAMNAME); m_listBox.InsertColumn( 3, column,LVCFMT_LEFT,125,1);
                column.LoadString(IDS_COLUMN_DESCRIPTION); m_listBox.InsertColumn( 4, column,LVCFMT_LEFT,205,1);
            }
        }      
    	
    }
    
}

void sort(CListCtrl & listbox,int col,bool order)
{
	CWaitCursor w;
	LV_ITEM lvItem;
	ZeroMemory(&lvItem, sizeof(lvItem));
	LV_ITEM lvItem2;
	ZeroMemory(&lvItem2, sizeof(lvItem2));
	bool ahead;
	CString temp1,temp2,temp3,temp4,temp5;
	int numItems = listbox.GetItemCount();
	for (int i = 0;i<numItems;i++)
	{
		for (int j=i;j<numItems;j++)
		{
			ahead = ((listbox.GetItemText(i,col)).CompareNoCase(listbox.GetItemText(j,col))> 0);
			if ((order && ahead) ||	(!order && !ahead))
			{
				temp1 = listbox.GetItemText(i,0);
				temp2 = listbox.GetItemText(i,1);
				temp3 = listbox.GetItemText(i,2);
				temp4 = listbox.GetItemText(i,3);
				temp5 = listbox.GetItemText(i,4);
				SetItemText(listbox,i,0,listbox.GetItemText(j,0));
				SetItemText(listbox,i,1,listbox.GetItemText(j,1));
				SetItemText(listbox,i,2,listbox.GetItemText(j,2));
				SetItemText(listbox,i,3,listbox.GetItemText(j,3));
				SetItemText(listbox,i,4,listbox.GetItemText(j,4));
				SetItemText(listbox,j,0,temp1);
				SetItemText(listbox,j,1,temp2);
				SetItemText(listbox,j,2,temp3);
				SetItemText(listbox,j,3,temp4);
				SetItemText(listbox,j,4,temp5);
			}
		}
	}
}
/*
void changePlaces(CListCtrl&listBox,int i,int j)
{
	CString temp1,temp2,temp3,temp4,temp5;
	temp1 = listbox.GetItemText(i,0);
	temp2 = listbox.GetItemText(i,1);
	temp3 = listbox.GetItemText(i,2);	
	temp4 = listbox.GetItemText(i,3);
	temp5 = listbox.GetItemText(i,4);
	SetItemText(listbox,i,0,listbox.GetItemText(j,0));
	SetItemText(listbox,i,1,listbox.GetItemText(j,1));
	SetItemText(listbox,i,2,listbox.GetItemText(j,2));
	SetItemText(listbox,i,3,listbox.GetItemText(j,3));
	SetItemText(listbox,i,4,listbox.GetItemText(j,4));
	SetItemText(listbox,j,0,temp1);
	SetItemText(listbox,j,1,temp2);
	SetItemText(listbox,j,2,temp3);
	SetItemText(listbox,j,3,temp4);
	SetItemText(listbox,j,4,temp5);
}
int Partition(CListCtrl & listbox,int col,bool order,int p,int r)
{
	CString x=listbox.GetItemText(p,col)
		int i=p-1;
	int j=r+1;
	while (true)
	{
		do
		{
			j--;
		}while(x.CompareNoCase(listBox.GetItemText(j,col) ) >= 0);
		do
		{
			i++;
		}while(x.CompareNoCase(listBox.GetItemText(i,col) ) <=0);
		if (i<j)
			changePlaces(listBox,i,j);
		else
			return j;
	}
	

}
void sort(CListCtrl & listbox,int col,bool order)
{
	CWaitCursor w;
	LV_ITEM lvItem;
	ZeroMemory(&lvItem, sizeof(lvItem));
	LV_ITEM lvItem2;
	ZeroMemory(&lvItem2, sizeof(lvItem2));
	bool ahead;
	CString temp1,temp2,temp3,temp4,temp5;
	int numItems = listbox.GetItemCount();
	
	for (int i = 0;i<numItems;i++)
	{
		for (int j=i;j<numItems;j++)
		{
			ahead = ((listbox.GetItemText(i,col)).CompareNoCase(listbox.GetItemText(j,col))> 0);
			if ((order && ahead) ||	(!order && !ahead))
			{
				temp1 = listbox.GetItemText(i,0);
				temp2 = listbox.GetItemText(i,1);
				temp3 = listbox.GetItemText(i,2);
				temp4 = listbox.GetItemText(i,3);
				temp5 = listbox.GetItemText(i,4);
				SetItemText(listbox,i,0,listbox.GetItemText(j,0));
				SetItemText(listbox,i,1,listbox.GetItemText(j,1));
				SetItemText(listbox,i,2,listbox.GetItemText(j,2));
				SetItemText(listbox,i,3,listbox.GetItemText(j,3));
				SetItemText(listbox,i,4,listbox.GetItemText(j,4));
				SetItemText(listbox,j,0,temp1);
				SetItemText(listbox,j,1,temp2);
				SetItemText(listbox,j,2,temp3);
				SetItemText(listbox,j,3,temp4);
				SetItemText(listbox,j,4,temp5);
			}
		}
	}
}

void QuickSort(CListCtrl & listbox,int col,bool order,int p,int r)
{
	int q;
	if (p<r)
	{
		q=	Partition(listBox,col,order,p,q);
		QuickSort(listBox,col,order,p,q);
		QuickSort(listBox,col,order,q+1,r);
	}
}
void sort(CListCtrl & listbox,int col,bool order)
{
	CWaitCursor w;
	QuickSort(listBox,col,order,1,listBox.GetItemCount());
}*/
void OnBROWSE(HWND hwndDlg,int id)
{
	TCHAR path[MAX_PATH]; 
	CString path2, sTitle; 
	BROWSEINFO b;

	ZeroMemory(&b, sizeof(b));
	sTitle.LoadString(IDS_BROWSE_REPORT_TITLE);
	b.hwndOwner=hwndDlg; 
    b.pidlRoot=NULL; 
    b.pszDisplayName=path; 
    b.lpszTitle=(LPCTSTR)sTitle; 
    b.lpfn=NULL; 
    b.lParam=NULL; 
    b.iImage=NULL; 
/**/b.ulFlags=0; //PRT - 4/3 
	LPITEMIDLIST l = SHBrowseForFolder(&b);
	SHGetPathFromIDList(l,path2.GetBuffer(1000));
	path2.ReleaseBuffer();
	SetDlgItemText(hwndDlg,id,path2.GetBuffer(1000));
	path2.ReleaseBuffer();
}


bool administrator(CString m_Computer,HRESULT& hr)
{
    hr = S_OK;

    return true;
}
HRESULT validDomain(CString m_Computer,bool& isNt4)
{
	IAccessCheckerPtr            pAccess;
	HRESULT                      hr;
	unsigned long     maj,min,sp;
	hr = pAccess.CreateInstance(CLSID_AccessChecker);
	hr = pAccess->raw_GetOsVersion(_bstr_t(m_Computer),&maj,&min,&sp);
	maj<5 ? isNt4=true :isNt4=false;
	return hr;
}

bool targetNativeMode(_bstr_t b,HRESULT& hr)
{
	IAccessCheckerPtr            pAccess;
	hr = pAccess.CreateInstance(CLSID_AccessChecker);
	BOOL bTgtNative=FALSE; 
	hr=pAccess->raw_IsNativeMode(b, (long*)&bTgtNative);
	return ( bTgtNative != FALSE);
}
bool CheckSameForest(CString& domain1,CString& domain2,HRESULT& hr)
{
	IAccessCheckerPtr            pAccess;
	hr = pAccess.CreateInstance(CLSID_AccessChecker);
	BOOL pbIsSame=FALSE;
	hr = pAccess->raw_IsInSameForest(_bstr_t(domain1), _bstr_t(domain2), (long *) &pbIsSame);
	return (pbIsSame!=FALSE);
}


HRESULT doSidHistory(HWND hwndDlg) 
{
    CWaitCursor                 c;
    IAccessCheckerPtr           pAC;
    HRESULT                     hr;
    CString                     info=L"";
    long                        bIs=0;
    DWORD                       dwStatus = 0;

    hr = pAC.CreateInstance(CLSID_AccessChecker);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Retrieve name of preferred target domain controller.
    //

    if (targetServer.IsEmpty())
    {
        _bstr_t strDcDns;
        _bstr_t strDcFlat;

        DWORD dwError = GetDcName5(GetTargetDomainName(), DS_DIRECTORY_SERVICE_REQUIRED, strDcDns, strDcFlat);

        if (dwError != ERROR_SUCCESS)
        {
            return HRESULT_FROM_WIN32(dwError);
        }

        targetServer = (LPCTSTR)strDcFlat;
        targetServerDns = (LPCTSTR)strDcDns;
    }

    hr = pAC->raw_CanUseAddSidHistory(
        _bstr_t(GetSourceDomainName()),
        _bstr_t(GetTargetDomainName()),
        _bstr_t(GetTargetDcName()),
        &bIs
    );

    if ( SUCCEEDED(hr) )
    {
        if ( bIs == 0 )
        {
            return S_OK;
        }
        else
        {
            // get primary domain controller in source domain

            _bstr_t sourceDomainController;

            dwStatus = GetDcName5(GetSourceDomainName(), DS_PDC_REQUIRED, sourceDomainController);

            if (dwStatus != NO_ERROR)
		    {
		       hr = HRESULT_FROM_WIN32(dwStatus);
		       return hr;
		    }

            if ( bIs & F_NO_AUDITING_SOURCE )
            {
                info.LoadString(IDS_MSG_ENABLE_SOURCE);
                if (MessageBox(hwndDlg,info,0,MB_YESNOCANCEL|MB_ICONQUESTION) ==IDYES)
                {
                    hr = pAC->raw_EnableAuditing(sourceDomainController);
                    if(FAILED(hr)) return hr;
                }			   
                else return E_ABORT;
            }
            if ( bIs & F_NO_AUDITING_TARGET )
            {
                info.LoadString(IDS_MSG_ENABLE_TARGET);
                if (MessageBox(hwndDlg,info,0,MB_YESNOCANCEL|MB_ICONQUESTION) ==IDYES)
                {
                    hr = pAC->raw_EnableAuditing(_bstr_t(GetTargetDcName()));
                    if(FAILED(hr)) return hr;
                }			   
                else return E_ABORT;
            }
            if ( bIs & F_NO_LOCAL_GROUP )
            {
                CString info2;
                info2.LoadString(IDS_MSG_LOCAL_GROUP);
                info.Format(info2,GetSourceDomainNameFlat(),GetSourceDomainName());
                if (MessageBox(hwndDlg,info,0,MB_YESNOCANCEL|MB_ICONQUESTION) ==IDYES)
                {
                    hr = pAC->raw_AddLocalGroup(_bstr_t(GetSourceDomainNameFlat()), sourceDomainController);
                    if(FAILED(hr)) return hr;
                }			   
                else return E_ABORT;
            }

            if ( bIs & F_NO_REG_KEY )
            {
                info.LoadString(IDS_MSG_REGKEY);
                int bReboot=0;
                if (MessageBox(hwndDlg,info,0,MB_YESNOCANCEL|MB_ICONQUESTION) ==IDYES)
                {
                    CString msg;
                    info.LoadString(IDS_MSG_REBOOT_SID);
                    msg.Format((LPCTSTR)info, (LPCTSTR)sourceDomainController);
                    int answer = MessageBox(hwndDlg,msg,0,MB_YESNOCANCEL|MB_ICONQUESTION) ;
                    if (answer==IDYES) 
                        bReboot=1;
                    else if (answer==IDNO)
                        bReboot=0;
                    else 
                        return E_ABORT;

                    hr = pAC->raw_AddRegKey(sourceDomainController,bReboot);
                    if(FAILED(hr)) return hr;

                    //
                    // If domain controller has been re-started then warn user to wait
                    // for domain controller to re-start before continuing.
                    //

                    if (bReboot)
                    {
                        CString strTitle;
                        strTitle.LoadString(IDS_MSG_WARNING);
                        msg.Format(IDS_MSG_WAIT_FOR_RESTART, (LPCTSTR)sourceDomainController);
                        MessageBox(hwndDlg, msg, strTitle, MB_OK|MB_ICONWARNING);
                    }
                }			   
                else return E_ABORT;
            }

            if ( bIs & F_NOT_DOMAIN_ADMIN )
            {
                CString strMessage;
                strMessage.LoadString(IDS_MSG_TARGET_DOMAIN_ADMIN);
                MessageBox(hwndDlg, strMessage, 0, MB_OK|MB_ICONERROR);
                return E_ABORT;
            }

            return S_OK;
        }
    }
    else
    {
        if (HRESULT_CODE(hr) == ERROR_BAD_NETPATH)
        {
            CString msg;
            info.LoadString(IDS_MSG_SIDHISTORY_NO_PDC);
            msg.Format((LPCTSTR)info, GetSourceDomainName());
            MessageBox(hwndDlg,msg,0,MB_ICONSTOP);
            return E_ABORT;
        }
        else
        {
            CString msg;
            info.LoadString(IDS_MSG_SID_HISTORY);
            msg.Format((LPCTSTR)info, _com_error(hr).ErrorMessage());
            MessageBox(hwndDlg,msg,0,MB_ICONSTOP);
            return E_ABORT;
        }
    }
}

//----------------------------------------------------------------------------
// GetDomainInfoFromActionHistory Function
//
// Synopsis
// Retrieves a domain's name and SID information from the database.
//
// Arguments
// IN  pszName        - either a DNS or NetBIOS domain name
// OUT pszNetBiosName - domain NetBIOS name
// OUT pszDnsName     - domain DNS name
// OUT pszSid         - domain SID
// OUT pbSetForest    - whether forest value was set
// OUT pbSetSrcOS     - whether source OS version was set
//
// Note that function assumes that buffers are large enough.
//----------------------------------------------------------------------------

void GetDomainInfoFromActionHistory
    (
    PCWSTR pszName,
	PWSTR pszNetBiosName, 
	PWSTR pszDnsName, 
	PWSTR pszSid, 
	bool* pbSetForest, 
	bool* pbSetSrcOS, 
	LPSHAREDWIZDATA pdata
    )
{
    //
    // retrieve source domain information from database
    //

    IVarSetPtr spVarSet = db->GetSourceDomainInfo(_bstr_t(pszName));

    if (spVarSet)
    {
        //
        // if information retrieved then copy to buffers
        //

        _bstr_t strFlatName = spVarSet->get(_T("Options.SourceDomain"));
        _bstr_t strDnsName = spVarSet->get(_T("Options.SourceDomainDns"));
        _bstr_t strSid = spVarSet->get(_T("Options.SourceDomainSid"));

        wcscpy(pszNetBiosName, strFlatName.length() ? strFlatName : L"");
        wcscpy(pszDnsName, strDnsName.length() ? strDnsName : L"");
        wcscpy(pszSid, strSid.length() ? strSid : L"");

        //
        // note that for security translation that
        // the following information is not important
        //
        // therefore assume that the domains were not in the same forest
        //
        // the DNS name is set equal to the NetBIOS name for NT4 domains therefore
        // assume that source domain was NT4 if DNS and NetBIOS names are same
        //

        *pbSetForest = true;
        *pbSetSrcOS = true;

        pdata->sameForest = false;
        pdata->sourceIsNT4 = (strFlatName == strDnsName);
    }
    else
    {
        *pszNetBiosName = L'\0';
        *pszDnsName = L'\0';
        *pszSid = L'\0';
    }
}

void cleanNames()
{
	sourceDNS=L"";
	sourceNetbios=L"";
	targetNetbios=L"";
	targetDNS=L"";
}

bool verifyprivs(HWND hwndDlg,CString& sourceDomainController,CString& targetDomainController,LPSHAREDWIZDATA& pdata)
{
    CWaitCursor wait;
    CString temp,temp2;
    HRESULT hr;
    bool result;
    DWORD dwResult = NO_ERROR;
    GetDlgItemText( hwndDlg, IDC_EDIT_DOMAIN, temp.GetBuffer(1000),1000);
    GetDlgItemText( hwndDlg, IDC_EDIT_DOMAIN2, temp2.GetBuffer(1000),1000);
    temp.ReleaseBuffer();
    temp2.ReleaseBuffer();

    temp.TrimLeft();temp.TrimRight();
    temp2.TrimLeft();temp2.TrimRight();
    // if the source domain has changed...
    if ( temp.CompareNoCase(sourceDNS) && temp.CompareNoCase(sourceNetbios) )
    {
        pdata->newSource = true;
        // Get the DNS and Netbios names for the domain name the user has entered
    }
    else
    {
        pdata->newSource = false;
    }

    _bstr_t strFlatName;
    _bstr_t strDnsName;

    dwResult = GetDomainNames5(temp, strFlatName, strDnsName);
    if(dwResult != NO_ERROR)
    {
        ErrorWrapper3(hwndDlg,dwResult,temp);
        if ( gbNeedToVerify )
        {
            cleanNames();
            return false;
        }

    }
    sourceDNS = (LPCTSTR)strDnsName;
    sourceNetbios = (LPCTSTR)strFlatName;

    dwResult = GetDomainNames5(temp2, strFlatName, strDnsName);
    if(dwResult != NO_ERROR)
    {
        ErrorWrapper3(hwndDlg,dwResult,temp2);
        if ( gbNeedToVerify )
        {
            cleanNames();
            return false;
        }

    }
    targetDNS = (LPCTSTR)strDnsName;
    targetNetbios = (LPCTSTR)strFlatName;

    if (!sourceNetbios.CompareNoCase(targetNetbios) || !sourceDNS.CompareNoCase(targetDNS))
    {
        MessageBoxWrapper3(hwndDlg,IDS_MSG_UNIQUE,IDS_MSG_ERROR,temp);
        cleanNames();
        return false;
    }

    _bstr_t text =get(DCTVS_Options_TargetDomain);
    CString tocheck = (WCHAR * const) text;
    tocheck.TrimLeft();tocheck.TrimRight();
    pdata->resetOUPATH = !tocheck.CompareNoCase(GetTargetDomainName())  ?  false: true;

    _bstr_t strDc;

    DWORD res = GetDcName5(GetSourceDomainName(), DS_DIRECTORY_SERVICE_PREFERRED, strDc);

    if (res!=NO_ERROR)
    {
        ErrorWrapper3(hwndDlg,HRESULT_FROM_WIN32(res),temp);
        if ( gbNeedToVerify )
        {
            cleanNames();
            return false;
        }
    }
    else
    {
        sourceDomainController = (LPCTSTR)strDc;
    }

    res = GetDcName5(GetTargetDomainName(), DS_DIRECTORY_SERVICE_REQUIRED, strDc);

    if (res!=NO_ERROR)
    {
        ErrorWrapper3(hwndDlg,HRESULT_FROM_WIN32(res),temp2);
        if ( gbNeedToVerify )
        {
            cleanNames();
            return false;
        }
    }
    else
    {
        targetDomainController = (LPCTSTR)strDc;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    bool nothing;
    hr =validDomain(sourceDomainController,pdata->sourceIsNT4);
    if (!SUCCEEDED(hr))
    {
        ErrorWrapper3(hwndDlg,hr,temp);
        if ( gbNeedToVerify )
        {
            cleanNames();
            return false;
        }
    }

    hr =validDomain(targetDomainController,nothing);
    if (!SUCCEEDED(hr))
    {
        ErrorWrapper3(hwndDlg,hr,temp2);
        if ( gbNeedToVerify )
        {
            cleanNames();

            return false;
        }
    }


    result = administrator(sourceDomainController,hr);
    if (!SUCCEEDED(hr))
    {
        ErrorWrapper3(hwndDlg,hr,temp);
        if ( gbNeedToVerify )
        {		 		
            cleanNames();

            return false;
        }
    }
    else if (!result)
    {	
        MessageBoxWrapper3(hwndDlg,IDS_MSG_SOURCE_ADMIN,IDS_MSG_ERROR,temp);
        if ( gbNeedToVerify )
        {
            cleanNames();

            return false;
        }
    }

    result=administrator(targetDomainController,hr);
    if (!SUCCEEDED(hr))
    {
        ErrorWrapper3(hwndDlg,hr,temp2);
        if ( gbNeedToVerify )
        {
            cleanNames();

            return false;
        }
    }
    else if (!result)
    {
        MessageBoxWrapper3(hwndDlg,IDS_MSG_TARGET_ADMIN,IDS_MSG_ERROR,temp2);
        if ( gbNeedToVerify )
        {
            cleanNames();

            return false;
        }
    }

    result=targetNativeMode(GetTargetDomainName(),hr);

    if (!SUCCEEDED(hr))
    {
        ErrorWrapper3(hwndDlg,hr,temp2);
        if ( gbNeedToVerify )
        {
            cleanNames();

            return false;
        }
    }
    else if (!result)
    {
        MessageBoxWrapper3(hwndDlg,IDS_MSG_TARGET_NATIVE,IDS_MSG_ERROR,temp2);
        if ( gbNeedToVerify )
        {
            cleanNames();
            return false;
        }
    }

    if (pdata->sourceIsNT4) 
    {
        pdata->sameForest=false;
    }
    else
    {
        pdata->sameForest=CheckSameForest(CString(GetSourceDomainName()),CString(GetTargetDomainName()),hr);
        if (!SUCCEEDED(hr))
        {
            ErrorWrapper3(hwndDlg,hr,temp);
            if ( gbNeedToVerify )
            {
                cleanNames();

                return false;
            }
        }
    }

    pdata->sameForest ?	put(DCTVS_Options_IsIntraforest,yes) : put(DCTVS_Options_IsIntraforest,no);
    return true;
}

bool verifyprivs2(HWND hwndDlg,CString& additionalDomainController,CString domainName)
{
    CWaitCursor w;

	_bstr_t strDc;

	DWORD dwResult = GetDcName5(domainName, DS_DIRECTORY_SERVICE_PREFERRED, strDc);
	if (dwResult!=NO_ERROR)
	{
		ErrorWrapper3(hwndDlg,HRESULT_FROM_WIN32(dwResult),domainName);
		if ( gbNeedToVerify )
			return false;
	}
	else
	{
		additionalDomainController = (LPCTSTR)strDc;
	}
	

	bool nothing;
	HRESULT	hr =validDomain(additionalDomainController,nothing);
	if (!SUCCEEDED(hr))
	{
		ErrorWrapper3(hwndDlg,hr,domainName);
		if ( gbNeedToVerify )
			return false;
	}

	HRESULT	result = administrator(additionalDomainController,hr);
	if (!SUCCEEDED(hr))
	{
	ErrorWrapper3(hwndDlg,hr,domainName);
		if ( gbNeedToVerify )
			return false;
	}
	else if (!result)
	{	
		MessageBoxWrapper3(hwndDlg,IDS_MSG_SOURCE_ADMIN,IDS_MSG_ERROR,domainName);
		if ( gbNeedToVerify )
			return false;
	}

	return true;
}

bool verifyprivsSTW(HWND hwndDlg,CString& sourceDomainController,CString& targetDomainController,LPSHAREDWIZDATA& pdata)
{
	CWaitCursor wait;
	CString temp,temp2;
	HRESULT hr;
	bool result, bSetSrcOS, bSetForest;
    WCHAR txtSid[MAX_PATH] = L"";
    DWORD dwResult = NO_ERROR;

	GetDlgItemText( hwndDlg, IDC_EDIT_DOMAIN, temp.GetBuffer(1000),1000);
	GetDlgItemText( hwndDlg, IDC_EDIT_DOMAIN2, temp2.GetBuffer(1000),1000);
	temp.ReleaseBuffer();
	temp2.ReleaseBuffer();
	
	temp.TrimLeft();temp.TrimRight();
	temp2.TrimLeft();temp2.TrimRight();
	// if the source domain has changed...
	if ( temp.CompareNoCase(sourceDNS) && temp.CompareNoCase(sourceNetbios) )
	{
		pdata->newSource = true;
		// Get the DNS and Netbios names for the domain name the user has entered
	}
	else
	{
		pdata->newSource = false;
	}

    _bstr_t strFlatName;
    _bstr_t strDnsName;

	dwResult = GetDomainNames5(temp2, strFlatName, strDnsName);
	if(dwResult != NO_ERROR)
	{
	    ErrorWrapper3(hwndDlg,dwResult,temp);
		cleanNames();
		return false;		
	    
	}

	targetNetbios = (LPCTSTR)strFlatName;
	targetDNS = (LPCTSTR)strDnsName;

	//
	// attempt to retrieve source domain information from the domain first
    // if unsuccessful then retrieve the information from the database
	//

	if (GetDomainNames5(temp, strFlatName, strDnsName) == NO_ERROR)
    {
	    sourceNetbios = (LPCTSTR)strFlatName;
	    sourceDNS = (LPCTSTR)strDnsName;
    }
    else
	{
	    GetDomainInfoFromActionHistory(
            &*temp,
            sourceNetbios.GetBuffer(1000),
            sourceDNS.GetBuffer(1000), 
			txtSid,
            &bSetForest,
            &bSetSrcOS,
            pdata
        );

	    sourceDNS.ReleaseBuffer();
	    sourceNetbios.ReleaseBuffer();
    }

	if ((sourceNetbios.IsEmpty()) && (sourceDNS.IsEmpty()))
	{
		MessageBoxWrapper3(hwndDlg,IDS_MSG_NOOBJECTS,IDS_MSG_ERROR,temp);
		cleanNames();
		return false;
	}

	if (!sourceNetbios.CompareNoCase(targetNetbios) || !sourceDNS.CompareNoCase(targetDNS))
	{
		MessageBoxWrapper3(hwndDlg,IDS_MSG_UNIQUE,IDS_MSG_ERROR,temp);
		cleanNames();
		return false;
	}

	   //get the source domain's sid, display
	   //message if no sid
	if (wcslen(txtSid) > 0)
         pVarSet->put(GET_BSTR(DCTVS_Options_SourceDomainSid),txtSid);
	else
	{
       PSID                      pSid = NULL;
       _bstr_t                   domctrl;
       DWORD                     lenTxt = DIM(txtSid);
	   BOOL						 bFailed = TRUE;

		  //try to get it from the source domain directly
       if (GetDcName5(GetSourceDomainName(), DS_DIRECTORY_SERVICE_PREFERRED, domctrl) == ERROR_SUCCESS)
	   {
	      if(GetDomainSid(domctrl,&pSid))
		  {
             if (GetTextualSid(pSid,txtSid,&lenTxt))
			 {
				    //add the sid to the varset
                 pVarSet->put(GET_BSTR(DCTVS_Options_SourceDomainSid),txtSid);
				    //populate the MigratedObjects table with this sid
				 db->PopulateSrcSidColumnByDomain(GetSourceDomainName(), _bstr_t(txtSid));
				 bFailed = FALSE;
			 }
			 if (pSid)
			    FreeSid(pSid);
		  }
	   }
	   if (bFailed)
	   {
	      MessageBoxWrapper3(hwndDlg,IDS_MSG_NOSOURCESID,IDS_MSG_ERROR,temp);
	      cleanNames();
	      return false;
	   }
	}
	
	_bstr_t text =get(DCTVS_Options_TargetDomain);
	CString tocheck = (WCHAR * const) text;
	tocheck.TrimLeft();tocheck.TrimRight();
	pdata->resetOUPATH = !tocheck.CompareNoCase(GetTargetDomainName())  ?  false: true;

	_bstr_t strDc;

	DWORD res = GetDcName5(GetSourceDomainName(), DS_DIRECTORY_SERVICE_PREFERRED, strDc); 
	if (res==NO_ERROR)
	{
		sourceDomainController = (LPCTSTR)strDc;
	}

	res = GetDcName5(GetTargetDomainName(), DS_DIRECTORY_SERVICE_REQUIRED, strDc);
	if (res!=NO_ERROR)
	{
		ErrorWrapper3(hwndDlg,HRESULT_FROM_WIN32(res),temp2);
		if ( gbNeedToVerify )
		{
			cleanNames();
			return false;
		}
	}
	else
	{
		targetDomainController = (LPCTSTR)strDc;
	}
	///////////////////////////////////////////////////////////////////////////////////////////
    bool nothing;

		//if we were not able to determine the source domain's OS from the
		//Action History table and we did get the source DC name, try to do 
		//it here.  This will work if the source domain still exists.  If 
		//the source domain no longer exists, set default.
	if ((!bSetSrcOS) && (!sourceDomainController.IsEmpty()))
	{
	   hr =validDomain(sourceDomainController,pdata->sourceIsNT4);
	   if (!SUCCEEDED(hr))
		   pdata->sourceIsNT4 = true;
	}

	hr =validDomain(targetDomainController,nothing);
	if (!SUCCEEDED(hr))
	{
		ErrorWrapper3(hwndDlg,hr,temp2);
		if ( gbNeedToVerify )
		{
			cleanNames();
			
			return false;
		}
	}
	
	result=administrator(targetDomainController,hr);
	if (!SUCCEEDED(hr))
	{
		ErrorWrapper3(hwndDlg,hr,temp2);
		if ( gbNeedToVerify )
		{	
			cleanNames();
		
		return false;
		}
	}
	else if (!result)
	{	
		MessageBoxWrapper3(hwndDlg,IDS_MSG_TARGET_ADMIN,IDS_MSG_ERROR,temp2);
		if ( gbNeedToVerify )
		{	
			cleanNames();
		    return false;
		}	
	}

	result=targetNativeMode(GetTargetDomainName(),hr);

	if (!SUCCEEDED(hr))
	{
		ErrorWrapper3(hwndDlg,hr,temp2);
		if ( gbNeedToVerify )
		{	
			cleanNames();
		
		return false;
		}
	}
	else if (!result)
	{
		MessageBoxWrapper3(hwndDlg,IDS_MSG_TARGET_NATIVE,IDS_MSG_ERROR,temp2);
		if ( gbNeedToVerify )
		{
			cleanNames();
			return false;
		}
	}
	
		//if we were not able to set the intraforest boolean variable by looking at 
		//the Action History table, then try to find out here.  This will not work 
		//if the source domain no longer exists, in which case we set it to a default 
		//value.
	if (!bSetForest)
	{
	   if (pdata->sourceIsNT4) 
	   {
		  pdata->sameForest=false;
	   }
	   else
	   {
		  pdata->sameForest=CheckSameForest(CString(GetSourceDomainName()),CString(GetTargetDomainName()),hr);
		  if (!SUCCEEDED(hr))
		  { 
			  //if we cannot figure it out, assume it is intra-forest so we
			  //will prompt for target domain credentials
		     pdata->sameForest=true;
		  }
	   }
	}

    pdata->sameForest ?	put(DCTVS_Options_IsIntraforest,yes) : put(DCTVS_Options_IsIntraforest,no);
    return true;
}


//-----------------------------------------------------------------------------
// VerifyCallerDelegated Method
//
// Synopsis
// If an intra-forest move operation is being performed then verify that the
// calling user's account has not been marked as sensitive and therefore
// cannot be delegated. As the move operation is performed on the domain
// controller which has the RID master role in the source domain it is
// necessary to delegate the user's security context.
//
// Arguments
// hwndDlg - handle to wizard page dialog window
// pdata   - pointer to shared wizard data
//
// Return Value
// The returned boolean value is true if caller's account may be delegated
// otherwise false.
//-----------------------------------------------------------------------------

bool __stdcall VerifyCallerDelegated(HWND hwndDlg, LPSHAREDWIZDATA pdata)
{
    bool bDelegated = true;

    //
    // It is only necessary to check this for intra-forest.
    //

    if (pdata->sameForest)
    {
        bool bDelegatable = false;

        HRESULT hr = IsCallerDelegatable(bDelegatable);

        if (SUCCEEDED(hr))
        {
            if (bDelegatable == false)
            {
                //
                // Caller's account is not delegatable. Retrieve name of domain controller
                // in the source domain that holds the RID master role and the name of this
                // computer.
                //

                _bstr_t strDnsName;
                _bstr_t strFlatName;

                hr = GetRidPoolAllocator4(GetSourceDomainName(), strDnsName, strFlatName);

                if (SUCCEEDED(hr))
                {
                    _TCHAR szComputerName[MAX_PATH];
                    DWORD cchComputerName = sizeof(szComputerName) / sizeof(szComputerName[0]);

                    if (GetComputerNameEx(ComputerNameDnsFullyQualified, szComputerName, &cchComputerName))
                    {
                        //
                        // If this computer is not the domain controller holding the
                        // RID master role in the source domain then generate error.
                        //

                        if (_tcsicmp(szComputerName, strDnsName) != 0)
                        {
                            MessageBoxWrapper(hwndDlg, IDS_MSG_CALLER_NOT_DELEGATED, IDS_MSG_ERROR);
                            bDelegated = false;
                        }
                    }
                    else
                    {
                        DWORD dwError = GetLastError();
                        hr = HRESULT_FROM_WIN32(dwError);
                    }
                }
            }
        }

        if (FAILED(hr))
        {
            CString strTitle;
            strTitle.LoadString(AFX_IDS_APP_TITLE);
            CString strFormat;
            strFormat.LoadString(IDS_MSG_UNABLE_VERIFY_CALLER_NOT_DELEGATED);
            CString strMessage;
            strMessage.Format(strFormat, _com_error(hr).ErrorMessage());
            MessageBox(hwndDlg, strMessage, strTitle, MB_ICONWARNING | MB_OK);
        }
    }

    return bDelegated;
}

void OnADD(HWND hwndDlg,bool sourceIsNT4)
{

	HRESULT hr = pDsObjectPicker->InvokeDialog(hwndDlg, &pdo);
	if (FAILED(hr)) return;	 
	if (hr == S_OK) {
		ProcessSelectedObjects(pdo,hwndDlg,sourceIsNT4);
		pdo->Release();
	}
}

bool GetCheck(CListCtrl & yo,int nItem)
{

	UINT nState = yo.GetItemState(nItem,LVIS_CUT);
	return (nState ? false: true);	
}
void SetCheck(CListCtrl & yo,int nItem,bool checkit)
{
	!checkit	? yo.SetItemState(nItem,LVIS_CUT,LVIS_CUT) : yo.SetItemState(nItem,0,LVIS_CUT); 
}

void SetItemText(CListCtrl& yo, int nItem, int subItem,CString& text)
{
CString f;
	LV_ITEM lvItem;
	ZeroMemory(&lvItem, sizeof(lvItem));
	lvItem.mask = LVIF_TEXT;
	
	lvItem.iItem = nItem;
	lvItem.iSubItem= subItem;
	
	f= text;
	lvItem.pszText = f.GetBuffer(1000);
	f.ReleaseBuffer();
	yo.SetItem(&lvItem); 
}

void SetItemText(CListCtrl& yo, int nItem, int subItem,TCHAR * text)
{
	CString temp = text;
	SetItemText(yo,nItem,subItem,temp);
}
void SetItemText(CListCtrl& yo, int nItem, int subItem,TCHAR const * text)
{
	CString temp = text;
	SetItemText(yo,nItem,subItem,temp);
}

void SetItemText(CListCtrl& yo, int nItem, int subItem,_bstr_t text)
{
	CString temp = (WCHAR * const) text;
	SetItemText(yo,nItem,subItem,temp);
}

void OnREMOVE(HWND hwndDlg) 
{
	int nItem;
//	POSITION pos = m_listBox.GetFirstSelectedItemPosition();
//	while (pos)
//	{
//		nItem = m_listBox.GetNextSelectedItem(pos);
	nItem = m_listBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	while (nItem != -1)//PRT
	{
		SetCheck(m_listBox,nItem,false);
		nItem = m_listBox.GetNextItem(nItem, LVNI_SELECTED);//PRT
	}
	
	for (int i=(m_listBox.GetItemCount()-1);i>=0;i--)
		if (!GetCheck(m_listBox,i))
			m_listBox.DeleteItem(i);
}	

void OnMIGRATE(HWND hwndDlg,int& accounts,int&servers)
{
	CString name,nameDns,spruced_name,varset_1,upnName;
	accounts=0,servers=0;
	int intCount=m_listBox.GetItemCount();
	CString n;
	for (int i=0;i<intCount;i++) 
	{
		if (migration==w_computer || (migration ==w_security || 
			(migration == w_reporting || migration == w_service)))
		{
            name= m_listBox.GetItemText(i, 2);
			spruced_name = L"\\\\" + name;
			varset_1.Format(L"Servers.%d",servers);
			pVarSet->put(_bstr_t(varset_1),_bstr_t(spruced_name));
			
            // DNS Name
            nameDns = m_listBox.GetItemText(i, 4);

            if (nameDns.IsEmpty() == FALSE)
            {
			    spruced_name = L"\\\\" + nameDns;
			    pVarSet->put(_bstr_t(varset_1 + L".DnsName"), _bstr_t(spruced_name));
            }

			pVarSet->put(_bstr_t(varset_1 + L".MigrateOnly"),no);
			if (migration==w_computer)
				pVarSet->put(_bstr_t(varset_1 + L".MoveToTarget"),yes);
			else if (migration==w_security)
			{
				pVarSet->put(_bstr_t(varset_1 + L".Reboot"),no);
				pVarSet->put(_bstr_t(varset_1 + L".MoveToTarget"),no);
			}
			servers++;
		}
		else
		{
			name= m_listBox.GetItemText(i,1);
			upnName = m_listBox.GetItemText(i,4);
		}
		
		
		if (name.IsEmpty())
		{
			MessageBoxWrapper(hwndDlg,IDS_MSG_PATH,IDS_MSG_ERROR);
		}
		
		varset_1.Format(L"Accounts.%d",accounts);	
		pVarSet->put(_bstr_t(varset_1),_bstr_t(name));
		pVarSet->put(_bstr_t(varset_1+".TargetName"),L"");
		switch(migration)
		{
		case w_account:
			pVarSet->put(_bstr_t(varset_1+L".Type"),L"user");
			pVarSet->put(_bstr_t(varset_1+L".UPNName"),_bstr_t(upnName));
			break;
		case w_group:pVarSet->put(_bstr_t(varset_1+L".Type"),L"group");break;
		case w_groupmapping:
			{
				pVarSet->put(_bstr_t(varset_1+L".Type"),L"group");
				_bstr_t temp = GET_BSTR(DCTVS_Accounts_D_OperationMask);
				CString holder = (WCHAR * const) temp;
				CString toenter;
				toenter.Format(holder,i);
				pVarSet->put(_bstr_t(toenter),(LONG)0x1d);				
				break;
			}
		case w_computer:pVarSet->put(_bstr_t(varset_1+L".Type"),L"computer");break;
		case w_security:pVarSet->put(_bstr_t(varset_1+L".Type"),L"computer");break;
		case w_reporting:pVarSet->put(_bstr_t(varset_1+L".Type"),L"computer");break;
		case w_service:pVarSet->put(_bstr_t(varset_1+L".Type"),L"computer");break;
		default: break;
		}
		
		n=m_listBox.GetItemText(i,0);
		if (migration==w_account) 
			pVarSet->put(_bstr_t(varset_1+L".Name"), _bstr_t(n));
		accounts++;
	}
	put(DCTVS_Accounts_NumItems,(LONG)accounts);
	put(DCTVS_Servers_NumItems,(LONG)servers);
}

HRESULT InitObjectPicker2(IDsObjectPicker *pDsObjectPicker,bool multiselect,CString targetComputer,bool sourceIsNT4) {
	static const int     SCOPE_INIT_COUNT = 2;
	
	DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];
	DSOP_INIT_INFO  InitInfo;
	ZeroMemory(aScopeInit, 
		sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);
	ZeroMemory(&InitInfo, sizeof(InitInfo));
	aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	InitInfo.cbSize = sizeof(InitInfo);
	
	aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;
	aScopeInit[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	aScopeInit[0].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP |DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT |DSOP_SCOPE_FLAG_STARTING_SCOPE;
	aScopeInit[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP |DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
	
	aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;	
	aScopeInit[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN 
		| DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
		| DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
		| DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE
		| DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE;
	InitInfo.pwzTargetComputer =  targetComputer.GetBuffer(1000);// Target is the local computer.
	targetComputer.ReleaseBuffer();
	InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
	InitInfo.aDsScopeInfos = aScopeInit;

	InitInfo.cAttributesToFetch = 3;
	InitInfo.apwzAttributeNames = new PCWSTR[3];
	InitInfo.apwzAttributeNames[0] =L"sAMAccountName";
	InitInfo.apwzAttributeNames[1] =L"description";
	InitInfo.apwzAttributeNames[2] =L"dNSHostName";

	if (multiselect)
		InitInfo.flOptions = DSOP_FLAG_MULTISELECT;	
	HRESULT hr= pDsObjectPicker->Initialize(&InitInfo);
	delete [] InitInfo.apwzAttributeNames;
	return hr;
}
HRESULT ReInitializeObjectPicker(IDsObjectPicker *pDsObjectPicker,bool multiselect,CString additionalDomainController,bool sourceIsNT4) 


{CWaitCursor c;
 // static const int     SCOPE_INIT_COUNT = 3;
static const int     SCOPE_INIT_COUNT = 2;
	DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];
	DSOP_INIT_INFO  InitInfo;
	ZeroMemory(aScopeInit, 
		sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);
	ZeroMemory(&InitInfo, sizeof(InitInfo));
	aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
//	aScopeInit[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	InitInfo.cbSize = sizeof(InitInfo);
	
	aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;
	aScopeInit[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;
//	aScopeInit[2].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
//	aScopeInit[2].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	aScopeInit[0].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP |DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT |DSOP_SCOPE_FLAG_STARTING_SCOPE;
	aScopeInit[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP |DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
//	aScopeInit[2].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP |DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
	
	aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;	
	aScopeInit[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN 
		| DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
		| DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
		| DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE
		| DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE;
//	aScopeInit[2].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;	
	InitInfo.pwzTargetComputer =  additionalDomainController.GetBuffer(1000);// Target is the local computer.
	additionalDomainController.ReleaseBuffer();
	InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
	InitInfo.aDsScopeInfos = aScopeInit;
	
	if (sourceIsNT4)
	{
	}
	else
	{
		InitInfo.cAttributesToFetch = 1;
		InitInfo.apwzAttributeNames = new PCWSTR[1];
		
		InitInfo.apwzAttributeNames[0] =L"Description";
		
	}		
	if (multiselect)
		InitInfo.flOptions = DSOP_FLAG_MULTISELECT;	
	HRESULT hr= pDsObjectPicker->Initialize(&InitInfo);
	return hr;
}


HRESULT InitObjectPicker(IDsObjectPicker *pDsObjectPicker,bool multiselect,CString targetComputer,bool sourceIsNT4) {
	static const int     SCOPE_INIT_COUNT = 1;

	DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];
	DSOP_INIT_INFO  InitInfo;
	ZeroMemory(aScopeInit, 
		sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);
	ZeroMemory(&InitInfo, sizeof(InitInfo));
	aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	InitInfo.cbSize = sizeof(InitInfo);
	aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
	aScopeInit[0].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP |DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
	
	if (migration==w_computer || (migration==w_security ||
		 (migration==w_service || migration==w_reporting))) 
	{
		aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
		aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;
	}
	else if (migration==w_account) 
	{
		aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
		aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
	}
	else if (migration==w_group || migration==w_groupmapping) 
	{
		aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_BUILTIN_GROUPS 
			| DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_UNIVERSAL_GROUPS_DL 
			| DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_GLOBAL_GROUPS_DL
			| DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL;
		aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;
		
	}
	if  (migration==w_security || (migration==w_reporting || migration==w_service))
	{
		aScopeInit[0].flType |= DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN 
			| DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
			| DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
			| DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE
			| DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE /*| DSOP_SCOPE_TYPE_GLOBAL_CATALOG*/;
	}

	InitInfo.pwzTargetComputer =  targetComputer.GetBuffer(1000);// Target is the local computer.
	targetComputer.ReleaseBuffer();
	InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
	InitInfo.aDsScopeInfos = aScopeInit;

	if (sourceIsNT4)
	{
		if (migration==w_computer || (migration==w_security ||
			(migration==w_service || migration==w_reporting))) 
		{
			InitInfo.cAttributesToFetch = 2;
			InitInfo.apwzAttributeNames = new PCWSTR[2];
			InitInfo.apwzAttributeNames[0] =L"sAMAccountName";
			InitInfo.apwzAttributeNames[1] =L"description";
		}
		else if (migration==w_account)
		{
			InitInfo.cAttributesToFetch = 2;
			InitInfo.apwzAttributeNames = new PCWSTR[3];
			
			InitInfo.apwzAttributeNames[0] =L"FullName";
			InitInfo.apwzAttributeNames[1] =L"Description";
		}
		else if (migration==w_group || migration==w_groupmapping)
		{
			InitInfo.cAttributesToFetch = 1;
			InitInfo.apwzAttributeNames = new PCWSTR[1];
			
			InitInfo.apwzAttributeNames[0] =L"Description";
		}
	}
	else
	{
		if (migration==w_computer || (migration==w_security ||
			(migration==w_service || migration==w_reporting))) 
		{
			InitInfo.cAttributesToFetch = 3;
			InitInfo.apwzAttributeNames = new PCWSTR[3];
			
			InitInfo.apwzAttributeNames[0] =L"sAMAccountName";
			InitInfo.apwzAttributeNames[1] =L"Description";
			InitInfo.apwzAttributeNames[2] =L"dNSHostName";
		}
		else if (migration==w_account)
		{
			InitInfo.cAttributesToFetch = 2;
			InitInfo.apwzAttributeNames = new PCWSTR[2];
			
			InitInfo.apwzAttributeNames[0] =L"sAMAccountName";
			InitInfo.apwzAttributeNames[1] =L"Description";
		}
		else if (migration==w_group || migration==w_groupmapping)
		{
			InitInfo.cAttributesToFetch = 2;
			InitInfo.apwzAttributeNames = new PCWSTR[2];
			
			InitInfo.apwzAttributeNames[0] =L"sAMAccountName";
			InitInfo.apwzAttributeNames[1] =L"Description";
		}
	}		

	if (multiselect)
		InitInfo.flOptions = DSOP_FLAG_MULTISELECT;

	HRESULT hr= pDsObjectPicker->Initialize(&InitInfo);

	delete [] InitInfo.apwzAttributeNames;

	return hr;
}
bool DC(WCHAR* computerName,CString sourceDomainController)
{
	USER_INFO_1   * uinf1 = NULL;
	bool toreturn =false;
	NET_API_STATUS  rc = NetUserGetInfo(sourceDomainController.GetBuffer(1000),computerName,1,(LPBYTE*)&uinf1);
	sourceDomainController.ReleaseBuffer();
	if ( ! rc )
	{
		if ( uinf1->usri1_flags & UF_SERVER_TRUST_ACCOUNT ) 
		{ 
			toreturn = true;
		}
		NetApiBufferFree(&uinf1);
	}
	return toreturn;
}
bool inList(CString m_name)
{CString temp;
	m_name.TrimLeft();m_name.TrimRight();
	int length=m_listBox.GetItemCount();
	for (int i=0;i<length;i++)
	{
		temp=m_listBox.GetItemText(i,1);
		temp.TrimLeft();temp.TrimRight();
		if (!temp.CompareNoCase(m_name))return true;
	}
	return false;

}
void ProcessSelectedObjects(IDataObject *pdo,HWND hwndDlg,bool sourceIsNT4)
{
	HRESULT hr = S_OK;	BOOL fGotStgMedium = FALSE;	PDS_SELECTION_LIST pDsSelList = NULL;	ULONG i;
	STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL, NULL};
	FORMATETC formatetc = {(CLIPFORMAT) g_cfDsObjectPicker,NULL,DVASPECT_CONTENT,-1,TYMED_HGLOBAL};
	hr = pdo->GetData(&formatetc, &stgmedium);
	if (FAILED(hr)) return;
	fGotStgMedium = TRUE;		
	pDsSelList = (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);
	if (!pDsSelList) return;
	CString toinsert;
	WCHAR temp[10000];
	CString samName;
	CString upnName;
	bool atleast1dc=false;
	bool continue1;
	CString sourceDomainController;
	if (migration==w_computer)
	{
        _bstr_t strDc;
		DWORD res = GetDcName5(GetSourceDomainName(), DS_DIRECTORY_SERVICE_PREFERRED, strDc);
		sourceDomainController=(LPCTSTR)strDc;
	}
	_bstr_t yo;
	int a, ndx;
	for (i = 0; i < pDsSelList->cItems; i++)
	{
		continue1=true;
		toinsert = pDsSelList->aDsSelection[i].pwzName;
		samName = pDsSelList->aDsSelection[i].pwzADsPath;
		upnName = pDsSelList->aDsSelection[i].pwzUPN;
		swprintf(temp,L"%s",(toinsert+L"$"));

		if (migration ==w_computer) 
		{
			if (DC(temp,sourceDomainController))
			{
				atleast1dc = true;
				continue1=false;
			}
		}

		
		if (!inList(samName)&&continue1)
		{
			a = m_listBox.GetItemCount();
			ndx = m_listBox.InsertItem(a,toinsert);
			if (ndx == -1)
		       continue;
			SetItemText(m_listBox,ndx,1,samName);

            if (migration==w_computer || (migration==w_security || (migration==w_service || migration==w_reporting)))
			{
                // set SAM account name column
                // use sAMAccountName attribute if returned otherwise use name attribute
                // uplevel objects will have the sAMAccountName attribute defined whereas
                // downlevel objects will not have the sAMAccountName attribute defined but
                // instead the name attribute is the SAM account name

				_bstr_t strSamAccountName;

                if (pDsSelList->cFetchedAttributes > 0)
                {
                    VARIANT& varSamAccountName = pDsSelList->aDsSelection[i].pvarFetchedAttributes[0];

                    if ((V_VT(&varSamAccountName) == VT_BSTR) && (SysStringLen(V_BSTR(&varSamAccountName)) > 0))
                    {
                        strSamAccountName = V_BSTR(&varSamAccountName);

                        // remove trailing $ which indicates a computer account
                        // but ADMT core expects SAM name without $

                        if (strSamAccountName.length())
                        {
                            LPTSTR pch = (LPTSTR)strSamAccountName + strSamAccountName.length() - 1;

                            if (*pch == L'$')
                            {
                                *pch = L'\0';
                            }
                        }
                    }
                    else
                    {
                        strSamAccountName = toinsert;
                    }
                }
                else
                {
                    strSamAccountName = toinsert;
                }

				SetItemText(m_listBox, ndx, 2, strSamAccountName);

                // set description column

                if (pDsSelList->cFetchedAttributes > 1)
                {
                    VARIANT& varDescription = pDsSelList->aDsSelection[i].pvarFetchedAttributes[1];

                    if ((V_VT(&varDescription) == VT_BSTR) && (SysStringLen(V_BSTR(&varDescription)) > 0))
                    {
					    SetItemText(m_listBox, ndx, 3, _bstr_t(_variant_t(varDescription)));
                    }
                }

                // set DNS name column

                if (pDsSelList->cFetchedAttributes > 2)
                {
                    VARIANT& varDnsName = pDsSelList->aDsSelection[i].pvarFetchedAttributes[2];

                    if ((V_VT(&varDnsName) == VT_BSTR) && (SysStringLen(V_BSTR(&varDnsName)) > 0))
                    {
					    SetItemText(m_listBox, ndx, 4, _bstr_t(_variant_t(varDnsName)));
                    }
                }
			}
            else
            {
			    _variant_t v;

			    if (sourceIsNT4)
			    {
				    if (migration==w_account)
				    {				
					    
					    v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[0];
					    yo = (_bstr_t) v;
					    SetItemText(m_listBox,ndx,2,yo);					
					    v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[1];
					    yo = (_bstr_t) v;
					    SetItemText(m_listBox,ndx,3,yo);
				    }
				    else if (migration==w_group || migration==w_groupmapping)
				    {					
					    v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[0];
					    yo = (_bstr_t) v;
					    SetItemText(m_listBox,ndx,2,yo);
				    }
			    }
			    else
			    {
				    if (migration==w_account)
				    {	
					    v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[0];
					    yo = (_bstr_t) v;
					    SetItemText(m_listBox,ndx,2,yo);	
					    v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[1];
					    yo = (_bstr_t) v;
					    SetItemText(m_listBox,ndx,3,yo);
					    SetItemText(m_listBox,ndx,4,upnName);
				    }
				    else if (migration==w_group || migration==w_groupmapping)
				    {
					    
					    v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[0];
					    yo = (_bstr_t) v;
					    SetItemText(m_listBox,ndx,2,yo);					
					    v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[1];
					    yo = (_bstr_t) v;
					    SetItemText(m_listBox,ndx,3,yo);
				    }
			    }
            }
		}
	}

	GlobalUnlock(stgmedium.hGlobal);
	if (fGotStgMedium) 	ReleaseStgMedium(&stgmedium);	
	if (atleast1dc)
		MessageBoxWrapper(hwndDlg,IDS_MSG_DC,IDS_MSG_ERROR);
}

bool checkFile(HWND hwndDlg)
{
	CString h;GetDlgItemText(hwndDlg,IDC_PASSWORD_FILE,h.GetBuffer(1000),1000);h.ReleaseBuffer();
	CFileFind finder;

	bool exists = (finder.FindFile((LPCTSTR) h )!=0);
	if (exists)
	{
		finder.FindNextFile();
	    CString fullpath = finder.GetFilePath();
	    if (fullpath.GetLength() != 0)
		   SetDlgItemText(hwndDlg, IDC_PASSWORD_FILE, (LPCTSTR)fullpath);
		return !(finder.IsReadOnly()!=FALSE);
	}
	else
	{
		   //remove the file off the path
		int tosubtract = h.ReverseFind(L'\\');
		int tosubtract2 = h.ReverseFind(L'/');
		int final = (tosubtract > tosubtract2) ? tosubtract : tosubtract2;
		if ((final==-1) || ((final+1)==h.GetLength()))return false;

		CString dir = h.Left(final);
		CString filename = h.Right(h.GetLength()-final); //save the filename
		if ((dir.Right(1) == L':') && (validDir(dir)))
			return true;

		   //call the helper function to make sure the path exists
		CString sResult = CreatePath(dir);
		if (sResult.GetLength())
		{
			  //readd the filename to the resulting full path
		   sResult += filename;
		   SetDlgItemText(hwndDlg, IDC_PASSWORD_FILE, (LPCTSTR)sResult);
		   return true;
		}
		else
		   return false;
	}
}

void ProcessSelectedObjects2(IDataObject *pdo,HWND hwndDlg)
{
	HRESULT hr = S_OK;	BOOL fGotStgMedium = FALSE;	PDS_SELECTION_LIST pDsSelList = NULL;
	STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL, NULL};
	FORMATETC formatetc = {(CLIPFORMAT) g_cfDsObjectPicker,NULL,DVASPECT_CONTENT,-1,TYMED_HGLOBAL};
	hr = pdo->GetData(&formatetc, &stgmedium);
	if (FAILED(hr)) return;
	fGotStgMedium = TRUE;		
	pDsSelList = (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);
	if (!pDsSelList) return;

	SetDlgItemText(hwndDlg,IDC_TARGET_GROUP,pDsSelList->aDsSelection[0].pwzName);
		
	GlobalUnlock(stgmedium.hGlobal);
	if (fGotStgMedium) 	ReleaseStgMedium(&stgmedium);
}



void initpasswordbox(HWND hwndDlg,int id1,int id2,int id3, BSTR bstr1, BSTR bstr2)
{
	_bstr_t     text;
	
	text = pVarSet->get(bstr2);

	if (!UStrICmp(text,(WCHAR const *) yes))
	{
		CheckRadioButton(hwndDlg,id1,id3,id3);
	}
	else
	{
	   text = pVarSet->get(bstr1);
	
	   if (!UStrICmp(text,(WCHAR const *) yes))
	   {
		  CheckRadioButton(hwndDlg,id1,id3,id1);
	   }
	   else 
	   {
		  CheckRadioButton(hwndDlg,id1,id3,id2);
	   }
	}
}

void initdisablesrcbox(HWND hwndDlg)
{
	_bstr_t 	text;
	CString		toformat;
	
	   //init disable src checkbox
    initcheckbox(hwndDlg,IDC_SRC_DISABLE_ACCOUNTS,DCTVS_AccountOptions_DisableSourceAccounts);

	   //set whether to expire accounts
	text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExpireSourceAccounts));
       //if invalid expire time, don't check it, set to 30 days, and disable the 
	   //other sub controls
	if ((!UStrICmp(text, L"")) || ((_wtol(text) == 0) && (UStrICmp(text,L"0"))) || (_wtol(text) > THREE_YEARS))
	{
		CheckDlgButton(hwndDlg, IDC_SRC_EXPIRE_ACCOUNTS, BST_UNCHECKED);
	    toformat.LoadString(IDS_30);
	    SetDlgItemText(hwndDlg,IDC_yo,toformat);
	    calculateDate(hwndDlg,toformat);
	    disable(hwndDlg,IDC_yo);
		disable(hwndDlg,IDC_DATE);
		disable(hwndDlg,IDC_TEXT);
	}
	else //else, check it, set to valid days, and enable sub controls 
	{
		CheckDlgButton(hwndDlg, IDC_SRC_EXPIRE_ACCOUNTS, BST_CHECKED);
	    toformat = (WCHAR*)text;
	    SetDlgItemText(hwndDlg,IDC_yo,toformat);
	    calculateDate(hwndDlg,toformat);
	    enable(hwndDlg,IDC_yo);
		enable(hwndDlg,IDC_DATE);
		enable(hwndDlg,IDC_TEXT);
	}
}

void inittgtstatebox(HWND hwndDlg)
{
	_bstr_t 	text;
	
       //if "Same as source" was set, check it
	text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_TgtStateSameAsSrc));
	if (!UStrICmp(text,(WCHAR const *) yes))
		CheckRadioButton(hwndDlg,IDC_TGT_ENABLE_ACCOUNTS,IDC_TGT_SAME_AS_SOURCE,IDC_TGT_SAME_AS_SOURCE);
	else   //else set enable tgt or disable tgt
	{
		text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableCopiedAccounts));
		if (!UStrICmp(text,(WCHAR const *) yes))
			CheckRadioButton(hwndDlg,IDC_TGT_ENABLE_ACCOUNTS,IDC_TGT_SAME_AS_SOURCE,IDC_TGT_DISABLE_ACCOUNTS);
		else
			CheckRadioButton(hwndDlg,IDC_TGT_ENABLE_ACCOUNTS,IDC_TGT_SAME_AS_SOURCE,IDC_TGT_ENABLE_ACCOUNTS);
	}
}

void addrebootValues(HWND hwndDlg)
{
	HWND hLC3= GetDlgItem(hwndDlg,IDC_COMBO2);
	m_rebootBox.Attach(hLC3);
	m_rebootBox.AddString(GET_CSTRING(IDS_ONE));
	m_rebootBox.AddString(GET_CSTRING(IDS_FIVE));
	m_rebootBox.AddString(GET_CSTRING(IDS_TEN));
}

void inittranslationbox(HWND hwndDlg,int id1,int id2,int id3,int i,bool sameForest)
{
	_bstr_t     text;
	text = pVarSet->get(GET_BSTR(i));
	_bstr_t b=pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
HRESULT hr;
	if (sameForest && targetNativeMode(b,hr))
	{
		CheckRadioButton(hwndDlg,id1,id3,id1);
		disable(hwndDlg,id2);
		disable(hwndDlg,id3);
	}
	else
	{
	
//*	if (!UStrICmp(text,L"Replace"))
	if (!UStrICmp(text,GET_STRING(IDS_Replace)))
		CheckRadioButton(hwndDlg,id1,id3,id1);
//*	else if (!UStrICmp(text,L"Add"))
	else if (!UStrICmp(text,GET_STRING(IDS_Add)))
		CheckRadioButton(hwndDlg,id1,id3,id2);
//*	else if (!UStrICmp(text,L"Remove"))
	else if (!UStrICmp(text,GET_STRING(IDS_Remove)))
		CheckRadioButton(hwndDlg,id1,id3,id3);
	else
		CheckRadioButton(hwndDlg,id1,id3,id1);
}
}
void handleDB()
{
    _variant_t vntIdentifier = get(DCTVS_AccountOptions_SidHistoryCredentials_Password);
    put(DCTVS_AccountOptions_SidHistoryCredentials_Password,L"");
    put(DCTVS_GatherInformation, L"");
    db->SaveSettings(IUnknownPtr(pVarSet));
    put(DCTVS_AccountOptions_SidHistoryCredentials_Password, vntIdentifier);
}
void populateTime(long rebootDelay,int servers )
{
	
	_variant_t varX;
	CString temp;
	CString typeExtension;
	time_t ltime;
	
	
	if (migration==w_computer)
	{
		time(&ltime);
		
		rebootDelay = rebootDelay;
		
		temp.Format(L"%d",rebootDelay);	
		varX = temp;
		for (int i =0;i<servers;i++)
		{
			typeExtension.Format(L"Servers.%d.RebootDelay",i);	
			pVarSet->put(_bstr_t(typeExtension), varX);
			typeExtension.Format(L"Servers.%d.Reboot",i);
			pVarSet->put(_bstr_t(typeExtension),yes);
		}
	}
}


void initcheckbox(HWND hwndDlg,int id,int varsetKey)
{
	_bstr_t     text;
	
	text = pVarSet->get(GET_BSTR(varsetKey));
	CheckDlgButton( hwndDlg,id, !UStrICmp(text,(WCHAR const * ) yes));
}

void initeditbox(HWND hwndDlg,int id,int varsetKey)
{
	_bstr_t     text;
	
	text = pVarSet->get(GET_BSTR(varsetKey));
	SetDlgItemText( hwndDlg,id, (WCHAR const *) text);
}

void initeditboxPassword(HWND hwndDlg, int id, int varsetKey)
{
    WCHAR szPassword[LEN_Password];

    szPassword[0] = L'\0';

    _bstr_t strIdentifier = pVarSet->get(GET_BSTR(varsetKey));

    if (strIdentifier.length() > 0)
    {
        DWORD dwError = RetrievePassword(strIdentifier, szPassword, countof(szPassword));

        if (dwError != ERROR_SUCCESS)
        {
            StorePassword(strIdentifier, NULL);
            pVarSet->put(GET_BSTR(varsetKey), L"");
        }
    }

    SetDlgItemText(hwndDlg, id, szPassword);

    SecureZeroMemory(szPassword, sizeof(szPassword));
}


void checkbox(HWND hwndDlg,int id,int varsetKey)
{
	_variant_t varX;
	varX = IsDlgButtonChecked( hwndDlg,id) ?  yes : no;
	pVarSet->put(GET_BSTR(varsetKey), varX);
}
void editbox(HWND hwndDlg,int id,int varsetKey)
{
	_variant_t varX;
	CString temp;
	GetDlgItemText( hwndDlg, id, temp.GetBuffer(1000),1000);
	temp.ReleaseBuffer();
	varX = temp;
	pVarSet->put(GET_BSTR(varsetKey), varX); 
}

void editboxPassword(HWND hwndDlg, int id, int varsetKey)
{
    //
    // Retrieve password from editbox.
    //

    WCHAR szPassword[LEN_Password];

    int cch = GetDlgItemText(hwndDlg, id, szPassword, countof(szPassword));

    if (cch > 0)
    {
        if (cch < countof(szPassword))
        {
            //
            // Retrieve password identifier. If not defined then generate new identifier.
            //

            _bstr_t strIdentifier = pVarSet->get(GET_BSTR(varsetKey));

            if (strIdentifier.length() == 0)
            {
                WCHAR szIdentifier[256];

                DWORD dwError = GeneratePasswordIdentifier(szIdentifier, countof(szIdentifier));

                if (dwError == ERROR_SUCCESS)
                {
                    strIdentifier = szIdentifier;
                }
                else
                {
                    MessageBoxWrapper(hwndDlg, IDS_MSG_UNABLE_RETRIEVE_STORE_PASSWORD, IDS_MSG_ERROR);
                }
            }

            //
            // If identifier then store password.
            //

            if (strIdentifier.length() > 0)
            {
                DWORD dwError = StorePassword(strIdentifier, szPassword);

                if (dwError == ERROR_SUCCESS)
                {
                    pVarSet->put(GET_BSTR(varsetKey), strIdentifier);
                }
                else
                {
                    StorePassword(strIdentifier, NULL);
                    pVarSet->put(GET_BSTR(varsetKey), L"");

                    MessageBoxWrapper(hwndDlg, IDS_MSG_UNABLE_RETRIEVE_STORE_PASSWORD, IDS_MSG_ERROR);
                }
            }
        }
        else
        {
            ErrorWrapper(hwndDlg, HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
        }
    }
    else
    {
        DWORD dwError = GetLastError();

        if (dwError != ERROR_SUCCESS)
        {
            ErrorWrapper(hwndDlg, HRESULT_FROM_WIN32(dwError));
        }
    }

    SecureZeroMemory(szPassword, sizeof(szPassword));
}


void translationbox(HWND hwndDlg,int id1,int id2,int id3,int varsetKey)
{
	_variant_t varX;
	if (IsDlgButtonChecked( hwndDlg, id1))
//*		varX = L"Replace";
		varX = GET_STRING(IDS_Replace);
	else if(IsDlgButtonChecked( hwndDlg, id2))
//*		varX = L"Add";
		varX = GET_STRING(IDS_Add);
	else if (IsDlgButtonChecked( hwndDlg, id3))
//*		varX = L"Remove"; 
		varX = GET_STRING(IDS_Remove); 
	pVarSet->put(GET_BSTR(varsetKey), varX);
}

long rebootbox(HWND hwndDlg,int id)
{
	_variant_t varX;
	int rebootDelay;
	if (IsDlgItemEmpty(hwndDlg,id))
		rebootDelay=0;
	else
	{
		CString rebooter;
		GetDlgItemText( hwndDlg, id, rebooter.GetBuffer(1000), 1000);		
		rebooter.ReleaseBuffer();
		rebootDelay = _ttoi(rebooter.GetBuffer(1000));
		rebooter.ReleaseBuffer();
	}
	rebootDelay =rebootDelay*60;
	return rebootDelay;
}


void populateList(CComboBox& s)
{
    DWORD            fndNet=0;     // number of nets found
    DWORD            rcNet;        // net enum return code
    HANDLE           eNet = NULL;  // enumerate net domains
    EaWNetDomainInfo iNet;         // net domain info

    rcNet = EaWNetDomainEnumOpen( &eNet );
    if (!rcNet )
    {
        for ( rcNet = EaWNetDomainEnumFirst( eNet, &iNet );
            !rcNet;
            rcNet = EaWNetDomainEnumNext( eNet, &iNet ) )
        {
            fndNet++;
            s.AddString(iNet.name);
        }
    }
    if (eNet)
    {
        EaWNetDomainEnumClose( eNet );
    }
}

//
// void populateTrustingList(CString domainName, CComboBox& comboBox)
//      This function populates the combo box list with trusting domains of the specified domain name.
//
//  Arguments:
//      domainName:         the name of the domain for which the trusting domains will be looked up
//      comboBox:             the combo box object to which the trusting domains will be added to
//
void populateTrustingList(CString domainName, CComboBox& comboBox)
{
    // clean up the list in combo box
    comboBox.ResetContent();
    
    // we are taking advantage of ITrust interface here
    ITrustPtr      pTrusts;
    
    HRESULT hr = pTrusts.CreateInstance(CLSID_Trust);
    if ( SUCCEEDED(hr) )
    {
        IUnknownPtr pUnk;

        // set up logging for trust
        CString dirname;
        GetDirectory(dirname.GetBuffer(1000));
        dirname.ReleaseBuffer();
        dirname+= L"Logs\\trust.log";

        // query trusts including trusting and trusted domains
        hr = pTrusts->raw_QueryTrusts(_bstr_t(domainName),_bstr_t(domainName),_bstr_t(dirname),&pUnk);
        if ( SUCCEEDED(hr) )
        {
            IVarSetPtr pVsTrusts(pUnk);
            
            // pick trusting ones
            long nTrusts = pVsTrusts->get(L"Trusts");
            for ( long i = 0 ; i < nTrusts ; i++ )
            {
                CString base;
                CString sub;
				
                base.Format(L"Trusts.%ld",i);
                _bstr_t value = pVsTrusts->get(_bstr_t(base));

                sub = base + L".Direction";
                _bstr_t direction = pVsTrusts->get(_bstr_t(sub));

                // we are looking for either inbound or bidirectional trusts
                if ((direction == GET_BSTR(IDS_TRUST_DIRECTION_BIDIRECTIONAL))
                    || (direction == GET_BSTR(IDS_TRUST_DIRECTION_INBOUND)))
                    comboBox.AddString(value);
				
            }
        }
    }
}

void enable(HWND hwndDlg,int id)
{
	HWND temp=GetDlgItem(hwndDlg,id);
	EnableWindow(temp,true);
}
void disable(HWND hwndDlg,int id)
{
	HWND temp=GetDlgItem(hwndDlg,id);
	EnableWindow(temp,false);
}

void handleInitRename(HWND hwndDlg,bool sameForest,bool bCopyGroups)
{
	_bstr_t text1,text2,text3;
	
	text1 = get(DCTVS_AccountOptions_ReplaceExistingAccounts);
	text2 = get(DCTVS_AccountOptions_Prefix);
	text3 = get(DCTVS_AccountOptions_Suffix);
	
	initeditbox(hwndDlg,IDC_PREFIX,DCTVS_AccountOptions_Prefix );
	initeditbox(hwndDlg,IDC_SUFFIX,DCTVS_AccountOptions_Suffix );
	initcheckbox(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS,DCTVS_AccountOptions_RemoveExistingUserRights);
	initcheckbox(hwndDlg,IDC_REMOVE_EXISTING_LOCATION,DCTVS_AccountOptions_MoveReplacedAccounts);
	if ((migration==w_computer) || (!bCopyGroups))
	{
		disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
		CheckDlgButton( hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,false);
	}
	else
	{
		enable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
		initcheckbox(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,DCTVS_AccountOptions_ReplaceExistingGroupMembers);
	}
	
	if (!UStrICmp(text1,(WCHAR const *) yes))
		CheckRadioButton(hwndDlg,IDC_SKIP_CONFLICTING_ACCOUNTS,IDC_RENAME_CONFLICTING_ACCOUNTS,IDC_REPLACE_CONFLICTING_ACCOUNTS);
	else if (UStrICmp(text2,L"") || UStrICmp(text3,L""))	
		CheckRadioButton(hwndDlg,IDC_SKIP_CONFLICTING_ACCOUNTS,IDC_RENAME_CONFLICTING_ACCOUNTS,IDC_RENAME_CONFLICTING_ACCOUNTS);
	else
		CheckRadioButton(hwndDlg,IDC_SKIP_CONFLICTING_ACCOUNTS,IDC_RENAME_CONFLICTING_ACCOUNTS,IDC_SKIP_CONFLICTING_ACCOUNTS);
	
	if (IsDlgButtonChecked(hwndDlg,IDC_REPLACE_CONFLICTING_ACCOUNTS) && 
		((sameForest) && migration !=w_computer))
	{
		CheckRadioButton(hwndDlg,IDC_SKIP_CONFLICTING_ACCOUNTS,IDC_RENAME_CONFLICTING_ACCOUNTS,IDC_SKIP_CONFLICTING_ACCOUNTS);
		disable(hwndDlg,IDC_REPLACE_CONFLICTING_ACCOUNTS);
	}

	else if (sameForest && migration !=w_computer)
		disable(hwndDlg,IDC_REPLACE_CONFLICTING_ACCOUNTS);
}


void MessageBoxWrapper(HWND hwndDlg,int m,int t)
{
	CString message;
	CString title;
	message.LoadString(m);
	title.LoadString(t);
	MessageBox(hwndDlg,message,title,MB_OK | MB_ICONSTOP);
}
void MessageBoxWrapper3(HWND hwndDlg,int m,int t,CString domainName)
{
	CString message;
	CString title;
	message.LoadString(m);
	title.LoadString(t);

	CString messageFormatter;
	messageFormatter.LoadString(IDS_FORMAT_MESSAGE);
	CString text;
	text.Format(messageFormatter,message,domainName);
	MessageBox(hwndDlg,text,title,MB_OK|MB_ICONSTOP);
}
void MessageBoxWrapperFormat1(HWND hwndDlg,int f,int m, int t)
{
	CString formatter;
	CString insert;
	CString message;
	CString title;
	formatter.LoadString(f);
	insert.LoadString(m);
	message.Format(formatter,insert);
	title.LoadString(t);
	MessageBox(hwndDlg,message,title,MB_OK | MB_ICONSTOP);
}
void MessageBoxWrapperFormat1P(HWND hwndDlg,int f, int t, CString sInsert11)
{
	CString formatter;
	CString message;
	CString title;
	formatter.LoadString(f);
	message.Format(formatter,sInsert11);
	title.LoadString(t);
	MessageBox(hwndDlg,message,title,MB_OK | MB_ICONSTOP);
}

HRESULT BrowseForContainer(HWND hWnd,//Handle to window that should own the browse dialog.
                    LPOLESTR szRootPath, //Root of the browse tree. NULL for entire forest.
                    LPOLESTR *ppContainerADsPath, //Return the ADsPath of the selected container.
                    LPOLESTR *ppContainerClass //Return the ldapDisplayName of the container's class.
                    )
{
   HRESULT hr = E_FAIL;
   DSBROWSEINFO dsbi;
   OLECHAR szPath[5000];
   OLECHAR szClass[MAX_PATH];
   DWORD result;
 
   if (!ppContainerADsPath)
     return E_POINTER;
 
   ::ZeroMemory( &dsbi, sizeof(dsbi) );
   dsbi.hwndOwner = hWnd;
   dsbi.cbStruct = sizeof (DSBROWSEINFO);
   CString temp1,temp2;
   temp1.LoadString(IDS_BROWSER);
   temp2.LoadString(IDS_SELECTOR);
   dsbi.pszCaption = temp1.GetBuffer(1000);
   temp1.ReleaseBuffer();
   dsbi.pszTitle = temp2.GetBuffer(1000);
   temp2.ReleaseBuffer();
  // L"Browse for Container"; // The caption (titlebar text)
	// dsbi.pszTitle = L"Select a target container."; //Text for the dialog.
   dsbi.pszRoot = szRootPath; //ADsPath for the root of the tree to display in the browser.
                   //Specify NULL with DSBI_ENTIREDIRECTORY flag for entire forest.
                   //NULL without DSBI_ENTIREDIRECTORY flag displays current domain rooted at LDAP.
   dsbi.pszPath = szPath; //Pointer to a unicode string buffer.
   dsbi.cchPath = sizeof(szPath)/sizeof(OLECHAR);//count of characters for buffer.
   dsbi.dwFlags = DSBI_RETURN_FORMAT | //Return the path to object in format specified in dwReturnFormat
               DSBI_RETURNOBJECTCLASS; //Return the object class
   dsbi.pfnCallback = NULL;
   dsbi.lParam = 0;
   dsbi.dwReturnFormat = ADS_FORMAT_X500; //Specify the format.
                       //This one returns an ADsPath. See ADS_FORMAT enum in IADS.H
   dsbi.pszObjectClass = szClass; //Pointer to a unicode string buffer.
   dsbi.cchObjectClass = sizeof(szClass)/sizeof(OLECHAR);//count of characters for buffer.
 
   //if root path is NULL, make the forest the root.
   if (!szRootPath)
     dsbi.dwFlags |= DSBI_ENTIREDIRECTORY;
 
 
 
   //Display browse dialog box.
   result = DsBrowseForContainerX( &dsbi ); // returns -1, 0, IDOK or IDCANCEL
   if (result == IDOK)
   {
       //Allocate memory for string
       *ppContainerADsPath = (OLECHAR *)CoTaskMemAlloc (sizeof(OLECHAR)*(wcslen(szPath)+1));
       if (*ppContainerADsPath)
       {
           hr = S_OK;
           wcscpy(*ppContainerADsPath, szPath);
           //Caller must free using CoTaskMemFree

		      //if the domain was selected, add the DC= stuff
		   CString sNewPath = szPath;
		   if (sNewPath.Find(L"DC=") == -1)
		   {
			     //try retrieving the ADsPath of the containier, which does include
			     //the full LDAP path with DC=
			  IADsPtr			        pCont;
			  BSTR						sAdsPath;
			  hr = ADsGetObject(sNewPath,IID_IADs,(void**)&pCont);
			  if (SUCCEEDED(hr)) 
			  {
                 hr = pCont->get_ADsPath(&sAdsPath);
			     if (SUCCEEDED(hr))
				 {
					sNewPath = (WCHAR*)sAdsPath;
					SysFreeString(sAdsPath);
			        CoTaskMemFree(*ppContainerADsPath);
                    *ppContainerADsPath = (OLECHAR *)CoTaskMemAlloc (sizeof(OLECHAR)*(sNewPath.GetLength()+1));
                    if (*ppContainerADsPath)
                       wcscpy(*ppContainerADsPath, (LPCTSTR)sNewPath);
                    else
                       hr=E_FAIL;
				 }
			  }
		   }
       }
       else
           hr=E_FAIL;
       if (ppContainerClass)
       {
           //Allocate memory for string
           *ppContainerClass = (OLECHAR *)CoTaskMemAlloc (sizeof(OLECHAR)*(wcslen(szClass)+1));
       if (*ppContainerClass)
       {
           wcscpy(*ppContainerClass, szClass);
           //Call must free using CoTaskMemFree
           hr = S_OK;
       }
       else
           hr=E_FAIL;
       }
   }
   else
       hr = E_FAIL;
 
   return hr;
 
}

BOOL GetDomainAndUserFromUPN(WCHAR const * UPNname,CString& domainNetbios, CString& user)
{
   HRESULT                   hr;
   HINSTANCE                 hLibrary = NULL;
   DSCRACKNAMES            * DsCrackNames = NULL;
   DSFREENAMERESULT        * DsFreeNameResult = NULL;
   DSBINDFUNC                DsBind = NULL;
   DSUNBINDFUNC              DsUnBind = NULL;
   HANDLE                    hDs = NULL;
   BOOL						 bConverted = FALSE;
   CString					 resultStr;
   CString					 sDomainDNS;

         // make sure the account name is in UPN format
   if ( NULL != wcschr(UPNname,L'\\') )
	   return FALSE;
      
   hLibrary = LoadLibrary(L"NTDSAPI.DLL"); 
   if ( hLibrary )
   {
       DsBind = (DSBINDFUNC)GetProcAddress(hLibrary,"DsBindW");
       DsUnBind = (DSUNBINDFUNC)GetProcAddress(hLibrary,"DsUnBindW");
       DsCrackNames = (DSCRACKNAMES *)GetProcAddress(hLibrary,"DsCrackNamesW");
       DsFreeNameResult = (DSFREENAMERESULT *)GetProcAddress(hLibrary,"DsFreeNameResultW");
   }
            
   if ( DsBind && DsUnBind && DsCrackNames && DsFreeNameResult)
   {
      hr = (*DsBind)(NULL,const_cast<TCHAR*>(GetTargetDomainName()),&hDs);

      if ( !hr )
      {
         PDS_NAME_RESULT         pNamesOut = NULL;
         WCHAR                 * pNamesIn[1];

         pNamesIn[0] = const_cast<WCHAR *>(UPNname);

         hr = (*DsCrackNames)(hDs,DS_NAME_NO_FLAGS,DS_USER_PRINCIPAL_NAME,DS_NT4_ACCOUNT_NAME,1,pNamesIn,&pNamesOut);
	     (*DsUnBind)(&hDs);
         if ( !hr )
         {
            if (pNamesOut->rItems[0].status == DS_NAME_NO_ERROR)
            {
                resultStr = pNamesOut->rItems[0].pName;
				int index = resultStr.Find(L'\\');
				if (index != -1)
				domainNetbios = resultStr.Left(index); //parse off the domain netbios name
				if (!domainNetbios.IsEmpty())
				{	
					   //get the user's sAMAccountName
					user = resultStr.Right(resultStr.GetLength() - index - 1);
					if (!user.IsEmpty())
					   bConverted = TRUE;
				}
            }
			else if (pNamesOut->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY)
			{
	           sDomainDNS = pNamesOut->rItems[0].pDomain;
               hr = (*DsBind)(NULL,sDomainDNS.GetBuffer(1000),&hDs);
			   sDomainDNS.ReleaseBuffer();
               if ( !hr )
			   {
                  (*DsFreeNameResult)(pNamesOut);
                  pNamesOut = NULL;
                  hr = (*DsCrackNames)(hDs,DS_NAME_NO_FLAGS,DS_USER_PRINCIPAL_NAME,DS_NT4_ACCOUNT_NAME,1,pNamesIn,&pNamesOut);
                  if ( !hr )
				  {
                     if ( pNamesOut->rItems[0].status == DS_NAME_NO_ERROR )
					 {
                        resultStr = pNamesOut->rItems[0].pName;
				        int index = resultStr.Find(L'\\');
				        if (index != -1)
				        domainNetbios = resultStr.Left(index); //parse off the domain netbios name
				        if (!domainNetbios.IsEmpty())
						{	
					          //get the user's sAMAccountName
					       user = resultStr.Right(resultStr.GetLength() - index - 1);
					       if (!user.IsEmpty())
					          bConverted = TRUE;
						}
					 }//end if no error
				  }//end if name cracked
  	              (*DsUnBind)(&hDs);
			   }//end if bound to other domain
			}
			if (pNamesOut)
               (*DsFreeNameResult)(pNamesOut);
         }//end if name cracked
      }//end if bound to target domain
   }//end got functions

   if ( hLibrary )
   {
      FreeLibrary(hLibrary);
   }

   return bConverted;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 31 AUG 2000                                                 *
 *                                                                   *
 *     This function is responsible for switching between showing the*
 * password file editbox and the password dc combobox.               *
 *                                                                   *
 *********************************************************************/

//BEGIN switchboxes
void switchboxes(HWND hwndDlg,int oldid, int newid)
{
/* local variables */
	CWnd oldWnd;
	CWnd newWnd;

/* function body */
	oldWnd.Attach(GetDlgItem(hwndDlg, oldid));
	newWnd.Attach(GetDlgItem(hwndDlg, newid));
	oldWnd.ShowWindow(SW_HIDE);
	newWnd.ShowWindow(SW_SHOW);
	oldWnd.Detach();
	newWnd.Detach();
}
//END switchboxes

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 31 AUG 2000                                                 *
 *                                                                   *
 *     This function is responsible for enumerating all DCs in the   *
 * given source domain and add them into the source domain combobox. *
 *                                                                   *
 *********************************************************************/

//BEGIN populatePasswordDCs
bool populatePasswordDCs(HWND hwndDlg, int id, bool bNT4)
{
/* local variables */
	CComboBox				pwdCombo;
	CString					aDCName;
	CString					aDnName;
    IEnumVARIANT          * pEnumerator = NULL;
    VARIANT                 var;
	POSITION				currentPos;
	HRESULT					hr = S_OK;

/* function body */
    VariantInit(&var);

    pwdCombo.Attach(GetDlgItem(hwndDlg, id));

	  //if we already have a list of DCs for this domain then add them
	if (!DCList.IsEmpty())
	{
		  //get the position and string of the first name in the list
	   currentPos = DCList.GetHeadPosition();

		  //while there is another entry to retrieve from the list, then 
		  //get a name from the list and add it to the combobox
	   while (currentPos != NULL)
	   {
			//get the next string in the list, starts with the first
		  aDCName = DCList.GetNext(currentPos);
		  if (pwdCombo.FindString(-1, aDCName) == CB_ERR)
	         pwdCombo.AddString(aDCName);//add the DC to the combobox
	   }
	}
	else //else enumerate DCs in the domain and add them
	{
	   pwdCombo.ResetContent();//reset the combobox contents

	      //enumerate all domain controllers in the given domain
       if (bNT4)
	      hr = QueryNT4DomainControllers(GetSourceDomainName(), pEnumerator);
       else
	      hr = QueryW2KDomainControllers(GetSourceDomainName(), pEnumerator);
	   if (SUCCEEDED(hr))
	   {
          unsigned long count = 0;
	         //for each computer see if a DC.  If so, add to combobox
          while ( pEnumerator->Next(1,&var,&count) == S_OK )
		  {
		        //get the sam account name for this computer
             if ( var.vt == ( VT_ARRAY | VT_VARIANT ) )
			 {
                VARIANT              * pData;
			    _variant_t			   vnt;
				_bstr_t				   abstr;

                SafeArrayAccessData(var.parray,(void**)&pData);
                  // pData[0] has the sam account name list
			    vnt.Attach(pData[0]);
				abstr = _bstr_t(vnt);
			    aDCName = (WCHAR *)abstr;
			    vnt.Detach();

			    SafeArrayUnaccessData(var.parray);

				   //computer sAMAccountNames end in $, lets get rid of that
				int length = aDCName.GetLength();
				if (aDCName[length-1] == L'$')
					aDCName = aDCName.Left(length-1);

				   //add the DC to the combobox and the memory list, if not in already
				if (pwdCombo.FindString(-1, aDCName) == CB_ERR)
				   pwdCombo.AddString(aDCName);
				if (DCList.Find(aDCName) == NULL)
		           DCList.AddTail(aDCName);
			 }
		  }//end while more computers
          pEnumerator->Release();
	   }
    }//end if must get DCs
	pwdCombo.Detach();

	if (hr == S_OK)
	   return true;
	else
	   return false;
}
//END populatePasswordDCs

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 1 SEPT 2000                                                 *
 *                                                                   *
 *     This worker function is responsible for enumerating all domain*
 * controllers in the given Windows 2000 domain.  The variant array  *
 * passed back is filled with the sAMAccountName for each domain     *
 * controller.                                                       *
 *                                                                   *
 *********************************************************************/

//BEGIN QueryW2KDomainControllers
HRESULT QueryW2KDomainControllers(CString domainDNS, IEnumVARIANT*& pEnum)
{
    CString                   sQuery;
    WCHAR                     sCont[MAX_PATH];
    SAFEARRAY               * colNames = NULL;
    SAFEARRAYBOUND            bd = { 1, 0 };
    HRESULT                   hr = S_OK;

    try
    {
        INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
        //query for all domain controllers in the domain
        sQuery = L"(&(objectCategory=Computer)";
        sQuery += L"(userAccountControl:";
        sQuery += LDAP_MATCHING_RULE_BIT_AND_W;
        sQuery += L":=8192))";

        wsprintf(sCont, L"LDAP://%s", domainDNS);

        //set columns to retrieve sAMAccountName
        colNames = SafeArrayCreate(VT_BSTR, 1, &bd);
        if (colNames == NULL)
            _com_issue_error(E_OUTOFMEMORY);
        
        long ndx[1];
        ndx[0] = 0;
        BSTR str = SysAllocString(L"sAMAccountName");
        if (str == NULL)
            _com_issue_error(E_OUTOFMEMORY);
        
        hr = SafeArrayPutElement(colNames,ndx,str);
        if (FAILED(hr))
        {
            SysFreeString(str);
            _com_issue_error(hr);
        }

        //prepare and execute the query
        pQuery->SetQuery(sCont, _bstr_t(domainDNS), _bstr_t(sQuery), ADS_SCOPE_SUBTREE, FALSE);
        pQuery->SetColumns(colNames);
        pQuery->Execute(&pEnum);
    }
    catch(_com_error& e)
    {
        hr = e.Error();
    }
    catch(...)
    {
        hr = E_FAIL;
    }

    if (colNames)
        SafeArrayDestroy(colNames);

    return hr;
}
//END QueryW2KDomainControllers

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 1 SEPT 2000                                                 *
 *                                                                   *
 *     This worker function is responsible for enumerating all domain*
 * controllers in the given Windows NT4 domain.  The variant array   *
 * passed back is filled with the sAMAccountName for each domain     *
 * controller.                                                       *
 *                                                                   *
 *********************************************************************/

//BEGIN QueryNT4DomainControllers
HRESULT QueryNT4DomainControllers(CString domainDNS, IEnumVARIANT*& pEnum)
{
    CString                   sCont;
    SAFEARRAY               * colNames = NULL;
    SAFEARRAYBOUND            bd = { 1, 0 };
    HRESULT                   hr = S_OK;

    try
    {
        INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));

        sCont = L"CN=DOMAIN CONTROLLERS";

        //set columns to retrieve sAMAccountName
        colNames = SafeArrayCreate(VT_BSTR, 1, &bd);
        if (colNames == NULL)
            _com_issue_error(E_OUTOFMEMORY);
        
        long ndx[1];
        ndx[0] = 0;
        BSTR str = SysAllocString(L"sAMAccountName");
        if (str == NULL)
            _com_issue_error(E_OUTOFMEMORY);
        
        hr = SafeArrayPutElement(colNames,ndx,str);
        if (FAILED(hr))
        {
            SysFreeString(str);
            _com_issue_error(hr);
        }

        //prepare and execute the query
        pQuery->SetQuery(_bstr_t(sCont), _bstr_t(domainDNS), L"", ADS_SCOPE_SUBTREE, FALSE);
        pQuery->SetColumns(colNames);
        pQuery->Execute(&pEnum);
    }
    catch(_com_error& e)
    {
        hr = e.Error();
    }
    catch(...)
    {
        hr = E_FAIL;
    }

    if (colNames)
        SafeArrayDestroy(colNames);

    return hr;
}
//END QueryNT4DomainControllers

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 1 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for adding a given string to a   *
 * given combobox, if that string is not already in the combobox.    *
 *                                                                   *
 *********************************************************************/

//BEGIN addStringToComboBox
void addStringToComboBox(HWND hwndDlg, int id, CString s)
{
/* local variables */
	CComboBox				pwdCombo;

/* function body */
       //if the DC starts with "\\", then remove them
    if (!UStrICmp(s,L"\\\\",UStrLen(L"\\\\")))
	   s = s.Right(s.GetLength() - UStrLen(L"\\\\"));

    pwdCombo.Attach(GetDlgItem(hwndDlg, id));
	if (pwdCombo.FindString(-1, s) == CB_ERR)
	   pwdCombo.AddString(s);//add the string to the combobox
	pwdCombo.Detach();
}
//END addStringToComboBox

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 1 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for selecting a string in a given*
 * combobox.  If we previously had a DC selected for this domain in  *
 * the varset, we select it.  If not, then we set it to the DC found *
 * in the Domain Selection dialog.                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN initDCcombobox
void initDCcombobox(HWND hwndDlg, int id, int varsetKey)
{
/* local variables */
	CComboBox				pwdCombo;
	CString					prevDC;
	CString					sTemp;
	_bstr_t					text;

/* function body */
	   //strip the "\\" off the sourceDC default in case we need it
    if (!UStrICmp(sourceDC,L"\\\\",UStrLen(L"\\\\")))
	   sTemp = sourceDC.Right(sourceDC.GetLength() - UStrLen(L"\\\\"));

    pwdCombo.Attach(GetDlgItem(hwndDlg, id));

       //get a previous DC
	text = pVarSet->get(GET_BSTR(varsetKey));
	prevDC = (WCHAR *)text;
	prevDC.TrimLeft();prevDC.TrimRight();
	   //if not previous DC, use the one found during the Domain Selection
	if (prevDC.IsEmpty())
		prevDC = sTemp;

	   //select string in combobox
	if (pwdCombo.SelectString(-1, prevDC) == CB_ERR)
	   pwdCombo.SelectString(-1, sTemp);

	pwdCombo.Detach();
}
//END initDCcombobox


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 3 OCT 2000                                                  *
 *                                                                   *
 *     This function is responsible for initializing the Security    *
 * Translation Input dialog's radio buttons based on any previous    *
 * settings.                                                         *
 *                                                                   *
 *********************************************************************/

//BEGIN initsecinputbox
void initsecinputbox(HWND hwndDlg,int id1,int id2,int varsetKey)
{
	_bstr_t     text;
	
	text = pVarSet->get(GET_BSTR(varsetKey));

	if (!UStrICmp(text,(WCHAR const *) yes))
		CheckRadioButton(hwndDlg,id1,id2,id1);
	else
	    CheckRadioButton(hwndDlg,id1,id2,id2);
}
//END initsecinputbox


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 3 OCT 2000                                                  *
 *                                                                   *
 *     This function is responsible for displaying and handling the  *
 * map file browse dialog.                                           *
 *                                                                   *
 *********************************************************************/

//BEGIN OnMapFileBrowse
void OnMapFileBrowse(HWND hwndDlg,int id)
{
	CWnd yo ;
	yo.Attach(hwndDlg);
	
    CFileDialog f(TRUE,
		NULL,
		NULL,
		OFN_LONGNAMES | OFN_NOREADONLYRETURN,
	    (L"Text Files (*.csv;*.txt)|*.csv;*.txt|All Files (*.*)|*.*||"),
		&yo);


	
	if ( f.DoModal() == IDOK )
	{
		SetDlgItemText(hwndDlg,id,f.GetPathName());
	}
	yo.Detach();
}
//END OnMapFileBrowse


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 3 OCT 2000                                                  *
 *                                                                   *
 *     This function is responsible for checking to see if the file  *
 * specified in the edit box on the given dialog is a valid file.  We*
 * will set the full path of the file if a relative path was given.  *
 *                                                                   *
 *********************************************************************/

//BEGIN checkMapFile
bool checkMapFile(HWND hwndDlg)
{
	CString h;GetDlgItemText(hwndDlg,IDC_MAPPING_FILE,h.GetBuffer(1000),1000);h.ReleaseBuffer();
	CFileFind finder;

	bool exists = (finder.FindFile((LPCTSTR) h )!=0);
	if (exists)
	{
	   BOOL bmore = finder.FindNextFile();//must call to fill in path info
	   CString fullpath = finder.GetFilePath();
	   if (fullpath.GetLength() != 0)
	      SetDlgItemText(hwndDlg,IDC_MAPPING_FILE,fullpath);
	}

    return exists;
}
//END checkMapFile


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 25 OCT 2000                                                 *
 *                                                                   *
 *     This function is responsible for initializing the object      *
 * property exclusion dialog.                                        *
 *     This function adds all common schema properties for the object*
 * type to the listboxes.  Previously excluded properties will be    *
 * placed in the excluded listbox and all other will be placed in the*
 * included listbox.  Since more than one object is allowable, we    *
 * have a combobox that holds the objects whose properties can be    *
 * enumerated, and the listboxes show the properties for the object  *
 * selected in the combobox.                                         *
 *                                                                   *
 *********************************************************************/

namespace
{
WCHAR DELIMITER[] = L",";//used to seperate names in the string
}

//BEGIN initpropdlg
void initpropdlg(HWND hwndDlg)
{
    /* local variables */
    CListCtrl				propIncList;
    CListCtrl				propExcList;
    CComboBox				typeCombo;
    CString					sPropName;
    CString					sPropOID;
    bool                    bExAll1 = false;
    bool                    bExAll2 = false;
    bool                    bExAll3 = false;
    CString					sExList1;
    CString					sExList2 = L"";
    CString					sExList3 = L"";
    CString                 Type1, Type2 = L"", Type3 = L"";
    CStringList				ExList1, ExList2, ExList3;
    _bstr_t					text;
    HRESULT                 hr;
    long					srcVer = 5;
    POSITION				currentPos;
    sType1.Empty();
    sType2.Empty();
    sType3.Empty();

    /* function body */
    CWaitCursor wait;
    /* get list(s) of previously excluded properties and set type
    related variables */
    if (migration==w_computer)
    {
        //get the previous computer exclusion list
        text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedComputerProps));
        sExList1 = (WCHAR *)text;
        Type1 = L"computer";  //set the type to computer
        //set the parent text
        sType1 = GET_STRING(IDS_COMPUTERPROPS);
    }
    else if (migration==w_account)
    {
        // initialize user and inetOrgPerson

        Type1 = L"user";
        sType1 = GET_STRING(IDS_USERPROPS);
        sExList1 = (LPCTSTR)_bstr_t(pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedUserProps)));

        Type2 = L"InetOrgPerson";
        sType2 = GET_STRING(IDS_INETORGPERSONPROPS);
        sExList2 = (LPCTSTR)_bstr_t(pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedInetOrgPersonProps)));

        // if migrating groups

        text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyMemberOf));

        if (!UStrICmp((WCHAR*)text,(WCHAR const *) yes))
        {
            // initialize group
            Type3 = L"group";
            sType3 = GET_STRING(IDS_GROUPPROPS);
            sExList3 = (LPCTSTR)_bstr_t(pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedGroupProps)));
        }
    }
    else if (migration==w_group || migration==w_groupmapping)
    {
        //get the previous group exclusion list
        text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedGroupProps));
        sExList1 = (WCHAR *)text;
        //if also migrating users, set 2nd parent information
        text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyContainerContents));
        if (!UStrICmp((WCHAR*)text,(WCHAR const *) yes))
        {
            //get the previous user exclusion list
            text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedUserProps));
            sExList2 = (WCHAR *)text;
            Type2 = L"user"; //set 2nd type to user
            //set 2nd parent text
            sType2 = GET_STRING(IDS_USERPROPS);

            //get the previous inetOrgPerson exclusion list
            sExList3 = (LPCTSTR)_bstr_t(pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedInetOrgPersonProps)));
            Type3 = L"InetOrgPerson";
            sType3 = GET_STRING(IDS_INETORGPERSONPROPS);
        }
        Type1 = L"group";  //set type to group
        //set the parent text
        sType1 = GET_STRING(IDS_GROUPPROPS);
    }

    /* place comma seperated exclusion strings parts into lists */
    //place each substring in the 1st exclusion string into a list
    if (!sExList1.IsEmpty())
    {
        if (IsStringInDelimitedString(sExList1, L"*", DELIMITER[0]))
        {
            bExAll1 = true;
        }
        else
        {
            CString sTemp = sExList1;
            WCHAR* pStr = sTemp.GetBuffer(0);
            WCHAR* pTemp = wcstok(pStr, DELIMITER);
            while (pTemp != NULL)
            {
                ExList1.AddTail(pTemp);
                //get the next item
                pTemp = wcstok(NULL, DELIMITER);
            }
            sTemp.ReleaseBuffer();
        }
    }

    //place each substring in the 2nd exclusion string into a list
    if (!sExList2.IsEmpty())
    {
        if (IsStringInDelimitedString(sExList2, L"*", DELIMITER[0]))
        {
            bExAll2 = true;
        }
        else
        {
            CString sTemp = sExList2;
            WCHAR* pStr = sTemp.GetBuffer(0);
            WCHAR* pTemp = wcstok(pStr, DELIMITER);
            while (pTemp != NULL)
            {
                ExList2.AddTail(pTemp);
                //get the next item
                pTemp = wcstok(NULL, DELIMITER);
            }
            sTemp.ReleaseBuffer();
        }
    }

    //place each substring in the 3rd exclusion string into a list
    if (!sExList3.IsEmpty())
    {
        if (IsStringInDelimitedString(sExList3, L"*", DELIMITER[0]))
        {
            bExAll3 = true;
        }
        else
        {
            CString sTemp = sExList3;
            WCHAR* pStr = sTemp.GetBuffer(0);
            WCHAR* pTemp = wcstok(pStr, DELIMITER);
            while (pTemp != NULL)
            {
                ExList3.AddTail(pTemp);
                //get the next item
                pTemp = wcstok(NULL, DELIMITER);
            }
            sTemp.ReleaseBuffer();
        }
    }

    /* place the type(s) in the combobox */
    typeCombo.Attach(GetDlgItem(hwndDlg, IDC_OBJECTCMBO));
    typeCombo.ResetContent();
    typeCombo.InsertString(-1, sType1);
    if (!sType2.IsEmpty())
        typeCombo.InsertString(-1, sType2);
    if (!sType3.IsEmpty())
        typeCombo.InsertString(-1, sType3);
    //select type 1 in the combobox
    typeCombo.SelectString(-1, sType1);
    typeCombo.Detach();

    //get a list of all properties names and their OIDs for this object type
    PropIncMap1.clear();
    PropExcMap1.clear();
    hr = BuildPropertyMap(Type1, srcVer, bExAll1 ? &PropExcMap1 : &PropIncMap1);

    /* remove excluded properties from the inclusion map and place that property in
    the exclusion map */
    if (!ExList1.IsEmpty())
    {
        //get the position and string of the first property in the previous
        //exclusion list
        currentPos = ExList1.GetHeadPosition();
        //while there is another entry to retrieve from the list, then 
        //get a property name from the list,remove it from the inclusion map, and
        //place it in the exclusion list
        while (currentPos != NULL)
        {
            //get the next string in the list, starts with the first
            sPropName = ExList1.GetNext(currentPos);

            //if we find the property in the inclusion map, remove it and 
            //add to the exclusion map
            CPropertyNameToOIDMap::iterator it = PropIncMap1.find(sPropName);
            if (it != PropIncMap1.end())
            {
                PropExcMap1.insert(CPropertyNameToOIDMap::value_type(it->first, it->second));
                PropIncMap1.erase(it); //remove it from the inc map
            }//end if found in map
        }
    }

    //
    // initialize list controls
    //
    propIncList.Attach(GetDlgItem(hwndDlg, IDC_INCLUDELIST));
    propExcList.Attach(GetDlgItem(hwndDlg, IDC_EXCLUDELIST));

    // insert a column with an empty string as the header text
    CString emptyColumn;
    propIncList.InsertColumn(1, emptyColumn, LVCFMT_LEFT, 157, 1);
    propExcList.InsertColumn(1, emptyColumn, LVCFMT_LEFT, 157, 1);

    propIncList.Detach();
    propExcList.Detach();

    /* add the type1 properties to the appropriate listboxes */
    listproperties(hwndDlg);

    //init "Exclude Prop" checkbox
    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludeProps));
    //if not checked, disable all other controls
    if (UStrICmp(text,(WCHAR const * ) yes))
    {
        CheckDlgButton( hwndDlg,IDC_EXCLUDEPROPS, BST_UNCHECKED);
        disable(hwndDlg,IDC_OBJECTCMBO);
        disable(hwndDlg,IDC_INCLUDELIST);
        disable(hwndDlg,IDC_EXCLUDELIST);
        disable(hwndDlg,IDC_EXCLUDEBTN);
        disable(hwndDlg,IDC_INCLUDEBTN);
    }
    else //eles enable them
    {
        CheckDlgButton( hwndDlg,IDC_EXCLUDEPROPS, BST_CHECKED);
        enable(hwndDlg,IDC_OBJECTCMBO);
        enable(hwndDlg,IDC_INCLUDELIST);
        enable(hwndDlg,IDC_EXCLUDELIST);
        enable(hwndDlg,IDC_EXCLUDEBTN);
        enable(hwndDlg,IDC_INCLUDEBTN);
    }

    //if no 2nd type to be displayed, leave
    if (Type2.IsEmpty())
        return;

    /* enumerate and add all mapped properties, for the 2nd type, to the maps */
    //get a list of all properties names and their OIDs for this object type
    PropIncMap2.clear();  //clear the property map
    PropExcMap2.clear();  //clear the property map
    hr = BuildPropertyMap(Type2, srcVer, bExAll2 ? &PropExcMap2 : &PropIncMap2);

    /* remove excluded properties from the inclusion map and place that property in
    the exclusion map */
    if (!ExList2.IsEmpty())
    {
        //get the position and string of the first name in the previous
        //exclusion list
        currentPos = ExList2.GetHeadPosition();
        //while there is another entry to retrieve from the list, then 
        //get a name from the list,remove it from the inclusion map, and
        //place it in the exclusion list
        while (currentPos != NULL)
        {
            //get the next string in the list, starts with the first
            sPropName = ExList2.GetNext(currentPos);
            //if we find the property in the inclusion map, remove it and 
            //add to the exclusion map
            CPropertyNameToOIDMap::iterator it = PropIncMap2.find(sPropName);
            if (it != PropIncMap2.end())
            {
                PropExcMap2.insert(CPropertyNameToOIDMap::value_type(it->first, it->second));
                PropIncMap2.erase(it); //remove it from the inc map
            }//end if found in map
        }
    }

    //if no 3rd type to be displayed, leave
    if (Type3.IsEmpty())
        return;

    /* enumerate and add all mapped properties, for the 3rd type, to the maps */
    //get a list of all properties names and their OIDs for this object type
    PropIncMap3.clear();  //clear the property map
    PropExcMap3.clear();  //clear the property map
    hr = BuildPropertyMap(Type3, srcVer, bExAll3 ? &PropExcMap3 : &PropIncMap3);

    /* remove excluded properties from the inclusion map and place that property in
    the exclusion map */
    if (!ExList3.IsEmpty())
    {
        //get the position and string of the first name in the previous
        //exclusion list
        currentPos = ExList3.GetHeadPosition();
        //while there is another entry to retrieve from the list, then 
        //get a name from the list,remove it from the inclusion map, and
        //place it in the exclusion list
        while (currentPos != NULL)
        {
            //get the next string in the list, starts with the first
            sPropName = ExList3.GetNext(currentPos);
            //if we find the property in the inclusion map, remove it and 
            //add to the exclusion map
            CPropertyNameToOIDMap::iterator it = PropIncMap3.find(sPropName);
            if (it != PropIncMap3.end())
            {
                PropExcMap3.insert(CPropertyNameToOIDMap::value_type(it->first, it->second));
                PropIncMap3.erase(it); //remove it from the inc map
            }//end if found in map
        }
    }
}
//END initpropdlg


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 26 OCT 2000                                                 *
 *                                                                   *
 *     This function is used by "initpropdlg" to retrieve a given    *
 * object's properties, and their associated OIDs, from the schema.  *
 *     The property names and OIDs are placed in a given             *
 * string-to-string map using the OID as the key.  Property          *
 * enumeration is accomplished using the ObjPropBuilder class.       *
 *                                                                   *
 *********************************************************************/

//BEGIN BuildPropertyMap
HRESULT BuildPropertyMap(CString Type, long lSrcVer, CPropertyNameToOIDMap * pPropMap)
{
/* local variables */
    IObjPropBuilderPtr      pObjProp(__uuidof(ObjPropBuilder));
    IVarSetPtr              pVarTemp(__uuidof(VarSet));
    IUnknown              * pUnk;
    HRESULT                 hr;
    long                    lRet=0;
    SAFEARRAY             * keys = NULL;
    SAFEARRAY             * vals = NULL;
    VARIANT                 var;
	CString					sPropName;
	CString					sPropOID;

/* function body */
    VariantInit(&var);

       //get an IUnknown pointer to the Varset for passing it around.
    hr = pVarTemp->QueryInterface(IID_IUnknown, (void**)&pUnk);
    if (FAILED(hr))
	   return hr;

	   //fill the varset with a list of properties in common between the source
	   //and target domain for the first type being migrated
    hr = pObjProp->raw_MapProperties(_bstr_t(Type), _bstr_t(GetSourceDomainName()), 
		                             lSrcVer, _bstr_t(Type), _bstr_t(GetTargetDomainName()), 
									 5, 1, &pUnk);
    if (SUCCEEDED(hr) || (hr == DCT_MSG_PROPERTIES_NOT_MAPPED))
	{
       hr = pVarTemp->getItems(L"", L"", 1, 10000, &keys, &vals, &lRet);
       if (SUCCEEDED(hr)) 
	   {
          for ( long x = 0; x < lRet; x++ )
		  {
             ::SafeArrayGetElement(keys, &x, &var);
             if (V_VT(&var) != VT_EMPTY)
			 {
                sPropOID = (WCHAR*)(var.bstrVal);
                VariantClear(&var);

                ::SafeArrayGetElement(vals, &x, &var);
                if (V_VT(&var) != VT_EMPTY)
				{
                   sPropName = (WCHAR*)(var.bstrVal);
                   VariantClear(&var);

			          //place the OID and Name in the map with the name as the key
                   pPropMap->insert(CPropertyNameToOIDMap::value_type(sPropName, sPropOID));
				}
			 }
		  }
	   }
	}

    // retrieve system exclude attributes and remove them from the include map
    // this prevents the user from manipulating them through this dialog

    CString strSysExclude = (LPCTSTR)_bstr_t(pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedSystemProps)));

    if (!strSysExclude.IsEmpty())
    {
        WCHAR* psz = strSysExclude.GetBuffer(0);

        for (psz = wcstok(psz, DELIMITER); psz; psz = wcstok(NULL, DELIMITER))
        {
            pPropMap->erase(CString(psz));
        }

        strSysExclude.ReleaseBuffer();
    }

	return hr;
}
//END BuildPropertyMap


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 27 OCT 2000                                                 *
 *                                                                   *
 *     This function is responsible for moving properties to and from*
 * the inclusion and exclusion listboxes.  If the boolean parameter  *
 * is true, then we are moving properties from the inclusion listbox *
 * to the exclusion listbox.  We will also move the properties from  *
 * the global inclusion and exclusion maps.                          *
 *                                                                   *
 *********************************************************************/

//BEGIN moveproperties
void moveproperties(HWND hwndDlg, bool bExclude)
{

/* local variables */
	CListCtrl				propToList;
	CListCtrl				propFromList;
	CComboBox				typeCombo;
    CPropertyNameToOIDMap*	pPropFromMap;
    CPropertyNameToOIDMap*	pPropToMap;
	CStringList				sMoveList;
	CString					sPropName;
	CString					sTempName;
	CString					sTempOID;
	POSITION				currentPos;
	int						ndx;
	int						nFound;

/* function body */
	/* find out whether type1 or type2 is having properties moved and
	   setup map pointer accordingly */
    typeCombo.Attach(GetDlgItem(hwndDlg, IDC_OBJECTCMBO));
	   //if type1, use the type1 maps
	if (typeCombo.FindString(-1, sType1) == typeCombo.GetCurSel())
	{
	   if (bExclude)
	   {
	      pPropToMap = &PropExcMap1;
	      pPropFromMap = &PropIncMap1;
	   }
	   else
	   {
	      pPropToMap = &PropIncMap1;
	      pPropFromMap = &PropExcMap1;
	   }
	}
	else if (typeCombo.FindString(-1, sType2) == typeCombo.GetCurSel()) //else use type2 maps
	{
	   if (bExclude)
	   {
	      pPropToMap = &PropExcMap2;
	      pPropFromMap = &PropIncMap2;
	   }
	   else
	   {
	      pPropToMap = &PropIncMap2;
	      pPropFromMap = &PropExcMap2;
	   }
	}
	else //else use type3 maps
	{
	   if (bExclude)
	   {
	      pPropToMap = &PropExcMap3;
	      pPropFromMap = &PropIncMap3;
	   }
	   else
	   {
	      pPropToMap = &PropIncMap3;
	      pPropFromMap = &PropExcMap3;
	   }
	}
	typeCombo.Detach();

	/* attach to the proper listboxes */
	if (bExclude)
	{
       propToList.Attach(GetDlgItem(hwndDlg, IDC_EXCLUDELIST));
       propFromList.Attach(GetDlgItem(hwndDlg, IDC_INCLUDELIST));
	}
	else
	{
       propToList.Attach(GetDlgItem(hwndDlg, IDC_INCLUDELIST));
       propFromList.Attach(GetDlgItem(hwndDlg, IDC_EXCLUDELIST));
	}

	/* get the items selected for moving and place the names in a list */
	sMoveList.RemoveAll();
    currentPos = propFromList.GetFirstSelectedItemPosition();
    while (currentPos != NULL)
    {
        ndx = propFromList.GetNextSelectedItem(currentPos);
        sMoveList.AddTail(propFromList.GetItemText(ndx, 0));
    }

    // move the properties in the listboxes and the maps
    if (!sMoveList.IsEmpty())
    {
        currentPos = sMoveList.GetHeadPosition();
        //while there is another entry to retrieve from the move list, then 
        //get a name from the 'from' list, remove it from the 'from' map and 
        //list control, and place it in the 'to' map and list control
        while (currentPos != NULL)
        {
            //get the next string in the list, starts with the first
            sTempName = sMoveList.GetNext(currentPos);
            //remove the property from the 'from' listbox
            LVFINDINFO info;

            info.flags = LVFI_STRING;
            info.psz = sTempName;

            // Delete all of the items that begin with the string sTempName.
            if ((ndx = propFromList.FindItem(&info)) != -1)
            {
                propFromList.DeleteItem(ndx);
                propToList.InsertItem(propToList.GetItemCount(), sTempName);
            }


		  /* find the property in the 'from' map, remove it, and add it to the
		     'to' map */
	         //if we find the property in the inclusion map, remove it and 
		     //add to the exclusion map
          CPropertyNameToOIDMap::iterator it = pPropFromMap->find(sTempName);
	      if (it != pPropFromMap->end())
		  {
	         pPropToMap->insert(CPropertyNameToOIDMap::value_type(it->first, it->second));//add it to the to map
		     pPropFromMap->erase(it); //remove it from the from map
		  }//end if found in map
	   }//end while more props to move
	}//end if props to move
	propToList.Detach();
	propFromList.Detach();
}
//END moveproperties


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 27 OCT 2000                                                 *
 *                                                                   *
 *     This function is responsible for listing properties in the    *
 * inclusion and exclusion listboxes based on the current object type*
 * selected in the combobox.                                         *
 *     We will retrieve the properties from the global inclusion and *
 * exclusion maps.                                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN listproperties
void listproperties(HWND hwndDlg)
{
/* local variables */
	CListCtrl				propIncList;
	CListCtrl				propExcList;
	CComboBox				typeCombo;
    CPropertyNameToOIDMap*	pPropIncMap;
    CPropertyNameToOIDMap*	pPropExcMap;
    CPropertyNameToOIDMap::iterator it;

/* function body */
	/* find out whether type1 or type2 is having properties listed and
	   setup map pointer accordingly */
    typeCombo.Attach(GetDlgItem(hwndDlg, IDC_OBJECTCMBO));
	   //if type1, use the type1 maps
	if (typeCombo.FindString(-1, sType1) == typeCombo.GetCurSel())
	{
       pPropIncMap = &PropIncMap1;
	   pPropExcMap = &PropExcMap1;
	}
	else if (typeCombo.FindString(-1, sType2) == typeCombo.GetCurSel())
	{
       pPropIncMap = &PropIncMap2;
	   pPropExcMap = &PropExcMap2;
	}
	else //else use type3 maps
	{
       pPropIncMap = &PropIncMap3;
	   pPropExcMap = &PropExcMap3;
	}
	typeCombo.Detach();

	/* attach to the proper list controls */
    propIncList.Attach(GetDlgItem(hwndDlg, IDC_INCLUDELIST));
    propExcList.Attach(GetDlgItem(hwndDlg, IDC_EXCLUDELIST));
    propIncList.DeleteAllItems();
    propExcList.DeleteAllItems();

	/* populate the include list control from the include map */
	if (!pPropIncMap->empty())
	{
	      //for each property in the include map, place it in 
	      //the include list control
	   for (it = pPropIncMap->begin(); it != pPropIncMap->end(); it++)
	   {
	      propIncList.InsertItem(propIncList.GetItemCount(), it->first);
	   }//end while more to list
	}//end if props to list

	/* populate the exclude list control from the exclude map */
	if (!pPropExcMap->empty())
	{
	      //for each property in the include map, place it in 
	      //the include list control
	   for (it = pPropExcMap->begin(); it != pPropExcMap->end(); it++)
	   {
	      propExcList.InsertItem(propExcList.GetItemCount(), it->first);
	   }//end while more to list
	}//end if props to list

	propIncList.Detach();
	propExcList.Detach();
}
//END listproperties


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 31 OCT 2000                                                 *
 *                                                                   *
 *     This function is responsible for storing excluded properties  *
 * in the proper varset field.  The excluded properties are retrieved*
 * from the global exclusion maps.  Properties are store in the      *
 * varset string as a comma-seperated string of the properties' IOD. *
 *                                                                   *
 *********************************************************************/

//BEGIN saveproperties
void saveproperties(HWND hwndDlg)
{
/* local variables */
	CComboBox				typeCombo;
	CString					sPropName;
	CString					sPropOID;
	CString					sType3 = L"";
	CString					sType2 = L"";
	CString					sType;
	CString					sExList;
    CPropertyNameToOIDMap::iterator it;
	int						ndx;
	_bstr_t					text;
	_bstr_t					key1;
	_bstr_t					key2;
	_bstr_t					key3;

/* function body */
	/* see if there is a second type listed in the combobox */
    typeCombo.Attach(GetDlgItem(hwndDlg, IDC_OBJECTCMBO));

	for (ndx = 0; ndx < typeCombo.GetCount(); ndx++)
	{
	   typeCombo.GetLBText(ndx, sType); //get the next type listed
       switch (ndx)
       {
          case 0:
		     //sType1 = sType; global variable
             break;
          case 1:
		     sType2 = sType;
             break;
          case 2:
		     sType3 = sType;
             break;
       }
	}
	typeCombo.Detach();

    /* find the proper varset key for each type */
	if (sType1 == GET_STRING(IDS_USERPROPS))
	   key1 = GET_BSTR(DCTVS_AccountOptions_ExcludedUserProps);
	else if (sType1 == GET_STRING(IDS_INETORGPERSONPROPS))
	   key1 = GET_BSTR(DCTVS_AccountOptions_ExcludedInetOrgPersonProps);
	else if (sType1 == GET_STRING(IDS_GROUPPROPS))
	   key1 = GET_BSTR(DCTVS_AccountOptions_ExcludedGroupProps);
	else if (sType1 == GET_STRING(IDS_COMPUTERPROPS))
	   key1 = GET_BSTR(DCTVS_AccountOptions_ExcludedComputerProps);

	if (!sType2.IsEmpty())
	{
	   if (sType2 == GET_STRING(IDS_USERPROPS))
	      key2 = GET_BSTR(DCTVS_AccountOptions_ExcludedUserProps);
	   else if (sType2 == GET_STRING(IDS_INETORGPERSONPROPS))
	      key2 = GET_BSTR(DCTVS_AccountOptions_ExcludedInetOrgPersonProps);
	   else if (sType2 == GET_STRING(IDS_GROUPPROPS))
	      key2 = GET_BSTR(DCTVS_AccountOptions_ExcludedGroupProps);
	   else if (sType2 == GET_STRING(IDS_COMPUTERPROPS))
	      key2 = GET_BSTR(DCTVS_AccountOptions_ExcludedComputerProps);
	}

	if (!sType3.IsEmpty())
	{
	   if (sType3 == GET_STRING(IDS_USERPROPS))
	      key3 = GET_BSTR(DCTVS_AccountOptions_ExcludedUserProps);
	   else if (sType3 == GET_STRING(IDS_INETORGPERSONPROPS))
	      key3 = GET_BSTR(DCTVS_AccountOptions_ExcludedInetOrgPersonProps);
	   else if (sType3 == GET_STRING(IDS_GROUPPROPS))
	      key3 = GET_BSTR(DCTVS_AccountOptions_ExcludedGroupProps);
	   else if (sType3 == GET_STRING(IDS_COMPUTERPROPS))
	      key3 = GET_BSTR(DCTVS_AccountOptions_ExcludedComputerProps);
	}

	/* populate the varset key for Type1 from the exclusion map */
	sExList = L"";
	if (!PropExcMap1.empty())
	{
	      //for each property in the exclusion map, place it's name in 
	      //the comma-seperated varset string
	   for (it = PropExcMap1.begin(); it != PropExcMap1.end(); it++)
	   {
	         //get the next name and associated OID from the map, starts with the first
	      sExList += it->first;
	      sExList += L",";
	   }//end while more to add
	      //remove the trailing ','
	   sExList.SetAt((sExList.GetLength() - 1), L'\0');
	}//end if props to record

	/* store the Type1 excluded properties in the varset */
	pVarSet->put(key1, _bstr_t(sExList));

	/* if a Type2, populate the varset key for Type2 from the exclusion map */
	if (!sType2.IsEmpty())
	{
	   sExList = L"";
	   if (!PropExcMap2.empty())
	   {
	         //for each property in the exclusion map, place it's name in 
	         //the comma-seperated varset string
	      for (it = PropExcMap2.begin(); it != PropExcMap2.end(); it++)
		  {
	            //get the next name and associated OID from the map, starts with the first
	         sExList += it->first;
	         sExList += L",";
		  }//end while more to add
	         //remove the trailing ','
	      sExList.SetAt((sExList.GetLength() - 1), L'\0');
	   }//end if props to record
	}//end if props to record

	/* if Type2, store the Type2 excluded properties in the varset */
	if (!sType2.IsEmpty())
	   pVarSet->put(key2, _bstr_t(sExList));

	/* if a Type3, populate the varset key for Type3 from the exclusion map */
	if (!sType3.IsEmpty())
	{
	   sExList = L"";
	   if (!PropExcMap3.empty())
	   {
	         //for each property in the exclusion map, place it's name in 
	         //the comma-seperated varset string
	      for (it = PropExcMap3.begin(); it != PropExcMap3.end(); it++)
		  {
	            //get the next name and associated OID from the map, starts with the first
	         sExList += it->first;
	         sExList += L",";
		  }//end while more to add
	         //remove the trailing ','
	      sExList.SetAt((sExList.GetLength() - 1), L'\0');
	   }//end if props to record
	}//end if props to record

	/* if Type3, store the Type3 excluded properties in the varset */
	if (!sType3.IsEmpty())
	   pVarSet->put(key3, _bstr_t(sExList));
}
//END saveproperties


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 17 NOV 2000                                                 *
 *                                                                   *
 *     This function is responsible for making an RPC call into the  *
 * given Password DC to see if it is ready to perform password       *
 * migrations.  We return if it is ready or not.  If the DC is not   *
 * ready, we also fill in the msg and title strings.                 *
 *                                                                   *
 *********************************************************************/

//BEGIN IsPasswordDCReady
bool IsPasswordDCReady(CString server, CString& msg, CString& title, UINT *msgtype)
{
    /* local variables */
    IPasswordMigrationPtr   pPwdMig(__uuidof(PasswordMigration));
    HRESULT					hr = S_OK;
    DWORD                   rc = 0;
    CString					sTemp;
    TErrorDct				err;
    _bstr_t					sText;
    WCHAR					sMach[1000];
    DWORD					dwMachLen = 1000;
    IErrorInfoPtr			pErrorInfo = NULL;
    BSTR					bstrDescription;

    /* function body */
    //get a DC from this domain.  We will set a VARSET key so that we use this DC for
    //password migration (and other acctrepl operations)

    if (targetServer.IsEmpty())
    {
        _bstr_t sTgtDCDns;
        _bstr_t sTgtDCFlat;

        rc = GetDcName5(GetTargetDomainName(), DS_DIRECTORY_SERVICE_REQUIRED, sTgtDCDns, sTgtDCFlat);

        if (rc == NO_ERROR)
        {
            //store this DC to use later for the actual migration
            targetServer = (LPCTSTR)sTgtDCFlat;
            targetServerDns = (LPCTSTR)sTgtDCDns;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(rc);
        }
    }

    //
    // Verify that the password server is in fact a domain controller for
    // the source domain.
    //
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC * pDomInfo = NULL;

    DWORD dwerr = DsRoleGetPrimaryDomainInformation((LPCTSTR)server,
        DsRolePrimaryDomainInfoBasic,
        (PBYTE*)&pDomInfo);

    if (dwerr != NO_ERROR)
    {
        sTemp.LoadString(IDS_MSG_PWDDC_CANT_GET_ROLE);
        msg.Format((LPCTSTR)sTemp, (LPCTSTR)server);
        title.LoadString(IDS_MSG_ERROR);
        *msgtype = MB_ICONERROR | MB_OK;
        return false;
    }
    else
    {
        if ((pDomInfo->MachineRole != DsRole_RolePrimaryDomainController) && (pDomInfo->MachineRole != DsRole_RoleBackupDomainController))
        {
            sTemp.LoadString(IDS_MSG_PWDDC_NOT_DC);
            msg.Format(sTemp, (LPCTSTR)server);
            title.LoadString(IDS_MSG_ERROR);
            *msgtype = MB_ICONERROR | MB_OK;
            DsRoleFreeMemory(pDomInfo);
            return false;
        }
    }

    // compare them
    if ( ( (pDomInfo->DomainNameDns != NULL)  &&
        ((LPCTSTR)sourceDNS  != NULL) &&
        (_wcsicmp(pDomInfo->DomainNameDns, (LPCTSTR)sourceDNS)==0) ) ||

        ( (pDomInfo->DomainNameFlat != NULL) &&
        ((LPCTSTR)sourceNetbios != NULL) &&
        (_wcsicmp(pDomInfo->DomainNameFlat, (LPCTSTR)sourceNetbios)==0) ) )
    {
        // at least one of them matches
        DsRoleFreeMemory(pDomInfo);

    }
    else
    {
        // no match
        DsRoleFreeMemory(pDomInfo);
        sTemp.LoadString(IDS_MSG_PWDDC_WRONG_DOMAIN);
        msg.Format((LPCTSTR)sTemp, (LPCTSTR)server, (LPCTSTR)sourceDNS);
        title.LoadString(IDS_MSG_ERROR);
        *msgtype = MB_ICONERROR | MB_OK;
        return false;
    }





    if (SUCCEEDED(hr))
    {
        //try to establish the session, which will check all requirements
        hr = pPwdMig->raw_EstablishSession(_bstr_t(server), _bstr_t(GetTargetDcName()));
        if (SUCCEEDED(hr)) //if success, return true
            return true;
    }

    //try to get the rich error information
    if (SUCCEEDED(GetErrorInfo(0, &pErrorInfo)))
    {
        HRESULT hrTmp = pErrorInfo->GetDescription(&bstrDescription);
        if (SUCCEEDED(hrTmp)) //if got rich error info, use it
            sText = _bstr_t(bstrDescription, false);
        else //else, prepare a standard message and return
        {
            sTemp.LoadString(IDS_MSG_PWDDC_NOT_READY);
            msg.Format((LPCTSTR)sTemp, (LPCTSTR)server, (LPCTSTR)server);
            title.LoadString(IDS_MSG_ERROR);
            *msgtype = MB_ICONERROR | MB_OK;
            return false;
        }
    }
    else //else, prepare a standard message and return
    {
        sTemp.LoadString(IDS_MSG_PWDDC_NOT_READY);
        msg.Format((LPCTSTR)sTemp, (LPCTSTR)server, (LPCTSTR)server);
        title.LoadString(IDS_MSG_ERROR);
        *msgtype = MB_ICONERROR | MB_OK;
        return false;
    }

    //if not enabled on the src, add special question to error info
    if (hr == PM_E_PASSWORD_MIGRATION_NOT_ENABLED)
    {
        sTemp.LoadString(IDS_MSG_PWDDC_DISABLED);
        msg = (LPCTSTR)sText;
        msg += sTemp; //add a question to the end of the error text
        title.LoadString(IDS_MSG_WARNING);
        *msgtype = MB_ICONQUESTION | MB_YESNO;
    }
    //else display the error info
    else
    {
        msg = (LPCTSTR)sText;
        title.LoadString(IDS_MSG_ERROR);
        *msgtype = MB_ICONERROR | MB_OK;
    }

    return false;
}
//END IsPasswordDCReady

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 7 FEB 2001                                                  *
 *                                                                   *
 *     This function is a helper function responsible for checking   *
 * the existance of a directory path, and create any needed          *
 * directories for this path. The given path should not include a    *
 * file and should be a full path and not a relative path.           *
 *     The function returns the newly created path.                  *
 *                                                                   *
 *********************************************************************/

//BEGIN CreatePath
CString CreatePath(CString sDirPath)
{
/* local variables */
   int			tosubtract,tosubtract2, final;
   CString		dir;
   CString		root;
   CString		sEmpty = L"";
   int			nStart = 1;

/* function body */
      //remove any trailing '\' or '/'
   tosubtract = sDirPath.ReverseFind(L'\\');
   tosubtract2 = sDirPath.ReverseFind(L'/');
   final = (tosubtract > tosubtract2) ? tosubtract : tosubtract2;
   if (final==-1)
	  return sEmpty;
   if (sDirPath.GetLength() == (final+1))
      dir = sDirPath.Left(final);
   else
	  dir = sDirPath;

      //try to convert a local relative dir path to a full path
   if (dir.GetAt(0) != L'\\')
   {
      CString szPath;
      LPTSTR pszFilePart;
      CString tempPath = dir;
      tempPath += "\\*.*";
      DWORD cchPath = GetFullPathName(tempPath, 2000, szPath.GetBuffer(2000), &pszFilePart);
      szPath.ReleaseBuffer();
      if ((cchPath != 0) && (cchPath <= 2000))
	  {
         final = szPath.ReverseFind(L'\\');
	     dir = szPath.Left(final);
	  }
   }
   else
      nStart = 2;

   if ((dir.Right(1) == L':') && (validDir(dir)))
	  return dir;

      //find the first '\' or '/' past the "C:" or "\\" at the beginning
   tosubtract = dir.Find(L'\\', nStart);
   tosubtract2 = dir.Find(L'/', nStart);
   if ((tosubtract != -1))
   {
      final = tosubtract;
	  if ((tosubtract2 != -1) && (tosubtract2 < final))
	     final = tosubtract2;
   }
   else if ((tosubtract2 != -1))
      final = tosubtract2;
   else
      return sEmpty;

   final++; //move to the next character
   root = dir.Left(final);
   dir = dir.Right(dir.GetLength()-final);

      //create needed directories
   final = dir.FindOneOf(L"\\/");
   while (final!=-1)
   {
      root += dir.Left(final);
      if (!validDir(root))
	  {
	     int create=CreateDirectory(root.GetBuffer(1000),NULL);
		 root.ReleaseBuffer();
		 if (create==0)return sEmpty;
	  }
	  root += L"\\";
	  dir = dir.Right(dir.GetLength()-final-1);
	  final = dir.FindOneOf(L"\\/");
   }
   root += dir;
   if (!validDir(root))
   {
      int create=CreateDirectory(root.GetBuffer(1000),NULL);
	  root.ReleaseBuffer();
	  if (create==0)return sEmpty;
   }
   return root;	
}
//END CreatePath

void GetValidPathPart(CString sFullPath, CString & sDirectory, CString & sFileName)
{
		//remove the file off the path
    int tosubtract = sFullPath.ReverseFind(L'\\');
	int tosubtract2 = sFullPath.ReverseFind(L'/');
	int final = (tosubtract > tosubtract2) ? tosubtract : tosubtract2;
	if (final == -1) 
	{
		sDirectory = L"";
		sFileName = L"";
		return;
	}

	sDirectory = sFullPath;
	sFileName = sFullPath.Right(sFullPath.GetLength()-(final+1)); //save the filename

	while (final != -1)
	{
		   //see if this shorter path exists
		sDirectory = sDirectory.Left(final);
		if (validDir(sDirectory))
			return;

		   //strip off the next directory from the path
		tosubtract = sDirectory.ReverseFind(L'\\');
		tosubtract2 = sDirectory.ReverseFind(L'/');
		final = (tosubtract > tosubtract2) ? tosubtract : tosubtract2;
	}

	sDirectory = L"";
	return;
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 4 JUNE 2001                                                 *
 *                                                                   *
 *     This function is a helper function responsible for checking   *
 * to see if the given account has previously been migrated.  If it  *
 * has, the function returns TRUE, otherwise, FALSE. We also fill in *
 * the given target account name CStrings.                           *
 *                                                                   *
 *********************************************************************/

//BEGIN HasAccountBeenMigrated
BOOL HasAccountBeenMigrated(CString sAccount, CString& sTgtAcct)
{
    /* local variables */
    BOOL		bMigrated = FALSE;
    int			index;
    CString     sUser=L"", sDomain=L"";

    /* function body */
    //if the account is given in NT4 format (Domain\user) then get the domain and username
    if ((index = sAccount.Find(L'\\')) != -1)
    {
        sDomain = sAccount.Left(index);
        sUser = sAccount.Mid(index + 1);
    }
    //else if in UPN format, so get the domain and username from it
    else if ((index = sAccount.Find(L'@')) != -1)
    {
        GetDomainAndUserFromUPN((LPCTSTR)sAccount, sDomain, sUser);
    }

    //if we got the domain and user names, see if this account has been migrated
    if ((sUser.GetLength()) && (sDomain.GetLength()))
    {
        IVarSetPtr			pVsMO(__uuidof(VarSet));
        IUnknown		  * pUnk = NULL;
        HRESULT				hr;

        hr = pVsMO->QueryInterface(IID_IUnknown, (void**)&pUnk);
        if (SUCCEEDED(hr))
        {
            _bstr_t strFlatName;
            _bstr_t strDnsName;

            DWORD dwError = GetDomainNames5(sDomain, strFlatName, strDnsName);

            if (dwError == ERROR_SUCCESS)
            {
                //see if this account has been migrated to any target domain
                hr = db->raw_GetAMigratedObjectToAnyDomain(_bstr_t(sUser), !strDnsName ? strFlatName : strDnsName, &pUnk);
                pUnk->Release();
                if (hr == S_OK)
                {
                    _bstr_t sTemp;
                    //get the managed object's target adspath
                    sTemp = pVsMO->get(L"MigratedObjects.TargetDomain");

                    dwError = GetDomainNames5(sTemp, strFlatName, strDnsName);

                    if (dwError == ERROR_SUCCESS)
                    {
                        sTgtAcct = (WCHAR*)strFlatName;
                        sTgtAcct += L"\\";
                        sTemp = pVsMO->get(L"MigratedObjects.TargetSamName");
                        sTgtAcct += sTemp;

                        bMigrated = TRUE;
                    }
                }
            }
        }
    }

    return bMigrated;	
}


//END HasAccountBeenMigrated


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 5 JUNE 2001                                                 *
 *                                                                   *
 *     This function is a helper function responsible for confirming *
 * a user's true intent to cancel out of a wizard.                   *
 *                                                                   *
 *********************************************************************/

//BEGIN ReallyCancel
BOOL ReallyCancel(HWND hwndDlg)
{
/* local variables */
	CString msg, title;

/* function body */
		//get the text to display in the message
	msg.LoadString(IDS_MSG_CANCEL_REALLY);
	title.LoadString(IDS_CANCEL_TITLE);
		//if they are sure they want to cancel, return TRUE
	if (MessageBox(hwndDlg,msg,title,MB_YESNO|MB_ICONSTOP) == IDYES)
		return TRUE;
	else
		return FALSE;
}
//END ReallyCancel


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 5 JULY 2001                                                 *
 *                                                                   *
 *     This function is a helper function responsible for checking to*
 * see if the user has requested to retry more than one task on a    *
 * single machine.  It returns the name of the first server found to *
 * have more than one task included for it.  If no machine has more  *
 * than one task includede then we return an empty string.           *
 *                                                                   *
 *********************************************************************/

//BEGIN GetServerWithMultipleTasks
CString GetServerWithMultipleTasks()
{
/* local variables */
	CStringList nameList;
	CString sServer, sStatus, sInclude;
	CString sRetServer = L"";
	BOOL bDup = FALSE;
	int ndx = 0;

/* function body */
		//while there are more selected tasks and no duplicate machine name
	sInclude.LoadString(IDS_INCLUDE); 
	while ((ndx < m_cancelBox.GetItemCount()) && (!bDup))
	{
			//get the status and only check those marked "Include"
		sStatus = m_cancelBox.GetItemText(ndx,5);
		if (sStatus == sInclude)
		{
				//get the server name
			sServer = m_cancelBox.GetItemText(ndx,0);
				//if the server is not in the list, add it
			if (nameList.Find(sServer) == NULL)
				nameList.AddTail(sServer);
			else //else it is in the list
			{
				bDup = TRUE; //set flag to leave loop
				sRetServer = sServer; //set server to return it
			}
		}
		ndx++;
	}
	nameList.RemoveAll(); //delete the list

	return (sRetServer);  //return server name if duplicate or empty string if not
}
//END GetServerWithMultipleTasks

void __stdcall SharedHelp(ADMTSHAREDHELP HelpTopic, HWND hwndDlg)
    {
        int HelpID;
        switch(HelpTopic)
        {
            // help page is "Domain Selection"
            case DOMAIN_SELECTION_HELP:
                {
        
                    if(migration == w_computer)
        	            HelpID = IDH_WINDOW_DOMAIN_SELECTION;
                    else if(migration == w_group)
        	            HelpID = IDH_WINDOW_DOMAIN_SELECTION_GROUP;
                    else if(migration == w_groupmapping)
                    	HelpID = IDH_WINDOW_DOMAIN_SELECTION_GROUPMAP;
                    else if(migration == w_reporting)
        	            HelpID = IDH_WINDOW_DOMAIN_SELECTION_REPORT;
                    else if(migration == w_security)
        	            HelpID = IDH_WINDOW_DOMAIN_SELECTION_SECURITY;
                    else if(migration == w_service)
        	            HelpID = IDH_WINDOW_DOMAIN_SELECTION_SERVICE;
                    else if(migration == w_trust)
        	            HelpID = IDH_WINDOW_DOMAIN_SELECTION_TRUST;
                    else if(migration == w_account)
        	            HelpID = IDH_WINDOW_DOMAIN_SELECTION_USER;
                    else if(migration == w_exchangeDir)
        	            HelpID = IDH_WINDOW_DOMAIN_SELECTION_EXCHANGE;

                    break;
            	}
            // help page is "Group Selection"
            case GROUP_SELECTION_HELP:
            	{
            		if(migration == w_group)
            			HelpID = IDH_WINDOW_GROUP_SELECTION;
            		else if(migration == w_groupmapping)
            			HelpID = IDH_WINDOW_GROUP_SELECTION_GROUPMAP;

            		break;
            	}
            // help page is "Computer Selection"
            case COMPUTER_SELECTION_HELP:
            	{
            		if(migration == w_computer)
            			HelpID = IDH_WINDOW_COMPUTER_SELECTION;
            		else if(migration == w_reporting)
            			HelpID = IDH_WINDOW_COMPUTER_SELECTION_REPORT;
            		else if(migration == w_security)
            			HelpID = IDH_WINDOW_COMPUTER_SELECTION_SECURITY;

            		break;
            	}
            // help page is "Organizational Unit Selection"
            case OU_SELECTION_HELP:
            	{
            		if(migration == w_computer)
            			HelpID = IDH_WINDOW_OU_SELECTION;
            		else if(migration == w_group)
            			HelpID = IDH_WINDOW_OU_SELECTION_GROUP;
            		else if(migration == w_groupmapping)
            			HelpID = IDH_WINDOW_OU_SELECTION_GROUPMAP;
            		else if(migration == w_account)
            			HelpID = IDH_WINDOW_OU_SELECTION_USER;

            		break;
            	}
            // help page is "Translate Objects"
            case TRANSLATE_OBJECTS_HELP:
            	{
            		if(migration == w_computer)
            			HelpID = IDH_WINDOW_OBJECTTYPE_SELECTION;
            		else if(migration == w_security)
            			HelpID = IDH_WINDOW_OBJECTTYPE_SELECTION_SECURITY;

            		break;
            	}
            // help page is "Group Options"
            case GROUP_OPTION_HELP:
            	{
            		if(migration == w_group)
            			HelpID = IDH_WINDOW_GROUP_OPTION;
            		else if(migration == w_groupmapping)
            			HelpID = IDH_WINDOW_GROUP_OPTION_GROUPMAP;

            		break;
            	}
            // help page is "Security Translaton Options"
            case SECURITY_OPTION_HELP:
            	{
            		if(migration == w_computer)
            			HelpID = IDH_WINDOW_SECURITY_OPTION;
            		else if(migration == w_security)
            			HelpID = IDH_WINDOW_SECURITY_OPTION_SECURITY;
            		else if(migration == w_exchangeDir)
            			HelpID = IDH_WINDOW_SECURITY_OPTION_EXCHANGE;

            		break;
            	}
            // help page is "Naming Conflicts"
            case NAME_CONFLICT_HELP:
            	{
            		if(migration == w_computer)
            			HelpID = IDH_WINDOW_NAME_CONFLICT;
            		else if(migration == w_group)
            			HelpID = IDH_WINDOW_NAME_CONFLICT_GROUP;
            		else if(migration == w_account)
            			HelpID = IDH_WINDOW_NAME_CONFLICT_USER;

            		break;
            	}
            // help page is "Confirmation"
            case CONFIRMATION_HELP:
            	{
            		if(migration == w_computer)
            			HelpID = IDH_WINDOW_CONFIRMATION;
            		else if(migration == w_group)
            			HelpID = IDH_WINDOW_CONFIRMATION_GROUP;
            		else if(migration == w_groupmapping)
            			HelpID = IDH_WINDOW_CONFIRMATION_GROUPMAP;
            		else if(migration == w_reporting)
            			HelpID = IDH_WINDOW_CONFIRMATION_REPORT;
            		else if(migration == w_retry)
            			HelpID = IDH_WINDOW_CONFIRMATION_RETRY;
            		else if(migration == w_security)
            			HelpID = IDH_WINDOW_CONFIRMATION_SECURITY;
            		else if(migration == w_service)
            			HelpID = IDH_WINDOW_CONFIRMATION_SERVICE;
            		else if(migration == w_undo)
            			HelpID = IDH_WINDOW_CONFIRMATION_UNDO;
            		else if(migration == w_account)
            			HelpID = IDH_WINDOW_CONFIRMATION_USER;
            		else if(migration == w_exchangeDir)
            			HelpID = IDH_WINDOW_CONFIRMATION_EXCHANGE;
            		else if(migration == w_trust)
            			HelpID = IDH_WINDOW_CONFIRMATION_TRUST;

            		break;
            	}
            // help page is "Test or Make Changes"
            case COMMIT_HELP:
            	{
            		if(migration == w_computer)
            			HelpID = IDH_WINDOW_COMMIT;
            		else if(migration == w_exchangeDir)
            			HelpID = IDH_WINDOW_COMMIT_EXCHANGE;
            		else if(migration == w_group)
            			HelpID = IDH_WINDOW_COMMIT_GROUP;
            		else if(migration == w_groupmapping)
            			HelpID = IDH_WINDOW_COMMIT_GROUPMAP;
            		else if(migration == w_security)
            			HelpID = IDH_WINDOW_COMMIT_SECURITY;
            		else if(migration == w_account)
            			HelpID = IDH_WINDOW_COMMIT_USER;

            		break;
            	}
            // help page is "Object Property Exclusion"
            case OBJECT_PROPERTY_EXCLUSION:
            	{
            		if(migration == w_computer)
            			HelpID = IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION;
            		else if(migration == w_group)
            			HelpID = IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION_GROUP;
            		else if(migration == w_account)
            			HelpID = IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION_USER;

            		break;
            	}
            // help page is "User Account"
            case CREDENTIALS_HELP:
            	{
            		if(migration == w_group)
            			HelpID = IDH_WINDOW_SIDHISTORY_CREDENTIALS;
            		else if(migration == w_groupmapping)
            			HelpID = IDH_WINDOW_SIDHISTORY_CREDENTIALS_GROUPMAP;
            		else if(migration == w_account)
            			HelpID = IDH_WINDOW_SIDHISTORY_CREDENTIALS_USER;
            		else if(migration == w_undo)
            			HelpID = IDH_WINDOW_SIDHISTORY_CREDENTIALS_UNDO;
            		else if(migration == w_exchangeDir)
            			HelpID = IDH_WINDOW_USER_ACC_PASS;

            		break;
            	}
            // help page is "Service Account Informatoin" in service wizard
            case SERVICE_ACCOUNT_INFO:
            	{
            		HelpID = IDH_WINDOW_SERVICE_ACCOUNT_INFO;

            		break;
            	}
            // help page is "User Service Account"
            case USER_SERVICE_ACCOUNT:
            	{
            		if(migration == w_account)
            			HelpID = IDH_WINDOW_USER_SERVICE_ACCOUNT_INFO;
            		else if(migration == w_group)
            			HelpID = IDH_WINDOW_USER_SERVICE_ACCOUNT_GROUP;

            		break;
            	}
            // help page is "Update Information" in Service wizard
            case REFRESH_INFO_HELP:
            	{
            		HelpID = IDH_WINDOW_REFRESH_INFO;

            		break;
            	}
            // help page is "Group Options"
            case GROUP_MEMBER_OPTION:
            	{
            		HelpID = IDH_WINDOW_GROUP_MEMBER_OPTION;

            		break;
            	}
            // help page is "User Options"
            case USER_OPTION_HELP:
            	{
            		HelpID = IDH_WINDOW_USER_OPTION;

            		break;
            	}
            case REPORT_SELECTION_HELP:
            	{
            		HelpID = IDH_WINDOW_REPORT_SELECTION;

            		break;
            	}
            case TASK_SELECTION_HELP:
            	{
            		HelpID = IDH_WINDOW_TASK_SELECTION;

            		break;
            	}
            case PASSWORD_OPTION_HELP:
            	{
            		HelpID = IDH_WINDOW_PASSWORD_OPTION;

            		break;
            	}
            case TARGET_GROUP_SELECTION:
            	{
            		HelpID = IDH_WINDOW_TARGET_GROUP_SELECTION;

            		break;
            	}
            case TRUST_INFO_HELP:
            	{
            		HelpID = IDH_WINDOW_TRUST_INFO;

            		break;
            	}
            case COMPUTER_OPTION:
            	{
            		HelpID = IDH_WINDOW_COMPUTER_OPTION;

            		break;
            	}
            case UNDO_HELP:
            	{
            		HelpID = IDH_WINDOW_UNDO;

            		break;
            	}
            case WELCOME_HELP:
            	{
            		HelpID = IDH_WINDOW_WELCOME;

            		break;
            	}
            case ACCOUNTTRANSITION_OPTION:
            	{
            	    HelpID = IDH_WINDOW_ACCOUNTTRANSITION_OPTION;

            	    break;
            	}
            case EXCHANGE_SERVER_SELECTION:
            	{
            		HelpID = IDH_WINDOW_EXCHANGE_SERVER_SELECTION;

            		break;
            	}
            case USER_SELECTION_HELP:
            	{
            		HelpID = IDH_WINDOW_USER_SELECTION;

            		break;
            	}
            case SERVICE_ACCOUNT_SELECTION:
            	{
            		HelpID = IDH_WINDOW_SERVICE_ACCOUNT_SELECTION;

            		break;
            	}
            case DIRECTORY_SELECTION_HELP:
            	{
            		HelpID = IDH_WINDOW_DIRECTORY_SELECTION;

            		break;
            	}
            case TRANSLATION_OPTION:
            	{
            		HelpID = IDH_WINDOW_TRANSLATION_OPTION;

            		break;
            	}
            	
            default:
            	break;                    
                                   			
        }

        
        helpWrapper(hwndDlg,HelpID);
        
    }


//-----------------------------------------------------------------------------
// SetDefaultExcludedSystemProperties
//
// Synopsis
// Sets the default system property exclusion list if the list has not already
// been generated. Note that the default system property exclusion list consists of
// the mail, proxyAddresses and all  attributes not marked as being part of
// the base schema.
//
// Arguments
// IN hwndDlg - handle to dialog which is used to display message box if error
//              occurs
//
// Return Value
// None
//-----------------------------------------------------------------------------

void __stdcall SetDefaultExcludedSystemProperties(HWND hwndDlg)
{
    try
    {
        //
        // If system property exclusion set value is zero then generate
        // and set default system property exclusion list.
        //

        IVarSetPtr spSettings(__uuidof(VarSet));
        IUnknownPtr spUnknown(spSettings);
        IUnknown* punk = spUnknown;

        db->GetSettings(&punk);

        long lSet = spSettings->get(GET_BSTR(DCTVS_AccountOptions_ExcludedSystemPropsSet));

        if (lSet == 0)
        {
            IObjPropBuilderPtr spObjPropBuilder(__uuidof(ObjPropBuilder));

            _bstr_t strNonBaseProperties = spObjPropBuilder->GetNonBaseProperties(GetTargetDomainName());
            _bstr_t strProperties = _T("mail,proxyAddresses,") + strNonBaseProperties;

            spSettings->put(GET_BSTR(DCTVS_AccountOptions_ExcludedSystemProps), strProperties);

            db->SaveSettings(punk);

            put(DCTVS_AccountOptions_ExcludedSystemProps, strProperties);
        }
    }
    catch (_com_error& ce)
    {
        CString strTitle;
        strTitle.LoadString(IDS_MSG_WARNING);
        CString strFormat;
        strFormat.LoadString(IDS_MSG_UNABLE_SET_EXCLUDED_SYSTEM_PROPERTIES);
        CString strMessage;
        strMessage.Format(strFormat, ce.ErrorMessage());
        MessageBox(hwndDlg, strMessage, strTitle, MB_ICONWARNING|MB_OK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\ouselect.h ===
#if !defined(AFX_CONTAINERSELECTIONDLG_H__D8C6E4B2_0256_48FA_8B27_8B3EE88AC24E__INCLUDED_)
#define AFX_CONTAINERSELECTIONDLG_H__D8C6E4B2_0256_48FA_8B27_8B3EE88AC24E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ContainerSelectionDlg.h : header file
//
#include "resource.h"
//#import "\bin\NetEnum.tlb" no_namespace
#import "NetEnum.tlb" no_namespace

/////////////////////////////////////////////////////////////////////////////
// CContainerSelectionDlg dialog

class CContainerSelectionDlg : public CDialog
{
// Construction
public:
	HRESULT FindContainer();
	CImageList ilist;
	BOOL LoadImageList();
	HRESULT ExpandCompletely(HTREEITEM tvItem, _bstr_t parentCont);
	HRESULT PopulateContainer(HTREEITEM tvItemParent,_bstr_t sContName, INetObjEnumeratorPtr pQuery);
	CString m_strDomain;
	CContainerSelectionDlg(CWnd* pParent = NULL);   // standard constructor
   COLORREF GetFirstBitmapPixel(CWnd * window,UINT idbBitmap);
   HTREEITEM OpenContainer(CString strCont, HTREEITEM root);

// Dialog Data
	//{{AFX_DATA(CContainerSelectionDlg)
	enum { IDD = IDD_CONT_SELECTION };
	CButton	m_btnOK;
	CTreeCtrl	m_trOUTree;
	CString	m_strCont;
	//}}AFX_DATA
   BSTR domain;
   HRESULT BrowseForContainer(HWND hWnd,//Handle to window that should own the browse dialog.
                       LPOLESTR szRootPath, //Root of the browse tree. NULL for entire forest.
                       LPOLESTR *ppContainerADsPath, //Return the ADsPath of the selected container.
                       LPOLESTR *ppContainerClass //Return the ldapDisplayName of the container's class.
                    );


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CContainerSelectionDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CContainerSelectionDlg)
	afx_msg void OnOk();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangedTree1(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkTree1(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONTAINERSELECTIONDLG_H__D8C6E4B2_0256_48FA_8B27_8B3EE88AC24E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\globals.h ===
#pragma once
#include "resource.h"		// main symbols


// From VC98/MFC/Include
#include <afx.h>
#include <afxdisp.h>


// From VC98/Include
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <FCNTL.H>
#include <sys/stat.h>

#define INC_OLE2

#include <windowsx.h>  // for SetWindowFont
#include <objbase.h>
#include <PrSht.h>
#include <shlobj.h>
#include <lm.h>


// From Platform SDK/Include
#include <HtmlHelp.h>
#include <objsel.h>

#include <DSCLIENT.H>
#include <dsgetdc.h>

#include <map>

#include "ResStr.h"
#include "TReg.hpp"
#include "ErrDct.hpp"
#include "WNetUtil.h"
#include "OuSelect.h"
#include "TrstDlg.h"
#include "HelpID.h"
#include "SidHistoryFlags.h"
#include "UString.hpp"
#include "HrMsg.h"
#include "Validation.h"
//#include "TxtSid.h"

//#import "\bin\MigDrvr.tlb" no_namespace, named_guids
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\DBManager.tlb" no_namespace, named_guids
//#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids
//#import "\bin\ScmMigr.tlb" no_namespace, named_guids
//#import "\bin\TrustMgr.tlb" no_namespace, named_guids
#import "MigDrvr.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#import "DBMgr.tlb" no_namespace, named_guids
#import "WorkObj.tlb" no_namespace, named_guids
#import "ScmMigr.tlb" no_namespace, named_guids
#import "TrustMgr.tlb" no_namespace, named_guids
#import "AdsProp.tlb" no_namespace
#import "MsPwdMig.tlb" no_namespace

#define SvcAcctStatus_NotMigratedYet			0
#define SvcAcctStatus_DoNotUpdate			   1
#define SvcAcctStatus_Updated				      2
#define SvcAcctStatus_UpdateFailed			   4
#define SvcAcctStatus_NeverAllowUpdate       8

#define w_account                       1
#define w_group                         2
#define w_computer                      3
#define w_security                      4
#define w_service                       5
#define w_undo                          6
#define w_exchangeDir                   7
#define w_reporting                     8
#define w_retry                         9
#define w_trust                         10
#define w_exchangeSrv                   11
#define w_groupmapping                  12
#ifndef BIF_USENEWUI
#define BIF_USENEWUI					0x0040
#endif

#define REAL_PSH_WIZARD97               0x01000000

typedef int (CALLBACK * DSBROWSEFORCONTAINER)(PDSBROWSEINFOW dsInfo);
extern DSBROWSEFORCONTAINER DsBrowseForContainerX;
typedef struct SHAREDWIZDATA {
	HFONT hTitleFont;
	bool IsSidHistoryChecked;
	int renameSwitch;
	bool prefixorsuffix;
	bool expireSwitch;
	bool refreshing;
	bool someService;
	bool memberSwitch;
	bool proceed;
	bool translateObjects;
	long rebootDelay;
	int accounts,servers;
	bool sameForest;
	bool newSource;
	bool resetOUPATH;
	bool sourceIsNT4;
	bool targetIsNT4;
	bool sort[6];
	bool migratingGroupMembers;
	bool targetIsMixed;
	bool secWithMapFile;
	
} SHAREDWIZDATA, *LPSHAREDWIZDATA;


extern					CEdit pEdit ;

extern IVarSet *			pVarSet;  
extern IVarSet *			pVarSetUndo; 
extern IVarSet *			pVarSetService;
extern IIManageDB *		db;
extern UINT g_cfDsObjectPicker;
extern IDsObjectPicker *pDsObjectPicker;
extern IDataObject *pdo;
extern IDsObjectPicker *pDsObjectPicker2;
extern IDataObject *pdo2;
extern int migration;
extern CComModule _Module;
extern CListCtrl m_listBox;
extern CListCtrl m_cancelBox;
extern CListCtrl m_reportingBox;
extern CListCtrl m_serviceBox;
extern CComboBox m_rebootBox;
extern CListCtrl m_trustBox;
extern CString sourceDNS;
extern CString targetDNS;
extern CString sourceNetbios;
extern CString targetNetbios;
extern StringLoader 			gString;
extern TErrorDct 			err;
extern CComboBox sourceDrop;
extern CComboBox targetDrop;
extern bool alreadyRefreshed;
extern BOOL gbNeedToVerify;
extern _bstr_t yes,no;
extern _bstr_t yes,no;
extern CString lastInitializedTo;
extern CComboBox additionalDrop;
extern bool clearCredentialsName;
extern CString sourceDC;
extern CStringList DCList;

//
// Define a map that maps an attribute's LDAP Display Name to it's OID.
// Note that the key comparison is defined to be case in-sensitive.
//

struct lessPropertyNameToOID
{
    bool operator()(const CString strA, const CString strB) const
    {
        return strA.CompareNoCase(strB) < 0;
    }
};
typedef std::map<CString, CString, lessPropertyNameToOID> CPropertyNameToOIDMap;

extern CPropertyNameToOIDMap	PropIncMap1;
extern CPropertyNameToOIDMap	PropExcMap1;
extern CPropertyNameToOIDMap	PropIncMap2;
extern CPropertyNameToOIDMap	PropExcMap2;
extern CPropertyNameToOIDMap	PropIncMap3;
extern CPropertyNameToOIDMap	PropExcMap3;
extern CString	sType1, sType2, sType3;
extern bool bChangedMigrationTypes;
extern bool bChangeOnFly;
extern CString targetServer;
extern CString targetServerDns;

//
// TODO:
//

inline PCTSTR __stdcall GetSourceDomainName()
{
    return sourceDNS.IsEmpty() ? sourceNetbios : sourceDNS;
}

inline PCTSTR __stdcall GetSourceDomainNameDns()
{
    return sourceDNS;
}

inline PCTSTR __stdcall GetSourceDomainNameFlat()
{
    return sourceNetbios;
}

inline PCTSTR __stdcall GetTargetDomainName()
{
    return targetDNS.IsEmpty() ? targetNetbios : targetDNS;
}

inline PCTSTR __stdcall GetTargetDomainNameDns()
{
    return targetDNS;
}

inline PCTSTR __stdcall GetTargetDomainNameFlat()
{
    return targetNetbios;
}

inline PCTSTR __stdcall GetTargetDcName()
{
    return targetServerDns.IsEmpty() ? targetServer : targetServerDns;
}

inline PCTSTR __stdcall GetTargetDcNameDns()
{
    return targetServerDns;
}

inline PCTSTR __stdcall GetTargetDcNameFlat()
{
    return targetServer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__220B8985_4139_11D3_AF77_0090275A583D__INCLUDED_)
#define AFX_STDAFX_H__220B8985_4139_11D3_AF77_0090275A583D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _DEBUG
//#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
//#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC Automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <iads.h>
#include <adshlp.h>
#include <comdef.h>
#include <atlbase.h>
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__220B8985_4139_11D3_AF77_0090275A583D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wizards.rc
//
#define IDS_MYTITLE2                    1
#define IDS_VALID_DIGITS                2
#define IDS_COLON                       3
#define IDS_TRUST_INFO                  3
#define ID_DIALOG_FONTSIZE              8
#define IDS_REBOOT_SUB                  12
#define IDS_UNDO                        13
#define IDS_UNDO_SUB                    14
#define IDS_SECURITY                    15
#define IDS_SECURITY_SUB                16
#define IDM_ABOUTBOX                    0x0010
#define IDS_SECURITY_OPTIONS            17
#define IDS_SECURITY_OPTIONS_SUB        18
#define IDS_SECURITY_FURTHER            19
#define IDS_SECURITY_FURTHER_SUB        20
#define IDS_SECURITY_SUB2               21
#define IDS_MSG_SELECT_TRUST            22
#define IDS_COMPUTER                    23
#define IDS_COMPUTER_SUB                24
#define IDS_COMPUTER_OPTIONS            25
#define IDS_COMPUTER_OPTIONS_SUB        26
#define IDS_COMPUTER_FURTHER            27
#define IDS_COMPUTER_FURTHER_SUB        28
#define IDS_CLOSED                      29
#define IDS_CLOSED_SUB                  30
#define IDS_CREDENTIALS                 31
#define IDS_CREDENTIALS_SUB             32
#define IDS_EXCHANGE                    33
#define IDS_EXCHANGE_SUB                34
#define IDS_ACCOUNT_TITLE               35
#define IDS_DOMAIN2                     36
#define IDS_COMPUTER_TITLE              37
#define IDS_SECURITY_TITLE              38
#define IDS_CREDENTIALS2                39
#define IDS_CREDENTIALS_SUB2            40
#define IDS_GROUP_TITLE                 41
#define IDS_UNDO_TITLE                  42
#define IDS_CREDENTIALS3                43
#define IDS_CREDENTIALS_SUB3            44
#define IDS_RETRY_TITLE                 45
#define IDS_RETRY                       46
#define IDS_RETRY_SUB                   47
#define IDS_MSG_NO_REPORT               48
#define IDS_COMMIT                      48
#define IDS_MSG_NO_REPORT2              49
#define IDS_COMMIT_SUB                  49
#define IDS_MSG_NO_REPORT3              50
#define IDS_TRUST_TITLE                 50
#define IDS_MSG_NO_REPORT4              51
#define IDS_TRUST                       51
#define IDS_MSG_NO_REPORT5              52
#define IDS_TRUST_SUB                   52
#define IDS_MSG_NO_REPORT6              53
#define IDS_CREDENTIALS_TRUST           53
#define IDS_MSG_NO_REPORT7              54
#define IDS_CREDENTIALS_TRUST_SUB       54
#define IDS_MSG_NO_REPORT8              55
#define IDS_GROUPMAPPING_TITLE          55
#define IDS_MSG_NO_REPORT9              56
#define IDS_GROUPMAPPING                56
#define IDS_MSG_NO_REPORT10             57
#define IDS_GROUPMAPPING_SUB            57
#define IDS_REBOOT_SUB2                 57
#define IDS_OPTIONS_FROM_USER           57
#define IDS_MSG_NO_REPORT11             58
#define IDS_GROUP_MAPPING               58
#define IDS_MSG_NO_REPORT12             59
#define IDS_GROUP_MAPPING_SUB           59
#define IDS_TARGET_GROUP                60
#define IDS_TARGET_GROUP_SUB            61
#define IDS_MSG_FOREST                  62
#define IDS_MSG_DISABLED_TRUST          63
#define IDS_MSG_CANCEL                  64
#define IDS_MSG_PASSWORD_POLICY         65
#define IDC_MSG_SELECT_COPY_MEMBER      66
#define IDS_MSG_DIRECTION_TRUST         67
#define IDS_MSG_GROUPMAPPING            68
#define IDS_OPTIONS_FROM_USER_SUB       69
#define IDS_NOT_CREATED                 70
#define IDS_FIVE                        71
#define IDS_TEXT                        72
#define IDS_30                          73
#define IDS_STRING104                   99
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_DELETEME_DIALOG             102
#define IDD_ACCOUNT_INTRO               103
#define IDD_INTRO_ACCOUNT               103
#define IDD_COMPUTER_INTRO              104
#define IDD_INTRO_COMPUTER              104
#define IDD_SECURITY_INTRO              105
#define IDD_INTRO_SECURITY              105
#define IDD_UNDO_INTRO                  106
#define IDD_INTRO_UNDO                  106
#define IDD_FOR_REAL                    108
#define IDD_REBOOT                      108
#define IDD_UNDO                        109
#define IDD_DOMAIN_SELECTION            111
#define IDD_UNDO_END                    112
#define IDD_END_UNDO                    112
#define IDD_ACCOUNT_SELECTION           114
#define IDD_SELECTION                   114
#define IDD_COMPUTER_SELECTION          115
#define IDD_SECURITY_SELECTION          116
#define IDD_ACCOUNT_OPTIONS             117
#define IDD_COMPUTER_OPTIONS            118
#define IDD_SECURITY_OPTIONS            119
#define IDD_ACCOUNT_FURTHER             120
#define IDD_COMPUTER_FURTHER            121
#define IDD_SECURITY_END                122
#define IDD_END_SECURITY                122
#define IDD_CLOSED_SET                  123
#define IDD_COMPUTER_END                124
#define IDD_END_COMPUTER                124
#define IDD_ACCOUNT_END                 125
#define IDD_END_ACCOUNT                 125
#define IDR_OUPICKTYPE                  129
#define IDD_CONT_SELECTION              130
#define IDB_CONT                        132
#define IDB_OU                          133
#define IDB_OPEN_CONT                   134
#define IDB_OPEN_DIR                    135
#define IDB_OPEN_OU                     136
#define IDD_HISTORY                     138
#define IDD_SECURITY_EXCHANGE           139
#define IDD_EXCHANGE                    139
#define IDD_OPTIONS_EXCHANGE            139
#define IDD_GROUP_END                   140
#define IDD_END_GROUP                   140
#define IDD_GROUP_FURTHER               141
#define IDD_GROUP_INTRO                 142
#define IDD_INTRO_GROUP                 142
#define IDD_GROUP_SELECTION             144
#define IDD_CREDENTIALS                 145
#define IDD_SID_HISTORY                 147
#define IDD_ACCOUNT_OPTIONS2            148
#define IDD_ACCOUNT_OPTIONS3            149
#define IDD_ACCOUNT_OPTIONS4            150
#define IDD_ACCOUNT_OPTIONS5            151
#define IDD_ACCOUNT_OPTIONS6            152
#define IDD_ACCOUNT_OPTIONS7            153
#define IDD_ACCOUNT_OPTIONS8            154
#define IDD_ACCOUNT_OPTIONS9            155
#define IDD_ACCOUNT_OPTIONS10           156
#define IDD_ACCOUNT_OPTIONS11           157
#define IDD_ACCOUNT_OPTIONS12           158
#define IDC_ACCOUNT_BEGIN_TITLE         200
#define IDC_GROUP_BEGIN_TITLE           200
#define IDC_ACCOUNT_END_TITLE           201
#define IDC_GROUP_END_TITLE             201
#define IDC_COMPUTER_BEGIN_TITLE        202
#define IDC_COMPUTER_END_TITLE          203
#define IDC_SECURITY_BEGIN_TITLE        204
#define IDC_SECURITY_END_TITLE          205
#define IDC_UNDO_BEGIN_TITLE            206
#define IDC_UNDO_END_TITLE              207
#define IDC_GROUP2                      210
#define IDC_GROUP1                      211
#define IDC_NOCHANGE                    212
#define IDC_CHANGEIT                    212
#define IDC_EDIT_DOMAIN                 300
#define IDC_EDIT_DOMAIN2                301
#define IDC_LIST_MEMBERS1               302
#define IDC_LIST_MEMBERS2               303
#define IDC_LIST_MEMBERS3               304
#define IDC_OPEN_SELECTION1             305
#define IDC_OPEN_SELECTION2             305
#define IDC_BACKTRACK1                  306
#define IDC_BACKTRACK2                  306
#define IDC_EDIT_Container1             307
#define IDC_EDIT_Container2             307
#define IDC_OPEN_SELECTION3             308
#define IDC_BACKTRACK3                  309
#define IDC_EDIT_Container3             310
#define IDC_GO1                         311
#define IDC_GO2                         312
#define IDC_GO3                         313
#define IDR_MAINFRAME                   500
#define IDC_TREE1                       1000
#define IDC_HISTORY                     1001
#define IDC_EDIT1                       1001
#define IDC_HISTORY_TITLE               1002
#define IDC_ADDITIONAL_TRUSTING_DOMAIN  1002
#define IDC_COPY_USERS                  1039
#define IDC_COPY_GLOBAL_GROUPS          1040
#define IDC_COPY_GROUPS                 1040
#define IDC_COPY_LOCAL_GROUPS           1041
#define IDC_COPY_COMPUTERS              1042
#define IDC_COPY_OUS                    1043
#define IDC_COPY_UNIVERSAL_GROUPS       1044
#define IDC_SETTINGS3                   1045
#define IDC_ADD_SID_HISTORY             1050
#define IDC_REMOVE_EXISTING_USER_RIGHTS 1051
#define IDC_FIX_MEMBERSHIP              1051
#define IDC_COPY_CONTAINER_CONTENTS     1052
#define IDC_UPDATE_USER_RIGHTS          1053
#define IDC_DISABLE_SOURCE_ACCOUNTS     1054
#define IDC_REPLACE_EXISTING_ACCOUNTS   1055
#define IDC_DISABLE_COPIED_ACCOUNTS     1056
#define IDC_REPLACE_EXISTING_GROUP_MEMBERS 1057
#define IDC_DISABLE_NEITHER_ACCOUNT     1058
#define IDC_TRANSLATE_ROAMING_PROFILES  1059
#define IDC_RESELECT                    1060
#define IDC_ABORT                       1061
#define IDC_GATHER                      1062
#define IDC_UPDATE                      1062
#define IDC_SETTINGS1                   1063
#define IDC_SETTINGS                    1063
#define IDC_SETTINGS2                   1064
#define IDC_FILES2                      1065
#define IDC_ADD_SID_HISTORY2            1066
#define IDC_SHARES2                     1067
#define IDC_REMOVE_EXISTING_USER_RIGHTS2 1068
#define IDC_COPY_CONTAINER_CONTENTS2    1069
#define IDC_MAPI_PROFILE                1069
#define IDC_UPDATE_USER_RIGHTS2         1070
#define IDC_TRANSLATE_MAILBOXES         1070
#define IDC_TRANSLATE_CONTAINERS        1071
#define IDC_TARGET_OU                   1071
#define IDC_PREFIX                      1073
#define IDC_SUFFIX                      1074
#define IDC_CREDENTIALS_DOMAIN          1075
#define IDC_ADD_TO_GROUP                1075
#define IDC_CREDENTIALS_USERNAME        1076
#define IDC_ADD_TO_GROUP_ON_SOURCE_DOMAIN 1076
#define IDC_CREDENTIALS_PASSWORD        1077
#define IDC_PASSWORD_FILE               1077
#define IDC_DOMAINNAME                  1078
#define IDC_DISABLE_COPIED_ACCOUNTS2    1080
#define IDC_REPLACE_EXISTING_ACCOUNTS2  1081
#define IDC_PRINTERS2                   1082
#define IDC_DISABLE_SOURCE_ACCOUNTS2    1083
#define IDC_USER_RIGHTS2                1084
#define IDC_REPLACE_EXISTING_GROUP_MEMBERS2 1085
#define IDC_REGISTRY2                   1085
#define IDC_LOCAL_GROUPS2               1086
#define IDC_GENERATE_STRONG_PASSWORDS2  1087
#define IDC_USER_PROFILES2              1088
#define IDC_TRANSLATE_ROAMING_PROFILES2 1089
#define IDC_TRANSLATION_MODE_REPLACE2   1090
#define IDC_TRANSLATION_MODE_REMOVE2    1091
#define IDC_TRANSLATION_MODE_ADD2       1092
#define IDC_GATHER_INFORMATION2         1093
#define IDC_COPY_USERS2                 1100
#define IDC_COPY_GLOBAL_GROUPS2         1101
#define IDC_COPY_UNIVERSAL_GROUPS2      1102
#define IDC_COPY_LOCAL_GROUPS2          1103
#define IDC_COPY_COMPUTERS2             1104
#define IDC_FILES3                      2065
#define IDC_ADD_SID_HISTORY3            2066
#define IDC_SHARES3                     2067
#define IDC_REMOVE_EXISTING_USER_RIGHTS3 2068
#define IDC_COPY_CONTAINER_CONTENTS3    2069
#define IDC_UPDATE_USER_RIGHTS3         2070
#define IDC_DISABLE_COPIED_ACCOUNTS3    2080
#define IDC_REPLACE_EXISTING_ACCOUNTS3  2081
#define IDC_PRINTERS3                   2082
#define IDC_DISABLE_SOURCE_ACCOUNTS3    2083
#define IDC_USER_RIGHTS3                2084
#define IDC_REPLACE_EXISTING_GROUP_MEMBERS3 2085
#define IDC_LOCAL_GROUPS3               2086
#define IDC_GENERATE_STRONG_PASSWORDS3  2087
#define IDC_USER_PROFILES3              2088
#define IDC_TRANSLATE_ROAMING_PROFILES3 2089
#define IDC_TRANSLATION_MODE_REPLACE3   2090
#define IDC_TRANSLATION_MODE_REMOVE3    2091
#define IDC_TRANSLATION_MODE_ADD3       2092
#define IDC_GATHER_INFORMATION3         2093
#define IDC_REGISTRY3                   2093
#define IDC_SETTINGS4                   3000
#define IDC_SETTINGS5                   3001
#define IDC_UNDO_TASK                   3002
#define IDC_TRANSLATE_EXCHANGE          4000
#define IDC_BROWSE                      4001
#define IDC_GENERATE_STRONG_PASSWORDS   4003
#define IDB_WATERMARK                   4004
#define IDB_WATERMARK_USER              4004
#define IDC_SET_EXPIRATION              4005
#define IDB_HEADER                      4005
#define IDB_HEADER_ARROW                4005
#define IDC_SRC_EXPIRE_ACCOUNTS         4005
#define IDC_GENERATE_STRONG_PASSWORDS_NOT 4006
#define IDR_ACCELERATOR1                4006
#define IDC_EXPIRATION_DATE             4007
#define IDC_DISABLE_NEITHER_ACCOUNT2    4007
#define IDC_MIGRATE_GROUPS_OF_USERS     4008
#define IDC_SKIP_CONFLICTING_ACCOUNTS   4009
#define IDC_REPLACE_CONFLICTING_ACCOUNTS 4010
#define IDC_RENAME_CONFLICTING_ACCOUNTS 4011
#define IDC_RADIO4                      4012
#define IDC_RADIO_PREFIX                4012
#define IDC_RADIO2                      4013
#define IDC_RADIO_SUFFIX                4013
#define IDC_RADIO_SKIP                  4013
#define IDC_REBOOT                      4014
#define IDC_ADD_BUTTON                  4014
#define IDC_RADIO_NONE                  4014
#define IDC_CREDENTIALS_DOMAIN2         4015
#define IDC_CREDENTIALS_USERNAME2       4016
#define IDC_REMOVE_BUTTON               4016
#define IDC_CREDENTIALS_PASSWORD2       4017
#define IDC_FILES                       4018
#define IDB_WATERMARK_SECURITY          4018
#define IDC_SHARES                      4019
#define IDC_PRINTERS                    4020
#define IDB_WATERMARK_GROUP             4020
#define IDC_USER_RIGHTS                 4021
#define IDC_LOCAL_GROUPS                4022
#define IDB_WATERMARK_COMPUTER          4022
#define IDC_USER_PROFILES               4023
#define IDC_REGISTRY                    4024
#define IDC_TRANSLATION_MODE_REPLACE    4025
#define IDC_TRANSLATION_MODE_ADD        4026
#define IDB_HEADER_KEY                  4026
#define IDC_TRANSLATION_MODE_REMOVE     4027
#define IDC_COPY_GROUP_MEMBERS          4029
#define IDC_COPY_USER_RIGHTS            4030
#define IDB_WATERMARK_EXCHANGE          4030
#define IDC_DESCRIPTION_TITLE           4031
#define IDB_WATERMARK_REPORTING         4031
#define IDC_MIGRATION_END               4032
#define IDB_WATERMARK_SERVICE_ACCOUNT   4032
#define IDC_yo                          4033
#define IDB_HEADER_BOOK                 4033
#define IDC_DATE                        4034
#define IDD_TRANSLATION_SRC             4038
#define IDD_PROP_EXCLUSION              4039
#define IDC_COMBO2                      4044
#define IDC_RADIO_GATHER                4047
#define IDC_RADIO1                      4048
#define IDC_REFRESH                     4048
#define IDC_CHANGE                      4048
#define IDC_DONTCHANGE                  4048
#define IDC_MIG_PASSWORDS               4048
#define IDC_TRANS_FROM_MOT              4048
#define IDC_ROAMING_OR_SIDHISTORY       4048
#define IDC_RADIO3                      4049
#define IDC_NO_REFRESH                  4049
#define IDC_SRC_LEAVE_ACCOUNTS          4049
#define IDC_DATETIMEPICKER1             4050
#define IDC_TRANS_FROM_FILE2            4050
#define IDC_TRANS_FROM_FILE             4050
#define IDC_EXCLUDE_BUTTON              4053
#define IDC_EXCLUDE_BUTTON2             4055
#define IDC_UPDATE_BUTTON2              4056
#define IDC_SKIP                        4057
#define IDC_LIST_SERVICE                4058
#define IDC_LIST_SERVICE2               4059
#define IDC_END_TITLE                   4063
#define IDC_BEGIN_TITLE                 4065
#define IDC_HTML_TARGET                 4066
#define IDC_LIST_REPORTING              4069
#define IDC_STATIC_ID                   4071
#define IDC_LIST_RETRY                  4072
#define IDC_CANCEL                      4073
#define IDC_TOGGLE                      4074
#define IDC_MIGRATE                     4077
#define IDC_OK                          4078
#define IDC_PASSWORD                    4080
#define IDC_USERNAME                    4081
#define IDC_REMIGRATE_OBJECTS           4082
#define IDC_EXCHANGE_SERVER             4083
#define IDC_PRE                         4084
#define IDC_SUF                         4085
#define IDC_RADIO_SUF                   4086
#define IDC_RADIO_PRE                   4087
#define IDC_ADD_SOURCE                  4088
#define IDC_ADD_TARGET                  4090
#define IDC_CREATEMAPPING               4092
#define IDC_TARGET                      4095
#define IDC_BUTTON1                     4096
#define IDC_TARGET_GROUP                4097
#define IDC_SCROLLBAR1                  4099
#define IDC_MYTITLE                     4107
#define IDC_TEXT                        4111
#define IDC_THERENAMINGTITLE            4113
#define IDC_PASSWORD_EDIT               4114
#define IDC_PASSWORD_DC                 4118
#define IDC_MAPPING_FILE                4119
#define IDC_REMOVE_EXISTING_LOCATION    4120
#define IDC_PROPTREE                    4121
#define IDC_INCLUDEBTN                  4122
#define IDC_INCLUDELIST                 4123
#define IDC_EXCLUDELIST                 4124
#define IDC_EXCLUDEBTN                  4125
#define IDC_OBJECTCMBO                  4126
#define IDC_EXCLUDEPROPS                4127
#define IDC_DATEPICKER                  4133
#define IDC_TGT_ENABLE_ACCOUNT          4134
#define IDC_SRC_DISABLE_ACCOUNTS        4135
#define IDC_TGT_ENABLE_ACCOUNTS         4136
#define IDC_SRC_DISABLE_ACCOUNTS_LATER  4137
#define IDC_TGT_DISABLE_ACCOUNTS        4138
#define IDC_TGT_SAME_AS_SOURCE          4139
#define IDC_SIDTEXT                     4143
#define IDS_ACCOUNT_FURTHER             4464
#define IDD_USER_RIGHTS                 5001
#define IDD_RENAMING                    5002
#define IDD_DISABLE                     5003
#define IDD_PASSWORD                    5004
#define IDD_TRANSLATE_ROAMING_PROFILES  5005
#define IDD_OPTIONS                     5005
#define IDD_OU_SELECTION                5006
#define IDD_ADD_TO_GROUP                5007
#define IDD_REPLACE_EXISTING_GROUP_MEMBERS 5008
#define IDD_TRANSLATION                 5009
#define IDD_TRANSLATION_MODE            5010
#define IDD_CREDENTIALS2                5011
#define IDD_OPTIONS_GROUP               5012
#define IDD_INTRO_EXCHANGESERVICE       5014
#define IDD_INTRO_SERVICE               5015
#define IDD_INTRO_REPORTING             5016
#define IDD_INTRO_EXCHANGE              5017
#define IDD_INTRO_EXCHANGE_DIR          5017
#define IDD_END_SERVICE                 5018
#define IDD_END_EXCHANGESERVICE         5019
#define IDD_END_REPORTING               5020
#define IDD_END_EXCHANGE                5021
#define IDD_END_EXCHANGE_SRV            5021
#define IDD_SA_REFRESH                  5023
#define IDD_SA_GATHER                   5024
#define IDD_SA_GATHER_INITIAL           5025
#define IDD_SA_INFO                     5026
#define IDD_SA_INFO2                    5027
#define IDD_HTML_LOCATION               5028
#define IDS_DOMAIN                      10000
#define IDS_SID_HISTORY                 10001
#define IDS_SID_HISTORY_SUB             10002
#define IDS_USER_RIGHTS                 10003
#define IDS_USER_RIGHTS_SUB             10004
#define IDS_RENAMING                    10005
#define IDS_RENAMING_SUB                10006
#define IDS_RENAMING_SUB1               10006
#define IDS_DISABLE                     10007
#define IDS_DISABLE_SUB                 10008
#define IDS_PASSWORD                    10009
#define IDS_PASSWORD_SUB                10010
#define IDS_TRANSLATE_ROAMING_PROFILES  10011
#define IDS_OPTIONS                     10011
#define IDS_TRANSLATE_ROAMING_PROFILES_SUB 10012
#define IDS_OPTIONS_SUB                 10012
#define IDS_OU_SELECTION                10013
#define IDS_OU_SELECTION_SUB            10014
#define IDS_ADD_TO_GROUP                10015
#define IDS_ADD_TO_GROUP_SUB            10016
#define IDS_OPTIONS_GROUP               10017
#define IDS_OPTIONS_GROUP_SUB           10018
#define IDS_SELECTION                   10019
#define IDS_SELECTION_SUB               10020
#define IDS_REPLACE_EXISTING            10021
#define IDS_REPLACE_EXISTING_SUB        10022
#define IDS_TRANSLATION_MODE            10023
#define IDS_RENAMING_SUB3               10023
#define IDS_TRANSLATION_MODE_SUB        10024
#define IDS_TRANSLATION                 10025
#define IDS_TRANSLATION_SUB             10026
#define IDS_GROUP                       10027
#define IDS_GROUP_SUB                   10028
#define IDS_RENAMING_SUB2               10029
#define IDS_SERVICE_TITLE               10030
#define IDS_SERVICE                     10031
#define IDS_SERVICE_SUB                 10032
#define IDS_REPORTING_TITLE             10033
#define IDS_REPORTING                   10034
#define IDS_REPORTING_SUB               10035
#define IDS_OPTIONS_REPORTING           10036
#define IDS_OPTIONS_REPORTING_SUB       10037
#define IDD_OPTIONS_REPORTING           10038
#define IDS_OPTIONS_EXCHANGE            10038
#define IDS_OPTIONS_GROUPMAPPING_SUB    10038
#define IDS_EXCHANGE_TITLE              10039
#define IDD_END_RETRY                   10039
#define IDS_EXCHANGESERVICE_TITLE       10040
#define IDD_INTRO_RETRY                 10040
#define IDS_EXCHANGESERVICE             10041
#define IDD_RETRY                       10041
#define IDS_EXCHANGESERVICE_SUB         10042
#define IDD_SA_INFO_BUTTON              10042
#define IDB_DIR                         10043
#define IDS_OPTIONS_EXCHANGE_SUB        10043
#define IDD_COMMIT                      10043
#define IDS_SA_INFO                     10044
#define IDD_END_TRUST                   10044
#define IDS_SA_INFO_SUB                 10045
#define IDD_INTRO_TRUST                 10045
#define IDS_SA_GATHER                   10046
#define IDD_TRUST_INFO                  10046
#define IDS_SA_GATHER_SUB               10047
#define IDD_CREDENTIALS_TRUST           10047
#define IDS_SA_REFRESH                  10048
#define IDD_INTRO_EXCHANGE_SRV          10048
#define IDS_SA_REFRESH_SUB              10049
#define IDD_END_EXCHANGE_DIR            10049
#define IDS_HTML_LOCATION               10050
#define IDD_EXCHANGE_SELECTION          10050
#define IDS_HTML_LOCATION_SUB           10051
#define IDD_INTRO_GROUPMAPPING          10051
#define IDS_EXCHANGE_DIR_TITLE          10052
#define IDD_END_GROUPMAPPING            10052
#define IDD_GROUPMAPPING                10053
#define IDD_TARGET_GROUP                10053
#define IDS_EXCHANGE_SRV_TITLE          10054
#define IDD_OPTIONS_GROUPMAPPING        10054
#define IDS_EXCHANGE_SELECTION          10055
#define IDD_OPTIONS_FROM_USER           10055
#define IDS_EXCHANGE_SELECTION_SUB      10056
#define IDD_SELECTION1                  10056
#define IDS_VALID_STRING                10057
#define IDD_SELECTION2                  10057
#define IDS_VALID_REBOOT                10058
#define IDD_SELECTION3                  10058
#define IDD_SELECTION4                  10059
#define IDS_ACCOUNT_FURTHER_SUB         14464
#define IDS_DOMAIN_SUB                  20000
#define IDS_MSG_INPUT                   20001
#define IDS_MSG_ERROR                   20002
#define IDS_MSG_REPORT                  20003
#define IDS_MSG_DIRECTORY               20004
#define IDS_MSG_OBJECTPICKER            20005
#define IDS_MSG_OBJECTPICKER_SOURCE     20005
#define IDS_MSG_OU                      20006
#define IDS_MSG_CREDENTIALS             20007
#define IDS_MSG_OBJECT                  20008
#define IDS_MSG_UNIQUE                  20009
#define IDS_MSG_SOURCE                  20010
#define IDS_MSG_TARGET                  20011
#define IDS_MSG_TARGET_ADMIN            20012
#define IDS_MSG_SOURCE_ADMIN            20013
#define IDS_MSG_TARGET_NATIVE           20014
#define IDS_MSG_PATH                    20015
#define IDS_MSG_DC                      20016
#define IDC_MSG_CANCEL                  20017
#define IDS_MSG_FAILED                  20018
#define IDS_MSG_STRING                  20019
#define IDS_MSG_SERVICE                 20020
#define IDS_MSG_CREDENTIALS2            20021
#define IDS_MSG_TRUST                   20022
#define IDS_MSG_DIRECTORY1              20023
#define IDS_MSG_REBOOT                  20024
#define IDS_MSG_EXCHANGE                20025
#define IDS_HELPFILE                    20026
#define IDS_MSG_OBJECTPICKER_TARGET     20027
#define IDS_MSG_BLANK                   20028
#define IDS_MSG_WARNING                 20029
#define IDS_MSG_WARNING_LENGTH          20030
#define IDS_MSG_ERRORBUF                20031
#define IDS_MSG_PERMANENT_REMOVE        20032
#define IDS_MSG_ENABLE_TARGET           20033
#define IDS_MSG_ENABLE_SOURCE           20034
#define IDS_MSG_REGKEY                  20035
#define IDS_MSG_SID_HISTORY             20036
#define IDS_MSG_REBOOT_SID              20037
#define IDS_MSG_DOMAIN                  20038
#define IDS_MSG_TIME                    20039
#define IDS_MSG_LOCAL_GROUP             20040
#define IDS_MSG_TRUST_LOADER            20041
#define IDS_MSG_MESSAGE2                20042
#define IDS_MESSAGE_TWO                 20043
#define IDS_MSG_HELP                    20049
#define IDS_ACCOUNT_CLOSED              24464
#define IDS_ACCOUNT                     30000
#define ID_REMOVE_BUTTON                32771
#define IDS_ACCOUNT_CLOSED_SUB          34464
#define IDS_ACCOUNT_SUB                 40000
#define IDS_ACCOUNT_OPTIONS             40500
#define IDS_DOMAIN_REPORTING_SUB        44464
#define IDS_COLUMN_COMPUTER             50000
#define IDS_COLUMN_SERVICE              50001
#define IDS_COLUMN_ACCOUNT              50002
#define IDS_COLUMN_REPORT               50004
#define IDS_COLUMN_STATUS               50005
#define IDS_COLUMN_LASTGENERATEDON      50006
#define IDS_COLUMN_SERVER               50007
#define IDS_COLUMN_JOBFILE              50008
#define IDS_COLUMN_ACTION               50009
#define IDS_COLUMN_ACTIONID             50010
#define IDS_COLUMN_SKIPINCLUDE          50011
#define IDS_COLUMN_DOMAIN               50012
#define IDS_COLUMN_DIRECTION            50013
#define IDS_COLUMN_ATTRIBUTES           50014
#define IDS_COLUMN_EXISTSFORTARGET      50015
#define IDS_COLUMN_NAME                 50016
#define IDS_COLUMN_OBJECTPATH           50017
#define IDS_COLUMN_SAMNAME              50018
#define IDS_COLUMN_DISPLAYNAME          50019
#define IDS_COLUMN_DESCRIPTION          50020
#define IDS_COLUMN_OWNER                50021
#define IDS_COLUMN_FULLNAME             50022
#define IDS_NAME_CONFLICTS              50023
#define IDS_ACCOUNT_REFERENCES          50024
#define IDS_EXPIRED_COMPUTERS           50025
#define IDS_MIGRATED_COMPUTERS          50026
#define IDS_MIGRATED_ACCOUNTS           50027
#define IDS_INCLUDE                     50028
#define IDS_UPDATED                     50029
#define IDS_UPDATEFAILED                50030
#define IDS_SKIP                        50031
#define IDS_CREDENTIALS_EXCHANGE_SUB    50032
#define IDS_COLUMN_NAMECONFLICTS        50033
#define IDS_COLUMN_ACCOUNTREFERENCES    50034
#define IDS_COLUMN_EXPIREDCOMPUTERS     50035
#define IDS_COLUMN_MIGRATEDCOMPUTERS    50036
#define IDS_COLUMN_MIGRATEDACCOUNTS     50037
#define IDS_CANNOT                      50038
#define IDS_ACCOUNT_OPTIONS_SUB         60000
#define IDS_SEC_CRED                    60001
#define IDS_MSG_INVALID_TIME            60002
#define IDS_COLUMN_SERVICE_DISPLAY      65000
#define IDS_MSG_LOCAL                   65001
#define IDS_MSG_INVALIDOU               65002
#define IDS_MSG_INVALIDEXCHANGE         65003
#define IDS_MSG_FILE                    65004
#define IDS_MSG_MESSAGE                 65005
#define IDS_TEMPORARY                   65006
#define IDS_MSG_MESSAGE8                65006
#define IDS_TEMPORARY_SUB               65007
#define IDD_TEMPORARY                   65008
#define IDS_TRUST_DOMAIN                65009
#define IDS_SERVICE_CREDENTIALS         65010
#define IDS_SERVICE_DOMAIN              65011
#define IDS_CREDENTIALS_EXCHANGE        65012
#define IDS_CREDENTIALS_ACCOUNT         65013
#define IDS_DOMAIN_GROUP                65014
#define IDS_DOMAIN_ACCOUNT              65015
#define IDS_DOMAIN_COMPUTERS            65016
#define IDS_DOMAIN_SECURITY             65017
#define IDS_DOMAIN_DIRECTORY            65018
#define IDS_MSG_MESSAGE9                65019
#define IDS_PASSWORDS                   65024
#define IDS_MASKS                       65025
#define IDS_OUTBOUND                    65026
#define IDS_INBOUND                     65027
#define IDS_BIDIRECTIONAL               65028
#define IDS_DISABLED                    65029
#define IDS_ONE                         65030
#define IDS_TEN                         65031
#define IDS_SIXTY                       65032
#define IDS_FORMAT_MESSAGE              65033
#define IDS_SELECTOR                    65034
#define IDS_BROWSER                     65035
#define IDS_MSG_ERRORBUF2               65036
#define IDS_WIZARD_USER                 65037
#define IDS_WIZARD_GROUP                65038
#define IDS_WIZARD_COMPUTER             65039
#define IDS_WIZARD_SECURITY             65040
#define IDS_WIZARD_UNDO                 65041
#define IDS_WIZARD_RETRY                65042
#define IDS_WIZARD_REPORTING            65043
#define IDS_WIZARD_SERVICE              65044
#define IDS_WIZARD_EXCHANGEDIR          65045
#define IDS_WIZARD_EXCHANGESRV          65046
#define IDS_WIZARD_TRUST                65047
#define IDS_WIZARD_GROUPMAPPING         65048
#define IDS_MIGRATE_COMPUTER            65049
#define IDS_GATHER_SERVICEACCOUNT       65050
#define IDS_TRANSLATE_SECURITY          65051
#define IDS_GATHER_INFORMATION          65052
#define IDS_MSG_ERRORBUF3               65053
#define IDS_MSG_ERRORBUF20              65054
#define IDS_MSG_OBJECTPICKER_SOURCE2    65055
#define IDS_SEC_CRED2                   65056
#define IDS_MSG_SA_FAILED               65057
#define IDS_MYTITLE3                    65058
#define IDS_COMPUTER_RENAME_TITLE       65059
#define IDS_GRATUITIOUS_MESSAGE         65060
#define IDS_GRATUITIOUS_MESSAGE2        65061
#define IDS_MSG_EXTENSION_MAX_PRE       65062
#define IDS_MSG_EXTENSION_MAX_SUF       65063
#define IDS_INVALID_STRING              65065
#define IDS_MSG_INVALIDCHARS            65066
#define IDS_MSG_TRANSUR_ADDONLY         65067
#define IDS_MSG_TRANSUR_TITLE           65068
#define IDS_COLUMN_UPN                  65069
#define IDS_MSG_NOOBJECTS               65070
#define IDS_MSG_NOSOURCESID             65071
#define IDS_PASSWORD_FILE_HDR           65072
#define IDS_PASSWORD_DC_HDR             65073
#define IDS_MAPFILE_TITLE               65074
#define IDS_MAPFILE_EMPTY               65075
#define IDS_MAPFILE_MISSING             65076
#define IDS_PROPEX                      65077
#define IDS_PROPEX_SUB                  65078
#define IDS_MSG_PWDDC_NOT_READY         65079
#define IDS_MSG_PWDDC_DISABLED          65080
#define IDS_MSG_PWDDC_WRONG_ENCRYPTION_KEY 65081
#define IDS_MSG_PWD_WRONG_ENCRYPTION_PACK 65082
#define IDS_MIGRATION_RUNNING           65083
#define IDS_APP_CAPTION                 65084
#define IDS_OU_TOO_LONG                 65085
#define IDS_BROWSE_REPORT_TITLE         65086
#define IDS_PASSWORD_SUB_GRP            65087
#define IDS_PASSWORD_GRP                65088
#define IDS_SIDHISTORY_CTRL_TEXT        65089
#define IDS_ROAMING_PROFILE_CTRL_TEXT   65090
#define IDS_DISABLE_GRP                 65091
#define IDS_DISABLE_SUB_GRP             65092
#define IDS_ADMT_PROCESSES_STILL_RUNNING 65093
#define IDS_MSG_SA_NO_MATCH             65094
#define IDS_SA_MISMATCH_TITLE           65095
#define IDS_MSG_SIDHISTORY_NO_PDC       65096
#define IDS_MSG_CANCEL_REALLY           65097
#define IDS_CANCEL_TITLE                65098
#define IDS_MSG_DUP_TITLE               65099
#define IDS_MSG_DUP_RETRY_SERVER        65100
#define IDS_MSG_INVALID_SID_HISTORY_CREDENTIALS 65101
#define IDS_MSG_WAIT_FOR_RESTART        65102
#define IDS_MSG_REMIGRATE_ACCOUNT       65103
#define IDS_MSG_INVALID_HANDLE          65104
#define IDS_MSG_TARGET_DOMAIN_ADMIN     65105
#define IDS_MSG_CALLER_NOT_DELEGATED    65106
#define IDS_MSG_UNABLE_VERIFY_CALLER_NOT_DELEGATED 65107
#define IDS_MSG_INVALID_EXCHANGE_SERVER_CREDENTIALS  65108
#define IDS_MSG_PWDDC_WRONG_DOMAIN      65109
#define IDS_MSG_PWDDC_CANT_GET_ROLE     65110
#define IDS_COLUMN_DNSNAME              65111
#define IDS_MSG_PWDDC_NOT_DC            65112
#define IDS_MSG_UNABLE_RETRIEVE_STORE_PASSWORD 65113
#define IDS_MSG_UNABLE_RETRIEVE_SERVER_INFO 65114
#define IDS_MSG_UNABLE_SET_EXCLUDED_SYSTEM_PROPERTIES 65115


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        4041
#define _APS_NEXT_COMMAND_VALUE         32804
#define _APS_NEXT_CONTROL_VALUE         4144
#define _APS_NEXT_SYMED_VALUE           4000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wizards.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\trstdlg.h ===
#if !defined(AFX_TRUSTERDLG_H__00348D40_621E_11D3_AF7D_0090275A583D__INCLUDED_)
#define AFX_TRUSTERDLG_H__00348D40_621E_11D3_AF7D_0090275A583D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TrusterDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTrusterDlg dialog
#include "resource.h"
#include "ErrDct.hpp"
class CTrusterDlg : public CDialog
{
// Construction
public:
	CTrusterDlg(CWnd* pParent = NULL);   // standard constructor
	CString m_strDomain;
	CString m_strPassword;
	CString m_strUser;
	DWORD len;
	bool toreturn;
	TErrorDct 			err;

// Dialog Data
	//{{AFX_DATA(CTrusterDlg)
	enum { IDD = IDD_CREDENTIALS_TRUST };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTrusterDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTrusterDlg)
	afx_msg void OnOK();
	afx_msg void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TRUSTERDLG_H__00348D40_621E_11D3_AF7D_0090275A583D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\trstdlg.cpp ===
// TrusterDlg.cpp : implementation file
//

#include "stdafx.h"
#include "TrstDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTrusterDlg dialog


CTrusterDlg::CTrusterDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTrusterDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTrusterDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CTrusterDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_USERNAME, m_strUser);
	DDX_Text(pDX, IDC_PASSWORD, m_strPassword);
	DDX_Text(pDX, IDC_DOMAINNAME, m_strDomain);

	//{{AFX_DATA_MAP(CTrusterDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTrusterDlg, CDialog)
	//{{AFX_MSG_MAP(CTrusterDlg)
	ON_BN_CLICKED(IDC_OK, OnOK)
	ON_BN_CLICKED(IDC_CANCEL, OnCancel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTrusterDlg message handlers


void CTrusterDlg::OnOK() 
{
    toreturn =false;
    UpdateData(TRUE);
    m_strUser.TrimLeft();m_strUser.TrimRight();
    m_strDomain.TrimLeft();m_strDomain.TrimRight();
    m_strPassword.TrimLeft();m_strPassword.TrimRight();
    if (m_strUser.IsEmpty() || m_strDomain.IsEmpty())
    {
        CString c;
        c.LoadString(IDS_MSG_DOMAIN);
        CString d;
        d.LoadString(IDS_MSG_INPUT);
        MessageBox(c,d,MB_OK);
        toreturn =false;
    }
    else
    {
        toreturn =true;
    }
    CDialog::OnOK();	
}

void CTrusterDlg::OnCancel() 
{
	toreturn=false;
	// TODO: Add your control notification handler code here
	CDialog::OnCancel();
}

BOOL CTrusterDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	toreturn =false;
	if ( m_strDomain.IsEmpty() )
      return TRUE;
	else
		UpdateData(FALSE);
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\wizards.h ===
// wizards.h : main header file for the WIZARDS DLL
//
#pragma once

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "Callback.h"
/////////////////////////////////////////////////////////////////////////////
// CWizardsApp
// See wizards.cpp for the implementation of this class
//
extern "C" __declspec(dllexport) int runWizard(int, HWND);

class CWizardsApp : public CWinApp
{
public:
	CWizardsApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWizardsApp)
	//}}AFX_VIRTUAL
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//{{AFX_MSG(CWizardsApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

int doAccount();
int doComputer();
int doSecurity();
int doGroup();
int doService();
int doExchangeDir();
int doExchangeSrv();
int doReporting();
int doUndo();		
int doRetry();		
int doTrust();
int doGroupMapping();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\wizards.cpp ===
// wizards.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include "wizards.h"
#include <Folders.h>
#include "LSAUtils.h"
#include <MigrationMutex.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



IVarSet *			pVarSet;  
IVarSet *			pVarSetUndo; 
IVarSet *			pVarSetService;
IIManageDB *		db;
UINT g_cfDsObjectPicker;
IDsObjectPicker *pDsObjectPicker;
IDataObject *pdo;
IDsObjectPicker *pDsObjectPicker2;
IDataObject *pdo2;

int migration;
CEdit pEdit;
CComModule _Module;
CListCtrl m_listBox;
CListCtrl m_cancelBox;
CListCtrl m_reportingBox;
CListCtrl m_serviceBox;
CComboBox m_rebootBox;
CString sourceNetbios;
CString targetNetbios;
CListCtrl m_trustBox;
CString sourceDNS;
CString targetDNS;
CComboBox sourceDrop;
CComboBox additionalDrop;
CComboBox targetDrop;
StringLoader 			gString;
TErrorDct 			err;
TError				& errCommon = err;
bool alreadyRefreshed;
DSBROWSEFORCONTAINER DsBrowseForContainerX;
BOOL gbNeedToVerify=FALSE;
_bstr_t yes,no;
CString lastInitializedTo;
bool clearCredentialsName;
CString sourceDC;
CStringList DCList;
CPropertyNameToOIDMap	PropIncMap1;
CPropertyNameToOIDMap	PropExcMap1;
CPropertyNameToOIDMap	PropIncMap2;
CPropertyNameToOIDMap	PropExcMap2;
CPropertyNameToOIDMap	PropIncMap3;
CPropertyNameToOIDMap	PropExcMap3;
CString					sType1, sType2, sType3;
bool bChangedMigrationTypes;
bool bChangeOnFly;
CString targetServer;
CString targetServerDns;
HWND s_hParentWindow;

/////////////////////////////////////////////////////////////////////////////
// CWizardsApp

BEGIN_MESSAGE_MAP(CWizardsApp, CWinApp)
	//{{AFX_MSG_MAP(CWizardsApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizardsApp construction

CWizardsApp::CWizardsApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

// Forward decleration for this function
HRESULT BrowseForContainer(HWND hWnd,//Handle to window that should own the browse dialog.
                    LPOLESTR szRootPath, //Root of the browse tree. NULL for entire forest.
                    LPOLESTR *ppContainerADsPath, //Return the ADsPath of the selected container.
                    LPOLESTR *ppContainerClass //Return the ldapDisplayName of the container's class.
                    );

/////////////////////////////////////////////////////////////////////////////
// The one and only CWizardsApp object
CWizardsApp theApp;
/////////////////////////////////////////////////////////////////////////////
// CDeletemeApp initialization
BOOL CWizardsApp::InitInstance()
{
	ATLTRACE(_T("{wizards.dll}CWizardsApp::InitInstance() : m_hInstance=0x%08X\n"), m_hInstance);
	BOOL bInit = CWinApp::InitInstance();
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
	return bInit;
}

int CWizardsApp::ExitInstance()
{
	ATLTRACE(_T("{wizards.dll}CWizardsApp::ExitInstance() : m_hInstance=0x%08X\n"), m_hInstance);
	return CWinApp::ExitInstance();
}

//extern "C" __declspec(dllexport) int runWizard(int whichWizard, HWND hParentWindow) 
int LocalRunWizard(int whichWizard, HWND hParentWindow)
{
    //declare variables
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CMigrationMutex mutexMigration(ADMT_MUTEX);

    if (mutexMigration.ObtainOwnership(0) == false)
    {
        CString strCaption;
        strCaption.LoadString(IDS_APP_CAPTION);
        CString strMessage;
        strMessage.LoadString(IDS_MIGRATION_RUNNING);

        CWnd* pWnd = theApp.GetMainWnd();

        if (pWnd)
        {
            pWnd->MessageBox(strMessage, strCaption);
        }
        else
        {
            MessageBox(NULL, strMessage, strCaption, MB_OK);
        }

        GetError(0);

        return 0;
    }

    int result=0;
    yes=GET_BSTR(IDS_YES);no=GET_BSTR(IDS_No);
    migration =whichWizard;
    gbNeedToVerify = CanSkipVerification();
    //migration varset
    IVarSetPtr  pVs(__uuidof(VarSet));
    HRESULT hr = pVs->QueryInterface(IID_IVarSet, (void**) &pVarSet);

    //undo varset
    IVarSetPtr  pVs2(__uuidof(VarSet));
    hr = pVs2->QueryInterface(IID_IVarSet, (void**) &pVarSetUndo);

    IVarSetPtr  pVs4(__uuidof(VarSet));
    hr = pVs4->QueryInterface(IID_IVarSet, (void**) &pVarSetService);

    //database
    IIManageDBPtr	pDb;
    hr = pDb.CreateInstance(__uuidof(IManageDB));

    if (FAILED(hr))
    {
        return 0;
    }

    hr = pDb->QueryInterface(IID_IIManageDB, (void**) &db);



    IUnknown * pUnk;

    if (migration!=w_undo)
        pVarSet->QueryInterface(IID_IUnknown, (void**) &pUnk);
    else 
        pVarSetUndo->QueryInterface(IID_IUnknown, (void**) &pUnk);
    db->GetSettings(&pUnk);
    pUnk->Release();

    if (migration!= w_undo)
    {
        IVarSetPtr  leaves;
        hr=pVarSet->raw_getReference(L"Accounts",&leaves);
        if (SUCCEEDED(hr))
            leaves->Clear();
        hr = pVarSet->raw_getReference(L"Servers",&leaves);
        if (SUCCEEDED(hr))
            leaves->Clear();

        g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
        pDsObjectPicker = NULL;
        pdo = NULL;
        hr = CoCreateInstance(CLSID_DsObjectPicker,NULL,CLSCTX_INPROC_SERVER,IID_IDsObjectPicker,(void **) &pDsObjectPicker);
        sourceNetbios = L"";
        targetNetbios = L"";
        sourceDNS = L"";
        targetDNS = L"";
        if (FAILED(hr)) return 0;
    }

    if (migration==w_groupmapping)
    {
        pDsObjectPicker2 = NULL;
        pdo2 = NULL;
        hr = CoCreateInstance(CLSID_DsObjectPicker,NULL,CLSCTX_INPROC_SERVER,IID_IDsObjectPicker,(void **) &pDsObjectPicker2);
        if (FAILED(hr)) return 0;
    }

    s_hParentWindow = hParentWindow;

    switch (whichWizard)
    {
    case w_account:
        result =doAccount();
        break;
    case w_group:
        result =doGroup();
        break;
    case w_computer: 
        result =doComputer();
        break;
    case w_security: 
        result =doSecurity();			
        break;
    case w_service:
        result =doService();
        break;
    case w_exchangeDir:
        result =doExchangeDir();
        break;
    case w_exchangeSrv:
        result =doExchangeSrv();
        break;
    case w_reporting: 
        result =doReporting();
        break;
    case w_undo: 
        result =doUndo();			
        break;
    case w_retry: 
        result =doRetry();			
        break;
    case w_trust: 
        result =doTrust();			
        break;
    case w_groupmapping: 
        result =doGroupMapping();			
        break;
    }	

    s_hParentWindow = 0;

    m_listBox.Detach();
    m_trustBox.Detach();
    m_reportingBox.Detach();
    m_cancelBox.Detach();
    m_serviceBox.Detach();

    sourceDrop.Detach();
    additionalDrop.Detach();
    targetDrop.Detach();
    m_rebootBox.Detach();

    if (pDsObjectPicker2)
    {
        pDsObjectPicker2->Release();
        pDsObjectPicker2 = NULL;
    }

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
        pDsObjectPicker = NULL;
    }

    if (pVarSet)
    {
        //
        // If a password was stored then the key must be deleted
        // to prevent using up available storage for keys.
        //

        _bstr_t strId = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password));

        if (strId.length() > 0)
        {
            StorePassword(strId, NULL);
        }

        pVarSet->Release();
        pVarSet = NULL;
    }

    if (pVarSetService)
    {
        pVarSetService->Release();
        pVarSetService = NULL;
    }

    if (pVarSetUndo)
    {
        pVarSetUndo->Release();
        pVarSetUndo = NULL;
    }

    if (db)
    {
        db->Release();
        db = NULL;
    }

    mutexMigration.ReleaseOwnership();

    return result;
}


extern "C" __declspec(dllexport) int runWizard(int whichWizard, HWND hParentWindow)
{
   return LocalRunWizard(whichWizard, hParentWindow);
}


void setpdatavars(SHAREDWIZDATA& wizdata,LOGFONT& TitleLogFont)
{
    put(DCTVS_Options_MaxThreads, L"20");
    put(DCTVS_Options_DispatchLog, GetDispatchLogPath());
    put(DCTVS_Options_Logfile, GetMigrationLogPath());  
    pVarSet->put(L"PlugIn.0",L"None");
    put(DCTVS_Options_AppendToLogs,yes);
    put(DCTVS_Reports_Generate,no);
    wizdata.hTitleFont = CreateFontIndirect(&TitleLogFont);
    wizdata.renameSwitch=1;
    wizdata.refreshing = false;
    wizdata.prefixorsuffix =false;
    wizdata.expireSwitch =false;
    wizdata.someService =false;
    alreadyRefreshed = false;
    wizdata.memberSwitch =false;
    wizdata.proceed=false;
    for (int i =0;i<6;i++)wizdata.sort[i]=true;
    wizdata.sourceIsNT4=true;
    wizdata.secWithMapFile=false;
    bChangedMigrationTypes=false;
    bChangeOnFly = false;
       //make sure we don't hide the progress dialogs if set by scripting
    put(DCTVS_Options_AutoCloseHideDialogs, L"0");
    put(DCTVS_Options_DontBeginNewLog, no);//always start a new log
       //don't use any specific server yet
    put(DCTVS_Options_TargetServerOverride, L"");
    put(DCTVS_Options_TargetServerOverrideDns, L"");

    switch (migration)
    {
    case w_account:
        {
        put(DCTVS_AccountOptions_CopyUsers, yes);
        put(DCTVS_AccountOptions_CopyLocalGroups, no);
        put(DCTVS_AccountOptions_CopyComputers, no);
        put(DCTVS_AccountOptions_CopyContainerContents, no);
        put(DCTVS_Security_TranslateContainers, L"");
        put(DCTVS_Options_Wizard, L"user");
        put(DCTVS_AccountOptions_FixMembership, yes);

        //
        // If password option has not been previously set then
        // set default password option to generate strong passwords.
        //

        _bstr_t strStrongPasswords = get(DCTVS_AccountOptions_GenerateStrongPasswords);

        if (strStrongPasswords.length() == 0)
        {
            put(DCTVS_AccountOptions_GenerateStrongPasswords, yes);
        }
        break;
        }
    case w_group:
        {
        put(DCTVS_AccountOptions_CopyLocalGroups, yes);
        put(DCTVS_AccountOptions_CopyComputers, no);
        put(DCTVS_AccountOptions_CopyMemberOf,no);
        put(DCTVS_Security_TranslateContainers, L"");
        put(DCTVS_Options_Wizard, L"group");
        put(DCTVS_AccountOptions_FixMembership, yes);

        //
        // If password option has not been previously set then
        // set default password option to generate strong passwords.
        //

        _bstr_t strStrongPasswords = get(DCTVS_AccountOptions_GenerateStrongPasswords);

        if (strStrongPasswords.length() == 0)
        {
            put(DCTVS_AccountOptions_GenerateStrongPasswords, yes);
        }
        break;
        }
    case w_computer: 
        put(DCTVS_AccountOptions_CopyUsers, no);
        put(DCTVS_AccountOptions_CopyLocalGroups, no);
        put(DCTVS_AccountOptions_CopyComputers, yes);
        put(DCTVS_Security_TranslateContainers, L"");
        put(DCTVS_Options_Wizard, L"computer");
        put(DCTVS_AccountOptions_AddSidHistory,L"");
        put(DCTVS_AccountOptions_CopyContainerContents, no);
        put(DCTVS_AccountOptions_CopyMemberOf, no);
        put(DCTVS_AccountOptions_CopyLocalGroups, no);
        put(DCTVS_AccountOptions_FixMembership, no);
        put(DCTVS_AccountOptions_SecurityInputMOT, yes);
        break;
    case w_security:
        put(DCTVS_AccountOptions_CopyUsers, no);
        put(DCTVS_AccountOptions_CopyLocalGroups, no);
        put(DCTVS_AccountOptions_CopyComputers, no);
        put(DCTVS_Security_TranslateContainers, L"");
        put(DCTVS_Options_Wizard, L"security");
        pVarSet->put(L"PlugIn.0",L"None");
        put(DCTVS_AccountOptions_AddSidHistory,L"");
        put(DCTVS_AccountOptions_SecurityInputMOT, yes);
        break;
    case w_undo:
        put(DCTVS_Options_Wizard, L"undo");
        put(DCTVS_Security_TranslateContainers, L"");
        break;
    case w_retry:
        put(DCTVS_Options_Wizard, L"retry");
        put(DCTVS_Security_TranslateContainers, L"");
        break;
    case w_reporting:
        put(DCTVS_Options_Wizard, L"reporting");
        put(DCTVS_GatherInformation, yes);
        put(DCTVS_Security_TranslateContainers, L"");
        pVarSet->put(L"PlugIn.0",L"None");
        break;
    case w_service:
        {
            _bstr_t t= get(DCTVS_AccountOptions_PasswordFile);
            CString yo=(WCHAR *) t;
            yo.TrimLeft();yo.TrimRight();
            if (yo.IsEmpty())
            {   
                CString toinsert;
                GetDirectory(toinsert.GetBuffer(1000));
                toinsert.ReleaseBuffer();
                toinsert+="Logs\\passwords.txt";
                put(DCTVS_AccountOptions_PasswordFile,_bstr_t(toinsert));
            }
            put(DCTVS_Security_TranslateContainers, L"");
        put(DCTVS_Options_Wizard, L"service");
        break;
        }
    case w_exchangeDir:
        put(DCTVS_AccountOptions_AddSidHistory,L"");
        put(DCTVS_Options_Wizard, L"exchangeDir");
        put(DCTVS_AccountOptions_SecurityInputMOT, yes);
        break;
    case w_exchangeSrv:
        put(DCTVS_Options_Wizard, L"exchangeDrv");
        break;
    case w_trust:
        put(DCTVS_Security_TranslateContainers, L"");
        put(DCTVS_Options_Wizard, L"trust");
        break;
    case w_groupmapping:
        put(DCTVS_Options_Wizard, L"groupmapping");
        put(DCTVS_AccountOptions_ReplaceExistingAccounts, yes);
        put(DCTVS_AccountOptions_CopyContainerContents, no);
        put(DCTVS_AccountOptions_CopyUsers, no);
        put(DCTVS_AccountOptions_CopyLocalGroups, yes);
        put(DCTVS_AccountOptions_CopyComputers, L"");
        put(DCTVS_AccountOptions_ReplaceExistingGroupMembers, no);
        put(DCTVS_Security_TranslateContainers, L"");
        put(DCTVS_AccountOptions_FixMembership, yes);
        break;
    }
}

void intropage(HPROPSHEETPAGE	ahpsp[],PROPSHEETPAGE& psp,int dialog,
			  int pagenum,SHAREDWIZDATA& wizdata,int dialogtitle,DLGPROC p)
{
	psp.dwSize =		sizeof(psp);
	psp.dwFlags =		PSP_DEFAULT|PSP_HIDEHEADER|PSP_USETITLE |PSP_HASHELP;
	psp.hInstance =		AfxGetInstanceHandle();
	psp.lParam =		(LPARAM) &wizdata; 
	psp.pszTitle =		MAKEINTRESOURCE(dialogtitle);
	psp.pszTemplate =	MAKEINTRESOURCE(dialog);
	psp.pfnDlgProc =	p;
	ahpsp[pagenum] =	CreatePropertySheetPage(&psp);
	
}

void definepage(HPROPSHEETPAGE	ahpsp[],PROPSHEETPAGE& psp,int title,int subtitle,int dialog,
			   int pagenum,int dialogtitle,DLGPROC p)
{
	psp.dwFlags =			PSP_DEFAULT|PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE|PSP_USETITLE|PSP_HASHELP;
	psp.pszTitle =			MAKEINTRESOURCE(dialogtitle);
	psp.pszHeaderTitle =	MAKEINTRESOURCE(title);
	psp.pszHeaderSubTitle =	MAKEINTRESOURCE(subtitle);
	psp.pszTemplate =		MAKEINTRESOURCE(dialog);
	psp.pfnDlgProc =	p;
	ahpsp[pagenum] =		CreatePropertySheetPage(&psp);
}

void endpage(HPROPSHEETPAGE	ahpsp[],PROPSHEETPAGE& psp,int dialog,int pagenum,int dialogtitle,DLGPROC p)
{
	psp.dwFlags =		PSP_DEFAULT|PSP_HIDEHEADER|PSP_USETITLE|PSP_HASHELP;
	psp.pszTitle =		MAKEINTRESOURCE(dialogtitle);
	psp.pszTemplate =	MAKEINTRESOURCE(dialog);
	psp.pfnDlgProc =	p;
	ahpsp[pagenum] =			CreatePropertySheetPage(&psp);
}

int defineSheet(HPROPSHEETPAGE	ahpsp[],PROPSHEETHEADER& psh,int numpages,SHAREDWIZDATA& wizdata
				 ,int headerGraphic,int waterGraphic)
{
	psh.dwSize =			sizeof(psh);
	psh.hInstance =			AfxGetInstanceHandle();
	psh.hwndParent =		s_hParentWindow;
	psh.phpage =			ahpsp;
	psh.dwFlags =		REAL_PSH_WIZARD97|PSH_WATERMARK|PSH_HEADER;
	psh.pszbmWatermark =	MAKEINTRESOURCE(waterGraphic);
	psh.pszbmHeader	=	MAKEINTRESOURCE(headerGraphic);
	psh.nStartPage =		0;
	psh.nPages =			numpages;
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
	LOGFONT TitleLogFont = ncm.lfMessageFont;
	TitleLogFont.lfWeight = FW_BOLD;
	CString s;
	s.LoadString(IDS_TEXT);

	lstrcpy(TitleLogFont.lfFaceName, s.GetBuffer(1000));
	s.ReleaseBuffer();
	HDC hdc = GetDC(NULL); //gets the screen DC
	INT FontSize = 12;
	TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * FontSize / 72;
	setpdatavars(wizdata,TitleLogFont);
	ReleaseDC(NULL, hdc);
//	int a=PropertySheet(&psh);
	int a=(int)PropertySheet(&psh);
	DeleteObject(wizdata.hTitleFont);
	return a;
}
int doTrust()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[4] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_TRUST,0,wizdata,IDS_TRUST_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_TRUST_DOMAIN,IDD_DOMAIN_SELECTION,1,IDS_TRUST_TITLE,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_TRUST,IDS_TRUST_SUB,IDD_TRUST_INFO,2,IDS_TRUST_TITLE,	IntTrustProc);
	endpage(ahpsp,psp,IDD_END_TRUST,3,IDS_TRUST_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,4,wizdata,IDB_HEADER_KEY,IDB_WATERMARK_SECURITY);
	return result;
}
int doGroupMapping()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[9] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_GROUPMAPPING,0,wizdata,IDS_GROUPMAPPING_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_GROUPMAPPING_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_SUB,IDD_DOMAIN_SELECTION,2,IDS_GROUPMAPPING_TITLE,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_GROUP_MAPPING,IDS_GROUP_MAPPING_SUB,IDD_SELECTION2,3,IDS_GROUPMAPPING_TITLE,IntSelectionProc);
	definepage(ahpsp,psp,IDS_TARGET_GROUP,IDS_TARGET_GROUP_SUB,IDD_TARGET_GROUP,4,IDS_GROUPMAPPING_TITLE,IntTargetGroupProc);
	definepage(ahpsp,psp,IDS_OU_SELECTION,IDS_OU_SELECTION_SUB,IDD_OU_SELECTION,5,IDS_GROUPMAPPING_TITLE,IntOuSelectionProc);
	definepage(ahpsp,psp,IDS_OPTIONS_GROUP,IDS_OPTIONS_GROUPMAPPING_SUB,IDD_OPTIONS_GROUPMAPPING,6,IDS_GROUPMAPPING_TITLE,IntOptionsGroupMappingProc);
	definepage(ahpsp,psp,IDS_CREDENTIALS_ACCOUNT,IDS_CREDENTIALS_SUB,IDD_CREDENTIALS,7,IDS_GROUPMAPPING_TITLE,IntCredentialsProc);
	endpage(ahpsp,psp,IDD_END_GROUPMAPPING,8,IDS_GROUPMAPPING_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,9,wizdata,IDB_HEADER_KEY,IDB_WATERMARK_GROUP);
	return result;
}


int doAccount()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[13] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_ACCOUNT,0,wizdata,IDS_ACCOUNT_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_ACCOUNT_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_ACCOUNT,IDD_DOMAIN_SELECTION,2,IDS_ACCOUNT_TITLE,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_ACCOUNT,IDS_ACCOUNT_SUB,IDD_SELECTION3,3,IDS_ACCOUNT_TITLE,IntSelectionProc);
	definepage(ahpsp,psp,IDS_OU_SELECTION,IDS_OU_SELECTION_SUB,IDD_OU_SELECTION,4,IDS_ACCOUNT_TITLE,IntOuSelectionProc);
	definepage(ahpsp,psp,IDS_PASSWORD,IDS_PASSWORD_SUB,IDD_PASSWORD,5,IDS_ACCOUNT_TITLE,IntPasswordProc);
	definepage(ahpsp,psp,IDS_DISABLE,IDS_DISABLE_SUB,IDD_DISABLE,6,IDS_ACCOUNT_TITLE,IntDisableProc);
	definepage(ahpsp,psp,IDS_CREDENTIALS_ACCOUNT,IDS_CREDENTIALS_SUB,IDD_CREDENTIALS,7,IDS_ACCOUNT_TITLE,IntCredentialsProc);
	definepage(ahpsp,psp,IDS_OPTIONS,IDS_OPTIONS_SUB,IDD_OPTIONS,8,IDS_ACCOUNT_TITLE,IntOptionsProc);
	definepage(ahpsp,psp,IDS_PROPEX,IDS_PROPEX_SUB,IDD_PROP_EXCLUSION,9,IDS_ACCOUNT_TITLE,IntPropExclusionProc);
	definepage(ahpsp,psp,IDS_RENAMING,IDS_RENAMING_SUB1,IDD_RENAMING,10,IDS_ACCOUNT_TITLE,IntRenameProc);
	definepage(ahpsp,psp,IDS_SA_INFO,IDS_SA_INFO_SUB,IDD_SA_INFO,11,IDS_ACCOUNT_TITLE,IntServiceInfoProc);
	endpage(ahpsp,psp,IDD_END_ACCOUNT,12,IDS_ACCOUNT_TITLE,EndDlgProc);
	int result = defineSheet(ahpsp,psh,13,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_USER);
	return result;
}

int doGroup()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[13] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_GROUP,0,wizdata,IDS_GROUP_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_GROUP_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_GROUP,IDD_DOMAIN_SELECTION,2,IDS_GROUP_TITLE,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_GROUP,IDS_GROUP_SUB,IDD_SELECTION2,3,IDS_GROUP_TITLE,	IntSelectionProc);
	definepage(ahpsp,psp,IDS_OU_SELECTION,IDS_OU_SELECTION_SUB,IDD_OU_SELECTION,4,IDS_GROUP_TITLE,IntOuSelectionProc);
	definepage(ahpsp,psp,IDS_OPTIONS_GROUP,IDS_OPTIONS_GROUP_SUB,IDD_OPTIONS_GROUP,5,IDS_GROUP_TITLE,IntGroupOptionsProc);
	definepage(ahpsp,psp,IDS_PROPEX,IDS_PROPEX_SUB,IDD_PROP_EXCLUSION,6,IDS_GROUP_TITLE,IntPropExclusionProc);
	definepage(ahpsp,psp,IDS_CREDENTIALS_ACCOUNT,IDS_CREDENTIALS_SUB,IDD_CREDENTIALS,7,IDS_GROUP_TITLE,IntCredentialsProc);
	definepage(ahpsp,psp,IDS_RENAMING,IDS_RENAMING_SUB2,IDD_RENAMING,8,IDS_GROUP_TITLE,	IntRenameProc);
	definepage(ahpsp,psp,IDS_PASSWORD_GRP,IDS_PASSWORD_SUB_GRP,IDD_PASSWORD,9,IDS_GROUP_TITLE,IntPasswordProc);
	definepage(ahpsp,psp,IDS_DISABLE_GRP,IDS_DISABLE_SUB_GRP,IDD_DISABLE,10,IDS_GROUP_TITLE,IntDisableProc);
//	definepage(ahpsp,psp,IDS_OPTIONS_FROM_USER,IDS_OPTIONS_FROM_USER_SUB,IDD_OPTIONS_FROM_USER,10,IDS_GROUP_TITLE,	IntOptionsFromUserProc);
	definepage(ahpsp,psp,IDS_SA_INFO,IDS_SA_INFO_SUB,IDD_SA_INFO,11,IDS_GROUP_TITLE,IntServiceInfoProc);
	endpage(ahpsp,psp,IDD_END_GROUP,12,IDS_GROUP_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,13,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_GROUP);
	return result;
}
int doComputer()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[11] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_COMPUTER,0,wizdata,IDS_COMPUTER_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_COMPUTER_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_COMPUTERS,IDD_DOMAIN_SELECTION,2,IDS_COMPUTER_TITLE,	IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_COMPUTER,IDS_COMPUTER_SUB,IDD_SELECTION1,3,IDS_COMPUTER_TITLE,	IntSelectionProc);
	definepage(ahpsp,psp,IDS_OU_SELECTION,IDS_OU_SELECTION_SUB,IDD_OU_SELECTION,4,IDS_COMPUTER_TITLE,	IntOuSelectionProc);
	definepage(ahpsp,psp,IDS_TRANSLATION,IDS_TRANSLATION_SUB,IDD_TRANSLATION,5,IDS_COMPUTER_TITLE,	IntTranslationProc);
	definepage(ahpsp,psp,IDS_SECURITY_OPTIONS,IDS_TRANSLATION_MODE_SUB,IDD_TRANSLATION_MODE,6,IDS_COMPUTER_TITLE,	IntTranslationModeProc);
//	definepage(ahpsp,psp,IDS_CREDENTIALS2,IDS_CREDENTIALS_SUB2,IDD_CREDENTIALS2,7,IDS_COMPUTER_TITLE,	IntCredentials2Proc);
	definepage(ahpsp,psp,IDS_COMPUTER_OPTIONS,IDS_REBOOT_SUB,IDD_REBOOT,7,IDS_COMPUTER_TITLE,	IntRebootProc);
	definepage(ahpsp,psp,IDS_PROPEX,IDS_PROPEX_SUB,IDD_PROP_EXCLUSION,8,IDS_COMPUTER_TITLE,IntPropExclusionProc);
	definepage(ahpsp,psp,IDS_RENAMING,IDS_RENAMING_SUB3,IDD_RENAMING,9,IDS_COMPUTER_TITLE,	IntRenameProc);
	endpage(ahpsp,psp,IDD_END_COMPUTER,10,IDS_COMPUTER_TITLE, EndDlgProc);
	int result = defineSheet(ahpsp,psh,11,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_COMPUTER);
	return result;
}

int doSecurity()
{		
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[8] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_SECURITY,0,wizdata,IDS_SECURITY_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_SECURITY_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_SECURITY_OPTIONS,IDS_TRANSLATION_MODE_SUB,IDD_TRANSLATION_SRC,2,IDS_SECURITY_TITLE,IntTranslationInputProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_SECURITY,IDD_DOMAIN_SELECTION,3,IDS_SECURITY_TITLE	,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_SECURITY,IDS_SECURITY_SUB,IDD_SELECTION4,4,IDS_SECURITY_TITLE,IntSelectionSecurityProc);
	definepage(ahpsp,psp,IDS_TRANSLATION,IDS_TRANSLATION_SUB,IDD_TRANSLATION,5,IDS_SECURITY_TITLE,	IntTranslationProc);
	definepage(ahpsp,psp,IDS_SECURITY_OPTIONS,IDS_TRANSLATION_MODE_SUB,IDD_TRANSLATION_MODE,6,IDS_SECURITY_TITLE,IntTranslationModeProc);
//	definepage(ahpsp,psp,IDS_CREDENTIALS2,IDS_CREDENTIALS_SUB2,IDD_CREDENTIALS2,7,IDS_SECURITY_TITLE,	IntCredentials2Proc);
	endpage(ahpsp,psp,IDD_END_SECURITY,7,IDS_SECURITY_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,8,wizdata,IDB_HEADER_KEY,IDB_WATERMARK_SECURITY);
	return result;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
int doExchangeDir()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[7] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_EXCHANGE_DIR,0,wizdata,IDS_EXCHANGE_DIR_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_EXCHANGE_DIR_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_DIRECTORY,IDD_DOMAIN_SELECTION,2,IDS_EXCHANGE_DIR_TITLE,	IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_SECURITY_OPTIONS,IDS_TRANSLATION_MODE_SUB,IDD_TRANSLATION_MODE,3,IDS_EXCHANGE_DIR_TITLE,	IntTranslationModeProc);
	definepage(ahpsp,psp,IDS_EXCHANGE_SELECTION,IDS_EXCHANGE_SELECTION_SUB,IDD_EXCHANGE_SELECTION,4,IDS_EXCHANGE_DIR_TITLE,IntExchangeSelectionProc);
	definepage(ahpsp,psp,IDS_CREDENTIALS_EXCHANGE,IDS_CREDENTIALS_EXCHANGE_SUB,IDD_CREDENTIALS,5,IDS_EXCHANGE_DIR_TITLE,IntCredentialsProc);
	endpage(ahpsp,psp,IDD_END_EXCHANGE_DIR,6,IDS_EXCHANGE_DIR_TITLE,	EndDlgProc);
	int result = 	defineSheet(ahpsp,psh,7,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_EXCHANGE);
	return result;
}
int doExchangeSrv()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[5] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_EXCHANGE_SRV,0,wizdata,IDS_EXCHANGE_SRV_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_EXCHANGE_SRV_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_SUB,IDD_DOMAIN_SELECTION,2,IDS_EXCHANGE_SRV_TITLE,	IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_EXCHANGE_SELECTION,IDS_EXCHANGE_SELECTION_SUB,IDD_EXCHANGE_SELECTION,3,IDS_EXCHANGE_SRV_TITLE,IntExchangeSelectionProc);
	endpage(ahpsp,psp,IDD_END_EXCHANGE_SRV,4,IDS_EXCHANGE_SRV_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,5,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_EXCHANGE);
	return result;
}
int doUndo()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[4] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_UNDO,0,wizdata,IDS_UNDO_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_UNDO,IDS_UNDO_SUB,IDD_UNDO,1,IDS_UNDO_TITLE,IntUndoProc);
	definepage(ahpsp,psp,IDS_CREDENTIALS_ACCOUNT,IDS_CREDENTIALS_SUB,IDD_CREDENTIALS,2,IDS_UNDO_TITLE,IntCredentialsProc);
//	definepage(ahpsp,psp,IDS_CREDENTIALS2,IDS_CREDENTIALS_SUB2,IDD_CREDENTIALS2,3,IDS_UNDO_TITLE,	IntCredentials2Proc);
	endpage(ahpsp,psp,IDD_END_UNDO,3,IDS_UNDO_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,4,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_USER);
	return result;
}
int doRetry()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[3] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_RETRY,0,wizdata,IDS_RETRY_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_RETRY,IDS_RETRY_SUB,IDD_RETRY,1,IDS_RETRY_TITLE,IntRetryProc);
//	definepage(ahpsp,psp,IDS_CREDENTIALS2,IDS_CREDENTIALS_SUB2,IDD_CREDENTIALS2,2,IDS_RETRY_TITLE,IntCredentials2Proc);
	endpage(ahpsp,psp,IDD_END_RETRY,2,IDS_RETRY_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,3,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_USER);
	return result;
}

int doReporting()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[6] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_REPORTING,0,wizdata,IDS_REPORTING_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_REPORTING_SUB,IDD_DOMAIN_SELECTION,1,IDS_REPORTING_TITLE,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_HTML_LOCATION,IDS_HTML_LOCATION_SUB,IDD_HTML_LOCATION,2,IDS_REPORTING_TITLE,IntHTMLLocationProc);
	definepage(ahpsp,psp,IDS_OPTIONS_REPORTING,IDS_OPTIONS_REPORTING_SUB,IDD_OPTIONS_REPORTING,3,IDS_REPORTING_TITLE,IntOptionsReportingProc);	
//	definepage(ahpsp,psp,IDS_CREDENTIALS3,IDS_CREDENTIALS_SUB3,IDD_CREDENTIALS2,4,IDS_REPORTING_TITLE,	IntCredentials2Proc);
	definepage(ahpsp,psp,IDS_REPORTING,IDS_REPORTING_SUB,IDD_SELECTION1,4,IDS_REPORTING_TITLE,IntSelectionProc);
	endpage(ahpsp,psp,IDD_END_REPORTING,5,IDS_REPORTING_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,6,wizdata,IDB_HEADER_BOOK,IDB_WATERMARK_REPORTING);
	return result;
}

int doService()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[6]=	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_SERVICE,0,wizdata,IDS_SERVICE_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_SERVICE_DOMAIN,IDD_DOMAIN_SELECTION,1,IDS_SERVICE_TITLE,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_SA_REFRESH,IDS_SA_REFRESH_SUB,IDD_SA_REFRESH,2,IDS_SERVICE_TITLE,IntServiceRefreshProc);
	definepage(ahpsp,psp,IDS_SERVICE,IDS_SERVICE_SUB,IDD_SELECTION1,3,IDS_SERVICE_TITLE,IntSelectionProc);
//	definepage(ahpsp,psp,IDS_CREDENTIALS2,IDS_SERVICE_CREDENTIALS,IDD_CREDENTIALS2,4,IDS_SERVICE_TITLE,	IntCredentials2Proc);
	definepage(ahpsp,psp,IDS_SA_INFO,IDS_SA_INFO_SUB,IDD_SA_INFO_BUTTON,4,IDS_SERVICE_TITLE,IntServiceInfoButtonProc);
	endpage(ahpsp,psp,IDD_END_SERVICE,5,IDS_SERVICE_TITLE,EndDlgProc);
	int result = defineSheet(ahpsp,psh,6,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_SERVICE_ACCOUNT);
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\wnetutil.h ===
/*============================================================================*\
     Windows Network Domain Enumeration APIs.  These are a shell around the
     TNetDomainEnum class member function.  The handle used is nothing more
     than the "this" pointer to the instantiated object.
\*============================================================================*/
#include "TCHAR.H"

#define EA_MAX_DOMAIN_NAME_SIZE 260

typedef  struct  EaWNetDomainInfo
{
   TCHAR                   name[EA_MAX_DOMAIN_NAME_SIZE]; // domain name string
}  EaWNetDomainInfo;


//-----------------------------------------------------------------------------
// EaWNetDomainEnumOpen
//
// Creates the enumeration object and gives the caller the handle
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumOpen(
      void                ** handle        // out-opaque handle addr to enum
   );


//-----------------------------------------------------------------------------
// EaWNetDomainEnumNext
//
// Sets the domain string buffer to the next domain name in the enumeration
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumNext(
      void                 * handle       ,// i/o-opaque handle to enumeration
      EaWNetDomainInfo     * domain        // out-domain information structure
   );


//-----------------------------------------------------------------------------
// EaWNetDomainEnumFirst
//
// Sets the domain string buffer to the first domain name in the enumeration
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumFirst(
      void                 * handle       ,// i/o-opaque handle to enumeration
      EaWNetDomainInfo     * domain        // out-domain information structure
   );

//-----------------------------------------------------------------------------
// EaWNetDomainEnumClose
//
// Closes and destroys the enumeration handle and the objects it contains
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumClose(
      void                 * handle        // i/o-opaque handle addr to enum
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\wnetutil.cpp ===
#include "StdAfx.h"

#include "WNetUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define  VALD_NETDOMAIN_ENUM  1000666      // bad pointer validation signature
#define  DOM_BUFFER_SIZE      (32768)      // buffer size held allocated by class

class TNetDomainEnum
{
public:
                        TNetDomainEnum();
                        ~TNetDomainEnum();
   DWORD                GetMsNetProvider( NETRESOURCE * resourceInfo, DWORD infoSize );
   WCHAR *              GetNext();
   DWORD                GetLastRc() const { return rc; };
   BOOL                 IsValid() const { return vald == VALD_NETDOMAIN_ENUM; };

private:
   DWORD                     vald;
   HANDLE                    hEnum;
   NETRESOURCE             * resourceBuffer;
   DWORD                     rc,
                             totEntries,
                             nextEntry,
                             buffSize;
};


//-----------------------------------------------------------------------------
// TNetDomainEnum::TNetDomainEnum
//-----------------------------------------------------------------------------
TNetDomainEnum::TNetDomainEnum()
{
   //--------------------------
   // Initialize Class Members
   //--------------------------
   vald  = VALD_NETDOMAIN_ENUM;
   hEnum = INVALID_HANDLE_VALUE;

   // init currEntry > totEntries to force first-time read
   totEntries = 0;
   nextEntry = 1;

   resourceBuffer = NULL;
   resourceBuffer = (NETRESOURCE *)new char[DOM_BUFFER_SIZE];
   if ( !resourceBuffer )
   {
      rc = 1;
   }
   else
   {
      //-----------------------------------
      // Determine Network Provider to Use
      //-----------------------------------
      char                      buffer[16384];
      NETRESOURCE *             info = (NETRESOURCE *)buffer;

      rc = GetMsNetProvider( info, sizeof(buffer));
      if ( ! rc )
      {
         rc = WNetOpenEnum( RESOURCE_GLOBALNET,
                            RESOURCETYPE_ANY,
                            RESOURCEUSAGE_CONTAINER,
                            info,
                            &hEnum );
         delete [] info->lpProvider;
      }

      if ( rc )
      {
         if ( resourceBuffer )
         {
            delete [] resourceBuffer;
            resourceBuffer = NULL;
         }
      }
   }
}

//-----------------------------------------------------------------------------
// TNetDomainEnum::~TNetDomainEnum
//-----------------------------------------------------------------------------
TNetDomainEnum::~TNetDomainEnum()
{
   if ( hEnum != INVALID_HANDLE_VALUE )
   {
      WNetCloseEnum( hEnum );
      hEnum = INVALID_HANDLE_VALUE;
   }

   vald = 0;

   if ( resourceBuffer )
   {
      delete resourceBuffer;
   }
}

//-----------------------------------------------------------------------------
// GetMsNetProvider - Retrieves network resource information for the 'Microsoft
//                    Windows Network' provider.
//
// Input: A pointer to a NETRESOURCE structure that we will fill if we find a
//        resource meeting our needs.
//
// Output: 0 of we found a provider. resourceInfo populated in this case
//         non-zero if no provider. resourceInfo contents undefined
//-----------------------------------------------------------------------------
DWORD TNetDomainEnum::GetMsNetProvider( NETRESOURCE * resourceInfo, DWORD infoSize )
{
	_TCHAR szProvider[_MAX_PATH];
	DWORD cchProvider = sizeof(szProvider) / sizeof(szProvider[0]);

	DWORD dwError = WNetGetProviderName(WNNC_NET_LANMAN, szProvider, &cchProvider);

	if (dwError == NO_ERROR)
	{
		memset(resourceInfo, 0, infoSize);
		resourceInfo->dwScope = RESOURCE_GLOBALNET;
		resourceInfo->dwType = RESOURCETYPE_ANY;
		resourceInfo->dwDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
		resourceInfo->dwUsage = RESOURCEUSAGE_CONTAINER;
		resourceInfo->lpProvider = new _TCHAR[_tcslen(szProvider) + 1];

		if (resourceInfo->lpProvider)
		{
			_tcscpy(resourceInfo->lpProvider, szProvider);

			rc = NO_ERROR;
		}
		else
		{
			rc = ERROR_OUTOFMEMORY;
		}
	}
	else
	{
		rc = dwError;
	}

	return rc;
}


//-----------------------------------------------------------------------------
// TNetDomainEnum::GetNext()
//-----------------------------------------------------------------------------
WCHAR *
   TNetDomainEnum::GetNext()
{
   rc = (DWORD)-1;      // init rc to internal error before reset

   if ( hEnum == INVALID_HANDLE_VALUE )
      return NULL;
   if ( !resourceBuffer )
      return NULL;
   if ( nextEntry >= totEntries )
   {
      buffSize = DOM_BUFFER_SIZE;
      totEntries = (DWORD)-1;
      rc = WNetEnumResource(
                     hEnum,
                     &totEntries,
                     (void *)resourceBuffer,
                     &buffSize );
      if ( rc == 0 )
         nextEntry = 0;
      else
      {
         totEntries = 0;
         return NULL;
      }
   }
   else
      rc = 0;

   return  resourceBuffer[nextEntry++].lpRemoteName;
}


//#pragma page()
/*============================================================================*\
     Windows Network Domain Enumeration APIs.  These are a shell around the
     TNetDomainEnum class member function.  The handle used is nothing more
     than the "this" pointer to the instantiated object.
\*============================================================================*/

//-----------------------------------------------------------------------------
// EaWNetDomainEnumOpen
//
// Creates the enumeration object and gives the caller the handle
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumOpen(
      void                ** handle        // out-opaque handle addr to enum
   )
{
   TNetDomainEnum          * domainEnum = new TNetDomainEnum();

   *handle = (PVOID)domainEnum;
   if ( ! domainEnum )
      return (DWORD)-1;                    // internal error

   return domainEnum->GetLastRc();
}


//-----------------------------------------------------------------------------
// EaWNetDomainEnumNext
//
// Sets the domain string buffer to the next domain name in the enumeration
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumNext(
      void                 * handle       ,// i/o-opaque handle to enumeration
      EaWNetDomainInfo     * domain        // out-domain information structure
   )
{
   TNetDomainEnum          * domainEnum = (TNetDomainEnum *)handle;
   WCHAR                   * str;

   if ( !domainEnum  ||  !domainEnum->IsValid() )
      return ERROR_INVALID_PARAMETER;      // caller's error - invalid handle

   str = domainEnum->GetNext();

   if ( !str )
   {
      domain->name[0] = _T('\0');
   }
   else
   {
      wcsncpy(domain->name, str, EA_MAX_DOMAIN_NAME_SIZE);
      domain->name[EA_MAX_DOMAIN_NAME_SIZE - 1] = _T('\0');
   }

   return domainEnum->GetLastRc();
}


//-----------------------------------------------------------------------------
// EaWNetDomainEnumFirst
//
// Sets the domain string buffer to the first domain name in the enumeration
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumFirst(
      void                 * handle       ,// i/o-opaque handle to enumeration
      EaWNetDomainInfo     * domain        // out-domain information structure
   )
{
   // We're cheating here by making the first/next the same.  We probably want to
   // change this eventually to make "first" really properly reset the enum to the
   // start
   return EaWNetDomainEnumNext(handle, domain);
}

//-----------------------------------------------------------------------------
// EaWNetDomainEnumClose
//
// Closes and destroys the enumeration handle and the objects it contains
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumClose(
      void                 * handle        // i/o-opaque handle addr to enum
   )
{
   TNetDomainEnum          * domainEnum = (TNetDomainEnum *)handle;

   if ( !domainEnum  ||  !domainEnum->IsValid() )
      return ERROR_INVALID_PARAMETER;      // caller's error - invalid handle

   delete domainEnum;

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\acctrepl.h ===
/*---------------------------------------------------------------------------
  File: AcctRepl.h

  Comments: Definition of account replicator COM object.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:18:21

 ---------------------------------------------------------------------------
*/

    
// AcctRepl.h : Declaration of the CAcctRepl

#ifndef __ACCTREPL_H_
#define __ACCTREPL_H_

#include "resource.h"       // main symbols

#include "ProcExts.h"

#import "MoveObj.tlb" no_namespace

#include "UserCopy.hpp"
#include "TNode.hpp"
#include "Err.hpp"

#include "ResStr.h"

#include <map>
#include <set>
#include <string>
using namespace std;

/////////////////////////////////////////////////////////////////////////////
// CAcctRepl
class ATL_NO_VTABLE CAcctRepl :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAcctRepl, &CLSID_AcctRepl>,
    public IAcctRepl

{
public:
    CAcctRepl()
    {
      m_pUnkMarshaler = NULL;
      m_UpdateUserRights = FALSE;
      m_ChangeDomain = FALSE;
      m_Reboot = FALSE;
      m_RenameOnly = FALSE;
      m_pExt = NULL;
      m_bIgnorePathConflict = false;
      m_pUserRights = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_ACCTREPL)
DECLARE_NOT_AGGREGATABLE(CAcctRepl)
DECLARE_GET_CONTROLLING_UNKNOWN()
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAcctRepl)
    COM_INTERFACE_ENTRY(IAcctRepl)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        if (FAILED(opt.openDBResult))
            return opt.openDBResult;
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        if (m_pUserRights)
        {
            m_pUserRights->Release();
        }

        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

   // IAcctRepl
public:
   STDMETHOD(Process)(IUnknown * pWorkItemIn);
protected:
    HRESULT ResetMembersForUnivGlobGroups(Options * pOptions, TAcctReplNode * pAcct);
    HRESULT FillNodeFromPath( TAcctReplNode * pAcct, Options * pOptions, TNodeListSortable * acctList );
   Options                   opt;
   TNodeListSortable         acctList;
   BOOL                      m_UpdateUserRights;
   BOOL                      m_ChangeDomain;
   BOOL                      m_Reboot;
   BOOL                      m_RenameOnly;

   struct SNamingAttribute
   {
      SNamingAttribute() :
         nMinRange(0),
         nMaxRange(0)
      {
      }
      SNamingAttribute(int nMinRange, int nMaxRange, wstring strName) :
         nMinRange(nMinRange),
         nMaxRange(nMaxRange),
         strName(strName)
      {
      }
      SNamingAttribute(const SNamingAttribute& r) :
         nMinRange(r.nMinRange),
         nMaxRange(r.nMaxRange),
         strName(r.strName)
      {
      }
      SNamingAttribute& operator =(const SNamingAttribute& r)
      {
         nMinRange = r.nMinRange;
         nMaxRange = r.nMaxRange;
         strName = r.strName;
         return *this;
      }
      int nMinRange;
      int nMaxRange;
      wstring strName;
   };
   typedef map<wstring, SNamingAttribute> CNamingAttributeMap;
   CNamingAttributeMap m_mapNamingAttribute;
   HRESULT GetNamingAttribute(LPCTSTR pszServer, LPCTSTR pszClass, SNamingAttribute& rNamingAttribute);

   //
   // Target Path Set
   // Maintains set of account node pointers sorted by target path.
   // Used to determine if target path already has been used.
   //

   struct lessTargetPath
   {
      bool operator()(const TAcctReplNode* pNodeA, const TAcctReplNode* pNodeB) const
      {
          const WCHAR PATH_SEPARATOR = L'/';
          const size_t PROVIDER_PREFIX_LENGTH = 7;

          PCWSTR pszPathA = pNodeA->GetTargetPath();
          PCWSTR pszPathB = pNodeB->GetTargetPath();

          if (pszPathA && (wcslen(pszPathA) > PROVIDER_PREFIX_LENGTH))
          {
              PCWSTR pch = wcschr(pszPathA + PROVIDER_PREFIX_LENGTH, PATH_SEPARATOR);

              if (pch)
              {
                  pszPathA = pch + 1;
              }
          }

          if (pszPathB && (wcslen(pszPathB) > PROVIDER_PREFIX_LENGTH))
          {
              PCWSTR pch = wcschr(pszPathB + PROVIDER_PREFIX_LENGTH, PATH_SEPARATOR);

              if (pch)
              {
                  pszPathB = pch + 1;
              }
          }

          return UStrICmp(pszPathA, pszPathB) < 0;
      }
   };

   typedef set<TAcctReplNode*, lessTargetPath> CTargetPathSet;
   bool m_bIgnorePathConflict;

   HRESULT Create2KObj( TAcctReplNode * pAcct, Options * pOptions, CTargetPathSet& setTargetPath);
   bool DoTargetPathConflict(CTargetPathSet& setTargetPath, TAcctReplNode* pAcct);

   void  LoadOptionsFromVarSet(IVarSet * pVarSet);
   void  LoadResultsToVarSet(IVarSet * pVarSet);
   DWORD PopulateAccountListFromVarSet(IVarSet * pVarSet);
   HRESULT UpdateUserRights(IStatusObj* pStatus);
   void  WriteOptionsToLog();
   int CopyObj(
      Options              * options,      // in -options
      TNodeListSortable    * acctlist,     // in -list of accounts to process
      ProgressFn           * progress,     // in -window to write progress messages to
      TError               & error,        // in -window to write error messages to
      IStatusObj           * pStatus,      // in -status object to support cancellation
      void                   WindowUpdate (void )    // in - window update function
   );

   int UndoCopy(
      Options              * options,      // in -options
      TNodeListSortable    * acctlist,     // in -list of accounts to process
      ProgressFn           * progress,     // in -window to write progress messages to
      TError               & error,        // in -window to write error messages to
      IStatusObj           * pStatus,      // in -status object to support cancellation
      void                   WindowUpdate (void )    // in - window update function
   );

   bool BothWin2K( Options * pOptions );
   int CopyObj2K( Options * pOptions, TNodeListSortable * acctList, ProgressFn * progress, IStatusObj * pStatus );
   int DeleteObject( Options * pOptions, TNodeListSortable * acctList, ProgressFn * progress, IStatusObj * pStatus );
   HRESULT UpdateGroupMembership(Options * pOptions, TNodeListSortable * acctlist,ProgressFn * progress, IStatusObj * pStatus );
private:
    HRESULT UpdateMemberToGroups(TNodeListSortable * acctList, Options * pOptions, BOOL bGrpsOnly);
    BOOL StuffComputerNameinLdapPath(WCHAR * sAdsPath, DWORD nPathLen, WCHAR * sSubPath, Options * pOptions, BOOL bTarget = TRUE);
    BOOL CheckBuiltInWithNTApi( PSID pSid, WCHAR * pNode, Options * pOptions );
    BOOL GetNt4Type( WCHAR const * sComp, WCHAR const * sAcct, WCHAR * sType);
    BOOL GetSamFromPath(_bstr_t sPath, _bstr_t& sSam, _bstr_t& sType, _bstr_t& sSrcName, _bstr_t& sTgtName, long& grpType, Options * pOptions);
    BOOL IsContainer( TAcctReplNode * pNode, IADsContainer ** ppCont);
    BOOL ExpandContainers( TNodeListSortable    * acctlist, Options *pOptions, ProgressFn * progress );
   CProcessExtensions      * m_pExt;
   HRESULT CAcctRepl::RemoveMembers(TAcctReplNode * pAcct, Options * pOptions);
   bool FillPathInfo(TAcctReplNode * pAcct,Options * pOptions);
   bool AcctReplFullPath(TAcctReplNode * pAcct, Options * pOptions);
   BOOL NeedToProcessAccount(TAcctReplNode * pAcct, Options * pOptions);
   BOOL ExpandMembership(TNodeListSortable *acctlist, Options *pOptions, TNodeListSortable *pNewAccts, ProgressFn * progress, BOOL bGrpsOnly, BOOL bAnySourceDomain = FALSE);
   int MoveObj2K(Options * options, TNodeListSortable * acctlist, ProgressFn * progress, IStatusObj * pStatus);
   HRESULT ResetObjectsMembership(Options * pOptions, TNodeListSortable * pMember, IIManageDBPtr pDb);
   HRESULT RecordAndRemoveMemberOf ( Options * pOptions, TAcctReplNode * pAcct,  TNodeListSortable * pMember);
   HRESULT RecordAndRemoveMember (Options * pOptions,TAcctReplNode * pAcct,TNodeListSortable * pMember);
   HRESULT MoveObject( TAcctReplNode * pAcct,Options * pOptions,IMoverPtr pMover);
   HRESULT ResetGroupsMembers( Options * pOptions, TAcctReplNode * pAcct, TNodeListSortable * pMember, IIManageDBPtr pDb );
   void ResetTypeOfPreviouslyMigratedGroups(Options* pOptions);
   HRESULT ADsPathFromDN( Options * pOptions,_bstr_t sDN,WCHAR * sPath, bool bWantLDAP = true);
   void SimpleADsPathFromDN( Options * pOptions,WCHAR const * sDN,WCHAR * sPath);
   BOOL FillNamingContext(Options * pOptions);
   HRESULT MakeAcctListFromMigratedObjects(Options * pOptions, long lUndoActionID, TNodeListSortable *& pAcctList,BOOL bReverseDomains);
   void AddPrefixSuffix( TAcctReplNode * pNode, Options * pOptions );
   HRESULT LookupAccountInTarget(Options * pOptions, WCHAR * sSam, WCHAR * sPath);
   void UpdateMemberList(TNodeListSortable * pMemberList,TNodeListSortable * acctlist);
   void BuildTargetPath(WCHAR const * sCN, WCHAR const * tgtOU, WCHAR * stgtPath);
   HRESULT BetterHR(HRESULT hr);
   HRESULT BuildSidPath(
                        IADs  *       pAds,     //in- pointer to the object whose sid we are retrieving.
                        WCHAR *       sSidPath, //out-path to the LDAP://<SID=###> object
                        WCHAR *       sSam,     //out-Sam name of the object
                        WCHAR *       sDomain,  //out-Domain name where this object resides.
                        Options *     pOptions, //in- Options
                        PSID  *       ppSid     //out-Pointer to the binary sid
                      );
   HRESULT CheckClosedSetGroups(
      Options              * pOptions,          // in - options for the migration
      TNodeListSortable    * pAcctList,         // in - list of accounts to migrate
      ProgressFn           * progress,          // in - progress function to display progress messages
      IStatusObj           * pStatus            // in - status object to support cancellation
   );

   BOOL CanMoveInMixedMode(TAcctReplNode *pAcct,TNodeListSortable * acctlist,Options * pOptions);
   HRESULT QueryPrimaryGroupMembers(BSTR cols, Options * pOptions, DWORD rid, IEnumVARIANT** pEnum);
   bool GetRidForGroup(Options * pOptions, WCHAR * sGroupSam, DWORD& rid);
   HRESULT AddPrimaryGroupMembers(Options * pOptions, SAFEARRAY * multiVals, WCHAR * sGroupSam);
   HRESULT GetThePrimaryGroupMembers(Options * pOptions, WCHAR * sGroupSam, IEnumVARIANT ** pVar);
   BOOL TruncateSam(WCHAR * tgtname, TAcctReplNode * acct, Options * options, TNodeListSortable * acctList);
   BOOL DoesTargetObjectAlreadyExist(TAcctReplNode * pAcct, Options * pOptions);
   void GetAccountUPN(Options * pOptions, _bstr_t sSName, _bstr_t& sSUPN);
   HRESULT UpdateManagement(TNodeListSortable * acctList, Options * pOptions);
   _bstr_t GetUnEscapedNameWithFwdSlash(_bstr_t strName);
   _bstr_t GetCNFromPath(_bstr_t sPath);
   BOOL ReplaceSourceInLocalGroup(TNodeListSortable * acctList, Options * pOptions, IStatusObj *pStatus);
   _bstr_t GetDomainOfMigratedForeignSecPrincipal(IADs * pAds, _bstr_t sPath);
   void RemoveSourceAccountFromGroup(IADsGroup * pGroup, IVarSetPtr pMOTVarSet, Options * pOptions);
    void VerifyAndUpdateMigratedTarget(Options* pOptions, IVarSetPtr spAccountVarSet);

   typedef std::map<_bstr_t,_bstr_t> CGroupNameMap;
   CGroupNameMap m_IgnoredGrpMap;

    IUserRights* m_pUserRights;
    HRESULT EnumerateAccountRights(BOOL bTarget, TAcctReplNode* pAcct);
    HRESULT AddAccountRights(BOOL bTarget, TAcctReplNode* pAcct);
    HRESULT RemoveAccountRights(BOOL bTarget, TAcctReplNode* pAcct);

    IVarSetPtr GenerateSourceToTargetDnMap(TNodeListSortable* acctlist);
};

typedef void ProgressFn(WCHAR const * mesg);

typedef HRESULT (CALLBACK * ADSGETOBJECT)(LPWSTR, REFIID, void**);
extern ADSGETOBJECT            ADsGetObject;

#endif //__ACCTREPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\chdom.h ===
/*---------------------------------------------------------------------------
  File: ChangeDomain.h

  Comments: Implementation class definition for COM object to change the domain
  affiliation of a remote computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:19

 ---------------------------------------------------------------------------
*/

// ChangeDomain.h : Declaration of the CChangeDomain

#ifndef __CHANGEDOMAIN_H_
#define __CHANGEDOMAIN_H_

#include "resource.h"       // main symbols
#include <comdef.h>

/////////////////////////////////////////////////////////////////////////////
// CChangeDomain
class ATL_NO_VTABLE CChangeDomain : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CChangeDomain, &CLSID_ChangeDomain>,
	public IDispatchImpl<IChangeDomain, &IID_IChangeDomain, &LIBID_MCSDCTWORKEROBJECTSLib>
{
   _bstr_t                   m_domain;
   _bstr_t                   m_account;
   _bstr_t                   m_password;
   _bstr_t                   m_domainAccount;
   BOOL                      m_bNoChange;

public:
	CChangeDomain()
	{
	   m_bNoChange = FALSE;
   }

DECLARE_REGISTRY_RESOURCEID(IDR_CHANGEDOMAIN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CChangeDomain)
	COM_INTERFACE_ENTRY(IChangeDomain)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IWorkNode
public:
   STDMETHOD(Process)(IUnknown *pWorkItem);
	
// IChangeDomain
public:
	STDMETHOD(get_NoChange)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_NoChange)(/*[in]*/ BOOL newVal);
	STDMETHOD(ConnectAs)(BSTR domain, BSTR user, BSTR password);
	STDMETHOD(ChangeToWorkgroup)(BSTR Computer, BSTR Workgroup, /*[out]*/ BSTR * errStatus);
	STDMETHOD(ChangeToDomain)(BSTR ActiveComputerName, BSTR Domain, BSTR TargetComputerName, /*[out]*/ BSTR * errStatus);
	STDMETHOD(ChangeToDomainWithSid)(BSTR ActiveComputerName, BSTR Domain,BSTR DomainSid, BSTR DomainController, BSTR TargetComputerName, BSTR SrcPath, /*[out]*/ BSTR * errStatus);
};

#endif //__CHANGEDOMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\arutil.cpp ===
/*---------------------------------------------------------------------------
  File: ARUtil.cpp

  Comments: Helper functions and command-line parsing for Account Replicator

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 6/23/98 4:26:54 PM

 ---------------------------------------------------------------------------
*/

#include "StdAfx.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define INCL_NETUSER
#define INCL_NETGROUP
#define INCL_NETERRORS
#include <lm.h>

#include "Mcs.h"
#include "Common.hpp"                    
#include "TNode.hpp"
#include "UString.hpp"                   

#include "ErrDct.hpp"

//#import "\bin\McsDctWorkerObjects.tlb"
//#import "WorkObj.tlb" //#imported via ARUtil.hpp below

#include "UserCopy.hpp"
#include "ARUtil.hpp"
#include "PWGen.hpp"
#include "ResStr.h"
#include <TxtSid.h>


extern TErrorDct             err;
bool                         bAllowReplicateOnSelf;
                                                       
extern PSID                  srcSid;   // SID of source domain

/***************************************************************************************************
 CompVal: used as a compare function for TANode trees

   It compares a UNICODE string, with the name field in the node
   
   Return Values:
                     0    tn->acct_name == actname 
                     1    tn->acct_name <  actname
                    -1    tn->acct_name >  actname 

/***************************************************************************************************/

int 
   CompVal(
      const TNode          * tn,          //in -tree node  
      const void           * actname      //in -name to look for  
   )
{

   LPWSTR                    str1 = ((TANode *)tn)->GetName();
   LPWSTR                    str2 = (LPWSTR) actname;
  
   return UStrICmp(str1,str2);
}
/***************************************************************************************************/
/* CompNode:  used as a compare function for TANode Trees
     
   It compares the name fields of TANodes
   
   Return Values:
                  0     t1->acct_name == t2->acct_name
                  1     t1->acct_name >  t2->acct_name
                 -1     t1->acct_name <  t2->acct_name

   Error Handling:
      if given bad inputs, CompN displays an error message and returns 0
/***************************************************************************************************/

int 
   CompNode(
      const TNode          * v1,       //in -first node to compare
      const TNode          * v2        //in -second node to compare
   )
{  

   TANode                  * t1 = (TANode *)v1;
   TANode                  * t2 = (TANode *)v2;
  
   return UStrICmp(t1->GetName(),t2->GetName());
} 


int 
   CompareSid(
      PSID const             sid1,  // in - first SID to compare
      PSID const             sid2   // in - second SID to compare
   )
{
   DWORD                     len1,
                             len2;
   int                       retval = 0;

   len1 = GetLengthSid(sid1);
   len2 = GetLengthSid(sid2);

   if ( len1 < len2 )
   {
      retval = -1;
   }
   if ( len1 > len2 )
   {
      retval = 1;
   }
   if ( len1 == len2 )
   {
      retval = memcmp(sid1,sid2,len1);
   }

   return retval;
}


int 
   CompSid(
      const TNode          * v1,      // in -first node to compare
      const TNode          * v2       // in -second node to compare
   )
{
   TANode                  * t1 = (TANode *)v1;
   TANode                  * t2 = (TANode *)v2;

   return CompareSid(t1->GetSid(),t2->GetSid());
}

int 
   CompSidVal(
      const TNode          * tn,     // in -node to compare
      const void           * pVal    // in -value to compare
   )
{
   TANode                  * node = (TANode *)tn;
   PSID                      pSid = (PSID)pVal;

   return CompareSid(node->GetSid(),pSid);
}


BOOL                                            // ret-TRUE if the password is successfully generated
   PasswordGenerate(
      Options const        * options,           // in  -includes PW Generating options
      WCHAR                * password,          // out -buffer for generated password
      DWORD                  dwPWBufferLength,  // in  -DIM length of password buffer
      BOOL                   isAdminAccount     // in  -Whether to use the Admin rules 
   )
{
   DWORD                     rc = 0;
   DWORD                     dwMinUC;           // minimum upper case chars
   DWORD                     dwMinLC;           // minimum lower case chars
   DWORD                     dwMinDigit;        // minimum numeric digits
   DWORD                     dwMinSpecial;      // minimum special chars
   DWORD                     dwMaxConsecutiveAlpha; // maximum consecutive alpha chars
   DWORD                     dwMinLength;       // minimum length
   WCHAR                     eaPassword[PWLEN+1];  // EA generated password
   DWORD                     dwEaBufferLength = DIM(eaPassword);// DIM length of newPassword

   // default values, if not enforcing PW strength through EA or MS DLL
   dwMinUC = 0;
   dwMinLC = 0;
   dwMinDigit = 1;            // if no enforcement, require one digit (this is what the GUI does)
   dwMinSpecial = 0;
   dwMaxConsecutiveAlpha = 0;
   dwMinLength = options->minPwdLength;
   
   
   // Get password enforcement rules, if in effect
   dwMinUC = options->policyInfo.minUpper;
   dwMinLC = options->policyInfo.minLower;
   dwMinDigit = options->policyInfo.minDigits;
   dwMinSpecial = options->policyInfo.minSpecial;
   dwMaxConsecutiveAlpha = options->policyInfo.maxConsecutiveAlpha;
   
   rc = EaPasswordGenerate(dwMinUC,dwMinLC,dwMinDigit,dwMinSpecial,
            dwMaxConsecutiveAlpha,dwMinLength,eaPassword,dwEaBufferLength);
   
   if ( ! rc )
   {
      UStrCpy(password,eaPassword,dwPWBufferLength);
   }
   else
   {
      if ( dwPWBufferLength )
         password[0] = 0;
   }
   
   return rc;
}


PSID 
   GetWellKnownSid(
      DWORD                  wellKnownAccount,  // in - constant defined in this file, representing well-known account
      Options              * opt,               // in - migration options 
      BOOL                   bTarget            // in - flag, whether to use source or target domain information
   )
{
   PSID                      pSid = NULL;
   PUCHAR                    numsubs = NULL;
   DWORD                   * rid = NULL;
   BOOL                      error = FALSE;
   DWORD                     rc;
   DWORD                     wellKnownRid = wellKnownAccount;
   BOOL                      bNeedToBuildDomainSid = FALSE;
   
   
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY creatorIA =    SECURITY_CREATOR_SID_AUTHORITY;
   
    //
    // Sid is the same regardless of machine, since the well-known
    // BUILTIN domain is referenced.
    //
   switch ( wellKnownAccount )
   {
      case CREATOR_OWNER:
         if( ! AllocateAndInitializeSid(
                  &creatorIA,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  SECURITY_CREATOR_OWNER_RID,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case ADMINISTRATORS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_ADMINS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case ACCOUNT_OPERATORS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case BACKUP_OPERATORS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_BACKUP_OPS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case DOMAIN_ADMINS:
        wellKnownRid = DOMAIN_GROUP_RID_ADMINS;
        bNeedToBuildDomainSid = TRUE;
         break;
      case DOMAIN_USERS:
         wellKnownRid = DOMAIN_GROUP_RID_USERS;
         bNeedToBuildDomainSid = TRUE;
         break;
      case DOMAIN_CONTROLLERS:
         wellKnownRid = DOMAIN_GROUP_RID_CONTROLLERS;
         bNeedToBuildDomainSid = TRUE;
         break;
      case DOMAIN_COMPUTERS:
         wellKnownRid = DOMAIN_GROUP_RID_COMPUTERS;
         bNeedToBuildDomainSid = TRUE;
         break;
      default:
         wellKnownRid = wellKnownAccount;
         bNeedToBuildDomainSid = TRUE;
         break;
   }

   if ( bNeedToBuildDomainSid )
   {
      // For the default case we can return a SID by using the wellKnownAccount parameter as a RID
      // this one is based on the sid for the domain
      // Get the domain SID
      USER_MODALS_INFO_2  * uinf = NULL;
      MCSASSERT(opt);
      srcSid = bTarget ? opt->tgtSid : opt->srcSid;
      if ( ! srcSid )
      {
         rc = NetUserModalsGet(bTarget ? opt->tgtComp :opt->srcComp,2,(LPBYTE*)&uinf);
         if ( rc )
         {
            err.SysMsgWrite(ErrE,rc,DCT_MSG_NO_DOMAIN_SID_SD,bTarget ? opt->tgtDomain :opt->srcDomain,rc );
            error = TRUE;
            srcSid = NULL;
         }
         else
         {
            srcSid = uinf->usrmod2_domain_id;
            // make a copy of the SID to keep in the Options structure for next time
            PSID     temp = LocalAlloc(LPTR,GetLengthSid(srcSid));
            
            memcpy(temp,srcSid,GetLengthSid(srcSid));

            if ( bTarget )
               opt->tgtSid = temp;
            else
               opt->srcSid = temp;
            NetApiBufferFree(uinf);
            srcSid = temp;
         }
      }
      if ( srcSid )
      {
         numsubs = GetSidSubAuthorityCount(srcSid);
         if (! AllocateAndInitializeSid(
            &sia,
            (*numsubs)+1,
            0,0,0,0,0,0,0,0,
            &pSid) )
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         if ( ! CopySid(GetLengthSid(srcSid), pSid, srcSid) )
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_COPY_SID_FAILED_D,GetLastError());
         }
         // reset number of subauthorities in pSid, since we just overwrote it with information from srcSid
         numsubs = GetSidSubAuthorityCount(pSid);
         (*numsubs)++; 
         rid = GetSidSubAuthority(pSid,(*numsubs)-1);
         *rid = wellKnownRid;
         
      }
   }
   if ( error )
   {
      LocalFree(pSid);
      pSid = NULL;
   }
   return pSid;
}


//---------------------------------------------------------------------------
// GenerateSidAsString Function
//
// Synopsis
// Generate a SID in string format from specifed domain and given RID.
//
// Arguments
// IN pOptions - account replicator options structure
// IN bTarget  - specifies whether to use the target domain or source domain
// IN dwRid    - specified RID
//
// Return
// The generated SID as a string if successfull or an empty string if not.
//---------------------------------------------------------------------------

_bstr_t __stdcall GenerateSidAsString(Options* pOptions, BOOL bTarget, DWORD dwRid)
{
    _bstr_t strSid;

    PSID pSid = GetWellKnownSid(dwRid, pOptions, bTarget);

    if (pSid)
    {
        WCHAR szSid[LEN_Path];
        DWORD cchSid = DIM(szSid);

        if (GetTextualSid(pSid, szSid, &cchSid))
        {
            strSid = szSid;
        }

        FreeSid(pSid);
    }

    return strSid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\acctrepl.cpp ===
/*---------------------------------------------------------------------------
  File: AcctRepl.cpp

  Comments: Implementation of Account Replicator COM object.
  This COM object handles the copying or moving of directory objects.

  Win2K to Win2K migration is implemented in this file.
  NT -> Win2K migration is implemented in UserCopy.cpp

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/12/99 10:08:44

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

// AcctRepl.cpp : Implementation of CAcctRepl
#include "stdafx.h"
#include "WorkObj.h"

#include "AcctRepl.h"
#include "BkupRstr.hpp"
#include "StrHelp.h"

/////////////////////////////////////////////////////////////////////////////
// CAcctRepl

#include "Err.hpp"
#include "ErrDct.hpp"
#include "EaLen.hpp"
#include <dsgetdc.h>

#include "UserRts.h" 
#include "BkupRstr.hpp"

#include "DCTStat.h"
#include "ResStr.h"
#include "LSAUtils.h"
#include "ARUtil.hpp"
#include "Names.hpp"
#include <lm.h>
#include <iads.h>
#include "RegTrans.h"
#include "TEvent.hpp"
#include "RecNode.hpp"
#include "ntdsapi.h"
#include "TxtSid.h"
#include "ExLDAP.h"
#include "GetDcName.h"
#include "Array.h"
#include "TReg.hpp"

#import "AdsProp.tlb" no_namespace
#import "NetEnum.tlb" no_namespace 

#ifndef IADsPtr
_COM_SMARTPTR_TYPEDEF(IADs, IID_IADs);
#endif
#ifndef IADsContainerPtr
_COM_SMARTPTR_TYPEDEF(IADsContainer, IID_IADsContainer);
#endif
#ifndef IADsGroupPtr
_COM_SMARTPTR_TYPEDEF(IADsGroup, IID_IADsGroup);
#endif
#ifndef IADsPropertyPtr
_COM_SMARTPTR_TYPEDEF(IADsProperty, IID_IADsProperty);
#endif
#ifndef IDirectorySearchPtr
_COM_SMARTPTR_TYPEDEF(IDirectorySearch, IID_IDirectorySearch);
#endif
#ifndef IADsPathnamePtr
_COM_SMARTPTR_TYPEDEF(IADsPathname, IID_IADsPathname);
#endif
#ifndef IADsMembersPtr
_COM_SMARTPTR_TYPEDEF(IADsMembers, IID_IADsMembers);
#endif

#ifndef tstring
typedef std::basic_string<_TCHAR> tstring;
#endif

extern tstring __stdcall GetEscapedFilterValue(PCTSTR pszValue);

using namespace _com_util;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IVarSet                    * g_pVarSet = NULL;

TErrorDct                    err;
TErrorDct                      errAlt;  // this is used for logging errors that occur after dispatcher is launched; use migration.log
bool                        useErrAlt;
TError                     & errCommon = err;
extern bool                  g_bAddSidWorks;
DWORD                        g_dwOpMask = OPS_All;  // Global OpSeq by default all ops

bool                         bAbortMessageWritten = false;

static WCHAR s_ClassUser[] = L"user";
static WCHAR s_ClassInetOrgPerson[] = L"inetOrgPerson";

BOOL BuiltinRid(DWORD rid);

ADSGETOBJECT            ADsGetObject;
typedef BOOL (CALLBACK * TConvertStringSidToSid)(LPCWSTR   StringSid,PSID   *Sid);
TConvertStringSidToSid  ConvertStringSidToSid;

bool                    firstTime = true;

typedef struct _Lookup {
   WCHAR             * pName;
   WCHAR             * pType;
} Lookup;

//Function to sort by account sam name only
int TNodeCompareNameOnly(TNode const * t1,TNode const * t2)
{
   // Sort function to sort by Type(dec) and Name(asc)
   TAcctReplNode     const * n1 = (TAcctReplNode *)t1;
   TAcctReplNode     const * n2 = (TAcctReplNode *)t2;


   return UStrICmp(n1->GetSourceSam(), n2->GetTargetSam());
}

// Function to do a find on the Account list that is sorted with TNodeCompareNameOnly function.
int TNodeFindByNameOnly(TNode const * t1, void const * pVoid)
{
   TAcctReplNode  const * n1 = (TAcctReplNode *) t1;
   WCHAR                * pLookup = (WCHAR *) pVoid;

   return UStrICmp(n1->GetTargetSam(), pLookup);
}


int TNodeCompareAccountType(TNode const * t1,TNode const * t2)
{
   // Sort function to sort by Type(dec) and Name(asc)
   TAcctReplNode     const * n1 = (TAcctReplNode *)t1;
   TAcctReplNode     const * n2 = (TAcctReplNode *)t2;

   // Compare types
   int retVal = UStrICmp(n2->GetType(), n1->GetType());
   if ( retVal == 0 ) 
   {
      // If same type then compare names.
      return UStrICmp(n1->GetName(), n2->GetName());
   }
   else
      return retVal;
}

int TNodeCompareAccountTypeAndRDN(TNode const * t1,TNode const * t2)
{
   // Sort function to sort by Type(dec) and RDN(asc)
   TAcctReplNode     const * n1 = (TAcctReplNode *)t1;
   TAcctReplNode     const * n2 = (TAcctReplNode *)t2;

   // Compare types
   int retVal = UStrICmp(n2->GetType(), n1->GetType());
   if ( retVal == 0 ) 
   {
      // If same type then compare RDNs in the source paths.
         //get the RDNs from the source paths
      WCHAR* sN1RDN = wcschr(n1->GetSourcePath() + wcslen(L"WinNT://"), L'/');
      WCHAR* sN2RDN = wcschr(n2->GetSourcePath() + wcslen(L"WinNT://"), L'/');
         //if got RDNs
      if ((sN1RDN && *sN1RDN) && (sN2RDN && *sN2RDN))
         return UStrICmp(sN1RDN, sN2RDN);
      else //else, compare the whole source paths
         return UStrICmp(n1->GetSourcePath(), n2->GetSourcePath());;
   }
   else
      return retVal;
}

// Function to sort by Account type and then by SamAccountName
int TNodeCompareAccountSam(TNode const * t1,TNode const * t2)
{
   // Sort function to sort by Type(dec) and Name(asc)
   TAcctReplNode     const * n1 = (TAcctReplNode *)t1;
   TAcctReplNode     const * n2 = (TAcctReplNode *)t2;

   // Compare types Sort in decending order
   int retVal = UStrICmp(n2->GetType(), n1->GetType());
   if ( retVal == 0 ) 
   {
      // If same type then compare Sam Account names.
      return UStrICmp(n1->GetSourceSam(), n2->GetSourceSam());
   }
   else
      return retVal;
}

// Function to do a find on the Account list that is sorted with TNodeCompareAccountType function.
int TNodeFindAccountName(TNode const * t1, void const * pVoid)
{
   TAcctReplNode  const * n1 = (TAcctReplNode *) t1;
   Lookup               * pLookup = (Lookup *) pVoid;

   int retVal = UStrICmp(pLookup->pType, n1->GetType());
   if ( retVal == 0 )
   {
      return UStrICmp(n1->GetSourceSam(), pLookup->pName);
   }
   else
      return retVal;
}

// Function to do a find on the Account list that is sorted with TNodeCompareAccountTypeAndRDN 
// function by using the RDN in a given path.
int TNodeFindAccountRDN(TNode const * t1, void const * pVoid)
{
   TAcctReplNode  const * n1 = (TAcctReplNode *) t1;
   Lookup               * pLookup = (Lookup *) pVoid;

   int retVal = UStrICmp(pLookup->pType, n1->GetType());
   if ( retVal == 0 )
   {
         //get and compare the RDNs in these paths
      WCHAR* sNodeRDN = wcschr(n1->GetSourcePath() + wcslen(L"LDAP://"), L'/');
      WCHAR* sLookupRDN = wcschr(pLookup->pName + wcslen(L"LDAP://"), L'/');
         //if got the RDNs, compare them
      if ((sNodeRDN && *sNodeRDN) && (sLookupRDN && *sLookupRDN))
         return UStrICmp(sNodeRDN, sLookupRDN);
      else //else, compare the whole source path
         return UStrICmp(n1->GetSourcePath(), pLookup->pName);;
   }
   else
      return retVal;
}

int TNodeCompareMember(TNode const * t1, TNode const * t2)
{
   TRecordNode const * n1 = (TRecordNode *) t1;
   TRecordNode const * n2 = (TRecordNode *) t2;

   if ( n1->GetARNode() < n2->GetARNode() )
      return -1;
   if ( n1->GetARNode() > n2->GetARNode() )
      return 1;
   return UStrICmp(n1->GetMember(), n2->GetMember());
}

int TNodeCompareMemberName(TNode const * t1, TNode const * t2)
{
   TRecordNode const * n1 = (TRecordNode *) t1;
   TRecordNode const * n2 = (TRecordNode *) t2;

   return UStrICmp(n1->GetMember(), n2->GetMember());
}

int TNodeCompareMemberDN(TNode const * t1, TNode const * t2)
{
   TRecordNode const * n1 = (TRecordNode *) t1;
   TRecordNode const * n2 = (TRecordNode *) t2;

   return UStrICmp(n1->GetDN(), n2->GetDN());
}


int TNodeCompareMemberItem(TNode const * t1, void const * t2)
{
   TRecordNode const * n1 = (TRecordNode *) t1;
   WCHAR const * n2 = (WCHAR const *) t2;

   return UStrICmp(n1->GetDN(),n2);
}

int TNodeCompareAcctNode(TNode const * t1, TNode const * t2)
{
   TRecordNode const * n1 = (TRecordNode *) t1;
   TRecordNode const * n2 = (TRecordNode *) t2;
   
   if ( n1->GetARNode() < n2->GetARNode() )
      return -1;
   if ( n1->GetARNode() > n2->GetARNode() )
      return 1;
   return 0;
}

// Checks to see if the account is from the BUILTIN domain.
BOOL IsBuiltinAccount(Options * pOptions, WCHAR * sAcctName)
{
   BOOL                      ret = FALSE;
   PSID                      sid = new BYTE[35];
   SID_NAME_USE              use;
   WCHAR                     sDomain[LEN_Path];
   DWORD                     dwDom, dwsid;

   if (!sid)
      return TRUE;

   dwDom = DIM(sDomain);
   dwsid = 35;
   if ( LookupAccountName(pOptions->srcComp, sAcctName, sid, &dwsid, sDomain, &dwDom, &use) )
   {
      ret = !_wcsicmp(sDomain, L"BUILTIN");
   }

   if (sid) 
      delete [] sid;

   return ret;
}

// global counters defined in usercopy.cpp
extern AccountStats          warnings;
extern AccountStats          errors;
extern AccountStats          created;
extern AccountStats          replaced;
extern AccountStats          processed;

// updates progress indicator
// this updates the stats entries in the VarSet
// this information will be returned to clients who call DCTAgent::QueryJobStatus
// while the job is running.
void 
   Progress(
      WCHAR          const * mesg          // in - progress message
   )
{
   if ( g_pVarSet )
   {
      g_pVarSet->put(GET_WSTR(DCTVS_CurrentPath),mesg);
      
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Users_Examined),processed.users);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Users_Created),created.users);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Users_Replaced),replaced.users);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Users_Warnings),warnings.users);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Users_Errors),errors.users);

      g_pVarSet->put(GET_WSTR(DCTVS_Stats_GlobalGroups_Examined),processed.globals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_GlobalGroups_Created),created.globals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_GlobalGroups_Replaced),replaced.globals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_GlobalGroups_Warnings),warnings.globals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_GlobalGroups_Errors),errors.globals);


      g_pVarSet->put(GET_WSTR(DCTVS_Stats_LocalGroups_Examined),processed.locals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_LocalGroups_Created),created.locals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_LocalGroups_Replaced),replaced.locals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_LocalGroups_Warnings),warnings.locals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_LocalGroups_Errors),errors.locals);


      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Computers_Examined),processed.computers);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Computers_Created),created.computers);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Computers_Replaced),replaced.computers);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Computers_Warnings),warnings.computers);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Computers_Errors),errors.computers);

      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Generic_Examined),processed.generic);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Generic_Created),created.generic);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Generic_Replaced),replaced.generic);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Generic_Warnings),warnings.generic);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Generic_Errors),errors.generic);
      
   }
   
}


// Gets the domain sid for the specified domain
BOOL                                       // ret- TRUE if successful
   GetSidForDomain(
      LPWSTR                 DomainName,   // in - name of domain to get SID for
      PSID                 * pDomainSid    // out- SID for domain, free with FreeSid
   )
{
   PSID                      pSid = NULL;
   DWORD                     rc = 0;
   _bstr_t                   domctrl;
   
   if (DomainName == NULL || DomainName[0] != L'\\' )
   {
      rc = GetAnyDcName4(DomainName, domctrl);
   }
   if ( ! rc )
   {
      rc = GetDomainSid(domctrl,&pSid);
   }
   (*pDomainSid) = pSid;
   
   return ( pSid != NULL);
}


//---------------------------------------------------------------------------
// CADsPathName Class
//
// Note that this class was copied from AdsiHelpers.h but I have had trouble
// including it in this file. Therefore using copy which should be removed
// once AdsiHelpers.h is included.
//---------------------------------------------------------------------------

#ifndef CADsPathName
class CADsPathName
{
    // ADS_DISPLAY_ENUM
    // ADS_DISPLAY_FULL       = 1
    // ADS_DISPLAY_VALUE_ONLY = 2

    // ADS_FORMAT_ENUM
    // ADS_FORMAT_WINDOWS           =  1
    // ADS_FORMAT_WINDOWS_NO_SERVER =  2
    // ADS_FORMAT_WINDOWS_DN        =  3
    // ADS_FORMAT_WINDOWS_PARENT    =  4
    // ADS_FORMAT_X500              =  5
    // ADS_FORMAT_X500_NO_SERVER    =  6
    // ADS_FORMAT_X500_DN           =  7
    // ADS_FORMAT_X500_PARENT       =  8
    // ADS_FORMAT_SERVER            =  9
    // ADS_FORMAT_PROVIDER          = 10
    // ADS_FORMAT_LEAF              = 11

    // ADS_SETTYPE_ENUM
    // ADS_SETTYPE_FULL     = 1
    // ADS_SETTYPE_PROVIDER = 2
    // ADS_SETTYPE_SERVER   = 3
    // ADS_SETTYPE_DN       = 4
public:

    CADsPathName(_bstr_t strPath = _bstr_t(), long lSetType = ADS_SETTYPE_FULL) :
        m_sp(CLSID_Pathname)
    {
        if (strPath.length() > 0)
        {
            CheckResult(m_sp->Set(strPath, lSetType));
        }
    }

    void Set(_bstr_t strADsPath, long lSetType)
    {
        CheckResult(m_sp->Set(strADsPath, lSetType));
    }

    void SetDisplayType(long lDisplayType)
    {
        CheckResult(m_sp->SetDisplayType(lDisplayType));
    }

    _bstr_t Retrieve(long lFormatType)
    {
        BSTR bstr;
        CheckResult(m_sp->Retrieve(lFormatType, &bstr));
        return _bstr_t(bstr, false);
    }

    long GetNumElements()
    {
        long l;
        CheckResult(m_sp->GetNumElements(&l));
        return l;
    }

    _bstr_t GetElement(long lElementIndex)
    {
        BSTR bstr;
        CheckResult(m_sp->GetElement(lElementIndex, &bstr));
        return _bstr_t(bstr, false);
    }

    void AddLeafElement(_bstr_t strLeafElement)
    {
        CheckResult(m_sp->AddLeafElement(strLeafElement));
    }

    void RemoveLeafElement()
    {
        CheckResult(m_sp->RemoveLeafElement());
    }

    CADsPathName CopyPath()
    {
        IDispatch* pdisp;
        CheckResult(m_sp->CopyPath(&pdisp));
        return CADsPathName(IADsPathnamePtr(IDispatchPtr(pdisp, false)));
    }

    _bstr_t GetEscapedElement(long lReserved, _bstr_t strInStr)
    {
        BSTR bstr;
        CheckResult(m_sp->GetEscapedElement(lReserved, strInStr, &bstr));
        return _bstr_t(bstr, false);
    }

    long GetEscapedMode()
    {
        long l;
        CheckResult(m_sp->get_EscapedMode(&l));
        return l;
    }

    void PutEscapedMode(long l)
    {
        CheckResult(m_sp->put_EscapedMode(l));
    }

protected:

    CADsPathName(const CADsPathName& r) :
        m_sp(r.m_sp)
    {
    }

    CADsPathName(IADsPathnamePtr& r) :
        m_sp(r)
    {
    }

    void CheckResult(HRESULT hr)
    {
        if (FAILED(hr))
        {
            _com_issue_errorex(hr, IUnknownPtr(m_sp), IID_IADsPathname);
        }
    }

protected:

    IADsPathnamePtr m_sp;
};
#endif


STDMETHODIMP 
   CAcctRepl::Process(
      IUnknown             * pWorkItemIn   // in - VarSet defining account replication job
   )
{
    HRESULT hr = S_OK;

    try
    {
       IVarSetPtr                                  pVarSet = pWorkItemIn;

       MCSDCTWORKEROBJECTSLib::IStatusObjPtr       pStatus;
       BOOL                                        bSameForest = FALSE;

       HMODULE hMod = LoadLibrary(L"activeds.dll");
       if ( hMod == NULL )
       {
          DWORD eNum = GetLastError();
          err.SysMsgWrite(ErrE, eNum, DCT_MSG_LOAD_LIBRARY_FAILED_SD, L"activeds.dll", eNum);
          Mark(L"errors",L"generic");
          return HRESULT_FROM_WIN32(eNum);
       }

       ADsGetObject = (ADSGETOBJECT)GetProcAddress(hMod, "ADsGetObject");

       g_pVarSet = pVarSet;

       try{
          pStatus = pVarSet->get(GET_BSTR(DCTVS_StatusObject));
          opt.pStatus = pStatus;
       }
       catch (...)
       {
          // Oh well, keep going
       }
       // Load the options specified by the user including the account information
       WCHAR                  mesg[LEN_Path];
       wcscpy(mesg, GET_STRING(IDS_BUILDING_ACCOUNT_LIST));
       Progress(mesg);
       LoadOptionsFromVarSet(pVarSet);

       MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
       if ( BothWin2K(&opt) )
       {
          hr = pAccess->raw_IsInSameForest(opt.srcDomainDns,opt.tgtDomainDns, (long*)&bSameForest);
       }
       if ( SUCCEEDED(hr) )
       {
          opt.bSameForest = bSameForest;
       }

       // We are going to initialize the Extension objects
       m_pExt = new CProcessExtensions(pVarSet);

       //
       // If updating of user rights is specified then create
       // instance of user rights component and set the test mode option.
       //

       if (m_UpdateUserRights)
       {
          CheckError(CoCreateInstance(CLSID_UserRights, NULL,CLSCTX_ALL, IID_IUserRights, (void**)&m_pUserRights));
          m_pUserRights->put_NoChange(opt.nochange);
       }

       TNodeListSortable    newList;
       if ( opt.expandMemberOf && ! opt.bUndo )  // always expand the member-of property, since we want to update the member-of property for migrated accounts
       {
          // Expand the containers and the membership
          wcscpy(mesg, GET_STRING(IDS_EXPANDING_MEMBERSHIP));
          Progress(mesg);
          // Expand the list to include all the groups that the accounts in this list are members of
          newList.CompareSet(&TNodeCompareAccountTypeAndRDN);
          if ( newList.IsTree() ) newList.ToSorted();
          ExpandMembership( &acctList, &opt, &newList, Progress, FALSE);
       }

       if ( opt.expandContainers && !opt.bUndo)
       {
          // Expand the containers and the membership
          wcscpy(mesg, GET_STRING(IDS_EXPANDING_CONTAINERS));
          Progress(mesg);
          // Expand the list to include all the members of the containers.
          acctList.CompareSet(&TNodeCompareAccountTypeAndRDN);
          ExpandContainers(&acctList, &opt, Progress);
       }

       // Add the newly created list ( if one was created )
       if ( opt.expandMemberOf && !opt.bUndo )
       {
          wcscpy(mesg, GET_STRING(IDS_MERGING_EXPANDED_LISTS));
          Progress(mesg);
          // add the new and the old list
          acctList.CompareSet(&TNodeCompareAccountTypeAndRDN);
          for ( TNode * acct = newList.Head(); acct; )
          {
             TNode * temp = acct->Next();
             if ( ! acctList.InsertIfNew(acct) )
                delete acct;
             acct = temp;
          }
          Progress(L"");
       }
       do { // once

          // Copy the NT accounts for users, groups and/or computers
          if ( pStatus!= NULL && (pStatus->Status & DCT_STATUS_ABORTING) )
             break;
          int res;

          if ( opt.bUndo )
             res = UndoCopy(&opt,&acctList,&Progress, err,(IStatusObj *)((MCSDCTWORKEROBJECTSLib::IStatusObj *)pStatus),NULL);
          else
             res = CopyObj( &opt,&acctList,&Progress, err,(IStatusObj *)((MCSDCTWORKEROBJECTSLib::IStatusObj *)pStatus),NULL);
          // Close the password log
          if ( opt.passwordLog.IsOpen() )
          {
             opt.passwordLog.LogClose();
          }

          if ( pStatus != NULL && (pStatus->Status & DCT_STATUS_ABORTING) )
             break;
          // Update Rights for user and group accounts
          if ( m_UpdateUserRights )
          {
             UpdateUserRights((IStatusObj *)((MCSDCTWORKEROBJECTSLib::IStatusObj *)pStatus));
          }

          if ( pStatus != NULL && (pStatus->Status & DCT_STATUS_ABORTING) )
             break;

          // Change of Domain affiliation on computers and optional reboot will be done by local agent 
     
       } while (false);

       LoadResultsToVarSet(pVarSet);

       // Cleanup the account list
       if ( acctList.IsTree() )
       {
          acctList.ToSorted();
       }

       TNodeListEnum             e;
       TAcctReplNode           * tnode;
       TAcctReplNode           * tnext;


       for ( tnode = (TAcctReplNode *)e.OpenFirst(&acctList) ; tnode ; tnode = tnext )
       {
          tnext = (TAcctReplNode*)e.Next();
          acctList.Remove(tnode);
          delete tnode;
       }
       e.Close();
       err.LogClose();
       Progress(L"");
       if (m_pExt)
          delete m_pExt;

       g_pVarSet = NULL;
       if ( hMod )
          FreeLibrary(hMod);
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
        err.SysMsgWrite(ErrS, hr, DCT_MSG_ACCOUNT_REPLICATOR_UNABLE_TO_CONTINUE);
    }
    catch (...)
    {
        hr = E_UNEXPECTED;
        err.SysMsgWrite(ErrS, hr, DCT_MSG_ACCOUNT_REPLICATOR_UNABLE_TO_CONTINUE);
    }

    return hr;
}


//------------------------------------------------------------------------------
// CopyObj: When source and target domains are both Win2k this function calls
//          The 2kobject functions. Other wise it calls the User copy functions.
//------------------------------------------------------------------------------
int CAcctRepl::CopyObj(
                        Options              * options,      // in -options
                        TNodeListSortable    * acctlist,     // in -list of accounts to process
                        ProgressFn           * progress,     // in -window to write progress messages to
                        TError               & error,        // in -window to write error messages to
                        IStatusObj           * pStatus,      // in -status object to support cancellation
                        void                   WindowUpdate (void )    // in - window update function
                    )
{
   BOOL bSameForest = FALSE;
   long rc;
   HRESULT hr = S_OK;
   // if the Source/Target domain is NT4 then use the UserCopy Function. If both domains are Win2K then use
   // the CopyObj2K function to do so.
   if ( BothWin2K( options ) ) 
   {
      // Since these are Win2k domains we need to process it with Win2k code.
      MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
      // First of all we need to find out if they are in the same forest.
      HRESULT hr = pAccess->raw_IsInSameForest(options->srcDomainDns,options->tgtDomainDns, (long*)&bSameForest);
      if ( SUCCEEDED(hr) )
      {
         options->bSameForest = bSameForest;
         if ( !bSameForest || (options->flags & F_COMPUTERS) ) // always copy the computer accounts
         {
             // Different forest we need to copy.
            rc = CopyObj2K(options, acctlist, progress, pStatus);
            if (opt.fixMembership)
            {
                // Update the group memberships
                rc = UpdateGroupMembership(options, acctlist, progress, pStatus);
                if ( !options->expandMemberOf )
                {
                   hr = UpdateMemberToGroups(acctlist, options, FALSE);
                   rc = HRESULT_CODE(hr);
                }
                else //if groups migrated, still expand but only for groups
                {
                   hr = UpdateMemberToGroups(acctlist, options, TRUE);
                   rc = HRESULT_CODE(hr);
                }
            }
                 //for user or group, migrate the manager\directReports or
                 //managedBy\managedObjects properties respectively
            if ((options->flags & F_USERS) || (options->flags & F_GROUP)) 
                 UpdateManagement(acctlist, options);
         }
         else 
         {
            // Within a forest we can move the object around.
            rc = MoveObj2K(options, acctlist, progress, pStatus);
         }

         if ( progress )
            progress(L"");
      }
      else
      {
         rc = -1;
         err.SysMsgWrite(ErrE, hr, DCT_MSG_ACCESS_CHECKER_FAILED_D, hr);
         Mark(L"errors",L"generic");
      }
   }
   else
   {
      // Create the object.
      rc = CopyObj2K(options, acctlist, progress, pStatus);
      if (opt.fixMembership)
      {
        rc = UpdateGroupMembership(options, acctlist, progress, pStatus);
        if ( !options->expandMemberOf )
        {
           hr = UpdateMemberToGroups(acctlist, options, FALSE);
           rc = HRESULT_CODE(hr);
        }
        else //if groups migrated, still expand but only for groups
        {
           hr = UpdateMemberToGroups(acctlist, options, TRUE);
           rc = HRESULT_CODE(hr);
        }
      }
      // Call NT4 Code to update the group memberships
      //UpdateNT4GroupMembership(options, acctlist, progress, pStatus, WindowUpdate);
   }
   return rc;
}

//------------------------------------------------------------------------------
// BothWin2k: Checks to see if Source and Target domains are both Win2k.
//------------------------------------------------------------------------------
bool CAcctRepl::BothWin2K(                                     // True if both domains are win2k
                              Options  * pOptions              //in- options
                          )
{
   // This function checks for the version on the Source and Target domain. If either one is
   // a non Win2K domain then it returns false
   bool retVal = true;

   if ( (pOptions->srcDomainVer > -1) && (pOptions->tgtDomainVer > -1) )
      return ((pOptions->srcDomainVer > 4) && (pOptions->tgtDomainVer > 4));
   
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   HRESULT                      hr;
   DWORD                        verMaj, verMin, sp;
   
   hr = pAccess->raw_GetOsVersion(pOptions->srcComp, &verMaj, &verMin, &sp);

   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrE,hr, DCT_MSG_GET_OS_VER_FAILED_SD, pOptions->srcDomain, hr);
      Mark(L"errors", L"generic");
      retVal = false;
   }
   else
   {
      pOptions->srcDomainVer = verMaj;
      pOptions->srcDomainVerMinor = verMin;
      if (verMaj < 5)
         retVal = false;
   }

   hr = pAccess->raw_GetOsVersion(pOptions->tgtComp, &verMaj, &verMin, &sp);
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrE, hr,DCT_MSG_GET_OS_VER_FAILED_SD, pOptions->tgtDomain , hr);
      Mark(L"errors", L"generic");
      retVal = false;
   }
   else
   {
      pOptions->tgtDomainVer = verMaj;
      pOptions->tgtDomainVerMinor = verMin;
      if  (verMaj < 5)
         retVal = false;
   }
   return retVal;
}

int CAcctRepl::CopyObj2K( 
                           Options              * pOptions,    //in -Options that we recieved from the user
                           TNodeListSortable    * acctlist,    //in -AcctList of accounts to be copied.
                           ProgressFn           * progress,    //in -Progress Function to display messages
                           IStatusObj           * pStatus      // in -status object to support cancellation
                        )
{
    // This function copies the object from Win2K domain to another Win2K domain.

    TNodeTreeEnum             tenum;
    TAcctReplNode           * acct;
    IObjPropBuilderPtr        pObjProp(__uuidof(ObjPropBuilder));
    IVarSetPtr                pVarset(__uuidof(VarSet));
    IUnknown                * pUnk;
    HRESULT                   hr;
    _bstr_t                   currentType = L"";
    //   TNodeListSortable       pMemberOf;

    // sort the account list by Source Type\Source Name
    acctlist->CompareSet(&TNodeCompareAccountType);

    if ( acctlist->IsTree() ) acctlist->ToSorted();
    acctlist->SortedToScrambledTree();
    acctlist->Sort(&TNodeCompareAccountType);
    acctlist->Balance();

    if ( pOptions->flags & F_AddSidHistory )
    {
        //Need to Add Sid history on the target account. So lets bind it and go from there
        g_bAddSidWorks = BindToDS( pOptions );
    }

    if ( pOptions->flags & F_TranslateProfiles )
    {
        GetBkupRstrPriv((WCHAR*)NULL);
        GetPrivilege((WCHAR*)NULL,SE_SECURITY_NAME);
    }

    // Get the defaultNamingContext for the source domain
    _variant_t                var;

    // Get an IUnknown pointer to the Varset for passing it around.
    hr = pVarset->QueryInterface(IID_IUnknown, (void**)&pUnk);

    CTargetPathSet setTargetPath;

    for ( acct = (TAcctReplNode *)tenum.OpenFirst(acctlist) ; acct ; acct = (TAcctReplNode *)tenum.Next() )
    {
        if (m_pExt && acct->CallExt())
        {
            hr = m_pExt->Process(acct, pOptions->tgtDomain, pOptions,TRUE);
        }
        // We will process accounts only if the corresponding check boxes (for object types to copy) are checked.
        if ( !NeedToProcessAccount( acct, pOptions ) )
            continue;

        // If we are told not to copy the object then we will obey
        if ( !acct->CreateAccount() )
            continue;

        //if the UPN name conflicted, then the UPNUpdate extension set the hr to
        //ERROR_OBJECT_ALREADY_EXISTS.  If so, set flag for "no change" mode
        if (acct->GetHr() == ERROR_OBJECT_ALREADY_EXISTS)
        {
            acct->bUPNConflicted = TRUE;
            acct->SetHr(S_OK);
        }

        // Mark processed object count and update the status display
        Mark(L"processed", acct->GetType());

        if ( pStatus )
        {
            LONG                status = 0;
            HRESULT             hr = pStatus->get_Status(&status);

            if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
            {
                if ( !bAbortMessageWritten ) 
                {
                    err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                    bAbortMessageWritten = true;
                }
                break;
            }
        }

        // Create the target object
        WCHAR                  mesg[LEN_Path];
        wsprintf(mesg, GET_STRING(IDS_CREATING_S), acct->GetName());
        if ( progress )
            progress(mesg);

        HRESULT hrCreate = Create2KObj(acct, pOptions, setTargetPath);

        acct->SetHr(hrCreate);
        if ( SUCCEEDED(hrCreate) )
        {
            err.MsgWrite(0, DCT_MSG_ACCOUNT_CREATED_S, acct->GetTargetName());
        }
        else 
        {
            if ((HRESULT_CODE(hrCreate) == ERROR_OBJECT_ALREADY_EXISTS) )
            {
                ;
            }
            else 
            {
                if ( acct->IsCritical() )
                {
                    err.SysMsgWrite(ErrE,ERROR_SPECIAL_ACCOUNT,DCT_MSG_REPLACE_FAILED_SD,acct->GetName(),ERROR_SPECIAL_ACCOUNT);
                    Mark(L"errors", acct->GetType());
                }
                else
                {
                    if ( HRESULT_CODE(hrCreate) == ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH )
                    {
                        err.MsgWrite(ErrE, DCT_MSG_CANT_REPLACE_DIFFERENT_TYPE_SS, acct->GetTargetPath(), acct->GetSourcePath() );
                        Mark(L"errors", acct->GetType());
                    }
                    else
                    {
                        err.SysMsgWrite(ErrE, hrCreate, DCT_MSG_CREATE_FAILED_SSD, acct->GetName(), pOptions->tgtDomain, hrCreate);
                        Mark(L"errors", acct->GetType());
                    }
                }
            }
        }   

        if ( acct->WasCreated() )
        {
            // Do we need to add sid history
            if ( pOptions->flags & F_AddSidHistory )
            {
                // Global flag tells us if we should try the AddSidHistory because
                // for some special cases if it does not work once it will not work
                // see the AddSidHistory function for more details.
                if ( g_bAddSidWorks )
                {
                    WCHAR                  mesg[LEN_Path];
                    wsprintf(mesg, GET_STRING(IDS_ADDING_SIDHISTORY_S), acct->GetName());
                    if ( progress )
                        progress(mesg);
                    if (! AddSidHistory( pOptions, acct->GetSourceSam(), acct->GetTargetSam(), pStatus ) )
                    {
                        Mark(L"errors", acct->GetType());
                    }
                    //               CopySidHistoryProperty(pOptions, acct, pStatus);
                }
            }
        }
    }

    tenum.Close();

    // free memory as set no longer needed
    setTargetPath.clear();

    bool bWin2k = BothWin2K(pOptions);

    //
    // Generate a mapping between the source object's distinguished name and the target object's
    // distinguished name. This is used to translate distinguished name attributes during copying
    // of properties.
    //

    IVarSetPtr spSourceToTargetDnMap = GenerateSourceToTargetDnMap(acctlist);

    for ( acct = (TAcctReplNode *)tenum.OpenFirst(acctlist) ; acct ; acct = (TAcctReplNode *)tenum.Next() )
    {
        if ( pStatus )
        {
            LONG                status = 0;
            HRESULT             hr = pStatus->get_Status(&status);

            if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
            {
                if ( !bAbortMessageWritten ) 
                {
                    err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                    bAbortMessageWritten = true;
                }
                break;
            }
        }
        // We are told not to copy the properties to the account so we ignore it.
        if ( acct->CopyProps() )
        {
            // If the object type is different from the one that was processed prior to this then we need to map properties
            if ((!pOptions->nochange) && (_wcsicmp(acct->GetType(),currentType) != 0))
            {
                WCHAR                  mesg[LEN_Path];
                wsprintf(mesg, GET_STRING(IDS_MAPPING_PROPS_S), acct->GetType());
                if ( progress )
                    progress(mesg);
                // Set the current type
                currentType = acct->GetType();
                // Clear the current mapping 
                pVarset->Clear();
                // Get a new mapping
                if ( BothWin2K(pOptions) )
                {
                    hr = pObjProp->raw_MapProperties(currentType, pOptions->srcDomain, pOptions->srcDomainVer, currentType, pOptions->tgtDomain, pOptions->tgtDomainVer, 0, &pUnk);
                    if (hr == DCT_MSG_PROPERTIES_NOT_MAPPED)
                    {
                        err.MsgWrite(ErrW,DCT_MSG_PROPERTIES_NOT_MAPPED, acct->GetType());
                        hr = S_OK;
                    }
                }
                else
                    hr = S_OK;

                if ( FAILED( hr ) )
                {
                    err.SysMsgWrite(ErrE, hr, DCT_MSG_PROPERTY_MAPPING_FAILED_SD, (WCHAR*)currentType, hr);
                    Mark(L"errors", currentType);
                    // No properties should be set if mapping fails
                    pVarset->Clear();
                }
            }
            // We update the properties if the object was created or it already existed and the replce flag is set.
            BOOL bExists = FALSE;
            if (HRESULT_CODE(acct->GetHr()) == ERROR_OBJECT_ALREADY_EXISTS)
                bExists = TRUE;

            if ( ((SUCCEEDED(acct->GetHr()) && (!bExists)) || ((bExists) && (pOptions->flags & F_REPLACE))) )
            {
                WCHAR                  mesg[LEN_Path];
                wsprintf(mesg, GET_STRING(IDS_UPDATING_PROPS_S), acct->GetName());
                if ( progress )
                    progress(mesg);
                // Create the AccountList object and update the list variable
                if ( !pOptions->nochange )
                {
                    _bstr_t sExcList;

                    if (pOptions->bExcludeProps)
                    {
                        if (!_wcsicmp(acct->GetType(), s_ClassUser))
                            sExcList = pOptions->sExcUserProps;
                        else if (!_wcsicmp(acct->GetType(), s_ClassInetOrgPerson))
                            sExcList = pOptions->sExcInetOrgPersonProps;
                        else if (!_wcsicmp(acct->GetType(), L"group"))
                            sExcList = pOptions->sExcGroupProps;
                        else if (!_wcsicmp(acct->GetType(), L"computer"))
                            sExcList = pOptions->sExcCmpProps;
                    }

                    //
                    // If asterisk character is not specified then copy properties using specified
                    // exclusion list otherwise exclude all properties by not copying any properties.
                    //

                    if ((sExcList.length() == 0) || (IsStringInDelimitedString(sExcList, L"*", L',') == FALSE))
                    {
                        //exclude user's profile path if translate roaming profiles and sIDHistory
                        //are both not selected
                        if (((!_wcsicmp(acct->GetType(), s_ClassUser) || !_wcsicmp(acct->GetType(), s_ClassInetOrgPerson))) && 
                            (!(pOptions->flags & F_TranslateProfiles)) && (!(pOptions->flags & F_AddSidHistory)))
                        {
                            //if already excluding properties, just add profiles to the list
                            if (pOptions->bExcludeProps)
                            {
                                //if we already have a list add a , to the end
                                if (sExcList.length())
                                    sExcList += L",";

                                //add the profile path to the exclude list
                                sExcList += L"profilePath";
                            }
                            else //else turn on the flag and add just profile path to the exclude list
                            {
                                //set the flag to indicate we want to exclude something
                                pOptions->bExcludeProps = TRUE;
                                //add the profile path only to the exclude list
                                sExcList = L"profilePath";
                            }
                        }//end if to exclude profile path

                        // add system exclude attributes

                        if (pOptions->sExcSystemProps.length())
                        {
                            if (sExcList.length())
                            {
                                sExcList += L",";
                            }

                            sExcList += pOptions->sExcSystemProps;

                            pOptions->bExcludeProps = TRUE;
                        }

                        if ( bWin2k )
                        {
                            //if ask to, exclude any properties desired by the user and create a new varset
                            if (pOptions->bExcludeProps)
                            {
                                IVarSetPtr pVarsetTemp(__uuidof(VarSet));
                                IUnknown * pUnkTemp;
                                hr = pVarsetTemp->QueryInterface(IID_IUnknown, (void**)&pUnkTemp);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pObjProp->raw_ExcludeProperties(sExcList, pUnk, &pUnkTemp);
                                }

                                //
                                // Only copy properties if exclusion list was successfully created.

                                // This prevents possibly updating attributes that should not be
                                // updated. For example, if some attributes used by Exchange were
                                // updated this could break Exchange functionality.
                                //

                                if (SUCCEEDED(hr))
                                {
                                    // Call the win 2k code to copy all but excluded props
                                    hr = pObjProp->raw_CopyProperties(
                                        const_cast<WCHAR*>(acct->GetSourcePath()),
                                        pOptions->srcDomain, 
                                        const_cast<WCHAR*>(acct->GetTargetPath()),
                                        pOptions->tgtDomain,
                                        pUnkTemp,
                                        pOptions->pDb,
                                        IUnknownPtr(spSourceToTargetDnMap)
                                    );
                                }
                                pUnkTemp->Release();
                            }//end if asked to exclude
                            else
                            {
                                // Call the win 2k code to copy all props
                                hr = pObjProp->raw_CopyProperties(
                                    const_cast<WCHAR*>(acct->GetSourcePath()),
                                    pOptions->srcDomain, 
                                    const_cast<WCHAR*>(acct->GetTargetPath()),
                                    pOptions->tgtDomain,
                                    pUnk,
                                    pOptions->pDb,
                                    IUnknownPtr(spSourceToTargetDnMap)
                                );
                            }
                        }
                        else
                        {
                            // Otherwise let the Net APIs do their thing.
                            hr = pObjProp->raw_CopyNT4Props(const_cast<WCHAR*>(acct->GetSourceSam()), 
                                const_cast<WCHAR*>(acct->GetTargetSam()),
                                pOptions->srcComp, pOptions->tgtComp, 
                                const_cast<WCHAR*>(acct->GetType()),
                                acct->GetGroupType(),
                                sExcList);
                        }
                    }
                }
                else
                    // we are going to assume that copy properties would work
                    hr = S_OK;

                if ( FAILED(hr) )
                {
                    if ( (acct->GetStatus() & AR_Status_Special) )
                    {
                        err.MsgWrite(ErrE,DCT_MSG_FAILED_TO_REPLACE_SPECIAL_ACCT_S,acct->GetTargetSam());
                    }
                    else
                    {
                        err.SysMsgWrite(ErrE, HRESULT_CODE(hr), DCT_MSG_COPY_PROPS_FAILED_SD, acct->GetTargetName(), hr);
                    }
                    acct->MarkError();
                    Mark(L"errors", acct->GetType());
                } 
                else
                {
                    if (HRESULT_CODE(acct->GetHr()) == ERROR_OBJECT_ALREADY_EXISTS)
                    {
                        acct->MarkAlreadyThere();
                        acct->MarkReplaced();
                        Mark(L"replaced",acct->GetType());
                        err.MsgWrite(0, DCT_MSG_ACCOUNT_REPLACED_S, acct->GetTargetName());
                    }
                }
            }
        }
        // do we need to call extensions. Only if Extension flag is set and the object is copied.
        if ((!pOptions->nochange) && (acct->CallExt()) && (acct->WasCreated() || acct->WasReplaced()))
        {
            // Let the Extension objects do their thing.
            WCHAR                  mesg[LEN_Path];
            wsprintf(mesg,GET_STRING(IDS_RUNNING_EXTS_S), acct->GetName());
            if ( progress )
                progress(mesg);

            // Close the log file if it is open
            WCHAR          filename[LEN_Path];
            err.LogClose();
            if (m_pExt)
                hr = m_pExt->Process(acct, pOptions->tgtDomain, pOptions,FALSE);
            safecopy (filename,opt.logFile);
            err.LogOpen(filename,1 /*append*/);

        }


        // only do these updates for account's we're copying
        //    and only do updates if the account was actually created
        //    .. or if the account was replaced, 
        //          or if we intentionally didn't replace the account (as in the group merge case)
        if ( acct->CreateAccount()          
            && ( acct->WasCreated()       
            || (  acct->WasReplaced() 
            || !acct->CopyProps()   
            ) 
            ) 
            )
        {
            WCHAR                  mesg[LEN_Path];
            wsprintf(mesg, GET_STRING(IDS_TRANSLATE_ROAMING_PROFILE_S), acct->GetName());
            if ( progress )
                progress(mesg);

            //Set the new profile if needed 
            if ( pOptions->flags & F_TranslateProfiles && ((_wcsicmp(acct->GetType(), s_ClassUser) == 0) || (_wcsicmp(acct->GetType(), s_ClassInetOrgPerson) == 0)))
            {
                WCHAR                tgtProfilePath[MAX_PATH];
                GetBkupRstrPriv((WCHAR*)NULL);
                GetPrivilege((WCHAR*)NULL,SE_SECURITY_NAME);
                if ( wcslen(acct->GetSourceProfile()) > 0 )
                {
                    DWORD ret = TranslateRemoteProfile( acct->GetSourceProfile(), 
                        tgtProfilePath,
                        acct->GetSourceSam(),
                        acct->GetTargetSam(),
                        pOptions->srcDomain,
                        pOptions->tgtDomain,
                        pOptions->pDb,
                        pOptions->lActionID,
                        NULL,
                        pOptions->nochange);
                    if ( !ret )  
                    {
                        WCHAR                  tgtuser[LEN_Path];
                        USER_INFO_3          * tgtinfo;
                        DWORD                  nParmErr;
                        wcscpy(tgtuser, acct->GetTargetSam());
                        // Get information for the target account
                        long rc = NetUserGetInfo(const_cast<WCHAR *>(pOptions->tgtComp),
                            tgtuser,
                            3,
                            (LPBYTE *) &tgtinfo);

                        if (!pOptions->nochange)
                        {
                            // Set the new profile path
                            tgtinfo->usri3_profile = tgtProfilePath;
                            // Set the information back for the account.
                            rc = NetUserSetInfo(const_cast<WCHAR *>(pOptions->tgtComp),
                                tgtuser,
                                3,
                                (LPBYTE)tgtinfo,
                                &nParmErr);
                            NetApiBufferFree((LPVOID) tgtinfo);
                            if (rc)
                            {
                                err.MsgWrite(ErrE, DCT_MSG_SETINFO_FAIL_SD, tgtuser, rc);
                                Mark(L"errors", acct->GetType());
                            }
                        }
                    }
                }
            }

            if ( acct->WasReplaced() )
            {

                // Do we need to add sid history
                if ( pOptions->flags & F_AddSidHistory )
                {
                    WCHAR                  mesg[LEN_Path];
                    wsprintf(mesg, GET_STRING(IDS_ADDING_SIDHISTORY_S), acct->GetName());
                    if ( progress )
                        progress(mesg);

                    // Global flag tells us if we should try the AddSidHistory because
                    // for some special cases if it does not work once it will not work
                    // see the AddSidHistory function for more details.
                    if ( g_bAddSidWorks )
                    {
                        if (! AddSidHistory( pOptions, acct->GetSourceSam(), acct->GetTargetSam(), pStatus ) )
                        {
                            Mark(L"errors", acct->GetType());
                        }
                        //                  CopySidHistoryProperty(pOptions, acct, pStatus);
                    }
                }

            }      
            wsprintf(mesg, L"", acct->GetName());
            if ( progress )
                progress(mesg);
        }
    }

    // Cleanup
    pUnk->Release();
    tenum.Close();
    return 0;
}

void CAcctRepl::LoadOptionsFromVarSet(IVarSet * pVarSet)
{
    _bstr_t text;
    DWORD rc;
    MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));

    //store the name of the wizard being run
    opt.sWizard = pVarSet->get(GET_BSTR(DCTVS_Options_Wizard));

    //
    // If group mapping and merging is the task then allow distinguished
    // name conflicts as the main reason for this task is to merge
    // several source groups into one target group.
    //

    if (opt.sWizard.length() && (_wcsicmp((wchar_t*)opt.sWizard, L"groupmapping") == 0))
    {
        m_bIgnorePathConflict = true;
    }

    // Read General Options
    // open log file first, so we'll be sure to get any errors!
    text = pVarSet->get(GET_BSTR(DCTVS_Options_Logfile));
    safecopy(opt.logFile,(WCHAR*)text);

    WCHAR filename[MAX_PATH];

    safecopy (filename,opt.logFile);

    err.LogOpen(filename,1 /*append*/);

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Domain));
    safecopy(opt.authDomain ,(WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_UserName));
    safecopy(opt.authUser ,(WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password));
    safecopy(opt.authPassword,(WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
    safecopy(opt.srcDomain,(WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
    safecopy(opt.tgtDomain,(WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomainDns));
    safecopy(opt.srcDomainDns,(WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomainDns));
    safecopy(opt.tgtDomainDns,(WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomainFlat));
    safecopy(opt.srcDomainFlat,(WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomainFlat));
    safecopy(opt.tgtDomainFlat,(WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_SourceServer));
    safecopy(opt.srcComp, (WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_SourceServerDns));
    safecopy(opt.srcCompDns, (WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_SourceServerFlat));
    safecopy(opt.srcCompFlat, (WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_TargetServer));
    safecopy(opt.tgtComp, (WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_TargetServerDns));
    safecopy(opt.tgtCompDns, (WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_TargetServerFlat));
    safecopy(opt.tgtCompFlat, (WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_NoChange));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
    {
        opt.nochange = TRUE;
    }
    else
    {
        opt.nochange = FALSE;
    }

    // Read Account Replicator Options

    // initialize
    safecopy(opt.prefix, L"");
    safecopy(opt.suffix, L"");
    safecopy(opt.globalPrefix, L"");
    safecopy(opt.globalSuffix, L"");

    DWORD flags = 0;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ReplaceExistingAccounts));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
    {
        flags |= F_REPLACE;
    }
    else
    {
        // Prefix/Suffix only apply if the Replace flag is not set.
        text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_Prefix));
        safecopy(opt.prefix,(WCHAR*)text);

        text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_Suffix));
        safecopy(opt.suffix,(WCHAR*)text);
    }

    // Global flags apply no matter what
    text = pVarSet->get(GET_BSTR(DCTVS_Options_Prefix));
    safecopy(opt.globalPrefix,(WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_Options_Suffix));
    safecopy(opt.globalSuffix,(WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyContainerContents));
    if ( text == _bstr_t(GET_BSTR(IDS_YES)) )
        opt.expandContainers = TRUE;
    else
        opt.expandContainers = FALSE;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyMemberOf));
    if ( text == _bstr_t(GET_BSTR(IDS_YES)) )
        opt.expandMemberOf = TRUE;
    else
        opt.expandMemberOf = FALSE;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_FixMembership));
    if ( text == _bstr_t(GET_BSTR(IDS_YES)) )
        opt.fixMembership = TRUE;
    else
        opt.fixMembership = FALSE;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_AddToGroup));
    safecopy(opt.addToGroup,(WCHAR*)text);

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_AddToGroupOnSourceDomain));
    safecopy(opt.addToGroupSource,(WCHAR*)text);


    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_TranslateRoamingProfiles));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
        flags |= F_TranslateProfiles;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyUsers));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
        flags |= F_USERS;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyGlobalGroups));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
        flags |= F_GROUP;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyComputers));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
        flags |= F_COMPUTERS;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyOUs));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
        flags |= F_OUS;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyContainerContents));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
        flags |= F_COPY_CONT_CONTENT;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_IncludeMigratedAccts));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
        flags |= F_COPY_MIGRATED_ACCT;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyLocalGroups));
    if (! UStrICmp(text,GET_STRING(IDS_YES)) )
        flags |= F_LGROUP;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableCopiedAccounts));
    if (! UStrICmp(text,GET_STRING(IDS_All)) )
        flags |= F_DISABLE_ALL;
    else if (! UStrICmp(text,GET_STRING(IDS_Special)) )
        flags |= F_DISABLE_SPECIAL;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableSourceAccounts));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
        flags |= F_DISABLESOURCE;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_GenerateStrongPasswords));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
        flags |= F_STRONGPW_ALL;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordFile));
    if ( text.length() )
    {
        // don't need this anymore, since it is handled by a plug-in
        // opt.passwordLog.LogOpen(text,TRUE);
    }

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_UpdateUserRights));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
    {
        m_UpdateUserRights = TRUE;
    }

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ReplaceExistingGroupMembers));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
        flags |= F_REMOVE_OLD_MEMBERS;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_RemoveExistingUserRights));
    if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
        flags |= F_RevokeOldRights;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_MoveReplacedAccounts));
    if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
        flags |= F_MOVE_REPLACED_ACCT;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyComputers));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
    {
        flags |= F_MACHINE;
    }

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_AddSidHistory));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
    {
        flags |= F_AddSidHistory;
    }

    opt.flags = flags;

    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_RenameOnly));
    if (! UStrICmp(text,GET_STRING(IDS_YES)) )
    {
        m_RenameOnly = TRUE;
    }

    text = pVarSet->get(GET_BSTR(DCTVS_Options_Undo));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
    {
        // this is an undo operation
        opt.bUndo = TRUE;
    }
    else
    {
        opt.bUndo = FALSE;
    }

    // What undo action are we performing.
    if ( opt.bUndo )
    {
        _variant_t var = pVarSet->get(L"UndoAction");
        if (var.vt == VT_I4)
            opt.lUndoActionID = var.lVal;
        else
            opt.lUndoActionID = -2;
    }
    else
    {
        _variant_t var = pVarSet->get(L"ActionID");
        if (var.vt == VT_I4)
            opt.lActionID = var.lVal;
        else
            opt.lActionID = -1;
    }

    // Read the password policy from the varset

    // We used to get the strong password policy from the target EA Server, so we can generate strong passwords
    // that meet the policy.
    // we don't do that anymore, since we have removed all depenedencies on EA.
    LONG           len = 10;

    // set the password settings to default values
    opt.policyInfo.bEnforce = TRUE;

    opt.policyInfo.maxConsecutiveAlpha = (LONG)pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MaxConsecutiveAlpha));
    opt.policyInfo.minDigits = (LONG)pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinDigit));
    opt.policyInfo.minLower = (LONG)pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinLower));
    opt.policyInfo.minUpper = (LONG)pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinUpper));
    opt.policyInfo.minSpecial = (LONG)pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinSpecial));   

    HRESULT hrAccess = pAccess->raw_GetPasswordPolicy(opt.tgtDomain,&len);   
    if ( SUCCEEDED(hrAccess) )
    {
        opt.minPwdLength = len;

        pVarSet->put(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinLength),len);
    }

    WriteOptionsToLog();

    // Build List of Accounts to Copy
    // Clear the account list first though
    TNodeListEnum             e;
    TAcctReplNode           * acct;
    for ( acct = (TAcctReplNode *)e.OpenFirst(&acctList) ; acct ; acct = (TAcctReplNode *)e.Next() )
    {
        acctList.Remove((TNode*)acct);
    }

    BothWin2K(&opt);

    // See if a global operation mask specified.
    _variant_t vdwOpMask = pVarSet->get(GET_BSTR(DCTVS_Options_GlobalOperationMask));
    if ( vdwOpMask.vt == VT_I4 )
        g_dwOpMask = (DWORD)vdwOpMask.lVal;

    // Then build the new list expect a list of accounts to copy in the VarSet
    if ( ! opt.bUndo )
    {
        rc = PopulateAccountListFromVarSet(pVarSet);
        if  ( rc )
        {
            _com_issue_error(HRESULT_FROM_WIN32(rc));
        }
    }

    // If we have an NT5 source domain then we need to fillin the path info
    DWORD maj, min, sp;
    HRESULT hr = pAccess->raw_GetOsVersion(opt.srcComp, &maj, &min, &sp);
    if (SUCCEEDED(hr))
    {
        // Ask the auxiliarry function to fill in the the Path for the source object if the AcctNode is not filled
        for ( acct = (TAcctReplNode *)e.OpenFirst(&acctList) ; acct ; acct = (TAcctReplNode *)e.Next() )
        {
            if ((!acct->IsFilled) && (maj > 4))
            {
                FillPathInfo(acct, &opt);
                AddPrefixSuffix(acct, &opt);
            }
            else if ((maj == 4) && (!_wcsicmp(acct->GetType(),L"computer")))
                FillPathInfo(acct, &opt);
        }
    }

    // Check for incompatible options!
    if ( (flags & F_RevokeOldRights) && !m_UpdateUserRights )
    {
        err.MsgWrite(ErrW,DCT_MSG_RIGHTS_INCOMPATIBLE_FLAGS);
        Mark(L"warnings", "generic");
    }

    text = pVarSet->get(GET_BSTR(DCTVS_Options_OuPath));
    if ( text.length() )
    {
        wcscpy(opt.tgtOUPath, text);
    }

    // intialize the system exclude attributes option
    // if not in passed in VarSet then retrieve from database

    _variant_t vntSystemExclude = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedSystemProps));

    if (V_VT(&vntSystemExclude) == VT_EMPTY)
    {
        IVarSetPtr spVarSet(__uuidof(VarSet));
        IUnknownPtr spUnknown(spVarSet);
        IUnknown* punk = spUnknown;
        opt.pDb->GetSettings(&punk);
        vntSystemExclude = spVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedSystemProps));
    }

    opt.sExcSystemProps = vntSystemExclude;

    //store the object property exclusion lists in the options structure

    opt.sExcUserProps = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedUserProps));
    opt.sExcInetOrgPersonProps = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedInetOrgPersonProps));
    opt.sExcGroupProps = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedGroupProps));
    opt.sExcCmpProps = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedComputerProps));
    text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludeProps));
    if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
        opt.bExcludeProps = TRUE;
    else
        opt.bExcludeProps = FALSE;
}

DWORD 
   CAcctRepl::PopulateAccountListFromVarSet(
      IVarSet              * pVarSet       // in - varset containing account list
   )
{
   _bstr_t                   val;
   long                      numAccounts;
   _bstr_t                   text;
   DWORD maj, min, sp;
   PSID                      pSrcSid = NULL;
   WCHAR                     txtSid[200] = L"";
   DWORD                     lenTxt = DIM(txtSid);
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   
   numAccounts = pVarSet->get(GET_BSTR(DCTVS_Accounts_NumItems));
   
   // Set up the account list functionality
   acctList.CompareSet(&TNodeCompareNameOnly);
   if ( acctList.IsTree() ) acctList.ToSorted();

      //get the source domain's Sid so we can store it as part of the node
   _bstr_t source = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
   GetSidForDomain((WCHAR*)source,&pSrcSid);

   for ( int i = 0 ; i < numAccounts ; i++ )
   {
      WCHAR                  key[LEN_Path];
      UCHAR                  acctName[LEN_Account];
      TAcctReplNode        * curr = new TAcctReplNode;

      if (!curr)
         return ERROR_NOT_ENOUGH_MEMORY;

      if ( opt.pStatus )
      {
         LONG                status = 0;
         HRESULT             hr = opt.pStatus->get_Status(&status);

         if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
         {
            if ( !bAbortMessageWritten ) 
            {
               err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
               bAbortMessageWritten = true;
            }
            break;
         }
      }


      // The object type must be specified
      swprintf(key,GET_STRING(DCTVSFmt_Accounts_Type_D),i);
      val = pVarSet->get(key);
      curr->SetType(val);
      
      swprintf(key,GET_STRING(DCTVSFmt_Accounts_D),i);
      text = pVarSet->get(key);
      if ( ! text.length() )
      {
         // oops, no name specified 
         // skip this entry and try the next one
         err.MsgWrite(ErrW,DCT_MSG_NO_NAME_IN_VARSET_S,key);
         Mark(L"warnings",L"generic");
         delete curr;
         continue;
      }
      
         //set the source domain's sid
      curr->SetSourceSid(pSrcSid);

      // Set the operation to the global mask then check if we need to overwrite with the individual setting.
      curr->operations = g_dwOpMask;

      swprintf(key, GET_STRING(DCTVS_Accounts_D_OperationMask), i);
      _variant_t vOpMask = pVarSet->get(key);
      if ( vOpMask.vt == VT_I4 )
         curr->operations = (DWORD)vOpMask.lVal;
      
      // Get the rest of the info from the VarSet.
      if ( ( (text.length() > 7 ) && (_wcsnicmp((WCHAR*) text, L"LDAP://",UStrLen(L"LDAP://")) == 0) )
        || ( (text.length() > 8 ) && (_wcsnicmp((WCHAR*)text, L"WinNT://",UStrLen(L"WinNT://")) == 0)) )
      {
         //hmmmm... They are giving use ADsPath. Lets get all the info we can from the object then.
         curr->SetSourcePath((WCHAR*) text);
         HRESULT hr = FillNodeFromPath(curr, &opt, &acctList);

         if (SUCCEEDED(hr))
         {
            // Get the target name if one is specified.
            swprintf(key,GET_STRING(DCTVSFmt_Accounts_TargetName_D),i);
            text = pVarSet->get(key);

            if ( text.length() )
            {
                // if target name is specified then use that.
                curr->SetTargetName((WCHAR*) text);
                curr->SetTargetSam((WCHAR*) text);
            }

            curr->IsFilled = true;
         }
      }
      else
      {
         FillNamingContext(&opt);
         // if this is a computer account, make sure the trailing $ is included in the name
         curr->SetName(text);
         curr->SetTargetName(text);
         if ( !UStrICmp(val,L"computer") )
         {
//            if ( ((WCHAR*)text)[text.length() - 1] != L'$' ) //comment out to fix 89513.
            text += L"$";
         }
         curr->SetSourceSam(text);
         curr->SetTargetSam(text);
         safecopy(acctName,(WCHAR*)text);

         // optional target name
         swprintf(key,GET_STRING(DCTVSFmt_Accounts_TargetName_D),i);
         text = pVarSet->get(key);
      
         if ( text.length() )
            curr->SetTargetName(text);

//         HRESULT hr = pAccess->raw_GetOsVersion(opt.srcComp, &maj, &min, &sp);
         pAccess->raw_GetOsVersion(opt.srcComp, &maj, &min, &sp);
         if ( maj < 5 )
            AddPrefixSuffix(curr,&opt);

         // if this is a computer account, make sure the trailing $ is included in the name
         if ( !UStrICmp(val,L"computer") )
         {
            if ( text.length() && ((WCHAR*)text)[text.length() - 1] != L'$' )
            text += L"$";
         }
         if ( text.length() )
         {
            if ( ((WCHAR*)text)[text.length() - 1] != L'$' )
            text += L"$";
            curr->SetTargetSam(text);
         }
         curr->IsFilled = false;
      }      

      if ( _wcsicmp(val, L"") != 0 )
      {
         acctList.InsertBottom((TNode*)curr);
      }
      else
      {
         err.MsgWrite(ErrW,DCT_MSG_BAD_ACCOUNT_TYPE_SD,curr->GetName(),val);
         Mark(L"warnings",L"generic");
         delete curr;
      }
   }

   return 0;
}


HRESULT 
   CAcctRepl::UpdateUserRights(
      IStatusObj           * pStatus       // in - status object
   )
{
    HRESULT hr = S_OK;

    if (!opt.bSameForest && !opt.bUndo)
    {
        hr = m_pUserRights->OpenSourceServer(_bstr_t(opt.srcComp));

        if (SUCCEEDED(hr))
        {
            hr = m_pUserRights->OpenTargetServer(_bstr_t(opt.tgtComp));
        }

        if (SUCCEEDED(hr))
        {
            m_pUserRights->put_RemoveOldRightsFromTargetAccounts((opt.flags & F_RevokeOldRights) != 0);

            if (acctList.IsTree())
            {
                acctList.ToSorted();
            }

            TNodeListEnum e;

            for (TAcctReplNode* acct = (TAcctReplNode*)e.OpenFirst(&acctList) ; acct; acct = (TAcctReplNode *)e.Next())
            {
                if ( pStatus )
                {
                    LONG                status = 0;
                    HRESULT             hr = pStatus->get_Status(&status);

                    if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                    {
                    if ( !bAbortMessageWritten ) 
                    {
                        err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                        bAbortMessageWritten = true;
                    }
                    break;
                    }
                }

                if (_wcsicmp(acct->GetType(), L"computer") != 0) // only update rights for users and groups, not computer accounts
                {
                    // if the account wasn't created or replaced, don't bother 
                    if (acct->GetStatus() & (AR_Status_Created | AR_Status_Replaced)) 
                    {
                        if ( acct->GetSourceRid() && acct->GetTargetRid() )
                        {
                            _bstr_t strSourceSid = GenerateSidAsString(&opt, FALSE, acct->GetSourceRid());
                            _bstr_t strTargetSid = GenerateSidAsString(&opt, TRUE, acct->GetTargetRid());

                            hr = m_pUserRights->CopyUserRightsWithSids(
                                _bstr_t(acct->GetSourceSam()),
                                strSourceSid,
                                _bstr_t(acct->GetTargetSam()),
                                strTargetSid
                            );
                        }
                        else
                        {
                            hr = m_pUserRights->CopyUserRights(
                                _bstr_t(acct->GetSourceSam()),
                                _bstr_t(acct->GetTargetSam())
                            );
                        }

                        if (SUCCEEDED(hr))
                        {
                            err.MsgWrite(0, DCT_MSG_UPDATED_RIGHTS_S, acct->GetTargetName() );
                            acct->MarkRightsUpdated();
                        }
                        else
                        {
                            err.SysMsgWrite(ErrE, hr, DCT_MSG_UPDATE_RIGHTS_FAILED_SD, acct->GetTargetName(), hr);
                            acct->MarkError();
                            Mark(L"errors", acct->GetType());
                        }
                    }
                }
            }

            e.Close();
        }

        Progress(L"");
    }

    return hr;
}


//---------------------------------------------------------------------------
// EnumerateAccountRights Method
//
// Synopsis
// Enumerate account rights for specified account. The rights are stored in
// the account node object.
//
// Arguments
// IN bTarget - specifies whether to use the target or source account
// IN pAcct   - a pointer to an account node object
//
// Return
// Returns an HRESULT where S_OK indicates success anything else an error.
//---------------------------------------------------------------------------

HRESULT CAcctRepl::EnumerateAccountRights(BOOL bTarget, TAcctReplNode* pAcct)
{
    HRESULT hr;

    //
    // Retrieve the target or source server name and the target or source
    // account RID and generate the account SID as a string.
    //

    _bstr_t strServer = bTarget ? opt.tgtComp : opt.srcComp;
    DWORD dwRid = bTarget ? pAcct->GetTargetRid() : pAcct->GetSourceRid();
    _bstr_t strSid = GenerateSidAsString(&opt, bTarget, dwRid);

    if ((PCWSTR)strServer && (PCWSTR)strSid)
    {
        //
        // If array of user rights currently exists
        // in account node object then destroy array.
        //

        if (pAcct->psaUserRights)
        {
            SafeArrayDestroy(pAcct->psaUserRights);
            pAcct->psaUserRights = NULL;
        }

        //
        // Retrieve array of user rights and save them in account node object.
        //

        hr = m_pUserRights->GetRightsOfUser(strServer, strSid, &pAcct->psaUserRights);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


//---------------------------------------------------------------------------
// AddAccountRights Method
//
// Synopsis
// Add account rights to specified account.
//
// Arguments
// IN bTarget - specifies whether to use the target or source account
// IN pAcct   - a pointer to an account node object
//
// Return
// Returns an HRESULT where S_OK indicates success anything else an error.
//---------------------------------------------------------------------------

HRESULT CAcctRepl::AddAccountRights(BOOL bTarget, TAcctReplNode* pAcct)
{
    HRESULT hr = S_OK;

    if (pAcct->psaUserRights)
    {
        //
        // Retrieve the target or source server name, the target or source account name
        // and the target or source account RID and generate the account SID as a string.
        //

        _bstr_t strServer = bTarget ? opt.tgtComp : opt.srcComp;
        _bstr_t strName = bTarget ? pAcct->GetTargetName() : pAcct->GetName();
        DWORD dwRid = bTarget ? pAcct->GetTargetRid() : pAcct->GetSourceRid();
        _bstr_t strSid = GenerateSidAsString(&opt, bTarget, dwRid);

        if ((PCWSTR)strServer && (PCWSTR)strSid)
        {
            //
            // Add rights to account.
            //

            hr = m_pUserRights->AddUserRights(strServer, strSid, pAcct->psaUserRights);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        //
        // If rights added successfully then generate messages specifying
        // rights granted and that rights were updated for specified account
        // otherwise generate message stating failure of rights update.
        //

        if (SUCCEEDED(hr))
        {
            SAFEARRAY* psaUserRights = pAcct->psaUserRights;
            BSTR* pbstrRight;
            hr = SafeArrayAccessData(psaUserRights, (void**)&pbstrRight);

            if (SUCCEEDED(hr))
            {
                ULONG ulCount = psaUserRights->rgsabound[0].cElements;

                for (ULONG ulIndex = 0; ulIndex < ulCount; ulIndex++)
                {
                    BSTR bstrRight = pbstrRight[ulIndex];
                    err.MsgWrite(0, DCT_MSG_RIGHT_GRANTED_SS, bstrRight, (PCWSTR)strName);
                }

                SafeArrayUnaccessData(psaUserRights);
            }

            err.MsgWrite(0, DCT_MSG_UPDATED_RIGHTS_S, (PCWSTR)strName);
            pAcct->MarkRightsUpdated();
        }
        else
        {
            err.SysMsgWrite(ErrE, hr, DCT_MSG_UPDATE_RIGHTS_FAILED_SD, (PCWSTR)strName, hr);
            pAcct->MarkError();
            Mark(L"errors", pAcct->GetType());
        }
    }

    return hr;
}


//---------------------------------------------------------------------------
// RemoveAccountRights Method
//
// Synopsis
// Remove account rights from specified account.
//
// Arguments
// IN bTarget - specifies whether to use the target or source account
// IN pAcct   - a pointer to an account node object
//
// Return
// Returns an HRESULT where S_OK indicates success anything else an error.
//---------------------------------------------------------------------------

HRESULT CAcctRepl::RemoveAccountRights(BOOL bTarget, TAcctReplNode* pAcct)
{
    HRESULT hr = S_OK;

    if (pAcct->psaUserRights)
    {
        //
        // Retrieve the target or source server name, the target or source account name
        // and the target or source account RID and generate the account SID as a string.
        //

        _bstr_t strServer = bTarget ? opt.tgtComp : opt.srcComp;
        DWORD dwRid = bTarget ? pAcct->GetTargetRid() : pAcct->GetSourceRid();
        _bstr_t strSid = GenerateSidAsString(&opt, bTarget, dwRid);

        if ((LPCTSTR)strServer && (LPCTSTR)strSid)
        {
            //
            // Remove rights from account.
            //

            hr = m_pUserRights->RemoveUserRights(strServer, strSid, pAcct->psaUserRights);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


void 
   CAcctRepl::WriteOptionsToLog()
{
   // This will make it easier to tell if arguments are ignored because they
   // were specified in the wrong format, or misspelled, etc.

   WCHAR                   cmdline[1000];
   
   UStrCpy(cmdline ,GET_STRING(IDS_AccountMigration));
   
   if ( opt.nochange )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_WriteChanges_No));
   }
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   UStrCpy(cmdline + UStrLen(cmdline),opt.srcDomainFlat);
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   UStrCpy(cmdline + UStrLen(cmdline),opt.tgtDomainFlat);
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   if ( opt.flags & F_USERS )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyUsers_Yes));
   }
   else 
   {
      UStrCpy(cmdline + UStrLen(cmdline), GET_STRING(IDS_CopyUsers_No));
   }
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   if ( opt.flags & F_GROUP )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyGlobalGroups_Yes));
   }
   else 
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyGlobalGroups_No));
   }
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   
   if ( opt.flags & F_LGROUP )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyLocalGroups_Yes));
   }
   else 
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyLocalGroups_No));
   }
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   
   if ( opt.flags & F_MACHINE )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyComputers_Yes));
   }
   else 
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyComputers_No));
   }
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   
   if ( opt.flags & F_REPLACE )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_ReplaceExisting_Yes));
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   if ( opt.flags & F_DISABLE_ALL )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_DisableAll_Yes));
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   else if ( opt.flags & F_DISABLE_SPECIAL )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_DisableSpecial_Yes));
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   if ( opt.flags & F_DISABLESOURCE )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_DisableSourceAccounts_Yes));
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   if ( opt.flags & F_STRONGPW_ALL )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_StrongPwd_All));
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   else if ( opt.flags & F_STRONGPW_SPECIAL )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_StrongPwd_Special));
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   if ( *opt.addToGroup )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_AddToGroup));
      UStrCpy(cmdline + UStrLen(cmdline),opt.addToGroup);
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   
   err.MsgWrite(0,DCT_MSG_GENERIC_S,cmdline);
}

void 
   CAcctRepl::LoadResultsToVarSet(
      IVarSet              * pVarSet      // i/o - VarSet 
   )
{
   _bstr_t                   text;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CSVResultFile));
   if ( text.length() )
   {
      CommaDelimitedLog         results;

      if ( results.LogOpen((WCHAR*)text,FALSE) )
      {
         // Write the results to a comma-separated file 
         // as SrcName,TgtName,AccountType,Status, srcRid, tgtRid
         // This file can be used by ST as input.
         TNodeListEnum             e;
         TAcctReplNode           * tnode;

         if ( acctList.IsTree() )
         {
            acctList.ToSorted();
         }
         
         for ( tnode = (TAcctReplNode *)e.OpenFirst(&acctList) ; tnode ; tnode = (TAcctReplNode *)e.Next() )
         {
            results.MsgWrite(L"%s,%s,%lx,%lx,%lx,%lx",tnode->GetName(),tnode->GetTargetSam(), tnode->GetType(),tnode->GetStatus(),tnode->GetSourceRid(),tnode->GetTargetRid());   
         }
         e.Close();
         results.LogClose();
      }
      else
      {
         err.MsgWrite(ErrE,DCT_MSG_FAILED_TO_WRITE_ACCOUNT_STATS_S,text);
         Mark(L"errors", "generic");
      }
   }
   long                     level = pVarSet->get(GET_BSTR(DCTVS_Results_ErrorLevel));
   
   if ( level < err.GetMaxSeverityLevel() )
   {
      pVarSet->put(GET_BSTR(DCTVS_Results_ErrorLevel),(LONG)err.GetMaxSeverityLevel());
   }
}

IADsGroup * GetWellKnownTargetGroup(long groupID,Options * pOptions)
{
   IADsGroup         * pGroup = NULL;
   HRESULT             hr;
   PSID                pSid;
   WCHAR               strSid[LEN_Path];
   WCHAR               sPath[LEN_Path];
   CLdapConnection     c;

   // Get the SID for the Domain Computers group
   
   pSid = GetWellKnownSid(groupID,pOptions,TRUE);
   if ( pSid )
   {
      c.BytesToString((LPBYTE)pSid,strSid,GetLengthSid(pSid));

      swprintf(sPath,L"LDAP://%ls/<SID=%ls>",pOptions->tgtDomain,strSid);
      
      hr = ADsGetObject(sPath,IID_IADsGroup,(void**)&pGroup);
      FreeSid(pSid);
   }

   return pGroup;
}

void PadCnName(WCHAR * sTarget)
{
    if (sTarget == NULL)
        _com_issue_error(E_INVALIDARG);

    // escape character
    const WCHAR ESCAPE_CHARACTER = L'\\';
    // characters that need escaping for RDN format
    static WCHAR SPECIAL_CHARACTERS[] = L"\"#+,;<=>\\";

    // copy old name
    WCHAR szOldName[LEN_Path];
    DWORD dwArraySizeOfszOldName = sizeof(szOldName)/sizeof(szOldName[0]);
    if (wcslen(sTarget) >= dwArraySizeOfszOldName)
        _com_issue_error(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    wcscpy(szOldName, sTarget);

    WCHAR* pchNew = sTarget;

    // for each character in old name...

    for (WCHAR* pchOld = szOldName; *pchOld; pchOld++)
    {
        // if special character...

        if (wcschr(SPECIAL_CHARACTERS, *pchOld))
        {
            // then add escape character
            *pchNew++ = ESCAPE_CHARACTER;
        }

        // add character
        *pchNew++ = *pchOld;
    }

    // null terminate new name
    *pchNew = L'\0';
}

//------------------------------------------------------------------------------
// Create2KObj: Creates a Win2K object. This code uses LDAP to create a new
//              object of specified type in the specified container.
//              If any information is incorrect or If there are any access
//              problems then it simply returns the Failed HRESULT.
//------------------------------------------------------------------------------
HRESULT CAcctRepl::Create2KObj(
                                 TAcctReplNode           * pAcct,       //in -TNode with account information
                                 Options                 * pOptions,    //in -Options set by the user.
                                 CTargetPathSet&           setTargetPath
                              )
{
   // This function creates a Win2K object.
   IADsPtr                   pAdsSrc;
   IADsPtr                   pAds;
   c_array<WCHAR>            achAdsPath(LEN_Path);
   DWORD                     nPathLen = LEN_Path;
   c_array<WCHAR>            achSubPath(LEN_Path);
   _bstr_t                   strClass;
   HRESULT                   hr;
   c_array<WCHAR>            achTarget(LEN_Path);
   _variant_t                varT;
   _bstr_t                   strName;
   IADsContainerPtr          pCont;
   IDispatchPtr              pDisp;
   c_array<WCHAR>            achPref(LEN_Path);
   c_array<WCHAR>            achSuf(LEN_Path);

   // Get the name of the class for the source object so we can use that to create the new object.
   strClass = pAcct->GetType();

   if (!strClass)
   {
       return E_FAIL;
   }

   // check if the sourceAdsPath, for LDAP paths only, is correct before creating this object on the target.  If not fail now.
   if (!wcsncmp(L"LDAP://", pAcct->GetSourcePath(), 7))
   {
      wcsncpy(achAdsPath, pAcct->GetSourcePath(), nPathLen-1);
      hr = ADsGetObject(achAdsPath, IID_IADs, (void**)&pAdsSrc);
      if (FAILED(hr))
      {
         err.SysMsgWrite(ErrE,hr, DCT_MSG_LDAP_CALL_FAILED_SD, (WCHAR*)achAdsPath, hr);
         Mark(L"errors", pAcct->GetType());
         return hr;
      }
   }

   // Now that we have the classname we can go ahead and create an object in the target domain.
   // First we need to get IAdsContainer * to the domain.
   wcscpy(achSubPath, pOptions->tgtOUPath);
   
   if ( !wcsncmp(L"LDAP://", achSubPath, 7) )
      StuffComputerNameinLdapPath(achAdsPath, nPathLen, achSubPath, pOptions);
   else
      MakeFullyQualifiedAdsPath(achAdsPath, nPathLen, achSubPath, pOptions->tgtComp, pOptions->tgtNamingContext);

   hr = ADsGetObject(achAdsPath, IID_IADsContainer, (void**)&pCont);
   if ( FAILED(hr) )
   {
      if ( firstTime ) 
      {
         err.SysMsgWrite(ErrE,hr,DCT_MSG_CONTAINER_NOT_FOUND_SSD, pOptions->tgtOUPath, pOptions->tgtDomain, hr);
         firstTime = false;
         Mark(L"errors", pAcct->GetType());
      }
      if ( _wcsicmp(strClass, L"computer") == 0 )
      {
         MakeFullyQualifiedAdsPath(achAdsPath, nPathLen, L"CN=Computers", pOptions->tgtDomain, pOptions->tgtNamingContext);
         hr = ADsGetObject(achAdsPath, IID_IADsContainer, (void**)&pCont);
      }
      else
      {
         MakeFullyQualifiedAdsPath(achAdsPath, nPathLen, L"CN=Users", pOptions->tgtDomain, pOptions->tgtNamingContext);
         hr = ADsGetObject(achAdsPath, IID_IADsContainer, (void**)&pCont);
      }
      if ( FAILED(hr) ) 
      {
         err.SysMsgWrite(ErrE, hr, DCT_MSG_DEFAULT_CONTAINER_NOT_FOUND_SD, (WCHAR*)achAdsPath, hr);
         Mark(L"errors", pAcct->GetType());
         return (hr);
      }
   }

   // Call the create method on the container.
   wcscpy(achTarget, pAcct->GetTargetName());

   // In case of the NT4 source domain the source and the target name have no CN= so we need
   // to add this to the target name.  The target name from the group mapping wizard also needs a "CN="
   // added to the target name.
   if ((pOptions->srcDomainVer < 5) || (!_wcsicmp(strClass, L"computer")) || (!_wcsicmp((WCHAR*)pOptions->sWizard, L"groupmapping")))
   {
      c_array<WCHAR> achTemp(LEN_Path);
      wcscpy(achTemp, pAcct->GetTargetName());
      PadCnName(achTemp);
      // if the CN part is not there add it.
      if ( _wcsicmp(strClass, L"organizationalUnit") == 0 )
         wsprintf(achTarget, L"OU=%s", (WCHAR*)achTemp);
      else
         wsprintf(achTarget, L"CN=%s", (WCHAR*)achTemp);
      pAcct->SetTargetName(achTarget);
   }

   // we need to truncate CN name to less that 64 characters
   for ( DWORD z = 0; z < wcslen(achTarget); z++ )
   {
      if ( achTarget[z] == L'=' ) break;
   }
   
   if ( z < wcslen(achTarget) )
   {
      // Get the prefix part ex.CN=
      wcsncpy(achPref, achTarget, z+1);
      achPref[z+1] = 0;
      wcscpy(achSuf, achTarget+z+1);
   }

   // The CN for the account could be greater than 64 we need to truncate it.
   c_array<WCHAR> achTempCn(LEN_Path);

   // if class is inetOrgPerson...

   if (_wcsicmp(strClass, s_ClassInetOrgPerson) == 0)
   {
      // retrieve naming attribute

      SNamingAttribute naNamingAttribute;

      if (SUCCEEDED(GetNamingAttribute(pOptions->tgtDomainDns, s_ClassInetOrgPerson, naNamingAttribute)))
      {
         if (long(wcslen(achSuf)) > naNamingAttribute.nMaxRange)
         {
            err.MsgWrite(ErrE, DCT_MSG_RDN_LENGTH_GREATER_THAN_MAX_RANGE_S, pAcct->GetTargetName());
            Mark(L"errors", pAcct->GetType());
            return HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION);
         }
      }

      wcscpy(achTempCn, achSuf);
   }
   else if ( wcslen(achSuf) > 64 )
   {
      if ( wcslen(pOptions->globalSuffix) )
      {
         // in case of a global suffix we need to remove the suffix and then truncate the account and then readd the suffix.
         achSuf[wcslen(achSuf) - wcslen(pOptions->globalSuffix)] = L'\0';
      }
      int truncate = 64 - wcslen(pOptions->globalSuffix);
      wcsncpy(achTempCn, achSuf, truncate);
      achTempCn[truncate] = L'\0';
      if (wcslen(pOptions->globalSuffix))
         wcscat(achTempCn, pOptions->globalSuffix);
      err.MsgWrite(1, DCT_MSG_TRUNCATE_CN_SS, pAcct->GetTargetName(), (WCHAR*)achTempCn);
   }
   else
      wcscpy(achTempCn, achSuf);

   wsprintf(achTarget, L"%s%s", (WCHAR*)achPref, (WCHAR*)achTempCn);
   pAcct->SetTargetName(achTarget);

   // even for a local group the object type of the group has to be a local group
   if ( !_wcsicmp(strClass, L"lgroup") )
   {
      strClass = L"group";
   }

   // Call the create method on the container.
   wcscpy(achTarget, pAcct->GetTargetName());
   hr = pCont->Create(strClass, _bstr_t(achTarget), &pDisp);
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrE, hr,DCT_MSG_CREATE_FAILED_SSD, pAcct->GetTargetName(), pOptions->tgtOUPath, hr);
      Mark(L"errors", pAcct->GetType());
      return hr;
   }
   // Get the IADs interface to get the path to newly created object.
   pAds = pDisp;
   if ( pAds == NULL )
   {
      err.SysMsgWrite(ErrE, hr, DCT_MSG_GET_IADS_FAILED_SSD, pAcct->GetTargetName(), pOptions->tgtOUPath, E_NOINTERFACE);
      Mark(L"errors", pAcct->GetType());
      return hr;
   }

   // if object class is inetOrgPerson and the naming attribute is not cn then...

   if ((_wcsicmp(strClass, s_ClassInetOrgPerson) == 0) && (_wcsicmp(achPref, L"cn=") != 0))
   {
      // retrieve the source cn attribute and set the target cn attribute
      // the cn attribute is a mandatory attribute and therefore
      // must be set before attempting to create the object

      _bstr_t strCN(L"cn");
      VARIANT var;
      VariantInit(&var);

      hr = pAdsSrc->Get(strCN, &var);

      if (SUCCEEDED(hr))
      {
         pAds->Put(strCN, var);
         VariantClear(&var);
      }
   }

   // Set the Target Account Sam name if not an OU.
   wstring strTargetSam = pAcct->GetTargetSam();

   // check if the $ is at the end of the SAM name for computer accounts.
   if ( !_wcsicmp(strClass, L"computer") )
   {
      // also make sure the target SAM name is not too long
      if ( strTargetSam.length() > MAX_COMPUTERNAME_LENGTH + 1 )
      {
         strTargetSam[MAX_COMPUTERNAME_LENGTH] = 0;
      }
      if (strTargetSam[strTargetSam.length()-1] != L'$')
      {
         strTargetSam += L"$";
         pAcct->SetTargetSam(strTargetSam.c_str());
      }
   }

   varT = strTargetSam.c_str();

   if ( _wcsicmp(strClass, L"organizationalUnit") != 0)
      // organizational unit has no sam account name
      hr = pAds->Put(L"sAMAccountName", varT);

   if ( _wcsicmp(strClass, L"group") == 0 )
   {
      varT = _variant_t(pAcct->GetGroupType());
      if ( pOptions->srcDomainVer < 5 )
      {
         // all NT4 accounts are security accounts but they tell us that they are Dist accts so lets set them straight.
         varT.lVal |= 0x80000000;
      }
      hr = pAds->Put(L"groupType", varT);
   }
   else if ((_wcsicmp(strClass, s_ClassUser) == 0) || (_wcsicmp(strClass, s_ClassInetOrgPerson) == 0))
   {
      if (pAdsSrc == NULL)
      {
         ADsGetObject(const_cast<WCHAR*>(pAcct->GetSourcePath()), IID_IADs, (void**)&pAdsSrc);
      }

      if (pAdsSrc)
      {
         // Get the source profile path and store it in the path
         _variant_t  var;

         // Don't know why it is different for WinNT to ADSI
         if ( pOptions->srcDomainVer > 4 )
            hr = pAdsSrc->Get(L"profilePath", &var);
         else
            hr = pAdsSrc->Get(L"profile", &var);

         if ( SUCCEEDED(hr))
         {
            pAcct->SetSourceProfile((WCHAR*) V_BSTR(&var));
         }
      }
   }

   // In no change mode we do not call the set info.
   if ( !pOptions->nochange )
   {
      hr = pAds->SetInfo();
      if ( FAILED(hr) )
      {
           if (HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS) 
           {
            //
            // check if object DN is conflicting with
            // another object that is currently being migrated
            //

            BSTR bstrPath = 0;

            if (SUCCEEDED(pAds->get_ADsPath(&bstrPath)))
            {
               pAcct->SetTargetPath(_bstr_t(bstrPath, false));

               if (DoTargetPathConflict(setTargetPath, pAcct))
               {
                  return hr;
               }
            }

            if ( wcslen(pOptions->prefix) > 0 )
            {
               c_array<WCHAR> achTgt(LEN_Path);
               c_array<WCHAR> achTempSam(LEN_Path);
               _variant_t varStr;

               // Here I am adding a prefix and then lets see if we can setinfo that way
               // find the '=' sign
               wcscpy(achTgt, pAcct->GetTargetName());
               for ( DWORD z = 0; z < wcslen(achTgt); z++ )
               {
                  if ( achTgt[z] == L'=' ) break;
               }
               
               if ( z < wcslen(achTgt) )
               {
                  // Get the prefix part ex.CN=
                  wcsncpy(achPref, achTgt, z+1);
                  achPref[z+1] = 0;
                  wcscpy(achSuf, achTgt+z+1);
               }

               // The CN for the account could be greater than 64 we need to truncate it.

               // if class is inetOrgPerson...

               if (_wcsicmp(strClass, s_ClassInetOrgPerson) == 0)
               {
                  SNamingAttribute naNamingAttribute;

                  if (SUCCEEDED(GetNamingAttribute(pOptions->tgtDomainDns, s_ClassInetOrgPerson, naNamingAttribute)))
                  {
                     if (long(wcslen(achSuf) + wcslen(pOptions->prefix)) > naNamingAttribute.nMaxRange)
                     {
                        wsprintf(achTgt, L"%s%s%s", (WCHAR*)achPref, pOptions->prefix, (WCHAR*)achSuf);
                        err.MsgWrite(ErrE, DCT_MSG_RDN_LENGTH_GREATER_THAN_MAX_RANGE_S, (WCHAR*)achTgt);
                        Mark(L"errors", pAcct->GetType());
                        return HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION);
                     }
                  }

                  wcscpy(achTempCn, achSuf);
               }
               else if ( wcslen(achSuf) + wcslen(pOptions->prefix) > 64 )
               {
                  int truncate = 64 - wcslen(pOptions->prefix);
                  wcsncpy(achTempCn, achSuf, truncate);
                  achTempCn[truncate] = L'\0';
                  err.MsgWrite(1, DCT_MSG_TRUNCATE_CN_SS, pAcct->GetTargetName(), (WCHAR*)achTempCn);
               }
               else
                  wcscpy(achTempCn, achSuf);
               
               // Remove the \ if it is escaping the space
               if ( achTempCn[0] == L'\\' && achTempCn[1] == L' ' )
               {
                  wstring str = achTempCn + 1;
                  wcscpy(achTempCn, str.c_str());
               }
               // Build the target string with the Prefix
               wsprintf(achTgt, L"%s%s%s", (WCHAR*)achPref, pOptions->prefix, (WCHAR*)achTempCn);

               pAcct->SetTargetName(achTgt);

               // Create the object in the container
               hr = pCont->Create(strClass, _bstr_t(achTgt), &pDisp);
               if ( FAILED(hr) )
               {
                  err.SysMsgWrite(ErrE, hr,DCT_MSG_CREATE_FAILED_SSD, pAcct->GetTargetName(), pOptions->tgtOUPath, hr);
                  Mark(L"errors", pAcct->GetType());
                  return hr;
               }
               // Get the IADs interface to get the path to newly created object.
               hr = pDisp->QueryInterface(IID_IADs, (void**)&pAds);
               if ( FAILED(hr) )
               {
                  err.SysMsgWrite(ErrE, hr, DCT_MSG_GET_IADS_FAILED_SSD, pAcct->GetTargetName(), pOptions->tgtOUPath, hr);
                  Mark(L"errors", pAcct->GetType());
                  return hr;
               }

               // if object class is inetOrgPerson and the naming attribute is not cn then...

               if ((_wcsicmp(strClass, s_ClassInetOrgPerson) == 0) && (_wcsicmp(achPref, L"cn=") != 0))
               {
                  // retrieve the source cn attribute and set the target cn attribute
                  // the cn attribute is a mandatory attribute and therefore
                  // must be set before attempting to create the object

                  _bstr_t strCN(L"cn");
                  VARIANT var;
                  VariantInit(&var);

                  hr = pAdsSrc->Get(strCN, &var);

                  if (SUCCEEDED(hr))
                  {
                     pAds->Put(strCN, var);
                     VariantClear(&var);
                  }
               }

               // truncate to allow prefix/suffix to fit in 20 characters.
               int resLen = wcslen(pOptions->prefix) + wcslen(pAcct->GetTargetSam());
               if ( !_wcsicmp(pAcct->GetType(), L"computer") )
               {
                  // Computer name can be only 15 characters long + $
                  if ( resLen > MAX_COMPUTERNAME_LENGTH + 1 )
                  {
                     c_array<WCHAR> achTruncatedSam(LEN_Path);
                     wcscpy(achTruncatedSam, pAcct->GetTargetSam());
                     if ( wcslen( pOptions->globalSuffix ) )
                     {
                        // We must remove the global suffix if we had one.
                        achTruncatedSam[wcslen(achTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                     }

                     int truncate = MAX_COMPUTERNAME_LENGTH + 1 - wcslen(pOptions->prefix) - wcslen(pOptions->globalSuffix);
                     if ( truncate < 1 ) truncate = 1;
                     wcsncpy(achTempSam, achTruncatedSam, truncate - 1);
                     achTempSam[truncate-1] = L'\0';              // Dont forget the $ sign and terminate string.
                     wcscat(achTempSam, pOptions->globalSuffix);
                     wcscat(achTempSam, L"$");
                  }
                  else
                     wcscpy(achTempSam, pAcct->GetTargetSam());

                  // Add the prefix
                  wsprintf(achTgt, L"%s%s", pOptions->prefix,(WCHAR*)achTempSam);
               }
               else if ((_wcsicmp(pAcct->GetType(), s_ClassUser) == 0) || (_wcsicmp(pAcct->GetType(), s_ClassInetOrgPerson) == 0))
               {
                  if ( resLen > 20 )
                  {
                     c_array<WCHAR> achTruncatedSam(LEN_Path);
                     wcscpy(achTruncatedSam, pAcct->GetTargetSam());
                     if ( wcslen( pOptions->globalSuffix ) )
                     {
                        // We must remove the global suffix if we had one.
                        achTruncatedSam[wcslen(achTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                     }
                     int truncate = 20 - wcslen(pOptions->prefix) - wcslen(pOptions->globalSuffix);
                     if ( truncate < 0 ) truncate = 0;
                     wcsncpy(achTempSam, achTruncatedSam, truncate);
                     achTempSam[truncate] = L'\0';
                     wcscat(achTempSam, pOptions->globalSuffix);
                  }
                  else
                     wcscpy(achTempSam, pAcct->GetTargetSam());

                  // Add the prefix
                  wsprintf(achTgt, L"%s%s", pOptions->prefix, (WCHAR*)achTempSam);
               }
               else
                  wsprintf(achTgt, L"%s%s", pOptions->prefix,pAcct->GetTargetSam());

               pAcct->SetTargetSam(achTgt);
               varStr = achTgt;
               pAds->Put(L"sAMAccountName", varStr);
               if ( _wcsicmp(strClass, L"group") == 0 )
               {
                  varT = _variant_t(pAcct->GetGroupType());
                  if ( pOptions->srcDomainVer < 5 )
                  {
                     // all NT4 accounts are security accounts but they tell us that they are Dist accts so lets set them straight.
                     varT.lVal |= 0x80000000;
                  }
                  hr = pAds->Put(L"groupType", varT);
               }
               hr = pAds->SetInfo();
               if ( SUCCEEDED(hr) )
               {
                      Mark(L"created", strClass);
                      pAcct->MarkCreated();
                      BSTR sTgtPath = 0;
                      HRESULT temphr = pAds->get_ADsPath(&sTgtPath);
                      if ( SUCCEEDED(temphr) )
                      {
                         pAcct->SetTargetPath(_bstr_t(sTgtPath, false));
                         setTargetPath.insert(pAcct);
                      }
                      else
                         pAcct->SetTargetPath(L"");
               }
               else if ( HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS )
               {
                  //
                  // check if object DN is conflicting with
                  // another object that is currently being migrated
                  //

                  BSTR bstrPath = 0;

                  if (SUCCEEDED(pAds->get_ADsPath(&bstrPath)))
                  {
                      pAcct->SetTargetPath(_bstr_t(bstrPath, false));

                      if (DoTargetPathConflict(setTargetPath, pAcct))
                      {
                         return hr;
                      }
                  }

                  pAcct->MarkAlreadyThere();
                  err.MsgWrite(ErrE, DCT_MSG_PREF_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
                  Mark(L"errors",pAcct->GetType());
               }
               else
               {
                     pAcct->MarkError();
                  err.SysMsgWrite(ErrE, hr, DCT_MSG_CREATE_FAILED_SSD, pAcct->GetTargetSam(), pOptions->tgtOUPath, hr);
                  Mark(L"errors",pAcct->GetType());
               }
            }
               else if ( wcslen(pOptions->suffix) > 0 )
               {
               c_array<WCHAR> achTgt(LEN_Path);
               c_array<WCHAR> achTempSam(LEN_Path);
               _variant_t varStr;
               
               wcscpy(achTgt, pAcct->GetTargetName());
               for ( DWORD z = 0; z < wcslen(achTgt); z++ )
               {
                  if ( achTgt[z] == L'=' ) break;
               }
               
               if ( z < wcslen(achTgt) )
               {
                  // Get the prefix part ex.CN=
                  wcsncpy(achPref, achTgt, z+1);
                  achPref[z+1] = 0;
                  wcscpy(achSuf, achTgt+z+1);
               }

               // The CN for the account could be greater than 64 we need to truncate it.

               // if class is inetOrgPerson...

               if (_wcsicmp(strClass, s_ClassInetOrgPerson) == 0)
               {
                  SNamingAttribute naNamingAttribute;

                  if (SUCCEEDED(GetNamingAttribute(pOptions->tgtDomainDns, s_ClassInetOrgPerson, naNamingAttribute)))
                  {
                     if (long(wcslen(achSuf) + wcslen(pOptions->suffix)) > naNamingAttribute.nMaxRange)
                     {
                        wsprintf(achTgt, L"%s%s%s", (WCHAR*)achPref, (WCHAR*)achSuf, pOptions->suffix);
                        err.MsgWrite(ErrE, DCT_MSG_RDN_LENGTH_GREATER_THAN_MAX_RANGE_S, (WCHAR*)achTgt);
                        Mark(L"errors", pAcct->GetType());
                        return HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION);
                     }
                  }

                  wcscpy(achTempCn, achSuf);
               }
               else if ( wcslen(achSuf) + wcslen(pOptions->suffix) + wcslen(pOptions->globalSuffix) > 64 )
               {
                  if ( wcslen(pOptions->globalSuffix) )
                  {
                     // in case of a global suffix we need to remove the suffix and then truncate the account and then readd the suffix.
                     achSuf[wcslen(achSuf) - wcslen(pOptions->globalSuffix)] = L'\0';
                  }
                  int truncate = 64 - wcslen(pOptions->suffix) - wcslen(pOptions->globalSuffix); 
                  wcsncpy(achTempCn, achSuf, truncate);
                  achTempCn[truncate] = L'\0';
                  wcscat(achTempCn, pOptions->globalSuffix);
                  err.MsgWrite(1, DCT_MSG_TRUNCATE_CN_SS, pAcct->GetTargetName(), (WCHAR*)achSuf);
               }
               else
                  wcscpy(achTempCn, achSuf);

               // Remove the trailing space \ escape sequence
               wcscpy(achTgt, achTempCn);
               for ( int i = wcslen(achTgt)-1; i >= 0; i-- )
               {
                  if ( achTgt[i] != L' ' )
                     break;
               }

               if ( achTgt[i] == L'\\' )
               {
                  WCHAR * pTemp = &achTgt[i];
                  *pTemp = 0;
                  wcscat(achPref, achTgt);
                  wcscpy(achSuf, pTemp+1);
               }
               else
               {
                  wcscat(achPref, achTgt);
                  wcscpy(achSuf, L"");
               }
               wsprintf(achTgt, L"%s%s%s", (WCHAR*)achPref, (WCHAR*)achSuf, pOptions->suffix);
               pAcct->SetTargetName(achTgt);

               // Create the object in the container
               hr = pCont->Create(strClass, _bstr_t(achTgt), &pDisp);
               if ( FAILED(hr) )
               {
                  err.SysMsgWrite(ErrE, hr,DCT_MSG_CREATE_FAILED_SSD, pAcct->GetTargetName(), pOptions->tgtOUPath, hr);
                  Mark(L"errors", pAcct->GetType());
                  return hr;
               }
               // Get the IADs interface to get the path to newly created object.
               hr = pDisp->QueryInterface(IID_IADs, (void**)&pAds);
               if ( FAILED(hr) )
               {
                  err.SysMsgWrite(ErrE, hr, DCT_MSG_GET_IADS_FAILED_SSD, pAcct->GetTargetName(), pOptions->tgtOUPath, hr);
                  Mark(L"errors", pAcct->GetType());
                  return hr;
               }

               // if object class is inetOrgPerson and the naming attribute is not cn then...

               if ((_wcsicmp(strClass, s_ClassInetOrgPerson) == 0) && (_wcsicmp(achPref, L"cn=") != 0))
               {
                  // retrieve the source cn attribute and set the target cn attribute
                  // the cn attribute is a mandatory attribute and therefore
                  // must be set before attempting to create the object

                  _bstr_t strCN(L"cn");
                  VARIANT var;
                  VariantInit(&var);

                  hr = pAdsSrc->Get(strCN, &var);

                  if (SUCCEEDED(hr))
                  {
                     pAds->Put(strCN, var);
                     VariantClear(&var);
                  }
               }

               // truncate to allow prefix/suffix to fit in valid length
               int resLen = wcslen(pOptions->suffix) + wcslen(pAcct->GetTargetSam());
               if ( !_wcsicmp(pAcct->GetType(), L"computer") )
               {
                  // Computer name can be only 15 characters long + $
                  if ( resLen > MAX_COMPUTERNAME_LENGTH + 1 )
                  {
                     c_array<WCHAR> achTruncatedSam(LEN_Path);
                     wcscpy(achTruncatedSam, pAcct->GetTargetSam());
                     if ( wcslen( pOptions->globalSuffix ) )
                     {
                        // We must remove the global suffix if we had one.
                        achTruncatedSam[wcslen(achTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                     }
                     int truncate = MAX_COMPUTERNAME_LENGTH + 1 - wcslen(pOptions->suffix) - wcslen(pOptions->globalSuffix);
                     if ( truncate < 1 ) truncate = 1;
                     wcsncpy(achTempSam, achTruncatedSam, truncate - 1);
                     achTempSam[truncate-1] = L'\0';
                     // Re add the global suffix after the truncation.
                     wcscat(achTempSam, pOptions->globalSuffix);
                     wcscat(achTempSam, L"$");
                  }
                  else
                     wcscpy(achTempSam, pAcct->GetTargetSam());

                  // Add the suffix taking into account the $ sign
                  if ( achTempSam[wcslen(achTempSam) - 1] == L'$' )
                     achTempSam[wcslen(achTempSam) - 1] = L'\0';
                  wsprintf(achTgt, L"%s%s$", (WCHAR*)achTempSam, pOptions->suffix);
               }
               else if ((_wcsicmp(pAcct->GetType(), s_ClassUser) == 0) || (_wcsicmp(pAcct->GetType(), s_ClassInetOrgPerson) == 0))
               {
                  if ( resLen > 20 )
                  {
                     c_array<WCHAR> achTruncatedSam(LEN_Path);
                     wcscpy(achTruncatedSam, pAcct->GetTargetSam());
                     if ( wcslen( pOptions->globalSuffix ) )
                     {
                        // We must remove the global suffix if we had one.
                        achTruncatedSam[wcslen(achTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                     }
                     int truncate = 20 - wcslen(pOptions->suffix) - wcslen(pOptions->globalSuffix);
                     if ( truncate < 0 ) truncate = 0;
                     wcsncpy(achTempSam, achTruncatedSam, truncate);
                     achTempSam[truncate] = L'\0';
                     wcscat(achTempSam, pOptions->globalSuffix);
                  }
                  else
                     wcscpy(achTempSam, pAcct->GetTargetSam());

                  // Add the suffix.
                  wsprintf(achTgt, L"%s%s", (WCHAR*)achTempSam, pOptions->suffix);
               }
               else
                  wsprintf(achTgt, L"%s%s", pAcct->GetTargetSam(), pOptions->suffix);

               pAcct->SetTargetSam(achTgt);
               varStr = achTgt;

               pAds->Put(L"sAMAccountName", varStr);
               if ( _wcsicmp(strClass, L"group") == 0 )
               {
                  varT = _variant_t(pAcct->GetGroupType());
                  if ( pOptions->srcDomainVer < 5 )
                  {
                     // all NT4 accounts are security accounts but they tell us that they are Dist accts so lets set them straight.
                     varT.lVal |= 0x80000000;
                  }
                  hr = pAds->Put(L"groupType", varT);
               }
               hr = pAds->SetInfo();
               if ( SUCCEEDED(hr) )
               {
                      Mark(L"created", strClass);
                      pAcct->MarkCreated();
                      BSTR sTgtPath = 0;
                      HRESULT temphr = pAds->get_ADsPath(&sTgtPath);
                      if ( SUCCEEDED(temphr) )
                      {
                         pAcct->SetTargetPath(_bstr_t(sTgtPath, false));
                         setTargetPath.insert(pAcct);
                      }
                      else
                         pAcct->SetTargetPath(L"");
               }
               else if ( HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS )
               {
                  //
                  // check if object DN is conflicting with
                  // another object that is currently being migrated
                  //

                  BSTR bstrPath = 0;

                  if (SUCCEEDED(pAds->get_ADsPath(&bstrPath)))
                  {
                      pAcct->SetTargetPath(_bstr_t(bstrPath, false));

                      if (DoTargetPathConflict(setTargetPath, pAcct))
                      {
                         return hr;
                      }
                  }

                  pAcct->MarkAlreadyThere();
                  err.MsgWrite(ErrE, DCT_MSG_PREF_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
                  Mark(L"errors",pAcct->GetType());
               }
               else
               {
                     pAcct->MarkError();
                  err.SysMsgWrite(ErrE, hr, DCT_MSG_CREATE_FAILED_SSD, pAcct->GetTargetSam(), pOptions->tgtOUPath, hr);
                  Mark(L"errors",pAcct->GetType());
               }
            }
            else
            {
               if (pOptions->flags & F_REPLACE)
               {
                  c_array<WCHAR>            achPath9(LEN_Path);
                  SAFEARRAY               * pszColNames = NULL;
                  BSTR     HUGEP          * pData;
                  LPWSTR                    sData[] = { L"ADsPath", L"profilePath", L"objectClass" };
                  INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
                  IEnumVARIANT            * pEnumMem = NULL;
                  _variant_t                var;
                  DWORD                     dwFetch;
                  HRESULT                   temphr;
                  int                       nElt = DIM(sData);
                  SAFEARRAYBOUND            bd = { nElt, 0 };
                  BOOL                      bIsCritical = FALSE;
                  BOOL                      bIsDifferentType = FALSE;

                     // Since the object already exists we need to get the ADsPath to the object and update the acct structure
                     // Set up the query and the path
                  wstring strPath = L"LDAP://";
                  strPath += pOptions->tgtComp+2;
                  strPath += L"/";
                  strPath += pOptions->tgtNamingContext;
                  wstring sTempSamName = pAcct->GetTargetSam();
                  if ( sTempSamName[0] == L' ' )
                  {
                     sTempSamName = L"\\20" + sTempSamName.substr(1);
                  }
                  wstring sQuery = L"(sAMAccountName=" + sTempSamName + L")";

                     temphr = pQuery->raw_SetQuery(_bstr_t(strPath.c_str()), _bstr_t(pOptions->tgtDomainDns), _bstr_t(sQuery.c_str()), ADS_SCOPE_SUBTREE, FALSE);
                     if ( FAILED(temphr) )
                  {
                     return temphr;
                  }

                     // Set up the columns so we get the ADsPath of the object.
                     pszColNames = ::SafeArrayCreate(VT_BSTR, 1, &bd);
                     temphr = ::SafeArrayAccessData(pszColNames, (void HUGEP **)&pData);
                     if ( FAILED(temphr) )
                  {
                     SafeArrayDestroy(pszColNames);
                     return temphr;
                  }
                     for ( long i = 0; i < nElt; i++ )
                     {
                        pData[i] = SysAllocString(sData[i]);
                     }
                     temphr = ::SafeArrayUnaccessData(pszColNames);
                     if ( FAILED(temphr) )
                  {
                     ::SafeArrayDestroy(pszColNames);
                     return temphr;
                  }
                     temphr = pQuery->raw_SetColumns(pszColNames);
                     if ( FAILED(temphr) )
                  {
                     ::SafeArrayDestroy(pszColNames);
                     return temphr;
                  }
                  // Time to execute the plan.
                     temphr = pQuery->raw_Execute(&pEnumMem);
                     if ( FAILED(temphr) )
                  {
                     ::SafeArrayDestroy(pszColNames);
                     return temphr;
                  }
                  ::SafeArrayDestroy(pszColNames);
                  temphr = pEnumMem->Next(1, &var, &dwFetch);
                  if ( temphr == S_OK )
                  {
                     // This would only happen if the member existed in the target domain.
                     // We now have a Variant containing an array of variants so we access the data
                    _variant_t    * pVar;
                    _bstr_t         sConfName = pAcct->GetTargetName();
                    _bstr_t         sOldCont;
                    pszColNames = V_ARRAY(&var);
                    SafeArrayAccessData(pszColNames, (void HUGEP **)&pVar);
                    wcscpy(achAdsPath, (WCHAR*)pVar[0].bstrVal);
                    pAcct->SetTargetPath(achAdsPath);

                    // Check if the object we are about to replace is of the same type.
                    if ( _wcsicmp(pAcct->GetType(), (WCHAR*) pVar[2].bstrVal) )
                       bIsDifferentType = TRUE;

                    SafeArrayUnaccessData(pszColNames);
                    
                    IADsPtr pAdsNew;
                    temphr = ADsGetObject(const_cast<WCHAR*>(pAcct->GetTargetPath()), IID_IADs, (void**)&pAdsNew);
                    if ( SUCCEEDED(temphr) )
                    {
                          //see if critical
                       _variant_t   varCritical;
                       temphr = pAdsNew->Get(L"isCriticalSystemObject", &varCritical);
                       if (SUCCEEDED(temphr))
                       {
                           bIsCritical = V_BOOL(&varCritical) == -1 ? TRUE : FALSE;
                       }
                          //get the name
                       BSTR  sTgtName = NULL;
                       temphr = pAdsNew->get_Name(&sTgtName);
                       if ( SUCCEEDED(temphr) )
                          sConfName = _bstr_t(sTgtName, false);

                          //get the parent container of the conflicting object
                       BSTR  sTgtCont = NULL;
                       temphr = pAdsNew->get_Parent(&sTgtCont);
                       if ( SUCCEEDED(temphr) )
                          sOldCont = _bstr_t(sTgtCont, false);
                    }

                    if ( bIsDifferentType )
                    {
                       // Since the source and target accounts are of different types we do not want to replace these.
                       hr = HRESULT_FROM_WIN32(ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH);
                    }
                       //else if not critical then move the account
                    else if ( !bIsCritical )
                    {
                          //if user selected to move that account into the user-specified OU, then move it
                       if (pOptions->flags & F_MOVE_REPLACED_ACCT)
                       {
                          temphr = pCont->MoveHere(const_cast<WCHAR*>(pAcct->GetTargetPath()), const_cast<WCHAR*>(pAcct->GetTargetName()), &pDisp);
                             //if move failed due to CN conflict, do not migrate
                          if ( FAILED(temphr) ) 
                          {
                             // Retrieve distinguished names of object and container from path.

                             CADsPathName pathname;
                             pathname.Set(pAcct->GetTargetPath(), ADS_SETTYPE_FULL);
                             _bstr_t strObjectPath = pathname.Retrieve(ADS_FORMAT_X500_DN);
                             pathname.Set(pOptions->tgtOUPath, ADS_SETTYPE_FULL);
                             _bstr_t strContainerPath = pathname.Retrieve(ADS_FORMAT_X500_DN);

                             // Log error and mark account so that no further operations are
                             // performed for this account.

                             err.SysMsgWrite(ErrE, hr, DCT_MSG_MOVE_FAILED_RDN_CONFLICT_SS, (LPCTSTR)strObjectPath, (LPCTSTR)strContainerPath);
                             Mark(L"errors", pAcct->GetType());
                             pAcct->operations = 0;
                             pAcct->MarkError();

                             return temphr;
                          }
                       }
                       else //else try to rename the CN of the object (I'll use the same MoveHere API)
                       {
                          IADsContainerPtr pOldCont;
                          temphr = ADsGetObject(sOldCont, IID_IADsContainer, (void**)&pOldCont);
                          if (SUCCEEDED(temphr))
                          {
                             temphr = pOldCont->MoveHere(const_cast<WCHAR*>(pAcct->GetTargetPath()), const_cast<WCHAR*>(pAcct->GetTargetName()), &pDisp);
                          }
                             //if failed to rename the CN, do not migrate
                          if ( FAILED(temphr) ) 
                          {
                             // The CN rename failed due to conflicting CN in this container
                             err.MsgWrite(ErrE, DCT_MSG_CN_RENAME_CONFLICT_SSS, (WCHAR*)sConfName, pAcct->GetTargetName(), (WCHAR*)sOldCont);
                             Mark(L"errors", pAcct->GetType());
                                //if we couldn't rename the CN, change the error code so we don't continue migrating this user
                             if ((HRESULT_CODE(temphr) == ERROR_OBJECT_ALREADY_EXISTS))
                                temphr = HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX);
                             return temphr;
                          }
                       }

                       // Get the new location of the object.
                       BSTR       sNewPath;
                       temphr = pDisp->QueryInterface(IID_IADs, (void**)&pAdsNew);
                       if ( FAILED(temphr) )
                       {
                          return temphr;
                       }
                       temphr = pAdsNew->get_ADsPath(&sNewPath);
                       if ( FAILED(temphr) )
                       {
                          return temphr;
                       }
                       // And store that in the target path
                       pAcct->SetTargetPath((WCHAR*) sNewPath);
                       SysFreeString(sNewPath);
                       setTargetPath.insert(pAcct);

                           // If the account is a group account and the Replace Existing members flag is set then we need to 
                           // remove all the members of this group.
                       if ( (_wcsicmp(L"group", pAcct->GetType()) == 0 ) && (pOptions->flags & F_REMOVE_OLD_MEMBERS) )
                          RemoveMembers(pAcct, pOptions);

                       pAcct->MarkAlreadyThere();
                       pAcct->MarkReplaced();
                    }
                    else
                    {
                       //if this is a special account that we need to mark as such
                       if (bIsCritical)
                       {
                          pAcct->MarkCritical();
                          hr = HRESULT_FROM_WIN32(ERROR_SPECIAL_ACCOUNT);
                       }
                    }
                  }
                  else
                  {
                     // Sam Account name is not in the target domain and we have a conflict see if it is a CN conf
                     DWORD                      nPathLen = LEN_Path;
                     c_array<WCHAR>             achPath(LEN_Path);
                     IADs                     * pAdsNew = NULL;

                     // Build the path to the target object
                     MakeFullyQualifiedAdsPath(achPath9, nPathLen, pOptions->tgtOUPath, pOptions->tgtDomain, pOptions->tgtNamingContext);
                     WCHAR * pRelativeTgtOUPath = wcschr(achPath9 + UStrLen(L"LDAP://") + 2,L'/');

                     if ( pRelativeTgtOUPath )
                     {
                        *pRelativeTgtOUPath = 0;
                        swprintf(achPath,L"%ls/%ls,%ls",(WCHAR*)achPath9,pAcct->GetTargetName(),pRelativeTgtOUPath+1);
                     }

                     temphr = ADsGetObject(achPath, IID_IADs, (void**) &pAdsNew);
                     if ( SUCCEEDED(temphr) )
                     {
                        // Object with that CN exists so we use it
                        BSTR sTgtPath;
                        HRESULT temphr = pAdsNew->get_ADsPath(&sTgtPath);
                        if (SUCCEEDED(temphr))
                           pAcct->SetTargetPath(sTgtPath);
                        else
                           pAcct->SetTargetPath(L"");
                           
                        // Check if the object we are about to replace is of the same type.
                        BSTR sClass;
                        temphr = pAdsNew->get_Class(&sClass);
                        if ((SUCCEEDED(temphr)) && (!_wcsicmp(pAcct->GetType(), (WCHAR*)sClass)))
                           bIsDifferentType = FALSE;
                        else
                           bIsDifferentType = TRUE;

                        _variant_t   varCritical;
                        temphr = pAdsNew->Get(L"isCriticalSystemObject", &varCritical);
                        if (SUCCEEDED(temphr))
                           bIsCritical = V_BOOL(&varCritical) == -1 ? TRUE : FALSE;

                           //if the source and target accounts are of different types we do not want to replace these.
                        if (bIsDifferentType)
                        {
                           hr = HRESULT_FROM_WIN32(ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH);
                        }
                           //else if not critical then fix the SAM name and other related chores
                        else if ( !bIsCritical )
                        {
                              //get the old Target Account Sam name
                           _variant_t varOldSAM = pAcct->GetTargetSam();
                           temphr = pAdsNew->Get(L"sAMAccountName", &varOldSAM);
                              // Set the Target Account Sam name
                           _variant_t varSAM = pAcct->GetTargetSam();
                           temphr = pAdsNew->Put(L"sAMAccountName", varSAM);
                           if (SUCCEEDED(temphr))
                              temphr = pAdsNew->SetInfo();
                           if ( FAILED(temphr) ) 
                           {
                              // The SAM rename failed due to conflicting SAM, do not migrate
                              err.MsgWrite(ErrE, DCT_MSG_SAM_RENAME_CONFLICT_SS, (WCHAR*)(varOldSAM.bstrVal), pAcct->GetTargetSam());
                              Mark(L"errors", pAcct->GetType());
                              return temphr;
                           }

                           setTargetPath.insert(pAcct);

                              // If the account is a group account and the Replace Existing members flag is set then we need to 
                              // remove all the members of this group.
                           if ( (_wcsicmp(L"group", pAcct->GetType()) == 0 ) && (pOptions->flags & F_REMOVE_OLD_MEMBERS) )
                              RemoveMembers(pAcct, pOptions);

                           pAcct->MarkAlreadyThere();
                           pAcct->MarkReplaced();
                        }
                        else
                        {
                           //if this is a special account that we need to mark as such
                           if (bIsCritical)
                           {
                              pAcct->MarkCritical();
                              hr = HRESULT_FROM_WIN32(ERROR_SPECIAL_ACCOUNT);
                           }
                        }
                     }
                     else
                     {
                        // This should only happen if the replace fails because the object that already has 
                        // this SAM Account Name is a special Win2K builtin object or container
                        // One example of this problem is "Service".
                        pAcct->SetStatus(pAcct->GetStatus()|AR_Status_Special);
                        err.SysMsgWrite(ErrE,ERROR_SPECIAL_ACCOUNT,DCT_MSG_REPLACE_FAILED_SD,pAcct->GetName(),ERROR_SPECIAL_ACCOUNT);
                        Mark(L"errors", pAcct->GetType());
                     }
                  }
                  pEnumMem->Release();
               }
               else
               {
                  pAcct->MarkAlreadyThere();
                  err.MsgWrite(ErrW,DCT_MSG_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
                  Mark(L"warnings",pAcct->GetType());

                  // retrieve target path for account
                  // fix group membership expects target path to be set
                  // even for conflicting objects that were not replaced

                  HRESULT hrPath = pCont->GetObject(strClass, _bstr_t(achTarget), &pDisp);

                  if (SUCCEEDED(hrPath))
                  {
                     BSTR bstr;
                     IADsPtr spObject(pDisp);
                     hrPath = spObject->get_ADsPath(&bstr);

                     if (SUCCEEDED(hrPath))
                     {
                        pAcct->SetTargetPath(_bstr_t(bstr, false));
                        setTargetPath.insert(pAcct);
                     }
                  }
               }
            }
         }
      }
      else
      {
         Mark(L"created", pAcct->GetType());
           pAcct->MarkCreated();
         BSTR  sTgtPath = NULL;
         HRESULT temphr = pAds->get_ADsPath(&sTgtPath);
         if ( SUCCEEDED(temphr) )
         {
            pAcct->SetTargetPath(sTgtPath);
            SysFreeString(sTgtPath);
            setTargetPath.insert(pAcct);
         }
         else
            pAcct->SetTargetPath(L"");

         // Add computers to 
         if ( !_wcsicmp(strClass,L"computer") )
         {
            IADsGroupPtr pGroup = GetWellKnownTargetGroup(DOMAIN_COMPUTERS,pOptions);
            if ( pGroup )
            {
               temphr = pGroup->Add(SysAllocString(pAcct->GetTargetPath()));
               if ( SUCCEEDED(temphr) )
               {
                  // if we successfully added the computer to Domain computers, now set Domain Computers as 
                  // the primary group
                  temphr = pAds->Put(L"primaryGroupID",_variant_t(LONG(515)));
                  if ( SUCCEEDED(temphr) )
                  {
                     temphr = pAds->SetInfo();
                  }
                  if ( SUCCEEDED(hr) )
                  {
                     // if this worked, now we can remove the computer from Domain Users
                     pGroup = GetWellKnownTargetGroup(DOMAIN_USERS,pOptions);
                     if ( pGroup )
                     {
                        temphr = pGroup->Remove(SysAllocString(pAcct->GetTargetPath()));
                     }
                  }
               }
            }
         }
         
      }  
   }
   else
   {
      // This is the No change mode. All we need to do here is to see if there might be a collision.
      c_array<WCHAR>         achPath(LEN_Path);
      c_array<WCHAR>         achPath9(LEN_Path);
      DWORD                  nPathLen = LEN_Path;
      c_array<WCHAR>         achPathTmp(LEN_Path);
      IADsPtr                pAdsNew;
      BOOL                   bConflict = FALSE;

      /* see if the CN conflicts */
         // Build the path to the target object
      MakeFullyQualifiedAdsPath(achPath9, nPathLen, pOptions->tgtOUPath, pOptions->tgtDomain, pOptions->tgtNamingContext);
      WCHAR * pRelativeTgtOUPath = wcschr(achPath9 + UStrLen(L"LDAP://") + 2,L'/');
      if ( pRelativeTgtOUPath )
      {
         *pRelativeTgtOUPath = 0;
         swprintf(achPathTmp,L"%ls/%ls,%ls",(WCHAR*)achPath9,pAcct->GetTargetName(),pRelativeTgtOUPath+1);
      }

      //
      // check if object DN is conflicting with
      // another object that is currently being migrated
      //

      pAcct->SetTargetPath(achPathTmp);

      if (DoTargetPathConflict(setTargetPath, pAcct))
      {
         return HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
      }

      HRESULT temphr = ADsGetObject(achPathTmp, IID_IADs, (void**) &pAdsNew);
      if (SUCCEEDED(temphr))
      {
         bConflict = TRUE;
      }
      
      /* if no CN conflict, see if the SAM conflicts */
      if (!bConflict)
      {
         hr = LookupAccountInTarget(pOptions, const_cast<WCHAR*>(pAcct->GetTargetSam()), achPath);
         if ( hr == S_OK )
            bConflict = TRUE;
      }

      if (!bConflict)
      {
         // There is no such account on the target. We can go ahead and assume that it would have worked.
         hr = S_OK;
         Mark(L"created", pAcct->GetType());
         pAcct->MarkCreated();

            //if the UPN conflicted, post a message
         if (pAcct->bUPNConflicted)
            err.MsgWrite(ErrE, DCT_MSG_UPN_CONF, pAcct->GetTargetSam());
      }
      else
      {
         bConflict = FALSE; //reset the conflict flag
         // there is a conflict. See if we need to add prefix or suffix. Or simply replace the account.
         if ( wcslen(pOptions->prefix) > 0 )
         {
            // Prefix was specified so we need to try that.
            c_array<WCHAR>      achTgt(LEN_Path);
            _variant_t          varStr;

            // Here I am adding a prefix and then lets see if we can setinfo that way
            // find the '=' sign
            wcscpy(achTgt, pAcct->GetTargetName());
            for ( DWORD z = 0; z < wcslen(achTgt); z++ )
            {
               if ( achTgt[z] == L'=' ) break;
            }
            
            if ( z < wcslen(achTgt) )
            {
               // Get the prefix part ex.CN=
               wcsncpy(achPref, achTgt, z+1);
               achPref[z+1] = 0;
               wcscpy(achSuf, achTgt+z+1);
            }

            // Build the target string with the Prefix
            wsprintf(achTgt, L"%s%s%s", (WCHAR*)achPref, pOptions->prefix, (WCHAR*)achSuf);
            pAcct->SetTargetName(achTgt);

            // Build the target SAM name with the prefix.
            wsprintf(achTgt, L"%s%s", pOptions->prefix, pAcct->GetTargetSam());
            pAcct->SetTargetSam(achTgt);

               //see if the CN still conflicts
            swprintf(achPathTmp,L"%ls/%ls,%ls",(WCHAR*)achPath9,pAcct->GetTargetName(),pRelativeTgtOUPath+1);

            //
            // check if object DN is conflicting with
            // another object that is currently being migrated
            //

            pAcct->SetTargetPath(achPathTmp);

            if (DoTargetPathConflict(setTargetPath, pAcct))
            {
               return HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
            }

            temphr = ADsGetObject(achPathTmp, IID_IADs, (void**) &pAdsNew);
            if (SUCCEEDED(temphr))
            {
               bConflict = TRUE;
            }
            
               //if no CN conflict, see if the SAM name conflicts
            if (!bConflict)
            {
               hr = LookupAccountInTarget(pOptions, const_cast<WCHAR*>(pAcct->GetTargetSam()), achPath);
               if ( hr == S_OK )
                  bConflict = TRUE;
            }

            if (!bConflict)
            {
               hr = 0;
               Mark(L"created", strClass);
               pAcct->MarkCreated();
            }
            else
            {
               hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
               pAcct->MarkAlreadyThere();
               err.MsgWrite(ErrE, DCT_MSG_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
               Mark(L"errors",pAcct->GetType());
            }

               //if the UPN conflicted, post a message
            if (pAcct->bUPNConflicted)
               err.MsgWrite(ErrE, DCT_MSG_UPN_CONF, pAcct->GetTargetSam());
         }
         else if ( wcslen(pOptions->suffix) > 0 )
         {
            // Suffix was specified so we will try that.
            c_array<WCHAR>      achTgt(LEN_Path);
            _variant_t          varStr;
            
            // Here I am adding a prefix and then lets see if we can setinfo that way
            wsprintf(achTgt, L"%s%s", pAcct->GetTargetName(), pOptions->suffix);
            // Build the target SAM name with the prefix.
            wsprintf(achTgt, L"%s%s", pAcct->GetTargetSam(), pOptions->suffix);
            pAcct->SetTargetSam(achTgt);

               //see if the CN still conflicts
            swprintf(achPathTmp,L"%ls/%ls,%ls",(WCHAR*)achPath9,pAcct->GetTargetName(),pRelativeTgtOUPath+1);

            //
            // check if object DN is conflicting with
            // another object that is currently being migrated
            //

            pAcct->SetTargetPath(achPathTmp);

            if (DoTargetPathConflict(setTargetPath, pAcct))
            {
               return HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
            }

            temphr = ADsGetObject(achPathTmp, IID_IADs, (void**) &pAdsNew);
            if (SUCCEEDED(temphr))
            {
               bConflict = TRUE;
            }
            
               //if no CN conflict, see if the SAM name conflicts
            if (!bConflict)
            {
               hr = LookupAccountInTarget(pOptions, const_cast<WCHAR*>(pAcct->GetTargetSam()), achPath);
               if ( hr == S_OK )
                  bConflict = TRUE;
            }

            if (!bConflict)
            {
               hr = 0;
               Mark(L"created", strClass);
               pAcct->MarkCreated();
            }
            else
            {
               hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
               pAcct->MarkAlreadyThere();
               err.MsgWrite(ErrE, DCT_MSG_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
               Mark(L"errors",pAcct->GetType());
            }

               //if the UPN conflicted, post a message
            if (pAcct->bUPNConflicted)
               err.MsgWrite(ErrE, DCT_MSG_UPN_CONF, pAcct->GetTargetSam());
         }
         else if (pOptions->flags & F_REPLACE)
         {
            // Replace the account.
            hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
         }
         else
         {
            // The account is already there and we really cant do anything about it. So tell the user.
            hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
            pAcct->MarkAlreadyThere();
            err.MsgWrite(ErrE, DCT_MSG_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
            Mark(L"errors",pAcct->GetType());
         }
      }

      pAcct->SetTargetPath(achPathTmp);
      setTargetPath.insert(pAcct);
   }

   return hr;
}


//----------------------------------------------------------------------------
// DoTargetPathConflict
//
// Checks if object's target distinguished name conflicts with another object
// that is currently being migrated and has already been processed.
//
// If a conflict is detected the account node's operations bits are cleared to
// prevent any further processing of this object and an error message is
// logged.
//----------------------------------------------------------------------------

bool CAcctRepl::DoTargetPathConflict(CTargetPathSet& setTargetPath, TAcctReplNode* pAcct)
{
    bool bConflict = false;

    //
    // If path conflicts are not to be ignored then check for a path conflict.
    //

    if (m_bIgnorePathConflict == false)
    {
        CTargetPathSet::iterator it = setTargetPath.find(pAcct);

        if (it != setTargetPath.end())
        {
            pAcct->operations = 0;

            err.MsgWrite(
                ErrW,
                DCT_MSG_OBJECT_RDN_CONFLICT_WITH_OTHER_CURRENT_OBJECT_SSS,
                pAcct->GetSourcePath(),
                pAcct->GetTargetName(),
                (*it)->GetSourcePath()
            );

            Mark(L"errors", pAcct->GetType());

            bConflict = true;
        }
    }

    return bConflict;
}


// GetNamingAttribute Method

HRESULT CAcctRepl::GetNamingAttribute(LPCTSTR pszServer, LPCTSTR pszClass, SNamingAttribute& rNamingAttribute)
{
    HRESULT hr = S_OK;

    try
    {
        if (pszServer == NULL)
            _com_issue_error(E_INVALIDARG);

        wstring strClass = pszClass;

        CNamingAttributeMap::iterator it = m_mapNamingAttribute.find(strClass);

        if (it != m_mapNamingAttribute.end())
        {
            rNamingAttribute = it->second;
        }
        else
        {
            WCHAR szADsPath[LEN_Path];
            DWORD dwArraySizeOfszADsPath = sizeof(szADsPath)/sizeof(szADsPath[0]);

            // bind to rootDSE

            IADsPtr spRootDSE;
            if (wcslen(L"LDAP://") + wcslen(pszServer) + wcslen(L"/rootDSE") >= dwArraySizeOfszADsPath)
                _com_issue_error(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
            wcscpy(szADsPath, L"LDAP://");
            wcscat(szADsPath, pszServer);
            wcscat(szADsPath, L"/rootDSE");
            CheckError(ADsGetObject(szADsPath, __uuidof(IADs), (VOID**)&spRootDSE));

            // get schema naming context

            VARIANT var;
            CheckError(spRootDSE->Get(_bstr_t(L"schemaNamingContext"), &var));
            _bstr_t strSchemaNamingContext = _variant_t(var, false);

            // bind to schema's directory search interface

            IDirectorySearchPtr spSearch;
            wcscpy(szADsPath, L"LDAP://");
            wcscat(szADsPath, strSchemaNamingContext);
            CheckError(ADsGetObject(szADsPath, __uuidof(IDirectorySearch), (VOID**)&spSearch));

            // search for inetOrgPerson class and retrieve rDNAttID attribute

            ADS_SEARCH_HANDLE ashSearch = NULL;
            LPWSTR pszAttributes[] = { L"rDNAttID" };

            CheckError(spSearch->ExecuteSearch(
                L"(&(objectClass=classSchema)(lDAPDisplayName=inetOrgPerson)(!isDefunct=TRUE))",
                pszAttributes,
                1,
                &ashSearch
            ));

            if (ashSearch)
            {
                wstring strAttribute;

                hr = spSearch->GetFirstRow(ashSearch);

                if (SUCCEEDED(hr))
                {
                    ADS_SEARCH_COLUMN ascColumn;
                    hr = spSearch->GetColumn(ashSearch, L"rDNAttID", &ascColumn);

                    if (SUCCEEDED(hr))
                    {
                        if ((ascColumn.dwADsType == ADSTYPE_CASE_IGNORE_STRING) && (ascColumn.dwNumValues == 1))
                        {
                            strAttribute = ascColumn.pADsValues->CaseIgnoreString;
                        }

                        spSearch->FreeColumn(&ascColumn);
                    }
                }

                spSearch->CloseSearchHandle(ashSearch);

                if (strAttribute.empty() == false)
                {
                    // get attribute's minimum and maximum range values

                    wcscpy(szADsPath, L"LDAP://");
                    wcscat(szADsPath, pszServer);
                    wcscat(szADsPath, L"/schema/");
                    wcscat(szADsPath, strAttribute.c_str());

                    IADsPropertyPtr spProperty;

                    CheckError(ADsGetObject(szADsPath, __uuidof(IADsProperty), (VOID**)&spProperty));

                    long lMinRange;
                    long lMaxRange;

                    CheckError(spProperty->get_MinRange(&lMinRange));
                    CheckError(spProperty->get_MaxRange(&lMaxRange));

                    // set naming attribute info

                    rNamingAttribute.nMinRange = lMinRange;
                    rNamingAttribute.nMaxRange = lMaxRange;
                    rNamingAttribute.strName = strAttribute;

                    // save naming attribute and range values in cache

                    m_mapNamingAttribute.insert(CNamingAttributeMap::value_type(strClass, SNamingAttribute(lMinRange, lMaxRange, strAttribute)));
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }

    return hr;
}


void VariantSidToString(_variant_t & varSid)
{
   if ( varSid.vt == VT_BSTR )
   {
      return;
   }
   else if ( varSid.vt == ( VT_ARRAY | VT_UI1) )
   {
      // convert the array of bits to a string
      CLdapConnection   c;
      LPBYTE            pByte = NULL;
      WCHAR             str[LEN_Path];

      SafeArrayAccessData(varSid.parray,(void**)&pByte);
      c.BytesToString(pByte,str,GetLengthSid(pByte));
      SafeArrayUnaccessData(varSid.parray);
      
      varSid = SysAllocString(str);

   }
   else
   {
      varSid.ChangeType(VT_BSTR);
   }
}

HRESULT CAcctRepl::UpdateGroupMembership(
                                          Options              * pOptions,    //in -Options set by the user
                                          TNodeListSortable    * acctlist,    //in -List of all accounts being copied
                                          ProgressFn           * progress,    //in -Progress update 
                                          IStatusObj           * pStatus      //in -Status update
                                        )
{
    IVarSetPtr                pVs(__uuidof(VarSet));
    MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
    WCHAR                     sTgtPath[LEN_Path];
    IIManageDBPtr             pDB = pOptions->pDb;
    IUnknown*                 pUnk = NULL;
    TNodeTreeEnum             tenum;
    HRESULT                   hr = S_OK;   
    DWORD                     ret = 0;
    bool                      bFoundGroups = false;
    WCHAR                     sDomain[LEN_Path];
    DWORD                     grpType = 0;

    IUnknownPtr spUnknown(pVs);
    pUnk = spUnknown;

    // sort the account list by Source Type\Source Sam Name
    if ( acctlist->IsTree() ) acctlist->ToSorted();
    acctlist->SortedToScrambledTree();
    acctlist->Sort(&TNodeCompareAccountSam);
    acctlist->Balance();

    for (TAcctReplNode* acct = (TAcctReplNode *)tenum.OpenFirst(acctlist) ; acct ; acct = (TAcctReplNode *)tenum.Next())
    {
        if ( !acct->ProcessMem() )
            continue;
        if ( pStatus )
        {
            LONG                status = 0;
            HRESULT             hr = pStatus->get_Status(&status);

            if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
            {
                if ( !bAbortMessageWritten ) 
                {
                    err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                    bAbortMessageWritten = true;
                }
                break;
            }
        }

        // Since the list is sorted by account type we can continue to ignore everything till we get to the
        // group type and once it is found and processed the rest of types can be ignored
        if ( _wcsicmp(acct->GetType(), L"group") != 0 )
        {
            if ( !bFoundGroups )
                continue;
            else
                break;
        }
        else
        {
            bFoundGroups = true;
        }


        // If we are here this must be a group type so tell the progrss function what we are doing
        WCHAR                  mesg[LEN_Path];
        bool                   bGotPrimaryGroups = false;

        wsprintf(mesg, GET_STRING(IDS_UPDATING_GROUP_MEMBERSHIPS_S), acct->GetName());
        if ( progress )
            progress(mesg);

        if ( acct->CreateAccount() && (!acct->WasCreated() && !acct->WasReplaced()) )
            // if the account was not copied then why should we even process it?
            // Bad idea. We need to process the account membership because the group may have been previously copied and
            // in this run we simply need to update the membership. Changing the expansion code to mark the account as created.
            // that should fix the problem.
            continue;

        if ( !_wcsicmp(acct->GetType(), L"group") && *acct->GetTargetPath() )
        {
            IADsGroupPtr spSourceGroup;
            IADsGroupPtr spTargetGroup;
            IADsMembersPtr spMembers;
            IEnumVARIANTPtr spEnum;

            err.MsgWrite(0, DCT_MSG_PROCESSING_GROUP_MEMBER_S, (WCHAR*) acct->GetTargetName());
            if ( !pOptions->nochange )
            {
                hr = ADsGetObject(const_cast<WCHAR*>(acct->GetTargetPath()), IID_IADsGroup, (void**) &spTargetGroup);
                if (FAILED(hr)) 
                {
                    err.SysMsgWrite(ErrE, hr, DCT_MSG_OBJECT_NOT_FOUND_SSD, acct->GetTargetPath(), pOptions->tgtDomain, hr );
                    Mark(L"errors", acct->GetType());
                    continue;    // we cant possibly do any thing without the source group
                }
            }
            else
                hr = S_OK;

            if ( spTargetGroup )
            {
                VARIANT var;
                VariantInit(&var);
                hr = spTargetGroup->Get(L"groupType", &var);
                if (SUCCEEDED(hr))
                    grpType = long(_variant_t(var, false));
            }

            hr = ADsGetObject(const_cast<WCHAR*>(acct->GetSourcePath()), IID_IADsGroup, (void**) &spSourceGroup);
            if (FAILED(hr)) 
            {
                err.SysMsgWrite(ErrE, 0, DCT_MSG_OBJECT_NOT_FOUND_SSD, acct->GetSourcePath(), pOptions->srcDomain, hr );
                Mark(L"errors", acct->GetType());
                continue;    // we cant possibly do any thing for this group without the target group
            }

            // Now we get the members interface.
            hr = spSourceGroup->Members(&spMembers);

            // Ask for an enumeration of the members
            if ( SUCCEEDED(hr) )
                hr = spMembers->get__NewEnum((IUnknown **)&spEnum);

            // If unable to retrieve enumerator then generate error message.
            if (FAILED(hr)) 
            {
                err.SysMsgWrite(ErrE, hr, DCT_MSG_UNABLE_TO_ENUM_MEMBERS_S, acct->GetSourcePath());
                Mark(L"errors", acct->GetType());
                continue;
            }

            VARIANT varMembers;
            VariantInit(&varMembers);

            // Now enumerate through all the objects in the Group
            while ( SUCCEEDED(spEnum->Next(1, &varMembers, &ret)) )
            {
                _variant_t vntMembers(varMembers, false);
                IADsPtr spADs;
                _bstr_t strClass;
                _bstr_t strPath;
                _bstr_t strSam;
                PSID pSid = NULL;

                // Check if user wants to abort the operation
                if ( pOptions->pStatus )
                {
                    LONG                status = 0;
                    HRESULT             hr = pOptions->pStatus->get_Status(&status);

                    if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                    {
                        if ( !bAbortMessageWritten ) 
                        {
                            err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                            bAbortMessageWritten = true;
                        }
                        break;
                    }
                }
                // If no values are returned that means we are done with all members
                if ( ret == 0  || vntMembers.vt == VT_EMPTY)
                {
                    if ( bGotPrimaryGroups )
                        break;
                    else
                    {
                        // Go through and add all the users that have this group as their primary group.
                        bGotPrimaryGroups = true;

                        //
                        // It is only necessary to query objects that have their primary group ID equal to the
                        // current group for W2K and later as NT4 required that the account be a member of the
                        // global group in order to set the primary group ID equal to the group. As the members
                        // of the group have already been queried it would be redundant to query for objects
                        // that have their primary group ID equal to the current group.
                        //

                        if (pOptions->srcDomainVer >= 5)
                        {
                            hr = GetThePrimaryGroupMembers(pOptions, const_cast<WCHAR*>(acct->GetSourceSam()), &spEnum);
                            if (SUCCEEDED(hr))
                                continue;
                            else
                                break;
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                // Depending on what we are looking at we get two variant types. In case of members we get
                // IDispatch pointer in a variant. In case of primary group members we get variant(bstr) array 
                // So we need to branch here depending on what we get
                if ( bGotPrimaryGroups )
                {
                    // first element is the ADsPath of the object so use that to get the object and continue
                    if ( vntMembers.vt == (VT_ARRAY | VT_VARIANT) )
                    {
                        SAFEARRAY * pArray = vntMembers.parray;
                        VARIANT            * pDt;

                        hr = SafeArrayAccessData(pArray, (void**) &pDt);
                        if (SUCCEEDED(hr))
                        {
                            if ( pDt[0].vt == VT_BSTR )
                                hr = ADsGetObject((WCHAR*)pDt[0].bstrVal, IID_IADs, (void**) &spADs);
                            else
                                hr = E_FAIL;
                            SafeArrayUnaccessData(pArray);
                        }
                        vntMembers.Clear();
                    }
                    else
                        hr = E_FAIL;
                }
                else
                {
                    // We have a dispatch pointer in the VARIANT so we will get the IADs pointer to it and
                    // then get the ADs path to that object and then remove it from the group

                    spADs = IDispatchPtr(vntMembers);

                    if (spADs)
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }

                if ( SUCCEEDED(hr) )
                {
                    BSTR bstr = NULL;
                    hr = spADs->get_ADsPath(&bstr);
                    if ( SUCCEEDED(hr) )
                    {
                        strPath = _bstr_t(bstr, false);

                        // Parse out the domain name from the WinNT path.
                        if ( !wcsncmp(L"WinNT://", (WCHAR*)strPath, 8) )
                        {
                            //Grab the domain name from the WinNT path.
                            WCHAR             sTemp[LEN_Path];
                            WCHAR * p = strPath;
                            wcscpy(sTemp, p+8);
                            p = wcschr(sTemp, L'/');
                            if ( p )
                                *p = L'\0';
                            else
                            {
                                //we have the path in this format "WinNT://S-1-5....."
                                // in this case we need to get the SID and then try and get its domain and account name
                                PSID                         pSid = NULL;
                                WCHAR                        sName[255];
                                DWORD                        rc = 1;

                                pSid = SidFromString(sTemp);
                                if ( pSid )
                                {
                                    rc = GetName(pSid, sName, sTemp);
                                    if ( !rc )
                                    {
                                        // Give it a winnt path. This way we get the path that we can use
                                        strPath = _bstr_t(L"WinNT://") + sTemp + _bstr_t(L"/") + sName;
                                    }
                                    FreeSid(pSid);
                                }

                                if ( rc ) 
                                {
                                    // Log a message that we cant resolve this guy
                                    err.SysMsgWrite(ErrE, rc, DCT_MSG_PATH_NOT_RESOLVED_SD, sTemp, rc);
                                    Mark("errors", acct->GetType());
                                    continue;
                                }
                            }
                            wcscpy(sDomain, sTemp);
                        }
                        else
                        {
                            // Get the domain name from the LDAP path. Convert domain name to the NETBIOS name.

                            _bstr_t strDomainDns = GetDomainDNSFromPath(strPath);

                            if (strDomainDns.length())
                            {
                                safecopy(sDomain, (WCHAR*)strDomainDns);
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                        }
                    }

                    if ( SUCCEEDED(hr) )
                    {
                        if ( !(acct->GetGroupType() & ADS_GROUP_TYPE_DOMAIN_LOCAL_GROUP) )
                        {
                            // Global/Universal groups are easy all we have to do is use the path we got back and get the info from that object
                            BSTR bstr = NULL;
                            hr = spADs->get_Class(&bstr);
                            if (SUCCEEDED(hr))
                                strClass = _bstr_t(bstr, false);
                            else
                                strClass = L"";
                            VARIANT var;
                            VariantInit(&var);
                            hr = spADs->Get(L"samAccountName", &var);
                            if ( SUCCEEDED(hr) )
                                strSam = _variant_t(var, false);
                            else
                            {
                                // make sure it is a WinNT:// path 
                                if ( !wcsncmp((WCHAR*)strPath, L"WinNT://", 8) )
                                {
                                    BSTR bstr = NULL;
                                    hr = spADs->get_Name(&bstr);
                                    if (SUCCEEDED(hr))
                                        strSam = _bstr_t(bstr, false);
                                }
                            }
                            //if universal group change domain if foreign security principal
                            if ((acct->GetGroupType() & ADS_GROUP_TYPE_UNIVERSAL_GROUP))
                            {
                                _bstr_t sTempDomain = GetDomainOfMigratedForeignSecPrincipal(spADs, strPath);
                                if (sTempDomain.length())
                                    wcscpy(sDomain, sTempDomain);
                            }
                        }
                        else
                        {
                            // Local group we need to get the SID LDAP path and then use that to add the account to the group.
                            WCHAR                   sSidDomain[LEN_Path];
                            WCHAR                   sSidPath[LEN_Path];
                            WCHAR                   sSamName[LEN_Path];

                            if ( pSid )
                            {
                                FreeSid(pSid);
                                pSid = NULL;
                            }

                            hr = BuildSidPath(spADs, sSidPath, sSamName, sSidDomain, pOptions,&pSid);

                            if (SUCCEEDED(hr))
                            {
                                _bstr_t sTempDomain = GetDomainOfMigratedForeignSecPrincipal(spADs, strPath);
                                if (sTempDomain.length())
                                    wcscpy(sDomain, sTempDomain);
                                strPath = sSidPath;
                                strSam = sSamName;
                            }
                            else
                            {
                                err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_ADD_TO_GROUP_SSD, (WCHAR*)strPath, acct->GetTargetName(), hr);
                                Mark(L"warnings", acct->GetType());
                            }
                        }
                    }
                }

                if ( SUCCEEDED(hr) )
                {
                    // Now that we have the SamAccountname and the path we can lookup the info from the DB
                    hr = pDB->GetAMigratedObject(strSam, sDomain, pOptions->tgtDomain, &pUnk);
                    if ( pOptions->nochange )
                    {
                        WCHAR                   targetPath[LEN_Path];
                        // in this case the account was not really copied so we need to make sure that we 
                        // we include the accounts that would have been added if this was a true migration.
                        Lookup      p;
                        p.pName = strSam;
                        p.pType = strClass;
                        TAcctReplNode * pNode = (TAcctReplNode *) acctlist->Find(&TNodeFindAccountName, &p);
                        if (pNode)
                        {
                            pVs->put(L"MigratedObjects.TargetSamName", _variant_t(pNode->GetTargetSam()));

                            BuildTargetPath(pNode->GetTargetName(), pOptions->tgtOUPath, targetPath);
                            pVs->put(L"MigratedObjects.TargetAdsPath", _variant_t(targetPath));
                            hr = S_OK;
                        }
                    }
                    if ( hr == S_OK )
                    {
                        VerifyAndUpdateMigratedTarget(pOptions, pVs);

                        // Since we have previously copied the account we can simply add the one that we copied.
                        _bstr_t strTargetPath = pVs->get(L"MigratedObjects.TargetAdsPath");
                        if ( strTargetPath.length() )
                        {
                            if ( !pOptions->nochange )
                                hr = spTargetGroup->Add(strTargetPath);
                            else
                                hr = S_OK;

                            if ( SUCCEEDED(hr) )
                            {
                                err.MsgWrite(0, DCT_MSG_ADDED_TO_GROUP_S, (WCHAR*)strTargetPath);

                                //if this is not a global group, remove the source account from the group, if there
                                if (!pOptions->nochange && !(acct->GetGroupType() & ADS_GROUP_TYPE_GLOBAL_GROUP))
                                    RemoveSourceAccountFromGroup(spTargetGroup, pVs, pOptions);
                            }
                            else
                            {
                                hr = BetterHR(hr);
                                switch ( HRESULT_CODE(hr) )
                                {
                                case NERR_UserNotFound:
                                case 0x5000:
                                    err.SysMsgWrite(0, hr, DCT_MSG_MEMBER_NONEXIST_SS, (WCHAR *)strTargetPath, acct->GetTargetName(), hr);
                                    break;
                                default:
                                    {
                                        err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_ADD_TO_GROUP_SSD, (WCHAR *)strTargetPath, acct->GetTargetName(), hr);
                                        Mark(L"warnings", acct->GetType());
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        // We have not migrated the accounts from source domain to the target domain.
                        // so we now have to branch for different group types.
                        WCHAR                     domain[LEN_Path];
                        DWORD                     cbDomain = DIM(domain);
                        SID_NAME_USE              use;

                        if ( grpType & ADS_GROUP_TYPE_GLOBAL_GROUP )
                        {
                            // For the global groups we simply say that account has not been migrated.
                            err.MsgWrite(0, DCT_MSG_MEMBER_NONEXIST_SS, (WCHAR*)strSam, acct->GetTargetName());
                        }
                        else
                        {
                            //Process local/universal groups ( can add objects from non-target domains )
                            // 1. See if we have migrated this account to some other domain.
                            // 2. Is the Source accounts SID valid here (trust) if so add that.
                            // 3. See if we can find an account with the same name in the target.
                            // if any of these operations yield a valid account then just add it.

                            // we are going to lookup migrated objects table to find migration of this object
                            // from source domain to any other domain.
                            hr = pDB->raw_GetAMigratedObjectToAnyDomain(strSam, sDomain, &pUnk);
                            if ( hr == S_OK )
                            {
                                // we have migrated the object to some other domain. So we will get the path to that object and try to add it to the group
                                // it may fail if there is no trust/forest membership of the target domain and the domain that this object resides in. 
                                _bstr_t strTargetPath = pVs->get(L"MigratedObjects.TargetAdsPath");
                                if ( strTargetPath.length() )
                                {
                                    // Since the object is in a different domain, we will have to get the SID of the object, 
                                    // and use that for the Add
                                    IADsPtr                spAds;
                                    _variant_t             varSid;

                                    hr = ADsGetObject(strTargetPath,IID_IADs,(void**)&spAds);
                                    if ( SUCCEEDED(hr) )
                                    {
                                        VARIANT var;
                                        VariantInit(&var);
                                        hr = spAds->Get(L"objectSid",&var);
                                        if (SUCCEEDED(hr))
                                            varSid = _variant_t(var, false);
                                        spAds.Release();
                                    }
                                    if ( SUCCEEDED(hr) )
                                    {
                                        // Make sure the SID we got was in string format
                                        VariantSidToString(varSid);
                                        UStrCpy(sTgtPath,L"LDAP://<SID=");
                                        UStrCpy(sTgtPath + UStrLen(sTgtPath),varSid.bstrVal);
                                        UStrCpy(sTgtPath + UStrLen(sTgtPath),L">");

                                        if ( !pOptions->nochange )
                                            hr = spTargetGroup->Add(sTgtPath);
                                        else
                                            hr = S_OK;
                                    }

                                    if ( SUCCEEDED(hr) )
                                    {
                                        err.MsgWrite(0, DCT_MSG_ADDED_TO_GROUP_S, (WCHAR*)strTargetPath);

                                        //remove the source account from the group, if there
                                        if (!pOptions->nochange)
                                        {
                                            RemoveSourceAccountFromGroup(spTargetGroup, pVs, pOptions);
                                        }
                                    }
                                    else
                                    {
                                        hr = BetterHR(hr);
                                        if ( HRESULT_CODE(hr) == NERR_UserExists )
                                        {
                                            err.MsgWrite(0,DCT_MSG_USER_IN_GROUP_SS,(WCHAR*)strTargetPath,acct->GetTargetName());
                                        }
                                        else if ( HRESULT_CODE(hr) == NERR_UserNotFound )
                                        {
                                            err.SysMsgWrite(0, hr, DCT_MSG_MEMBER_NONEXIST_SS, (WCHAR*)strTargetPath, acct->GetTargetName(), hr);
                                        }
                                        else
                                        {
                                            // message for the generic failure case
                                            err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_ADD_TO_GROUP_SSD, (WCHAR*)strTargetPath, acct->GetTargetName(), hr);
                                            Mark(L"warnings", acct->GetType());
                                        }
                                    }
                                }
                            }
                            else
                            {
                                // we have never migrated this account. So we will try to add the original account to the target domain.
                                // This would work if the target domain and the domain where this object is satisfy the requirements of
                                // forest membership/ trusts imposed by Universal/Local groups respectively.

                                // Get the sid of the source account
                                _variant_t             varSid;

                                // check whether the target domain knows this sid
                                // Before we try to add, make sure the target domain knows this account
                                WCHAR                      name[LEN_Path];
                                DWORD                      lenName = DIM(name);
                                cbDomain = DIM(domain);

                                if ( grpType & ADS_GROUP_TYPE_UNIVERSAL_GROUP )
                                {
                                    // in case of the Universal group we need to make sure that domains are in 
                                    // the same forest. We will use access checker for this
                                    BOOL           bIsSame = FALSE;
                                    _bstr_t sSrcDomainDNS = GetDomainDNSFromPath(strPath);
                                    hr = pAccess->raw_IsInSameForest(pOptions->tgtDomainDns, sSrcDomainDNS, (long*)&bIsSame);

                                    if ( SUCCEEDED(hr) && bIsSame )
                                    {
                                        // We have accounts that are in same forest so we can simply add the account.
                                        if ( !pOptions->nochange )
                                            hr = spTargetGroup->Add(strPath);
                                        else
                                            hr = S_OK;

                                        if ( SUCCEEDED(hr) )
                                        {
                                            WCHAR sWholeName[LEN_Path];
                                            wcscpy(sWholeName, sSrcDomainDNS);
                                            wcscat(sWholeName, L"\\");
                                            wcscat(sWholeName, !strSam ? L"" : strSam);
                                            err.MsgWrite(0, DCT_MSG_ADDED_TO_GROUP_S, sWholeName);
                                        }
                                        else
                                        {
                                            hr = BetterHR(hr);
                                            err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_ADD_TO_GROUP_SSD, (WCHAR*) strSam, acct->GetTargetName(), hr);
                                            Mark(L"warnings", acct->GetType());
                                        }
                                    }
                                    else
                                    {
                                        err.MsgWrite(ErrW, DCT_MSG_CANNOT_ADD_OBJECTS_NOT_IN_FOREST_TO_GROUP_SS, (WCHAR*)strSam, acct->GetTargetName());
                                        Mark(L"warnings", acct->GetType());
                                    }
                                }
                                else
                                {
                                    if ( !pOptions->nochange )
                                        hr = spTargetGroup->Add(strPath);
                                    else
                                        hr = S_OK;

                                    // In case of local groups If we know the SID in the target domain then we can simply
                                    // add that account to the target group
                                    if ( LookupAccountSid(pOptions->tgtComp,pSid,name,&lenName,domain,&cbDomain,&use) )
                                    {
                                        WCHAR sWholeName[LEN_Path];
                                        wcscpy(sWholeName, domain);
                                        wcscat(sWholeName, L"\\");
                                        wcscat(sWholeName, !strSam ? L"" : strSam);
                                        err.MsgWrite(0, DCT_MSG_ADDED_TO_GROUP_S, sWholeName);
                                    }
                                    else
                                    {
                                        // log the fact that the SID could not be resolved in the target domain
                                        // this will happen when the target domain does not trust the source domain
                                        WCHAR sWholeName[LEN_Path];
                                        wcscpy(sWholeName, sDomain);
                                        wcscat(sWholeName, L"\\");
                                        wcscat(sWholeName, !strSam ? L"" : strSam);
                                        err.MsgWrite(0, DCT_MSG_CANNOT_RESOLVE_SID_IN_TARGET_SS, sWholeName, acct->GetTargetName(), HRESULT_FROM_WIN32(GetLastError()));
                                    }
                                }
                            }
                        }  // if group type
                    }  // if not migrated to the target domain.
                }  // if can get to the member. 
                if( pSid )
                    FreeSid(pSid);
            }  //while
        }
    }

    return hr;
}

HRESULT CAcctRepl::LookupAccountInTarget(Options * pOptions, WCHAR * sSam, WCHAR * sPath)
{
   if ( pOptions->tgtDomainVer < 5 )
   {
      // for NT4 we can just build the path and send it back. 
      wsprintf(sPath, L"WinNT://%s/%s", pOptions->tgtDomain, sSam);
      return S_OK;
   }
   // Use the net object enumerator to lookup the account in the target domain.
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   IEnumVARIANT            * pEnum = NULL;
   SAFEARRAYBOUND            bd = { 1, 0 };
   SAFEARRAY               * pszColNames;
   BSTR  HUGEP             * pData = NULL;
   LPWSTR                    sData[] = { L"aDSPath" };
   WCHAR                     sQuery[LEN_Path];
   WCHAR                     sDomPath[LEN_Path];
   DWORD                     ret = 0;
   _variant_t                var, varVal;
   HRESULT                   hr = S_OK;

   wsprintf(sDomPath, L"LDAP://%s/%s", pOptions->tgtDomainDns, pOptions->tgtNamingContext);
   WCHAR                     sTempSamName[LEN_Path];
   wcscpy(sTempSamName, sSam);
   if ( sTempSamName[0] == L' ' )
   {
      WCHAR               sTemp[LEN_Path];
      wsprintf(sTemp, L"\\20%s", sTempSamName + 1); 
      wcscpy(sTempSamName, sTemp);
   }
   wsprintf(sQuery, L"(sAMAccountName=%s)", sTempSamName);

   hr = pQuery->raw_SetQuery(sDomPath, pOptions->tgtDomain, sQuery, ADS_SCOPE_SUBTREE, FALSE);

   // Set up the columns that we want back from the query ( in this case we need SAM accountname )
   pszColNames = ::SafeArrayCreate(VT_BSTR, 1, &bd);
   hr = ::SafeArrayAccessData(pszColNames, (void HUGEP **)&pData);
   if ( SUCCEEDED(hr) )
      pData[0] = SysAllocString(sData[0]);

   if ( SUCCEEDED(hr) )
      hr = ::SafeArrayUnaccessData(pszColNames);

   if ( SUCCEEDED(hr) )
      hr = pQuery->raw_SetColumns(pszColNames);

   // Time to execute the plan.
   if ( SUCCEEDED(hr) )
      hr = pQuery->raw_Execute(&pEnum);

   if ( SUCCEEDED(hr) )
   {
      // if this worked that means we can only have one thing in the result.
      if ( (pEnum->Next(1, &var, &ret) == S_OK) && ( ret > 0 ) )
      {
         SAFEARRAY * pArray = var.parray;
         long        ndx = 0;
         hr = SafeArrayGetElement(pArray,&ndx,&varVal);
         if ( SUCCEEDED(hr) )
            wcscpy(sPath, (WCHAR*)varVal.bstrVal);
         else
            hr = HRESULT_FROM_WIN32(NERR_UserNotFound);
      }
      else
         hr = HRESULT_FROM_WIN32(NERR_UserNotFound);
   }
   if ( pEnum ) pEnum->Release();
   return hr;
}

//----------------------------------------------------------------------------
// RemoveMembers : This function enumerates through all the members of the 
//                 given group and removes them one at a time.
//----------------------------------------------------------------------------
HRESULT CAcctRepl::RemoveMembers(
                                    TAcctReplNode * pAcct,  //in- AccountReplicator Node with the Account info
                                    Options * pOptions      //in- Options set by the user.
                                )

{
   IADsMembers             * pMem = NULL;
   IADs                    * pAds = NULL;
   IADsGroup               * pGrp = NULL;
  // IUnknown                * pUnk;
   IEnumVARIANT            * pVar = NULL;
   IDispatch               * pDisp = NULL;
   DWORD                     ret = 0;
   _variant_t                var;
   WCHAR                   * sPath;

   // First we make sure that this is really a group otherwise we ignore it.
   if (_wcsicmp((WCHAR*)pAcct->GetType(),L"group"))
      return S_OK;

   // Lets get a IADsGroup * to the group object.
   HRESULT hr = ADsGetObject(const_cast<WCHAR*>(pAcct->GetTargetPath()), IID_IADsGroup, (void **) &pGrp);

   // Now we get the members interface.
   if ( SUCCEEDED(hr) )
      hr = pGrp->Members(&pMem);

   // Ask for an enumeration of the members
   if ( SUCCEEDED(hr) )
      hr = pMem->get__NewEnum((IUnknown **)&pVar);

   // Now enumerate through all the objects in the Group and for each one remove it from the group
   while ( SUCCEEDED(pVar->Next(1, &var, &ret)) )
   {
      // If no values are returned that means we are done with all members so break out of this loop
      if ( ret == 0 )
         break;

      // We hace a dispatch pointer in the VARIANT so we will get the IADs pointer to it and
      // then get the ADs path to that object and then remove it from the group
      pDisp = V_DISPATCH(&var);  
      hr = pDisp->QueryInterface(IID_IADs, (void**) &pAds);

      if ( SUCCEEDED(hr) )
         hr = pAds->get_ADsPath(&sPath);
      if ( pAds ) pAds->Release();
      
      if ( SUCCEEDED(hr) )
      {
         _bstr_t bstrPath(sPath);
         if ( !pOptions->nochange )
            hr = pGrp->Remove(bstrPath);
      }
      var.Clear();
   }
   if ( pMem ) pMem->Release();
   if ( pGrp ) pGrp->Release();
   if ( pVar ) pVar->Release();
   return hr;
}

//----------------------------------------------------------------------------
// FillPathInfo : This function looks up the ADs path from the source domain 
//                for a given SAMAccountName
//----------------------------------------------------------------------------
bool CAcctRepl::FillPathInfo(
                              TAcctReplNode * pAcct,  //in- AccountReplicator Node with the Account info
                              Options * pOptions      //in- Options set by the user.
                            )
{
   wstring                   sPath;
   _bstr_t                   sTgtPath;
   // Fill the naming context for the domains. If the Naming context does not work then it is not a Win2kDomain
   // so we need to stop right here.
   if ( wcslen(pOptions->srcNamingContext) == 0 ) 
      FillNamingContext(pOptions);

   if ( wcslen(pOptions->srcNamingContext) == 0 )
   {
      // this is probably an NT 4 source domain
      // construct the source path
      if ( ! *pAcct->GetSourcePath() )
      {
         sPath = L"WinNT://";
         sPath += pOptions->srcDomain;
         sPath += L"/";
         sPath += pAcct->GetName();
         pAcct->SetSourcePath(sPath.c_str());
      }
      return true;
   }

   WCHAR                     strName[LEN_Path];
   wcscpy(strName, pAcct->GetName());
   // Check if the Name field is a LDAP sub path or not. If we have LDAP subpath then we
   // call the AcctReplFullPath function to fillup the path information.
   if ( (wcslen(strName) > 3) && (strName[2] == (L'=')) )
   {
      AcctReplFullPath(pAcct, pOptions);
      return true;
   }

   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   HRESULT                   hr;
   LPWSTR                    sData[] = { L"ADsPath", L"distinguishedName", L"name", L"profilePath", L"groupType" };
   long                      nElt = DIM(sData);
   BSTR                    * pData;
   SAFEARRAY               * psaColNames;
   IEnumVARIANTPtr           pEnum;
   _variant_t                var;
   DWORD                     dwFetch;

   // We are going to update all fields that we know about
 
   // Set the LDAP path to the whole domain and then the query to the SAMAccountname
   sPath = L"LDAP://";
   sPath += pOptions->srcDomain;
   sPath += L"/";
   sPath += pOptions->srcNamingContext;

   wstring sTempSamName = pAcct->GetSourceSam();

   if (sTempSamName[0] == L' ')
   {
      sTempSamName = L"\\20" + sTempSamName.substr(1);
   }

   wstring strQuery = L"(sAMAccountName=" + sTempSamName + L")";

   // Set the enumerator query
   hr = pQuery->raw_SetQuery(
       _bstr_t(sPath.c_str()),
       _bstr_t(pOptions->srcDomain),
       _bstr_t(strQuery.c_str()),
       ADS_SCOPE_SUBTREE,
       FALSE
   );

   if (SUCCEEDED(hr))
   {
      // Create a safearray of columns we need from the enumerator.
      SAFEARRAYBOUND bd = { nElt, 0 };
   
      psaColNames = ::SafeArrayCreate(VT_BSTR, 1, &bd);

      if (psaColNames)
      {
         hr = ::SafeArrayAccessData(psaColNames, (void**)&pData);
      }
      else
      {
         hr = E_OUTOFMEMORY;
      }

      if ( SUCCEEDED(hr) )
      {
         for( long i = 0; i < nElt; i++)
         {
            pData[i] = SysAllocString(sData[i]);
         }
   
         hr = ::SafeArrayUnaccessData(psaColNames);
      }

      if (SUCCEEDED(hr))
      {
         // Set the columns on the enumerator object.
         hr = pQuery->raw_SetColumns(psaColNames);
      }

      if (psaColNames)
      {
         SafeArrayDestroy(psaColNames);
      }
   }

   if (SUCCEEDED(hr))
   {
      // Now execute.
      hr = pQuery->raw_Execute(&pEnum);
   }

   if (SUCCEEDED(hr))
   {
      // We should have recieved only one value. So we will get the value and set it into the Node.
      VARIANT varTemp;
      VariantInit(&varTemp);
      hr = pEnum->Next(1, &varTemp, &dwFetch);
      var = _variant_t(varTemp, false);
   }

   if ( SUCCEEDED(hr) && ( var.vt & VT_ARRAY) )
   {
      // This would only happen if the member existed in the target domain.
      // We now have a Variant containing an array of variants so we access the data
      SAFEARRAY* psa = V_ARRAY(&var);
      VARIANT* pVar;
      SafeArrayAccessData(psa, (void**)&pVar);
      
      // Get the AdsPath first
      sTgtPath = pVar[0].bstrVal;
      if (sTgtPath.length() > 0)
      {
         // Set the source Path in the Account node
         pAcct->SetSourcePath(sTgtPath);

         // Then we get the distinguishedName to get the prefix string
         sTgtPath = V_BSTR(&pVar[1]);

         // We also get the name value to set the target name
         if (V_BSTR(&pVar[2]))
         {
            pAcct->SetName(V_BSTR(&pVar[2]));
            pAcct->SetTargetName(V_BSTR(&pVar[2]));
         }

         // We also get the profile path so we can translate it
         if (V_BSTR(&pVar[3]))
         {
            pAcct->SetTargetProfile(V_BSTR(&pVar[3]));
         }

         if ( pVar[4].vt == VT_I4 )
         {
            // We have the object type property so lets set it.
            pAcct->SetGroupType(pVar[4].lVal);
         }
      
         SafeArrayUnaccessData(psa);
      
         return true;
      }
      else
      {
         //There is no account with this SAM name in this domain
         err.SysMsgWrite(ErrE, 2, DCT_MSG_PATH_NOT_FOUND_SS, pAcct->GetName(), pOptions->tgtDomain);
         Mark(L"errors", pAcct->GetType());
         SafeArrayUnaccessData(psa);
      }

   }

   return false;
}

//--------------------------------------------------------------------------
// AcctReplFullPath : Fills up Account node when the account information
//                 coming in is a LDAP sub path.
//--------------------------------------------------------------------------
bool CAcctRepl::AcctReplFullPath(                              
                                    TAcctReplNode * pAcct,  //in- AccountReplicator Node with the Account info
                                    Options * pOptions      //in- Options set by the user.
                                )
{
   WCHAR                     sName[LEN_Path];
   WCHAR                     sPath[LEN_Path];
   IADs                    * pAds;
   _variant_t                var;

   // Build a full path and save it to the Account node
   wsprintf(sPath, L"LDAP://%s/%s,%s", pOptions->srcDomain, pAcct->GetName(), pOptions->srcNamingContext);
   pAcct->SetSourcePath(sPath);

   // Do the same for Target account.
   wcscpy(sName, pAcct->GetTargetName());
   if ( !wcslen(sName) ) 
   {
      // Since Target name not specified we will go ahead and use the source name as the target name,
      wcscpy(sName, pAcct->GetName());
      pAcct->SetTargetName(sName);
   }

   // Build a full path from the sub path
/*   wsprintf(sPath, L"LDAP://%s/%s,%s", pOptions->tgtDomain, sName, pOptions->tgtNamingContext);
   pAcct->SetTargetPath(sPath);
*/
   // Lets try and get the SAM name for the source account
   HRESULT hr = ADsGetObject(const_cast<WCHAR*>(pAcct->GetSourcePath()), IID_IADs, (void**) &pAds);
   if ( FAILED(hr)) return false;

   hr = pAds->Get(L"sAMAccountName", &var);
   pAds->Release();
   if ( SUCCEEDED(hr) )
      pAcct->SetSourceSam((WCHAR*)var.bstrVal);

   // SAM account name for the target account
   // Since we are here we have a LDAP sub path. So we can copy string from 3rd character to end of line or
   // till the first ','
   wcscpy(sName, pAcct->GetTargetName());
   WCHAR * p = wcschr(sName, L',');
   int ndx = wcslen(sName);
   if ( p )
   {
      // There is a , So we can find how many characters that is by subtracting two pointers
      ndx = (int)(p - sName);
   }
   ndx -= 3;   // We are going to ignore the first three characters
 
   // Copy from third character on to the , or End of line this is going to be the SAM name for target
   wcsncpy(sPath, sName + 3, ndx);
   sPath[ndx] = 0;   // Truncate it.
   pAcct->SetTargetSam(sPath);

   return true;
}

//--------------------------------------------------------------------------
// NeedToProcessAccount : This function tells us if the user has set the 
//                         options to copy certain types of accounts.
//--------------------------------------------------------------------------
BOOL CAcctRepl::NeedToProcessAccount(                               
                                       TAcctReplNode * pAcct,  //in- AccountReplicator Node with the Account info
                                       Options * pOptions      //in- Options set by the user.
                                    )
{
   if ((_wcsicmp(pAcct->GetType(), s_ClassUser) == 0) || (_wcsicmp(pAcct->GetType(), s_ClassInetOrgPerson) == 0))
      return (pOptions->flags & F_USERS);
   else if ( _wcsicmp(pAcct->GetType(), L"group") == 0)
      return ((pOptions->flags & F_GROUP) || (pOptions->flags & F_LGROUP));
   else if ( _wcsicmp(pAcct->GetType(), L"computer") == 0)
      return pOptions->flags & F_COMPUTERS;
   else if ( _wcsicmp(pAcct->GetType(), L"organizationalUnit") == 0)
      return pOptions->flags & F_OUS;
   else
   {
      err.MsgWrite(0,DCT_MSG_SKIPPING_OBJECT_TYPE_SS,pAcct->GetName(),pAcct->GetType());
      return false;
   }
}

// Compares the DC=...,DC=com part of two ads paths to determine if the objects
// are in the same domain.
BOOL CompareDCPath(WCHAR const * sPath, WCHAR const * sPath2)
{
   WCHAR                   * p1 = NULL, * p2 = NULL;
   p1 = wcsstr(sPath, L"DC=");
   p2 = wcsstr(sPath2, L"DC=");

   if ( p1 && p2 )
      return !_wcsicmp(p1, p2);
   else
      return FALSE;
}

_bstr_t  PadDN(_bstr_t sDN)
{
   _bstr_t retVal = sDN;
   int offset = 0;
   WCHAR sLine[LEN_Path];
   WCHAR sOut[LEN_Path];

   safecopy(sLine, (WCHAR*) sDN);

   for ( DWORD i = 0; i < wcslen(sLine); i++ )
   {
      if ( sLine[i] == L'/' )
      {
         sOut[i + offset] = L'\\';
         offset++;
      }
      sOut[i + offset] = sLine[i];
   }
   sOut[i+offset] = 0;
   retVal = sOut;
   return retVal;
}

//--------------------------------------------------------------------------
// ExpandContainers : Adds all the members of a container/group to the 
//                    account list recursively.
//--------------------------------------------------------------------------
BOOL CAcctRepl::ExpandContainers(
                                    TNodeListSortable *acctlist,     //in- Accounts being processed
                                    Options           *pOptions,     //in- Options specified by the user
                                    ProgressFn        *progress      //in- Show status
                                 )
{
   TAcctReplNode           * pAcct;
   IEnumVARIANT            * pEnum;
   HRESULT                   hr;
   _variant_t                var;
   DWORD                     dwf;
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   LPWSTR                    sCols[] = { L"member" };
   LPWSTR                    sCols1[] = { L"ADsPath" };
   int                       nElt = DIM(sCols);
   SAFEARRAY               * cols;
   SAFEARRAY               * vals;
   SAFEARRAY               * multiVals;
   SAFEARRAYBOUND            bd = { nElt, 0 };
   BSTR  HUGEP             * pData = NULL;
//   _bstr_t                 * pBstr = NULL;
   _variant_t              * pDt = NULL;
   _variant_t              * pVar = NULL;
   _variant_t                vx;
   _bstr_t                   sCont, sQuery;
   _bstr_t                   sPath;
   _bstr_t                   sSam; 
   _bstr_t                   sType;
   _bstr_t                   sName;
   _bstr_t                   sTgtName;
   DWORD                     dwMaj, dwMin, dwSP;
//   IIManageDBPtr             pDb(__uuidof(IManageDB));
   IVarSetPtr                pVs(__uuidof(VarSet));
   IUnknown                * pUnk;
   long                      lgrpType;
   WCHAR                     sAcctType[LEN_Path];
   WCHAR                     mesg[LEN_Path];
   WCHAR                     sSourcePath[LEN_Path];
   bool                      bExpanded = true;

   pVs->QueryInterface(IID_IUnknown, (void **) &pUnk);
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   
   // Change from a tree to a sorted list
   if ( acctlist->IsTree() ) acctlist->ToSorted();

   // Check the domain type for the source domain.
   hr = pAccess->raw_GetOsVersion(pOptions->srcComp, &dwMaj, &dwMin, &dwSP);
   if (FAILED(hr)) return FALSE;

   if ( dwMaj < 5 )
   {
      while ( bExpanded )
      {
         bExpanded = false;
         pAcct = (TAcctReplNode *)acctlist->Head();
         while (pAcct)
         {
            if ( pOptions->pStatus )
            {
               LONG                status = 0;
               HRESULT             hr = pOptions->pStatus->get_Status(&status);
   
               if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
               {
                  if ( !bAbortMessageWritten ) 
                  {
                     err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                     bAbortMessageWritten = true;
                  }
                  break;
               }
            }

            // If we have already expanded the account then we dont need to process it again.
            if ( pAcct->bExpanded )
            {
               pAcct = (TAcctReplNode *) pAcct->Next();
               continue;
            }

            //Set the flag to say that we expanded something.
            bExpanded = true;
            pAcct->bExpanded = true;

            if ( UStrICmp(pAcct->GetType(), L"group") || UStrICmp(pAcct->GetType(), L"lgroup") )
            {
               // Build the column array
               cols = SafeArrayCreate(VT_BSTR, 1, &bd);
               SafeArrayAccessData(cols, (void HUGEP **) &pData);
               for ( int i = 0; i < nElt; i++)
                  pData[i] = SysAllocString(sCols1[i]);
               SafeArrayUnaccessData(cols);
            
               // Build the NT4 recognizable container name
               sCont = _bstr_t(pAcct->GetName()) + L",CN=GROUPS";
               sQuery = L"";  // ignored.

               // Query the information
               hr = pQuery->raw_SetQuery(sCont, pOptions->srcDomain, sQuery, ADS_SCOPE_SUBTREE, TRUE);
               if (FAILED(hr)) return FALSE;
               hr = pQuery->raw_SetColumns(cols);
               if (FAILED(hr)) return FALSE;
               hr = pQuery->raw_Execute(&pEnum);
               if (FAILED(hr)) return FALSE;

               while (pEnum->Next(1, &var, &dwf) == S_OK)
               {
                  if ( pOptions->pStatus )
                  {
                     LONG                status = 0;
                     HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                     if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                     {
                        if ( !bAbortMessageWritten ) 
                        {
                           err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                           bAbortMessageWritten = true;
                        }
                        break;
                     }
                  }
                  vals = var.parray;
                  // Get the first column which is the name of the object.
                  SafeArrayAccessData(vals, (void HUGEP**) &pDt);
                  sPath = pDt[0];
                  SafeArrayUnaccessData(vals);

                  // Enumerator returns empty strings which we need to ignore.
                  if ( sPath.length() > 0 )
                  {
                     // Look if we have migrated the group
                     if ( pOptions->flags & F_COPY_MIGRATED_ACCT )
                        // We want to copy it again even if it was already copied.
                        hr = S_FALSE;
                     else
                        hr = pOptions->pDb->raw_GetAMigratedObject(sPath, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);

                     if ( hr != S_OK )
                     {
                        if ( !IsBuiltinAccount(pOptions, (WCHAR*)sPath) )
                        {
                           // We don't care about the objects that we have migrated because they will be picked up automatically
                           // Find the type of this account.
                           if ( GetNt4Type(pOptions->srcComp, (WCHAR*) sPath, sAcctType) )
                           {
                              // Expand the containers and the membership
                              wsprintf(mesg, GET_STRING(IDS_EXPANDING_ADDING_SS) , pAcct->GetName(), (WCHAR*) sPath);
                              Progress(mesg);
                              TAcctReplNode * pNode = new TAcctReplNode();
                              if (!pNode)
                                 return FALSE;
                              pNode->SetName((WCHAR*)sPath);
                              pNode->SetTargetName((WCHAR*)sPath);
                              pNode->SetSourceSam((WCHAR*)sPath);
                              pNode->SetTargetSam((WCHAR*)sPath);
                              pNode->SetType(sAcctType);
                              if ( !UStrICmp(sAcctType,L"group") )
                              {
                                 // in NT4, only global groups can be members of other groups
                                 pNode->SetGroupType(2);
                              }
                                 //Get the source domain sid from the user
                              pNode->SetSourceSid(pAcct->GetSourceSid());
                              // build a source WinNT path
                              wsprintf(sSourcePath, L"WinNT://%s/%s", pOptions->srcDomain, (WCHAR*)sPath);
                              pNode->SetSourcePath(sSourcePath);

                              if (acctlist->InsertIfNew(pNode))
                              {
                                 WCHAR szSam[LEN_Path];
                                 wcscpy(szSam, pNode->GetTargetSam());
                                 TruncateSam(szSam, pNode, pOptions, acctlist);
                                 pNode->SetTargetSam(szSam);
                                 AddPrefixSuffix(pNode, pOptions);
                              }
                              else
                              {
                                 delete pNode;
                              }
                           }
                           else
                           {
                              wsprintf(mesg,GET_STRING(IDS_EXPANDING_IGNORING_SS), pAcct->GetName(), (WCHAR*) sPath);
                              Progress(mesg);
                           }
                        }
                        else
                        {
                           err.MsgWrite(ErrW, DCT_MSG_IGNORING_BUILTIN_S, (WCHAR*)sPath);
                           Mark("warnings", pAcct->GetType());
                        }
                     }
                     else
                     {
                        wsprintf(mesg, GET_STRING(IDS_EXPANDING_IGNORING_SS), pAcct->GetName(), (WCHAR*) sPath);
                        Progress(mesg);
                     }
                  }
               }
               pEnum->Release();
               var.Clear();
            }
            pAcct = (TAcctReplNode *) pAcct->Next();
         }
      }
      pUnk->Release();
      return TRUE;
   }

   // If we are here that means that we are dealing with Win2k
   while ( bExpanded )   
   {
      bExpanded = false;
      // Go through the list of accounts and expand them one at a time
      pAcct = (TAcctReplNode *)acctlist->Head();
      while (pAcct)
      {
         // If we have already expanded the account then we dont need to process it again.
         if ( pAcct->bExpanded )
         {
            pAcct = (TAcctReplNode *) pAcct->Next();
            continue;
         }

         //Set the flag to say that we expanded something.
         bExpanded = true;
         pAcct->bExpanded = true;

         if ( pOptions->pStatus )
         {
            LONG                status = 0;
            HRESULT             hr = pOptions->pStatus->get_Status(&status);

            if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
            {
               if ( !bAbortMessageWritten ) 
               {
                  err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                  bAbortMessageWritten = true;
               }
               break;
            }
         }
         DWORD    scope = 0;
         sCont = pAcct->GetSourcePath();
         sQuery = L"(objectClass=*)";
         if ( wcslen(pAcct->GetSourceSam()) == 0 )
         {
            scope = ADS_SCOPE_SUBTREE;
            // Build the column array
            cols = SafeArrayCreate(VT_BSTR, 1, &bd);
            SafeArrayAccessData(cols, (void HUGEP **) &pData);
            for ( int i = 0; i < nElt; i++)
               pData[i] = SysAllocString(sCols1[i]);
            SafeArrayUnaccessData(cols);
         }
         else
         {
            scope = ADS_SCOPE_BASE;
            // Build the column array
            cols = SafeArrayCreate(VT_BSTR, 1, &bd);
            SafeArrayAccessData(cols, (void HUGEP **) &pData);
            for ( int i = 0; i < nElt; i++)
               pData[i] = SysAllocString(sCols[i]);
            SafeArrayUnaccessData(cols);
         }
      
         hr = pQuery->raw_SetQuery(sCont, pOptions->srcDomain, sQuery, scope, TRUE);
         if (FAILED(hr)) return FALSE;
         hr = pQuery->raw_SetColumns(cols);
         if (FAILED(hr)) return FALSE;
         hr = pQuery->raw_Execute(&pEnum);
         if (FAILED(hr)) return FALSE; 

         while (pEnum->Next(1, &var, &dwf) == S_OK)
         {
            if ( pOptions->pStatus )
            {
               LONG                status = 0;
               HRESULT             hr = pOptions->pStatus->get_Status(&status);
   
               if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
               {
                  if ( !bAbortMessageWritten ) 
                  {
                     err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                     bAbortMessageWritten = true;
                  }
                  break;
               }
            }
            vals = var.parray;
            // Get the VARIANT Array out
            SafeArrayAccessData(vals, (void HUGEP**) &pDt);
            vx = pDt[0];
            SafeArrayUnaccessData(vals);

            if ( vx.vt == VT_BSTR )
            {
               // We got back a BSTR which could be the value that we are looking for
               sPath = V_BSTR(&vx);
               // Enumerator returns empty strings which we need to ignore.
               if ( sPath.length() > 0 )
               {
                  if ( GetSamFromPath(sPath, sSam, sType, sName, sTgtName, lgrpType, pOptions)  && CompareDCPath((WCHAR*)sPath, pAcct->GetSourcePath()))
                  {
                     if ( pOptions->flags & F_COPY_MIGRATED_ACCT )
                        hr = S_FALSE;
                     else
                        hr = pOptions->pDb->raw_GetAMigratedObject(sSam, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);

                     if ( hr != S_OK )
                     {
                        // We don't care about the objects that we have migrated because they will be picked up automatically
                        if ( _wcsicmp((WCHAR*) sType, L"computer") != 0 )
                        {
                           TAcctReplNode * pNode = new TAcctReplNode();
                           if (!pNode)
                              return FALSE;
                           pNode->SetSourceSam((WCHAR*)sSam);
                           pNode->SetTargetSam((WCHAR*)sSam);
                           pNode->SetName((WCHAR*)sName);
                           pNode->SetTargetName((WCHAR*)sTgtName);
                           pNode->SetType((WCHAR*)sType);
                           pNode->SetSourcePath((WCHAR*)sPath);
                           pNode->SetGroupType(lgrpType);
                              //Get the source domain sid from the user
                           pNode->SetSourceSid(pAcct->GetSourceSid());

                           if (acctlist->InsertIfNew(pNode))
                           {
                              WCHAR szSam[LEN_Path];
                              TruncateSam(szSam, pNode, pOptions, acctlist);
                              pNode->SetTargetSam(szSam);
                              AddPrefixSuffix(pNode, pOptions);
                           }
                           else
                           {
                              delete pNode;
                           }

                           wsprintf(mesg, GET_STRING(IDS_EXPANDING_ADDING_SS), pAcct->GetName(), (WCHAR*) sSam);
                           Progress(mesg);
                        }
                        else
                        {
                           wsprintf(mesg, GET_STRING(IDS_EXPANDING_IGNORING_SS), pAcct->GetName(), (WCHAR*) sSam);
                           Progress(mesg);
                        }
                     }
                     else
                     {
                        wsprintf(mesg, GET_STRING(IDS_EXPANDING_IGNORING_SS), pAcct->GetName(), (WCHAR*) sSam);
                        Progress(mesg);
                     }
                  }
               }
   //            continue;
            }

   //         if (! ( vx.vt & VT_ARRAY ) )
   //            continue;
            if ( vx.vt & VT_ARRAY )
               // We must have got an Array of multivalued properties
               multiVals = vx.parray; 
            else
            {
               // We need to also process the accounts that have this group as its primary group.
               SAFEARRAYBOUND bd = { 0, 0 };
               multiVals = SafeArrayCreate(VT_VARIANT, 1, &bd);
            }
            AddPrimaryGroupMembers(pOptions, multiVals, const_cast<WCHAR*>(pAcct->GetTargetSam()));

            // Access the BSTR elements of this variant array
            SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
            for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
            {
               if ( pOptions->pStatus )
               {
                  LONG                status = 0;
                  HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                  if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                  {
                     if ( !bAbortMessageWritten ) 
                     {
                        err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                        bAbortMessageWritten = true;
                     }
                     break;
                  }
               }
               
               _bstr_t sDN = _bstr_t(pVar[dw]);
               sDN = PadDN(sDN);

               sPath = _bstr_t(L"LDAP://") + _bstr_t(pOptions->srcDomain) + _bstr_t(L"/") + sDN;
               if ( GetSamFromPath(sPath, sSam, sType, sName, sTgtName, lgrpType, pOptions)  && CompareDCPath((WCHAR*)sPath, pAcct->GetSourcePath()))
               {
                  if ( pOptions->flags & F_COPY_MIGRATED_ACCT ) 
                     hr = S_FALSE;
                  else
                     hr = pOptions->pDb->raw_GetAMigratedObject(sSam, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);

                  if ( hr != S_OK )
                  {
                     // We don't care about the objects that we have migrated because they will be picked up automatically
                     if ( _wcsicmp((WCHAR*) sType, L"computer") != 0 )
                     {
                        TAcctReplNode * pNode = new TAcctReplNode();
                        if (!pNode)
                           return FALSE;
                        pNode->SetSourceSam((WCHAR*)sSam);
                        pNode->SetTargetSam((WCHAR*)sSam);
                        pNode->SetName((WCHAR*)sName);
                        pNode->SetTargetName((WCHAR*)sTgtName);
                        pNode->SetType((WCHAR*)sType);
                        pNode->SetSourcePath((WCHAR*)sPath);
                        pNode->SetGroupType(lgrpType);
                           //Get the source domain sid from the user
                        pNode->SetSourceSid(pAcct->GetSourceSid());

                        if (acctlist->InsertIfNew(pNode))
                        {
                           WCHAR szSam[LEN_Path];
                           wcscpy(szSam, sSam);
                           TruncateSam(szSam, pNode, pOptions, acctlist);
                           pNode->SetTargetSam(szSam);
                           AddPrefixSuffix(pNode, pOptions);
                        }
                        else
                        {
                           delete pNode;
                        }

                        wsprintf(mesg, GET_STRING(IDS_EXPANDING_ADDING_SS), pAcct->GetName(), (WCHAR*) sSam);
                        Progress(mesg);
                     }
                     else
                     {
                        wsprintf(mesg, GET_STRING(IDS_EXPANDING_IGNORING_SS), pAcct->GetName(), (WCHAR*) sSam);
                        Progress(mesg);
                     }
                  }
                  else
                  {
                     wsprintf(mesg, GET_STRING(IDS_EXPANDING_IGNORING_SS), pAcct->GetName(), (WCHAR*) sSam);
                     Progress(mesg);
                  }
               }
            }
            SafeArrayUnaccessData(multiVals);
         }
         pEnum->Release();
         var.Clear();
         pAcct = (TAcctReplNode*)pAcct->Next();
      }
   }
   pUnk->Release();
   return TRUE;
}

//--------------------------------------------------------------------------
// IsContainer : Checks if the account in question is a container type
//               if it is then it returns a IADsContainer * to it.
//--------------------------------------------------------------------------
BOOL CAcctRepl::IsContainer(TAcctReplNode *pNode, IADsContainer **ppCont)
{
   HRESULT                   hr;
   hr = ADsGetObject(const_cast<WCHAR*>(pNode->GetSourcePath()), IID_IADsContainer, (void**)ppCont);
   return SUCCEEDED(hr);
}

BOOL CAcctRepl::GetSamFromPath(_bstr_t sPath, _bstr_t& sSam, _bstr_t& sType, _bstr_t& sSrcName, _bstr_t& sTgtName, long& grpType, Options * pOptions)
{
   HRESULT                   hr;
   IADsPtr                   pAds;
   BOOL                      bIsCritical = FALSE;
   BOOL                      rc = TRUE;

   sSam = L"";
   // Get the object so we can ask the questions from it.
   hr = ADsGetObject((WCHAR*)sPath, IID_IADs, (void**)&pAds);
   if ( FAILED(hr) ) return FALSE;

   if ( SUCCEEDED(hr))
   {
      VARIANT var;
      VariantInit(&var);
      hr = pAds->Get(L"isCriticalSystemObject", &var);
      if ( SUCCEEDED(hr) )
      {
         // This will only succeed for the Win2k objects.
         bIsCritical = (V_BOOL(&var) == VARIANT_TRUE) ? TRUE : FALSE;
         VariantClear(&var);
      }
      else
      {
         // This must be a NT4 account. We need to get the SID and check if
         // it's RID belongs to the BUILTIN rids.
         hr = pAds->Get(L"objectSID", &var);
         if ( SUCCEEDED(hr) )
         {
            SAFEARRAY * pArray = V_ARRAY(&var);
            PSID                 pSid;
            hr = SafeArrayAccessData(pArray, (void**)&pSid);
            if ( SUCCEEDED(hr) )
            {
               PUCHAR ucCnt = GetSidSubAuthorityCount(pSid);
               DWORD * rid = (DWORD *) GetSidSubAuthority(pSid, (*ucCnt)-1);
               bIsCritical = BuiltinRid(*rid);
               if ( bIsCritical ) 
               {
                  BSTR           sName;
                  hr = pAds->get_Name(&sName);
                  bIsCritical = CheckBuiltInWithNTApi(pSid, (WCHAR*)sName, pOptions);
                  SysFreeString(sName);
               }
               hr = SafeArrayUnaccessData(pArray);
            }
            VariantClear(&var);
         }
      }
   }

   // Get the class from the object. If it is a container/ou class then it will not have a SAM name so put the CN= or OU= into the list
   BSTR bstr = 0;
   hr = pAds->get_Class(&bstr);
   if ( FAILED(hr) ) rc = FALSE;

   if ( rc ) 
   {
      sType = _bstr_t(bstr, false);
   
      if (UStrICmp((WCHAR*) sType, L"organizationalUnit") == 0)
      {
         bstr = 0;
         hr = pAds->get_Name(&bstr);
         sSrcName = _bstr_t(L"OU=") + _bstr_t(bstr, false);
         sTgtName = sSrcName;
         sSam = L"";
         if ( FAILED(hr) ) rc = FALSE;
      }
      else if (UStrICmp((WCHAR*) sType, L"container") == 0)
      {
         bstr = 0;
         hr = pAds->get_Name(&bstr);
         sSrcName = _bstr_t(L"CN=") + _bstr_t(bstr, false);
         sTgtName = sSrcName;
         sSam = L"";
         if ( FAILED(hr) ) rc = FALSE;
      }
      else
      {
         bstr = 0;
         hr = pAds->get_Name(&bstr);
         sSrcName = _bstr_t(bstr, false);

         //if the name includes a '/', then we have to get the escaped version from the path
         //due to a bug in W2K.
         if (wcschr((WCHAR*)sSrcName, L'/'))
         {
            _bstr_t sCNName = GetCNFromPath(sPath);
            if (sCNName.length() != 0)
               sSrcName = sCNName;
         }

         // if inter-forest migration and source object is an InetOrgPerson then...

         if ((pOptions->bSameForest == FALSE) && (_wcsicmp(sType, s_ClassInetOrgPerson) == 0))
         {
            //
            // must use the naming attribute of the target forest
            //

            // retrieve naming attribute for this class in target forest

            SNamingAttribute naNamingAttribute;

            if (FAILED(GetNamingAttribute(pOptions->tgtDomainDns, s_ClassInetOrgPerson, naNamingAttribute)))
            {
               err.MsgWrite(ErrE, DCT_MSG_CANNOT_GET_NAMING_ATTRIBUTE_SS, s_ClassInetOrgPerson, pOptions->tgtDomainDns);
               Mark(L"errors", sType);
               return FALSE;
            }

            _bstr_t strNamingAttribute(naNamingAttribute.strName.c_str());

            // retrieve source attribute value

            VARIANT var;
            VariantInit(&var);

            if (FAILED(pAds->Get(strNamingAttribute, &var)))
            {
               err.MsgWrite(ErrE, DCT_MSG_CANNOT_GET_SOURCE_ATTRIBUTE_REQUIRED_FOR_NAMING_SSS, naNamingAttribute.strName.c_str(), sPath, pOptions->tgtDomainDns);
               Mark(L"errors", sType);
               return FALSE;
            }

            // set target naming attribute value from source attribute value

            sTgtName = strNamingAttribute + L"=" + _bstr_t(_variant_t(var, false));
         }
         else
         {
            // else set target name equal to source name
            sTgtName = sSrcName;
         }

         VARIANT var;
         VariantInit(&var);
         hr = pAds->Get(L"sAMAccountName", &var);
         if ( FAILED(hr)) rc = FALSE;
         sSam = _variant_t(var, false);
         if ( UStrICmp((WCHAR*) sType, L"group") == 0)
         {
            // we need to get and set the group type
            pAds->Get(L"groupType", &var);
            if ( SUCCEEDED(hr))
               grpType = _variant_t(var, false);              
         }
      }
      if ( bIsCritical )
      {
         // Builtin account so we are going to ignore this account. 
         //Don't log this message in IntraForest because we do mess with it
         // Also if it is a Domain Users group we add the migrated objects to it by default.
         if ( !pOptions->bSameForest && _wcsicmp((WCHAR*) sSam, pOptions->sDomUsers))    
         {
            err.MsgWrite(ErrW, DCT_MSG_IGNORING_BUILTIN_S, (WCHAR*)sPath);
            Mark(L"warnings", (WCHAR*) sType);
         }
         rc = FALSE;
      }
   }

   return rc;
}

//-----------------------------------------------------------------------------
// ExpandMembership : This method expands the account list to encorporate the
//                    groups that contain the members in the account list.
//-----------------------------------------------------------------------------
BOOL CAcctRepl::ExpandMembership(
                                 TNodeListSortable *acctlist,     //in- Accounts being processed
                                 Options           *pOptions,     //in- Options specified by the user
                                 TNodeListSortable *pNewAccts,    //out-The newly Added accounts.
                                 ProgressFn        *progress,     //in- Show status
                                 BOOL               bGrpsOnly,    //in- Expand for groups only
                                 BOOL               bAnySourceDomain //in- include groups from any domain (fix group membership)
                                 )
{
   TAcctReplNode           * pAcct;
   HRESULT                   hr = S_OK;
   _variant_t                var;
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   DWORD                     dwMaj, dwMin, dwSP;
   IVarSetPtr                pVs(__uuidof(VarSet));
   PSID                      pSid = NULL;
   SID_NAME_USE              use;
   DWORD                     dwNameLen = LEN_Path;
   DWORD                     dwDomName = LEN_Path;
   c_array<WCHAR>            achDomain(LEN_Path);
   c_array<WCHAR>            achDomUsers(LEN_Path);
   BOOL                      rc = FALSE;
   long                      lgrpType;
   c_array<WCHAR>            achMesg(LEN_Path);

   IUnknownPtr spUnknown(pVs);
   IUnknown* pUnk = spUnknown;

   // Change from a tree to a sorted list
   if ( acctlist->IsTree() ) acctlist->ToSorted();

   // Get the Domain Users group name
   pSid = GetWellKnownSid(DOMAIN_USERS, pOptions,FALSE);
   if ( pSid )
   {
      // since we have the well known SID now we can get its name
      if ( ! LookupAccountSid(pOptions->srcComp, pSid, achDomUsers, &dwNameLen, achDomain, &dwDomName, &use) )
         hr = HRESULT_FROM_WIN32(GetLastError());
      else
         wcscpy(pOptions->sDomUsers, achDomUsers);
      FreeSid(pSid);
   }

   // Check the domain type for the source domain.
   if ( SUCCEEDED(hr) )
      hr = pAccess->raw_GetOsVersion(pOptions->srcComp, &dwMaj, &dwMin, &dwSP);
   
   if ( SUCCEEDED(hr))
   {
      if ( dwMaj < 5 ) 
      {
         // NT4 objects we need to use NT API to get the groups that this account is a member of.

         LPGROUP_USERS_INFO_0            pBuf = NULL;
         DWORD                           dwLevel = 0;
         DWORD                           dwPrefMaxLen = 0xFFFFFFFF;
         DWORD                           dwEntriesRead = 0;
         DWORD                           dwTotalEntries = 0;
         NET_API_STATUS                  nStatus;
         c_array<WCHAR>                  achGrpName(LEN_Path);
         _bstr_t                         strType;
         BOOL                            bBuiltin;
         long                            numGroups = 0;

            //get a varset of previously migrated groups (we will need this if any accounts being migrated are groups
         hr = pOptions->pDb->raw_GetMigratedObjectByType(-1, _bstr_t(L""), _bstr_t(L"group"), &pUnk);
         if ( SUCCEEDED(hr) )
         {
               //get the num of objects in the varset
            numGroups = pVs->get(L"MigratedObjects");
         }

         m_IgnoredGrpMap.clear(); //clear the ignored group map used to optimize group fixup
            //for each account, enumerate its membership in any previously migrated groups
         for ( pAcct = (TAcctReplNode*)acctlist->Head(); pAcct; pAcct = (TAcctReplNode*)pAcct->Next())
         {
            if ( pOptions->pStatus )
            {
               LONG                status = 0;
               HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
               if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
               {
                  if ( !bAbortMessageWritten ) 
                  {
                     err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                     bAbortMessageWritten = true;
                  }
                  break;
               }
            }

               //if user
            if (!_wcsicmp(pAcct->GetType(), s_ClassUser) || !_wcsicmp(pAcct->GetType(), s_ClassInetOrgPerson))
            {
               //User object
               nStatus = NetUserGetGroups(pOptions->srcComp, pAcct->GetName(), 0, (LPBYTE*)&pBuf, dwPrefMaxLen, &dwEntriesRead, &dwTotalEntries );
               if (nStatus == NERR_Success)
               {
                  for ( DWORD i = 0; i < dwEntriesRead; i++ )
                  {
                     if ( pOptions->pStatus )
                     {
                        LONG                status = 0;
                        HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                        if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                        {
                           if ( !bAbortMessageWritten ) 
                           {
                              err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                              bAbortMessageWritten = true;
                           }
                           break;
                        }
                     }

                        //see if this group is in the acctlist and successfully migrated.  If so, then we 
                        //should not need to add this to the list.
                     Lookup      p;
                     p.pName = pBuf[i].grui0_name;
                     strType = L"group";
                     p.pType = strType;
                     TAcctReplNode * pFindNode = (TAcctReplNode *) acctlist->Find(&TNodeFindAccountName, &p);
                     if (pFindNode && (pFindNode->WasCreated() || pFindNode->WasReplaced()) && (bGrpsOnly))
                        continue;

                        //if we are doing group membership fixup, see if this group 
                        //is already in the new list we are creating.  If so, just add this member to the 
                        //member map for this group node.  This will save us the waste of 
                        //recalculating all the fields and save on memory.
                     pFindNode = NULL;
                     if ((!pOptions->expandMemberOf) || ((pOptions->expandMemberOf) && (bGrpsOnly)))
                     {
                        pFindNode = (TAcctReplNode *) pNewAccts->Find(&TNodeFindAccountName, &p);
                        if (pFindNode)
                        {
                           pFindNode->mapGrpMember.insert(CGroupMemberMap::value_type(pAcct->GetSourceSam(), pAcct->GetType()));
                           continue;
                        }
                     }

                        //we also want to avoid the slow code below if we are expanding users' groups for inclusion
                        //in the migration and that group has already been added to the new list by another user
                     pFindNode = NULL;
                     if ((pOptions->expandMemberOf) && (!bGrpsOnly))
                     {
                           //if already included by another user, move on to the next group for this user
                        pFindNode = (TAcctReplNode *) pNewAccts->Find(&TNodeFindAccountName, &p);
                        if (pFindNode)
                           continue;
                     }

                        //if this group has already been placed in the ignore map, continue on to
                        //the next group
                     CGroupNameMap::iterator        itGroupNameMap;
                     itGroupNameMap = m_IgnoredGrpMap.find(pBuf[i].grui0_name);
                        //if found, continue with the next group
                     if (itGroupNameMap != m_IgnoredGrpMap.end())
                        continue;

                     bBuiltin = IsBuiltinAccount(pOptions, pBuf[i].grui0_name);
                     // Ignore the Domain users group.
                     if ( (_wcsicmp(pBuf[i].grui0_name, achDomUsers) != 0) && !bBuiltin)
                     {
                        wsprintf(achMesg, GET_STRING(IDS_EXPANDING_GROUP_ADDING_SS), pAcct->GetName(), pBuf[i].grui0_name);
                        Progress(achMesg);
                        // This is the global group type by default
                        strType = L"group";
                        // Get the name of the group and add it to the list if it does not already exist in the list.
                        wcscpy(achGrpName, pBuf[i].grui0_name);

                        TAcctReplNode * pNode = new TAcctReplNode();
                        if (!pNode)
                           return FALSE;
                        // Source name stays as is
                        pNode->SetName(achGrpName);
                        pNode->SetSourceSam(achGrpName);
                        pNode->SetType(strType);
                        pNode->SetGroupType(2);
                        pNode->SetTargetName(achGrpName);
                           //Get the source domain sid from the user
                        pNode->SetSourceSid(pAcct->GetSourceSid());
                        // Look if we have migrated the group
                        hr = pOptions->pDb->raw_GetAMigratedObject(achGrpName, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
                        if ( hr == S_OK )
                        {
                           VerifyAndUpdateMigratedTarget(pOptions, pVs);

                           var = pVs->get(L"MigratedObjects.SourceAdsPath");
                           pNode->SetSourcePath(var.bstrVal);
                           //Get the target name and assign that to the node
                           var = pVs->get(L"MigratedObjects.TargetSamName");
                           pNode->SetTargetSam(V_BSTR(&var));
                           pNode->SetTargetName(V_BSTR(&var));
                           // Get the path too
                           var = pVs->get(L"MigratedObjects.TargetAdsPath");
                           pNode->SetTargetPath(V_BSTR(&var));
                           // Get the type too
                           var = pVs->get(L"MigratedObjects.Type");
                           strType = V_BSTR(&var);
                           pNode->SetType(strType);

                              //if they dont want to copy migrated objects, or they do but it was .
                           if (!(pOptions->flags & F_COPY_MIGRATED_ACCT))      
                           {
                              pNode->operations = 0;
                              pNode->operations |= OPS_Process_Members;
                              // Since the account has already been created we should go ahead and mark it created
                              // so that the processing of group membership can continue.
                              pNode->MarkCreated();
                           }
                              //else if already migrated, mark already there so that we fix group membership whether we migrate the group or not
                           else 
                           {
                              if (pOptions->flags & F_REPLACE)
                                 pNode->operations |= OPS_Process_Members;
                              else
                                 pNode->operations = OPS_Create_Account | OPS_Process_Members | OPS_Copy_Properties;
                              // We need to add the account to the list with the member map set so that we can add the
                              // member to the migrated group
                              pNode->mapGrpMember.insert(CGroupMemberMap::value_type(pAcct->GetSourceSam(), pAcct->GetType()));
                              pNode->MarkAlreadyThere();
                           }

                           if ( !pOptions->expandMemberOf )
                           {
                              // We need to add the account to the list with the member map set so that we can add the
                              // member to the migrated group
                              pNode->mapGrpMember.insert(CGroupMemberMap::value_type(pAcct->GetSourceSam(), pAcct->GetType()));
                              pNewAccts->Insert((TNode *) pNode);
                           }
                        }
                        else
                        {
                           // account has not been previously copied so we will set it up
                           if ( pOptions->expandMemberOf )
                           {
                              TruncateSam(achGrpName, pNode, pOptions, acctlist);
                              pNode->SetTargetSam(achGrpName);
                              FillPathInfo(pNode,pOptions);
                              AddPrefixSuffix(pNode, pOptions);
                           }
                           else
                           {
                              //if containing group has not been migrated, and was not to be migrated in this operation
                              //then we should add it to the ignore map in case it contains other objects currently
                              //being migrated.
                               m_IgnoredGrpMap.insert(CGroupNameMap::value_type((WCHAR*)achGrpName, strType));
                              delete pNode;
                           }
                        }
                        if ( pOptions->expandMemberOf )
                        {
                           if ( ! pNewAccts->InsertIfNew((TNode*) pNode) )
                              delete pNode;
                        }
                     }

                     if (bBuiltin)
                     {
                        // BUILTIN account error message
                        err.MsgWrite(ErrW, DCT_MSG_IGNORING_BUILTIN_S, pBuf[i].grui0_name);
                        Mark(L"warnings", pAcct->GetType());
                     }
                  }//end for each group
               }//if got groups
               if (pBuf != NULL)
                  NetApiBufferFree(pBuf);

               // Process local groups
               pBuf = NULL;
               dwLevel = 0;
               dwPrefMaxLen = 0xFFFFFFFF;
               dwEntriesRead = 0;
               dwTotalEntries = 0;
               DWORD dwFlags = 0 ;
               nStatus = NetUserGetLocalGroups(pOptions->srcComp, pAcct->GetName(), 0, dwFlags, (LPBYTE*)&pBuf, dwPrefMaxLen, &dwEntriesRead, &dwTotalEntries );
               if (nStatus == NERR_Success)
               {
                  for ( DWORD i = 0; i < dwEntriesRead; i++ )
                  {
                     if ( pOptions->pStatus )
                     {
                        LONG                status = 0;
                        HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                        if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                        {
                           if ( !bAbortMessageWritten ) 
                           {
                              err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                              bAbortMessageWritten = true;
                           }
                           break;
                        }
                     }

                        //see if this group is in the acctlist and successfully migrated.  If so, then we 
                        //should not need to add this to the list.
                     Lookup      p;
                     p.pName = pBuf[i].grui0_name;
                     strType = L"group";
                     p.pType = strType;
                     TAcctReplNode * pFindNode = (TAcctReplNode *) acctlist->Find(&TNodeFindAccountName, &p);
                     if (pFindNode && (pFindNode->WasCreated() || pFindNode->WasReplaced()) && (bGrpsOnly))
                        continue;

                        //if we are doing group membership fixup, see if this group 
                        //is already in the new list we are creating.  If so, just add this member to the 
                        //member map for this group node.  This will save us the waste of 
                        //recalculating all the fields and save on memory.
                     pFindNode = NULL;
                     if ((!pOptions->expandMemberOf) || ((pOptions->expandMemberOf) && (bGrpsOnly)))
                     {
                        pFindNode = (TAcctReplNode *) pNewAccts->Find(&TNodeFindAccountName, &p);
                        if (pFindNode)
                        {
                           pFindNode->mapGrpMember.insert(CGroupMemberMap::value_type(pAcct->GetSourceSam(), pAcct->GetType()));
                           continue;
                        }
                     }

                        //we also want to avoid the slow code below if we are expanding users' groups for inclusion
                        //in the migration and that group has already been added to the new list by another user
                     pFindNode = NULL;
                     if ((pOptions->expandMemberOf) && (!bGrpsOnly))
                     {
                           //if already included by another user, move on to the next group for this user
                        pFindNode = (TAcctReplNode *) pNewAccts->Find(&TNodeFindAccountName, &p);
                        if (pFindNode)
                           continue;
                     }

                        //if this group has already been placed in the ignore map, continue on to
                        //the next group
                     CGroupNameMap::iterator        itGroupNameMap;
                     itGroupNameMap = m_IgnoredGrpMap.find(pBuf[i].grui0_name);
                        //if found, continue with the next group
                     if (itGroupNameMap != m_IgnoredGrpMap.end())
                        continue;

                     if (!IsBuiltinAccount(pOptions, pBuf[i].grui0_name))
                     {
                        strType = L"group";
                        // Get the name of the group and add it to the list if it does not already exist in the list.
                        wcscpy(achGrpName, pBuf[i].grui0_name);
                        wsprintf(achMesg, GET_STRING(IDS_EXPANDING_GROUP_ADDING_SS), pAcct->GetName(), (WCHAR*)achGrpName);
                        Progress(achMesg);
                        TAcctReplNode * pNode = new TAcctReplNode();
                        if (!pNode)
                           return FALSE;
                        pNode->SetName(achGrpName);
                        pNode->SetSourceSam(achGrpName);
                        pNode->SetType(strType);
                        pNode->SetGroupType(4);
                        pNode->SetTargetName(achGrpName);
                           //Get the source domain sid from the user
                        pNode->SetSourceSid(pAcct->GetSourceSid());
                        // Look if we have migrated the group
                        hr = pOptions->pDb->raw_GetAMigratedObject(achGrpName, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
                        if ( hr == S_OK )
                        {
                           VerifyAndUpdateMigratedTarget(pOptions, pVs);

                           var = pVs->get(L"MigratedObjects.SourceAdsPath");
                           pNode->SetSourcePath(var.bstrVal);
                           //Get the target name and assign that to the node
                           var = pVs->get(L"MigratedObjects.TargetSamName");
                           pNode->SetTargetName(V_BSTR(&var));
                           pNode->SetTargetSam(V_BSTR(&var));
                           // Get the path too
                           var = pVs->get(L"MigratedObjects.TargetAdsPath");
                           pNode->SetTargetPath(V_BSTR(&var));
                           // Get the type too
                           var = pVs->get(L"MigratedObjects.Type");
                           strType = V_BSTR(&var);
                              //if they dont want to copy migrated objects, or they do but it was .
                           if (!(pOptions->flags & F_COPY_MIGRATED_ACCT))      
                           {
                              pNode->operations = 0;
                              pNode->operations |= OPS_Process_Members;
                              // Since the account has already been created we should go ahead and mark it created
                              // so that the processing of group membership can continue.
                              pNode->MarkCreated();
                           }
                              //else if already migrated, mark already there so that we fix group membership whether we migrate the group or not
                           else
                           {
                              if (pOptions->flags & F_REPLACE)
                                 pNode->operations |= OPS_Process_Members;
                              else
                                 pNode->operations = OPS_Create_Account | OPS_Process_Members | OPS_Copy_Properties;
                              // We need to add the account to the list with the member map set so that we can add the
                              // member to the migrated group
                              pNode->mapGrpMember.insert(CGroupMemberMap::value_type(pAcct->GetSourceSam(), pAcct->GetType()));
                              pNode->MarkAlreadyThere();
                           }

                           pNode->SetType(strType);
                           pNode->SetGroupType(4);
                           if ( !pOptions->expandMemberOf )
                           {
                              // We need to add the account to the list with the member map set so that we can add the
                              // member to the migrated group
                              pNode->mapGrpMember.insert(CGroupMemberMap::value_type(pAcct->GetSourceSam(), pAcct->GetType()));
                              pNewAccts->Insert((TNode *) pNode);
                           }
                        }//if migrated
                        else
                        {
                           // account has not been previously copied so we will set it up
                           if ( pOptions->expandMemberOf )
                           {
                              TruncateSam(achGrpName, pNode, pOptions, acctlist);
                              pNode->SetTargetSam(achGrpName);
                              FillPathInfo(pNode,pOptions);
                              AddPrefixSuffix(pNode, pOptions);
                           }
                           else
                           {
                              //if containing group has not been migrated, and was not to be migrated in this operation
                              //then we should add it to the ignore map in case it contains other objects currently
                              //being migrated.
                              m_IgnoredGrpMap.insert(CGroupNameMap::value_type((WCHAR*)achGrpName, strType));
                              delete pNode;
                           }
                        }
                        if ( pOptions->expandMemberOf )
                        {
                           if ( ! pNewAccts->InsertIfNew((TNode*) pNode) )
                           {
                              delete pNode;
                           }
                        }
                     }//end if not built-in
                     else
                     {
                        // BUILTIN account error message
                        err.MsgWrite(ErrW, DCT_MSG_IGNORING_BUILTIN_S, pBuf[i].grui0_name);
                        Mark(L"warnings", pAcct->GetType());
                     }
                  }//for each local group
               }//if any local groups
               if (pBuf != NULL)
                  NetApiBufferFree(pBuf);
            }//end if user and should expand

               //if global group, expand membership of previously migrated groups (don't need
               //to enumerate groups which local groups are members of since they cannot be 
               //placed in another group)
            if ((!_wcsicmp(pAcct->GetType(), L"group")) && (pAcct->GetGroupType() & 2))
            {
                  //for each previously migrated group, check for account as member
               for (long ndx = 0; ndx < numGroups; ndx++)
               {
                  _bstr_t          tgtAdsPath = L"";
                  WCHAR            text[MAX_PATH];
                  IADsGroupPtr     pGrp;
                  VARIANT_BOOL     bIsMem = VARIANT_FALSE;
                  _variant_t       var;

                     //check for abort
                  if ( pOptions->pStatus )
                  {
                     LONG                status = 0;
                     HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                     if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                     {
                        if ( !bAbortMessageWritten ) 
                        {
                           err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                           bAbortMessageWritten = true;
                        }
                        break;
                     }
                  }

                  /* since global groups cannot contain other groups on NT4, universal
                     groups did not exist on NT4.0, and both cannot contain members outside 
                     the forest, we can ignore them */
                     //get this previously migrated group's type
                  swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_Type));
                  _bstr_t sMOTGrpType = pVs->get(text);
                  if ((!wcscmp((WCHAR*)sMOTGrpType, L"ggroup")) || (!wcscmp((WCHAR*)sMOTGrpType, L"ugroup")))
                     continue;

                     //get this previously migrated group's target ADSPath
                  swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_TargetAdsPath));
                  tgtAdsPath = pVs->get(text);
                  if (!tgtAdsPath.length())
                     break;
                     
                     //connect to the previously migrated target group
                  hr = ADsGetObject(tgtAdsPath, IID_IADsGroup, (void**)&pGrp);
                  if (FAILED(hr))
                     continue;
                     //get that group's type                     
                  hr = pGrp->Get(L"groupType", &var);
                     //if that previously migrated group is a local group, see if this 
                     //account is a member
                  if ((SUCCEEDED(hr)) && (var.lVal & 4))
                  {
                        //get the source object's sid from the migrate objects table 
                        //(source AdsPath will not work)
                     WCHAR  strSid[MAX_PATH];
                     WCHAR  strRid[MAX_PATH];
                     DWORD  lenStrSid = DIM(strSid);
                     GetTextualSid(pAcct->GetSourceSid(), strSid, &lenStrSid);
                     _bstr_t sSrcDmSid = strSid;
                     _ltow((long)(pAcct->GetSourceRid()), strRid, 10);
                     _bstr_t sSrcRid = strRid;
                     if ((!sSrcDmSid.length()) || (!sSrcRid.length()))
                        continue;

                        //build an LDAP path to the src object in the group
                     _bstr_t sSrcSid = sSrcDmSid + _bstr_t(L"-") + sSrcRid;
                     _bstr_t sSrcLDAPPath = L"LDAP://";
                     sSrcLDAPPath += _bstr_t(pOptions->tgtComp + 2);
                     sSrcLDAPPath += L"/CN=";
                     sSrcLDAPPath += sSrcSid;
                     sSrcLDAPPath += L",CN=ForeignSecurityPrincipals,";
                     sSrcLDAPPath += pOptions->tgtNamingContext;
                        
                        //got the source LDAP path, now see if that account is in the group
                     hr = pGrp->IsMember(sSrcLDAPPath, &bIsMem);
                        //if it is a member, then add this groups to the list
                     if (SUCCEEDED(hr) && bIsMem)
                     {
                        _bstr_t sTemp;
                           //create a new node to add to the list
                        swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_SourceSamName));
                        sTemp = pVs->get(text);
                        wsprintf(achMesg, GET_STRING(IDS_EXPANDING_GROUP_ADDING_SS), pAcct->GetName(), (WCHAR*)sTemp);
                        Progress(achMesg);
                        TAcctReplNode * pNode = new TAcctReplNode();
                        if (!pNode)
                           return FALSE;
                        pNode->SetName(sTemp);
                        pNode->SetSourceSam(sTemp);
                        pNode->SetTargetName(sTemp);
                        pNode->SetGroupType(4);
                        pNode->SetTargetPath(tgtAdsPath);
                        swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_TargetSamName));
                        sTemp = pVs->get(text);
                        pNode->SetTargetSam(sTemp);
                        swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_SourceDomainSid));
                        sTemp = pVs->get(text);
                        pNode->SetSourceSid(SidFromString((WCHAR*)sTemp));
                        swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_SourceAdsPath));
                        sTemp = pVs->get(text);
                        pNode->SetSourcePath(sTemp);
                        swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_Type));
                        sTemp = pVs->get(text);
                        pNode->SetType(sTemp);
                        if ( !(pOptions->flags & F_COPY_MIGRATED_ACCT))
                        {
                           // Since the account already exists we can tell it just to update group memberships
                           pNode->operations = 0;
                           pNode->operations |= OPS_Process_Members;
                           // Since the account has already been created we should go ahead and mark it created
                           // so that the processing of group membership can continue.
                           pNode->MarkCreated();
                        }
                           // We need to add the account to the list with the member map set so that we can add the
                           // member to the migrated group
                        pNode->mapGrpMember.insert(CGroupMemberMap::value_type(pAcct->GetSourceSam(), pAcct->GetType()));
                        pNewAccts->Insert((TNode *) pNode);
                     }//end if local group has as member
                  }//end if local group
               }//end for each group
            }//end if global group
         }//for each account in the list
         m_IgnoredGrpMap.clear(); //clear the ignored group map used to optimize group fixup
      }//end if NT 4.0 objects
      else
      {
         // Win2k objects so we need to go to active directory and query the memberOf field of each of these objects and update the
         // list.
         INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
         LPWSTR                    sCols[] = { L"memberOf" };
         int                       nCols = DIM(sCols);
         SAFEARRAYBOUND            bd = { nCols, 0 };
         wstring                   strQuery;
         DWORD                     dwf = 0;

         //
         // In order to determine if an object is a member of a universal group outside of the source domain
         // it is necessary to query the memberOf attribute of the member in the global catalog. Querying
         // this attribute in the source domain only returns universal groups that are in the source domain.
         //
         // Only if universal groups have been migrated is it necessary to query the global catalog therefore
         // will query the migrated objects table to determine if any universal groups have been migrated. If
         // universal groups have been migrated then set query global catalog to true.
         //

         bool bQueryGlobalCatalog = false;
         _bstr_t strGlobalCatalogServer;

         IVarSetPtr spUniversalGroups(__uuidof(VarSet));
         IUnknownPtr spunkUniversalGroups(spUniversalGroups);
         IUnknown* punkUniversalGroups = spunkUniversalGroups;

         HRESULT hrUniversalGroups = pOptions->pDb->raw_GetMigratedObjectByType(
             -1L, _bstr_t(L""), _bstr_t(L"ugroup"), &punkUniversalGroups
         );

         if (SUCCEEDED(hrUniversalGroups))
         {
             long lCount = spUniversalGroups->get(L"MigratedObjects");

             if (lCount > 0)
             {
                 //
                 // If able to retrieve name of global catalog server in source forest
                 // then set query global catalog to true otherwise log error message
                 // as ADMT will be unable to fix-up group memberships for universal
                 // groups that are outside of the source domain.
                 //

                 DWORD dwError = GetGlobalCatalogServer4(pOptions->srcDomain, strGlobalCatalogServer);

                 if ((dwError == ERROR_SUCCESS) && (strGlobalCatalogServer.length() > 0))
                 {
                    bQueryGlobalCatalog = true;
                 }
                 else
                 {
                    err.SysMsgWrite(ErrW, HRESULT_FROM_WIN32(dwError), DCT_MSG_UNABLE_TO_QUERY_GROUPS_IN_GLOBAL_CATALOG_SERVER_S, pOptions->srcDomain);
                 }
             }
         }

         spunkUniversalGroups.Release();
         spUniversalGroups.Release();

         m_IgnoredGrpMap.clear(); //clear the ignored group map used to optimize group fixup
         for ( pAcct = (TAcctReplNode*)acctlist->Head(); pAcct; pAcct = (TAcctReplNode*)pAcct->Next())
         {
            if ( pOptions->pStatus )
            {
               LONG                status = 0;
               HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
               if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
               {
                  if ( !bAbortMessageWritten ) 
                  {
                     err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                     bAbortMessageWritten = true;
                  }
                  break;
               }
            }
            // Get the Accounts Primary group. This is not in the memberOf property for some reason.(Per Richard Ault in Firstwave NewsGroup)
            IADsPtr                   spADs;
            _variant_t                varRid;
            _bstr_t                   sPath;
            _bstr_t                   sSam;
            _bstr_t                   sType;
            _bstr_t                   sName;
            _bstr_t                   sTgtName;

            hr = ADsGetObject(const_cast<WCHAR*>(pAcct->GetSourcePath()), IID_IADs, (void**)&spADs);
            if ( SUCCEEDED(hr))
            {
               VARIANT var;
               VariantInit(&var);
               hr = spADs->Get(L"primaryGroupID", &var);
               varRid = _variant_t(var, false);
               spADs.Release();
            }
         
            if ( SUCCEEDED(hr) )
            {
               c_array<WCHAR>         achSam(LEN_Path);
               c_array<WCHAR>         achAcctName(LEN_Path);
               DWORD                  cbName = LEN_Path;
               SID_NAME_USE           sidUse;
               // Get the SID from the RID
               PSID sid = GetWellKnownSid(varRid.lVal, pOptions);
               // Lookup the sAMAccountNAme from the SID
               if ( LookupAccountSid(pOptions->srcComp, sid, achAcctName, &cbName, achDomain, &dwDomName, &sidUse) )
               {
                     //see if this group was not migrated due to a conflict, if so then
                     //we need to fix up this membership
                  bool bInclude = true;
                  Lookup p;
                  p.pName = (WCHAR*)sSam;
                  p.pType = (WCHAR*)sType;
                  TAcctReplNode * pFindNode = (TAcctReplNode *) acctlist->Find(&TNodeFindAccountName, &p);
                  if (pFindNode && (pFindNode->WasCreated() || pFindNode->WasReplaced()) && (bGrpsOnly))
                     bInclude = false;

                  // We have the SAM Account name for the Primary group so lets Fill the node and add it to the list.
                  // Ignore in case of the Domain Users group.
                  if ( varRid.lVal != DOMAIN_GROUP_RID_USERS)
                  {
                     TAcctReplNode * pNode = new TAcctReplNode();
                     if (!pNode)
                        return FALSE;
                     pNode->SetName(achAcctName);
                     pNode->SetTargetName(achAcctName);
                     pNode->SetSourceSam(achAcctName);
                     wcscpy(achSam, achAcctName);
                     TruncateSam(achSam, pNode, pOptions, acctlist);
                     pNode->SetTargetSam(achSam);
                     pNode->SetType(L"group");
                        //Get the source domain sid from the user
                     pNode->SetSourceSid(pAcct->GetSourceSid());
                     AddPrefixSuffix(pNode, pOptions);
                     FillPathInfo(pNode, pOptions);
                     // See if the object is migrated
                     hr = pOptions->pDb->raw_GetAMigratedObject(achAcctName, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
                     if ( hr == S_OK )
                     {
                        if ((!(pOptions->expandMemberOf) || ((pOptions->expandMemberOf) && ((!(pOptions->flags & F_COPY_MIGRATED_ACCT)) || (bInclude)))) ||
                             (!_wcsicmp(pAcct->GetType(), L"group")))
                        {
                           VerifyAndUpdateMigratedTarget(pOptions, pVs);

                           // Get the target name
                           sSam = pVs->get(L"MigratedObjects.TargetSamName");
                           pNode->SetTargetSam(sSam);
                           // Also Get the Ads path
                           sPath = pVs->get(L"MigratedObjects.TargetAdsPath");
                           pNode->SetTargetPath(sPath);
                           //set the target name based on the target adspath
                           pNode->SetTargetName(GetCNFromPath(sPath));
                           // Since the account is already copied we only want it to update its Group memberships
                           if (!(pOptions->flags & F_COPY_MIGRATED_ACCT))
                           {
                              pNode->operations = 0;
                              pNode->operations |= OPS_Process_Members;
                              // Since the account has already been created we should go ahead and mark it created
                              // so that the processing of group membership can continue.
                              pNode->MarkCreated();
                           }
                           else if (bInclude)//else if already migrated, mark already there so that we fix group membership whether we migrate the group or not
                           {
                              if (pOptions->flags & F_REPLACE)
                                 pNode->operations |= OPS_Process_Members;
                              else
                                 pNode->operations = OPS_Create_Account | OPS_Process_Members | OPS_Copy_Properties;
                              pNode->MarkAlreadyThere();
                           }

                           if ((!pOptions->expandMemberOf) || (!_wcsicmp(pAcct->GetType(), L"group")) || (bInclude))
                           {
                              // We need to add the account to the list with the member map set so that we can add the
                              // member to the migrated group
                              pNode->mapGrpMember.insert(CGroupMemberMap::value_type(pAcct->GetSourceSam(), pAcct->GetType()));
                              pNewAccts->Insert((TNode *) pNode);
                           }
                        }
                     }
                     else if ( !pOptions->expandMemberOf )
                     {
                        delete pNode;
                     }
                     if (( pOptions->expandMemberOf ) && (_wcsicmp(pAcct->GetType(), L"group")))
                     {
                        if ( ! pNewAccts->InsertIfNew(pNode) )
                           delete pNode;
                     }
                  }
               }
               if ( sid )
                  FreeSid(sid);
            }

            //
            // If the global catalog needs to be queried then two queries will be performed otherwise
            // only one query will be performed in the source domain.
            //
            // The first iteration queries the memberOf attribute of the object in the source domain
            // to retrieve the local, global and universal groups in the source domain that the object
            // is a member of.
            //
            // The second iteration queries the memberOf attribute of the object in the global catalog
            // to retrieve all of the universal groups in the forest that the object is a member of.
            //
            // Note that if the global catalog is in the source domain that the second query will retrieve
            // all of the groups in the source domain again. Also the second query will always return
            // universal groups from the source domain that have already been retrieved during the first
            // query. Duplicate groups are not added to the list.
            //

            int cQuery = bQueryGlobalCatalog ? 2 : 1;

            for (int nQuery = 0; nQuery < cQuery; nQuery++)
            {
                IEnumVARIANTPtr spEnum;

                // Build query stuff

                strQuery = L"(&(sAMAccountName=";
                strQuery += pAcct->GetSourceSam();

                if (!_wcsicmp(pAcct->GetType(), s_ClassUser))
                   strQuery += L")(objectCategory=Person)(objectClass=user))";
                else if (!_wcsicmp(pAcct->GetType(), s_ClassInetOrgPerson))
                   strQuery += L")(objectCategory=Person)(objectClass=inetOrgPerson))";
                else
                   strQuery += L")(objectCategory=Group))";

                SAFEARRAY* psaCols = SafeArrayCreate(VT_BSTR, 1, &bd);
                BSTR* pData;
                SafeArrayAccessData(psaCols, (void**)&pData);
                for ( int i = 0; i < nCols; i++ )
                   pData[i] = SysAllocString(sCols[i]);
                SafeArrayUnaccessData(psaCols);

                //
                // Query the source domain on the first iteration then
                // query the global catalog on the second iteration.
                //

                _bstr_t strContainer;

                if (nQuery == 0)
                {
                    strContainer = pAcct->GetSourcePath();
                }
                else
                {
                    //
                    // Constuct an ADsPath from the source object's ADsPath by specifying
                    // the GC provider instead of the LDAP provider and specifying the
                    // forest DNS name for the server instead of the source domain name.
                    //
                    // The forest DNS name must be specified so that the entire forest
                    // may be queried otherwise only the specified domain is queried.
                    //

                    BSTR bstr = NULL;

                    IADsPathnamePtr spOldPathname(CLSID_Pathname);

                    spOldPathname->Set(_bstr_t(pAcct->GetSourcePath()), ADS_SETTYPE_FULL);

                    IADsPathnamePtr spNewPathname(CLSID_Pathname);

                    // specify global catalog

                    spNewPathname->Set(_bstr_t(L"GC"), ADS_SETTYPE_PROVIDER);

                    // specify the source global catalog server

                    spNewPathname->Set(strGlobalCatalogServer, ADS_SETTYPE_SERVER);

                    // specify source object DN

                    spOldPathname->Retrieve(ADS_FORMAT_X500_DN, &bstr);
                    spNewPathname->Set(_bstr_t(bstr, false), ADS_SETTYPE_DN);

                    // retrieve ADsPath to source object in global catalog

                    spNewPathname->Retrieve(ADS_FORMAT_X500, &bstr);
                    strContainer = _bstr_t(bstr, false);
                }

                // Tell the object to run the query and report back to us
                hr = pQuery->raw_SetQuery(strContainer, _bstr_t(pOptions->srcDomain), _bstr_t(strQuery.c_str()), ADS_SCOPE_BASE, TRUE);
                if (FAILED(hr)) return FALSE;
                hr = pQuery->raw_SetColumns(psaCols);
                if (FAILED(hr)) return FALSE;
                hr = pQuery->raw_Execute(&spEnum);
                if (FAILED(hr)) return FALSE;
                SafeArrayDestroy(psaCols);

                VARIANT var;
                VariantInit(&var);

                while (spEnum->Next(1, &var, &dwf) == S_OK)
                {
                   _variant_t varMain(var, false);

                   if ( pOptions->pStatus )
                   {
                      LONG                status = 0;
                      HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                      if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                      {
                         if ( !bAbortMessageWritten ) 
                         {
                            err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                            bAbortMessageWritten = true;
                         }
                         break;
                      }
                   }
                   SAFEARRAY * vals = V_ARRAY(&varMain);
                   // Get the VARIANT Array out
                   VARIANT* pDt;
                   SafeArrayAccessData(vals, (void**) &pDt);
                   _variant_t vx = pDt[0];
                   SafeArrayUnaccessData(vals);
                   if ( vx.vt & VT_ARRAY )
                   {
                      // We must have got an Array of multivalued properties
                      // Access the BSTR elements of this variant array
                      SAFEARRAY * multiVals = vx.parray; 
                      VARIANT* pVar;
                      SafeArrayAccessData(multiVals, (void**) &pVar);
                      for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
                      {
                         if ( pOptions->pStatus )
                         {
                            LONG                status = 0;
                            HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                            if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                            {
                               if ( !bAbortMessageWritten ) 
                               {
                                  err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                                  bAbortMessageWritten = true;
                               }
                               break;
                            }
                         }

                         _bstr_t sDN = _bstr_t(V_BSTR(&pVar[dw]));
                         sDN = PadDN(sDN);

                         sPath = _bstr_t(L"LDAP://") + _bstr_t(pOptions->srcDomainDns) + _bstr_t(L"/") + sDN;
                     
                            //see if the RDN of this group is in the acctlist.  If so, then we should not need
                            //to add this to the list. I will do a find based on path and not name even though the
                            //list is sorted by name.  This should be fine since the list is not in tree form.
                         Lookup p;
                         p.pName = (WCHAR*)sPath;
                         sType = L"group";
                         p.pType = (WCHAR*)sType;
                         TAcctReplNode * pFindNode = (TAcctReplNode *) acctlist->Find(&TNodeFindAccountRDN, &p);
                         if (pFindNode && (pFindNode->WasCreated() || pFindNode->WasReplaced()) && ((bGrpsOnly) || (pOptions->expandContainers)))
                            continue;

                            //this group has already been placed in the ignore map, continue on to
                            //the next group
                         CGroupNameMap::iterator        itGroupNameMap;
                         itGroupNameMap = m_IgnoredGrpMap.find(sPath);
                            //if found, continue with the next group
                         if (itGroupNameMap != m_IgnoredGrpMap.end())
                            continue;
                     
                            //if we are doing group membership fixup, see if the RDN of this group 
                            //is already in the new list we are creating.  If so, just add this member to the 
                            //member map for this group node.  This will save us the waste of 
                            //recalculating all the fields and save on memory.  (The compare is done based on the RDN which should 
                            //be fine since this list is a tree sorted based on type and RDN)
                         pFindNode = NULL;
                         if ((!pOptions->expandMemberOf) || ((pOptions->expandMemberOf) && (bGrpsOnly)))
                         {
                            pFindNode = (TAcctReplNode *) pNewAccts->Find(&TNodeFindAccountRDN, &p);
                            if (pFindNode)
                            {
                               pFindNode->mapGrpMember.insert(CGroupMemberMap::value_type(pAcct->GetSourceSam(), pAcct->GetType()));
                               continue;
                            }
                         }

                            //we also want to avoid the slow code below if we are expanding users' groups for inclusion
                            //in the migration and that group has already been added to the new list by another user
                         pFindNode = NULL;
                         if ((pOptions->expandMemberOf) && (!bGrpsOnly))
                         {
                               //if already included by another user, move on to the next group for this user
                            pFindNode = (TAcctReplNode *) pNewAccts->Find(&TNodeFindAccountRDN, &p);
                            if (pFindNode)
                               continue;
                         }
                         
                         if ((bAnySourceDomain || CompareDCPath(sPath, pAcct->GetSourcePath())) && GetSamFromPath(sPath, sSam, sType, sName, sTgtName, lgrpType, pOptions))
                         {
                            _bstr_t strSourceDomain;

                            if (bAnySourceDomain)
                            {
                                if (CompareDCPath(sPath, pAcct->GetSourcePath()))
                                {
                                    strSourceDomain = pOptions->srcDomain;
                                }
                                else
                                {
                                    strSourceDomain = GetDomainDNSFromPath(sPath);
                                }
                            }
                            else
                            {
                                strSourceDomain = pOptions->srcDomain;
                            }

                               //see if this group was not migrated due to a conflict, if so then
                               //we need to fix up this membership
                            bool bInclude = true;
                            p.pName = (WCHAR*)sSam;
                            p.pType = (WCHAR*)sType;
                            TAcctReplNode * pFindNode = (TAcctReplNode *) acctlist->Find(&TNodeFindAccountName, &p);
                            if (pFindNode && (pFindNode->WasCreated() || pFindNode->WasReplaced()) && (bGrpsOnly))
                               bInclude = false;

                            // Ignore the Domain users group and group already being migrated
                            if ((_wcsicmp(sSam, achDomUsers) != 0) && (bInclude))
                            {
                               wsprintf(achMesg, GET_STRING(IDS_EXPANDING_GROUP_ADDING_SS), pAcct->GetName(), (WCHAR*) sSam);
                               Progress(achMesg);
                               TAcctReplNode * pNode = new TAcctReplNode();
                               if (!pNode)
                                  return FALSE;
                               pNode->SetName(sName);
                               pNode->SetTargetName(sTgtName);
                               pNode->SetType(sType);
                               pNode->SetSourcePath(sPath);
                               pNode->SetSourceSam(sSam);
                               c_array<WCHAR> achSam(LEN_Path);
                               wcscpy(achSam, sSam);
                               TruncateSam(achSam, pNode, pOptions, acctlist);
                               pNode->SetTargetSam(achSam);
                                  //Get the source domain sid from the user
                               pNode->SetSourceSid(pAcct->GetSourceSid());
                               AddPrefixSuffix(pNode, pOptions);
                               pNode->SetGroupType(lgrpType);
                               // See if the object is migrated
                               hr = pOptions->pDb->raw_GetAMigratedObject((WCHAR*)sSam, strSourceDomain, pOptions->tgtDomain, &pUnk);
                               if ( hr == S_OK )
                               {
                                  if ((!(pOptions->expandMemberOf) || ((pOptions->expandMemberOf) && ((!(pOptions->flags & F_COPY_MIGRATED_ACCT)) || (bInclude)))) ||
                                      (!_wcsicmp(pAcct->GetType(), L"group")))
                                  {
                                     VerifyAndUpdateMigratedTarget(pOptions, pVs);

                                     // Get the target name
                                     sSam = pVs->get(L"MigratedObjects.TargetSamName");
                                     pNode->SetTargetSam(sSam);
                                     // Also Get the Ads path
                                     sPath = pVs->get(L"MigratedObjects.TargetAdsPath");
                                     pNode->SetTargetPath(sPath);
                                     //set the target name based on the target adspath
                                     pNode->SetTargetName(GetCNFromPath(sPath));
                                     // Since the account is already copied we only want it to update its Group memberships
                                     if (!(pOptions->flags & F_COPY_MIGRATED_ACCT))
                                     {
                                        pNode->operations = 0;
                                        pNode->operations |= OPS_Process_Members;
                                        // Since the account has already been created we should go ahead and mark it created
                                        // so that the processing of group membership can continue.
                                        pNode->MarkCreated();
                                     }
                                     else if (bInclude)//else if already migrated, mark already there so that we fix group membership whether we migrate the group or not
                                     {
                                        if (pOptions->flags & F_REPLACE)
                                           pNode->operations |= OPS_Process_Members;
                                        else
                                           pNode->operations = OPS_Create_Account | OPS_Process_Members | OPS_Copy_Properties;
                                        pNode->MarkAlreadyThere();
                                     }

                                     if ((!pOptions->expandMemberOf) || (!_wcsicmp(pAcct->GetType(), L"group")) || (bInclude))
                                     {
                                        // We need to add the account to the list with the member map set so that we can add the
                                        // member to the migrated group
                                        pNode->mapGrpMember.insert(CGroupMemberMap::value_type(pAcct->GetSourceSam(), pAcct->GetType()));
                                        pNewAccts->Insert((TNode *) pNode);
                                        pNode = NULL;
                                     }
                                  }
                               }
                               else if ( ! pOptions->expandMemberOf )
                               {
                                  //if containing group has not been migrated, and was not to be migrated in this operation
                                  //then we should add it to the ignore map in case it contains other objects currently
                                  //being migrated.  Store the path as the key so we don't have to call GetSamFromPath to 
                                  //see if we should ignore.
                                  m_IgnoredGrpMap.insert(CGroupNameMap::value_type(sPath, sSam));
                                  delete pNode;
                                  pNode = NULL;
                               }
                               if (pNode)
                               {
                                  if (( pOptions->expandMemberOf ) && (_wcsicmp(pAcct->GetType(), L"group")))
                                  {
                                     if (! pNewAccts->InsertIfNew(pNode) )
                                        delete pNode;
                                  }
                                  else
                                  {
                                     delete pNode;
                                  }
                               }
                            }
                         }
                      }
                      SafeArrayUnaccessData(multiVals);
                   }
                }
            }
         }//for each object being migrated

         m_IgnoredGrpMap.clear(); //clear the ignored group map used to optimize group fixup
      }
      rc = TRUE;
   }

   return rc;
}

HRESULT CAcctRepl::BuildSidPath(
                                 IADs  *       pAds,     //in- pointer to the object whose sid we are retrieving.
                                 WCHAR *       sSidPath, //out-path to the LDAP://<SID=###> object
                                 WCHAR *       sSam,     //out-Sam name of the object
                                 WCHAR *       sDomain,  //out-Domain name where this object resides.
                                 Options *     pOptions, //in- Options
                                 PSID        * ppSid      //out- pointer to the binary SID
                               )
{
    HRESULT                   hr = S_OK;
    DWORD                     cbName = LEN_Path, cbDomain = LEN_Path;
    PSID                      sid = NULL;
    SID_NAME_USE              use;
    _variant_t                var;

    if (!pAds)
        return E_POINTER;

    // Get the object's SID
    hr = pAds->Get(_bstr_t(L"objectSid"), &var);

    if ( SUCCEEDED(hr) )
    {
        sid = SafeCopySid((PSID)var.parray->pvData);

        if (sid)
        {
            if (LookupAccountSid(pOptions->srcComp, sid, sSam, &cbName, sDomain, &cbDomain, &use))
            {
                //
                // If SID type is domain then the object has the same name as the domain. There is
                // a known issue with the WinNT provider where the ObjectSid attribute is returned
                // incorrectly for objects that have the same name as the the domain. The WinNT
                // provider code passes only the account name to LookupAccountName and not the
                // complete NT4 format name which includes the domain. Therefore LookupAccountName
                // correctly returns the SID for the domain and not the account.
                //
                // This situation is detected by looking at the SID type which will be domain in
                // this case. If this is the case then retrieve the correct account SID by using the
                // complete NT4 account name format. The SAM name is filled in from the path.
                //

                if (use == SidTypeDomain)
                {
                    //
                    // Retrieve path of object.
                    //

                    BSTR bstr = NULL;
                    hr = pAds->get_ADsPath(&bstr);

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Retrieve only name component of path.
                        //

                        CADsPathName pnPathName(_bstr_t(bstr, false), ADS_SETTYPE_FULL);
                        _bstr_t strName = pnPathName.Retrieve(ADS_FORMAT_LEAF);

                        if ((PCWSTR)strName)
                        {
                            //
                            // The name component is the SAM name.
                            //

                            wcsncpy(sSam, strName, LEN_Path);
                            sSam[LEN_Path - 1] = L'\0';

                            //
                            // Construct the complete NT4 name.
                            //

                            _bstr_t strNT4Name = sDomain;
                            strNT4Name += _T("\\");
                            strNT4Name += strName;

                            //
                            // Get size of buffer required for SID.
                            //

                            DWORD cbSid = 0;
                            cbDomain = LEN_Path;

                            LookupAccountName(
                                pOptions->srcComp,
                                strNT4Name,
                                NULL,
                                &cbSid,
                                sDomain,
                                &cbDomain,
                                &use
                            );

                            //
                            // The last error should be insufficient buffer size.
                            //

                            DWORD dwError = GetLastError();

                            if (dwError == ERROR_INSUFFICIENT_BUFFER)
                            {
                                // Create buffer for SID.

                                var.Clear();
                                var.parray = SafeArrayCreateVector(VT_UI1, 0, cbSid);

                                if (var.parray)
                                {
                                    var.vt = VT_ARRAY|VT_UI1;
                                    cbDomain = LEN_Path;

                                    //
                                    // Retrieve correct account SID.
                                    //

                                    BOOL bLookup = LookupAccountName(
                                        pOptions->srcComp,
                                        strNT4Name,
                                        var.parray->pvData,
                                        &cbSid,
                                        sDomain,
                                        &cbDomain,
                                        &use
                                    );

                                    if (bLookup)
                                    {
                                        FreeSid(sid);
                                        sid = SafeCopySid((PSID)var.parray->pvData);
                                    }
                                    else
                                    {
                                        DWORD dwError = GetLastError();
                                        hr = HRESULT_FROM_WIN32(dwError);
                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            else
                            {
                                hr = HRESULT_FROM_WIN32(dwError);
                            }
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    //
                    // Construct SID path string.
                    //

                    VariantSidToString(var);
                    _bstr_t strSid = var;

                    if ((PCWSTR)strSid)
                    {
                        wcscpy(sSidPath, L"LDAP://<SID=");
                        wcscat(sSidPath, (PCWSTR)strSid);
                        wcscat(sSidPath, L">");
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
            }
            else
            {
                DWORD dwError = GetLastError();
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }
        else
        {
            DWORD dwError = GetLastError();
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }

    if ( SUCCEEDED(hr) )
    {
        (*ppSid) = sid;
    }
    else
    {
        if (sid)
        {
            FreeSid(sid);
        }

        (*ppSid) = NULL;
    }

    return hr;
}

BOOL
   CAcctRepl::CanMoveInMixedMode(TAcctReplNode *pAcct,TNodeListSortable * acctlist, Options * pOptions)
{
    HRESULT                         hr = S_OK;
    BOOL                            ret = TRUE;
    IADsGroup                     * pGroup = NULL;
    IADsMembers                   * pMembers = NULL;
    IEnumVARIANT                  * pEnum = NULL;
    IDispatch                     * pDisp = NULL;
    IADs                          * pAds = NULL;
    _bstr_t                         sSam;
    _variant_t                      vSam;
    BSTR                            sClass;
    IVarSetPtr                      pVs(__uuidof(VarSet));
    IUnknown                      * pUnk = NULL;


    pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
    // in case of a global group we need to check if we have/are migrating all the members. If we 
    // are then we can move it and if not then we need to use the parallel group theory.
    if ( pAcct->GetGroupType() & 2 )
    {
        // This is a global group. What we need to do now is to see if we have/will migrate all its members.
        // First enumerate the members.
        hr = ADsGetObject(const_cast<WCHAR*>(pAcct->GetSourcePath()), IID_IADsGroup, (void**)&pGroup);

        if ( SUCCEEDED(hr) )
            hr = pGroup->Members(&pMembers);

        if (SUCCEEDED(hr)) 
            hr = pMembers->get__NewEnum((IUnknown**)&pEnum);

        if ( SUCCEEDED(hr) )
        {
            _variant_t              var;
            DWORD                   fetch = 0;
            while ( pEnum->Next(1, &var, &fetch) == S_OK )
            {
                // Get the sAMAccount name from the object so we can do the lookups
                pDisp = V_DISPATCH(&var);
                hr = pDisp->QueryInterface(IID_IADs, (void**)&pAds);

                if (SUCCEEDED(hr))
                    hr = pAds->Get(L"sAMAccountName", &vSam);

                if (SUCCEEDED(hr))
                    hr = pAds->get_Class(&sClass);

                if ( SUCCEEDED(hr))
                {
                    sSam = vSam;
                    // To see if we will migrate all its members check the account list.
                    Lookup                        lup;
                    lup.pName = (WCHAR*) sSam;
                    lup.pType = (WCHAR*) sClass;

                    TAcctReplNode * pNode = (TAcctReplNode*)acctlist->Find(&TNodeFindAccountName, &lup);
                    if ( !pNode )     
                    {
                        // This member is not in the account list therefore cannot move this group.
                        ret = FALSE;
                        err.MsgWrite(0,DCT_MSG_CANNOT_MOVE_GG_FROM_MIXED_MODE_SS,pAcct->GetSourceSam(),(WCHAR*)sSam);
                        break;      
                    }
                }
            }
            if ( pEnum ) pEnum->Release();
            if ( pAds ) pAds->Release();
            if ( pGroup ) pGroup->Release();
            if ( pMembers ) pMembers->Release();
        }
    }
    else
    // Local groups can be moved, if all of their members are removed first
        ret = TRUE;

    return ret;
}

HRESULT 
   CAcctRepl::CheckClosedSetGroups(
      Options              * pOptions,          // in - options for the migration
      TNodeListSortable    * pAcctList,         // in - list of accounts to migrate
      ProgressFn           * progress,          // in - progress function to display progress messages
      IStatusObj           * pStatus            // in - status object to support cancellation
   )
{
    HRESULT        hr = S_OK;
    TNodeListEnum  e;
    TAcctReplNode* pAcct;

    if ( pAcctList->IsTree() ) 
        pAcctList->ToSorted();

    for ( pAcct = (TAcctReplNode*)e.OpenFirst(pAcctList) ; pAcct ; pAcct = (TAcctReplNode*)e.Next() )
    {
        if ( (pAcct->operations & OPS_Create_Account ) == 0 )
            continue;

        if ( !UStrICmp(pAcct->GetType(),s_ClassUser) || !UStrICmp(pAcct->GetType(),s_ClassInetOrgPerson) )
        {
            // users, we will always move
            err.MsgWrite(0,DCT_MSG_USER_WILL_BE_MOVED_S,pAcct->GetName());
            pAcct->operations = OPS_Move_Object | OPS_Call_Extensions;
        }
        else if (! UStrICmp(pAcct->GetType(),L"group") )
        {
            if ( CanMoveInMixedMode(pAcct,pAcctList,pOptions) )
            {
                pAcct->operations = OPS_Move_Object | OPS_Call_Extensions;
                err.MsgWrite(0,DCT_MSG_GROUP_WILL_BE_MOVED_S,pAcct->GetName());
            }
            else
            {
                hr = S_FALSE;
            }
        }
        else
        {
            err.MsgWrite(0,DCT_MSG_CANT_MOVE_UNKNOWN_TYPE_SS,pAcct->GetName(), pAcct->GetType());
        }
    }
    e.Close();

    pAcctList->SortedToTree();

    return hr;
}

void LoadNecessaryFunctions()
{
   HMODULE hPro = LoadLibrary(L"advapi32.dll");
   if ( hPro )
      ConvertStringSidToSid = (TConvertStringSidToSid)GetProcAddress(hPro, "ConvertStringSidToSidW");
   else
   {
      err.SysMsgWrite(ErrE, GetLastError(), DCT_MSG_LOAD_LIBRARY_FAILED_SD, L"advapi32.dll");
      Mark(L"errors", L"generic");
   }
}
//---------------------------------------------------------------------------------------------------------
// MoveObj2k - This function moves objects within a forest.
//---------------------------------------------------------------------------------------------------------
int CAcctRepl::MoveObj2K( 
                           Options              * pOptions,    //in -Options that we recieved from the user
                           TNodeListSortable    * acctlist,    //in -AcctList of accounts to be copied.
                           ProgressFn           * progress,    //in -Progress Function to display messages
                           IStatusObj           * pStatus      // in -status object to support cancellation
                        )
{
    HRESULT  hr = S_OK;

    MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
    IObjPropBuilderPtr pClass(__uuidof(ObjPropBuilder));
    TNodeListSortable pMemberOf, pMember;
    c_array<WCHAR> achMesg(LEN_Path);

    LoadNecessaryFunctions();
    FillNamingContext(pOptions);

    // Make sure we are connecting to the DC that has RID Pool Allocator FSMO role.

    hr = GetRidPoolAllocator(pOptions);

    if (FAILED(hr))
    {
        return hr;
    }

    // Since we are in the same forest we need to turn off the AddSidHistory functionality.
    // because it is always going to fail.
    pOptions->flags &= ~F_AddSidHistory;

    BOOL bSrcNative = false;
    BOOL bTgtNative = false;
    _variant_t var;
    _bstr_t sTargetDomain = pOptions->tgtDomain;

    pAccess->raw_IsNativeMode(pOptions->srcDomain, (long*)&bSrcNative);
    pAccess->raw_IsNativeMode(pOptions->tgtDomain, (long*)&bTgtNative);

    IMoverPtr      pMover(__uuidof(Mover));
    TNodeTreeEnum  e;

    // build the source and target DSA names
    _bstr_t              sourceDSA;
    _bstr_t              targetDSA;
    TAcctReplNode      * pAcct = NULL;
    sourceDSA = pOptions->srcCompDns;
    targetDSA = pOptions->tgtCompDns;

    err.LogClose();
    // In this call the fourth parameter is the log file name. We are piggy backing this value
    // so that we will not have to change the interface for the IMover object.

    hr = pMover->raw_Connect(sourceDSA, targetDSA, pOptions->authDomain, 
        pOptions->authUser, pOptions->authPassword, pOptions->logFile, L"", L"");

    err.LogOpen(pOptions->logFile, 1);
    if ( SUCCEEDED(hr) )
    {
        // make sure the account list is in the proper format
        if (acctlist->IsTree()) acctlist->ToSorted();
        acctlist->CompareSet(&TNodeCompareAccountType);

        // sort the account list by Source Type\Source Name
        if ( acctlist->IsTree() ) acctlist->ToSorted();
        acctlist->CompareSet(&TNodeCompareAccountType);

        acctlist->SortedToScrambledTree();
        acctlist->Sort(&TNodeCompareAccountType);
        acctlist->Balance();

        pMemberOf.CompareSet(&TNodeCompareMember);
        pMember.CompareSet(&TNodeCompareMember);

        /* The account list is sorted in descending order by type, then in ascending order by object name
        this means that the user accounts will be moved first.
        Here are the steps we will perform for native mode MoveObject.
        1.  For each object to be copied, Remove (and record) the group memberships
        2.    If the object is a group, convert it to universal (to avoid having to remove any members that are not 
        being migrated.
        3.    Move the object.

        4.  For each migrated group that was converted to a universal group, change it back to its original 
        type, if possible.
        5.  Restore the group memberships for all objects.

        Here are the steps we will perform for mixed mode MoveObject
        1.  If closed set is not achieved, copy the groups, rather than moving them
        2.  For each object to be copied, Remove (and record) the group memberships
        3.    If the object is a group, remove all of its members
        4.    Move the object.

        5.  For each migrated group try to add all of its members back 
        6.  Restore the group memberships for all objects.
        */

        if ( ! bSrcNative )
        {
            //
            // If a closed-set is not achieved.
            //

            if (CheckClosedSetGroups(pOptions, acctlist, progress, pStatus) != S_OK)
            {
                bool bAllow = false;

                //
                // Check whether user has enabled non closed-set moves.
                //

                TRegKey key;

                if (key.Open(REGKEY_ADMT) == ERROR_SUCCESS)
                {
                    DWORD dwAllow = 0;

                    if (key.ValueGetDWORD(REGVAL_ALLOW_NON_CLOSEDSET_MOVE, &dwAllow) == ERROR_SUCCESS)
                    {
                        if (dwAllow)
                        {
                            bAllow = true;
                        }
                    }
                }

                //
                // If user has allowed non closed-set moves generate warning message as a reminder
                // that non closed-set moves are currently allowed otherwise generate error message
                // and throw exception to stop migration task.
                //

                if (bAllow)
                {
                    err.MsgWrite(ErrW, DCT_MSG_MOVE_NON_CLOSEDSET);
                }
                else
                {
                    Mark(L"errors", L"generic");
                    err.MsgWrite(ErrE, DCT_MSG_CANNOT_MOVE_NON_CLOSEDSET);
                    _com_issue_error(HRESULT_FROM_WIN32(ERROR_DS_CROSS_DOM_MOVE_ERROR));
                }
            }

            // this will copy any groups that cannot be moved from the source domain
            // if groups are copied in this fashion, SIDHistory cannot be used, and reACLing must be performed
            CopyObj2K(pOptions,acctlist,progress,pStatus);
        }

        // This is the start of the Move loop
        try { 
            for ( pAcct = (TAcctReplNode *)e.OpenFirst(acctlist); 
                pAcct; 
                pAcct = (TAcctReplNode *)e.Next() )
            {

                if ( m_pExt )
                {
                    if ( pAcct->operations & OPS_Call_Extensions )
                    {
                        m_pExt->Process(pAcct,sTargetDomain,pOptions,TRUE);
                    }
                }

                // Do we need to abort ?
                if ( pStatus )
                {
                    LONG                status = 0;
                    HRESULT             hr = pStatus->get_Status(&status);

                    if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                    {
                        if ( !bAbortMessageWritten ) 
                        {
                            err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                            bAbortMessageWritten = true;
                        }
                        break;
                    }
                }

                // in the mixed-mode case, skip any accounts that we've already copied
                if ( ! bSrcNative && ((pAcct->operations & OPS_Move_Object)==0 ) )
                    continue;

                if ( bSrcNative && 
                    ( (pAcct->operations & OPS_Create_Account)==0 ) 
                    )
                    continue;

                //if the UPN name conflicted, then the UPNUpdate extension set the hr to
                //ERROR_OBJECT_ALREADY_EXISTS.  If so, set flag for "no change" mode
                if (pAcct->GetHr() == ERROR_OBJECT_ALREADY_EXISTS)
                {
                    pAcct->bUPNConflicted = TRUE;
                    pAcct->SetHr(S_OK);
                }

                Mark(L"processed", pAcct->GetType());

                c_array<WCHAR> achMesg(LEN_Path);
                achMesg[0] = 0;
                if ( progress )
                    progress(achMesg);

                //
                // If updating of user rights is specified then retrieve list of rights
                // for source account before the object is moved as object deletion from
                // a domain will automatically remove rights in the domain if the domain
                // is .NET or later.
                //

                if (m_UpdateUserRights)
                {
                    HRESULT hrRights = EnumerateAccountRights(FALSE, pAcct);
                }

                // We need to remove this object from any global groups so that it can be moved.
                if ( ! pOptions->nochange )
                {
                    wsprintf(achMesg, (WCHAR*)GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBEROF_S), pAcct->GetName());
                    Progress(achMesg);
                    RecordAndRemoveMemberOf( pOptions, pAcct, &pMemberOf );
                }

                if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
                {
                    // First, record the group type, so we can change it back later if needed
                    IADsGroup * pGroup = NULL;
                    VARIANT     var;

                    VariantInit(&var);

                    // get the group type
                    hr = ADsGetObject( const_cast<WCHAR*>(pAcct->GetSourcePath()), IID_IADsGroup, (void**) &pGroup);
                    if (SUCCEEDED(hr) )
                    {
                        hr = pGroup->Get(L"groupType", &var);
                        pGroup->Release();
                    }
                    if ( SUCCEEDED(hr) ) 
                    {
                        pAcct->SetGroupType(var.lVal);
                    }
                    else
                    {
                        pAcct->SetGroupType(0);
                    }
                    // make sure it is native and group is a global group
                    if ( bSrcNative && bTgtNative )
                    {
                        if ( pAcct->GetGroupType() & 2) 
                        {
                            // We are going to convert the group type to universal groups so we can easily move them

                            wsprintf(achMesg, GET_STRING(DCT_MSG_CHANGE_GROUP_TYPE_S), pAcct->GetName());
                            Progress(achMesg);
                            // Convert global groups to universal, so we can move them without de-populating
                            if ( ! pOptions->nochange )
                            {
                                c_array<WCHAR> achPath(LEN_Path);
                                DWORD nPathLen = LEN_Path;
                                StuffComputerNameinLdapPath(achPath, nPathLen, const_cast<WCHAR*>(pAcct->GetSourcePath()), pOptions, FALSE);
                                hr = pClass->raw_ChangeGroupType(achPath, 8);
                                if (SUCCEEDED(hr))
                                {
                                    pAcct->MarkGroupScopeChanged();
                                }
                            }
                            else
                            {
                                hr = S_OK;
                            }
                            if (FAILED(hr)) 
                            {
                                err.SysMsgWrite(ErrE,hr,DCT_MSG_FAILED_TO_CONVERT_GROUP_TO_UNIVERSAL_SD, pAcct->GetSourceSam(), hr);
                                pAcct->MarkError();
                                Mark(L"errors", pAcct->GetType());
                                continue; // skip any further processing of this group.  
                            }
                        }
                        else  if ( ! ( pAcct->GetGroupType() & 8 ) ) // don't need to depopulate universal groups
                        {
                            // For local groups we are going to depopulate the group and move it and then repopulate it.
                            // In mixed mode, there are no universal groups, so we must depopulate all of the groups
                            // before we can move them out to the new domain. We will RecordAndRemove members of all Group type
                            // move them to the target domain and then change their type to Universal and then add all of its 
                            // members back to it.

                            wsprintf(achMesg, GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBER_S), pAcct->GetName());
                            Progress(achMesg);
                            RecordAndRemoveMember(pOptions, pAcct, &pMember);
                        }

                    }
                    else
                    {
                        // for mixed mode source domain, we must depopulate all of the groups
                        wsprintf(achMesg, GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBER_S), pAcct->GetName());
                        if ( progress )
                            progress(achMesg);
                        RecordAndRemoveMember(pOptions, pAcct, &pMember);
                    }

                }

                BOOL bObjectExists = DoesTargetObjectAlreadyExist(pAcct, pOptions);

                if ( bObjectExists )
                {
                    // The object exists, see if we need to rename
                    if ( wcslen(pOptions->prefix) > 0 )
                    {
                        // Add a prefix to the account name
                        c_array<WCHAR>      achTgt(LEN_Path);
                        c_array<WCHAR>      achPref(LEN_Path);
                        c_array<WCHAR>      achSuf(LEN_Path);
                        c_array<WCHAR>      achTempSam(LEN_Path);
                        _variant_t          varStr;


                        // find the '=' sign
                        wcscpy(achTgt, pAcct->GetTargetName());
                        for ( DWORD z = 0; z < wcslen(achTgt); z++ )
                        {
                            if ( achTgt[z] == L'=' ) break;
                        }

                        if ( z < wcslen(achTgt) )
                        {
                            // Get the prefix part ex.CN=
                            wcsncpy(achPref, achTgt, z+1);
                            achPref[z+1] = 0;
                            wcscpy(achSuf, achTgt+z+1);
                        }

                        // Build the target string with the Prefix
                        wsprintf(achTgt, L"%s%s%s", (WCHAR*)achPref, pOptions->prefix, (WCHAR*)achSuf);
                        pAcct->SetTargetName(achTgt);

                        // truncate to allow prefix/suffix to fit in 20 characters.
                        int resLen = wcslen(pOptions->prefix) + wcslen(pAcct->GetTargetSam());
                        if ( !_wcsicmp(pAcct->GetType(), L"computer") )
                        {
                            // Computer name can be only 15 characters long + $
                            if ( resLen > MAX_COMPUTERNAME_LENGTH + 1 )
                            {
                                c_array<WCHAR> achTruncatedSam(LEN_Path);
                                wcscpy(achTruncatedSam, pAcct->GetTargetSam());
                                if ( wcslen( pOptions->globalSuffix ) )
                                {
                                    // We must remove the global suffix if we had one.
                                    achTruncatedSam[wcslen(achTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                                }
                                int truncate = MAX_COMPUTERNAME_LENGTH + 1 - wcslen(pOptions->prefix) - wcslen(pOptions->globalSuffix);
                                if ( truncate < 1 ) truncate = 1;
                                wcsncpy(achTempSam, achTruncatedSam, truncate - 1);
                                achTempSam[truncate - 1] = L'\0';
                                wcscat(achTempSam, pOptions->globalSuffix);
                                wcscat(achTempSam, L"$");
                            }
                            else
                                wcscpy(achTempSam, pAcct->GetTargetSam());

                            // Add the prefix
                            wsprintf(achTgt, L"%s%s", pOptions->prefix,(WCHAR*)achTempSam);
                        }
                        else if ( !_wcsicmp(pAcct->GetType(), L"group") )
                        {
                            if ( resLen > 64 )
                            {
                                int truncate = 64 - wcslen(pOptions->prefix);
                                if ( truncate < 0 ) truncate = 0;
                                wcsncpy(achTempSam, pAcct->GetTargetSam(), truncate);
                                achTempSam[truncate] = L'\0';
                            }
                            else
                                wcscpy(achTempSam, pAcct->GetTargetSam());

                            // Add the prefix
                            wsprintf(achTgt, L"%s%s", pOptions->prefix,(WCHAR*)achTempSam);
                        }
                        else
                        {
                            if ( resLen > 20 )
                            {
                                c_array<WCHAR> achTruncatedSam(LEN_Path);
                                wcscpy(achTruncatedSam, pAcct->GetTargetSam());
                                if ( wcslen( pOptions->globalSuffix ) )
                                {
                                    // We must remove the global suffix if we had one.
                                    achTruncatedSam[wcslen(achTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                                }
                                int truncate = 20 - wcslen(pOptions->prefix) - wcslen(pOptions->globalSuffix);
                                if ( truncate < 0 ) truncate = 0;
                                wcsncpy(achTempSam, achTruncatedSam, truncate);
                                achTempSam[truncate] = L'\0';
                                wcscat(achTempSam, pOptions->globalSuffix);
                            }
                            else
                                wcscpy(achTempSam, pAcct->GetTargetSam());

                            // Add the prefix
                            wsprintf(achTgt, L"%s%s", pOptions->prefix,(WCHAR*)achTempSam);
                        }
                        pAcct->SetTargetSam(achTgt);
                        if ( DoesTargetObjectAlreadyExist(pAcct, pOptions) )
                        {
                            // Double collision lets log a message and forget about this account
                            pAcct->MarkAlreadyThere();
                            err.MsgWrite(ErrE, DCT_MSG_PREF_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
                            Mark(L"errors",pAcct->GetType());
                            continue;
                        }
                    }
                    else if ( wcslen(pOptions->suffix) > 0 )
                    {
                        // Add a suffix to the account name
                        c_array<WCHAR> achTgt(LEN_Path);
                        c_array<WCHAR> achTempSam(LEN_Path);

                        wsprintf(achTgt, L"%s%s", pAcct->GetTargetName(), pOptions->suffix);
                        pAcct->SetTargetName(achTgt);
                        //Update the sam account name
                        // truncate to allow prefix/suffix to fit in valid length
                        int resLen = wcslen(pOptions->suffix) + wcslen(pAcct->GetTargetSam());
                        if ( !_wcsicmp(pAcct->GetType(), L"computer") )
                        {
                            // Computer name can be only 15 characters long + $
                            if ( resLen > MAX_COMPUTERNAME_LENGTH + 1 )
                            {
                                c_array<WCHAR> achTruncatedSam(LEN_Path);
                                wcscpy(achTruncatedSam, pAcct->GetTargetSam());
                                if ( wcslen( pOptions->globalSuffix ) )
                                {
                                    // We must remove the global suffix if we had one.
                                    achTruncatedSam[wcslen(achTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                                }
                                int truncate = MAX_COMPUTERNAME_LENGTH + 1 - wcslen(pOptions->suffix) - wcslen(pOptions->globalSuffix);
                                if ( truncate < 1 ) truncate = 1;
                                wcsncpy(achTempSam, achTruncatedSam, truncate - 1);
                                achTempSam[truncate - 1] = L'\0';
                                wcscat(achTempSam, pOptions->globalSuffix);
                                wcscat(achTempSam, L"$");
                            }
                            else
                                wcscpy(achTempSam, pAcct->GetTargetSam());

                            // Add the suffix taking into account the $ sign
                            if ( achTempSam[wcslen(achTempSam) - 1] == L'$' )
                                achTempSam[wcslen(achTempSam) - 1] = L'\0';
                            wsprintf(achTgt, L"%s%s$", (WCHAR*)achTempSam, pOptions->suffix);
                        }
                        else if ( !_wcsicmp(pAcct->GetType(), L"group") )
                        {
                            if ( resLen > 64 )
                            {
                                int truncate = 64 - wcslen(pOptions->suffix);
                                if ( truncate < 0 ) truncate = 0;
                                wcsncpy(achTempSam, pAcct->GetTargetSam(), truncate);
                                achTempSam[truncate] = L'\0';
                            }
                            else
                                wcscpy(achTempSam, pAcct->GetTargetSam());

                            // Add the suffix.
                            wsprintf(achTgt, L"%s%s", (WCHAR*)achTempSam, pOptions->suffix);
                        }
                        else
                        {
                            if ( resLen > 20 )
                            {
                                c_array<WCHAR> achTruncatedSam(LEN_Path);
                                wcscpy(achTruncatedSam, pAcct->GetTargetSam());
                                if ( wcslen( pOptions->globalSuffix ) )
                                {
                                    // We must remove the global suffix if we had one.
                                    achTruncatedSam[wcslen(achTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                                }
                                int truncate = 20 - wcslen(pOptions->suffix) - wcslen(pOptions->globalSuffix);
                                if ( truncate < 0 ) truncate = 0;
                                wcsncpy(achTempSam, achTruncatedSam, truncate);
                                achTempSam[truncate] = L'\0';
                                wcscat(achTempSam, pOptions->globalSuffix);
                            }
                            else
                                wcscpy(achTempSam, pAcct->GetTargetSam());

                            // Add the suffix.
                            wsprintf(achTgt, L"%s%s", (WCHAR*)achTempSam, pOptions->suffix);
                        }
                        pAcct->SetTargetSam(achTgt);
                        if ( DoesTargetObjectAlreadyExist(pAcct, pOptions) )
                        {
                            // Double collision lets log a message and forget about this account
                            pAcct->MarkAlreadyThere();
                            err.MsgWrite(ErrE, DCT_MSG_PREF_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
                            Mark(L"errors",pAcct->GetType());
                            continue;
                        }
                    }
                    else
                    {
                        // if the skip existing option is specified, and the object exists in the target domain,
                        // we just skip it
                        err.MsgWrite(0, DCT_MSG_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
                        continue;
                    }
                }

                // If a prefix/suffix is added to the target sam name then we need to rename the account.
                // on the source domain and then move it to the target domain.
                if ( bObjectExists || (_wcsicmp(pAcct->GetSourceSam(), pAcct->GetTargetSam()) && !pOptions->bUndo ))
                {
                    // we need to rename the account to the target SAM name before we try to move it
                    // Get an ADs pointer to the account
                    IADs        * pADs = NULL;

                    c_array<WCHAR>      achPaths(LEN_Path);
                    DWORD               nPathLen = LEN_Path;

                    StuffComputerNameinLdapPath(achPaths, nPathLen, const_cast<WCHAR*>(pAcct->GetSourcePath()), pOptions, FALSE);
                    hr = ADsGetObject(achPaths,IID_IADs,(void**)&pADs);
                    if ( SUCCEEDED(hr) )
                    {
                        hr = pADs->Put(_bstr_t(L"sAMAccountName"),_variant_t(pAcct->GetTargetSam()));
                        if ( SUCCEEDED(hr) && !pOptions->nochange )
                        {
                            hr = pADs->SetInfo();
                            if ( SUCCEEDED(hr) )
                                err.MsgWrite(0,DCT_MSG_ACCOUNT_RENAMED_SS,pAcct->GetSourceSam(),pAcct->GetTargetSam());
                        }
                        if ( FAILED(hr) )
                        {
                            err.SysMsgWrite(ErrE,hr,DCT_MSG_RENAME_FAILED_SSD,pAcct->GetSourceSam(),pAcct->GetTargetSam(), hr);
                            Mark(L"errors",pAcct->GetType());
                        }
                        pADs->Release();
                    }
                }

                WCHAR  sName[MAX_PATH];
                DWORD  cbDomain = MAX_PATH, cbSid = MAX_PATH;
                PSID   pSrcSid = new BYTE[MAX_PATH];
                WCHAR  sDomain[MAX_PATH];
                SID_NAME_USE  use;

                if (!pSrcSid)
                    return ERROR_NOT_ENOUGH_MEMORY;

                // Get the source account's rid
                wsprintf(sName, L"%s\\%s", pOptions->srcDomain, pAcct->GetSourceSam());
                if (LookupAccountName(pOptions->srcComp, sName, pSrcSid, &cbSid, sDomain, &cbDomain, &use))
                {
                    pAcct->SetSourceSid(pSrcSid);
                }

                // Now we move it
                hr = MoveObject( pAcct, pOptions, pMover );

                // don't bother with this in nochange mode
                if ( pOptions->nochange )
                {
                    // we haven't modified the accounts in any way, so nothing else needs to be done for nochange mode
                    continue;
                }
                // Now, we have attempted to move the object - we need to put back the memberships

                // UNDO -- 
                if ( _wcsicmp(pAcct->GetSourceSam(), pAcct->GetTargetSam()) &&  pAcct->WasReplaced() && pOptions->bUndo )
                {
                    // Since we undid a prior migration that renamed the account we need
                    // to rename the account back to its original name.
                    // Get an ADs pointer to the account
                    IADs        * pADs = NULL;

                    c_array<WCHAR>      achPaths(LEN_Path);
                    DWORD               nPathLen = LEN_Path;

                    StuffComputerNameinLdapPath(achPaths, nPathLen, const_cast<WCHAR*>(pAcct->GetTargetPath()), pOptions, TRUE);
                    hr = ADsGetObject(achPaths,IID_IADs,(void**)&pADs);
                    if ( SUCCEEDED(hr) )
                    {
                        hr = pADs->Put(_bstr_t(L"sAMAccountName"),_variant_t(pAcct->GetTargetSam()));
                        if ( SUCCEEDED(hr) && !pOptions->nochange )
                        {
                            hr = pADs->SetInfo();
                            if ( SUCCEEDED(hr) )
                                err.MsgWrite(0,DCT_MSG_ACCOUNT_RENAMED_SS,pAcct->GetSourceSam(),pAcct->GetTargetSam());
                        }
                        if ( FAILED(hr) )
                        {
                            err.SysMsgWrite(ErrE,hr,DCT_MSG_RENAME_FAILED_SSD,pAcct->GetSourceSam(),pAcct->GetTargetSam(), hr);
                            Mark(L"errors",pAcct->GetType());
                        }
                        pADs->Release();
                    }
                }
                // -- UNDO

                // FAILED Move ----
                if ( (bObjectExists || _wcsicmp(pAcct->GetSourceSam(), pAcct->GetTargetSam())) && ! pAcct->WasReplaced() )
                {
                    // if we changed the SAM account name, and the move still failed, we need to change it back now
                    IADs        * pADs = NULL;

                    c_array<WCHAR>      achPaths(LEN_Path);
                    DWORD               nPathLen = LEN_Path;

                    StuffComputerNameinLdapPath(achPaths, nPathLen, const_cast<WCHAR*>(pAcct->GetSourcePath()), pOptions, FALSE);
                    hr = ADsGetObject(achPaths,IID_IADs,(void**)&pADs);
                    if ( SUCCEEDED(hr) )
                    {
                        hr = pADs->Put(_bstr_t(L"sAMAccountName"),_variant_t(pAcct->GetSourceSam()));
                        if ( SUCCEEDED(hr) )
                        {
                            hr = pADs->SetInfo();
                            if ( SUCCEEDED(hr) )
                                err.MsgWrite(0,DCT_MSG_ACCOUNT_RENAMED_SS,pAcct->GetTargetSam(),pAcct->GetSourceSam());
                        }
                        if ( FAILED(hr) )
                        {
                            err.SysMsgWrite(ErrE,hr,DCT_MSG_RENAME_FAILED_SSD,pAcct->GetTargetSam(),pAcct->GetSourceSam(), hr);
                            Mark(L"errors",pAcct->GetType());
                        }
                        pADs->Release();
                    }
                }// --- Failed Move
            } // end of Move-Loop
            e.Close();    
        }
        catch ( ... )
        {
            err.MsgWrite(ErrE,DCT_MSG_MOVE_EXCEPTION);
            Mark(L"errors", L"generic");
        }

        try { // if we've moved any of the members, update the member records to use the target names
            Progress(GET_STRING(DCT_MSG_UPDATE_MEMBER_LIST_S));
            UpdateMemberList(&pMember,acctlist);
            UpdateMemberList(&pMemberOf,acctlist);
        }
        catch (... )
        {
            err.MsgWrite(ErrE,DCT_MSG_RESET_MEMBER_EXCEPTION);
            Mark(L"errors", L"generic");
        }

        for ( pAcct = (TAcctReplNode *)e.OpenFirst(acctlist); 
            pAcct; 
            pAcct = (TAcctReplNode *)e.Next() )
        {
            if ( m_pExt && !pOptions->nochange )
            {
                if ( pAcct->WasReplaced() && (pAcct->operations & OPS_Call_Extensions) )
                {
                    m_pExt->Process(pAcct,sTargetDomain,pOptions,FALSE);
                }
            }

            //
            // If updating of rights is specified then add rights for target object. If
            // the source domain is W2K then explicitly remove rights for source object
            // as W2K does not automatically remove rights when an object is removed from
            // the domain as of SP 2. This behavior most likely will not change for W2K.
            //

            if (m_UpdateUserRights)
            {
                HRESULT hrRights = AddAccountRights(TRUE, pAcct);

                if (SUCCEEDED(hrRights) && (pOptions->srcDomainVer == 5) && (pOptions->srcDomainVerMinor == 0))
                {
                    RemoveAccountRights(FALSE, pAcct);
                }
            }

            //translate the roaming profile if requested 
            if ( pOptions->flags & F_TranslateProfiles && ((_wcsicmp(pAcct->GetType(), s_ClassUser) == 0) || (_wcsicmp(pAcct->GetType(), s_ClassInetOrgPerson) == 0)))
            {
                wsprintf(achMesg, GET_STRING(IDS_TRANSLATE_ROAMING_PROFILE_S), pAcct->GetName());
                if ( progress )
                    progress(achMesg);

                WCHAR  tgtProfilePath[MAX_PATH];

                GetBkupRstrPriv((WCHAR*)NULL);
                GetPrivilege((WCHAR*)NULL,SE_SECURITY_NAME);
                if ( wcslen(pAcct->GetSourceProfile()) > 0 )
                {
                    DWORD ret = TranslateRemoteProfile(pAcct->GetSourceProfile(), 
                        tgtProfilePath,
                        pAcct->GetSourceSam(),
                        pAcct->GetTargetSam(),
                        pOptions->srcDomain,
                        pOptions->tgtDomain,
                        pOptions->pDb,
                        pOptions->lActionID,
                        pAcct->GetSourceSid(),
                        pOptions->nochange);
                }
            }
        }
        e.Close();

        for ( pAcct = (TAcctReplNode *)e.OpenFirst(acctlist); 
            pAcct; 
            pAcct = (TAcctReplNode *)e.Next() )
        {
            try 
            { 
                if (bSrcNative && bTgtNative)
                {
                    if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
                    {
                        wsprintf(achMesg, GET_STRING(IDS_UPDATING_GROUP_MEMBERSHIPS_S), pAcct->GetName());
                        if ( progress )
                            progress(achMesg);
                        if ( pAcct->GetGroupType() & 4 )
                        {
                            wsprintf(achMesg, GET_STRING(DCT_MSG_RESET_GROUP_MEMBERS_S), pAcct->GetName());
                            Progress(achMesg);
                            ResetGroupsMembers(pOptions, pAcct, &pMember, pOptions->pDb);
                        }
                        else
                        {
                            // we need to update the members of these Universal/Global groups to 
                            // point members to the target domain if those members have been migrated
                            // in previous runs.
                            ResetMembersForUnivGlobGroups(pOptions, pAcct);
                        }
                    }
                }
                else
                {      
                    if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
                    {
                        wsprintf(achMesg, GET_STRING(DCT_MSG_RESET_GROUP_MEMBERS_S), pAcct->GetName());
                        if ( progress )
                            progress(achMesg);
                        ResetGroupsMembers(pOptions, pAcct, &pMember, pOptions->pDb);
                    }
                }
            }
            catch (... )
            { 
                err.MsgWrite(ErrE,DCT_MSG_GROUP_MEMBERSHIPS_EXCEPTION);
                Mark(L"errors", pAcct->GetType());
            }
        }

        bool bChangedAny = true;   // Have to go through it atleast once.
        while ( bChangedAny )
        {
            bChangedAny = false;
            for ( pAcct = (TAcctReplNode *)e.OpenFirst(acctlist); 
                pAcct; 
                pAcct = (TAcctReplNode *)e.Next() )
            {
                if ( pOptions->nochange )
                    continue;

                if ( bSrcNative && bTgtNative )
                {
                    // We have changed the migrated global groups to universal groups
                    // now we need to change them back to their original types, if possible
                    if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
                    {
                        if ( pAcct->GetGroupType() & 2 )
                        {
                            if ( pAcct->bChangedType )
                                continue;

                            // attempt to change it back to its original type
                            if ( pAcct->WasReplaced() )
                            {
                                // the account was moved, use the target name
                                hr = pClass->raw_ChangeGroupType(const_cast<WCHAR*>(pAcct->GetTargetPath()), pAcct->GetGroupType());
                            }
                            else
                            {
                                // we failed to move the account, use the source name
                                hr = pClass->raw_ChangeGroupType(const_cast<WCHAR*>(pAcct->GetSourcePath()), pAcct->GetGroupType());
                            }
                            pAcct->SetHr(hr);

                            if ( SUCCEEDED(hr) )
                            {
                                pAcct->bChangedType = true;
                                bChangedAny = true;
                            }
                        }
                    }
                }
                else
                {
                    // for mixed->native mode migration we can change the group type and add all the members back
                    if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
                    {
                        if ( !(pAcct->GetGroupType() & 4) && !pAcct->bChangedType )
                        {
                            if ( pAcct->WasReplaced() )
                            {
                                hr = pClass->raw_ChangeGroupType(const_cast<WCHAR*>(pAcct->GetTargetPath()), pAcct->GetGroupType());
                            }
                            else
                            {
                                hr = pClass->raw_ChangeGroupType(const_cast<WCHAR*>(pAcct->GetSourcePath()), pAcct->GetGroupType());
                            }
                            pAcct->SetHr(hr);

                            if ( SUCCEEDED(hr) )
                            {
                                pAcct->bChangedType = true;
                                bChangedAny = true;
                            }
                        }
                    } // if group
                }  // Native/Mixed
            }     //for
        } 

        // Log a message for all the groups that we were not able to change back to original type
        for ( pAcct = (TAcctReplNode *)e.OpenFirst(acctlist); 
            pAcct; 
            pAcct = (TAcctReplNode *)e.Next() )
        {
            if ( pOptions->nochange )
                continue;
            if ( bSrcNative && bTgtNative )
            {
                // We have changed the migrated global groups to universal groups
                // now we need to change them back to their original types, if possible
                if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
                {
                    if ( pAcct->GetGroupType() & 2 )
                    {
                        if (FAILED(pAcct->GetHr())) 
                        {
                            err.SysMsgWrite(ErrE,hr,DCT_MSG_GROUP_CHANGETYPE_FAILED_SD, pAcct->GetTargetPath(), hr);
                            Mark(L"errors", pAcct->GetType());
                        }
                    }
                }
            }
            else
            {
                // for mixed->native mode migration we can change the group type and add all the members back
                if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
                {
                    if ( !(pAcct->GetGroupType() & 4) )
                    {
                        if (FAILED(pAcct->GetHr())) 
                        {
                            err.SysMsgWrite(ErrE,hr,DCT_MSG_GROUP_CHANGETYPE_FAILED_SD, pAcct->GetTargetPath(), hr);
                            Mark(L"errors", pAcct->GetType());
                        }
                    }
                } // if group
            }  // Native/Mixed
        }     //for

        Progress(GET_STRING(DCT_MSG_RESET_MEMBERSHIP_S));
        ResetObjectsMembership( pOptions,&pMemberOf, pOptions->pDb );

        ResetTypeOfPreviouslyMigratedGroups(pOptions);
    }
    else
    {
        // Connection failed.
        err.SysMsgWrite(ErrE,hr,DCT_MSG_MOVEOBJECT_CONNECT_FAILED_D,hr);
        Mark(L"errors", ((TAcctReplNode*)acctlist->Head())->GetType());
    }
    if ( progress )
        progress(L"");
    pMover->Close();
    return 0;
}


//---------------------------------------------------------------------------------------------------------
// MoveObject - This method does the actual move on the object calling the Mover object.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::MoveObject( 
                               TAcctReplNode * pAcct,
                               Options * pOptions,
                               IMoverPtr pMover
                             )
{
   HRESULT                   hr = S_OK;
   WCHAR                     sourcePath[LEN_Path];
   WCHAR                     targetPath[LEN_Path];
   DWORD                     nPathLen = LEN_Path;
   WCHAR                   * pRelativeTgtOUPath = NULL;

   safecopy(sourcePath,pAcct->GetSourcePath());

   WCHAR                  mesg[LEN_Path];
   wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_MOVING_S), pAcct->GetName());
   Progress(mesg); 

   if ( ! pOptions->bUndo )
   {
      MakeFullyQualifiedAdsPath(targetPath, nPathLen, pOptions->tgtOUPath, pOptions->tgtDomain, pOptions->tgtNamingContext);
   }
   else
   {
      swprintf(targetPath,L"LDAP://%ls/%ls",pOptions->tgtDomain,pOptions->tgtOUPath);
   }
        //make sourcePath and targetPath all lowercase to avoid a W2K bug in ntdsa.dll
   _wcslwr(targetPath);
   _wcslwr(sourcePath);
        //due to lowercase force above, we have to replace "ldap://" with "LDAP://" in
        //order for subsequent ADsGetObjects calls to succeed
   if ( !_wcsnicmp(L"LDAP://", targetPath, 7) )
   {
      WCHAR  aNewPath[LEN_Path] = L"LDAP";
      UStrCpy(aNewPath+UStrLen(aNewPath), targetPath+UStrLen(aNewPath));
      wcscpy(targetPath, aNewPath);
   }
   if ( !_wcsnicmp(L"LDAP://", sourcePath, 7) )
   {
      WCHAR  aNewPath[LEN_Path] = L"LDAP";
      UStrCpy(aNewPath+UStrLen(aNewPath), sourcePath+UStrLen(aNewPath));
      wcscpy(sourcePath, aNewPath);
   }

   WCHAR                     sTargetRDN[LEN_Path];
   wcscpy(sTargetRDN, pAcct->GetTargetName());

   if ( ! pOptions->nochange )
   {
      hr = pMover->raw_MoveObject(sourcePath,sTargetRDN,targetPath);
         //if the Move operation failed due to a W2K bug for CNs which
         //include a '/', un-escape the '/' and try again
      if ((hr == E_INVALIDARG) && (wcschr(sTargetRDN, L'/')))
      {
         _bstr_t strName = GetUnEscapedNameWithFwdSlash(_bstr_t(sTargetRDN)); //remove any escape characters added
         hr = pMover->raw_MoveObject(sourcePath,(WCHAR*)strName,targetPath);
      }
   }
   else
   {
      hr = pMover->raw_CheckMove(sourcePath,sTargetRDN,targetPath);
         //if the Check Move operation failed due to a W2K bug for CNs which
         //include a '/', un-escape the '/' and try again
      if ((hr == E_INVALIDARG) && (wcschr(sTargetRDN, L'/')))
      {
         _bstr_t strName = GetUnEscapedNameWithFwdSlash(_bstr_t(sTargetRDN)); //remove any escape characters added
         hr = pMover->raw_CheckMove(sourcePath,(WCHAR*)strName,targetPath);
      }
      if ( HRESULT_CODE(hr) == ERROR_DS_CANT_MOVE_ACCOUNT_GROUP 
         || HRESULT_CODE(hr) == ERROR_DS_CANT_MOVE_RESOURCE_GROUP
         || HRESULT_CODE(hr) == ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS
         || HRESULT_CODE(hr) == ERROR_USER_EXISTS )
      {
         hr = 0;
      }
   }
   if ( SUCCEEDED(hr) )
   {
      WCHAR                 path[LEN_Path];
      DWORD                 nPathLen = LEN_Path;

      pAcct->MarkReplaced();
      Mark(L"created", pAcct->GetType());   
      // set the target path 
      UStrCpy(path,pAcct->GetTargetName());
      if ( *pOptions->tgtOUPath )
      {
         wcscat(path, L",");
         wcscat(path, pOptions->tgtOUPath);
      }
      pRelativeTgtOUPath = wcschr(targetPath + wcslen(L"LDAP://") + 2, L'/');

      if ( pRelativeTgtOUPath )
      {
         *pRelativeTgtOUPath = 0;
         swprintf(path,L"%ls/%ls,%ls",targetPath,pAcct->GetTargetName(),pRelativeTgtOUPath+1);
         
      }
      else
      {
         MakeFullyQualifiedAdsPath(path, nPathLen, pOptions->tgtOUPath, pOptions->tgtComp, pOptions->tgtNamingContext);
      }

      pAcct->SetTargetPath(path);
      err.MsgWrite(0,DCT_MSG_OBJECT_MOVED_SS,pAcct->GetSourcePath(),pAcct->GetTargetPath());

   }
   else
   {
      pAcct->MarkError();
      Mark(L"errors", pAcct->GetType());
      if ( hr == 8524 )
      {
         err.MsgWrite(ErrE,DCT_MSG_MOVEOBJECT_FAILED_S8524,pAcct->GetName(),hr);
      }
      else if
          (
            (hr == HRESULT_FROM_WIN32(ERROR_DS_INAPPROPRIATE_AUTH)) ||
            (hr == SEC_E_UNKNOWN_CREDENTIALS) ||
            (hr == SEC_E_NO_CREDENTIALS)
          )
      {
         err.SysMsgWrite(ErrE,hr,DCT_MSG_MOVEOBJECT_FAILED_DELEGATION_SD,pAcct->GetName(),hr);
      }
      else
      {
         err.SysMsgWrite(ErrE,hr,DCT_MSG_MOVEOBJECT_FAILED_SD,pAcct->GetName(),hr);
      }
   }

   return hr;
}

//---------------------------------------------------------------------------------------------------------
// RecordAndRemoveMemberOf : This method removes all values in the memberOf property and then records these
//                           memberships. These memberships are later updated.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::RecordAndRemoveMemberOf (
                                            Options * pOptions,         //in- Options specified by the user
                                           TAcctReplNode * pAcct,       //in- Account being migrated.
                                           TNodeListSortable * pMember  //out-List containing the MemberOf values.
                                         )
{
    // First Enumerate all the objects in the member of property
    INetObjEnumeratorPtr            pQuery(__uuidof(NetObjEnumerator));
    IEnumVARIANT                  * pEnum;
    LPWSTR                          sCols[] = { L"memberOf" };
    SAFEARRAY                     * pSa;
    BSTR                          * pData;
    SAFEARRAYBOUND                  bd = { 1, 0 };
    IADs                          * pAds;
    _bstr_t                         sObjDN;
    _bstr_t                         sGrpName;
    _variant_t                      var;
    _variant_t                    * pDt;
    _variant_t                      vx;
    DWORD                           ulFetch;
    _bstr_t                         sDN;
    WCHAR                           sPath[LEN_Path];
    IADsGroup                     * pGroup;
    _variant_t                    * pVar;

    if ( pMember->IsTree() ) pMember->ToSorted();

    WCHAR                     sPathSource[LEN_Path];
    DWORD                     nPathLen = LEN_Path;
    StuffComputerNameinLdapPath(sPathSource, nPathLen, const_cast<WCHAR*>(pAcct->GetSourcePath()), pOptions, FALSE);
    err.MsgWrite(0,DCT_STRIPPING_GROUP_MEMBERSHIPS_SS,pAcct->GetName(),sPathSource);
    // Get this users distinguished name.
    HRESULT hr = ADsGetObject(sPathSource, IID_IADs, (void**) &pAds);
    if ( FAILED(hr) )
    {
        err.SysMsgWrite(ErrE, hr, DCT_MSG_SOURCE_ACCOUNT_NOT_FOUND_SSD, pAcct->GetName(), pOptions->srcDomain, hr);
        Mark(L"errors", pAcct->GetType());
        return hr;
    }

    hr = pAds->Get(L"distinguishedName", &var);
    pAds->Release();
    if ( FAILED(hr))
        return hr;
    sObjDN = V_BSTR(&var);

    // Set up the column array
    pSa = SafeArrayCreate(VT_BSTR, 1, &bd);
    SafeArrayAccessData(pSa, (void HUGEP **) &pData);
    pData[0] = SysAllocString(sCols[0]);
    SafeArrayUnaccessData(pSa);

    //   hr = pQuery->raw_SetQuery(const_cast<WCHAR*>(pAcct->GetSourcePath()), pOptions->srcDomain, L"(objectClass=*)", ADS_SCOPE_BASE, TRUE);
    hr = pQuery->raw_SetQuery(sPathSource, pOptions->srcDomain, L"(objectClass=*)", ADS_SCOPE_BASE, TRUE);
    hr = pQuery->raw_SetColumns(pSa);
    hr = pQuery->raw_Execute(&pEnum);
    if ( FAILED(hr))
        return hr;

    while ( pEnum->Next(1, &var, &ulFetch) == S_OK )
    {
        SAFEARRAY * vals = var.parray;
        // Get the VARIANT Array out
        SafeArrayAccessData(vals, (void HUGEP**) &pDt);
        vx = pDt[0];
        SafeArrayUnaccessData(vals);

        // Single value in the property. Good enough for me though
        if ( vx.vt == VT_BSTR )
        {
            sDN = V_BSTR(&vx);
            sDN = PadDN(sDN);

            if ( sDN.length() > 0 )
            {
                WCHAR                  mesg[LEN_Path];
                wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBEROF_SS), pAcct->GetName(), (WCHAR*) sDN);
                Progress(mesg);

                SimpleADsPathFromDN(pOptions, sDN, sPath);
                WCHAR                     sSourcePath[LEN_Path];
                WCHAR                     sPaths[LEN_Path];
                DWORD                     nPathLen = LEN_Path;

                wcscpy(sSourcePath, (WCHAR*) sPath);

                if ( !wcsncmp(L"LDAP://", sSourcePath, 7) )
                    StuffComputerNameinLdapPath(sPaths, nPathLen, sSourcePath, pOptions, FALSE);

                // Get the IADsGroup pointer to each of the objects in member of and remove this object from the group
                hr = ADsGetObject(sPaths, IID_IADsGroup, (void**) &pGroup);
                if ( FAILED(hr) )
                    continue;

                pGroup->Get(L"sAMAccountName", &var);
                sGrpName = V_BSTR(&var);
                hr = pGroup->Get(L"groupType",&var);
                if ( SUCCEEDED(hr) )
                {
                    if ( var.lVal & 2 )
                    {
                        // this is a global group

                        if ( !pOptions->nochange )
                            hr = pGroup->Remove(sPathSource);
                        else
                            hr = S_OK;

                        if ( SUCCEEDED(hr) )
                        {
                            //                     err.MsgWrite(0,DCT_MSG_REMOVED_MEMBER_FROM_GROUP_SS,sPath2,(WCHAR*)sGrpName);
                            err.MsgWrite(0,DCT_MSG_REMOVED_MEMBER_FROM_GROUP_SS,sPathSource,(WCHAR*)sPaths);
                        }
                        else
                        {
                            err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_MEMBER_FAILED_SSD,sPathSource,sPaths,hr);
                            Mark(L"errors", pAcct->GetType());
                        }
                    }
                    else
                    {
                        err.MsgWrite(0,DCT_MSG_NOT_REMOVING_MEMBER_FROM_GROUP_SS,sPathSource,sPaths);
                        pGroup->Release();
                        continue;
                    }
                }
                pGroup->Release();
                if (FAILED(hr))
                    continue;

                // Record this path into the list
                TRecordNode * pNode = new TRecordNode();
                if (!pNode)
                    return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                pNode->SetMember((WCHAR*)sPath);
                pNode->SetMemberSam((WCHAR*)sGrpName);
                pNode->SetDN((WCHAR*)sDN);
                pNode->SetARNode(pAcct);
                if (! pMember->InsertIfNew((TNode*) pNode) )
                    delete pNode;
            }
        }
        else if ( vx.vt & VT_ARRAY )
        {
            // We must have got an Array of multivalued properties
            // Access the BSTR elements of this variant array
            SAFEARRAY * multiVals = vx.parray; 
            SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
            for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
            {
                sDN = _bstr_t(pVar[dw]);
                sDN = PadDN(sDN);
                SimpleADsPathFromDN(pOptions, sDN, sPath);

                WCHAR                  mesg[LEN_Path];
                wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBEROF_SS), pAcct->GetName(), (WCHAR*) sDN);
                Progress(mesg);

                WCHAR                     sSourcePath[LEN_Path];
                WCHAR                     sPaths[LEN_Path];
                DWORD                     nPathLen = LEN_Path;

                wcscpy(sSourcePath, (WCHAR*) sPath);

                if ( !wcsncmp(L"LDAP://", sSourcePath, 7) )
                    StuffComputerNameinLdapPath(sPaths, nPathLen, sSourcePath, pOptions, FALSE);

                // Get the IADsGroup pointer to each of the objects in member of and remove this object from the group
                hr = ADsGetObject(sPaths, IID_IADsGroup, (void**) &pGroup);
                if ( FAILED(hr) )
                    continue;

                pGroup->Get(L"sAMAccountName", &var);
                sGrpName = V_BSTR(&var);
                hr = pGroup->Get(L"groupType",&var);
                if ( SUCCEEDED(hr) )
                {
                    if ( var.lVal & 2 )
                    {
                        // This is a global group
                        if ( !pOptions->nochange )
                            hr = pGroup->Remove(sPathSource);
                        else
                            hr = S_OK;

                        if ( SUCCEEDED(hr) )
                        {
                            err.MsgWrite(0,DCT_MSG_REMOVED_MEMBER_FROM_GROUP_SS,sPathSource,sPaths);
                        }
                        else
                        {
                            err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_MEMBER_FAILED_SSD,sPathSource,sPaths);
                            Mark(L"errors", pAcct->GetType());
                        }
                    }
                    else
                    {
                        err.MsgWrite(0,DCT_MSG_NOT_REMOVING_MEMBER_FROM_GROUP_SS,sPathSource,sPaths);
                        pGroup->Release();
                        continue;
                    }
                }
                pGroup->Release();
                if (FAILED(hr))
                    continue;

                // Record this path into the list
                TRecordNode * pNode = new TRecordNode();
                if (!pNode)
                    return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                pNode->SetMember(sPath);
                pNode->SetMemberSam((WCHAR*)sGrpName);
                pNode->SetDN((WCHAR*)sDN);
                pNode->SetARNode(pAcct);
                if (! pMember->InsertIfNew((TNode*) pNode) )
                    delete pNode;
            }
            SafeArrayUnaccessData(multiVals);
        }
    }
    pEnum->Release();
    var.Clear();
    return S_OK;
}


//---------------------------------------------------------------------------------------------------------
// ResetObjectsMembership : This method restores the memberOf property of the object being migrated. It uses
//                          the information that was stored by RecordAndRemoveMemberOf function.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::ResetObjectsMembership(
                                     Options * pOptions,          //in- Options set by the user.
                                     TNodeListSortable * pMember, //in- The member list that is used to restore the values
                                     IIManageDBPtr pDb            //in- Database object to lookup migrated accounts.
                                    )
{
   IVarSetPtr                pVs(__uuidof(VarSet));
   _bstr_t                   sMember;
   IADs                    * pAds;
   IUnknown                * pUnk;
   _bstr_t                   sPath;
   _variant_t                var;
   _bstr_t                   sMyDN;
   IADsGroup               * pGroup = NULL;
   TAcctReplNode           * pAcct = NULL;
   HRESULT                   hr;
   WCHAR                     sPaths[LEN_Path];
   DWORD                     nPathLen = LEN_Path;
   

   // Sort the member list by the account nodes
  
   pMember->Sort(&TNodeCompareAcctNode);


   
   // For all the items in the member list lets add the member to the group.
   // First check in the migrated objects table to see if it has been migrated.
   for ( TRecordNode * pNode = (TRecordNode *)pMember->Head(); pNode; pNode = (TRecordNode *)pNode->Next())
   {
      pVs->QueryInterface(IID_IUnknown, (void**) &pUnk);
      // get the needed information from the account node
      if ( pAcct != pNode->GetARNode() )
      {
         if ( pNode->GetARNode()->WasReplaced() )
         {
            // the account was moved successfully - add the target account to all of its old groups
            StuffComputerNameinLdapPath(sPaths, nPathLen, const_cast<WCHAR*>(pNode->GetARNode()->GetTargetPath()), pOptions);
            hr = ADsGetObject(sPaths, IID_IADs, (void**) &pAds);
         }
         else
         {
            // the move failed, add the source account back to its groups
            StuffComputerNameinLdapPath(sPaths, nPathLen, const_cast<WCHAR*>(pNode->GetARNode()->GetSourcePath()), pOptions, FALSE);
            hr = ADsGetObject(sPaths, IID_IADs, (void**) &pAds);
         }
         if ( SUCCEEDED(hr) )
         {
            pAds->Get(L"distinguishedName", &var);
            pAds->Release();
            sMyDN = V_BSTR(&var);
         }
         else 
         {
            continue;
         }
         pAcct = pNode->GetARNode();
         if ( pAcct->WasReplaced() )
         {
            err.MsgWrite(0,DCT_READDING_GROUP_MEMBERS_SS,pAcct->GetTargetName(),sPaths);
         }
         else
         {
            err.MsgWrite(0,DCT_READDING_GROUP_MEMBERS_SS,pAcct->GetName(),sPaths);
         }
      }
      
      sMember = pNode->GetMemberSam();
      if ( pAcct->WasReplaced() )
      {
         pVs->Clear();
         hr = pDb->raw_GetAMigratedObject((WCHAR*)sMember,pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
         pUnk->Release();
         if ( hr == S_OK )
         {
            // Since we have already migrated this object lets use the target objects information.
            VerifyAndUpdateMigratedTarget(pOptions, pVs);
            sPath = pVs->get(L"MigratedObjects.TargetAdsPath");
         }
         else
            // Other wise use the source objects path to add.
            sPath = pNode->GetMember();
      }
      else
      {
         sPath = pNode->GetMember();
      }
      // We have a path to the object lets get the group interface and add this object as a member
      WCHAR                     sPath2[LEN_Path];
      DWORD                     nPathLen = LEN_Path;
      if ( SUCCEEDED(hr) )
      {
         StuffComputerNameinLdapPath(sPath2, nPathLen, (WCHAR*) sPath, pOptions, TRUE);
         hr = ADsGetObject(sPath2, IID_IADsGroup, (void**) &pGroup);
      }
      if ( SUCCEEDED(hr) )
      {
         if ( pAcct->WasReplaced() )
         {
            if ( ! pOptions->nochange )
               hr = pGroup->Add(sPaths);  
            else 
               hr = 0;
            if ( SUCCEEDED(hr) )
            {
               err.MsgWrite(0,DCT_MSG_READDED_MEMBER_SS,pAcct->GetTargetPath(),sPath2);
            }
            else
            {
               //hr = BetterHR(hr);
               if ( HRESULT_CODE(hr) == ERROR_DS_UNWILLING_TO_PERFORM )
               {
                  err.MsgWrite(0,DCT_MSG_READD_MEMBER_FAILED_CONSTRAINTS_SS,pAcct->GetTargetPath(),sPath2);  
               }
               else
               {
                  err.SysMsgWrite(ErrE,hr,DCT_MSG_READD_TARGET_MEMBER_FAILED_SSD,pAcct->GetTargetPath(),(WCHAR*)sPath2,hr);
               }
               Mark(L"errors", pAcct->GetType());
            }
         }
         else
         {
            WCHAR                  mesg[LEN_Path];
            wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RESET_OBJECT_MEMBERSHIP_SS), (WCHAR*) sPath2, pAcct->GetTargetName());
            Progress(mesg);

            if ( ! pOptions->nochange )
               hr = pGroup->Add(sPaths);
            else
               hr = 0;
            if ( SUCCEEDED(hr) )
            {
               err.MsgWrite(0,DCT_MSG_READDED_MEMBER_SS,pAcct->GetSourcePath(),(WCHAR*)sPath2);
            }
            else
            {
               //hr = BetterHR(hr);
               if ( HRESULT_CODE(hr) == ERROR_DS_UNWILLING_TO_PERFORM )
               {
                  err.MsgWrite(0,DCT_MSG_READD_MEMBER_FAILED_CONSTRAINTS_SS,pAcct->GetTargetPath(),(WCHAR*)sPath2);  
               }
               else
               {
                  err.SysMsgWrite(ErrE,hr,DCT_MSG_READD_SOURCE_MEMBER_FAILED_SSD,pAcct->GetSourcePath(),(WCHAR*)sPath2,hr);
               }
               Mark(L"errors", pAcct->GetType());
            }
         }
      }
      else
      {
         // the member could not be added to the group
         hr = BetterHR(hr);
         err.SysMsgWrite(ErrW,hr,DCT_MSG_FAILED_TO_GET_OBJECT_SD,(WCHAR*)sPath2,hr);
         Mark(L"warnings", pAcct->GetType());
      }
         if ( pGroup )
      {
         pGroup->Release();
         pGroup = NULL;
      }
   }
   return hr;
}


//---------------------------------------------------------------------------------------------------------
// ResetTypeOfPreviouslyMigratedGroups
//
// Attempts to change group scope back to global for global groups that were previously migrated but were
// unable to have their scope changed back to global due to having members outside of the domain.
//---------------------------------------------------------------------------------------------------------

void CAcctRepl::ResetTypeOfPreviouslyMigratedGroups(Options* pOptions)
{
    // retrieve list of global groups that have been migrated from source domain

    IVarSetPtr spVarSet(__uuidof(VarSet));
    IUnknownPtr spUnknown(spVarSet);
    IUnknown* punk = spUnknown;

    HRESULT hr = pOptions->pDb->GetMigratedObjectByType(-1, _bstr_t(pOptions->srcDomain), _bstr_t(L"ggroup"), &punk);

    if (SUCCEEDED(hr))
    {
        // for each global group

        long lCount = spVarSet->get(_bstr_t(L"MigratedObjects"));

        for (long lIndex = 0; lIndex < lCount; lIndex++)
        {
            WCHAR szKey[256];

            // if marked as having been global group
            // which means it was converted to universal group

            swprintf(szKey, L"MigratedObjects.%ld.status", lIndex);
            long lStatus = spVarSet->get(_bstr_t(szKey));

            if (lStatus & AR_Status_GroupScopeChanged)
            {
                // bind to group in target domain

                swprintf(szKey, L"MigratedObjects.%ld.TargetAdsPath", lIndex);
                _bstr_t strADsPath = spVarSet->get(_bstr_t(szKey));

                if (strADsPath.length())
                {
                    IADsGroupPtr spGroup;
                    hr = ADsGetObject(strADsPath, IID_IADsGroup, (void**)&spGroup);

                    if (SUCCEEDED(hr))
                    {
                        // if group is currently a universal group

                        _bstr_t strPropertyName(L"groupType");

                        VARIANT var;
                        VariantInit(&var);

                        hr = spGroup->Get(strPropertyName, &var);

                        if (SUCCEEDED(hr))
                        {
                            long lGroupType = _variant_t(var, false);

                            if (lGroupType & ADS_GROUP_TYPE_UNIVERSAL_GROUP)
                            {
                                // change it's type back to global group

                                spGroup->Put(strPropertyName, _variant_t(long(unsigned long(ADS_GROUP_TYPE_GLOBAL_GROUP|ADS_GROUP_TYPE_SECURITY_ENABLED))));
                                hr = spGroup->SetInfo();

                                if (SUCCEEDED(hr))
                                {
                                    // log successful change
                                    err.MsgWrite(ErrI, DCT_MSG_CHANGE_GLOBAL_GROUP_SCOPE_BACK_S, (LPCTSTR)strADsPath);
                                }
                            }

                            if (SUCCEEDED(hr))
                            {
                                // clear status flag in database
                                swprintf(szKey, L"MigratedObjects.%ld.GUID", lIndex);
                                _bstr_t strGUID = spVarSet->get(_bstr_t(szKey));
                                pOptions->pDb->UpdateMigratedObjectStatus(strGUID, lStatus & ~AR_Status_GroupScopeChanged);
                            }
                        }
                    }
                }
            }
        }
    }
}


//---------------------------------------------------------------------------------------------------------
// RecordAndRemoveMember : Records and removes the objects in the member property of the object(group) being
//                         migrated. The recorded information is later used to restore membership.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::RecordAndRemoveMember (
                                            Options * pOptions,         //in- Options set by the user.
                                           TAcctReplNode * pAcct,       //in- Account being copied.
                                           TNodeListSortable * pMember  //out-Membership list to be used later to restore membership
                                         )
{
    HRESULT                   hr;
    INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
    IEnumVARIANT            * pEnum;
    LPWSTR                    sCols[] = { L"member" };
    SAFEARRAY               * pSa;
    SAFEARRAYBOUND            bd = { 1, 0 };
    WCHAR                     sPath[LEN_Path];
    DWORD                     nPathLen = LEN_Path;
    _bstr_t                   sDN;
    IADsGroupPtr              pGroup;
    _variant_t                var;
    DWORD                     ulFetch=0;
    IADsPtr                   pAds;
    _bstr_t                   sGrpName;
    _variant_t              * pDt;
    _variant_t                vx;
    BSTR  HUGEP             * pData;
    WCHAR                     sSourcePath[LEN_Path];
    WCHAR                     sAdsPath[LEN_Path];

    wcscpy(sSourcePath, pAcct->GetSourcePath());

    if ( !wcsncmp(L"LDAP://", sSourcePath, 7) )
        StuffComputerNameinLdapPath(sAdsPath, nPathLen, sSourcePath, pOptions, FALSE);

    hr = ADsGetObject(sAdsPath, IID_IADsGroup, (void**) &pGroup);
    if ( FAILED(hr) ) return hr;

    pSa = SafeArrayCreate(VT_BSTR, 1, &bd);
    hr = SafeArrayAccessData(pSa, (void HUGEP **)&pData);
    pData[0] = SysAllocString(sCols[0]);
    hr = SafeArrayUnaccessData(pSa);
    hr = pQuery->raw_SetQuery(sAdsPath, pOptions->srcDomain, L"(objectClass=*)", ADS_SCOPE_BASE, TRUE);
    hr = pQuery->raw_SetColumns(pSa);
    hr = pQuery->raw_Execute(&pEnum);
    if ( FAILED(hr) ) return hr;

    err.MsgWrite(0,DCT_STRIPPING_GROUP_MEMBERS_SS,pAcct->GetName(),sAdsPath);
    while ( pEnum->Next(1, &var, &ulFetch) == S_OK )
    {
        SAFEARRAY * vals = var.parray;
        // Get the VARIANT Array out
        SafeArrayAccessData(vals, (void HUGEP**) &pDt);
        vx = pDt[0];
        SafeArrayUnaccessData(vals);

        // Single value in the property. Good enough for me though
        if ( vx.vt == VT_BSTR )
        {
            sDN = V_BSTR(&vx);
            sDN = PadDN(sDN);

            if ( sDN.length() )
            {
                WCHAR                  mesg[LEN_Path];
                wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBER_SS), pAcct->GetName(), (WCHAR*) sDN);
                Progress(mesg);

                hr = ADsPathFromDN(pOptions, sDN, sPath);

                if (SUCCEEDED(hr))
                {
                    // Get the IADs pointer to each of the objects in member and remove the object from the group
                    hr = ADsGetObject((WCHAR*)sPath, IID_IADs, (void**) &pAds);

                    if ( SUCCEEDED(hr) )
                    {
                        pAds->Get(L"sAMAccountName", &var);
                        sGrpName = V_BSTR(&var);

                        pAds->Get(L"distinguishedName", &var);
                        sDN = V_BSTR(&var);
                    }

                    if ( !pOptions->nochange )
                        hr = pGroup->Remove((WCHAR*) sPath);
                    else
                        hr = S_OK;

                    if (FAILED(hr))
                    {
                        err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_MEMBER_FAILED_SSD,sAdsPath,(WCHAR*)sPath,hr);
                        Mark(L"errors", pAcct->GetType());
                        continue;
                    }
                    else
                    {
                        err.MsgWrite(0,DCT_MSG_REMOVED_MEMBER_FROM_GROUP_SS,(WCHAR*)sPath,sAdsPath);
                    }
                }
                else
                {
                    err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_MEMBER_FAILED_SSD,sAdsPath,(WCHAR*)sDN,hr);
                    Mark(L"errors", pAcct->GetType());
                    continue;
                }

                // Record this path into the list
                TRecordNode * pNode = new TRecordNode();
                if (!pNode)
                    return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                pNode->SetMember((WCHAR*)sPath);
                pNode->SetMemberSam((WCHAR*)sGrpName);
                pNode->SetDN((WCHAR*)sDN);
                pNode->SetARNode(pAcct);
                if (! pMember->InsertIfNew((TNode*) pNode) )
                    delete pNode;
            }
        }
        else if ( vx.vt & VT_ARRAY )
        {
            // We must have got an Array of multivalued properties
            // Access the BSTR elements of this variant array
            _variant_t              * pVar;
            SAFEARRAY * multiVals = vx.parray; 
            SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
            for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
            {
                sDN = _bstr_t(pVar[dw]);
                _bstr_t sPadDN = PadDN(sDN);

                WCHAR                  mesg[LEN_Path];
                wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBER_SS), pAcct->GetName(), (WCHAR*) sPadDN);
                Progress(mesg);

                hr = ADsPathFromDN(pOptions, sPadDN, sPath);

                if (SUCCEEDED(hr))
                {
                    WCHAR tempPath[LEN_Path];
                    wcscpy(tempPath, sPath);
                    if ( !wcsncmp(L"LDAP://", tempPath, 7) )
                        StuffComputerNameinLdapPath(sPath, nPathLen, tempPath, pOptions, FALSE);

                    // Get the IADsGroup pointer to each of the objects in member of and remove this object from the group
                    hr = ADsGetObject((WCHAR*)sPath, IID_IADs, (void**) &pAds);
                    if ( SUCCEEDED(hr) )
                    {
                        hr = pAds->Get(L"sAMAccountName", &var);
                        if ( SUCCEEDED(hr) )
                        {
                            sGrpName = V_BSTR(&var);
                        }

                        hr = pAds->Get(L"distinguishedName", &var);
                        if ( SUCCEEDED(hr) )
                        {
                            sDN = V_BSTR(&var);
                        }

                        if ( !pOptions->nochange )
                            hr = pGroup->Remove((WCHAR*)sPath);
                        else
                            hr = S_OK;

                        if ( SUCCEEDED(hr) )
                        {
                            err.MsgWrite(0,DCT_MSG_REMOVED_MEMBER_FROM_GROUP_SS,(WCHAR*)sPath,sAdsPath);
                        }
                        else
                        {
                            err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_MEMBER_FAILED_SSD,sAdsPath,(WCHAR*)sPath,hr);
                            Mark(L"errors", pAcct->GetType());
                        }
                        if ( SUCCEEDED(hr) )
                        {
                            // Record this path into the list
                            TRecordNode * pNode = new TRecordNode();
                            if (!pNode)
                                return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                            pNode->SetMember((WCHAR*)sPath);
                            pNode->SetMemberSam((WCHAR*)sGrpName);
                            pNode->SetDN((WCHAR*)sDN);
                            pNode->SetARNode(pAcct);
                            if ( ! pMember->InsertIfNew((TNode*) pNode) )
                                delete pNode;
                        }
                    }
                    else
                    {
                        // Since we were not able to get this user. it has probably been migrated to another domain. 
                        // we should use the DN to find where the object is migrated to and then use the migrated object 
                        // to establish the membership instead.

                        // Remove the rogue member
                        if ( !pOptions->nochange )
                            hr = pGroup->Remove((WCHAR*)sPath);
                        else
                            hr = S_OK;

                        if ( SUCCEEDED(hr) )
                        {
                            err.MsgWrite(0,DCT_MSG_REMOVED_MEMBER_FROM_GROUP_SS,(WCHAR*)sPath,sAdsPath);
                        }
                        else
                        {
                            err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_MEMBER_FAILED_SSD,sAdsPath,(WCHAR*)sPath,hr);
                            Mark(L"errors", pAcct->GetType());
                        }

                        // Check in the DB to see where this object may have been migrated
                        IUnknown * pUnk = NULL;
                        IVarSetPtr  pVsMigObj(__uuidof(VarSet));

                        hr = pVsMigObj->QueryInterface(IID_IUnknown, (void**)&pUnk);

                        if ( SUCCEEDED(hr) )
                            hr = pOptions->pDb->raw_GetMigratedObjectBySourceDN(sPadDN, &pUnk);

                        if (pUnk) pUnk->Release();

                        if ( hr == S_OK )
                        {
                            // Record this path into the list
                            TRecordNode * pNode = new TRecordNode();
                            if (!pNode)
                                return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                            WCHAR          sKey[500];

                            wsprintf(sKey, L"MigratedObjects.%s", GET_STRING(DB_TargetAdsPath));
                            pNode->SetMember((WCHAR*)pVsMigObj->get(sKey).bstrVal);

                            wsprintf(sKey, L"MigratedObjects.%s", GET_STRING(DB_TargetSamName));
                            pNode->SetMemberSam((WCHAR*)pVsMigObj->get(sKey).bstrVal);
                            pNode->SetDN((WCHAR*)sDN);
                            pNode->SetARNode(pAcct);
                            if ( ! pMember->InsertIfNew((TNode*) pNode) )
                                delete pNode;
                        }
                        else
                        {
                            //Log a message saying we can not find this object and the membership will not be updated on the other side.
                            err.MsgWrite(ErrE,DCT_MSG_MEMBER_NOT_FOUND_SS, pAcct->GetName(), (WCHAR*)sDN);
                        }
                    }
                }
                else
                {
                    err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_MEMBER_FAILED_SSD,sAdsPath,(WCHAR*)sPadDN,hr);
                    Mark(L"errors", pAcct->GetType());
                }
            }
            SafeArrayUnaccessData(multiVals);
        }
    }
    pEnum->Release();
    var.Clear();
    return S_OK;
}

void 
   CAcctRepl::UpdateMemberList(TNodeListSortable * pMemberList,TNodeListSortable * acctlist)
{
   // for each moved object in the account list, look it up in the member list
   TNodeTreeEnum        e;
   TAcctReplNode      * pAcct;
   TRecordNode        * pRec;
//   HRESULT              hr = S_OK;
   WCHAR                dn[LEN_Path];
   WCHAR        const * slash;

   pMemberList->Sort(TNodeCompareMemberDN);

   for ( pAcct = (TAcctReplNode *)e.OpenFirst(acctlist) ; pAcct ; pAcct = (TAcctReplNode *)e.Next())
   {
      if ( pAcct->WasReplaced() )
      {
         //err.DbgMsgWrite(0,L"UpdateMemberList:: %ls was replaced",pAcct->GetSourcePath());
         
         slash = wcschr(pAcct->GetSourcePath()+8,L'/');
         if ( slash )
         {
            safecopy(dn,slash+1);
           // err.DbgMsgWrite(0,L"Searching the member list for %ls",dn);
            // if the account was replaced, find any instances of it in the member list, and update them
            pRec = (TRecordNode *)pMemberList->Find(&TNodeCompareMemberItem,dn);
            while ( pRec )
            {
             // err.DbgMsgWrite(0,L"Found record: Member=%ls, changing it to %ls",pRec->GetMember(),pAcct->GetTargetPath());
               // change the member data to refer to the new location of the account
               pRec->SetMember(pAcct->GetTargetPath());
               pRec->SetMemberSam(pAcct->GetTargetSam());
               pRec->SetMemberMoved();
            
               pRec = (TRecordNode*)pRec->Next();
               if ( pRec && UStrICmp(pRec->GetDN(),dn) )
               {
                  // the next record is for a different node
                  pRec = NULL;
               }
            }
         }
      }
     // else
     //    err.DbgMsgWrite(0,L"UpdateMemberList:: %ls was not replaced",pAcct->GetSourcePath());
         
   }
   e.Close();
   // put the list back like it was before
   pMemberList->Sort(TNodeCompareMember);
}

void 
   CAcctRepl::SimpleADsPathFromDN(
      Options              * pOptions,
      WCHAR          const * sDN,
      WCHAR                * sPath
   )
{
   WCHAR             const * pDcPart = wcsstr(sDN,L",DC=");

   UStrCpy(sPath,L"LDAP://");

   if ( pDcPart )
   {
      WCHAR          const * curr;        // pointer to DN
      WCHAR                * sPathCurr;   // pointer to domain name part of the path
      
      for ( sPathCurr = sPath+UStrLen(sPath), curr = pDcPart + 4; *curr ; sPathCurr++ )
      {
         // replace each occurrence of ,DC= in the DN with '.' in this part of the domain
         if ( !UStrICmp(curr,L",DC=",4) )
         {
            (*sPathCurr) = L'.';
            curr+=4;
         }
         else
         {
            (*sPathCurr) = (*curr);
            curr++;
         }
      }
      // null-terminate the string
      (*sPathCurr) = 0;
   }
   else
   {
      // if we can't figure it out from the path for some reason, default to the source domain
      UStrCpy(sPath+UStrLen(sPath),pOptions->srcDomain);
   }
   
   UStrCpy(sPath+UStrLen(sPath),L"/");
   UStrCpy(sPath + UStrLen(sPath),sDN);

}

BOOL GetSidString(PSID sid, WCHAR* sSid)
{
   BOOL                   ret = false;
   SAFEARRAY            * pSa = NULL;
   SAFEARRAYBOUND         bd;
   HRESULT                hr = S_OK;
   LPBYTE                 pByte = NULL;
   _variant_t             var;
   
   if (IsValidSid(sid))
   {
      DWORD len = GetLengthSid(sid);
      bd.cElements = len;
      bd.lLbound = 0;
      pSa = SafeArrayCreate(VT_UI1, 1, &bd);
      if ( pSa )
         hr = SafeArrayAccessData(pSa, (void**)&pByte);

      if ( SUCCEEDED(hr) )
      {
         for ( DWORD x = 0; x < len; x++)
            pByte[x] = ((LPBYTE)sid)[x];
         hr = SafeArrayUnaccessData(pSa);
      }
      
      if ( SUCCEEDED(hr) )
      {
         var.vt = VT_UI1 | VT_ARRAY;
         var.parray = pSa;
         VariantSidToString(var);
         wcscpy(sSid, (WCHAR*) var.bstrVal);
         ret = true;
      }
   }
   return ret;
}
//---------------------------------------------------------------------------------------------------------
// ADsPathFromDN : Constructs the AdsPath from distinguished name by looking up the Global Catalog.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::ADsPathFromDN( 
                                 Options * pOptions,     //in -Options as set by the user
                                  _bstr_t sDN,           //in -Distinguished name to be converted
                                  WCHAR * sPath,         //out-The ads path of object referenced by the DN
                                  bool bWantLDAP         //in - Flag telling us if they want LDAP path or GC path.
                                )
{
    HRESULT                   hr;
    INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
    WCHAR                     sCont[LEN_Path];
    IEnumVARIANT            * pEnum;
    WCHAR                     sQuery[LEN_Path];
    LPWSTR                    sCols[] = { L"ADsPath" };
    _variant_t                var;
    DWORD                     pFetch = 0;
    BSTR                    * pDt;
    _variant_t              * pvar;
    _variant_t                vx;
    SAFEARRAY               * pSa;
    SAFEARRAYBOUND            bd = { 1, 0 };
    long                      rc;

    pSa = SafeArrayCreate(VT_BSTR, 1, &bd);
    SafeArrayAccessData( pSa, (void HUGEP **) &pDt);
    pDt[0] = SysAllocString(sCols[0]);
    SafeArrayUnaccessData(pSa);

    //
    // Attempt to query the global catalog for specified distinguished name. If unable to
    // obtain name of global catalog server than query domain controller in source domain.
    //

    _bstr_t strGlobalCatalogServer;

    DWORD dwError = GetGlobalCatalogServer4(pOptions->srcDomain, strGlobalCatalogServer);

    if (dwError == ERROR_SUCCESS)
    {
        if ((PWSTR)strGlobalCatalogServer)
        {
            wsprintf(sCont, L"GC://%s", (PWSTR)strGlobalCatalogServer);
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        wsprintf(sCont, L"LDAP://%s", pOptions->srcDomain);
    }

    wsprintf(sQuery, L"(distinguishedName=%s)", GetEscapedFilterValue(sDN).c_str());
    hr = pQuery->raw_SetQuery(sCont, pOptions->srcDomain, sQuery, ADS_SCOPE_SUBTREE, TRUE);
    if ( FAILED(hr) )
        return hr;
    hr = pQuery->raw_SetColumns(pSa);
    if ( FAILED(hr) )
        return hr;
    hr = pQuery->raw_Execute(&pEnum);
    if ( FAILED(hr) )
        return hr;

    hr = pEnum->Next(1, &var, &pFetch);
    if ( SUCCEEDED(hr) && pFetch > 0 && (var.vt & VT_ARRAY) )
    {
        SAFEARRAY * vals = var.parray;
        // Get the VARIANT Array out
        rc = SafeArrayAccessData(vals, (void HUGEP**) &pvar);
        vx = pvar[0];
        rc = SafeArrayUnaccessData(vals);

        wcscpy(sPath, (WCHAR*)V_BSTR(&vx));
        if (bWantLDAP)
        {
            WCHAR   sTemp[LEN_Path];
            wsprintf(sTemp, L"LDAP%s", sPath + 2);
            wcscpy(sPath, sTemp);
        }
        hr = S_OK;
    }
    else
    {
        // This must not be from this forest so we need to use the LDAP://<SID=##> format
        wsprintf(sPath, L"LDAP://%s/%s", pOptions->srcDomain, (WCHAR*) sDN);
        hr = S_OK;
    }
    pEnum->Release();

    return hr;
}
                                    

//---------------------------------------------------------------------------------------------------------
// FillNamingContext : Gets the naming context for both domains if they are Win2k
//---------------------------------------------------------------------------------------------------------
BOOL CAcctRepl::FillNamingContext(
                                    Options * pOptions      //in,out-Options as set by the user
                                 )
{
   // Get the defaultNamingContext for the source domain
   IADs                    * pAds = NULL;
   WCHAR                     sAdsPath[LEN_Path];
   VARIANT                   var;
   BOOL                      rc = TRUE;
   HRESULT                   hr;

   VariantInit(&var);
   // we should always be able to get the naming context for the target domain,
   // since the target domain will always be Win2K
   if ( ! *pOptions->tgtNamingContext )
   {
      wcscpy(sAdsPath, L"LDAP://");
      wcscat(sAdsPath, pOptions->srcDomain);
      wcscat(sAdsPath, L"/rootDSE");
   
      hr = ADsGetObject(sAdsPath, IID_IADs, (void**)&pAds);
      if ( FAILED(hr))
         rc = FALSE;

      if ( SUCCEEDED (hr) )
      {
         hr = pAds->Get(L"defaultNamingContext",&var);
         if ( SUCCEEDED( hr) )
            wcscpy(pOptions->srcNamingContext, var.bstrVal);
         VariantClear(&var);
      }
      if ( pAds )
      {
         pAds->Release();
         pAds = NULL;
      }
         
      wcscpy(sAdsPath, L"LDAP://");
      wcscat(sAdsPath, pOptions->tgtDomain);
      wcscat(sAdsPath, L"/rootDSE");
   
      hr = ADsGetObject(sAdsPath, IID_IADs, (void**)&pAds);
      if ( FAILED(hr))
         rc = FALSE;

      if ( SUCCEEDED (hr) )
      {
         hr = pAds->Get(L"defaultNamingContext",&var);
         if ( SUCCEEDED( hr) )
            wcscpy(pOptions->tgtNamingContext, var.bstrVal);
         VariantClear(&var);
      }
      if ( pAds )
         pAds->Release();
   }
   return rc;
}

//---------------------------------------------------------------------------------------------------------
// ResetGroupsMembers : This method re-adds the objects in the pMember list to the group account. This
//                      resets the group to its original form. ( as before the migration ). It also
//                      takes into account the MigratedObjects table which in turn allows to add the target
//                      information of newly migrated accounts to the group instead of the source account.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::ResetGroupsMembers( 
                                       Options * pOptions,           //in- Options as set by the user
                                       TAcctReplNode * pAcct,        //in- Account being copied
                                       TNodeListSortable * pMember,  //in- Membership list to restore
                                       IIManageDBPtr pDb             //in- DB object to look up migrated objects.
                                     )
{
   // Add all the members back to the group.
   IADsGroup               * pGroup;   
   HRESULT                   hr;
   _bstr_t                   sMember;
   _bstr_t                   sPath;
   IVarSetPtr                pVs(__uuidof(VarSet));
   IUnknown                * pUnk;
   DWORD                     groupType = 0;
   _variant_t                var;
   WCHAR                     sMemPath[LEN_Path];
   WCHAR                     sPaths[LEN_Path];
   DWORD                     nPathLen = LEN_Path;
   WCHAR                     subPath[LEN_Path];

   *sMemPath = L'\0';

   
   if ( pAcct->WasReplaced() )
   {
      wcscpy(subPath, pAcct->GetTargetPath());
      StuffComputerNameinLdapPath(sPaths, nPathLen, subPath, pOptions, TRUE);
      hr = ADsGetObject(sPaths, IID_IADsGroup, (void**) &pGroup);
      err.MsgWrite(0, DCT_READDING_MEMBERS_TO_GROUP_SS, pAcct->GetTargetName(), sPaths);
   }
   else
   {
      wcscpy(subPath, pAcct->GetSourcePath());
      StuffComputerNameinLdapPath(sPaths, nPathLen, subPath, pOptions, FALSE);
      hr = ADsGetObject(sPaths, IID_IADsGroup, (void**) &pGroup);
      err.MsgWrite(0, DCT_READDING_MEMBERS_TO_GROUP_SS, pAcct->GetName(), sPaths);
   }
   if ( FAILED(hr) ) return hr;

   hr = pGroup->Get(L"groupType", &var);
   if ( SUCCEEDED(hr) )
   {
      groupType = var.lVal;  
   }

   for ( TRecordNode * pNode = (TRecordNode*)pMember->Head(); pNode; pNode = (TRecordNode*)pNode->Next())
   {
      if ( pNode->GetARNode() != pAcct ) 
         continue;
      pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);

      sMember = pNode->GetMemberSam();
      if ( pAcct->WasReplaced() && sMember.length() && !pNode->IsMemberMoved() )
      {
         hr = pDb->raw_GetAMigratedObject(sMember,pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
      }
      else
      {
         hr = S_FALSE;  // if we don't have the sam name, don't bother trying to look this one up
      }
      pUnk->Release();
      if ( hr == S_OK )
      {
         // Since we have already migrated this object lets use the target objects information.
         VerifyAndUpdateMigratedTarget(pOptions, pVs);
         sPath = pVs->get(L"MigratedObjects.TargetAdsPath");
      }
      else
         // Other wise use the source objects path to add.
         sPath = pNode->GetMember();
 
      if ( groupType & 4 )
      {
         // To add local group members we need to change the LDAP path to the SID type path
         IADs * pAds = NULL;
         hr = ADsGetObject((WCHAR*) sPath, IID_IADs, (void**) &pAds);
         if ( SUCCEEDED(hr) )
            hr = pAds->Get(L"objectSid", &var);

         if ( SUCCEEDED(hr) )
         {
            // Make sure the SID we got was in string format
            VariantSidToString(var);
            UStrCpy(sMemPath,L"LDAP://<SID=");
            UStrCpy(sMemPath + UStrLen(sMemPath),var.bstrVal);
            UStrCpy(sMemPath + UStrLen(sMemPath),L">");
         }
      }
      else
         wcscpy(sMemPath, (WCHAR*) sPath);

      WCHAR                  mesg[LEN_Path];
      wsprintf(mesg, GET_STRING(DCT_MSG_RESET_GROUP_MEMBERS_SS), pAcct->GetName(), (WCHAR*) sMemPath);
      Progress(mesg);

      if ( !pOptions->nochange )
         hr = pGroup->Add(sMemPath);
      else
         hr = S_OK;

      // Try again with LDAP path if SID path failed.
      if ( FAILED(hr) && ( groupType & 4 ) )
         hr = pGroup->Add((WCHAR*) sPath);

      if ( FAILED(hr) )
      {
         hr = BetterHR(hr);
         err.SysMsgWrite(ErrE, hr, DCT_MSG_FAILED_TO_READD_TO_GROUP_SSD,(WCHAR*)sPath, pAcct->GetName(),hr);
         Mark(L"errors", pAcct->GetType());
      }
      else
      {
         err.MsgWrite(0, DCT_MSG_READD_MEMBER_TO_GROUP_SS, (WCHAR*) sPath, pAcct->GetName());
      }
   }
   pGroup->Release();
   return hr;
}

BOOL CAcctRepl::TruncateSam(WCHAR * tgtname, TAcctReplNode * acct, Options * options, TNodeListSortable * acctList)
{
   // SInce we can not copy accounts with lenght more than 20 characters we will truncate
   // it and then add sequence numbers (0-99) in case there are duplicates.
   // we are also going to take into account the global prefix and suffix length while truncating
   // the account.
   BOOL                      ret = TRUE;
   int                       lenPref = wcslen(options->globalPrefix);
   int                       lenSuff = wcslen(options->globalSuffix);
   int                       lenOrig = wcslen(tgtname);
   int                       maxLen = 20;

   if ( !_wcsicmp(acct->GetType(), L"group") )
      maxLen = 255;
   else
      maxLen = 20;

   int                       lenTruncate = maxLen - ( 2 + lenPref + lenSuff );

   // we can not truncate accounts if prefix and suffix are > 20 characters themselves
   if ( lenPref + lenSuff > (maxLen - 2) ) return FALSE;

   WCHAR sTemp[LEN_Path];

   wcscpy(sTemp, tgtname);
   StripSamName(tgtname);

   bool bReplaced = wcscmp(tgtname, sTemp) != 0;
   bool bTruncate = lenPref + lenSuff + lenOrig > maxLen;

   if (bReplaced || bTruncate)
   {
      bool bGenerate = true;

      // if the account was previously migrated

      if (IsAccountMigrated(acct, options, options->pDb, sTemp))
      {
         //if (CheckifAccountExists(options, sTemp))
         //{
            // if prefix matches
            if ((lenPref == 0) || (_wcsnicmp(sTemp, options->globalPrefix, lenPref) == 0))
            {
               // if suffix matches
               if ((lenSuff == 0) || (_wcsnicmp(&sTemp[wcslen(sTemp) - lenSuff], options->globalSuffix, lenSuff) == 0))
               {
                  // and portion of name without sequence number matches

                  int cchName = wcslen(sTemp) - 2 - lenSuff - lenPref;

                  if ((_wcsnicmp(&sTemp[lenPref], tgtname, cchName) == 0))
                  {
                     // then use previously truncated name
                     cchName += 2;
                     wcsncpy(tgtname, &sTemp[lenPref], cchName);
                     tgtname[cchName] = 0;
                     bGenerate = false;
                  }
               }
            }
         //}
      }

      // generate truncated name without sequence number
      // if name has not been previously generated and
      // the account does not exist then use generated name

      if (bGenerate)
      {
         // Note: using swprintf instead of wsprintf because
         // swprintf supports supplying length argument for precision

         swprintf(
            sTemp,
            L"%s%.*s%s",
            lenPref ? options->globalPrefix : L"",
            lenTruncate + 2,
            tgtname,
            lenSuff ? options->globalSuffix : L""
         );

         if (acctList->Find(&TNodeFindByNameOnly, sTemp) == NULL)
         {
            if (CheckifAccountExists(options, sTemp) == false)
            {
               tgtname[lenTruncate + 2] = 0;

               if (bTruncate)
               {
                  err.MsgWrite(0, DCT_MSG_TRUNCATED_ACCOUNT_NAME_SSD, acct->GetName(), tgtname, maxLen);
               }

               bGenerate = false;
            }
         }
      }

      // generate truncated name with sequence number

      if (bGenerate)
      {
         wcsncpy(sTemp, tgtname, lenTruncate);
         sTemp[lenTruncate] = 0;
         int cnt = 0;
         bool cont = true;
         while (cont)
         {
            wsprintf(
               tgtname,
               L"%s%s%02d%s",
               lenPref ? options->globalPrefix : L"",
               sTemp,
               cnt,
               lenSuff ? options->globalSuffix : L""
            );

            if (acctList->Find(&TNodeFindByNameOnly, tgtname) || CheckifAccountExists(options, tgtname))
            {
               cnt++;
            }
            else
            {
               wsprintf(tgtname, L"%s%02d", sTemp, cnt);
               cont = false;

               // Account is truncated so log a message.
               if (bTruncate)
               {
                  err.MsgWrite(0, DCT_MSG_TRUNCATED_ACCOUNT_NAME_SSD, acct->GetName(), tgtname, maxLen);
               }
            }

            if (cnt > 99)
            {
               // We only have 2 digits for numbers so any more than this we can not handle.
               if (bTruncate)
               {
                  err.MsgWrite(ErrW,DCT_MSG_FAILED_TO_TRUNCATE_S, acct->GetTargetName());
               }
               Mark(L"warnings",acct->GetType());
               UStrCpy(tgtname, acct->GetTargetName());
               ret = FALSE;
               break;
            }
         }
      }
   }

   return ret;
}
//---------------------------------------------------------------------------------------------------------
//  FillNodeFromPath : We will take the LDAP path that is provided to us and from that fill 
//                     in all the information that is required in AcctRepl node.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::FillNodeFromPath(
                                       TAcctReplNode *pAcct, // in-Account node to fillin
                                       Options * pOptions,   //in - Options set by the users
                                       TNodeListSortable * acctList
                                   )
{
    HRESULT hr = S_OK;
    IADsPtr pAds;
    VARIANT var;
    BSTR    sText;
    WCHAR   text[LEN_Account];
    BOOL    bBuiltIn = FALSE;
    WCHAR   sSam[LEN_Path];

    VariantInit(&var);
    FillNamingContext(pOptions);

    hr = ADsGetObject(const_cast<WCHAR*>(pAcct->GetSourcePath()), IID_IADs, (void**)&pAds);
    if ( SUCCEEDED(hr) )
    {
        // Check if this is a BuiltIn account. 
        hr = pAds->Get(L"isCriticalSystemObject", &var);
        if ( SUCCEEDED(hr) )
        {
            bBuiltIn = V_BOOL(&var) == -1 ? TRUE : FALSE;
        }
        else
        {
            // This must be a NT4 account. We need to get the SID and check if
            // it's RID belongs to the BUILTIN rids.
            hr = pAds->Get(L"objectSID", &var);
            if ( SUCCEEDED(hr) )
            {
                SAFEARRAY * pArray = V_ARRAY(&var);
                PSID                 pSid;
                hr = SafeArrayAccessData(pArray, (void**)&pSid);
                if ( SUCCEEDED(hr) )
                {
                    PUCHAR ucCnt =  GetSidSubAuthorityCount(pSid);
                    DWORD * rid = (DWORD *) GetSidSubAuthority(pSid, (*ucCnt)-1);
                    bBuiltIn = BuiltinRid(*rid);
                    if ( bBuiltIn ) 
                    {
                        hr = pAds->get_Name(&sText);
                        if (SUCCEEDED(hr))
                        {
                            bBuiltIn = CheckBuiltInWithNTApi(pSid, (WCHAR*) sText, pOptions);
                        }
                        SysFreeString(sText);
                        sText = NULL;
                    }
                    hr = SafeArrayUnaccessData(pArray);
                }
                VariantClear(&var);
            }
        }

        hr = pAds->get_Class(&sText);
        if ( SUCCEEDED(hr) )
        {
            pAcct->SetType((WCHAR*) sText);
        }
        else
        {
            err.MsgWrite(ErrE, DCT_MSG_GET_REQUIRED_ATTRIBUTE_FAILED, L"objectClass", pAcct->GetSourcePath(), hr);
            Mark(L"errors", (wcslen(pAcct->GetType()) > 0) ? pAcct->GetType() : L"generic");
            pAcct->operations = 0;
            return hr;
        }

        // check if it is a group. If it is then get the group type and store it in the node.
        if ( _wcsicmp((WCHAR*) sText, L"group") == 0 )
        {
            hr = pAds->Get(L"groupType", &var);
            if ( SUCCEEDED(hr) )
            {
                pAcct->SetGroupType((long) V_INT(&var));
            }
        }

        SysFreeString(sText);
        sText = NULL;

        hr = pAds->get_Name(&sText);
        if (SUCCEEDED(hr))
        {
            safecopy(text,(WCHAR*)sText);
            pAcct->SetName(text);
        }
        else
        {
            err.MsgWrite(ErrE, DCT_MSG_GET_REQUIRED_ATTRIBUTE_FAILED, L"distinguishedName", pAcct->GetSourcePath(), hr);
            Mark(L"errors", pAcct->GetType());
            pAcct->operations = 0;
            return hr;
        }

        //if the name includes a '/', then we have to get the escaped version from the path
        //due to a bug in W2K.
        if (wcschr((WCHAR*)sText, L'/'))
        {
            _bstr_t sCNName = GetCNFromPath(_bstr_t(pAcct->GetSourcePath()));
            if (sCNName.length() != 0)
            {
                pAcct->SetName((WCHAR*)sCNName);
            }
        }

        // if inter-forest migration and source object is an InetOrgPerson then...

        if ((pOptions->bSameForest == FALSE) && (_wcsicmp(pAcct->GetType(), s_ClassInetOrgPerson) == 0))
        {
            //
            // must use the naming attribute of the target forest
            //

            // retrieve naming attribute for this class in target forest

            SNamingAttribute naNamingAttribute;

            hr = GetNamingAttribute(pOptions->tgtDomainDns, s_ClassInetOrgPerson, naNamingAttribute);

            if (FAILED(hr))
            {
                err.MsgWrite(ErrE, DCT_MSG_CANNOT_GET_NAMING_ATTRIBUTE_SS, s_ClassInetOrgPerson, pOptions->tgtDomainDns);
                Mark(L"errors", pAcct->GetType());
                return hr;
            }

            _bstr_t strNamingAttribute(naNamingAttribute.strName.c_str());

            // retrieve source attribute value

            VARIANT var;
            VariantInit(&var);

            hr = pAds->Get(strNamingAttribute, &var);

            if (FAILED(hr))
            {
                err.MsgWrite(ErrE, DCT_MSG_CANNOT_GET_SOURCE_ATTRIBUTE_REQUIRED_FOR_NAMING_SSS, naNamingAttribute.strName.c_str(), pAcct->GetSourcePath(), pOptions->tgtDomainDns);
                Mark(L"errors", pAcct->GetType());
                return hr;
            }

            // set target naming attribute value from source attribute value

            pAcct->SetTargetName(strNamingAttribute + L"=" + _bstr_t(_variant_t(var, false)));
        }
        else
        {
            // else set target name equal to source name
            pAcct->SetTargetName(pAcct->GetName());
        }

        hr = pAds->Get(L"sAMAccountName", &var);
        if ( SUCCEEDED(hr))
        {
            // Add the prefix or the suffix as it is needed
            wcscpy(sSam, (WCHAR*)V_BSTR(&var));
            pAcct->SetSourceSam(sSam);
            TruncateSam(sSam, pAcct, pOptions, acctList);
            pAcct->SetTargetSam(sSam);
            AddPrefixSuffix(pAcct, pOptions);
            VariantClear(&var);
        }
        else
        {
            wcscpy(sSam, sText);
            pAcct->SetSourceSam(sSam);
            TruncateSam(sSam, pAcct, pOptions, acctList);
            pAcct->SetTargetSam(sSam);
            AddPrefixSuffix(pAcct, pOptions);
        }

        SysFreeString(sText);
        sText = NULL;

        // Don't know why it is different for WinNT to ADSI
        if ( pOptions->srcDomainVer > 4 )
            hr = pAds->Get(L"profilePath", &var);
        else
            hr = pAds->Get(L"profile", &var);

        if ( SUCCEEDED(hr))
        {
            pAcct->SetSourceProfile((WCHAR*) V_BSTR(&var));
            VariantClear(&var);
        }
        else
        {
            hr = S_OK;
        }

        if ( bBuiltIn )
        {
            // Builtin account so we are going to ignore this account. ( by setting the operation mask to 0 )
            err.MsgWrite(ErrW, DCT_MSG_IGNORING_BUILTIN_S, pAcct->GetSourceSam());
            Mark(L"warnings", pAcct->GetType());
            pAcct->operations = 0;
        }
    }
    else
    {
        err.SysMsgWrite(ErrE, hr, DCT_MSG_OBJECT_NOT_FOUND_SSD, pAcct->GetSourcePath(), opt.srcDomain, hr);
        Mark(L"errors", (wcslen(pAcct->GetType()) > 0) ? pAcct->GetType() : L"generic");
        pAcct->operations = 0;
    }

    return hr;
}


//---------------------------------------------------------------------------------------------------------
// GetNt4Type : Given the account name and the domain finds the type of account.
//---------------------------------------------------------------------------------------------------------
BOOL CAcctRepl::GetNt4Type(const WCHAR *sComp, const WCHAR *sAcct, WCHAR *sType)
{
   DWORD                     rc = 0;
   USER_INFO_0             * buf;
   BOOL                      ret = FALSE;
   USER_INFO_1             * specialBuf;

   if ( (rc = NetUserGetInfo(sComp, sAcct, 1, (LPBYTE *) &specialBuf)) == NERR_Success )
   {
      if ( specialBuf->usri1_flags & UF_WORKSTATION_TRUST_ACCOUNT 
         || specialBuf->usri1_flags & UF_SERVER_TRUST_ACCOUNT 
         || specialBuf->usri1_flags & UF_INTERDOMAIN_TRUST_ACCOUNT )
      {
         // this is not really a user (maybe a computer or a trust account) So we will ignore it.
         ret = FALSE;
      }
      else
      {
         wcscpy(sType, L"user");
         ret = TRUE;
      }
      NetApiBufferFree(specialBuf);
   }
   else if ( (rc = NetGroupGetInfo(sComp, sAcct, 0, (LPBYTE *) &buf)) == NERR_Success )
   {
      wcscpy(sType, L"group");
      NetApiBufferFree(buf);
      ret = TRUE;
   }
   else if ( (rc = NetLocalGroupGetInfo(sComp, sAcct, 0, (LPBYTE *) &buf)) == NERR_Success )
   {
      wcscpy(sType, L"group");
      NetApiBufferFree(buf);
      ret = TRUE;
   }

   return ret;
}


//------------------------------------------------------------------------------
// UndoCopy: This function Undoes the copying of the accounts. It currently
//           does the following tasks. Add to it if needed.
//           1. Deletes the target account if Inter-Forest, but replace source acocunts
//              in local groups for accounts migrated by ADMT.
//           2. Moves the object back to its original position if Intra-Forest.
//           3. Calls the Undo function on the Extensions 
//------------------------------------------------------------------------------
int CAcctRepl::UndoCopy(
                        Options              * options,      // in -options
                        TNodeListSortable    * acctlist,     // in -list of accounts to process
                        ProgressFn           * progress,     // in -window to write progress messages to
                        TError               & error,        // in -window to write error messages to
                        IStatusObj           * pStatus,      // in -status object to support cancellation
                        void                   WindowUpdate (void )    // in - window update function
                    )
{
   BOOL bSameForest = FALSE;
   
   // sort the account list by Source Type\Source Name
   acctlist->CompareSet(&TNodeCompareAccountType);

   acctlist->SortedToScrambledTree();
   acctlist->Sort(&TNodeCompareAccountType);
   acctlist->Balance();

   long rc;
   // Since these are Win2k domains we need to process it with Win2k code.
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   // First of all we need to find out if they are in the same forest.
   HRESULT hr = S_OK;
   if ( BothWin2K(options) )
   {
      hr = pAccess->raw_IsInSameForest(options->srcDomainDns,options->tgtDomainDns, (long*)&bSameForest);
   }
   if ( SUCCEEDED(hr) )
   {
      if ( !bSameForest )
         // Different forest we need to delete the one that we had previously created.
         rc = DeleteObject(options, acctlist, progress, pStatus);
      else
      {
         // Within a forest we can move the object around.
         TNodeListSortable          * pList = NULL;
         hr = MakeAcctListFromMigratedObjects(options, options->lUndoActionID, pList,TRUE);
         if ( SUCCEEDED(hr) && pList )
         {
            if ( pList->IsTree() ) pList->ToSorted();
            pList->CompareSet(&TNodeCompareAccountType);
            pList->UnsortedToTree();
            pList->Balance();

            rc = MoveObj2K(options, pList, progress, pStatus);
         }
         else
         {
            err.SysMsgWrite(ErrE,hr,DCT_MSG_FAILED_TO_LOAD_UNDO_LIST_D,hr);
            Mark(L"errors", L"generic");
         }
      }

      if ( progress )
         progress(L"");
   }
   return rc;
}

int CAcctRepl::DeleteObject( 
                           Options              * pOptions,    //in -Options that we recieved from the user
                           TNodeListSortable    * acctlist,    //in -AcctList of accounts to be copied.
                           ProgressFn           * progress,    //in -Progress Function to display messages
                           IStatusObj           * pStatus      // in -status object to support cancellation
                        )
{
   TNodeListSortable       * pList = NULL;
   TNodeTreeEnum             tenum;
   TAcctReplNode           * acct = NULL, * tNext = NULL;
   HRESULT                   hr = S_OK;
   DWORD                     rc = 0;
   WCHAR                     mesg[LEN_Path];
   IUnknown                * pUnk = NULL;
   IVarSetPtr                pVs(__uuidof(VarSet));
   _variant_t                var;
      
   hr = MakeAcctListFromMigratedObjects(pOptions, pOptions->lUndoActionID, pList,FALSE);
   
   if ( SUCCEEDED(hr) && pList )
   {
      if ( pList->IsTree() ) pList->ToSorted();
      pList->SortedToScrambledTree();
      pList->Sort(&TNodeCompareAccountSam);
      pList->Balance();
   
      /* restore source account of account being deleted in local groups prior to deleting 
         the target account */
      wcscpy(mesg, GET_STRING(IDS_LG_MEMBER_FIXUP_UNDO));
      if ( progress )
         progress(mesg);
      ReplaceSourceInLocalGroup(pList, pOptions, pStatus);

      for ( acct = (TAcctReplNode *)tenum.OpenFirst(pList) ; acct ; acct = tNext)
      {
         // Call the extensions for undo
         wsprintf(mesg, GET_STRING(IDS_RUNNING_EXTS_S), acct->GetTargetPath());
         if ( progress )
            progress(mesg);
         Mark(L"processed",acct->GetType());
         // Close the log file if it is open
         WCHAR          filename[LEN_Path];
         err.LogClose();
         if (m_pExt)
            m_pExt->Process(acct, pOptions->tgtDomain, pOptions,FALSE);
         safecopy (filename,opt.logFile);
         err.LogOpen(filename,1 /*append*/ );

         if ( acct->GetStatus() & AR_Status_Created )
         {
            wsprintf(mesg, GET_STRING(IDS_DELETING_S), acct->GetTargetPath());
            if ( progress ) progress(mesg);
            if ( ! _wcsicmp(acct->GetType(),L"computer") )
            {
               // do not delete the computer accounts, because if we do,
               // the computer will be immediately locked out of the domain
               tNext = (TAcctReplNode *) tenum.Next();
               pList->Remove(acct);
               delete acct;
               continue;
            }

            //
            // If updating of rights was specified and objects are being deleted from a W2K domain
            // then explicitly remove rights for objects as W2K does not automatically remove
            // rights when an object is deleted.
            //

            if (m_UpdateUserRights && (pOptions->tgtDomainVer == 5) && (pOptions->tgtDomainVerMinor == 0))
            {
                hr = EnumerateAccountRights(TRUE, acct);

                if (SUCCEEDED(hr))
                {
                    RemoveAccountRights(TRUE, acct);
                }
            }

            // Now delete the account.
            if ( !_wcsicmp(acct->GetType(), s_ClassUser) || !_wcsicmp(acct->GetType(), s_ClassInetOrgPerson) )
               rc = NetUserDel(pOptions->tgtComp, acct->GetTargetSam());
            else
            {
               // Must be a group try both local and global.
               rc = NetGroupDel(pOptions->tgtComp, acct->GetTargetSam());
               if ( rc )
                  rc = NetLocalGroupDel(pOptions->tgtComp, acct->GetTargetSam());
            }
            
             // Log a message
            if ( !rc ) 
            {
               err.MsgWrite(0, DCT_MSG_ACCOUNT_DELETED_S, (WCHAR*)acct->GetTargetPath());
               Mark(L"created",acct->GetType());
            }
            else
            {
               err.SysMsgWrite(ErrE, rc, DCT_MSG_DELETE_ACCOUNT_FAILED_SD, (WCHAR*)acct->GetTargetPath(), rc);
               Mark(L"errors", acct->GetType());
            }
         }
         else
         {
            err.MsgWrite(ErrW, DCT_MSG_NO_DELETE_WAS_REPLACED_S, acct->GetTargetPath());
            Mark(L"warnings",acct->GetType());
         }
         tNext = (TAcctReplNode *) tenum.Next();
         pList->Remove(acct);
         delete acct;
      }
      tenum.Close();
      delete pList;
   }

   if ( pUnk ) pUnk->Release();

   return rc;
}

HRESULT CAcctRepl::MakeAcctListFromMigratedObjects(Options * pOptions, long lUndoActionID, TNodeListSortable *& pAcctList,BOOL bReverseDomains)
{
   IVarSetPtr                pVs(__uuidof(VarSet));
   IUnknown                * pUnk = NULL;
   HRESULT                   hr = S_OK;
   _bstr_t                   sSName, sTName, sSSam, sTSam, sType, sSUPN, sSDSid;
   long                      lSRid, lTRid;
   long                      lStat;
   WCHAR                     sActionInfo[LEN_Path];

   hr = pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
   if ( SUCCEEDED(hr) )
      hr = pOptions->pDb->raw_GetMigratedObjects( pOptions->lUndoActionID, &pUnk);

   if ( SUCCEEDED(hr) )
   {
      pAcctList = new TNodeListSortable();
      if (!pAcctList)
         return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
      
      long lCnt = pVs->get("MigratedObjects");
   
      for ( long l = 0; l < lCnt; l++)
      {
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_SourceAdsPath));      
         sSName = pVs->get(sActionInfo);

         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_TargetAdsPath));      
         sTName = pVs->get(sActionInfo);
         
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_status));      
         lStat = pVs->get(sActionInfo);
         
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_TargetSamName));      
         sTSam = pVs->get(sActionInfo);
         
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_SourceSamName));      
         sSSam = pVs->get(sActionInfo);

         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_Type));      
         sType = pVs->get(sActionInfo);
       
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_SourceDomainSid));      
         sSDSid = pVs->get(sActionInfo);
       
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_SourceRid));      
         lSRid = pVs->get(sActionInfo);
       
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_TargetRid));      
         lTRid = pVs->get(sActionInfo);
       
         TAcctReplNode * pNode = new TAcctReplNode();
         if (!pNode)
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

         if ( bReverseDomains )
         {
            pNode->SetSourcePath((WCHAR*) sTName);
            pNode->SetTargetPath((WCHAR*) sSName);
            pNode->SetSourceSam((WCHAR*) sTSam);
            pNode->SetTargetSam((WCHAR*) sSSam);
            pNode->SetSourceRid(lTRid);
            pNode->SetTargetRid(lSRid);
            
               //if we are moving the acounts back during an undo, get the source UPN for this account
            GetAccountUPN(pOptions, sSName, sSUPN);
            pNode->SetSourceUPN((WCHAR*) sSUPN);
         }
         else
         {
            pNode->SetSourcePath((WCHAR*) sSName);
            pNode->SetTargetPath((WCHAR*) sTName);
            pNode->SetSourceSam((WCHAR*) sSSam);
            pNode->SetTargetSam((WCHAR*) sTSam);
            pNode->SetSourceRid(lSRid);
            pNode->SetTargetRid(lTRid);
         }
         pNode->SetType((WCHAR*) sType);
         pNode->SetStatus(lStat);
         pNode->SetSourceSid(SidFromString((WCHAR*)sSDSid));
         pAcctList->InsertBottom((TNode*) pNode);
      }
   }
   return hr;
}

void CAcctRepl::AddPrefixSuffix( TAcctReplNode * pNode, Options * pOptions )
{
   DWORD dwLen = 0;
   c_array<WCHAR> achSs(LEN_Path);
   c_array<WCHAR> achTgt(LEN_Path);
   c_array<WCHAR> achPref(LEN_Path);
   c_array<WCHAR> achSuf(LEN_Path);
   c_array<WCHAR> achTemp(LEN_Path);
   c_array<WCHAR> achTargetSamName(LEN_Path);

   wcscpy(achTargetSamName, pNode->GetTargetSam());
   if ( wcslen(pOptions->globalPrefix) )
   {
      int truncate = 255;
      if ( !_wcsicmp(pNode->GetType(), s_ClassUser) || !_wcsicmp(pNode->GetType(), s_ClassInetOrgPerson) )
      {
         truncate = 20 - wcslen(pOptions->globalPrefix);
      }
      else  if ( !_wcsicmp(pNode->GetType(), L"computer") )
      {
         // fix up the trailing $
         // assume that achTargetSamName always ends with $
         // if the length of achTargetSamName (including $) is greater than truncate,
         // we need to add in $ before string terminator
         // since the trailing $ comes from the original sam name, we use MAX_COMPUTERNAME_LENGTH + 1
         // to calculate the truncation position
         truncate = MAX_COMPUTERNAME_LENGTH + 1 - wcslen(pOptions->globalPrefix);
         if (truncate < wcslen(achTargetSamName))
         {
            WCHAR sTruncatedSamName[LEN_Path];
            wcscpy(sTruncatedSamName, achTargetSamName);
            sTruncatedSamName[truncate - 1] = L'$';
            sTruncatedSamName[truncate] = L'\0';
            err.MsgWrite(0, DCT_MSG_TRUNCATED_COMPUTER_NAME_SSD, (WCHAR*)achTargetSamName, sTruncatedSamName, MAX_COMPUTERNAME_LENGTH); 
            achTargetSamName[truncate - 1] = L'$';
         }            
      }

      // make sure we truncate the account so we dont get account names that are very large.
      achTargetSamName[truncate] = L'\0';

      // Prefix is specified so lets just add that.
      wsprintf(achTemp, L"%s%s", pOptions->globalPrefix, (WCHAR*)achTargetSamName);

      wcscpy(achTgt, pNode->GetTargetName());
      for ( DWORD z = 0; z < wcslen(achTgt); z++ )
      {
         if ( achTgt[z] == L'=' ) break;
      }
      
      if ( z < wcslen(achTgt) )
      {
         // Get the prefix part ex.CN=
         wcsncpy(achPref, achTgt, z+1);
         achPref[z+1] = 0;
         wcscpy(achSuf, achTgt+z+1);
      }
      else
      {
         wcscpy(achPref,L"");
         wcscpy(achSuf,achTgt);
      }

      // Remove the \ if it is escaping the space
      if ( achSuf[0] == L'\\' && achSuf[1] == L' ' )
      {
         WCHAR       achTemp[LEN_Path];
         wcscpy(achTemp, achSuf+1);
         wcscpy(achSuf, achTemp);
      }
      // Build the target string with the Prefix
      wsprintf(achTgt, L"%s%s%s", (WCHAR*)achPref, pOptions->globalPrefix, (WCHAR*)achSuf);

      pNode->SetTargetSam(achTemp);
      pNode->SetTargetName(achTgt);
   }
   else if ( wcslen(pOptions->globalSuffix) )
   {
      
      int truncate = 255;
      if ( !_wcsicmp(pNode->GetType(), s_ClassUser) || !_wcsicmp(pNode->GetType(), s_ClassInetOrgPerson) )
      {
         truncate = 20 - wcslen(pOptions->globalSuffix);
      }
      else  if ( !_wcsicmp(pNode->GetType(), L"computer") )
      {
         // since the trailing $ does not come from the original sam name, we have to use MAX_COMPUTERNAME_LENGTH
         // to calculate the truncation position
         truncate = MAX_COMPUTERNAME_LENGTH - wcslen(pOptions->globalSuffix);
         if (truncate < wcslen(achTargetSamName))
         {
            WCHAR sTruncatedSamName[LEN_Path];
            wcscpy(sTruncatedSamName, achTargetSamName);
            sTruncatedSamName[truncate] = L'$';
            sTruncatedSamName[truncate + 1] = L'\0';
            err.MsgWrite(0, DCT_MSG_TRUNCATED_COMPUTER_NAME_SSD, (WCHAR*)achTargetSamName, sTruncatedSamName, MAX_COMPUTERNAME_LENGTH); 
         }
      }

      // make sure we truncate the account so we dont get account names that are very large.
      achTargetSamName[truncate] = L'\0';

      // Suffix is specified.
      if ( !_wcsicmp( pNode->GetType(), L"computer") )
      {
         // We need to make sure we take into account the $ sign in computer sam name.
         dwLen = wcslen(achTargetSamName);
         // Get rid of the $ sign
         wcscpy(achSs, achTargetSamName);
         if ( achSs[dwLen - 1] == L'$' ) 
         {
            achSs[dwLen - 1] = L'\0';
         }
         wsprintf(achTemp, L"%s%s$", (WCHAR*)achSs, pOptions->globalSuffix);
      }
      else
      {
         //Simply add the suffix to all other accounts.
         wsprintf(achTemp, L"%s%s", (WCHAR*)achTargetSamName, pOptions->globalSuffix);
      }

      // Remove the trailing space \ escape sequence
      wcscpy(achTgt, pNode->GetName());
      for ( int i = wcslen(achTgt)-1; i >= 0; i-- )
      {
         if ( achTgt[i] != L' ' )
            break;
      }

      if ( achTgt[i] == L'\\' )
      {
         WCHAR * pTemp = &achTgt[i];
         *pTemp = 0;
         wcscpy(achPref, achTgt);
         wcscpy(achSuf, pTemp+1);
      }
      else
      {
         wcscpy(achPref, achTgt);
         wcscpy(achSuf, L"");
      }
      wsprintf(achTgt, L"%s%s%s", (WCHAR*)achPref, (WCHAR*)achSuf, pOptions->globalSuffix);

      pNode->SetTargetSam(achTemp);
      pNode->SetTargetName(achTgt);
   }
}

void CAcctRepl::BuildTargetPath(WCHAR const * sCN, WCHAR const * tgtOU, WCHAR * stgtPath)
{
   WCHAR pTemp[LEN_Path];
   DWORD dwArraySizeOfpTemp = sizeof(pTemp)/sizeof(pTemp[0]);

   if (tgtOU == NULL)
      _com_issue_error(E_INVALIDARG);
   if (wcslen(tgtOU) >= dwArraySizeOfpTemp)
      _com_issue_error(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
   wcscpy(pTemp, tgtOU);
   *stgtPath = L'\0';
   // Make sure it is a LDAP path.
   if ( !wcsncmp(L"LDAP://", pTemp, 7) )
   {
      // Get the LDAP://<DOMAIN>/ part.
      WCHAR * p = wcschr(pTemp + 7, L'/');
      // Build the string.
      if (p)
      {
         *p = L'\0';
         wsprintf(stgtPath, L"%s/%s,%s", pTemp, sCN, p+1);
      }
   }
}

HRESULT CAcctRepl::BetterHR(HRESULT hr)
{
   HRESULT temp = hr;
   if ( hr == 0x8007001f || hr == 0x80071392 ) temp = HRESULT_FROM_WIN32(NERR_UserExists);
   else if ( hr == 0x80072030 || hr == 0x80070534 ) temp = HRESULT_FROM_WIN32(NERR_UserNotFound);
   return temp;
}

HRESULT CAcctRepl::GetThePrimaryGroupMembers(Options * pOptions, WCHAR * sGroupSam, IEnumVARIANT ** pVar)
{
   // This function looks for accounts that have the primaryGroupID set to the rid of the
   // group in the argument. 
   BSTR                      pCols = L"aDSPath";
   DWORD                     rid = 0;
   HRESULT                   hr;
   if ( GetRidForGroup(pOptions, sGroupSam, rid) )
      hr = QueryPrimaryGroupMembers(pCols, pOptions, rid, pVar);
   else
      hr = HRESULT_FROM_WIN32(GetLastError());

   return hr;
}

HRESULT CAcctRepl::AddPrimaryGroupMembers(Options * pOptions, SAFEARRAY * multiVals, WCHAR * sGroupSam)
{
   // This function will get the accounts with primarygroupID = Group's RID and
   // adds the DN for these Accounts to the safearry in the argument list.
   BSTR                      pCols = L"distinguishedName";
   DWORD                     rid = 0, dwFetch = 0;
   IEnumVARIANT            * pEnum = NULL;
   HRESULT                   hr = S_OK;
   _variant_t                var;
   _variant_t              * var2;
   SAFEARRAYBOUND            bd;
   long                      lb, ub;
   _variant_t              * pData = NULL;

   SafeArrayGetLBound(multiVals, 1, &lb);
   SafeArrayGetUBound(multiVals, 1, &ub);
   bd.lLbound = lb;
   bd.cElements = ub - lb + 1;
   if ( GetRidForGroup(pOptions, sGroupSam, rid) )
   {
      hr = QueryPrimaryGroupMembers(pCols, pOptions, rid, &pEnum);
      if ( SUCCEEDED(hr) )
      {
         while ( pEnum->Next(1, &var, &dwFetch) == S_OK )
         {
            if (var.vt == (VT_ARRAY|VT_VARIANT))
            {
               SAFEARRAY * pArray = var.parray;
               hr = SafeArrayAccessData(pArray, (void **)&var2);
               if ( SUCCEEDED(hr) )
               {
                  // Add one more element to the array.
                  bd.cElements++;
                  hr = SafeArrayRedim(multiVals, &bd);
               }

               // Fill in the new element with the information in the variant.
               if ( SUCCEEDED(hr) )
                  hr = SafeArrayAccessData(multiVals, (void HUGEP**) &pData);

               if ( SUCCEEDED(hr) )
               {
                  pData[++ub] = *var2;
                  SafeArrayUnaccessData(multiVals);
               }
               if ( SUCCEEDED(hr) )
                  SafeArrayUnaccessData(pArray);
               
               var.Clear();
            }
            else
               // Something really bad happened we should not get here in normal cond
               hr = E_FAIL;
         }
      }
   }
   else
      hr = HRESULT_FROM_WIN32(GetLastError());

   if ( pEnum ) pEnum->Release();
   return hr;
}

bool CAcctRepl::GetRidForGroup(Options * pOptions, WCHAR * sGroupSam, DWORD& rid)
{
   // We lookup the Account name and get its SID. Once we have the SID we extract the RID and return that
   SID_NAME_USE              use;
   PSID                      sid = (PSID) new BYTE[LEN_Path];
   WCHAR                     dom[LEN_Path];
   DWORD                     cbsid = LEN_Path, cbDom = LEN_Path;
   bool                      ret = true;

   if (!sid)
      return false;

   if ( LookupAccountName(pOptions->srcComp, sGroupSam, sid, &cbsid, dom, &cbDom, &use) )
   {
      // we now have the sid so get its sub authority count.
      PUCHAR pSubCnt = GetSidSubAuthorityCount(sid);
      DWORD * pRid = GetSidSubAuthority(sid, (*pSubCnt) -1 );
      rid = *pRid;
   }
   else
      ret = false;
   
   delete [] sid;
   return ret;
}

HRESULT CAcctRepl::QueryPrimaryGroupMembers(BSTR cols, Options * pOptions, DWORD rid, IEnumVARIANT** pEnum)
{
   WCHAR                     sQuery[LEN_Path];
   WCHAR                     sCont[LEN_Path];
   SAFEARRAY               * colNames;
   SAFEARRAYBOUND            bd = { 1, 0 };
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   BSTR                    * pData;
   HRESULT                   hr;

   wsprintf(sQuery, L"(primaryGroupID=%d)", rid);
   wsprintf(sCont, L"LDAP://%s", pOptions->srcDomain);

   colNames = SafeArrayCreate(VT_BSTR, 1, &bd);

   hr = SafeArrayAccessData(colNames, (void**)&pData);

   if ( SUCCEEDED(hr) )
   {
      pData[0] = SysAllocString(cols);
      hr = SafeArrayUnaccessData(colNames);
   }

    if ( SUCCEEDED(hr) )
        hr = pQuery->SetQuery(sCont, pOptions->srcDomain, sQuery, ADS_SCOPE_SUBTREE, FALSE);
        
    if ( SUCCEEDED(hr) )
        hr = pQuery->SetColumns(colNames);

    if ( SUCCEEDED(hr) )
        hr = pQuery->Execute(pEnum);

   return hr;
}

// CheckBuiltInWithNTApi - This function makes sure that the account really is a 
//                          builtin account with the NT APIs. In case of NT4 accounts
//                         there are certain special accounts that the WinNT provider
//                         gives us a SID that is the SYSTEM sid ( example Service ).
//                         To make sure that this account exists we use LookupAccountName
//                         with domain qualified account name to make sure that the account
//                         is really builtin or not.
BOOL CAcctRepl::CheckBuiltInWithNTApi(PSID pSid, WCHAR *sSam, Options * pOptions)
{
   BOOL                      retVal = TRUE;
   WCHAR                     sName[LEN_Path];
   SID_NAME_USE              use;
   DWORD                     cbDomain = LEN_Path, cbSid = LEN_Path;
   PSID                      pAccSid = new BYTE[LEN_Path];
   WCHAR                     sDomain[LEN_Path];

   if (!pAccSid)
      return TRUE;

   wsprintf(sName, L"%s\\%s", pOptions->srcDomainFlat, sSam);
   if ( LookupAccountName(pOptions->srcComp, sName, pAccSid, &cbSid, sDomain, &cbDomain, &use) )
   {
      // We found the account now we need to check the sid with the sid passed in and if they
      // are the same then this is a builtin account otherwise its not.
      retVal = EqualSid(pSid, pAccSid);
   }
   delete [] pAccSid;
   return retVal;
}

BOOL CAcctRepl::StuffComputerNameinLdapPath(WCHAR *sAdsPath, DWORD nPathLen, WCHAR *sSubPath, Options *pOptions, BOOL bTarget)
{
   BOOL                      ret = FALSE;
   _bstr_t                   sTemp;

   if ((!sAdsPath) || (!sSubPath))
      return FALSE;

   WCHAR * pTemp = wcschr(sSubPath + 7, L'/');     // Filter out the 'LDAP://<domain-name>/' from the path
   if ( pTemp )
   {                           
      sTemp = L"LDAP://";
      if ( bTarget )
         sTemp += (pOptions->tgtComp + 2);
      else
         sTemp += (pOptions->srcComp + 2);
      sTemp += L"/";
      sTemp += (pTemp + 1);

      if (sTemp.length() > 0)
      {
          wcsncpy(sAdsPath, sTemp, nPathLen-1);
          ret = TRUE;
      }
   }
   return ret;
}

BOOL CAcctRepl::DoesTargetObjectAlreadyExist(TAcctReplNode * pAcct, Options * pOptions)
{
   // Check to see if the target object already exists
   WCHAR          sPath[LEN_Path];
   DWORD          nPathLen = LEN_Path;
   BOOL           bObjectExists = FALSE;
   WCHAR        * pRelativeTgtOUPath;
   WCHAR          path[LEN_Path] = L"";
   IADs         * pAdsTemp = NULL;
   WCHAR          sSrcTemp[LEN_Path];
   WCHAR          *  pTemp = NULL;



   // First, check the target path, to see if an object with the same CN already exists
   if ( ! pOptions->bUndo )
   {
      MakeFullyQualifiedAdsPath(sPath, nPathLen, pOptions->tgtOUPath, pOptions->tgtDomain, pOptions->tgtNamingContext);
      pRelativeTgtOUPath = wcschr(sPath + UStrLen(L"LDAP://") + 2,L'/');
   }
   else
   {
      UStrCpy(sPath,pAcct->GetTargetPath());
      pRelativeTgtOUPath = wcschr(sPath + UStrLen(L"LDAP://") + 2,L'/');
      
      if (pRelativeTgtOUPath)
      {
          // get the target CN name
          pTemp = pRelativeTgtOUPath + 1;
          (*pRelativeTgtOUPath) = 0;
          do 
          {
             pRelativeTgtOUPath = wcschr(pRelativeTgtOUPath+1,L',');

          } while ((pRelativeTgtOUPath) && ( *(pRelativeTgtOUPath-1) == L'\\' ));
      }
   }

   if ( pRelativeTgtOUPath )
   {
      *pRelativeTgtOUPath = 0;
      if ( pOptions->bUndo && pTemp )
      {
         pAcct->SetTargetName(pTemp);
         // get the source CN name for the account
         UStrCpy(sSrcTemp,pAcct->GetSourcePath());
         WCHAR * start = wcschr(sSrcTemp + UStrLen(L"LDAP://")+2,L'/');
         *start = 0;
         start++;

         WCHAR * comma = start-1;
         do 
         {
            comma = wcschr(comma+1,L',');
         } while ( *(comma-1) == L'\\' );
         *comma = 0;
         pAcct->SetName(start);
      }
      swprintf(path,L"%ls/%ls,%ls",sPath,pAcct->GetTargetName(),pRelativeTgtOUPath+1);
      if ( pOptions->bUndo )
      {
         UStrCpy(pOptions->tgtOUPath,pRelativeTgtOUPath+1);
      }

   }
   else
   {
      MakeFullyQualifiedAdsPath(path, nPathLen, pOptions->tgtOUPath, pOptions->tgtDomain, pOptions->tgtNamingContext);
   }
   HRESULT hr = ADsGetObject(path,IID_IADs,(void**)&pAdsTemp);
   if ( SUCCEEDED(hr) )
   {
      pAdsTemp->Release();
      bObjectExists = TRUE;
   }

   // Also, check the SAM name to see if it exists on the target
   hr = LookupAccountInTarget(pOptions,const_cast<WCHAR*>(pAcct->GetTargetSam()),sPath);
   if ( SUCCEEDED(hr) )
   {
      bObjectExists = TRUE;
   }
   else
   {
      hr = 0;
   }

   return bObjectExists;
}


//-----------------------------------------------------------------------------------------
// UpdateMemberToGroups This function updates the groups that the accounts are members of.
//                      adding this member to all the groups that have been migrated.
//-----------------------------------------------------------------------------------------
HRESULT CAcctRepl::UpdateMemberToGroups(TNodeListSortable * acctList, Options *pOptions, BOOL bGrpsOnly)
{
   TNodeListSortable         newList;
   WCHAR                     mesg[LEN_Path];
   HRESULT                   hr = S_OK;

   // Expand the containers and the membership
   wcscpy(mesg, GET_STRING(IDS_EXPANDING_MEMBERSHIP));
   Progress(mesg);
   // Expand the list to include all the groups that the accounts in this list are members of
   newList.CompareSet(&TNodeCompareAccountTypeAndRDN); //set to sort by type and source path RDN
   if ( !newList.IsTree() ) newList.SortedToTree();
   // Call expand membership function to get a list of all groups that contain as members objects in our account list
   if ( ExpandMembership( acctList, pOptions, &newList, Progress, bGrpsOnly, TRUE) )
   {
      if ( newList.IsTree() ) newList.ToSorted();
      TNodeListEnum                   e;
      Lookup                          p;
      for (TAcctReplNode* pNode = (TAcctReplNode *)e.OpenFirst((TNodeList*)&newList); pNode; pNode = (TAcctReplNode*)e.Next())
      {
         hr = S_OK;
         IADsGroupPtr spGroup;
         _bstr_t strGroupName;

         // go through each of the account nodes in the newly added account list. Since
         // we have special map that contain the members information we can use that

         //For each member in the member map for this group, find the account node that corresponds to the member 
         //information and possibly add the member to the group
         CGroupMemberMap::iterator itGrpMemberMap;
         for (itGrpMemberMap = pNode->mapGrpMember.begin(); itGrpMemberMap != pNode->mapGrpMember.end(); itGrpMemberMap++)
         {
            p.pName = (WCHAR*)(itGrpMemberMap->first);
            p.pType = (WCHAR*)(itGrpMemberMap->second);
         
            TAcctReplNode * pNodeMember = (TAcctReplNode *) acctList->Find(&TNodeFindAccountName, &p);

            bool bIgnored = false;
            if (pNodeMember)
                bIgnored = ((!pNodeMember->WasReplaced()) && (pNodeMember->GetStatus() & AR_Status_AlreadyExisted));

            // If we found one ( we should always find one. ) and the member was successfuly
            // added or replaced the member information.
            if ( pNodeMember && ((pNodeMember->WasCreated() || pNodeMember->WasReplaced()) || bIgnored))
            {
                // Get the Group pointer (once per group) and add the target object to the member.
                if (spGroup)
                {
                    hr = S_OK;
                }
                else
                {
                    hr = ADsGetObject(const_cast<WCHAR*>(pNode->GetTargetPath()), IID_IADsGroup, (void**)&spGroup);

                    if (SUCCEEDED(hr))
                    {
                       BSTR bstr = 0;
                       spGroup->get_Name(&bstr);
                       strGroupName = _bstr_t(bstr, false);
                    }
                }

                if ( SUCCEEDED(hr) )
                {
                    if ( pOptions->nochange )
                    {
                        VARIANT_BOOL               bIsMem;
                        hr = spGroup->IsMember(const_cast<WCHAR*>(pNodeMember->GetTargetPath()), &bIsMem);
                        if ( SUCCEEDED(hr) )
                        {
                            if ( bIsMem )
                                hr = HRESULT_FROM_WIN32(NERR_UserExists);
                        }
                    }
                    else
                    {
                            //add the new account to the group
                        hr = spGroup->Add(const_cast<WCHAR*>(pNodeMember->GetTargetPath()));

                        /* if the new account's source account is also in the group, remove it */
                        IIManageDBPtr pDB = pOptions->pDb;
                        IVarSetPtr pVsTemp(__uuidof(VarSet));
                        IUnknownPtr spUnknown(pVsTemp);
                        IUnknown* pUnk = spUnknown;
            
                            //is this account in the migrated objects table 
                        HRESULT hrGet = pDB->raw_GetAMigratedObject(_bstr_t(pNodeMember->GetSourceSam()), pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
                        if (hrGet == S_OK)
                        {
                                //remove the source account from the group
                            RemoveSourceAccountFromGroup(spGroup, pVsTemp, pOptions);
                        }
                    }//end else not no change mode
                }//end  if got group pointer

                if ( SUCCEEDED(hr) )
                    err.MsgWrite(0, DCT_MSG_ADDED_TO_GROUP_SS, pNodeMember->GetTargetPath(), (WCHAR*)strGroupName);
                else
                {
                    if (strGroupName.length() == 0)
                        strGroupName = pNode->GetTargetPath(); 

                    hr = BetterHR(hr);
                    if ( HRESULT_CODE(hr) == NERR_UserExists )
                    {
                        err.MsgWrite(0,DCT_MSG_USER_IN_GROUP_SS,pNodeMember->GetTargetPath(), (WCHAR*)strGroupName);
                    }
                    else if ( HRESULT_CODE(hr) == NERR_UserNotFound )
                    {
                        err.SysMsgWrite(0, hr, DCT_MSG_MEMBER_NONEXIST_SS, pNodeMember->GetTargetPath(), (WCHAR*)strGroupName, hr);
                    }
                    else
                    {
                        // message for the generic failure case
                        err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_ADD_TO_GROUP_SSD, pNodeMember->GetTargetPath(), (WCHAR*)strGroupName, hr);
                        Mark(L"warnings", pNodeMember->GetType());
                    }
                }//end else failed to add account to group
            }//end if found account to add to group
         }//for each member in the enumerated group node's member map
      }//for each account being migrated

      // Clean up the list.
      TAcctReplNode           * pNext = NULL;
      for ( pNode = (TAcctReplNode *)e.OpenFirst(&newList); pNode; pNode = pNext)
      {
         pNext = (TAcctReplNode *)e.Next();
         newList.Remove(pNode);
         delete pNode;
      }
   }

   return hr;
}

// This function enumerates all members of the Universal/Global groups and for each member
// checks if that member has been migrated. If it is then it removes the source member and 
// adds the target member.
HRESULT CAcctRepl::ResetMembersForUnivGlobGroups(Options *pOptions, TAcctReplNode *pAcct)
{
   IADsGroup               * pGroup;   
   HRESULT                   hr;
   _bstr_t                   sMember;
   _bstr_t                   sTgtMem;
   WCHAR                     sSrcPath[LEN_Path];
   WCHAR                     sTgtPath[LEN_Path];
   DWORD                     nPathLen = LEN_Path;
   IVarSetPtr                pVs(__uuidof(VarSet));
   IUnknown                * pUnk;
   IADsMembers             * pMembers = NULL;
   IEnumVARIANT            * pEnum = NULL;
   _variant_t                var;

   if ( pAcct->WasReplaced() )
   {
      WCHAR                     subPath[LEN_Path];
      WCHAR                     sPaths[LEN_Path];

      wcscpy(subPath, pAcct->GetTargetPath());
      StuffComputerNameinLdapPath(sPaths, nPathLen, subPath, pOptions, TRUE);
      hr = ADsGetObject(sPaths, IID_IADsGroup, (void**) &pGroup);
      err.MsgWrite(0, DCT_UPDATING_MEMBERS_TO_GROUP_SS, pAcct->GetTargetName(), sPaths);
   }
   else
      return S_OK;

   if ( FAILED(hr) ) return hr;

   hr = pGroup->Members(&pMembers);

   if ( SUCCEEDED(hr) )
   {
      hr = pMembers->get__NewEnum((IUnknown**)&pEnum);
   }

   if ( SUCCEEDED(hr) )
   {
      DWORD dwFet = 0;
      while ( pEnum->Next(1, &var, &dwFet) == S_OK )
      {
         IDispatch * pDisp = var.pdispVal;
         IADs * pAds = NULL;

         pDisp->QueryInterface(IID_IADs, (void**)&pAds);
         pAds->Get(L"distinguishedName", &var);
         pAds->Release();
         sMember = var;
         pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
         hr = pOptions->pDb->raw_GetMigratedObjectBySourceDN(sMember, &pUnk);
         pUnk->Release();
         if ( hr == S_OK )
         {
            // Since we have moved this member we should remove it from the group
            // and add target member to the group.
            sTgtMem = pVs->get(L"MigratedObjects.TargetAdsPath");
            _bstr_t sTgtType = pVs->get(L"MigratedObjects.Type");

            if ( !_wcsicmp(L"computer", (WCHAR*) sTgtType ) )
            {
               MakeFullyQualifiedAdsPath(sSrcPath, nPathLen, (WCHAR*)sMember, pOptions->srcComp + 2, L"");
               MakeFullyQualifiedAdsPath(sTgtPath, nPathLen, (WCHAR*)sTgtMem, pOptions->tgtComp + 2, L"");
//               HRESULT hr1 = pGroup->Remove(sSrcPath);
               pGroup->Remove(sSrcPath);

               if ( ! pOptions->nochange )
                  hr = pGroup->Add(sTgtPath);
               else 
                  hr = 0;

               if ( SUCCEEDED(hr) )
               {
                  err.MsgWrite(0, DCT_REPLACE_MEMBER_TO_GROUP_SSS, (WCHAR*)sMember, (WCHAR*) sTgtMem, pAcct->GetTargetName());
               }
               else
               {
                  err.SysMsgWrite(ErrE, hr, DCT_REPLACE_MEMBER_FAILED_SSS, (WCHAR*)sMember, (WCHAR*) sTgtMem, pAcct->GetTargetName());
               }
            }
         }
      }
   }

   if ( pEnum ) pEnum->Release();
   if ( pMembers ) pMembers->Release();
   return hr;
}

/* This function will get the varset from the action history table for the given
    undo action ID.  We will find the given source name and retrieve the UPN for
    that account */
void CAcctRepl::GetAccountUPN(Options * pOptions, _bstr_t sSName, _bstr_t& sSUPN)
{
   HRESULT hr;
   IUnknown * pUnk = NULL;
   IVarSetPtr  pVsAH(__uuidof(VarSet));

   sSUPN = L"";

   hr = pVsAH->QueryInterface(IID_IUnknown, (void**)&pUnk);

    //fill a varset with the setting from the action to be undone from the Action History table
   if ( SUCCEEDED(hr) )
      hr = pOptions->pDb->raw_GetActionHistory(pOptions->lUndoActionID, &pUnk);

   if (pUnk) pUnk->Release();

   if ( hr == S_OK )
   {
      WCHAR          key[MAX_PATH];
      bool           bFound = false;
      int            i = 0;
      long           numAccounts = pVsAH->get(GET_BSTR(DCTVS_Accounts_NumItems));
      _bstr_t        tempName;

      while ((i<numAccounts) && (!bFound))
      {
         swprintf(key,GET_STRING(DCTVSFmt_Accounts_D),i);
         tempName = pVsAH->get(key);
         if (_wcsicmp((WCHAR*)tempName, (WCHAR*)sSName) == 0)
         {
             bFound = true;
             swprintf(key,GET_STRING(DCTVSFmt_Accounts_SourceUPN_D),i);
             sSUPN = pVsAH->get(key);
         }
         i++;
      }//end while
   }//end if S_OK
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 1 NOV 2000                                                  *
 *                                                                   *
 *     This function is responsible for updating the                 *
 * manager\directReports properties for a migrated user or the       *
 * managedBy\managedObjects properties for a migrated group.         *
 *                                                                   *
 *********************************************************************/

//BEGIN UpdateManagement
HRESULT CAcctRepl::UpdateManagement(TNodeListSortable * acctList, Options *pOptions)
{
    /* local variables */
    HRESULT                   hr = S_OK;
    TAcctReplNode           * pAcct;
    IEnumVARIANT            * pEnum;
    INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
    INetObjEnumeratorPtr      pQuery2(__uuidof(NetObjEnumerator));
    LPWSTR                    sUCols[] = { L"directReports",L"managedObjects", L"manager"};
    int                       nUCols = DIM(sUCols);
    LPWSTR                    sGCols[] = { L"managedBy" };
    int                       nGCols = DIM(sGCols);
    SAFEARRAY               * cols;
    SAFEARRAYBOUND            bdU = { nUCols, 0 };
    SAFEARRAYBOUND            bdG = { nGCols, 0 };
    BSTR  HUGEP             * pData = NULL;
    _bstr_t                   sQuery;
    _variant_t                varMgr;
    _variant_t                varDR;
    _variant_t                varMdO;
    _variant_t                varMain;
    _variant_t   HUGEP      * pDt, * pVar;
    DWORD                     dwf;
    _bstr_t                   sTPath;
    _bstr_t                   sPath;
    _bstr_t                   sSam;
    _bstr_t                   sType;
    _bstr_t                   sName;
    _bstr_t                   sTgtName;
    long                      lgrpType;
    WCHAR                     mesg[LEN_Path];
    IADs                    * pDSE = NULL;
    WCHAR                     strText[LEN_Path];
    _variant_t                varGC;

    /* function body */
    //change from a tree to a sorted list
    if ( acctList->IsTree() ) acctList->ToSorted();

    //prepare to connect to the GC
    _bstr_t  sGCDomain = pOptions->srcDomainDns;
    swprintf(strText,L"LDAP://%ls/RootDSE",pOptions->srcDomainDns);
    hr = ADsGetObject(strText,IID_IADs,(void**)&pDSE);
    if ( SUCCEEDED(hr) )
    {
        hr = pDSE->Get(L"RootDomainNamingContext",&varGC);
        if ( SUCCEEDED(hr) )
            sGCDomain = GetDomainDNSFromPath(varGC.bstrVal);
    }
    _bstr_t sGCPath = _bstr_t(L"GC://") + sGCDomain;

    //for each account migrated, if not excluded, migrate the manager\directReports
    for ( pAcct = (TAcctReplNode*)acctList->Head(); pAcct; pAcct = (TAcctReplNode*)pAcct->Next())
    {
        if ( pOptions->pStatus )
        {
            LONG                status = 0;
            HRESULT             hr = pOptions->pStatus->get_Status(&status);

            if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
            {
                if ( !bAbortMessageWritten ) 
                {
                    err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                    bAbortMessageWritten = true;
                }
                break;
            }
        }

        //update the message
        wsprintf(mesg, GET_STRING(IDS_UPDATING_MGR_PROPS_S), pAcct->GetName());
        Progress(mesg);

        //build the path to the source object
        WCHAR sPathSource[LEN_Path];
        DWORD nPathLen = LEN_Path;
        StuffComputerNameinLdapPath(sPathSource, nPathLen, const_cast<WCHAR*>(pAcct->GetSourcePath()), pOptions, FALSE);

        //connect to the GC instead of a specific DC
        WCHAR * pTemp = wcschr(sPathSource + 7, L'/');
        if ( pTemp )
        {
            _bstr_t sNewPath = sGCPath + _bstr_t(pTemp);
            wcscpy(sPathSource, sNewPath);
        }

        //for user, migrate the manager\directReports managedObjects relationship
        if (!_wcsicmp(pAcct->GetType(), s_ClassUser) || !_wcsicmp(pAcct->GetType(), s_ClassInetOrgPerson))
        {
            bool bDoManager = false;
            bool bDoManagedObjects = false;

            //if the property has explicitly been excluded from migration by the user, don't migrate it
            if (pOptions->bExcludeProps)
            { 
                PCWSTR pszExcludeList;

                if (!_wcsicmp(pAcct->GetType(), s_ClassUser))
                {
                    pszExcludeList = pOptions->sExcUserProps;
                }
                else if (!_wcsicmp(pAcct->GetType(), s_ClassInetOrgPerson))
                {
                    pszExcludeList = pOptions->sExcInetOrgPersonProps;
                }
                else
                {
                    pszExcludeList = NULL;
                }

                if (!IsStringInDelimitedString(pszExcludeList, L"*", L','))
                {
                    if (!IsStringInDelimitedString(pszExcludeList, L"manager", L',') &&
                        !IsStringInDelimitedString(pszExcludeList, L"directReports", L','))
                    {
                        bDoManager = true;
                    }

                    if (!IsStringInDelimitedString(pszExcludeList, L"managedObjects", L','))
                    {
                        bDoManagedObjects = true;
                    }
                }
            }
            else
            {
                bDoManager = true;
                bDoManagedObjects = true;
            }

            if (!bDoManager && !bDoManagedObjects)
            {
                continue;
            }

            /* get the "manager", and "directReports", and "managedObjects" property */
            //build the column array
            cols = SafeArrayCreate(VT_BSTR, 1, &bdU);
            SafeArrayAccessData(cols, (void HUGEP **) &pData);
            for ( int i = 0; i < nUCols; i++)
                pData[i] = SysAllocString(sUCols[i]);
            SafeArrayUnaccessData(cols);

            sQuery = L"(objectClass=*)";

            //query the information
            hr = pQuery->raw_SetQuery(sPathSource, pOptions->srcDomain, sQuery, ADS_SCOPE_SUBTREE, TRUE);
            if (FAILED(hr)) return FALSE;
            hr = pQuery->raw_SetColumns(cols);
            if (FAILED(hr)) return FALSE;
            hr = pQuery->raw_Execute(&pEnum);
            if (FAILED(hr)) return FALSE;

            while (pEnum->Next(1, &varMain, &dwf) == S_OK)
            {
                SAFEARRAY * vals = V_ARRAY(&varMain);
                // Get the VARIANT Array out
                SafeArrayAccessData(vals, (void HUGEP**) &pDt);
                varDR =  pDt[0];
                varMdO = pDt[1];
                varMgr = pDt[2];
                SafeArrayUnaccessData(vals);

                //process the manager by setting the manager on the moved user if the
                //source user's manager has been migrated
                if ( bDoManager && (varMgr.vt & VT_ARRAY) )
                {
                    //we always get an Array of variants
                    SAFEARRAY * multiVals = varMgr.parray; 
                    SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
                    for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
                    {
                        _bstr_t sManager = _bstr_t(V_BSTR(&pVar[dw]));
                        sManager = PadDN(sManager);
                        _bstr_t sSrcDomain = GetDomainDNSFromPath(sManager);
                        sPath = _bstr_t(L"LDAP://") + sSrcDomain + _bstr_t(L"/") + sManager;
                        if (GetSamFromPath(sPath, sSam, sType, sName, sTgtName, lgrpType, pOptions))
                        {
                            IVarSetPtr                pVs(__uuidof(VarSet));
                            IUnknown                * pUnk = NULL;
                            pVs->QueryInterface(IID_IUnknown, (void**) &pUnk);
                            WCHAR                     sDomainNB[LEN_Path];
                            WCHAR                     sDNS[LEN_Path];

                            //get NetBIOS of the objects source domain
                            GetDnsAndNetbiosFromName(sSrcDomain, sDomainNB, sDNS);

                            // See if the manager was migrated
                            hr = pOptions->pDb->raw_GetAMigratedObjectToAnyDomain((WCHAR*)sSam, sDomainNB, &pUnk);
                            if ( hr == S_OK )
                            {
                                VerifyAndUpdateMigratedTarget(pOptions, pVs);
                                _variant_t var;
                                //get the manager's target adspath
                                var = pVs->get(L"MigratedObjects.TargetAdsPath");
                                sTPath = V_BSTR(&var);
                                if ( wcslen((WCHAR*)sTPath) > 0 )
                                {
                                    IADsUser       * pUser = NULL;
                                    //set the manager on the target object
                                    hr = ADsGetObject((WCHAR*)pAcct->GetTargetPath(), IID_IADsUser, (void**)&pUser);
                                    if ( SUCCEEDED(hr) )
                                    {
                                        _bstr_t sTemp = _bstr_t(wcsstr((WCHAR*)sTPath, L"CN="));
                                        var = sTemp;
                                        hr = pUser->Put(L"Manager", var);   
                                        if ( SUCCEEDED(hr) )
                                        {
                                            hr = pUser->SetInfo();
                                            if (FAILED(hr))
                                                err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)sTPath, (WCHAR*)pAcct->GetTargetPath(), hr);
                                        }
                                        else
                                            err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)sTPath, (WCHAR*)pAcct->GetTargetPath(), hr);
                                        pUser->Release();
                                    }
                                    else
                                        err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)sTPath, (WCHAR*)pAcct->GetTargetPath(), hr);
                                }//end if got the path to the manager on the target
                            }//end if manager was migrated
                            pUnk->Release();
                        }//end if got source sam
                    }//for each manager (only one)
                    SafeArrayUnaccessData(multiVals);
                }//end if variant array (it will be)

                //process the directReports by setting the manager on the previously moved 
                //user if the source user's manager has been migrated
                if ( bDoManager && (varDR.vt & VT_ARRAY) )
                {
                    //we always get an Array of variants
                    SAFEARRAY * multiVals = varDR.parray; 
                    SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
                    for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
                    {
                        _bstr_t sDirectReport = _bstr_t(V_BSTR(&pVar[dw]));
                        sDirectReport = PadDN(sDirectReport);
                        _bstr_t sSrcDomain = GetDomainDNSFromPath(sDirectReport);
                        sPath = _bstr_t(L"LDAP://") + sSrcDomain + _bstr_t(L"/") + sDirectReport;
                        if (GetSamFromPath(sPath, sSam, sType, sName, sTgtName, lgrpType, pOptions))
                        {
                            IVarSetPtr                pVs(__uuidof(VarSet));
                            IUnknown                * pUnk = NULL;
                            pVs->QueryInterface(IID_IUnknown, (void**) &pUnk);
                            WCHAR                     sDomainNB[LEN_Path];
                            WCHAR                     sDNS[LEN_Path];

                            //get NetBIOS of the objects source domain
                            GetDnsAndNetbiosFromName(sSrcDomain, sDomainNB, sDNS);

                            // See if the direct report was migrated
                            hr = pOptions->pDb->raw_GetAMigratedObjectToAnyDomain((WCHAR*)sSam, sDomainNB, &pUnk);
                            if ( hr == S_OK )
                            {
                                VerifyAndUpdateMigratedTarget(pOptions, pVs);
                                _variant_t var;
                                //get the direct report's target adspath
                                var = pVs->get(L"MigratedObjects.TargetAdsPath");
                                sTPath = V_BSTR(&var);
                                if ( wcslen((WCHAR*)sTPath) > 0 )
                                {
                                    IADsUser       * pUser = NULL;
                                    //set the manager on the target object
                                    hr = ADsGetObject(sTPath, IID_IADsUser, (void**)&pUser);
                                    if ( SUCCEEDED(hr) )
                                    {
                                        _bstr_t sTemp = _bstr_t(wcsstr((WCHAR*)pAcct->GetTargetPath(), L"CN="));
                                        var = sTemp;
                                        hr = pUser->Put(L"Manager", var);   
                                        if ( SUCCEEDED(hr) )
                                        {
                                            hr = pUser->SetInfo();
                                            if (FAILED(hr))
                                                err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)pAcct->GetTargetPath(), (WCHAR*)sTPath, hr);
                                        }
                                        else
                                            err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)pAcct->GetTargetPath(), (WCHAR*)sTPath, hr);
                                        pUser->Release();
                                    }
                                    else
                                        err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)pAcct->GetTargetPath(), (WCHAR*)sTPath, hr);
                                }//end if got the path to the manager on the target
                            }//end if manager was migrated
                            pUnk->Release();
                        }//end if got source sam
                    }//for each directReport
                    SafeArrayUnaccessData(multiVals);
                }//end if variant array (it will be)

                /* get the "managedObjects" property */
                //process the managedObjects by setting the managedBy on the moved group if the
                //source user's managed group has been migrated
                if ( bDoManagedObjects && (varMdO.vt & VT_ARRAY) )
                {
                    //we always get an Array of variants
                    SAFEARRAY * multiVals = varMdO.parray; 
                    SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
                    for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
                    {
                        _bstr_t sManaged = _bstr_t(V_BSTR(&pVar[dw]));
                        sManaged = PadDN(sManaged);
                        _bstr_t sSrcDomain = GetDomainDNSFromPath(sManaged);
                        sPath = _bstr_t(L"LDAP://") + sSrcDomain + _bstr_t(L"/") + sManaged;
                        if (GetSamFromPath(sPath, sSam, sType, sName, sTgtName, lgrpType, pOptions))
                        {
                            IVarSetPtr                pVs(__uuidof(VarSet));
                            IUnknown                * pUnk = NULL;
                            pVs->QueryInterface(IID_IUnknown, (void**) &pUnk);
                            WCHAR                     sDomainNB[LEN_Path];
                            WCHAR                     sDNS[LEN_Path];

                            //get NetBIOS of the objects source domain
                            GetDnsAndNetbiosFromName(sSrcDomain, sDomainNB, sDNS);

                            // See if the managed object was migrated
                            hr = pOptions->pDb->raw_GetAMigratedObjectToAnyDomain((WCHAR*)sSam, sDomainNB, &pUnk);
                            if ( hr == S_OK )
                            {
                                VerifyAndUpdateMigratedTarget(pOptions, pVs);
                                _variant_t var;
                                //get the managed object's target adspath
                                var = pVs->get(L"MigratedObjects.TargetAdsPath");
                                sTPath = V_BSTR(&var);
                                if ( wcslen((WCHAR*)sTPath) > 0 )
                                {
                                    IADsGroup       * pGroup = NULL;
                                    //set the manager on the target object
                                    hr = ADsGetObject(sTPath, IID_IADsGroup, (void**)&pGroup);
                                    if ( SUCCEEDED(hr) )
                                    {
                                        _bstr_t sTemp = _bstr_t(wcsstr((WCHAR*)pAcct->GetTargetPath(), L"CN="));
                                        var = sTemp;
                                        hr = pGroup->Put(L"ManagedBy", var);   
                                        if ( SUCCEEDED(hr) )
                                        {
                                            hr = pGroup->SetInfo();
                                            if (FAILED(hr))
                                                err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)pAcct->GetTargetPath(), (WCHAR*)sTPath, hr);
                                        }
                                        else
                                            err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)pAcct->GetTargetPath(), (WCHAR*)sTPath, hr);
                                        pGroup->Release();
                                    }
                                    else
                                        err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)pAcct->GetTargetPath(), (WCHAR*)sTPath, hr);
                                }//end if got the path to the manager on the target
                            }//end if manager was migrated
                            pUnk->Release();
                        }//end if got source sam
                    }//for each manager (only one)
                    SafeArrayUnaccessData(multiVals);
                }//end if variant array (it will be)

                varMgr.Clear();
                varMdO.Clear();
                varDR.Clear();
                VariantInit(&varMain); // data not owned by varMain so clear VARTYPE
            }

            if (pEnum)
                pEnum->Release();
            //         SafeArrayDestroy(cols);
        }//end if user

        //for group, migrate the managedBy\managedObjects relationship
        if (!_wcsicmp(pAcct->GetType(), L"group"))
        {
            //if the managedBy property has explicitly been excluded from migration by the user, don't migrate it
            if (pOptions->bExcludeProps &&
                (IsStringInDelimitedString(pOptions->sExcGroupProps, L"managedBy", L',') ||
                IsStringInDelimitedString(pOptions->sExcGroupProps, L"*", L',')))
                continue;

            /* get the "managedBy" property */
            //build the column array
            cols = SafeArrayCreate(VT_BSTR, 1, &bdG);
            SafeArrayAccessData(cols, (void HUGEP **) &pData);
            for ( int i = 0; i < nGCols; i++)
                pData[i] = SysAllocString(sGCols[i]);
            SafeArrayUnaccessData(cols);

            sQuery = L"(objectClass=*)";

            //query the information
            hr = pQuery->raw_SetQuery(sPathSource, pOptions->srcDomain, sQuery, ADS_SCOPE_BASE, TRUE);
            if (FAILED(hr)) return FALSE;
            hr = pQuery->raw_SetColumns(cols);
            if (FAILED(hr)) return FALSE;
            hr = pQuery->raw_Execute(&pEnum);
            if (FAILED(hr)) return FALSE;

            while (pEnum->Next(1, &varMain, &dwf) == S_OK)
            {
                SAFEARRAY * vals = V_ARRAY(&varMain);
                // Get the VARIANT Array out
                SafeArrayAccessData(vals, (void HUGEP**) &pDt);
                varMgr = pDt[0];
                SafeArrayUnaccessData(vals);

                //process the managedBy by setting the managedBy on the moved group if the
                //source group's manager has been migrated
                if ( varMgr.vt & VT_BSTR )
                {
                    _bstr_t sManager = varMgr;
                    sManager = PadDN(sManager);
                    _bstr_t sSrcDomain = GetDomainDNSFromPath(sManager);
                    sPath = _bstr_t(L"LDAP://") + sSrcDomain + _bstr_t(L"/") + sManager;
                    if (GetSamFromPath(sPath, sSam, sType, sName, sTgtName, lgrpType, pOptions))
                    {
                        IVarSetPtr                pVs(__uuidof(VarSet));
                        IUnknown                * pUnk = NULL;
                        pVs->QueryInterface(IID_IUnknown, (void**) &pUnk);
                        WCHAR                     sDomainNB[LEN_Path];
                        WCHAR                     sDNS[LEN_Path];

                        //get NetBIOS of the objects source domain
                        GetDnsAndNetbiosFromName(sSrcDomain, sDomainNB, sDNS);

                        // See if the manager was migrated
                        hr = pOptions->pDb->raw_GetAMigratedObjectToAnyDomain((WCHAR*)sSam, sDomainNB, &pUnk);
                        if ( hr == S_OK )
                        {
                            VerifyAndUpdateMigratedTarget(pOptions, pVs);
                            _variant_t var;
                            //get the manager's target adspath
                            var = pVs->get(L"MigratedObjects.TargetAdsPath");
                            sTPath = V_BSTR(&var);
                            if ( wcslen((WCHAR*)sTPath) > 0 )
                            {
                                IADsGroup       * pGroup = NULL;
                                //set the manager on the target object
                                hr = ADsGetObject((WCHAR*)pAcct->GetTargetPath(), IID_IADsGroup, (void**)&pGroup);
                                if ( SUCCEEDED(hr) )
                                {
                                    _bstr_t sTemp = _bstr_t(wcsstr((WCHAR*)sTPath, L"CN="));
                                    var = sTemp;
                                    hr = pGroup->Put(L"ManagedBy", var);   
                                    if ( SUCCEEDED(hr) )
                                    {
                                        hr = pGroup->SetInfo();
                                        if (FAILED(hr))
                                            err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)sTPath, (WCHAR*)pAcct->GetTargetPath(), hr);
                                    }
                                    else
                                        err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)sTPath, (WCHAR*)pAcct->GetTargetPath(), hr);
                                    pGroup->Release();
                                }
                                else
                                    err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)sTPath, (WCHAR*)pAcct->GetTargetPath(), hr);
                            }//end if got the path to the manager on the target
                        }//end if manager was migrated
                        pUnk->Release();
                    }//end if got source sam
                }//end if variant array (it will be)

                varMgr.Clear();
                varMain.Clear();
            }

            if (pEnum)
                pEnum->Release();
            //         SafeArrayDestroy(cols);
        }//end if group
    }//end for each account being migrated

    wcscpy(mesg, L"");
    Progress(mesg);

    return hr;
}
//END UpdateManagement


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 29 NOV 2000                                                 *
 *                                                                   *
 *     This function is responsible for removing the escape character*
 * in front of any '/' characters.                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN GetUnEscapedNameWithFwdSlash
_bstr_t CAcctRepl::GetUnEscapedNameWithFwdSlash(_bstr_t strName)
{
/* local variables */
    WCHAR   szNameOld[MAX_PATH];
    WCHAR   szNameNew[MAX_PATH];
    WCHAR * pchBeg = NULL;
    _bstr_t sNewName = L"";

/* function body */
    if (strName.length())
    {
        safecopy(szNameOld, (WCHAR*)strName);
        for (WCHAR* pch = wcschr(szNameOld, _T('\\')); pch; pch = wcschr(pch + 1, _T('\\')))
        {
            if ((*(pch + 1)) == L'/')
            {
                if (pchBeg == NULL)
                {
                    wcsncpy(szNameNew, szNameOld, pch - szNameOld);
                    szNameNew[pch - szNameOld] = L'\0';
                }
                else
                {
                    size_t cch = wcslen(szNameNew);
                    wcsncat(szNameNew, pchBeg, pch - pchBeg);
                    szNameNew[cch + (pch - pchBeg)] = L'\0';
                }

                pchBeg = pch + 1;
            }
        }

        if (pchBeg == NULL)
            wcscpy(szNameNew, szNameOld);
        else
            wcscat(szNameNew, pchBeg);

        sNewName = szNameNew;
    }

    return sNewName;
}
//END GetUnEscapedNameWithFwdSlash


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 29 NOV 2000                                                 *
 *                                                                   *
 *     This function is responsible for gets the CN name of an object*
 * from an ADsPath and returns that CN name if it was retrieved or   *
 * NULL otherwise.                                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN GetCNFromPath
_bstr_t CAcctRepl::GetCNFromPath(_bstr_t sPath)
{
/* local variables */
   BOOL bFound = FALSE;
   WCHAR sName[LEN_Path];
   WCHAR sTempPath[LEN_Path];
   _bstr_t sCNName = L"";
   WCHAR * sTempDN;
  
/* function body */
   if ((sPath.length() > 0) && (sPath.length() < LEN_Path ))
   {
      wcscpy(sTempPath, (WCHAR*)sPath);
      sTempDN = wcsstr(sTempPath, L"CN=");
      if (sTempDN)
      {
         wcscpy(sName, sTempDN);
         sTempDN = wcsstr(sName, L",OU=");
         if (sTempDN)
         {
            bFound = TRUE;
            *sTempDN = L'\0';
         }
         sTempDN = wcsstr(sName, L",CN=");
         if (sTempDN)
         {
            bFound = TRUE;
            *sTempDN = L'\0';
         }
         sTempDN = wcsstr(sName, L",DC=");
         if (sTempDN)
         {
            bFound = TRUE;
            *sTempDN = L'\0';
         }
      }
   }
   if (bFound)
       sCNName = sName;

   return sCNName;
}
//END GetCNFromPath



/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 26 FEB 2001                                                 *
 *                                                                   *
 *     This function is responsible for replacing the source account *
 * for a given list of accounts in any local groups they are a member*
 * of on the target, if that account was migrated by ADMT.  This     *
 * function is called during the undo process.                       *
 *                                                                   *
 *********************************************************************/

//BEGIN ReplaceSourceInLocalGroup
BOOL CAcctRepl::ReplaceSourceInLocalGroup(TNodeListSortable *acctlist, //in- Accounts being processed
                                             Options        *pOptions, //in- Options specified by the user
                                             IStatusObj     *pStatus)  // in -status object to support cancellation
{
/* local variables */
   TAcctReplNode           * pAcct;
   IEnumVARIANT            * pEnum;
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   LPWSTR                    sCols[] = { L"memberOf" };
   int                       nCols = DIM(sCols);
   SAFEARRAY               * psaCols;
   SAFEARRAYBOUND            bd = { nCols, 0 };
   BSTR  HUGEP             * pData;
   WCHAR                     sQuery[LEN_Path];
   _variant_t   HUGEP      * pDt, * pVar;
   _variant_t                vx;
   _variant_t                varMain;
   DWORD                     dwf = 0;
   HRESULT                   hr = S_OK;
   _bstr_t                   sDomPath = L"";
   _bstr_t                   sDomain = L"";

/* function body */
   FillNamingContext(pOptions);

      //for each account, enumerate all local groups it is a member of and add the account's
      //source account in that local group
   for ( pAcct = (TAcctReplNode*)acctlist->Head(); pAcct; pAcct = (TAcctReplNode*)pAcct->Next())
   {
      // Do we need to abort ?
      if ( pStatus )
      {
         LONG                status = 0;
         HRESULT             hr = pStatus->get_Status(&status);
         
         if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
         {
            if ( !bAbortMessageWritten ) 
            {
               err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
               bAbortMessageWritten = true;
            }
            break;
         }
      }

         //enumerate the groups this account is a member of
      sDomain = GetDomainDNSFromPath(pAcct->GetTargetPath());
      if (!_wcsicmp(pAcct->GetType(), s_ClassUser))
         wsprintf(sQuery, L"(&(sAMAccountName=%s)(objectCategory=Person)(objectClass=user))", pAcct->GetTargetSam());
      else if (!_wcsicmp(pAcct->GetType(), s_ClassInetOrgPerson))
         wsprintf(sQuery, L"(&(sAMAccountName=%s)(objectCategory=Person)(objectClass=inetOrgPerson))", pAcct->GetTargetSam());
      else
         wsprintf(sQuery, L"(&(sAMAccountName=%s)(objectCategory=Group))", pAcct->GetTargetSam());
      psaCols = SafeArrayCreate(VT_BSTR, 1, &bd);
      SafeArrayAccessData(psaCols, (void HUGEP **)&pData);
      for ( int i = 0; i < nCols; i++ )
         pData[i] = SysAllocString(sCols[i]);
      SafeArrayUnaccessData(psaCols);
      hr = pQuery->raw_SetQuery(sDomPath, sDomain, sQuery, ADS_SCOPE_SUBTREE, FALSE);
      if (FAILED(hr)) return FALSE;
      hr = pQuery->raw_SetColumns(psaCols);
      if (FAILED(hr)) return FALSE;
      hr = pQuery->raw_Execute(&pEnum);
      if (FAILED(hr)) return FALSE;

         //while more groups
      while (pEnum->Next(1, &varMain, &dwf) == S_OK)
      {
         SAFEARRAY * vals = V_ARRAY(&varMain);
         // Get the VARIANT Array out
         SafeArrayAccessData(vals, (void HUGEP**) &pDt);
         vx = pDt[0];
         SafeArrayUnaccessData(vals);
         if ( vx.vt == VT_BSTR )
         {
            _bstr_t            sPath;
            BSTR              sGrpName = NULL;
            IADsGroup       * pGrp = NULL;
            _variant_t         var;

            _bstr_t sDN = vx.bstrVal;
            if (wcslen((WCHAR*)sDN) == 0)
               continue;

            sDN = PadDN(sDN);
            sPath = _bstr_t(L"LDAP://") + sDomain + _bstr_t(L"/") + sDN;

               //connect to the target group
            hr = ADsGetObject(sPath, IID_IADsGroup, (void**)&pGrp);
            if (FAILED(hr))
               continue;
            
               //get this group's type and name              
            hr = pGrp->get_Name(&sGrpName);
            hr = pGrp->Get(L"groupType", &var);

               //if this is a local group, get this account source path and add it as a member
            if ((SUCCEEDED(hr)) && (var.lVal & 4))
            {
                  //add the account's source account to the local group, using the sid string format
               WCHAR  strSid[MAX_PATH] = L"";
               WCHAR  strRid[MAX_PATH] = L"";
               DWORD  lenStrSid = DIM(strSid);
               GetTextualSid(pAcct->GetSourceSid(), strSid, &lenStrSid);
               _bstr_t sSrcDmSid = strSid;
               _ltow((long)(pAcct->GetSourceRid()), strRid, 10);
               _bstr_t sSrcRid = strRid;
               if ((!sSrcDmSid.length()) || (!sSrcRid.length()))
               {
                  hr = E_INVALIDARG;
                  err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_READD_TO_GROUP_SSD, pAcct->GetSourcePath(), (WCHAR*)sGrpName, hr);
                  continue;
               }

                  //build an LDAP path to the src object in the group
               _bstr_t sSrcSid = sSrcDmSid + _bstr_t(L"-") + sSrcRid;
               _bstr_t sSrcLDAPPath = L"LDAP://";
               sSrcLDAPPath += _bstr_t(pOptions->tgtComp + 2);
               sSrcLDAPPath += L"/CN=";
               sSrcLDAPPath += sSrcSid;
               sSrcLDAPPath += L",CN=ForeignSecurityPrincipals,";
               sSrcLDAPPath += pOptions->tgtNamingContext;

                  //add the source account to the local group
               hr = pGrp->Add(sSrcLDAPPath);
               if (SUCCEEDED(hr))
                  err.MsgWrite(0,DCT_MSG_READD_MEMBER_TO_GROUP_SS, pAcct->GetSourcePath(), (WCHAR*)sGrpName);
               else
                  err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_READD_TO_GROUP_SSD, pAcct->GetSourcePath(), (WCHAR*)sGrpName, hr);
            }//end if local group
            if (pGrp) 
               pGrp->Release();
         }//end if bstr
         else if ( vx.vt & VT_ARRAY )
         {
            // We must have got an Array of multivalued properties
            // Access the BSTR elements of this variant array
            SAFEARRAY * multiVals = vx.parray; 
            SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
               //for each group
            for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
            {
               // Do we need to abort ?
               if ( pStatus )
               {
                  LONG                status = 0;
                  HRESULT             hr = pStatus->get_Status(&status);
         
                  if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                  {
                     if ( !bAbortMessageWritten ) 
                     {
                        err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                        bAbortMessageWritten = true;
                     }
                     break;
                  }
               }
               _bstr_t            sPath;
               BSTR               sGrpName = NULL;
               IADsGroup        * pGrp = NULL;
               _variant_t         var;

               _bstr_t sDN = _bstr_t(V_BSTR(&pVar[dw]));
               sDN = PadDN(sDN);
               sPath = _bstr_t(L"LDAP://") + sDomain + _bstr_t(L"/") + sDN;

                  //connect to the target group
               hr = ADsGetObject(sPath, IID_IADsGroup, (void**)&pGrp);
               if (FAILED(hr))
                  continue;
            
                  //get this group's type and name               
               hr = pGrp->get_Name(&sGrpName);
               hr = pGrp->Get(L"groupType", &var);

                  //if this is a local group, get this account source path and add it as a member
               if ((SUCCEEDED(hr)) && (var.lVal & 4))
               {
                     //add the account's source account to the local group, using the sid string format
                  WCHAR  strSid[MAX_PATH];
                  WCHAR  strRid[MAX_PATH];
                  DWORD  lenStrSid = DIM(strSid);
                  GetTextualSid(pAcct->GetSourceSid(), strSid, &lenStrSid);
                  _bstr_t sSrcDmSid = strSid;
                  _ltow((long)(pAcct->GetSourceRid()), strRid, 10);
                  _bstr_t sSrcRid = strRid;
                  if ((!sSrcDmSid.length()) || (!sSrcRid.length()))
                  {
                     hr = E_INVALIDARG;
                     err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_READD_TO_GROUP_SSD, pAcct->GetSourcePath(), (WCHAR*)sGrpName, hr);
                     continue;
                  }

                     //build an LDAP path to the src object in the group
                  _bstr_t sSrcSid = sSrcDmSid + _bstr_t(L"-") + sSrcRid;
                  _bstr_t sSrcLDAPPath = L"LDAP://";
                  sSrcLDAPPath += _bstr_t(pOptions->tgtComp + 2);
                  sSrcLDAPPath += L"/CN=";
                  sSrcLDAPPath += sSrcSid;
                  sSrcLDAPPath += L",CN=ForeignSecurityPrincipals,";
                  sSrcLDAPPath += pOptions->tgtNamingContext;

                     //add the source account to the local group
                  hr = pGrp->Add(sSrcLDAPPath);
                  if (SUCCEEDED(hr))
                     err.MsgWrite(0,DCT_MSG_READD_MEMBER_TO_GROUP_SS, pAcct->GetSourcePath(), (WCHAR*)sGrpName);
                  else
                     err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_READD_TO_GROUP_SSD, pAcct->GetSourcePath, (WCHAR*)sGrpName, hr);
               }//end if local group
               if (pGrp) 
                  pGrp->Release();
            }//end for each group
            SafeArrayUnaccessData(multiVals);
         }//end if array of groups
      }//end while groups
      pEnum->Release();
      VariantInit(&vx);
      VariantInit(&varMain);
      SafeArrayDestroy(psaCols);
   }//end for each account

   return TRUE;
}
//END ReplaceSourceInLocalGroup


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 6 MAR 2001                                                  *
 *                                                                   *
 *     This function is responsible for retrieving the actual source *
 * domain, from the Migrated Objects table, of a given path if that  *
 * path is one to a foreign security principal.  We are also given a *
 * pointer to the object reflected by the path parameter.            *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDomainOfMigratedForeignSecPrincipal
_bstr_t CAcctRepl::GetDomainOfMigratedForeignSecPrincipal(IADs * pAds, _bstr_t sPath)
{
/* local variables */
   IVarSetPtr      pVs(__uuidof(VarSet));
   IUnknown      * pUnk = NULL;
   HRESULT         hr = S_OK;   
   _variant_t      varName;
   _bstr_t         sDomainSid, sRid;
   _bstr_t         sDomain = L"";
   BOOL            bSplit = FALSE;

/* function body */
      //if this account is outside the domain, lookup the account
      //in the migrated objects table to retrieve it's actual source domain
   if (wcsstr((WCHAR*)sPath, L"CN=ForeignSecurityPrincipals"))
   {
      //get the sid of this account
         //use already valid pointer to the object
      if (pAds)
      {
         hr = pAds->Get(L"name", &varName);
      }
      else //else connect to the object
      {
         IADs   * pTempAds = NULL;
         hr = ADsGetObject(sPath,IID_IADs,(void**)&pTempAds);
         if (SUCCEEDED(hr))
         {
            hr = pTempAds->Get(L"name",&varName);
            pTempAds->Release();
         }
      }

      if (SUCCEEDED(hr))
      {
         WCHAR sName[MAX_PATH];
         _bstr_t sTempName = varName;
            
         if (!sTempName == false)
         {
             wcscpy(sName, sTempName);
                //break the sid into domain sid and account rid
             WCHAR * pTemp = wcsrchr(sName, L'-');
             if (pTemp)
             {
                sRid = (pTemp + 1);
                *pTemp = L'\0';
                sDomainSid = sName;
                bSplit = TRUE;
             }
         }
      }
    
         //if we got the rid and domain sid, look in MOT for account's
         //real source domain
      if (bSplit)
      {
         pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
         try 
         {
            IIManageDBPtr   pDB(CLSID_IManageDB);
            hr = pDB->raw_GetAMigratedObjectBySidAndRid(sDomainSid, sRid, &pUnk);
            if (SUCCEEDED(hr))
               sDomain = pVs->get(L"MigratedObjects.SourceDomain");
         }
         catch(_com_error& e)
         {
            hr = e.Error();
         }
         catch(...)
         {
            hr = E_FAIL;
         }
         
         if (pUnk)
            pUnk->Release();
      }
   }

   return sDomain;
}
//END GetDomainOfMigratedForeignSecPrincipal


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 APR 2001                                                 *
 *                                                                   *
 *     This function is responsible for removing the source account  *
 * object, represented by its VarSet entry from the Migrated Objects *
 * Table, from the given group.  This helper function is used by     *
 * "UpdateMemberToGroups" and "UpdateGroupMembership" after          *
 * successfully adding the cloned account to this same group.        *
 *                                                                   *
 *********************************************************************/

//BEGIN RemoveSourceAccountFromGroup
void CAcctRepl::RemoveSourceAccountFromGroup(IADsGroup * pGroup, IVarSetPtr pMOTVarSet, Options * pOptions)
{
/* local variables */
   _bstr_t          sSrcDmSid, sSrcRid, sSrcPath, sGrpName = L"";
   HRESULT          hr = S_OK;   

/* function body */

      //get the target group's name
   BSTR bstr = NULL;
   hr = pGroup->get_Name(&bstr);
   if ( SUCCEEDED(hr) )
      sGrpName = _bstr_t(bstr, false);

      //get the source object's sid from the migrate objects table
   sSrcDmSid = pMOTVarSet->get(L"MigratedObjects.SourceDomainSid");
   sSrcRid = pMOTVarSet->get(L"MigratedObjects.SourceRid");
   sSrcPath = pMOTVarSet->get(L"MigratedObjects.SourceAdsPath");
   if ((wcslen((WCHAR*)sSrcDmSid) > 0) && (wcslen((WCHAR*)sSrcPath) > 0) 
       && (wcslen((WCHAR*)sSrcRid) > 0))
   {
         //build an LDAP path to the src object in the group
      _bstr_t sSrcSid = sSrcDmSid + _bstr_t(L"-") + sSrcRid;
      _bstr_t sSrcLDAPPath = L"LDAP://";
      sSrcLDAPPath += _bstr_t(pOptions->tgtComp + 2);
      sSrcLDAPPath += L"/CN=";
      sSrcLDAPPath += sSrcSid;
      sSrcLDAPPath += L",CN=ForeignSecurityPrincipals,";
      sSrcLDAPPath += pOptions->tgtNamingContext;
                        
      VARIANT_BOOL bIsMem = VARIANT_FALSE;
         //got the source LDAP path, now see if that account is in the group
      pGroup->IsMember(sSrcLDAPPath, &bIsMem);
      if (bIsMem)
      {
         hr = pGroup->Remove(sSrcLDAPPath);//remove the src account
         if ( SUCCEEDED(hr) )
            err.MsgWrite(0,DCT_MSG_REMOVE_FROM_GROUP_SS, (WCHAR*)sSrcPath, (WCHAR*)sGrpName);
      }
   }
}
//END RemoveSourceAccountFromGroup


// GetDomainDnFromPath
//
// Retrieves domain distinguished name from ADsPath

_bstr_t __stdcall GetDomainDnFromPath(_bstr_t strADsPath)
{
    CADsPathName pnPathname(strADsPath);

    for (long lCount = pnPathname.GetNumElements(); lCount > 0; lCount--)
    {
        _bstr_t str = pnPathname.GetElement(0);

        if (!str || (_tcsnicmp(str, _T("DC="), 3) == 0))
        {
            break;
        }

        pnPathname.RemoveLeafElement();
    }

    return pnPathname.Retrieve(ADS_FORMAT_X500_DN);
}


//----------------------------------------------------------------------------
// VerifyAndUpdateMigratedTarget Method
//
// Verifies target path and if changed then retrieves new path and updates
// database.
//----------------------------------------------------------------------------

void CAcctRepl::VerifyAndUpdateMigratedTarget(Options* pOptions, IVarSetPtr spAccountVarSet)
{
    WCHAR szADsPath[LEN_Path];

    // retrieve migrated objects ADsPath and update server to current domain controller

    _bstr_t strGuid = spAccountVarSet->get(L"MigratedObjects.GUID");
    _bstr_t strOldPath = spAccountVarSet->get(L"MigratedObjects.TargetAdsPath");

    // attempt to connect to object

    IADsPtr spTargetObject;

    StuffComputerNameinLdapPath(szADsPath, LEN_Path, strOldPath, pOptions, TRUE);

    HRESULT hr = ADsGetObject(szADsPath, __uuidof(IADs), (VOID**)&spTargetObject);

    //
    // If able to bind to an object with the old distinguished name verify
    // that the GUID is equal to the previously migrated object.
    //

    bool bGuidEqual = false;

    if (SUCCEEDED(hr))
    {
        BSTR bstr = NULL;

        hr = spTargetObject->get_GUID(&bstr);

        if (SUCCEEDED(hr))
        {
            _bstr_t strGuidB = _bstr_t(bstr, false);

            PCTSTR pszGuidA = strGuid;
            PCTSTR pszGuidB = strGuidB;

            if (pszGuidA && pszGuidB)
            {
                if (_tcsicmp(pszGuidA, pszGuidB) == 0)
                {
                    bGuidEqual = true;
                }
            }
        }
        else
        {
            _com_issue_error(hr);
        }
    }

    //
    // If bind failed because object no longer exists at given path or the GUID of the object does not
    // equal the previously migrated object then attempt to bind to object using GUID to retrieve updated
    // distinguished name and SAM account name.
    //

    if ((hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT)) || (SUCCEEDED(hr) && (bGuidEqual == false)))
    {
        // retrieve object based on GUID

        _bstr_t strGuidPath = _bstr_t(L"LDAP://") + _bstr_t(pOptions->tgtDomainDns) + _bstr_t(L"/<GUID=") + strGuid + _bstr_t(L">");

        hr = ADsGetObject(strGuidPath, __uuidof(IADs), (VOID**)&spTargetObject);

        // if object found then...

        if (SUCCEEDED(hr))
        {
            VARIANT var;

            hr = spTargetObject->Get(_bstr_t(L"distinguishedName"), &var);

            if (SUCCEEDED(hr))
            {
                CADsPathName pathname;
                pathname.Set(L"LDAP", ADS_SETTYPE_PROVIDER);
                pathname.Set(pOptions->tgtDomainDns, ADS_SETTYPE_SERVER);
                pathname.Set(_bstr_t(_variant_t(var)), ADS_SETTYPE_DN);

                _bstr_t strNewPath = pathname.Retrieve(ADS_FORMAT_X500);

                // retrieve domain distinguished names

                _bstr_t strOldDomainDn = GetDomainDnFromPath(strOldPath);
                _bstr_t strNewDomainDn = GetDomainDnFromPath(strNewPath);

                // if domains are equal than update path

                if (strOldDomainDn.length() && strNewDomainDn.length() && (_tcsicmp(strOldDomainDn, strNewDomainDn) == 0))
                {
                    // replace server with current target domain controller
                    StuffComputerNameinLdapPath(szADsPath, LEN_Path, strNewPath, pOptions, TRUE);

                    // update ADsPath
                    spAccountVarSet->put(L"MigratedObjects.TargetAdsPath", _bstr_t(szADsPath));

                    // update SAMAccountName

                    hr = spTargetObject->Get(_bstr_t(L"sAMAccountName"), &var);

                    if (SUCCEEDED(hr))
                    {
                       spAccountVarSet->put(L"MigratedObjects.TargetSamName", _bstr_t(_variant_t(var)));
                    }

                    // update database
                    pOptions->pDb->UpdateMigratedTargetObject(IUnknownPtr(spAccountVarSet));
                }
            }
        }
    }
}


//-----------------------------------------------------------------------------
// GenerateSourceToTargetDnMap Method
//
// Synopsis
// Generates a mapping of source object distinguished names to target object
// distinguished names. This is used during copying of distinguished name type
// attributes to translate the distinguished name for the source object to the
// distinguished name of the target object.
//
// Parameters
// IN acctlist - list of account node objects
//
// Return Value
// A VarSet data object whose keys are the source distinguished names and whose
// values are the target distinguished names.
//-----------------------------------------------------------------------------

IVarSetPtr CAcctRepl::GenerateSourceToTargetDnMap(TNodeListSortable* acctlist)
{
    IVarSetPtr spVarSet(__uuidof(VarSet));

    if (opt.srcDomainVer > 4)
    {
        TNodeTreeEnum nteEnum;
        CADsPathName pnSource;
        CADsPathName pnTarget;

        //
        // For each object being migrated...
        //

        for (TAcctReplNode* parnNode = (TAcctReplNode *)nteEnum.OpenFirst(acctlist); parnNode; parnNode = (TAcctReplNode *)nteEnum.Next())
        {
            //
            // If either the object has been created or will be replaced then add object to map.
            //

            if ((opt.flags & F_REPLACE) || parnNode->WasCreated())
            {
                pnSource.Set(parnNode->GetSourcePath(), ADS_SETTYPE_FULL);
                pnTarget.Set(parnNode->GetTargetPath(), ADS_SETTYPE_FULL);

                spVarSet->put(pnSource.Retrieve(ADS_FORMAT_X500_DN), pnTarget.Retrieve(ADS_FORMAT_X500_DN));
            }
        }
    }

    return spVarSet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\chdom.cpp ===
/*---------------------------------------------------------------------------
  File: ChangeDomain.cpp

  Comments: Implementation of COM object that changes the domain affiliation on 
  a computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:21:07

 ---------------------------------------------------------------------------
*/

// ChangeDomain.cpp : Implementation of CChangeDomain
#include "stdafx.h"
#include "WorkObj.h"
#include "ChDom.h"

#include "Common.hpp"
#include "UString.hpp"
#include "EaLen.hpp"
#include "ResStr.h"
#include "ErrDct.hpp"
#include "TxtSid.h"
#include "TReg.hpp"

/////////////////////////////////////////////////////////////////////////////
// CChangeDomain


#include "LSAUtils.h"

#import "NetEnum.tlb" no_namespace 
#import "VarSet.tlb" no_namespace rename("property", "aproperty")

#include <lm.h>         // for NetXxx API
#include <winbase.h>

TErrorDct errLocal;

typedef NET_API_STATUS (NET_API_FUNCTION* PNETJOINDOMAIN)
    (
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDomain,
    IN  LPCWSTR lpAccountOU, OPTIONAL
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fJoinOptions
    );

HINSTANCE                hDll = NULL;
PNETJOINDOMAIN           pNetJoinDomain = NULL;

BOOL GetNetJoinDomainFunction()
{
   BOOL bSuccess = FALSE;

   hDll = LoadLibrary(L"NetApi32.dll");

   if ( hDll )
   {
      pNetJoinDomain = (PNETJOINDOMAIN)GetProcAddress(hDll,"NetJoinDomain");
      if ( pNetJoinDomain )
      {
         bSuccess = TRUE;
      }
   }

   return bSuccess;
}

typedef HRESULT (CALLBACK * ADSGETOBJECT)(LPWSTR, REFIID, void**);
extern ADSGETOBJECT            ADsGetObject;

STDMETHODIMP 
   CChangeDomain::ChangeToDomain(
      BSTR                   activeComputerName,   // in - computer name currently being used (old name if simultaneously renaming and changing domain)
      BSTR                   domain,               // in - domain to move computer to
      BSTR                   newComputerName,      // in - computer name the computer will join the new domain as (the name that will be in effect on reboot, if simultaneously renaming and changing domain)
      BSTR                 * errReturn             // out- string describing any errors that occurred
   )
{
   HRESULT                   hr = S_OK;

   return hr;
}


STDMETHODIMP 
   CChangeDomain::ChangeToDomainWithSid(
      BSTR                   activeComputerName,   // in - computer name currently being used (old name if simultaneously renaming and changing domain)
      BSTR                   domain,               // in - domain to move computer to
      BSTR                   domainSid,            // in - sid of domain, as string
      BSTR                   domainController,     // in - domain controller to use
      BSTR                   newComputerName,      // in - computer name the computer will join the new domain as (the name that will be in effect on reboot, if simultaneously renaming and changing domain)
      BSTR                   srcPath,		   // in - source account original LDAP path
      BSTR                 * errReturn             // out- string describing any errors that occurred
   )
{
    USES_CONVERSION;

    HRESULT hr = S_OK;

    // initialize output parameters
    (*errReturn) = NULL;

    //
    // Use NetJoinDomain API if available (Windows 2000 and later)
    // otherwise must use LSA APIs (Windows NT 4 and earlier).
    //

    if (GetNetJoinDomainFunction())
    {
        DWORD dwError = ERROR_SUCCESS;

        //
        // If a preferred domain controller is specified then use it.
        //

        _bstr_t strNewDomain = domain;

        if (SysStringLen(domainController) > 0)
        {
            //
            // The preferred domain controller may only be specified for uplevel
            // (W2K or later) domains. During undo of a computer migration the
            // target domain may be a downlevel (NT4) domain. If unable to obtain
            // operating system version information from the specified domain
            // controller or the operating system is downlevel then don't specify
            // a preferred domain controller.
            //

            PWKSTA_INFO_100 pInfo = NULL;

            NET_API_STATUS nasStatus = NetWkstaGetInfo(domainController, 100, (LPBYTE*)&pInfo);

            if ((nasStatus == NERR_Success) && pInfo)
            {
                if (pInfo->wki100_ver_major >= 5)
                {
                    NetApiBufferFree(pInfo);

                    strNewDomain += L"\\";
                    strNewDomain += domainController;
                }
            }
        }

        //
        // Join Options
        //

        const DWORD JOIN_OPTIONS = NETSETUP_JOIN_DOMAIN | NETSETUP_DOMAIN_JOIN_IF_JOINED | NETSETUP_JOIN_UNSECURE;

        //
        // Check whether a new computer name has been specified.
        //

        if (SysStringLen(newComputerName) == 0)
        {
            //
            // A new name has not been specified therefore simply
            // join the new domain with the current computer name.
            //

            dwError = pNetJoinDomain(NULL, strNewDomain, NULL, NULL, NULL, JOIN_OPTIONS);
        }
        else
        {
            //
            // A new name has been specified therefore computer must be re-named during join.
            //
            // The current APIs only support joining a domain with the current name and then
            // re-naming the computer in the domain after the join. Unfortunately the re-name
            // in the domain requires the credentials of a security principal with the rights
            // to change the name of the computer in the domain or that this process be running
            // under the security context of a security principal with the rights to change the
            // name of the computer in the domain. Since these requirements cannot be met with
            // ADMT the following trick (read hack) must be used.
            //
            // Set the active computer name in the registry to the new name during the duration
            // of the NetJoinDomain call so that the computer is joined to the new domain with
            // the new name without requiring a subsequent re-name in the new domain.
            //

            TRegKey key;
            static WCHAR c_szKey[] = L"System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName";

            dwError = key.Open(c_szKey, HKEY_LOCAL_MACHINE);

            if (dwError == ERROR_SUCCESS)
            {
                static WCHAR c_szKeyValue[] = L"ComputerName";
                WCHAR szOldComputerName[MAX_PATH];

                dwError = key.ValueGetStr(c_szKeyValue, szOldComputerName, MAX_PATH - 1);

                if (dwError == ERROR_SUCCESS)
                {
                    dwError = key.ValueSetStr(c_szKeyValue, OLE2CW(newComputerName));

                    if (dwError == ERROR_SUCCESS)
                    {
                        dwError = pNetJoinDomain(NULL, strNewDomain, NULL, NULL, NULL, JOIN_OPTIONS);

                        key.ValueSetStr(c_szKeyValue, szOldComputerName);
                        key.Close();
                    }
                }
            }
        }

        hr = HRESULT_FROM_WIN32(dwError);
    }
    else
    {
       do // once  
       {
           LSA_HANDLE                PolicyHandle = NULL;
           LPWSTR                    Workstation; // target machine of policy update
           WCHAR                     Password[LEN_Password];
           PSID                      DomainSid=NULL;      // Sid representing domain to trust
           PSERVER_INFO_101          si101 = NULL;
           DWORD                     Type;
           NET_API_STATUS            nas;
           NTSTATUS                  Status;
           WCHAR                     errMsg[1000];
           WCHAR                     TrustedDomainName[LEN_Domain];
           WCHAR                     LocalMachine[MAX_PATH] = L"";
           DWORD                     lenLocalMachine = DIM(LocalMachine);
           LPWSTR                    activeWorkstation = L"";

           // use the target name, if provided

           if ( newComputerName && UStrLen((WCHAR*)newComputerName) )
           {
              Workstation = (WCHAR*)newComputerName;

              if ( ! activeComputerName || ! UStrLen((WCHAR*)activeComputerName) )
              {
                 activeWorkstation = LocalMachine;
              }
              else
              {
                 activeWorkstation = (WCHAR*)activeComputerName;
              }
           }
           else
           {
              if (! activeComputerName || ! UStrLen((WCHAR*)activeComputerName) )
              {
                 GetComputerName(LocalMachine,&lenLocalMachine);
                 Workstation = LocalMachine;
                 activeWorkstation = L"";
              }
              else
              {
                 Workstation = (WCHAR*)activeComputerName;
                 activeWorkstation = Workstation;
              }
           }

           wcscpy(TrustedDomainName,(WCHAR*)domain);

           if ( Workstation[0] == L'\\' )
              Workstation += 2;

           // Use a default password
           for ( UINT p = 0 ; p < wcslen(Workstation) ; p++ )
              Password[p] = towlower(Workstation[p]);
           Password[wcslen(Workstation)] = 0;

           // ensure that the password is truncated at 14 characters
           Password[14] = 0;
           //
           // insure the target machine is NOT a DC, as this operation is
           // only appropriate against a workstation.
           //
          nas = NetServerGetInfo(activeWorkstation, 101, (LPBYTE *)&si101);
          if(nas != NERR_Success) 
          {
             hr = HRESULT_FROM_WIN32(nas);
             break;
          }

         // Use LSA APIs
         Type = si101->sv101_type;
         
         if( (Type & SV_TYPE_DOMAIN_CTRL) ||
           (Type & SV_TYPE_DOMAIN_BAKCTRL) ) 
         {
            swprintf(errMsg,GET_STRING(IDS_NotAllowedOnDomainController));
            hr = E_NOTIMPL;
            break;

         }

         //
         // do not allow a workstation to trust itself
         //
         if(lstrcmpiW(TrustedDomainName, Workstation) == 0) 
         {
            swprintf(errMsg,GET_STRING(IDS_CannotTrustSelf),
               TrustedDomainName);
            hr = E_INVALIDARG; 
            break;
         }
      
         if( lstrlenW(TrustedDomainName ) > MAX_COMPUTERNAME_LENGTH )
         {
            TrustedDomainName[MAX_COMPUTERNAME_LENGTH] = L'\0'; // truncate
         }
         
         if ( ! m_bNoChange )
         {
            //
            // build the DomainSid of the domain to trust
            //
            DomainSid = SidFromString(domainSid);
            if(!DomainSid ) 
            {
               hr = HRESULT_FROM_WIN32(GetLastError());
               break;
            }
         
         }
         if ( (!m_bNoChange) && (si101->sv101_version_major < 4) )
         {
            // For NT 3.51 machines, we must move the computer to a workgroup, and 
            // then move it into the new domain
            hr = ChangeToWorkgroup(SysAllocString(activeWorkstation),SysAllocString(L"WORKGROUP"),errReturn);

            if (FAILED(hr)) {
                break;
            }

            Status = QueryWorkstationTrustedDomainInfo(PolicyHandle,DomainSid,m_bNoChange);

            if ( Status != STATUS_SUCCESS ) 
            {
                hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
                break;
            }
         }


         //
         // see if the computer account exists on the domain
         //
         
         //
         // open the policy on this computer
         //
         Status = OpenPolicy(
                  activeWorkstation,
                  DELETE                      |    // to remove a trust
                  POLICY_VIEW_LOCAL_INFORMATION | // to view trusts
                  POLICY_CREATE_SECRET |  // for password set operation
                  POLICY_TRUST_ADMIN,     // for trust creation
                  &PolicyHandle
                  );

         if( Status != STATUS_SUCCESS ) 
         {
            hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
            break;
         }
 
         if ( ! m_bNoChange )
         {
            Status = QueryWorkstationTrustedDomainInfo(PolicyHandle,DomainSid,m_bNoChange);
            if (Status == STATUS_SUCCESS) {
                Status = SetWorkstationTrustedDomainInfo(
                      PolicyHandle,
                      DomainSid,
                      TrustedDomainName,
                      Password,
                      errMsg
                      );
            }
         }

         if( Status != STATUS_SUCCESS ) 
         {
            hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
            break;
         }

         //
         // Update the primary domain to match the specified trusted domain
         //
         if (! m_bNoChange )
         {
            Status = SetPrimaryDomain(PolicyHandle, DomainSid, TrustedDomainName);

            if(Status != STATUS_SUCCESS) 
            {
           //    DisplayNtStatus(errMsg,"SetPrimaryDomain", Status,NULL);
               hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
               break;
            }
         }
         
         NetApiBufferFree(si101);

           // Cleanup

           //LocalFree(Workstation);

           //
           // free the Sid which was allocated for the TrustedDomain Sid
           //
           if(DomainSid)
           {
              FreeSid(DomainSid);
           }

           //
           // close the policy handle
           //
           if ( PolicyHandle )
           {
              LsaClose(PolicyHandle);
           }

        } while (false);  // do once 

        if (FAILED(hr))
        {
            (*errReturn) = NULL;
        }
    }

    return hr;
}


STDMETHODIMP 
   CChangeDomain::ChangeToWorkgroup(
      BSTR                   Computer,       // in - name of computer to update
      BSTR                   Workgroup,      // in - name of workgroup to join
      BSTR                 * errReturn       // out- text describing error if failure
   )
{
    HRESULT                   hr = S_OK;
   LSA_HANDLE                PolicyHandle = NULL;
   LPWSTR                    Workstation; // target machine of policy update
   LPWSTR                    TrustedDomainName; // domain to join
   PSERVER_INFO_101          si101;
   DWORD                     Type;
   NET_API_STATUS            nas;
   NTSTATUS                  Status;
   WCHAR                     errMsg[1000] = L"";
//   BOOL                      bSessionEstablished = FALSE;

   // initialize output parameters
   (*errReturn) = NULL;

   Workstation = (WCHAR*)Computer;
   TrustedDomainName = (WCHAR*)Workgroup;
    
   errLocal.DbgMsgWrite(0,L"Changing to workgroup...");
   //
   // insure the target machine is NOT a DC, as this operation is
   // only appropriate against a workstation.
   //
   do // once  
   { 
      /*if ( m_account.length() )
      {
         // Establish our credentials to the target machine
         if (! EstablishSession(Workstation,m_domain,m_account,m_password, TRUE) )
         {
           // DisplayError(errMsg,"EstablishSession",GetLastError(),NULL);
            hr = GetLastError();
         }
         else
         {
            bSessionEstablished = TRUE;
         }
      }
      */
      nas = NetServerGetInfo(Workstation, 101, (LPBYTE *)&si101);
   
      if(nas != NERR_Success) 
      {
         //DisplayError(errMsg, "NetServerGetInfo", nas,NULL);
         hr = E_FAIL;
         break;
      }

      Type = si101->sv101_type;
      NetApiBufferFree(si101);

      if( (Type & SV_TYPE_DOMAIN_CTRL) ||
        (Type & SV_TYPE_DOMAIN_BAKCTRL) ) 
      {
         swprintf(errMsg,L"Operation is not valid on a domain controller.\n");
         hr = E_FAIL;
         break;

      }

      //
      // do not allow a workstation to trust itself
      //
      if(lstrcmpiW(TrustedDomainName, Workstation) == 0) 
      {
         swprintf(errMsg,L"Error:  Domain %ls cannot be a member of itself.\n",
            TrustedDomainName);
         hr = E_FAIL; 
         break;
      }

      if( lstrlenW(TrustedDomainName ) > MAX_COMPUTERNAME_LENGTH )
      {
         TrustedDomainName[MAX_COMPUTERNAME_LENGTH] = L'\0'; // truncate
      }

      //
      // open the policy on this computer
      //
      Status = OpenPolicy(
               Workstation,
               DELETE                      |    // to remove a trust
               POLICY_VIEW_LOCAL_INFORMATION | // to view trusts
               POLICY_CREATE_SECRET |  // for password set operation
               POLICY_TRUST_ADMIN,     // for trust creation
               &PolicyHandle
               );

      if( Status != STATUS_SUCCESS ) 
      {
         //DisplayNtStatus(errMsg,"OpenPolicy", Status,NULL);
         hr = LsaNtStatusToWinError(Status);
         break;
      }

      if( Status != STATUS_SUCCESS ) 
      {
         hr = E_FAIL;
         break;
      }


      //
      // Update the primary domain to match the specified trusted domain
      //
      if (! m_bNoChange )
      {
         Status = SetPrimaryDomain(PolicyHandle, NULL, TrustedDomainName);

         if(Status != STATUS_SUCCESS) 
         {
            //DisplayNtStatus(errMsg,"SetPrimaryDomain", Status,NULL);
            hr = LsaNtStatusToWinError(Status);
            break;
         }

      }
   } while (false);  // do once 

   // Cleanup
   //
   // close the policy handle
   //

   if(PolicyHandle)
   {
      LsaClose(PolicyHandle);
   }
   
   /*if ( bSessionEstablished )
   {
      EstablishSession(Workstation,m_domain,m_account,m_password,FALSE);
   }
   */
   if ( FAILED(hr) )
   {
      hr = S_FALSE;
      (*errReturn) = SysAllocString(errMsg);
   }
   return hr;

}

STDMETHODIMP 
   CChangeDomain::ConnectAs(
      BSTR                   domain,            // in - domain name to use for credentials
      BSTR                   user,              // in - account name to use for credentials
      BSTR                   password           // in - password to use for credentials
   )
{
	m_domain = domain;
   m_account = user;
   m_password = password;
   m_domainAccount = domain;
   m_domainAccount += L"\\";
   m_domainAccount += user;
   return S_OK;
}

STDMETHODIMP 
   CChangeDomain::get_NoChange(
      BOOL                 * pVal              // out- flag, whether to write changes
   )
{
	(*pVal) = m_bNoChange;
	return S_OK;
}

STDMETHODIMP 
   CChangeDomain::put_NoChange(
      BOOL                   newVal           // in - flag, whether to write changes
   )
{
	m_bNoChange = newVal;
   return S_OK;
}


// ChangeDomain worknode:  Changes the domain affiliation of a workstation or server
//                         (This operation cannot be performed on domain controllers)
//
// VarSet syntax:
//
// Input:  
//          ChangeDomain.Computer: <ComputerName>
//          ChangeDomain.TargetDomain: <Domain>
//          ChangeDomain.DomainIsWorkgroup: <Yes|No>           default is No
//          ChangeDomain.ConnectAs.Domain: <Domain>            optional credentials to use
//          ChangeDomain.ConnectAs.User : <Username>
//          ChangeDomain.ConnectAs.Password : <Password>
//
// Output:
//          ChangeDomain.ErrorText : <string-error message>

// This function is not currently used by the domain migration tool.
// The actual implementation is removed from the source.
STDMETHODIMP 
   CChangeDomain::Process(
      IUnknown             * pWorkItem
   )
{
   return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\checker.cpp ===
// AccessChecker.cpp : Implementation of CAccessChecker
#include "stdafx.h"
#include "WorkObj.h"
#include "Checker.h"
#include <lm.h>
#include "GetDcName.h"
#include <iads.h>
#include <comdef.h>
//#include <adshlp.h>
#include "treg.hpp"
#include "BkupRstr.hpp"
#include "UString.hpp"
#include "EaLen.hpp"
#include "IsAdmin.hpp"
#include <ntsecapi.h>
#include <winerror.h>
#include "SidHistoryFlags.h"
#include "BkupRstr.hpp"
#include "ResStr.h"

//#import "\bin\NetEnum.tlb" no_namespace 
#import "NetEnum.tlb" no_namespace 

// Win2k function
typedef HRESULT (CALLBACK * ADSGETOBJECT)(LPWSTR, REFIID, void**);


/////////////////////////////////////////////////////////////////////////////
// CAccessChecker


STDMETHODIMP CAccessChecker::GetOsVersion(BSTR server, DWORD * pdwVerMaj, DWORD * pdwVerMin, DWORD * pdwVerSP)
{
   // This function looksup the OS version on the server specified and returns it.
   // CAUTION : This function always returns 0 for the ServicePack. 
   WKSTA_INFO_100       * pInfo;
   long rc = NetWkstaGetInfo(server,100,(LPBYTE*)&pInfo);
	if ( ! rc )
	{
      *pdwVerMaj = pInfo->wki100_ver_major;
      *pdwVerMin = pInfo->wki100_ver_minor;
      *pdwVerSP = 0;
      NetApiBufferFree(pInfo);
	}  
   else
      return HRESULT_FROM_WIN32(rc);

   return S_OK;
}

STDMETHODIMP CAccessChecker::IsNativeMode(BSTR Domain, BOOL * pbIsNativeMode)
{
   ADSGETOBJECT            ADsGetObject;
   HMODULE hMod = LoadLibrary(L"activeds.dll");
   if ( hMod == NULL )
      return HRESULT_FROM_WIN32(GetLastError());

   ADsGetObject = (ADSGETOBJECT)GetProcAddress(hMod, "ADsGetObject");
   if (!ADsGetObject)
   {
      if ( hMod )
         FreeLibrary(hMod);
      return HRESULT_FROM_WIN32(GetLastError());
   }

   IADs     			* pDomain;
   HRESULT				  hr;
   VARIANT				  var;
   _bstr_t                sDom( L"LDAP://" );
   sDom += Domain;

   hr = ADsGetObject(sDom, IID_IADs, (void **) &pDomain);
   if (SUCCEEDED(hr))
   {
      VariantInit(&var);
      
      //Get the ntMixedDomain attribute
      hr = pDomain->Get(L"ntMixedDomain", &var);
      if (SUCCEEDED(hr))
      {
         hr = E_FAIL;
         //Type should be VT_I4.
         if (var.vt==VT_I4)
         {
            //Zero means native mode.
            if (var.lVal == 0)
            {
               hr = S_OK;
               *pbIsNativeMode = true;
            }
            //One means mixed mode.
            else if(var.lVal == 1)
            {
               hr = S_OK;
               *pbIsNativeMode = false; 
            }
         }
      }
      VariantClear(&var);
	  pDomain->Release();
   }

   if ( hMod )
      FreeLibrary(hMod);

   return hr;
}

STDMETHODIMP CAccessChecker::CanUseAddSidHistory(BSTR srcDomain, BSTR tgtDomain, BSTR tgtDC, long * pbCanUseIt)
{
    DWORD                     rc = 0;         // OS return code
    WKSTA_INFO_100          * pInfo = NULL;
    TRegKey                   sysKey, regComputer;
    DWORD                     rval;	
    _bstr_t                   bstrSourceMachine;
    _bstr_t                   bstrTargetMachine;

    // initialize the return FieldMask
    * pbCanUseIt = F_WORKS;

    rc = GetDcName4(srcDomain, DS_PDC_REQUIRED, bstrSourceMachine);

    if( rc != NO_ERROR ) goto ret_exit;

    if (tgtDC && *tgtDC)
    {
        bstrTargetMachine = tgtDC;
    }
    else
    {
        rc = GetDcName4(tgtDomain, 0, bstrTargetMachine);

        if( rc != NO_ERROR ) goto ret_exit;
    }

    if (GetBkupRstrPriv(bstrSourceMachine))
    {
        rc = regComputer.Connect( HKEY_LOCAL_MACHINE, bstrSourceMachine );

        // Check the registry to see if the TcpipClientSupport key is there
        if ( ! rc )
        {
            rc = sysKey.OpenRead(L"System\\CurrentControlSet\\Control\\Lsa",&regComputer);
        }
        if ( ! rc )
        {
            rc = sysKey.ValueGetDWORD(L"TcpipClientSupport",&rval);
            if ( !rc ) 
            {
                if ( rval != 1 )
                {
                    *pbCanUseIt |= F_NO_REG_KEY;
                }
            }
            else
            {
                // DWORD value not found
                *pbCanUseIt |= F_NO_REG_KEY;
                rc = 0;
            }
        }
    }
    else
    {
        rc = GetLastError();
    }

    // Check if the target domain is a Win2k native mode domain.
    if ( !rc )
    {
        rc = NetWkstaGetInfo(bstrTargetMachine,100,(LPBYTE*)&pInfo);
        if ( ! rc )
        {
            if ( pInfo->wki100_ver_major < 5 )
            {
                // cannot add Sid history to non Win2k Domains
                *pbCanUseIt |= F_WRONGOS;
            }
            else{
                BOOL isNative = false;
                if(SUCCEEDED(IsNativeMode( _bstr_t(pInfo->wki100_langroup), &isNative))){
                    if( isNative == false ) *pbCanUseIt |= F_WRONGOS;
                }
            }
        }
        else
        {
            rc = GetLastError();
        }
    }

    bool bDotNetOrLater = false;

    if (pInfo)
    {
        if (pInfo->wki100_ver_major > 5 || (pInfo->wki100_ver_major == 5 && pInfo->wki100_ver_minor > 0))
        {
            bDotNetOrLater = true;
        }
    }

    //
    // If the target domain controller is Windows 2000 then caller must
    // be a member of the domain administrators group in the target domain.
    //

    if (!rc)
    {
        if (!bDotNetOrLater)
        {
            PUSER_MODALS_INFO_2 pumi2Info;

            NET_API_STATUS nasStatus = NetUserModalsGet(bstrTargetMachine, 2, (LPBYTE*)&pumi2Info);

            if (nasStatus == NERR_Success)
            {
                rc = IsDomainAdmin(pumi2Info->usrmod2_domain_id);

                if (rc == ERROR_ACCESS_DENIED)
                {
                    *pbCanUseIt |= F_NOT_DOMAIN_ADMIN;
                    rc = ERROR_SUCCESS;
                }

                NetApiBufferFree(pumi2Info);
            }
            else
            {
                rc = nasStatus;
            }
        }
    }

    if ( !rc )
    {
        // Check auditing on the source domain.
        rc = DetectAuditing(bstrSourceMachine);
        if ( rc == -1 )
        {
            rc = 0;
            *pbCanUseIt |= F_NO_AUDITING_SOURCE;
        }
    }

    if ( !rc )
    {
        // Check auditing on the target domain.
        rc = DetectAuditing(bstrTargetMachine);
        if ( rc == -1 )
        {
            rc = 0;
            *pbCanUseIt |= F_NO_AUDITING_TARGET;
        }

        //
        // On .NET Server and later the permission to migrate SIDs may be granted to any user.
        // As this user may not be an administrator in the target domain it might not be
        // possible for this user to obtain access to auditing policy information. Therefore
        // an access denied error will be ignored so that the user may perform the SID
        // migration but only on .NET Server (5.1) or later. If Windows 2000 and the caller is
        // not a domain administrator then also set success as the reason for the access
        // denied has already been determined.
        //

        if (rc == ERROR_ACCESS_DENIED)
        {
            if (bDotNetOrLater || (*pbCanUseIt & F_NOT_DOMAIN_ADMIN))
            {
                rc = ERROR_SUCCESS;
            }
        }
    }

    if (!rc )
    {
        _bstr_t strDnsName;
        _bstr_t strFlatName;

        rc = GetDomainNames4(srcDomain, strFlatName, strDnsName);

        if (rc == ERROR_SUCCESS)
        {
            LOCALGROUP_INFO_0    * pInfo = NULL;
            WCHAR                  groupName[LEN_Account];

            wsprintf(groupName,L"%ls$$$",(WCHAR*)strFlatName);
            rc = NetLocalGroupGetInfo(bstrSourceMachine,groupName,0,(BYTE**)&pInfo);

            if ( rc == NERR_GroupNotFound )
            {
                rc = 0;
                *pbCanUseIt |= F_NO_LOCAL_GROUP;
            }
            else
            {
                NetApiBufferFree(pInfo);
            }
        }
    }

ret_exit:

    if ( pInfo ) NetApiBufferFree(pInfo);

    return HRESULT_FROM_WIN32(rc);
}

//------------------------------------------------------------------------------------------
// AddLocalGroup : Given the source domain, and source domain controller names, this 
//					    function creates the local group SOURCEDOMAIN$$$ in the source domain.
//                 This local group must exist in the source domain for the DsAddSidHistory 
//                 API to work.
//             
//------------------------------------------------------------------------------------------

STDMETHODIMP CAccessChecker::AddLocalGroup(BSTR srcDomain, BSTR sourceDC)
{
   DWORD                     rc = 0;
   LOCALGROUP_INFO_1         groupInfo;
   WCHAR                     name[LEN_Account];
   WCHAR                     comment[LEN_Account];
   DWORD                     parmErr;

   swprintf(name,L"%ls$$$",(WCHAR*)srcDomain);
   groupInfo.lgrpi1_name = name;
   wcscpy(comment, (WCHAR*)GET_BSTR(IDS_DOM_LOC_GRP_COMMENT));
   groupInfo.lgrpi1_comment = comment;
   
   rc = NetLocalGroupAdd(sourceDC,1,(LPBYTE)&groupInfo,&parmErr);

   return HRESULT_FROM_WIN32(rc);
}
//------------------------------------------------------------------------------------------
// IsInSameForest : Given the source and the target domains this function tells us if 
//					both the domains are in the same forest. This function enumerates all
//                  the domains in the Forest of the source domain and compares them to
//                  the target domain name. If there is a match then we know we are in same
//                  forest.
//------------------------------------------------------------------------------------------
STDMETHODIMP CAccessChecker::IsInSameForest(BSTR srcDomain, BSTR tgtDomain, BOOL * pbIsSame)
{
    // Initialize the return value
    *pbIsSame = FALSE;

    // Load the ADSI function dynamically
    ADSGETOBJECT            ADsGetObject;
    HMODULE                 hMod = LoadLibrary(L"activeds.dll");
    if ( hMod == NULL )
        return HRESULT_FROM_WIN32(GetLastError());

    ADsGetObject = (ADSGETOBJECT)GetProcAddress(hMod, "ADsGetObject");
    if (!ADsGetObject)
    {
        if ( hMod )
            FreeLibrary(hMod);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // we are going to look up the Schema naming context of both domains.
    // if they are the same then these two domains are in same forest.
    IADs       * pAds = NULL;
    HRESULT      hr = S_OK;
    WCHAR        sPath[LEN_Path];
    _variant_t   var;
    _bstr_t      srcSchema, tgtSchema;

    // Get the schemaNamingContext for the source domain.
    wsprintf(sPath, L"LDAP://%s/rootDSE", (WCHAR*) srcDomain);
    hr = ADsGetObject(sPath, IID_IADs, (void**) &pAds);
    if ( SUCCEEDED(hr) )
        hr = pAds->Get(L"schemaNamingContext", &var);

    if ( SUCCEEDED(hr) )
        srcSchema = var;
    else
        srcSchema = L"";

    if ( pAds )
    {
        pAds->Release();
        pAds = NULL;
    }

    if (SUCCEEDED(hr))
    {
        // Now do the same for the target domain.
        wsprintf(sPath, L"LDAP://%s/rootDSE", (WCHAR*) tgtDomain);
        hr = ADsGetObject(sPath, IID_IADs, (void**) &pAds);
        if ( SUCCEEDED(hr) )
            hr = pAds->Get(L"schemaNamingContext", &var);

        if ( SUCCEEDED(hr) )
            tgtSchema = var;
        else
        {
            if ( hr == HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN) )
            {
                // for NT 4 domains, we always get this error
                _bstr_t strDc;

                DWORD rc = GetDcName4(tgtDomain, 0, strDc);

                if ( ! rc )
                {
                    WKSTA_INFO_100       * pInfo = NULL;

                    rc = NetWkstaGetInfo(strDc,100,(LPBYTE*)&pInfo);
                    if ( ! rc )
                    {
                        if ( pInfo->wki100_ver_major < 5 )
                        {
                            (*pbIsSame) = FALSE;
                            hr = 0;
                        }
                        NetApiBufferFree(pInfo);
                    }  
                    else
                        hr = HRESULT_FROM_WIN32(rc); // the return code from NetWkstaGetInfo may be more descriptive
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(rc);
                }
            }
            tgtSchema = L"";
        }

        if ( pAds )
        {
            pAds->Release();
            pAds = NULL;
        }

        *pbIsSame = (srcSchema == tgtSchema);
    }
    else
    {
        if ( hr == HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN) )
        {
            // for NT 4 domains, we always get this error
            _bstr_t strDc;

            DWORD rc = GetDcName4(srcDomain, 0, strDc);

            if ( ! rc )
            {
                WKSTA_INFO_100       * pInfo = NULL;

                rc = NetWkstaGetInfo(strDc,100,(LPBYTE*)&pInfo);
                if ( ! rc )
                {
                    if ( pInfo->wki100_ver_major < 5 )
                    {
                        (*pbIsSame) = FALSE;
                        hr = 0;
                    }
                    NetApiBufferFree(pInfo);
                }  
                else
                    hr = HRESULT_FROM_WIN32(rc); // the return code from NetWkstaGetInfo may be more descriptive
            }
        }

    }

    return hr;
}

STDMETHODIMP 
   CAccessChecker::GetPasswordPolicy(
      BSTR                   domain,                  /*[out]*/ 
      LONG                 * dwPasswordLength         /*[out]*/ 
  )
{
   HRESULT                   hr = S_OK;

   // initialize output parameter
   (*dwPasswordLength) = 0;

   ADSGETOBJECT            ADsGetObject;

   HMODULE                 hMod = LoadLibrary(L"activeds.dll");
   if ( hMod == NULL )
      return HRESULT_FROM_WIN32(GetLastError());

   ADsGetObject = (ADSGETOBJECT)GetProcAddress(hMod, "ADsGetObject");
   if (!ADsGetObject)
   {
      if ( hMod )
         FreeLibrary(hMod);
      return HRESULT_FROM_WIN32(GetLastError());
   }

   IADsDomain     			* pDomain;
   _bstr_t                   sDom( L"WinNT://" );
   
   sDom += domain;

   hr = ADsGetObject(sDom, IID_IADsDomain, (void **) &pDomain);
   if (SUCCEEDED(hr))
   {
      
      //Get the ntMixedDomain attribute
      hr = pDomain->get_MinPasswordLength(dwPasswordLength);
     
      pDomain->Release();
   }
      
   if ( hMod )
      FreeLibrary(hMod);
   return hr;
}

STDMETHODIMP CAccessChecker::EnableAuditing(BSTR sDC)
{
   LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
   DWORD                     wszStringLength;
   LSA_UNICODE_STRING        lsaszServer;
   NTSTATUS                  ntsResult;
   LSA_HANDLE                hPolicy;
   long                      rc = 0;

   // Object attributes are reserved, so initalize to zeroes.
   ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
   
   //Initialize an LSA_UNICODE_STRING structure to the server name.
   wszStringLength = wcslen((WCHAR*)sDC);
   lsaszServer.Buffer = (WCHAR*)sDC;
   lsaszServer.Length = (USHORT)wszStringLength * sizeof(WCHAR);
   lsaszServer.MaximumLength=(USHORT)wszStringLength * sizeof(WCHAR);

   // Attempt to open the policy.
   ntsResult = LsaOpenPolicy(
                &lsaszServer,
                &ObjectAttributes,
                POLICY_VIEW_AUDIT_INFORMATION | POLICY_VIEW_LOCAL_INFORMATION | POLICY_SET_AUDIT_REQUIREMENTS , 
                &hPolicy  //recieves the policy handle
                );

   if ( !ntsResult )
   {
      // Ask for audit policy information
      PPOLICY_AUDIT_EVENTS_INFO   info;
      ntsResult = LsaQueryInformationPolicy(hPolicy, PolicyAuditEventsInformation, (PVOID *)&info);
      
      if ( !ntsResult )
      {
         // turn on the audit mode.
         info->AuditingMode = TRUE;
         // turn on the success/failure for the Account management events
         info->EventAuditingOptions[AuditCategoryAccountManagement] = POLICY_AUDIT_EVENT_SUCCESS | POLICY_AUDIT_EVENT_FAILURE;
         ntsResult = LsaSetInformationPolicy(hPolicy, PolicyAuditEventsInformation, (PVOID) info);
         if ( ntsResult ) 
            rc = LsaNtStatusToWinError(ntsResult);
         // be a good boy and cleanup after yourself.
         LsaFreeMemory((PVOID) info);
      }
      else
         rc = LsaNtStatusToWinError(ntsResult);
      
      //Freeing the policy object handle
      ntsResult = LsaClose(hPolicy);
   }
   else
      rc = LsaNtStatusToWinError(ntsResult);
//      long rc = LsaNtStatusToWinError(ntsResult);

   return HRESULT_FROM_WIN32(rc);
}

long CAccessChecker::DetectAuditing(BSTR sDC)
{
   LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
   DWORD                     wszStringLength;
   LSA_UNICODE_STRING        lsaszServer;
   NTSTATUS                  ntsResult;
   LSA_HANDLE                hPolicy;
   long                      rc = 0;

   // Object attributes are reserved, so initalize to zeroes.
   ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
   
   //Initialize an LSA_UNICODE_STRING structure to the server name.
   wszStringLength = wcslen((WCHAR*)sDC);
   lsaszServer.Buffer = (WCHAR*)sDC;
   lsaszServer.Length = (USHORT)wszStringLength * sizeof(WCHAR);
   lsaszServer.MaximumLength=(USHORT)wszStringLength * sizeof(WCHAR);

   // Attempt to open the policy.
   ntsResult = LsaOpenPolicy(
                &lsaszServer,
                &ObjectAttributes,
                POLICY_VIEW_AUDIT_INFORMATION | POLICY_VIEW_LOCAL_INFORMATION,
                &hPolicy  //recieves the policy handle
                );

   if ( !ntsResult )
   {
      // Ask for audit policy information
      PPOLICY_AUDIT_EVENTS_INFO   info;
      ntsResult = LsaQueryInformationPolicy(hPolicy, PolicyAuditEventsInformation, (PVOID *)&info);
      
      if ( !ntsResult )
      {
         // check if the over all auditing is turned on
         if (!info->AuditingMode)
            rc = -1;

         // Check if the account management event auditing is on
         if (info->EventAuditingOptions[AuditCategoryAccountManagement] != (POLICY_AUDIT_EVENT_SUCCESS | POLICY_AUDIT_EVENT_FAILURE))
            rc = -1;
         LsaFreeMemory((PVOID) info);
      }
      else
         rc = LsaNtStatusToWinError(ntsResult);
      
      //Freeing the policy object handle
      ntsResult = LsaClose(hPolicy);
   }
   else
      rc = LsaNtStatusToWinError(ntsResult);
   
   return rc;
}

STDMETHODIMP CAccessChecker::AddRegKey(BSTR srcDc,LONG bReboot)
{
   // This function will add the necessary registry key and then reboot the 
   // PDC for a given domain
   TRegKey                   sysKey, regComputer;
   DOMAIN_CONTROLLER_INFO  * pSrcDomCtrlInfo = NULL;
  	DWORD                     rc = 0;         // OS return code
//   BSTR							  bstrSourceMachine = NULL;
   _bstr_t                   sDC;

   if (GetBkupRstrPriv(srcDc))
   {
      rc = regComputer.Connect( HKEY_LOCAL_MACHINE, (WCHAR*)srcDc );
   }
   else
   {
      rc = GetLastError();
   }
   // Add the TcpipClientSupport DWORD value
	if ( ! rc )
	{
		rc = sysKey.Open(L"System\\CurrentControlSet\\Control\\Lsa",&regComputer);
	}
	
   if ( ! rc )
	{
		rc = sysKey.ValueSetDWORD(L"TcpipClientSupport",1);
	}

   if ( !rc && bReboot)
   {
      // Computer will shutdown and restart in 10 seconds.
      rc = ComputerShutDown((WCHAR*) srcDc, GET_STRING(IDS_RegKeyRebootMessage), 10, TRUE, FALSE);         
   }
   if ( pSrcDomCtrlInfo ) NetApiBufferFree(pSrcDomCtrlInfo);
   return HRESULT_FROM_WIN32(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\dctstat.h ===
#define DCT_STATUS_NOT_STARTED         (0x00000001)
#define DCT_STATUS_IN_PROGRESS         (0x00000002)
#define DCT_STATUS_ABORTING            (0x00000004)
#define DCT_STATUS_ABORTED             (0x00000008)
#define DCT_STATUS_COMPLETED           (0x00000010)
#define DCT_STATUS_UNKNOWN             (0x00000020)
#define DCT_STATUS_COMPLETED_WITH_ERRORS		(0x00000040)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\checker.h ===
// AccessChecker.h : Declaration of the CAccessChecker

#ifndef __ACCESSCHECKER_H_
#define __ACCESSCHECKER_H_

#include "resource.h"       // main symbols

#include "WorkObj.h"
/////////////////////////////////////////////////////////////////////////////
// CAccessChecker
class ATL_NO_VTABLE CAccessChecker : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAccessChecker, &CLSID_AccessChecker>,
	public IDispatchImpl<IAccessChecker, &IID_IAccessChecker, &LIBID_MCSDCTWORKEROBJECTSLib>
{
public:
	CAccessChecker()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_ACCESSCHECKER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAccessChecker)
	COM_INTERFACE_ENTRY(IAccessChecker)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IAccessChecker
public:
	STDMETHOD(IsInSameForest)(BSTR srcDomain, BSTR tgtDomain, /*[out]*/ BOOL * pbIsSame);
	STDMETHOD(CanUseAddSidHistory)(BSTR srcDomain, BSTR tgtDomain, BSTR tgtDC, /*[out]*/ LONG * pbCanUseIt);
	STDMETHOD(IsNativeMode)(BSTR Domain, /*[out]*/ BOOL * pbIsNativeMode);
	STDMETHOD(GetOsVersion)(BSTR server, /*[out]*/ DWORD * pdwVerMaj, /*[out]*/ DWORD * pdwVerMin, /*[out]*/ DWORD * pdwVerSP);
    STDMETHOD(GetPasswordPolicy)(BSTR domain,/*[out]*/ LONG * dwPasswordLength);
    STDMETHOD(EnableAuditing)(/*[in]*/BSTR sDC);
    STDMETHOD(AddRegKey)(/*[in]*/BSTR sDC,LONG bReboot);
    STDMETHOD(AddLocalGroup)(/*[in]*/BSTR srcDomain,/*[in]*/BSTR srcDC);
private:
	long DetectAuditing(BSTR sDC);
};


#endif //__ACCESSCHECKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
//#include "WorkerObjects_p.c"
#include "WorkObj_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__DF98CEF3_B5F4_11D2_A1DE_00A0C9AFE114__INCLUDED_)
#define AFX_DLLDATAX_H__DF98CEF3_B5F4_11D2_A1DE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__DF98CEF3_B5F4_11D2_A1DE_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\enumvols.cpp ===
//#pragma title( "EnumVols.cpp - Volume Enumeration" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  enumvols.hpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/06/27
Description -  Classes used to generate a list of pathnames, given a list of paths and/or 
               machine names.
Updates     -
===============================================================================
*/
#include <stdio.h>

#include "stdafx.h"

#include <lm.h>
#include <assert.h>

#include "Common.hpp"
#include "Err.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"
#include "EnumVols.hpp"
#include "BkupRstr.hpp"

#define BUF_ENTRY_LENGTH     (3)

extern WCHAR *       // ret -machine-name prefix of pathname if pathname is a UNC path, otherwise returns NULL
   GetMachineName(
      const LPWSTR           pathname        // in -pathname from which to extract machine name
   );


extern TErrorDct err;
extern bool silent;

bool                                   // ret -true if name begins with "\\" has at least 3 total chars, and no other '\'
   IsMachineName(
      const LPWSTR           name      // in -possible machine name to check
   )
{
   assert( name );
   WCHAR                   * c = NULL;          // used to traverse the name (will stay NULL if prefix check fails)
   if ( name[0] == L'\\' &&  name[1] == L'\\' )               // check for "\\" prefix      
   {
         for ( c = name + 2 ; *c && *c != L'\\' ; c++ )     // check rest of string
         ;
   }
   return ( c && *c != L'\\' );      // <=> prefix check worked && we made it to the end of the string without hitting a '\'
}

bool                                   // ret -true if name is of the form \\machine\share
   IsShareName(
      const LPWSTR           name      // in -string to check
   )
{
   assert( name );

   WCHAR                   * c = NULL;          // used to traverse the name (will stay NULL if prefix check fails)
   bool                      skip = true;

   if ( name[0] == L'\\' &&  name[1] == L'\\' )               // check for "\\" prefix      
   {
         for ( c = name + 2 ; *c && (*c != L'\\' || skip) ; c++ )     // check rest of string
         {
            if ( *c == L'\\' )
               skip = false;
         }
   }
   return ( c && *c != L'\\' );   
}

bool 
   IsUNCName(
      const LPWSTR           name    // in - string to check
   )
{
   return ( name[0] == L'\\' && name[1] == L'\\' && name[2]!=0 );
}

bool 
   ContainsWildcard(
      WCHAR const *        string
   )
{
   bool                   wc = false;
   WCHAR          const * curr = string;

   if ( string )
   {
      while ( *curr && ! wc )
      {
         if (  *curr == L'*' 
            || *curr == L'?'
            || *curr == L'#'
            )
         {
            wc = true;
         }
         curr++;
      }
   }
   return wc;
}
   

/************************************************************************************
                           TPathNode Implementation
*************************************************************************************/
   TPathNode::TPathNode(
      const LPWSTR           name              // -in path-name for this node 
   )
{
   assert( name );                                  // name should always be a valid 
   assert( UStrLen(name) <= MAX_PATH );             // string, shorter than MAX_PATH               
   safecopy(path,name);
   iscontainer = true;
   FindServerName();
   LookForWCChars();
}

void 
   TPathNode::Display() const 
{
   wprintf(L"%s\n",path);
   wprintf(L"%s\n",server);
}

void 
   TPathNode::LookForWCChars()
{
   ContainsWC(ContainsWildcard(path)); 
}

void 
   TPathNode::FindServerName()
{
   WCHAR                     volRoot[MAX_PATH];
   WCHAR                     tempName[MAX_PATH];
   UINT                      driveType;
   DWORD                     rc = 0;
   REMOTE_NAME_INFO          info;
   DWORD                     sizeBuffer = (sizeof info);
   WCHAR                   * machine;
   
   if ( IsMachineName(path) )
   {
      safecopy(server,path);
   }
   else
   {
      safecopy(tempName,path);
      if ( path[0] != L'\\' || path[1] != L'\\' )       // get the unc name
      {
         swprintf(volRoot, L"%-3.3s", path);
         driveType = GetDriveType(volRoot);
         switch ( driveType )
         {
            case DRIVE_REMOTE:
               rc = WNetGetUniversalName(volRoot,
                                         REMOTE_NAME_INFO_LEVEL,
                                         (PVOID)&info,
                                         &sizeBuffer);
               switch ( rc )
               {
                  case 0:
                     safecopy(tempName, info.lpUniversalName);
                     swprintf(volRoot,L"%s\\%s",tempName,path+3);
                     safecopy(path,volRoot);
                     break;
                  case ERROR_NOT_CONNECTED:
                     break;
                  default:
                     err.SysMsgWrite(ErrE, rc, DCT_MSG_GET_UNIVERSAL_NAME_FAILED_SD,
                                                path, rc);
               }
               break;
         }
      }
      machine = GetMachineName(path);
      if ( machine )
      {
         safecopy(server,machine);
         delete [] machine;
      }
      else
      {
         server[0] = 0;
      }
   }
}

DWORD                                      // ret-0=path exists, ERROR_PATH_NOT_FOUND=path does not exist
   TPathNode::VerifyExists()
{
   DWORD                     rc = 0;
   WCHAR                     wname[MAX_PATH];
   int                       len;
   HANDLE                    hFind;
   WIN32_FIND_DATAW          findEntry;              
   SERVER_INFO_100         * servInfo = NULL;
   SHARE_INFO_0            * shareInfo = NULL;

   safecopy(wname,path);
   
   if ( IsMachineName(wname) )
   {
      rc = NetServerGetInfo(wname,100,(LPBYTE *)&servInfo);
      switch ( rc )
      {                   
      case NERR_Success:  
         break;
      case ERROR_BAD_NETPATH:
         rc = ERROR_PATH_NOT_FOUND;
         break;
      default:
         err.SysMsgWrite(ErrW,rc,DCT_MSG_SERVER_GETINFO_FAILED_SD,wname,rc);
         break;
      }
      if ( servInfo )
      {
         NetApiBufferFree(servInfo);
      }
   }
   else if ( IsShareName(wname) )
   {
      int                    ch;
      for ( ch = 2; wname[ch]!= L'\\' && wname[ch] ; ch++ )
         ;
      MCSVERIFY(wname[ch] == L'\\' );
      
      wname[ch] = 0;
      rc = NetShareGetInfo(wname,wname+ch+1,0,(LPBYTE *)&shareInfo);
      wname[ch] = L'\\';
      
      switch ( rc )
      {
      case NERR_NetNameNotFound:
         rc = ERROR_PATH_NOT_FOUND;
         break;
      case ERROR_SUCCESS:
         NetApiBufferFree(shareInfo);
         break;
      default:
         err.SysMsgWrite(ErrW,rc,DCT_MSG_SHARE_GETINFO_FAILED_SD,wname,rc);
         break;
      }
   }
   else
   {
      iscontainer = false;

      if ( wname[len = UStrLen(wname) - 1] == '\\' )  // len is the index of the last character (before NULL)
      {
         wname[len] = '\0';     // remove trailing backslash
         len--;
      }       
                                             // do a 'find' on this file w/o wildcards, in case it is a file
      hFind = FindFirstFileW(wname, &findEntry);
      
      if ( hFind == INVALID_HANDLE_VALUE )
      {                                      // it's not a file, lets see if it's a directory
                                             // do a find with \*.* appended
         validalone = false;
         UStrCpy(wname + len + 1,"\\*.*",DIM(wname) - len);
         hFind = FindFirstFileW(wname,&findEntry);
         if ( hFind == INVALID_HANDLE_VALUE )
         {
            rc = ERROR_PATH_NOT_FOUND;
         }
         iscontainer = true;
         wname[len+1] = 0;    
      }
      else
      {
         validalone = true;
         if ( findEntry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
         {
            iscontainer = true;
         } 
         FindClose(hFind);
      }
   }
   return rc;
}

DWORD                                            // ret- 0=successful, ERROR_PRIVILEGE_NOT_HELD otherwise
   TPathNode::VerifyBackupRestore()
{
   DWORD                     rc = 0;
   
	  //get needed privileges and keep them until the agent removes itself
   if ( ! GetBkupRstrPriv(server) )
   {
      rc = ERROR_PRIVILEGE_NOT_HELD;
   }
   
   return rc;
}
  
// GetRootPath finds the root path of a volume.  This is needed so we can call
// GetVolumeInformation to find out things like whether this volume supports ACLs
// This is fairly simplistic, and works by counting the backslashes in the path
DWORD                                        // ret- 0 or OS return code
   GetRootPath(
      WCHAR                * rootpath,       // out- path to root of volume
      WCHAR          const * path            // in - path within some volume
   )
{
   DWORD                     rc = 0;
   DWORD                     i = 0;
   DWORD                     slashcount = 1;
   bool                      unc = false;
   WCHAR                     tempPath[MAX_PATH];
   SHARE_INFO_2            * sInfo;

   if ( path[0] == L'\\' && path[1] == L'\\' )
   {
      slashcount = 4;
      unc = true;
   }
   for (i = 0 ; path[i] && slashcount &&  i < DIM(tempPath)-1; i++ )
   {
      tempPath[i] = path[i];
      if ( tempPath[i] == L'\\' )
      {
         slashcount--;
      }
   }
   if ( tempPath[i-1] == L'\\' )
   {
      tempPath[i] = 0;     
   }
   else
   {
      if (i == DIM(tempPath) - 1)
      {
        // if i points to the end of the buffer, truncate the last character
        i--;
      }
      tempPath[i] = L'\\' ;
      tempPath[i+1] = 0;
      i++;
   }
   
   // now rootpath contains either D:\ or \\machine\share\ .
   if ( unc )
   {
      // remove the trailing slash from the sharename
      if ( tempPath[i] == 0 )
      {
         i--;
      }
      if ( tempPath[i] == L'\\' )
      {
         tempPath[i] = 0;
      }
      // find the beginning of the share name
      while ( ( i > 0 ) && tempPath[i] != L'\\' )
         i--;

      if ( i < 3 )
      {
         MCSVERIFY(FALSE);
         rc = ERROR_INVALID_PARAMETER;
      }
      else
      {
         tempPath[i] = 0;
      }
      rc = NetShareGetInfo(tempPath,tempPath+i+1,2,(LPBYTE*)&sInfo);
      if ( ! rc )
      {
         swprintf(rootpath,L"%s\\%c$\\",tempPath,sInfo->shi2_path[0]);
         NetApiBufferFree(sInfo);
      }
   }
   else
   {
      UStrCpy(rootpath,tempPath);
   }
   return rc;
}

DWORD 
   TPathNode::VerifyPersistentAcls()                    // ret- 0=Yes, ERROR_NO_SECURITY_ON_OBJECT or OS error code
{
   DWORD               rc = 0;
   DWORD               maxcomponentlen;               // will be used as args for GetVolumeInformation
   DWORD               flags;
   UINT                errmode;                      
   WCHAR               rootpath[MAX_PATH];                     
   WCHAR               fstype[MAX_PATH];
   
   errmode = SetErrorMode(SEM_FAILCRITICALERRORS);    // set this to prevent message box when
                                                      // called on removable media drives which are empty
   if ( ! IsMachineName(path) )
   {
      rc = GetRootPath(rootpath,path);
      if ( ! rc )
      {
         if ( !GetVolumeInformation(rootpath,NULL,0,NULL,&maxcomponentlen,&flags,fstype,DIM(fstype)) )
         {
   
            rc = GetLastError();
   
            if ( rc != ERROR_NOT_READY ) 
            {
               err.SysMsgWrite(ErrW,GetLastError(),DCT_MSG_GET_VOLUME_INFO_FAILED_SD,rootpath,GetLastError());
            }
         }
         else 
         {
            if (!( FS_PERSISTENT_ACLS & flags) )
            {
               rc = ERROR_NO_SECURITY_ON_OBJECT;
            }
         }
      }
   }

   SetErrorMode(errmode);  // restore error mode to its prior state

   return rc;
}

// This function is used when expanding wildcards in server names.  It replaces server field with the new name,
// and if the path is a UNC, it changes the server component of the path.
void 
   TPathNode::SetServerName(
      UCHAR          const * name          // in - new server name
   )
{
   if ( IsUNCName(path) )
   {
      WCHAR                  newpath[MAX_PATH];
      int                    len = UStrLen(server);

      swprintf(newpath,L"%S%s",name,path+len);

      safecopy(path,newpath);
   }
   safecopy(server,name);
}

/************************************************************************************
                           TPathList Implementation
*************************************************************************************/

   TPathList::TPathList()
{
   numServers = 0;
   numPaths   = 0;
}

   TPathList::~TPathList()
{
   TPathNode               * node;

   for (node = (TPathNode *)Head() ; Count() ; node = (TPathNode *)Head() )
   {
      Remove(node);
      delete node;
   }
}
// enumerate the nodes in the list, and display the name of each - used for debugging purposes
void 
   TPathList::Display() const
{
   TPathNode               * node;
   TNodeListEnum             displayenum;

   err.DbgMsgWrite(0,L"%ld servers, %ld total paths\n", numServers, numPaths);
   for ( node = (TPathNode *)displayenum.OpenFirst(this) ;
         node ;
         node = (TPathNode *)displayenum.Next() 
       )
   {
      node->Display();
   }          
   displayenum.Close();
}

void 
   TPathList::OpenEnum()
{
   tenum.Open(this);
}

// Return the name from the next node in the enumeration
// Returns NULL if no more nodes in the list
// OpenEnum() must be called before calling Next();
WCHAR *
   TPathList::Next()
{                             

   TPathNode               * pn = (TPathNode *)tenum.Next();
   LPWSTR                    result;
   if ( pn ) 
      result =  pn->GetPathName();
   else 
      result = NULL;
   return result;
}

void 
   TPathList::CloseEnum()
{                      
   tenum.Close();
}

      
bool                                               // ret -returns true if path added, false if path too long
   TPathList::AddPath(
      const LPWSTR           path,                  // in -path to add to list
      DWORD                  verifyFlags            // in -indicates which types of verification to perform
   )
{
   TPathNode               * pnode;
   bool                      error = false;
   bool                      messageshown = false;
   DWORD                     rc = 0;
   WCHAR                     fullpath[MAX_PATH];
   WCHAR*                    pFullPathBuffer = NULL;

   if ( UStrLen(path) >= MAX_PATH )
   {
      err.MsgWrite(ErrW,DCT_MSG_PATH_TOO_LONG_SD,path,MAX_PATH);
      messageshown = true;
      error = true;
      return error;
   }
   pFullPathBuffer = _wfullpath(fullpath,path,DIM(fullpath));
   if(!pFullPathBuffer)
   {
      err.MsgWrite(ErrW,DCT_MSG_GET_FULL_PATH_FAILED, path);
      messageshown = true;
      error = true;
      return error;
   }

   pnode = new TPathNode(fullpath);
   if (!pnode)
      return true;

   if ( ! ContainsWildcard(pnode->GetServerName()) )
   {
      if ( verifyFlags & VERIFY_EXISTS )
      {
         if ( rc = pnode->VerifyExists() )
         {
            error = true;
         }
      }
      if ( !error && ( verifyFlags & VERIFY_BACKUPRESTORE) )
      {
         if ( rc = pnode->VerifyBackupRestore() )
         {
//            WCHAR             * server = pnode->GetServerName();   
         
         }
      }
      if ( !error && (verifyFlags & VERIFY_PERSISTENT_ACLS ) )
      {
         rc = pnode->VerifyPersistentAcls();
         if ( rc == ERROR_NO_SECURITY_ON_OBJECT  )
         {
            err.MsgWrite(ErrW,DCT_MSG_NO_ACLS_S,fullpath);
            error = true;
            messageshown = true;
         }
      }
   }
   if ( ! error )
   {      
      AddPathToList(pnode);
      numPaths++;                                     // increment count of paths
   }
   else if ( !messageshown )
   {
      // need to include an error code here.
      if ( ! rc )
      {
         err.MsgWrite(ErrE,DCT_MSG_PATH_NOT_FOUND_S,fullpath);
      }
      else
      {
         err.SysMsgWrite(ErrE,rc,DCT_MSG_CANNOT_READ_PATH_SD,fullpath,rc);
      }
	  delete pnode;
   }
   else
	  delete pnode;

   return error;
}

void 
   TPathList::Clear()
{
   TNodeListEnum             tEnum;
   TPathNode               * pNode;
   TPathNode               * pNext;

   for ( pNode = (TPathNode *)tEnum.OpenFirst(this) ; pNode ; pNode = pNext )
   {
      pNext = (TPathNode *)tEnum.Next();
      Remove(pNode);
      delete pNode;
   }
}

void
   TPathList::AddPathToList(
      TPathNode            * pNode           // in - path to add to the list
   )
{
   // set the IsFirstPathFromMachine property
   TNodeListEnum             tEnum;
   TPathNode               * currNode;
   bool                      machineFound = false;
   WCHAR                   * myMachine = GetMachineName(pNode->GetPathName());
   WCHAR                   * currMachine;

   for ( currNode = (TPathNode *)tEnum.OpenFirst(this) 
      ;  currNode && !machineFound 
      ;  currNode = (TPathNode *)tEnum.Next() )
   {
      currMachine = GetMachineName(currNode->GetPathName());
      if ( currMachine && myMachine )
      {  
         if ( !UStrICmp(currMachine,myMachine) )
         {
            machineFound = true;
         }
      }
      else
      {
         if ( !currMachine && ! myMachine )
         {
            machineFound = true;
         }
      }
      
      if ( currMachine )
         delete [] currMachine;
   }
   
   if ( myMachine )
      delete [] myMachine;

   tEnum.Close();
   
   pNode->IsFirstPathFromMachine(!machineFound);

   InsertBottom((TNode *)pNode);
}
   

// AddVolsOnMachine generates a list of volumes on the machine mach, checks for the administrative share 
// for each volume, and adds NTFS shared volumes to the pathlist
 
DWORD 
   TVolumeEnum::Open(
      WCHAR const          * serv,         // in - server to enumerate volumes on
      DWORD                  verifyflgs,    // in - flags indicating what to verify about each volume (i.e. NTFS)
      BOOL                   logmsgs         // in - flag whether to print diagnostic messages
     )
{  
   NET_API_STATUS            res;
   
   if ( isOpen )
      Close();

   if ( serv )
      safecopy(server,serv);
   else
      server[0] = 0;

   resume_handle = 0;
   pbuf = NULL;
   verbose = logmsgs;
   verifyFlags = verifyflgs;

   errmode = SetErrorMode(SEM_FAILCRITICALERRORS);    // set this to prevent message box when
                                                      // called on removable media drives which are empty
   if ( ! bLocalOnly )
   {

      res = NetServerDiskEnum(server,0,&pbuf,MAXSIZE, &numread, &total, &resume_handle);
      if (NERR_Success != res )
      {
         err.SysMsgWrite(ErrW, res, DCT_MSG_DRIVE_ENUM_FAILED_SD,server, res);
         isOpen = FALSE;
      }   
      if ( ! res )  
      {
         drivelist = (WCHAR *) pbuf;                        // NetServerDiskEnum returns an array of
         isOpen = true;                                     // WCHAR[3] elements (of the form <DriveLetter><:><NULL>)
         curr = 0;
      } 
   }
   else
   {
         //first call to determine the size of the buffer we need for drive strings
      DWORD dwSizeNeeded = GetLogicalDriveStrings(0, NULL);
	  if (dwSizeNeeded != 0)
	  {
            //add 1 character to the needed length and allocate the memory
         pbuf = new BYTE[(dwSizeNeeded + 1) * sizeof(TCHAR)];
	     if (!pbuf)
	        return ERROR_NOT_ENOUGH_MEMORY;

            //now get the drive strings
         dwSizeNeeded = GetLogicalDriveStrings(dwSizeNeeded + 1, (WCHAR *)pbuf);
	     if (dwSizeNeeded != 0) //if success, save the drive string
		 {
            drivelist = (WCHAR*)pbuf;
            isOpen = true;
            curr = 0;
            res = 0;
		 }
		 else
		 {
            res = GetLastError();
            err.SysMsgWrite(ErrW,res,DCT_MSG_LOCAL_DRIVE_ENUM_FAILED_D,res);   
		 }
	  }//end if got size needed
	  else
      {
         res = GetLastError();
         err.SysMsgWrite(ErrW,res,DCT_MSG_LOCAL_DRIVE_ENUM_FAILED_D,res);   
      }
   }

   return res;
}

WCHAR * 
   TVolumeEnum::Next()
{
   WCHAR                   * pValue = NULL;
   WCHAR                     ShareName[MAX_PATH];
   WCHAR                     rootsharename[MAX_PATH];    // this will hold "machinename\C$\"
   NET_API_STATUS            res;
   bool                      found = false;

   assert(isOpen);

   while ( ! found )
   {
      if (  ( !bLocalOnly && curr < BUF_ENTRY_LENGTH * numread ) 
         || ( bLocalOnly && drivelist[curr] ) ) 
      {
         if ( verbose ) 
            err.DbgMsgWrite(0,L"%C\n",drivelist[curr]);

         if ( ! bLocalOnly )
         {
            swprintf(ShareName,L"%c$",drivelist[curr]);                                   
            res = NetShareGetInfo(server, ShareName, 1, &shareptr); // is this really necessary?

            switch ( res )
            {
            case NERR_NetNameNotFound:
               if ( verbose ) 
                  err.DbgMsgWrite(0,L"Not Shared\n");
               break;
            case NERR_Success:
               {
                  if ( verbose ) 
                     err.DbgMsgWrite(0,L"Shared\n");
                  NetApiBufferFree(shareptr);
                  shareptr = NULL;
                                                                     // build the complete share name
                  DWORD               mnamelen = UStrLen(server);                
                  WCHAR               append[5] = L"\\C$\\";                          

                  append[1] = drivelist[curr];                               // change the 'C' to the actual drive letter
                  UStrCpy(rootsharename, server, mnamelen+1);
                  UStrCpy(&rootsharename[mnamelen], append, 5);
                  if ( verbose ) 
                     err.DbgMsgWrite(0,L"Share name: %S\n",rootsharename);  
               }
               break;
            default:
               err.MsgWrite(ErrW,DCT_MSG_ADMIN_SHARES_ERROR_SSD,ShareName,server,res);
               break;
            }
         }
         else
         {
            res = GetDriveType(&drivelist[curr]);
            switch ( res )
            {
            case DRIVE_REMOVABLE:
            case DRIVE_FIXED:
               res = 0;
               break;
            case DRIVE_REMOTE:
               err.MsgWrite(0,DCT_MSG_SKIPPING_DRIVE_REMOTE_S, &drivelist[curr]);
               break;
            case DRIVE_CDROM:
               err.MsgWrite(0,DCT_MSG_SKIPPING_DRIVE_CDROM_S, &drivelist[curr]);
               break;
            case DRIVE_RAMDISK:
               err.MsgWrite(0,DCT_MSG_SKIPPING_DRIVE_RAMDISK_S, &drivelist[curr]);
               break;
            case DRIVE_UNKNOWN:
               err.MsgWrite(0,DCT_MSG_SKIPPING_DRIVE_UNKNOWN_S, &drivelist[curr]);
               break;
            case DRIVE_NO_ROOT_DIR:
               err.MsgWrite(0,DCT_MSG_SKIPPING_DRIVE_NO_ROOT_S, &drivelist[curr]);
               break;
            default:
               err.MsgWrite(0,DCT_MSG_SKIPPING_DRIVE_SD, &drivelist[curr],res);
               break;
            }
            UStrCpy(rootsharename,&drivelist[curr]);
            curr++;
         }
         if ( ! res )
         {
            if ( verifyFlags & VERIFY_PERSISTENT_ACLS )
            {
               TPathNode     pnode(rootsharename);
               DWORD rc  = pnode.VerifyPersistentAcls();
               if ( !rc )
               {
                  safecopy(currEntry,rootsharename);
                  pValue = currEntry;
                  found = true;
               }
               else if ( rc == ERROR_NO_SECURITY_ON_OBJECT )
               {
                  err.MsgWrite(0,DCT_MSG_SKIPPING_FAT_VOLUME_S,rootsharename);
               }
               else
               {
                  err.SysMsgWrite(0,rc,DCT_MSG_SKIPPING_PATH_SD,rootsharename,rc);
               }
            }
            else
            {
               safecopy(currEntry,rootsharename);
               pValue = currEntry;
               found = true;
            }
         }
         curr += BUF_ENTRY_LENGTH;
      }
      else
      {
         break; // no more drives left
      }
   }
   
   return pValue;
}

void 
   TVolumeEnum::Close()
{
   if ( pbuf )
   {
      if (! bLocalOnly )
      {
         NetApiBufferFree(pbuf);
      }
      else
      {
         delete [] pbuf;
      }
      pbuf = NULL;
   }
   isOpen = FALSE;
   SetErrorMode(errmode);      // restore error mode to its prior state
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\enumvols.hpp 