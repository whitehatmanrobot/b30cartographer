
            }

            break;
        }

        default:
        {
            break;
        }
    }

    ReturnIrp(pIrp, status);
    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);

    return status;
}


//----------------------------------------------------------------------------
PFILE_FULL_EA_INFORMATION
FindInEA(
    IN PFILE_FULL_EA_INFORMATION    start,
    IN PCHAR                        wanted
    )

/*++

Routine Description:

    This function check for the "Wanted" string in the Ea structure and
    returns a pointer to the extended attribute structure
    representing the given extended attribute name.

Arguments:

    device - ptr to device object for target device
    pIrp    - ptr to I/O request packet

Return Value:

    pointer to the extended attribute structure, or NULL if not found.

--*/

{
    PFILE_FULL_EA_INFORMATION eabuf;

    CTEPagedCode();

    //
    // Bug # 225668: advance eabug ptr by typecasting it to UCHAR
    //
    for (eabuf = start; eabuf; eabuf =  (PFILE_FULL_EA_INFORMATION) ((PUCHAR)eabuf + eabuf->NextEntryOffset))
    {
        if (strncmp(eabuf->EaName,wanted,eabuf->EaNameLength) == 0)
        {
           return eabuf;
        }

        if (eabuf->NextEntryOffset == 0)
        {
            return((PFILE_FULL_EA_INFORMATION) NULL);
        }
    }
    return((PFILE_FULL_EA_INFORMATION) NULL);

} // FindEA



//----------------------------------------------------------------------------
VOID
ReturnIrp(
    IN PIRP     pIrp,
    IN int      status
    )

/*++

Routine Description:

    This function completes an IRP, and arranges for return parameters,
    if any, to be copied.

    Although somewhat a misnomer, this function is named after a similar
    function in the SpiderSTREAMS emulator.

Arguments:

    pIrp     -  pointer to the IRP to complete
    status  -  completion status of the IRP

Return Value:

    number of bytes copied back to the user.

--*/

{
    KIRQL oldlevel;
    CCHAR priboost;

    //
    // pIrp->IoStatus.Information is meaningful only for STATUS_SUCCESS
    //

    // set the Irps cancel routine to null or the system may bugcheck
    // with a bug code of CANCEL_STATE_IN_COMPLETED_IRP
    //
    // refer to IoCancelIrp()  ..\ntos\io\iosubs.c
    //
    IoAcquireCancelSpinLock(&oldlevel);
    IoSetCancelRoutine(pIrp,NULL);
    IoReleaseCancelSpinLock(oldlevel);

    pIrp->IoStatus.Status      = status;

    priboost = (CCHAR) ((status == STATUS_SUCCESS) ?
                        IO_NETWORK_INCREMENT : IO_NO_INCREMENT);

    IoCompleteRequest(pIrp, priboost);

    return;

}
//----------------------------------------------------------------------------
VOID
MakePending(
    IN PIRP     pIrp
    )

/*++

Routine Description:

    This function marks an irp pending and sets the correct status.

Arguments:

    pIrp     -  pointer to the IRP to complete
    status  -  completion status of the IRP

Return Value:


--*/

{
    IoMarkIrpPending(pIrp);
    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

}

#ifdef _NBT_WMI_SOFTWARE_TRACING_
int nbtlog_strnlen(char *p, int n)
{
    int i;

    for (i = 0; (i < n) && *p; i++, p++) {
    }

    return i;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\precomp.h ===
/*
 * stddef.h define offsetof without checking if it is already defined or not.
 * Prevent Windows Event Tracing from including stddef.h again.
 */
#include <stddef.h>

#include "nbtprocs.h"

#include <wmikm.h>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\ntisol.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Ntisol.h

Abstract:


    This file contains the interface between the TDI interface on the top
    of NBT and the OS independent code.  It takes the parameters out of the
    irps and puts in into procedure calls for the OS independent code (which
    is mostly in name.c).


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

Notes:

    The Nbt routines have been modified to include an additional parameter, i.e,
    the transport type. This transport type is used primarily to distinguish the
    NETBIOS over TCP/IP implementation from the Messaging Over TCP/IP implementation.

    The primary difference between the two being that the later uses the NETBT framing
    without the associated NETBIOS name registartion/resolution. It primarily uses
    DNS for name resolution. All the names that are registered for the new transport
    are local names and are not defended on the network.

    The primary usage is in conjuntion with an extended NETBIOS address type defined
    in tdi.h. The NETBIOS name resolution/registration traffic occurs in two phases.
    The first phase contains all the broadcast traffic that ensues during NETBIOS
    name registration. Subsequently the NETBT implementation queries the remote
    adapter status to choose the appropriate called name. This approach results in
    additional traffic for querying the remote adapter status. The new address type
    defined in tdi.h enables the client of netbt to supply the name to be used in
    NETBT session setup. This avoids the network traffic for querying the adapter
    status.

    The original design which has not been fully implemented involved exposing two
    device objects from the NetBt driver -- the NetBt device object which would be
    the full implementation of NETBIOS over TCP/IP and the MoTcp device object which
    would be the implementation of Messaging over TCP/IP. The MoTcp device object
    would use the same port address as NetBt and use the same session setup protocol
    to talk to remote machines running old NetBt drivers and machines running new
    NetBt drivers.

    The transport type variations combined with the address type changes present us
    with four different cases which need to be handled -- the NetBt transport being
    presented with a TDI_ADDRESS_NETBIOS_EX structure, the NetBt transport being
    prsented with a TDI_ADDRESS_NETBIOS structure and the same two cases for the
    MoTcp transport.

--*/

#include "precomp.h"
#include "ntprocs.h"
#include <ipinfo.h>
#include <ntddtcp.h>    // for IOCTL_TCP_SET_INFORMATION_EX
#ifdef RASAUTODIAL
#include <acd.h>
#include <acdapi.h>
#endif // RASAUTODIAL
#include <tcpinfo.h>
#include <tdiinfo.h>

#include "ntisol.tmh"

#if BACK_FILL
#define SESSION_HDR_SIZE   sizeof(tSESSIONHDR)
#endif

NTSTATUS
SendCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


NTSTATUS
NTSendCleanupConnection(
    IN  tCONNECTELE     *pConnEle,
    IN  PVOID           pCompletionRoutine,
    IN  PVOID           Context,
    IN  PIRP            pIrp);

VOID
DpcSendSession(
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    );

NBT_WORK_ITEM_CONTEXT *
FindLmhSvcRequest(
    IN PDEVICE_OBJECT   DeviceContext,
    IN PIRP             pIrp,
    IN tLMHSVC_REQUESTS *pLmhRequest
    );

NTSTATUS
NbtCancelCancelRoutine(
    IN  PIRP            pIrp
    );

#ifdef RASAUTODIAL
extern ACD_DRIVER AcdDriverG;

BOOLEAN
NbtCancelPostConnect(
    IN PIRP pIrp
    );
#endif // RASAUTODIAL

NTSTATUS
NbtQueryGetAddressInfo(
    IN PIO_STACK_LOCATION   pIrpSp,
    OUT PVOID               *ppBuffer,
    OUT ULONG               *pSize
    );

VOID
NbtCancelConnect(
    IN PDEVICE_OBJECT pDeviceContext,
    IN PIRP pIrp
    );

VOID
NbtCancelReceive(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

NTSTATUS
GetIpAddrs(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PIRP                pIrp
    );

typedef struct
{
    struct _DeviceContext       *pDeviceContext;
    PIRP                        pClientIrp;
    PIRP                        pLocalIrp;
    tCONNECTELE                 *pConnEle;
    PTA_NETBT_INTERNAL_ADDRESS  pTransportAddress;
    TDI_CONNECTION_INFORMATION  LocalConnectionInformation;
    BOOLEAN                     ProcessingDone;
    TDI_ADDRESS_NETBIOS_UNICODE_EX  *pUnicodeAddress;   // First Readable buffer in the transport address list
    TDI_ADDRESS_NETBIOS_UNICODE_EX  *pReturnBuffer;     // First writable buffer in the transport address list

    LONG                        CurrIndex, NumberOfAddresses;
    LONG                        TaAddressLength, RemainingAddressLength;
    PUCHAR                      pTaAddress;
} NBT_DELAYED_CONNECT_CONTEXT, *PNBT_DELAYED_CONNECT_CONTEXT;

extern POBJECT_TYPE *IoFileObjectType;

NTSTATUS
InitDelayedNbtProcessConnect(
    IN PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx
    );

HANDLE
NbtOpenParametersRegistry(
    VOID
    );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NTOpenControl)
#pragma CTEMakePageable(PAGE, NTOpenAddr)
#pragma CTEMakePageable(PAGE, NTCloseAddress)
#pragma CTEMakePageable(PAGE, NTOpenConnection)
#pragma CTEMakePageable(PAGE, NTAssocAddress)
#pragma CTEMakePageable(PAGE, NTCloseConnection)
#pragma CTEMakePageable(PAGE, NTSetSharedAccess)
#pragma CTEMakePageable(PAGE, NTCheckSharedAccess)
#pragma CTEMakePageable(PAGE, NTCleanUpConnection)
#pragma CTEMakePageable(PAGE, NTCleanUpAddress)
#pragma CTEMakePageable(PAGE, NTDisAssociateAddress)
#pragma CTEMakePageable(PAGE, NTListen)
#pragma CTEMakePageable(PAGE, DelayedNbtProcessConnect)
#pragma CTEMakePageable(PAGE, InitDelayedNbtProcessConnect)
#pragma CTEMakePageable(PAGE, DispatchIoctls)
#pragma CTEMakePageable(PAGE, NTSendDatagram)
#pragma CTEMakePageable(PAGE, NTSetInformation)
#pragma CTEMakePageable(PAGE, NTSetEventHandler)
#pragma CTEMakePageable(PAGE, NbtOpenParametersRegistry)

//
// Should not be pageable since AFD can call us at raised Irql in case of AcceptEx.
//
// #pragma CTEMakePageable(PAGE, NTQueryInformation)
#endif
//*******************  Pageable Routine Declarations ****************

int check_unicode_string(IN PUNICODE_STRING str);

//----------------------------------------------------------------------------
NTSTATUS
NTOpenControl(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)
/*++
Routine Description:

    This Routine handles opening the control object, which represents the
    driver itself.  For example QueryInformation uses the control object
    as the destination of the Query message.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION          pIrpSp;
    NTSTATUS                    status;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pIrpSp->FileObject->FsContext2 = (PVOID)(NBT_CONTROL_TYPE);

    // return a ptr the control endpoint
    pIrpSp->FileObject->FsContext = (PVOID)pNbtGlobConfig->pControlObj;

    //
    // the following call opens a control object with the transport below since
    // several of the query information calls are passed directly on to the
    // transport below.
    //
    if (!pDeviceContext->pControlFileObject)
    {
        status = NbtTdiOpenControl(pDeviceContext);
    }
    else
        status = STATUS_SUCCESS;


    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
NTOpenAddr(
    IN  tDEVICECONTEXT              *pDeviceContext,
    IN  PIRP                        pIrp,
    IN  PFILE_FULL_EA_INFORMATION   ea)
/*++
Routine Description:

    This Routine handles converting an Open Address Request from an IRP to
    a procedure call so that NbtOpenAddress can be called in an OS independent
    manner.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    TDI_REQUEST                         Request;
    TA_ADDRESS                          *pAddress;
    int                                 j;
    NTSTATUS                            status=STATUS_INVALID_ADDRESS_COMPONENT;
    ULONG                               BufferLength, MinBufferLength;
    TRANSPORT_ADDRESS UNALIGNED         *pTransportAddr; // structure containing counted array of TA_ADDRESS


    CTEPagedCode();

    // make up the Request data structure from the IRP info
    Request.Handle.AddressHandle = NULL;

    //
    // Verify Minimum Buffer length!
    // Bug#: 120683
    //
    BufferLength = ea->EaValueLength;
    if (BufferLength < sizeof(TA_NETBIOS_ADDRESS))
    {
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.NTOpenAddr[1]: ...Rejecting Open Address request -- BufferLength<%d> < Min<%d>\n",
                BufferLength, sizeof(TA_NETBIOS_ADDRESS)));
        NbtTrace(NBT_TRACE_LOCALNAMES, ("Rejecting Open Address request -- BufferLength<%d> < Min<%d>",
                BufferLength, sizeof(TA_NETBIOS_ADDRESS)));
        return (status);
    }
    MinBufferLength = FIELD_OFFSET(TRANSPORT_ADDRESS,Address);  // Set for Address[0]

    pTransportAddr = (PTRANSPORT_ADDRESS)&ea->EaName[ea->EaNameLength+1];
    pAddress = (TA_ADDRESS *) &pTransportAddr->Address[0]; // this includes the address type + the actual address

    //
    // The Transport Address information is packed as follows:
    //  Field:                              Length:
    //  ------                              -------
    //  TAAddressCount                  --> LONG
    //
    //      Address[0].AddressLength    --> USHORT
    //      Address[0].AddressType      --> USHORT
    //      Address[0].Address..        --> Address[0].AddressLength
    //
    //      Address[1].AddressLength    --> USHORT
    //      Address[1].AddressType      --> USHORT
    //      Address[1].Address..        --> Address[1].AddressLength
    //          :
    //


    // loop through the addresses passed in until ONE is successfully used
    // *TODO* do we need this loop or can we just assume the name is at the start of the address buffer...
    // *TODO* does this need to handle multiple names??
    for (j=0; BufferLength >= MinBufferLength && j<pTransportAddr->TAAddressCount ;j++ )
    {
        //
        // do we have enough data to access the "AddressLength" field?
        //
        MinBufferLength += FIELD_OFFSET(TA_ADDRESS,Address);
        if (BufferLength < MinBufferLength) {
            return (status);
        }

        //
        // Now we can safely access AddressLength
        //
        MinBufferLength += pAddress->AddressLength;
        if (BufferLength < MinBufferLength) {
            return (status);
        }

        //
        // We support only 2 address types:
        //
        if (pAddress->AddressType == TDI_ADDRESS_TYPE_NETBIOS &&
                pAddress->AddressLength >= sizeof(TDI_ADDRESS_NETBIOS)) {
            status = STATUS_SUCCESS;
            break;
        } else if (pAddress->AddressType == TDI_ADDRESS_TYPE_NETBIOS_EX &&
                pAddress->AddressLength >= sizeof(TDI_ADDRESS_NETBIOS_EX)) {
            status = STATUS_SUCCESS;
            break;
        }

        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.NTOpenAddr[2]: ...Rejecting Open Address request for AddressType=<%d>\n",
                pAddress->AddressType));

        //
        // Set pAddress to point to the next address
        //
        pAddress = (TA_ADDRESS *) ((PUCHAR)pAddress
                                 + FIELD_OFFSET(TA_ADDRESS,Address)
                                 + pAddress->AddressLength);
    }

    if (status == STATUS_SUCCESS)       // We found a valid address type!
    {
        // call the non-NT specific function to open an address
        status = NbtOpenAddress(&Request,
                                pAddress,
                                pDeviceContext->IpAddress,
                                pDeviceContext,
                                (PVOID)pIrp);
        if (status != STATUS_SUCCESS) {
            NbtTrace(NBT_TRACE_NAMESRV, ("NbtOpenAddress returns %!status!", status));
        }
    }

    return(status);
}
//----------------------------------------------------------------------------
NTSTATUS
NTCloseAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles converting a Close Address Request from an IRP to
    a procedure call so that NbtCloseAddress can be called in an OS independent
    manner.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    TDI_REQUEST                 Request;
    TDI_REQUEST_STATUS          RequestStatus;
    PIO_STACK_LOCATION          pIrpSp;
    NTSTATUS                    status;
    tCLIENTELE                  *pClientEle;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pClientEle = Request.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
    {
        ASSERTMSG ("Nbt.NTCloseAddress: ERROR - Invalid Address Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    status = NbtCloseAddress (&Request, &RequestStatus, pDeviceContext, (PVOID)pIrp);
    NbtTrace(NBT_TRACE_NAMESRV, ("NbtCloseAddress returns %!status! for ClientEle=%p", status, pClientEle));

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NTOpenConnection(
    IN  tDEVICECONTEXT              *pDeviceContext,
    IN  PIRP                        pIrp,
    IN  PFILE_FULL_EA_INFORMATION   ea)

/*++
Routine Description:

    This Routine handles converting an Open Connection Request from an IRP to
    a procedure call so that NbtOpenConnection can be called in an OS independent
    manner.  The connection must be associated with an address before it
    can be used, except for in inbound call where the client returns the
    connection ID in the accept.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    TDI_REQUEST                 Request;
    PIO_STACK_LOCATION          pIrpSp;
    CONNECTION_CONTEXT          ConnectionContext;
    NTSTATUS                    status;
    PFILE_OBJECT                pFileObject;
    ULONG                       BufferLength;
    tCONNECTELE                 *pConnEle;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    // make up the Request data structure from the IRP info
    Request.Handle.ConnectionContext = NULL;

    //
    // Verify Minimum Buffer length!
    // Bug#: 120682
    //
    BufferLength = ea->EaValueLength;
    if (BufferLength < sizeof(CONNECTION_CONTEXT))
    {
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.NTOpenConnection: ERROR -- Open Connection request -- (BufferLength=%d < Min=%d)\n",
                BufferLength, sizeof(CONNECTION_CONTEXT)));
        ASSERT(0);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    // the connection context value is stored in the string just after the
    // name "connectionContext", and it is most likely unaligned, so just
    // copy it out.( 4 bytes of copying ).
    CTEMemCopy(&ConnectionContext,
               (CONNECTION_CONTEXT)&ea->EaName[ea->EaNameLength+1],
               sizeof(CONNECTION_CONTEXT));

    // call the non-NT specific function to open an address
    status = NbtOpenConnection (&Request, ConnectionContext, pDeviceContext);

    pFileObject = pIrpSp->FileObject;

    if (!NT_SUCCESS(status))
    {
        pFileObject->FsContext = NULL;
        NbtTrace(NBT_TRACE_OUTBOUND, ("NbtOpenConnection returns %!status!", status));
    }
    else if (Request.Handle.ConnectionContext)
    {

        // fill the IRP with successful completion information so we can
        // find the connection object given the fileObject later.
        pConnEle = pFileObject->FsContext = Request.Handle.ConnectionContext;
        if (!NBT_VERIFY_HANDLE (pConnEle, NBT_VERIFY_CONNECTION))
        {
            ASSERTMSG ("Nbt.NTOpenConnection: ERROR - Invalid Connection Handle\n", 0);
            return (STATUS_UNSUCCESSFUL);
        }
        pFileObject->FsContext2 = (PVOID)(NBT_CONNECTION_TYPE);
        pConnEle->pClientFileObject = pFileObject;
        NbtTrace(NBT_TRACE_OUTBOUND, ("New connection %p", pConnEle));

        status = STATUS_SUCCESS;
    }

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
NTAssocAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles converting an Associate Address Request from an IRP to
    a procedure call so that NbtAssociateAddress can be called in an OS independent
    manner.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    TDI_REQUEST                   Request;
    PIO_STACK_LOCATION            pIrpSp;
    PFILE_OBJECT                  fileObject;
    PTDI_REQUEST_KERNEL_ASSOCIATE parameters;   // holds address handle
    NTSTATUS                      status;
    tCONNECTELE                   *pConnEle;
    tCLIENTELE                    *pClientEle;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pConnEle = Request.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE (pConnEle, NBT_VERIFY_CONNECTION))
    {
        ASSERTMSG ("Nbt.NTAssocAddress: ERROR - Invalid Connection Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    // the address handle is buried in the Irp...
    parameters = (PTDI_REQUEST_KERNEL_ASSOCIATE)&pIrpSp->Parameters;

    // now get a pointer to the file object, which points to the address
    // element by calling a kernel routine to convert this filehandle into
    // a file pointer.

    status = ObReferenceObjectByHandle (parameters->AddressHandle,
                                        FILE_READ_DATA,
                                        *IoFileObjectType,
                                        pIrp->RequestorMode,
                                        (PVOID *)&fileObject,
                                        NULL);

    IF_DBG(NBT_DEBUG_HANDLES)
        KdPrint (("\t  ++<%x>====><%x>\tNTAssocAddress->ObReferenceObject, Status = <%x>\n", parameters->AddressHandle, fileObject, status));

    if ((NT_SUCCESS(status)) &&
        (fileObject->DeviceObject->DriverObject == NbtConfig.DriverObject) &&   // Bug# 202349
        NBT_VERIFY_HANDLE(((tDEVICECONTEXT*)fileObject->DeviceObject), NBT_VERIFY_DEVCONTEXT) &&  // Bug# 202349
        (PtrToUlong(fileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE))
    {
        pClientEle = fileObject->FsContext;
        if (NBT_VERIFY_HANDLE (pClientEle, NBT_VERIFY_CLIENT))
        {
            // call the non-NT specific function to associate the address with
            // the connection
            status = NbtAssociateAddress (&Request, pClientEle, (PVOID)pIrp);
            NbtTrace(NBT_TRACE_OUTBOUND, ("NbtAssociateAddress returns %!status!", status));
        }
        else
        {
            ASSERTMSG ("Nbt.NTAssocAddress: ERROR - Invalid Address Handle\n", 0);
            status = STATUS_INVALID_HANDLE;
        }

        // we are done with the file object, so release the reference
        ObDereferenceObject((PVOID)fileObject);

        return(status);
    }
    else
    {
        return(STATUS_INVALID_HANDLE);
    }

}

//----------------------------------------------------------------------------
NTSTATUS
NTCloseConnection(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles converting a Close Connection Request from an IRP to
    a procedure call so that NbtCloseConnection can be called in an OS independent
    manner.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    TDI_REQUEST                   Request;
    TDI_REQUEST_STATUS            RequestStatus;
    PIO_STACK_LOCATION            pIrpSp;
    NTSTATUS                      status;
    tCONNECTELE                   *pConnEle;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pConnEle = Request.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NTCloseConnection: ERROR - Invalid Connection Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    status = NbtCloseConnection(
                    &Request,
                    &RequestStatus,
                    pDeviceContext,
                    (PVOID)pIrp);
    NbtTrace(NBT_TRACE_OUTBOUND, ("Close connection %p returns %!status!", pConnEle, status));

    return(status);
}

//----------------------------------------------------------------------------
VOID
NTSetFileObjectContexts(
    IN  PIRP            pIrp,
    IN  PVOID           FsContext,
    IN  PVOID           FsContext2)

/*++
Routine Description:

    This Routine handles fills in two context values in the Irp stack location,
    that has to be done in an OS-dependent manner.  This routine is called
    from NbtOpenAddress() when a name is being registered on the network( i.e.
    as a result of OpenAddress).

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION            pIrpSp;
    PFILE_OBJECT                  pFileObject;

    //
    // fill the IRP with context information so we can
    // find the address object given the fileObject later.
    //
    // This must be done here, rather than after the call to NbtOpenAddress
    // because that call can complete the Irp before it returns.  Soooo,
    // in the complete routine for the Irp, if the completion code is not
    // good, it Nulls these two context values.
    //
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pFileObject = pIrpSp->FileObject;
    pFileObject->FsContext = FsContext;
    pFileObject->FsContext2 =FsContext2;
}


//----------------------------------------------------------------------------
VOID
NTClearFileObjectContext(
    IN  PIRP            pIrp
    )
/*++
Routine Description:

    This Routine clears the context value in the file object when an address
    object is closed.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    none

--*/

{

    PIO_STACK_LOCATION            pIrpSp;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    CHECK_PTR(pIrpSp->FileObject);
    pIrpSp->FileObject->FsContext = NULL;

}

//----------------------------------------------------------------------------
NTSTATUS
NTSetSharedAccess(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  tADDRESSELE     *pAddress)

/*++
Routine Description:

    This Routine handles setting the shared access on the file object.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    PACCESS_STATE       AccessState;
    ULONG               DesiredAccess;
    PIO_STACK_LOCATION  pIrpSp;
    NTSTATUS            status;
    static GENERIC_MAPPING AddressGenericMapping = { READ_CONTROL, READ_CONTROL, READ_CONTROL, READ_CONTROL };

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    if ((pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                (pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE))
    {
        DesiredAccess  = (ULONG)FILE_SHARE_READ;
    }
    else
    {
        DesiredAccess = (ULONG)0;
    }

    IoSetShareAccess (FILE_READ_DATA, DesiredAccess, pIrpSp->FileObject, &pAddress->ShareAccess);

    // assign the security descriptor ( need to to do this with the spinlock
    // released because the descriptor is not mapped.  Assign and CheckAccess
    // are synchronized using a Resource.

    AccessState = pIrpSp->Parameters.Create.SecurityContext->AccessState;
    status = SeAssignSecurity (NULL,           // Parent Descriptor
                               AccessState->SecurityDescriptor,
                               &pAddress->SecurityDescriptor,
                               FALSE,          // is a directory
                               &AccessState->SubjectSecurityContext,
                               &AddressGenericMapping,
                               NonPagedPool);

    if (!NT_SUCCESS(status))
    {
        IoRemoveShareAccess (pIrpSp->FileObject, &pAddress->ShareAccess);
    }

    return status;
}

//----------------------------------------------------------------------------
NTSTATUS
NTCheckSharedAccess(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  tADDRESSELE     *pAddress)

/*++
Routine Description:

    This Routine handles setting the shared access on the file object.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    PACCESS_STATE       AccessState;
    ACCESS_MASK         GrantedAccess;
    BOOLEAN             AccessAllowed;
    ULONG               DesiredAccess;
    PIO_STACK_LOCATION  pIrpSp;
    BOOLEAN             duplicate=FALSE;
    NTSTATUS            status;
    ULONG               DesiredShareAccess;
    static GENERIC_MAPPING AddressGenericMapping =
           { READ_CONTROL, READ_CONTROL, READ_CONTROL, READ_CONTROL };


    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);


    if ((pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                (pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE))
        DesiredAccess  = (ULONG)FILE_SHARE_READ;
    else
        DesiredAccess = (ULONG)0;


    //
    // The address already exists.  Check the ACL and see if we
    // can access it.  If so, simply use this address as our address.
    //

    AccessState = pIrpSp->Parameters.Create.SecurityContext->AccessState;

    status = STATUS_SUCCESS;

    // *TODO* check that this routine is doing the right thing...
    //
    AccessAllowed = SeAccessCheck(
                        pAddress->SecurityDescriptor,
                        &AccessState->SubjectSecurityContext,
                        FALSE,                   // tokens locked
                        pIrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                        (ACCESS_MASK)0,             // previously granted
                        NULL,                    // privileges
                        &AddressGenericMapping,
                        pIrp->RequestorMode,
                        &GrantedAccess,
                        &status);


    // use the status from the IoCheckShareAccess as the return access
    // event if SeAccessCheck fails....

    //
    // Hmmm .... Compare DesiredAccess to GrantedAccess?
    //

    //
    // Now check that we can obtain the desired share
    // access. We use read access to control all access.
    //

    DesiredShareAccess = (ULONG)
        (((pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
          (pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) ?
                FILE_SHARE_READ : 0);

    //ACQUIRE_SPIN_LOCK (&pDeviceContext->SpinLock, &oldirql);

    status = IoCheckShareAccess(
                 FILE_READ_DATA,
                 DesiredAccess,
                 pIrpSp->FileObject,
                 &pAddress->ShareAccess,
                 TRUE);


    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
NTCleanUpAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles the first stage of releasing an address object.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS            status;
    tCLIENTELE          *pClientEle;
    PIO_STACK_LOCATION  pIrpSp;

    CTEPagedCode();

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NTCleanUpAddress: Cleanup Address Hit ***\n"));

    //
    // Disconnect any active connections, and for each connection that is not
    // in use, remove one from the free list to the transport below.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pClientEle = (tCLIENTELE *) pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE (pClientEle, NBT_VERIFY_CLIENT))
    {
        ASSERTMSG ("Nbt.NTCleanUpAddress: ERROR - Invalid Address Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    CTEVerifyHandle(pClientEle,NBT_VERIFY_CLIENT,tCLIENTELE,&status);
    status = NbtCleanUpAddress(pClientEle,pDeviceContext);
    NbtTrace(NBT_TRACE_NAMESRV, ("Cleanup address %p returns %!status!", pClientEle, status));

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NTCleanUpConnection(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles running down a connection in preparation for a close
    that will come in next.  NtClose hits this entry first, and then it hits
    the NTCloseConnection next. If the connection was outbound, then the
    address object must be closed as well as the connection.  This routine
    mainly deals with the pLowerconn connection to the transport whereas
    NbtCloseConnection deals with closing pConnEle, the connection to the client.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS            status;
    PIO_STACK_LOCATION  pIrpSp;
    tCONNECTELE         *pConnEle;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pConnEle = (tCONNECTELE *) pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NTCleanUpConnection: ERROR - Invalid Connection Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    //CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NTCleanUpConnection: Cleanup Connection Hit state= %X\n",pConnEle->state));

    pConnEle->ConnectionCleanedUp = TRUE;
    status = NbtCleanUpConnection(pConnEle,pDeviceContext);
    ASSERT (status != STATUS_PENDING);
    NbtTrace(NBT_TRACE_NAMESRV, ("Cleanup connection %p returns %!status!", pConnEle, status));

    return(status);

}
//----------------------------------------------------------------------------
NTSTATUS
NTAccept(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles passing an accept for an inbound connect indication to
    the OS independent code.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                    status;
    TDI_REQUEST                 TdiRequest;
    PIO_STACK_LOCATION          pIrpSp;
    PTDI_REQUEST_KERNEL_ACCEPT  pRequest;
    tCONNECTELE                 *pConnEle;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NTAccept: ** Got an Accept from the Client **\n"));

    // pull the junk out of the Irp and call the non-OS specific routine.
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    // the Parameters value points to a Request structure...
    pRequest = (PTDI_REQUEST_KERNEL_ACCEPT)&pIrpSp->Parameters;

    // the pConnEle ptr was stored in the FsContext value when the connection
    // was initially created.
    pConnEle = TdiRequest.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NTAccept: ERROR - Invalid Connection Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    status = NbtAccept(
                    &TdiRequest,
                    pRequest->RequestConnectionInformation,
                    pRequest->ReturnConnectionInformation,
                    pIrp);

    return(status);

}


//----------------------------------------------------------------------------
NTSTATUS
NTDisAssociateAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/


{
    NTSTATUS                    status;
    TDI_REQUEST                 TdiRequest;
    PIO_STACK_LOCATION          pIrpSp;
    PTDI_REQUEST_KERNEL_ACCEPT  pRequest;
    tCONNECTELE                 *pConnEle;

    CTEPagedCode();

    // pull the junk out of the Irp and call the non-OS specific routine.
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    // the Parameters value points to a Request structure...
    pRequest = (PTDI_REQUEST_KERNEL_ACCEPT)&pIrpSp->Parameters;

    // the pConnEle ptr was stored in the FsContext value when the connection
    // was initially created.
    pConnEle = TdiRequest.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NTCloseAddress: ERROR - Invalid Address Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    status = NbtDisassociateAddress(&TdiRequest);

    return(status);
}

LONG
NextTransportAddress(
    IN PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx
    )
/*++
    Move the pointer to the next address.
--*/
{
    pDelConnCtx->RemainingAddressLength -= (pDelConnCtx->TaAddressLength + FIELD_OFFSET(TRANSPORT_ADDRESS,Address));
    pDelConnCtx->pTaAddress += pDelConnCtx->TaAddressLength + FIELD_OFFSET(TRANSPORT_ADDRESS,Address);
    RtlCopyMemory(&pDelConnCtx->TaAddressLength,
                (pDelConnCtx->pTaAddress+FIELD_OFFSET(TA_ADDRESS,AddressLength)), sizeof(USHORT));
    pDelConnCtx->CurrIndex++;
    /*
     * make sure we don't overrun the buffer
     */
    if(pDelConnCtx->RemainingAddressLength < (pDelConnCtx->TaAddressLength + FIELD_OFFSET(TRANSPORT_ADDRESS,Address))) {
        KdPrint(("netbt!NextTransportAddress: insufficient TaAddress buffer size\n"));
        pDelConnCtx->CurrIndex = pDelConnCtx->NumberOfAddresses;
    }
    return pDelConnCtx->CurrIndex;
}

NTSTATUS
InitDelayedNbtProcessConnect(
    IN PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx
    )
/*++
    Reset the NBT_DELAYED_CONNECT_CONTEXT
    Find the first readable unicode address and writable buffer. In compound address case, NetBT will first try
    to establish the connection using the first readable unicode address. If this fails, it will attempt to use
    OEM address, ie. only one readable unicode address is effective. If DNS name resolution is used, NetBT will
    return the result in the first writable buffer and update the NameBufferType to NBT_WRITTEN.
--*/
{
    PTDI_REQUEST_KERNEL  pRequestKernel;
    PIO_STACK_LOCATION   pIrpSp;
    PTRANSPORT_ADDRESS   pRemoteAddress;
    PUCHAR               pTaAddress;
    enum eNameBufferType NameBufferType, UnicodeAddressNameBufferType;
    NTSTATUS             status;
    tCONNECTELE          *pConnEle = NULL;

    CTEPagedCode();


    pIrpSp          = IoGetCurrentIrpStackLocation(pDelConnCtx->pClientIrp);
    pRequestKernel  = (PTDI_REQUEST_KERNEL) &pIrpSp->Parameters;
    pRemoteAddress  = pRequestKernel->RequestConnectionInformation->RemoteAddress;

    pDelConnCtx->NumberOfAddresses = pRemoteAddress->TAAddressCount;
    pDelConnCtx->RemainingAddressLength = pRequestKernel->RequestConnectionInformation->RemoteAddressLength;
    pDelConnCtx->pTaAddress       = (PCHAR)&pRemoteAddress->Address[0];
    RtlCopyMemory(&pDelConnCtx->TaAddressLength,
                (pDelConnCtx->pTaAddress+FIELD_OFFSET(TA_ADDRESS,AddressLength)), sizeof(USHORT));
    pDelConnCtx->CurrIndex = 0;

    /*
     * Find the first writable buffer and readable unicode address
     */
    pDelConnCtx->pReturnBuffer = NULL;
    pDelConnCtx->pUnicodeAddress = NULL;
    for (pDelConnCtx->CurrIndex = 0; pDelConnCtx->CurrIndex < pDelConnCtx->NumberOfAddresses; 
                        NextTransportAddress(pDelConnCtx)) {
        USHORT               TaAddressType;
        
        RtlCopyMemory(&TaAddressType, (pDelConnCtx->pTaAddress+FIELD_OFFSET(TA_ADDRESS,AddressType)), sizeof(USHORT));
        if (TaAddressType != TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX) {
            continue;
        }
        RtlCopyMemory(&NameBufferType,
                        pDelConnCtx->pTaAddress +
                        FIELD_OFFSET(TA_ADDRESS,Address)+
                        FIELD_OFFSET(TDI_ADDRESS_NETBIOS_UNICODE_EX,NameBufferType),
                        sizeof(NameBufferType));
        if (NameBufferType != NBT_READONLY && NameBufferType != NBT_WRITEONLY &&
            NameBufferType != NBT_READWRITE && NameBufferType != NBT_WRITTEN) {
            return STATUS_INVALID_ADDRESS;
        }
        if (NameBufferType == NBT_READONLY || NameBufferType == NBT_READWRITE) {
            if (pDelConnCtx->pUnicodeAddress == NULL) {
                pDelConnCtx->pUnicodeAddress = (TDI_ADDRESS_NETBIOS_UNICODE_EX*)
                        (pDelConnCtx->pTaAddress + FIELD_OFFSET(TA_ADDRESS,Address));
                UnicodeAddressNameBufferType = NameBufferType;
            }
        }
        if (NameBufferType == NBT_WRITEONLY) {
            pDelConnCtx->pReturnBuffer = (TDI_ADDRESS_NETBIOS_UNICODE_EX*)
                        (pDelConnCtx->pTaAddress + FIELD_OFFSET(TA_ADDRESS,Address));
            break;
        }
        if (NameBufferType == NBT_READWRITE) {
            pDelConnCtx->pReturnBuffer = (TDI_ADDRESS_NETBIOS_UNICODE_EX*)
                        (pDelConnCtx->pTaAddress + FIELD_OFFSET(TA_ADDRESS,Address));
            /*
             * Only when no WRITEONLY buffer is presented, can we use a READWRITE buffer. So continue searching.
             */
        }
    }
    pDelConnCtx->NumberOfAddresses = pRemoteAddress->TAAddressCount;
    pDelConnCtx->RemainingAddressLength = pRequestKernel->RequestConnectionInformation->RemoteAddressLength;
    pDelConnCtx->pTaAddress       = (PCHAR)&pRemoteAddress->Address[0];
    RtlCopyMemory(&pDelConnCtx->TaAddressLength,
                (pDelConnCtx->pTaAddress+FIELD_OFFSET(TA_ADDRESS,AddressLength)), sizeof(USHORT));
    pDelConnCtx->CurrIndex = 0;

    /*
     * Setup the first local transport address
     */
    if (pDelConnCtx->pUnicodeAddress != NULL) {
        pTaAddress = ((PUCHAR)pDelConnCtx->pUnicodeAddress - FIELD_OFFSET(TA_ADDRESS,Address));
    } else {
        pTaAddress = pDelConnCtx->pTaAddress;
    }
    status = NewInternalAddressFromTransportAddress(
                (PTRANSPORT_ADDRESS) (pTaAddress-FIELD_OFFSET(TRANSPORT_ADDRESS,Address)),
                pDelConnCtx->RemainingAddressLength, &pDelConnCtx->pTransportAddress);

    if (status != STATUS_SUCCESS) {
        ASSERT(pDelConnCtx->pTransportAddress == NULL);
        return status;
    }
    if (pDelConnCtx->pUnicodeAddress == NULL || UnicodeAddressNameBufferType != NBT_READWRITE) {
        pDelConnCtx->pTransportAddress->Address[0].Address[0].pNetbiosUnicodeEX = pDelConnCtx->pReturnBuffer;
    }

    ASSERT(pDelConnCtx->pTransportAddress);

    pConnEle = pIrpSp->FileObject->FsContext;
    if (NULL == pConnEle || !NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN)) {
        return STATUS_INVALID_HANDLE;
    }

    pDelConnCtx->pConnEle = pConnEle;
    NBT_REFERENCE_CONNECTION (pConnEle, REF_CONN_MULTIPLE_CONNECT); // so we don't delete the connection
    return STATUS_SUCCESS;
}

NTSTATUS
NextDelayedNbtProcessConnect(
    IN PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx
    )
/*++
    Move the pointer to the next address.
--*/
{
    USHORT  TaAddressType;
    enum eNameBufferType        NameBufferType;
    PTA_NETBT_INTERNAL_ADDRESS  pTransportAddress = NULL;
    TDI_ADDRESS_NETBT_INTERNAL  *pAddr;
    PIO_STACK_LOCATION          pIrpSp;
    tCONNECTELE                 *pConnEle;
    NTSTATUS                    status;

    pIrpSp   = IoGetCurrentIrpStackLocation(pDelConnCtx->pClientIrp);
    pConnEle = pIrpSp->FileObject->FsContext;
    ASSERT (pConnEle->pIrp == NULL);
    ASSERT(pDelConnCtx->pTransportAddress);
    status = STATUS_SUCCESS;
    while(1) {
        /*
         * Free memory allocated in previous loop
         */
        if (pTransportAddress) {
            DeleteInternalAddress(pTransportAddress);
            pTransportAddress = NULL;
        }

        if (pDelConnCtx->pUnicodeAddress == NULL) {
            NextTransportAddress(pDelConnCtx);
        } else {
            pDelConnCtx->pUnicodeAddress = NULL;
        }
        if (pDelConnCtx->CurrIndex >= pDelConnCtx->NumberOfAddresses) {
            break;
        }

        /*
         * Skip UNICODE address.
         * UNICODE address is always done first, ie. just after InitDelayedNbtProcessConnect gets called.
         */
        RtlCopyMemory(&TaAddressType, (pDelConnCtx->pTaAddress+FIELD_OFFSET(TA_ADDRESS,AddressType)), sizeof(USHORT));
        if (TaAddressType != TDI_ADDRESS_TYPE_NETBIOS && TaAddressType != TDI_ADDRESS_TYPE_NETBIOS_EX) {
            continue;
        }

        /*
         * Since we only do OEM address, we can safely call NewInternalAddressFromTransportAddress (this guy will
         * call Rtl* to convert UNICODE to OEM in UNICODE address case so that we may hit bug check.)
         */
        status = NewInternalAddressFromTransportAddress(
                (PTRANSPORT_ADDRESS) (pDelConnCtx->pTaAddress-FIELD_OFFSET(TRANSPORT_ADDRESS,Address)),
                pDelConnCtx->RemainingAddressLength, &pTransportAddress);
        if (status != STATUS_SUCCESS) {
            ASSERT(pTransportAddress == NULL);
            continue;
        }
        ASSERT(pTransportAddress);
        pAddr = pTransportAddress->Address[0].Address;

        /*
         * Always attach a writable buffer in OEM address case
         */
        pAddr->pNetbiosUnicodeEX = pDelConnCtx->pReturnBuffer;

        /*
         * Skip any address which is same as previous one.
         *    Since the previous one fails, there is no point to use it again.
         */
        if (IsDeviceNetbiosless(pDelConnCtx->pDeviceContext) ||
                (pDelConnCtx->pLocalIrp->IoStatus.Status == STATUS_HOST_UNREACHABLE)) {
            OEM_STRING  RemoteName, PreviouseRemoteName;

            CTEMemCopy (&RemoteName, &pAddr->OEMRemoteName, sizeof(OEM_STRING));
            CTEMemCopy (&PreviouseRemoteName,
                &pDelConnCtx->pTransportAddress->Address[0].Address[0].OEMRemoteName, sizeof(OEM_STRING));
            if ((RemoteName.Length) && (RemoteName.Length == PreviouseRemoteName.Length) &&
                (CTEMemEqu (RemoteName.Buffer, PreviouseRemoteName.Buffer, RemoteName.Length))) {
                IF_DBG(NBT_DEBUG_NETBIOS_EX)
                    KdPrint(("Nbt.DelayedNbtProcessConnect: Irp=<%x>, Names match!<%16.16s:%x>, Types=<%x:%x>\n",
                        pDelConnCtx->pClientIrp, pAddr->OEMRemoteName.Buffer, pAddr->OEMRemoteName.Buffer[15],
                        pAddr->AddressType, pDelConnCtx->pTransportAddress->Address[0].Address[0].AddressType));
                continue;
            }
        }

        if (pConnEle->RemoteNameDoesNotExistInDNS) {
            IF_DBG(NBT_DEBUG_NETBIOS_EX)
                KdPrint(("netbt!DelayedNbtProcessConnect: Skipping address type %lx length %lx\n"
                        "\t\tfor nonexistent name, pIrp %lx, pLocalIrp %lx\n",
                            TaAddressType, pDelConnCtx->TaAddressLength,
                            pDelConnCtx->pClientIrp, pDelConnCtx->pLocalIrp));

            // If the address type is such that we rely on DNS name resolution and
            // if a prior attempt failed, there is no point in reissuing the request.
            // We can fail them without having to go on the NET.
            if (TaAddressType == TDI_ADDRESS_TYPE_NETBIOS_EX) {
                status = STATUS_BAD_NETWORK_PATH;
                continue;
            } else if (pDelConnCtx->TaAddressLength != TDI_ADDRESS_LENGTH_NETBIOS) {
                ASSERT(TaAddressType == TDI_ADDRESS_TYPE_NETBIOS);
                status = STATUS_INVALID_ADDRESS_COMPONENT;
                continue;
            }
        }

        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("netbt!DelayedNbtProcessConnect: Sending local irp=%lx, %lx of %lx\n"
                    "\t\t\t\tTA=%lx Length=%lx\n",
                    pDelConnCtx->pLocalIrp, pDelConnCtx->CurrIndex+1, pDelConnCtx->NumberOfAddresses,
                    pDelConnCtx->pTaAddress, pDelConnCtx->TaAddressLength));

        DeleteInternalAddress(pDelConnCtx->pTransportAddress);
        pDelConnCtx->pTransportAddress = pTransportAddress;
        pTransportAddress = NULL;

        break;
    }
    if (pTransportAddress) {
        DeleteInternalAddress(pTransportAddress);
        pTransportAddress = NULL;
    }
    return status;
}

VOID
DoneDelayedNbtProcessConnect(
    IN PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx,
    NTSTATUS    status
    )
/*++
    1. Complete the client IRP
    2. Cleanup everything
--*/
{
    tCONNECTELE     *pConnEle = NULL;

    ASSERT(pDelConnCtx->pLocalIrp);
    ASSERT(pDelConnCtx->pClientIrp);

    NbtCancelCancelRoutine(pDelConnCtx->pClientIrp);

    pConnEle = pDelConnCtx->pConnEle;
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_MULTIPLE_CONNECT); // so we don't delete the connection

    ASSERT(status != STATUS_PENDING);
    if (pDelConnCtx->pLocalIrp) {
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("netbt!DoneDelayedNbtProcessConnect: Freeing Local Irp=<%x>\n", pDelConnCtx->pLocalIrp));
        IoFreeIrp(pDelConnCtx->pLocalIrp);
    }
    if (pDelConnCtx->pTransportAddress) {
        DeleteInternalAddress(pDelConnCtx->pTransportAddress);
    }

    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint(("netbt!DoneDelayed...: Connect Complete, LocalIrp=<%x>, ClientIrp=<%x>, Status=<%x>\n",
            pDelConnCtx->pLocalIrp, pDelConnCtx->pClientIrp, status));

    NbtTrace(NBT_TRACE_OUTBOUND, ("Complete connection request pIrp=%p pLocalIrp=%p with %!status!",
                            pDelConnCtx->pClientIrp, pDelConnCtx->pLocalIrp, status));
    NTIoComplete (pDelConnCtx->pClientIrp, status, 0);

    pDelConnCtx->pLocalIrp = NULL;
    pDelConnCtx->pClientIrp = NULL;
    pDelConnCtx->pTransportAddress = NULL;

    CTEFreeMem(pDelConnCtx);
}


//----------------------------------------------------------------------------

NTSTATUS
NbtpConnectCompletionRoutine(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    PVOID           pCompletionContext
    )
/*++
Routine Description:

    This Routine is the completion routine for local IRPS that are generated
    to handle compound transport addresses

Arguments:

    pDeviceObject - the device object

    pIrp - a  ptr to an IRP

    pCompletionContext - the completion context

Return Value:

    NTSTATUS - status of the request

--*/

{
    PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx;
    NTSTATUS                        Status, Status2;
    PIRP                            pLocalIrp;
    tDEVICECONTEXT                  *pDeviceContext;

    pDelConnCtx = pCompletionContext;
    pDeviceContext = pDelConnCtx->pDeviceContext;
    pLocalIrp = pDelConnCtx->pLocalIrp;
    ASSERT (pIrp == pLocalIrp);

    Status = pLocalIrp->IoStatus.Status;
    ASSERT(Status != STATUS_PENDING);
 
    NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: %!status! pParentIrp %p",
                    pIrp, Status, pDelConnCtx->pClientIrp));

    pDelConnCtx->ProcessingDone = TRUE;

    /*
     * Let's move to next address
     */
    Status2 = NextDelayedNbtProcessConnect(pDelConnCtx);

    /*
     * Are we done
     */
    if (Status == STATUS_CANCELLED || Status == STATUS_SUCCESS || Status2 != STATUS_SUCCESS ||
            pDelConnCtx->CurrIndex >= pDelConnCtx->NumberOfAddresses) {
        if (Status2 != STATUS_SUCCESS) {
            Status = Status2;
        }
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.NbtpC...:==>Connect Complete, LocalIrp=<%x>, ClientIrp=<%x>, Status=<%x> <==\n",
                pIrp,pDelConnCtx->pClientIrp, Status));

        if (Status == STATUS_HOST_UNREACHABLE) {
            Status = STATUS_BAD_NETWORK_PATH;
        }
        DoneDelayedNbtProcessConnect(pDelConnCtx, Status);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    /*
     * Start worker thread to process the Connect request on the next address
     */
    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint(("NbtpConnectCompletionRoutine: queuing worker item, local irp=%lx, previous status=%lx\n",
                            pIrp, Status));

    if (STATUS_SUCCESS != NTQueueToWorkerThread(NULL, DelayedNbtProcessConnect,
                                                        NULL,
                                                        pDelConnCtx,
                                                        NULL,
                                                        pDeviceContext,
                                                        FALSE))
    {
        KdPrint(("Nbt.NbtpConnectCompletionRoutine: Failed to Enqueue Worker thread\n"));
        DoneDelayedNbtProcessConnect(pDelConnCtx, STATUS_INSUFFICIENT_RESOURCES);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

//----------------------------------------------------------------------------
NTSTATUS
DelayedNbtProcessConnect(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pClientContext,
    IN  PVOID                   pUnused2,
    IN  tDEVICECONTEXT          *pUnused3
    )

/*++
Routine Description:

    This Routine is the worker thread for processing Connect Requests.

Arguments:

    pContext

Return Value:

    NONE

--*/

{
    PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx = NULL;
    PIRP                        pIrp = NULL, pLocalIrp = NULL;
    PIO_STACK_LOCATION          pIrpSp = NULL;
    tCONNECTELE                 *pConnEle = NULL;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PTDI_REQUEST_KERNEL         pRequestKernel = NULL;


    CTEPagedCode();

    pDelConnCtx     = (PNBT_DELAYED_CONNECT_CONTEXT) pClientContext;
    pIrp            = pDelConnCtx->pClientIrp;
    pLocalIrp       = pDelConnCtx->pLocalIrp;

    IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("netbt!DelayedNbtProcessConnect: Enter with local irp=%lx, %lx of %lx\n"
                    "\t\t\t\tTA=%lx Length=%lx\n",
                    pLocalIrp, pDelConnCtx->CurrIndex+1, pDelConnCtx->NumberOfAddresses,
                    pDelConnCtx->pTaAddress, pDelConnCtx->TaAddressLength));

    pConnEle = pDelConnCtx->pConnEle;
    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN)) {
        DbgPrint ("Nbt.DelayedNbtProcessConnect: ERROR - Invalid Connection Handle\n");
        DoneDelayedNbtProcessConnect(pDelConnCtx,
            (pDelConnCtx->ProcessingDone)? pLocalIrp->IoStatus.Status: STATUS_UNSUCCESSFUL);
        return STATUS_UNSUCCESSFUL;
    }
    CHECK_PTR (pConnEle);

    Status = STATUS_UNSUCCESSFUL;

    /*
     * Set the Cancel routine and ensure that the original IRP was not cancelled before continuing.
     */
    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint (("Nbt.DelayedNbtProcessConnect: Setting Cancel=<NbtCancelConnect> for Irp:Device <%x:%x>\n",
            pIrp, pDelConnCtx->pDeviceContext));

    if (STATUS_CANCELLED == NTCheckSetCancelRoutine(pIrp, NbtCancelConnect, pDelConnCtx->pDeviceContext)) {
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.DelayedNbtProcessConnect: Irp <%x> was cancelled\n", pIrp));
        pConnEle->pIrp = NULL;
        DoneDelayedNbtProcessConnect(pDelConnCtx, STATUS_CANCELLED);
        return STATUS_CANCELLED;
    }

    /*
     * InitDelayedNbtProcessConnect/NextDelayedNbtProcessConnect has set up pDelConnCtx->pTransportAddress properly
     */
    ASSERT(pDelConnCtx->pTransportAddress);

    pConnEle->AddressType = pDelConnCtx->pTransportAddress->Address[0].Address[0].AddressType;
    pIrpSp          = IoGetCurrentIrpStackLocation(pIrp);
    pRequestKernel  = (PTDI_REQUEST_KERNEL) &pIrpSp->Parameters;
    pDelConnCtx->LocalConnectionInformation = *(pRequestKernel->RequestConnectionInformation);
    pDelConnCtx->LocalConnectionInformation.RemoteAddress = pDelConnCtx->pTransportAddress;
    pDelConnCtx->LocalConnectionInformation.RemoteAddressLength = pDelConnCtx->pTransportAddress->Address[0].AddressLength;

    //
    // Save the thread info for debugging purposes!
    //
    pLocalIrp->Tail.Overlay.Thread = PsGetCurrentThread();

    TdiBuildConnect (pLocalIrp,
                     &pDelConnCtx->pDeviceContext->DeviceObject,
                     pIrpSp->FileObject,
                     NbtpConnectCompletionRoutine,
                     pDelConnCtx,
                     pRequestKernel->RequestSpecific,
                     &pDelConnCtx->LocalConnectionInformation,
                     pRequestKernel->ReturnConnectionInformation);

    Status = IoCallDriver(&pDelConnCtx->pDeviceContext->DeviceObject,pLocalIrp);

    if (Status != STATUS_PENDING) {
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.DelayedNbtProcessConnect: IoCallDriver returned %lx for irp %lx (%lx)\n",
                Status,pIrp,pLocalIrp));

        // ASSERT(0);
    }
    return STATUS_PENDING;
}

//----------------------------------------------------------------------------
NTSTATUS
NTConnect(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles calling the non OS specific code to open a session
    connection to a destination.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION              pIrpSp;
    PTRANSPORT_ADDRESS              pRemoteAddress;
    PTDI_REQUEST_KERNEL             pRequestKernel;
    PIRP                            pLocalIrp;
    PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx;
    NTSTATUS                        Status;

    pIrpSp          = IoGetCurrentIrpStackLocation(pIrp);
    pRequestKernel  = (PTDI_REQUEST_KERNEL)&pIrpSp->Parameters;

    NbtTrace(NBT_TRACE_OUTBOUND, ("TDI_CONNECT pIrp %p", pIrp));

    try
    {
        pRemoteAddress  = pRequestKernel->RequestConnectionInformation->RemoteAddress;

        if (pRequestKernel->RequestConnectionInformation->RemoteAddressLength < sizeof(TRANSPORT_ADDRESS)) {
            return STATUS_INVALID_ADDRESS_COMPONENT;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        KdPrint (("Nbt.NTConnect: Exception <0x%x> trying to access Connection info\n", GetExceptionCode()));
        return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    if (pIrpSp->CompletionRoutine != NbtpConnectCompletionRoutine) {
        pDelConnCtx = NbtAllocMem(sizeof(NBT_DELAYED_CONNECT_CONTEXT),NBT_TAG('e'));
        if (!pDelConnCtx) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        CTEZeroMemory(pDelConnCtx, sizeof(NBT_DELAYED_CONNECT_CONTEXT));
        pLocalIrp = IoAllocateIrp(pDeviceContext->DeviceObject.StackSize,FALSE);
        if (!pLocalIrp) {
            CTEFreeMem(pDelConnCtx);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        pDelConnCtx->pDeviceContext = pDeviceContext;
        pDelConnCtx->pClientIrp = pIrp;
        pDelConnCtx->pLocalIrp  = pLocalIrp;
        pDelConnCtx->pTransportAddress = NULL;
        pDelConnCtx->ProcessingDone = FALSE;

        Status = InitDelayedNbtProcessConnect(pDelConnCtx);
        if (!NT_SUCCESS(Status)) {
            CTEFreeMem(pDelConnCtx);
            IoFreeIrp(pLocalIrp);
            return Status;
        }
        NbtTrace(NBT_TRACE_OUTBOUND, ("Connection request pIrp=%p pLocalIrp=%p", pIrp, pLocalIrp));

        //return (DelayedNbtProcessConnect (NULL, pDelConnCtx, NULL, NULL));
        DelayedNbtProcessConnect (NULL, pDelConnCtx, NULL, NULL);
        // Ignore the return from DelayedNbtProcessConnect and always return STATUS_PENDING;
        // our client completion routine will take care of completing the IRP
        // Otherwise, we will complete the IRP twice.
        return STATUS_PENDING;
    }
    else
    {
        TDI_REQUEST     Request;
        tCONNECTELE     *pConnEle;

        // call the non-NT specific function to setup the connection
        pConnEle = Request.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
        if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
        {
            ASSERTMSG ("Nbt.NTConnect: ERROR - Invalid Connection Handle\n", 0);
            return (STATUS_INVALID_HANDLE);
        }

        /*
         * A user mode process may send us a faked request with a completion routine
         * equal to NbtpConnectCompletionRoutine.
         * Never let it pass through.
         */
        if (pIrp->RequestorMode != KernelMode) {
            ASSERTMSG ("Nbt.NTConnect: ERROR - Invalid request\n", 0);
            return (STATUS_INVALID_PARAMETER);
        }
        return NbtConnect(&Request,
                          pRequestKernel->RequestSpecific, // Ulong
                          pRequestKernel->RequestConnectionInformation,
                          pIrp);
    }
}


//----------------------------------------------------------------------------
NTSTATUS
NTDisconnect(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles calling the Non OS specific code to disconnect a
    session.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    TDI_REQUEST                   Request;
    PIO_STACK_LOCATION            pIrpSp;
    NTSTATUS                      status;
    PTDI_REQUEST_KERNEL           pRequestKernel;
    tCONNECTELE                   *pConnEle;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pRequestKernel = (PTDI_REQUEST_KERNEL)&pIrpSp->Parameters;

    pConnEle = Request.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NTDisconnect: ERROR - Invalid Connection Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    // call the non-NT specific function to setup the connection
    NbtTrace(NBT_TRACE_DISCONNECT, ("Client Disconnects %!NBTNAME!<%02x>",
                pConnEle->RemoteName, (unsigned char)pConnEle->RemoteName[15]));
    status = NbtDisconnect(
                        &Request,
                        pRequestKernel->RequestSpecific, // Large Integer
                        (ULONG) pRequestKernel->RequestFlags,
                        pRequestKernel->RequestConnectionInformation,
                        pRequestKernel->ReturnConnectionInformation,
                        pIrp
                        );
    NbtTrace(NBT_TRACE_DISCONNECT, ("Client Disconnects status: %!status!", status));

    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
NTListen(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    NTSTATUS                    status;
    TDI_REQUEST                 Request;
    PTDI_REQUEST_KERNEL         pRequestKernel;
    PIO_STACK_LOCATION          pIrpSp;
    tCONNECTELE                 *pConnEle;

    CTEPagedCode();

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NTListen: Got a LISTEN !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pRequestKernel = (PTDI_REQUEST_KERNEL)&pIrpSp->Parameters;

    pConnEle = Request.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        try
        {
            PCHAR                   pName;
            ULONG                   lNameType;
            ULONG                   NameLen;

            // Initialize Request data (may be needed by Vxd)
            Request.RequestNotifyObject = NULL;
            Request.RequestContext = NULL;
            // call the non-NT specific function to setup the connection
            status = NbtListen (&Request,
                                (ULONG) pRequestKernel->RequestFlags, // Ulong
                                pRequestKernel->RequestConnectionInformation,
                                pRequestKernel->ReturnConnectionInformation,
                                pIrp);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
           KdPrint (("Nbt.NTListen: Exception <0x%x> trying to access buffer\n", GetExceptionCode()));
           status = STATUS_INVALID_ADDRESS;
        }
    }
    else
    {
        ASSERTMSG ("Nbt.NTListen: ERROR - Invalid Connection Handle\n", 0);
        status = STATUS_INVALID_HANDLE; // Bug# 202340:  Have to complete Irp here!
    }

    if (status != STATUS_PENDING)
    {
        NTIoComplete(pIrp,status,0);
    }
    return(status);

}
//----------------------------------------------------------------------------
NBT_WORK_ITEM_CONTEXT *
FindLmhSvcRequest(
    IN PDEVICE_OBJECT   DeviceContext,
    IN PIRP             pIrp,
    IN tLMHSVC_REQUESTS *pLmhRequest
    )
/*++

Routine Description:

    This routine handles the cancelling a Query to LmHost, so that the client's
    irp can be returned to the client.  This cancellation is instigated
    by the client (i.e. RDR).

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    NBT_WORK_ITEM_CONTEXT   *Context;
    BOOLEAN                 FoundIt = FALSE;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;

    if (pLmhRequest->ResolvingNow && pLmhRequest->Context)
    {
        // this is the session setup tracker
        //
        Context = (NBT_WORK_ITEM_CONTEXT *) pLmhRequest->Context;
        pTracker = (tDGRAM_SEND_TRACKING *) Context->pClientContext;
        if (pTracker->pClientIrp == pIrp)
        {
            pLmhRequest->Context = NULL;
            FoundIt = TRUE;
        }
    }
    else
    {
        //
        // go through the list of Queued requests to find the correct one
        // and cancel it
        //
        pHead = pEntry = &pLmhRequest->ToResolve;
        while ((pEntry = pEntry->Flink) != pHead)
        {
            Context = CONTAINING_RECORD (pEntry,NBT_WORK_ITEM_CONTEXT,Linkage);

            // this is the session setup tracker
            //
            pTracker = (tDGRAM_SEND_TRACKING *)Context->pClientContext;
            if (pTracker->pClientIrp == pIrp)
            {
                RemoveEntryList(pEntry);
                FoundIt = TRUE;
                break;
            }
        }
    }

    return (FoundIt ? Context : NULL);
}

//----------------------------------------------------------------------------
NTSTATUS
QueryProviderCompletion(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine handles the completion event when the Query Provider
    Information completes.  This routine must decrement the MaxDgramSize
    and max send size by the respective NBT header sizes.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - not used

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PTDI_PROVIDER_INFO   pProvider;
    ULONG                HdrSize;
    ULONG                SubnetAddr;
    ULONG                ThisSubnetAddr;
    PLIST_ENTRY          pHead;
    PLIST_ENTRY          pEntry;
    tDEVICECONTEXT       *pDeviceContext;
    tDEVICECONTEXT       *pDevContext;
    CTELockHandle        OldIrq;

    if (NT_SUCCESS(Irp->IoStatus.Status))
    {
        pDeviceContext = (tDEVICECONTEXT *)DeviceContext;
        pProvider = (PTDI_PROVIDER_INFO)MmGetMdlVirtualAddress(Irp->MdlAddress);

        //
        // Set the correct service flags to indicate what Netbt supports.
        //
        pProvider->ServiceFlags = TDI_SERVICE_MESSAGE_MODE |
                                  TDI_SERVICE_CONNECTION_MODE |
                                  TDI_SERVICE_CONNECTIONLESS_MODE |
                                  TDI_SERVICE_ERROR_FREE_DELIVERY |
                                  TDI_SERVICE_BROADCAST_SUPPORTED |
                                  TDI_SERVICE_MULTICAST_SUPPORTED |
                                  TDI_SERVICE_DELAYED_ACCEPTANCE |
                                  TDI_SERVICE_ROUTE_DIRECTED |
                                  TDI_SERVICE_FORCE_ACCESS_CHECK;

        pProvider->MinimumLookaheadData = 128;

        if (pProvider->MaxSendSize > sizeof(tSESSIONHDR))
        {
            //
            // Nbt has just a two byte + 1 bit session message length, so it
            // can't have a send size larger than 1ffff
            //
            if (pProvider->MaxSendSize > (0x1FFFF + sizeof(tSESSIONHDR)))
            {
                pProvider->MaxSendSize = 0x1FFFF;
            }
            else
            {
                pProvider->MaxSendSize -= sizeof(tSESSIONHDR);
            }
        }
        else
        {
            pProvider->MaxSendSize = 0;
        }

        // subtract the datagram hdr size and the scope size (times 2)
        HdrSize = DGRAM_HDR_SIZE + (NbtConfig.ScopeLength << 1);
        if ((!IsDeviceNetbiosless (pDeviceContext)) &&
            (pProvider->MaxDatagramSize > HdrSize))
        {
            pProvider->MaxDatagramSize -= HdrSize;
            if (pProvider->MaxDatagramSize > MAX_NBT_DGRAM_SIZE)
            {
                pProvider->MaxDatagramSize = MAX_NBT_DGRAM_SIZE;
            }
        }
        else
        {
            pProvider->MaxDatagramSize = 0;
        }

        //
        // We need to hold the JointLock before we traverse
        // the list of Devices
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq);

        //
        // Check if any of the adapters with the same subnet address have
        // the PointtoPoint bit set - and if so set it in the response.
        //
        SubnetAddr = pDeviceContext->IpAddress & pDeviceContext->SubnetMask;
        pEntry = pHead = &NbtConfig.DeviceContexts;
        while ((pEntry = pEntry->Flink) != pHead)
        {
            pDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
            ThisSubnetAddr = pDevContext->IpAddress & pDevContext->SubnetMask;

            if ((SubnetAddr == ThisSubnetAddr) &&
                (pDevContext->IpInterfaceFlags & IP_INTFC_FLAG_P2P))
            {
                pProvider->ServiceFlags |= TDI_SERVICE_POINT_TO_POINT;
                break;
            }
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back into the users buffer.
    //
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
NTQueryInformation(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION                      pIrpSp;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION   Query;
    NTSTATUS                                status = STATUS_UNSUCCESSFUL;
    NTSTATUS                                Locstatus;
    PVOID                                   pBuffer = NULL;
    LONG                                    Size ;
    PTA_NETBIOS_ADDRESS                     BroadcastAddress;
    ULONG                                   AddressLength;
    ULONG                                   BytesCopied = 0;
    PDEVICE_OBJECT                          pDeviceObject;

    //
    // Should not be pageable since AFD can call us at raised Irql in case of AcceptEx.
    //
    // CTEPagedCode();

    if (pDeviceContext == pWinsDeviceContext)
    {
        NTIoComplete(pIrp, STATUS_INVALID_DEVICE_REQUEST, 0);
        return (STATUS_INVALID_DEVICE_REQUEST);
    }

    pIrpSp   = IoGetCurrentIrpStackLocation(pIrp);
    Query = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)&pIrpSp->Parameters;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NTQueryInformation: Query type = %X\n",Query->QueryType));

    switch (Query->QueryType)
    {
        case TDI_QUERY_BROADCAST_ADDRESS:
        {
            // the broadcast address is the netbios name "*0000000..."
            if ((!pIrp->MdlAddress) ||
                (!(BroadcastAddress = (PTA_NETBIOS_ADDRESS)NbtAllocMem(sizeof(TA_NETBIOS_ADDRESS),NBT_TAG('b')))))
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            AddressLength = sizeof(TA_NETBIOS_ADDRESS);

            BroadcastAddress->TAAddressCount = 1;
            BroadcastAddress->Address[0].AddressLength = NETBIOS_NAME_SIZE +
                                                                sizeof(USHORT);
            BroadcastAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
            BroadcastAddress->Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_GROUP;

            // the broadcast address to NetBios is "* 000000...", an * followed
            // by 15 zeroes.
            CTEZeroMemory(BroadcastAddress->Address[0].Address[0].NetbiosName,
                            NETBIOS_NAME_SIZE);
            BroadcastAddress->Address[0].Address[0].NetbiosName[0] = '*';


            status = TdiCopyBufferToMdl (
                            (PVOID)BroadcastAddress,
                            0,
                            AddressLength,
                            pIrp->MdlAddress,
                            0,
                            (PULONG)&pIrp->IoStatus.Information);

            BytesCopied = (ULONG) pIrp->IoStatus.Information;
            CTEMemFree((PVOID)BroadcastAddress);

            break;
        }

        case TDI_QUERY_PROVIDER_INFO:
        {
            //
            // Simply pass the Irp on by to the Transport, and let it
            // fill in the provider info
            //
            if (!pDeviceContext->IpAddress)
            {
                status = STATUS_INVALID_DEVICE_STATE;
                break;
            }

            if (StreamsStack)
            {
                TdiBuildQueryInformation(pIrp,
                                        pDeviceContext->pFileObjects->pDgramDeviceObject,
                                        pDeviceContext->pFileObjects->pDgramFileObject,
                                        QueryProviderCompletion,
                                        NULL,
                                        TDI_QUERY_PROVIDER_INFO,
                                        pIrp->MdlAddress);
            }
            else
            {
                TdiBuildQueryInformation(pIrp,
                                        pDeviceContext->pControlDeviceObject,
                                        pDeviceContext->pControlFileObject,
                                        QueryProviderCompletion,
                                        NULL,
                                        TDI_QUERY_PROVIDER_INFO,
                                        pIrp->MdlAddress);
            }

            CHECK_COMPLETION(pIrp);
            status = IoCallDriver(pDeviceContext->pControlDeviceObject,pIrp);
            //
            // we must return the next drivers ret code back to the IO subsystem
            //
            return(status);
        }

        case TDI_QUERY_ADAPTER_STATUS:
        {
            if (!pIrp->MdlAddress)
            {
                break;
            }

            Size = MmGetMdlByteCount (pIrp->MdlAddress);

            //
            // check if it is a remote or local adapter status
            //
            if (Query->RequestConnectionInformation &&
                Query->RequestConnectionInformation->RemoteAddress)
            {
                PCHAR                   pName;
                ULONG                   lNameType;
                ULONG                   NameLen;
                tDGRAM_SEND_TRACKING    *pTracker;
                TDI_ADDRESS_NETBT_INTERNAL  TdiAddr;

                //
                //
                // in case the call results in a name query on the wire...
                //
                IoMarkIrpPending(pIrp);

                status = STATUS_SUCCESS;
                if (pIrp->RequestorMode != KernelMode) {
                    try
                    {
                        ProbeForRead(Query->RequestConnectionInformation->RemoteAddress,
                                 Query->RequestConnectionInformation->RemoteAddressLength,
                                 sizeof(BYTE));
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        status = STATUS_INVALID_PARAMETER;
                    }
                }
                if (NT_SUCCESS(status) && NT_SUCCESS (status = GetNetBiosNameFromTransportAddress(
                                    (PTRANSPORT_ADDRESS) Query->RequestConnectionInformation->RemoteAddress,
                                    Query->RequestConnectionInformation->RemoteAddressLength, &TdiAddr)))
                {
                    pName = TdiAddr.OEMRemoteName.Buffer;
                    NameLen = TdiAddr.OEMRemoteName.Length;
                    lNameType = TdiAddr.NameType;
                    if ((lNameType == TDI_ADDRESS_NETBIOS_TYPE_UNIQUE) &&
                        (NameLen == NETBIOS_NAME_SIZE) &&
                        (NT_SUCCESS (status = GetTracker(&pTracker, NBT_TRACKER_ADAPTER_STATUS))))
                    {
                        pTracker->ClientContext = pIrp;
                        status = NbtSendNodeStatus (pDeviceContext,
                                                    pName,
                                                    NULL,
                                                    pTracker,
                                                    CopyNodeStatusResponseCompletion);

                        // only complete the irp (below) for failure status's
                        if (status == STATUS_PENDING)
                        {
                            return(status);
                        }

                        //
                        // We cannot have a Success status returned here!
                        //
                        if (status == STATUS_SUCCESS)
                        {
                            ASSERT (0);
                            status = STATUS_UNSUCCESSFUL;
                        }

                        FreeTracker (pTracker, RELINK_TRACKER);
                    }
                    else if (NT_SUCCESS(status))
                    {
                        status = STATUS_INVALID_PARAMETER;  // The NameType or NameLen must be wrong!
                    }
                }

                // the request has been satisfied, so unmark the pending
                // since we will return the irp below
                //
                pIrpSp->Control &= ~SL_PENDING_RETURNED;
            }
            else
            {
                // return an array of netbios names that are registered
                status = NbtQueryAdapterStatus(pDeviceContext,
                                               &pBuffer,
                                               &Size,
                                               NBT_LOCAL);

            }
            break;
        }

        case TDI_QUERY_CONNECTION_INFO:
        {
            tCONNECTELE         *pConnectEle;
            tLOWERCONNECTION    *pLowerConn;
            KIRQL               OldIrq1, OldIrq2;

            // pass to transport to get the current throughput, delay and
            // reliability numbers
            //

            pConnectEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;
            if (!NBT_VERIFY_HANDLE2 (pConnectEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
            {
                ASSERTMSG ("Nbt.NTQueryInformation: ERROR - Invalid Connection Handle\n", 0);
                status =  STATUS_INVALID_HANDLE;
                break;
            }

            CTESpinLock(pConnectEle, OldIrq1);

            pLowerConn = (tLOWERCONNECTION *)pConnectEle->pLowerConnId;
            if (!NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN))
            {
                status = STATUS_CONNECTION_INVALID;
                CTESpinFree(pConnectEle, OldIrq1);
                break;
            }

            CTESpinLock(pLowerConn, OldIrq2);
            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_QUERY_INFO);   // Bug # 212632
            CTESpinFree(pLowerConn, OldIrq2);
            CTESpinFree(pConnectEle, OldIrq1);

            //
            // Simply pass the Irp on by to the Transport, and let it
            // fill in the info
            //
            pDeviceObject = IoGetRelatedDeviceObject( pLowerConn->pFileObject );

            TdiBuildQueryInformation(pIrp,
                                    pDeviceObject,
                                    pLowerConn->pFileObject,
                                    NULL, NULL,
                                    TDI_QUERY_CONNECTION_INFO,
                                    pIrp->MdlAddress);


            status = IoCallDriver(pDeviceObject,pIrp);

            NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_QUERY_INFO, FALSE);
            //
            // we must return the next drivers ret code back to the IO subsystem
            //
            return(status);
        }

        case TDI_QUERY_FIND_NAME:
        {
            //
            //
            // in case the call results in a name query on the wire...
            //
            if (pIrp->MdlAddress)
            {
                //
                // Verify the request address space
                //
                try
                {
                    status = STATUS_INVALID_ADDRESS_COMPONENT;

                    if (pIrp->RequestorMode == KernelMode)
                    {
                        //
                        // Since the TdiBuildQueryInformation macro NULLs out the
                        // RequestConnectionInformation field, we need to dereference
                        // it under Try/Except to ensure that the caller has filled
                        // the fields in properly
                        //
                        PTRANSPORT_ADDRESS  pRemoteAddress=Query->RequestConnectionInformation->RemoteAddress;

                        if ((Query->RequestConnectionInformation->RemoteAddressLength
                                < sizeof(TRANSPORT_ADDRESS)) ||
                            (pRemoteAddress->TAAddressCount < 1) ||
                            (pRemoteAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_NETBIOS))
                        {
                            break;
                        }
                    }
                    else    // User-mode client
                    {
                        ProbeForRead(Query->RequestConnectionInformation->RemoteAddress,
                                     Query->RequestConnectionInformation->RemoteAddressLength,
                                     sizeof(BYTE));
                    }
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    KdPrint (("Nbt.TDI_QUERY_FIND_NAME: Exception <0x%x> during Probe\n",
                        GetExceptionCode()));
                    break;
                }

                IoMarkIrpPending(pIrp);
                status = NbtQueryFindName(Query->RequestConnectionInformation, pDeviceContext, pIrp, FALSE);

                if (status == STATUS_PENDING)
                {
                    return(status);
                }

                // the request has been satisfied, so unmark the pending
                // since we will return the irp below
                //
                pIrpSp->Control &= ~SL_PENDING_RETURNED;
            }

            break;
        }

        case TDI_QUERY_ADDRESS_INFO:
        {
            if (pIrp->MdlAddress)
            {
                status = NbtQueryGetAddressInfo (pIrpSp, &pBuffer, &Size);
            }
            break;
        }

        case TDI_QUERY_SESSION_STATUS:
        default:
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt Query Info NOT SUPPORTED = %X\n",Query->QueryType));
            status = STATUS_NOT_SUPPORTED;
            break;
        }
    }   // switch

    if (!NT_ERROR(status) &&        // allow buffer overflow to pass by
        ((Query->QueryType == TDI_QUERY_ADAPTER_STATUS) ||
        (Query->QueryType == TDI_QUERY_ADDRESS_INFO)))
    {
        status = TdiCopyBufferToMdl (pBuffer, 0, Size, pIrp->MdlAddress, 0, &BytesCopied);
        CTEMemFree((PVOID)pBuffer);
    }
    //
    // either Success or an Error
    // so complete the irp
    //

    NTIoComplete(pIrp,status,BytesCopied);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtQueryGetAddressInfo(
    IN PIO_STACK_LOCATION   pIrpSp,
    OUT PVOID               *ppBuffer,
    OUT ULONG               *pSize
    )
{
    NTSTATUS            status;
    BOOLEAN             IsGroup;
    PLIST_ENTRY         p;
    tADDRESSELE         *pAddressEle;
    tNAMEADDR           *pNameAddr;
    tADDRESS_INFO       *pAddressInfo;
    tCLIENTELE          *pClientEle;
    tCONNECTELE         *pConnectEle;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    PNBT_ADDRESS_PAIR_INFO pAddressPairInfo;

    //
    // We are not sure whether this is a ConnectionContext or a ClientContext!
    //
    pConnectEle = (tCONNECTELE *) pClientEle = pIrpSp->FileObject->FsContext;
    if (NBT_VERIFY_HANDLE2 (pConnectEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        //
        // We crashed here since the pLowerConn was NULL below.
        // Check the state of the connection, since it is possible that the connection
        // was aborted and the disconnect indicated, but this query came in before the client
        // got the disconnect indication.
        // If the state is idle (in case of TDI_DISCONNECT_ABORT) or DISCONNECTED
        // (TDI_DISCONNECT_RELEASE), error out.
        // Also check for NBT_ASSOCIATED.
        //
        // NOTE: If NbtOpenConnection is unable to allocate the lower conn block (say, if the session fileobj
        // has not been created yet), the state will be still be IDLE, so we are covered here.
        //
        CTESpinLock(pConnectEle,OldIrq);

        if (pConnectEle->Verify != NBT_VERIFY_CONNECTION)
        {
            CTESpinFree(pConnectEle,OldIrq);
            return (STATUS_INVALID_HANDLE);
        }
        else if ((pConnectEle->state <= NBT_ASSOCIATED) ||   // includes NBT_IDLE
                 (pConnectEle->state == NBT_DISCONNECTED))
        {
            CTESpinFree(pConnectEle,OldIrq);
            return (STATUS_CONNECTION_DISCONNECTED);
        }

        //
        // A TdiQueryInformation() call requesting TDI_QUERY_ADDRESS_INFO
        // on a connection.  Fill in a TDI_ADDRESS_INFO containing both the
        // NetBIOS address and the IP address of the remote.  Some of the
        // fields are fudged.
        //
        if (pAddressPairInfo = NbtAllocMem(sizeof (NBT_ADDRESS_PAIR_INFO), NBT_TAG('c')))
        {
            memset ( pAddressPairInfo, 0, sizeof(NBT_ADDRESS_PAIR_INFO) );

            pAddressPairInfo->ActivityCount = 1;
            pAddressPairInfo->AddressPair.TAAddressCount = 2;
            pAddressPairInfo->AddressPair.AddressIP.AddressType = TDI_ADDRESS_TYPE_IP;
            pAddressPairInfo->AddressPair.AddressIP.AddressLength = TDI_ADDRESS_LENGTH_IP;
            pAddressPairInfo->AddressPair.AddressNetBIOS.AddressType = TDI_ADDRESS_TYPE_NETBIOS;
            pAddressPairInfo->AddressPair.AddressNetBIOS.AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
            pAddressPairInfo->AddressPair.AddressNetBIOS.Address.NetbiosNameType =
                TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            memcpy( &pAddressPairInfo->AddressPair.AddressNetBIOS.Address.NetbiosName[0],
                    &pConnectEle->RemoteName[0],
                    NETBIOS_NAME_SIZE);

            //
            // Check for NULL (should not be NULL here since we check for states above).
            //
            if (pConnectEle->pLowerConnId)
            {
                pAddressPairInfo->AddressPair.AddressIP.Address.in_addr =
                    pConnectEle->pLowerConnId->SrcIpAddr;

                *ppBuffer = (PVOID)pAddressPairInfo;
                *pSize = sizeof(NBT_ADDRESS_PAIR_INFO);
                status = STATUS_SUCCESS;
            }
            else
            {
                DbgPrint("pLowerConn NULL in pConnEle%lx, state: %lx\n", pConnectEle, pConnectEle->state);
                CTEMemFree ((PVOID)pAddressPairInfo);
                status = STATUS_CONNECTION_DISCONNECTED;
            }
        }
        else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        CTESpinFree(pConnectEle,OldIrq);
    }
    else if (NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
    {
        pAddressInfo = NbtAllocMem(sizeof(tADDRESS_INFO),NBT_TAG('c'));
        if (pAddressInfo)
        {
            //
            // count the clients attached to this address
            // We need to spinlock the address element, which
            // is why this routine is not pageable
            //
            pAddressInfo->ActivityCount = 0;
            pAddressEle = pClientEle->pAddress;

            //
            // The Client can be removed from the AddressEle only under the JointLock,
            // so we need to hold that while counting the Clients on htis address
            //
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            CTESpinLock(pAddressEle,OldIrq1);

            for (p = pAddressEle->ClientHead.Flink; p != &pAddressEle->ClientHead; p = p->Flink)
            {
                ++pAddressInfo->ActivityCount;
            }

            CTESpinFree(pAddressEle,OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            pNameAddr = pAddressEle->pNameAddr;
            IsGroup = (pNameAddr->NameTypeState & NAMETYPE_UNIQUE) ? FALSE : TRUE;
            TdiBuildNetbiosAddress((PUCHAR)pNameAddr->Name, IsGroup, &pAddressInfo->NetbiosAddress);

            *ppBuffer = (PVOID)pAddressInfo;
            *pSize = sizeof(tADDRESS_INFO);
            status = STATUS_SUCCESS;
        }
        else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else    // neither a client nor a connection context!
    {
        ASSERTMSG ("Nbt.NbtQueryGetAddressInfo: ERROR - Invalid Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    return status;
}


//----------------------------------------------------------------------------
NTSTATUS
NbtGetInterfaceInfo(
    IN PIRP pIrp
    )
/*++
Routine Description:

    gets the interface to index mapping info
    for all the interfaces


Arguments:

    Irp          - Pointer to I/O request packet to cancel.
    IrpSp        - pointer to current stack

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{
    NTSTATUS                LocStatus, Status = STATUS_SUCCESS;
    ULONG                   InfoBufferLen, MaxSize, i=0;
    NETBT_INTERFACE_INFO    *pInterfaceInfo;
    KIRQL                   OldIrq;
    PLIST_ENTRY             pEntry,pHead;
    tDEVICECONTEXT          *pDeviceContext;
    PIO_STACK_LOCATION      pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtGetInterfaceInfo: AdapterCount=<%x>\n", NbtConfig.AdapterCount));

    InfoBufferLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    MaxSize = (NbtConfig.AdapterCount+1)*sizeof(NETBT_ADAPTER_INDEX_MAP)+sizeof(ULONG);
    if (MaxSize <= InfoBufferLen)
    {
        if (pInterfaceInfo = NbtAllocMem (MaxSize,NBT_TAG('P')))
        {
            pEntry = pHead = &NbtConfig.DeviceContexts;
            while ((pEntry = pEntry->Flink) != pHead)
            {
                pDeviceContext = CONTAINING_RECORD(pEntry, tDEVICECONTEXT, Linkage);
                CTEMemCopy (&pInterfaceInfo->Adapter[i].Name,
                            pDeviceContext->ExportName.Buffer,
                            pDeviceContext->ExportName.Length);
                pInterfaceInfo->Adapter[i].Name[pDeviceContext->ExportName.Length/2] = 0;
                pInterfaceInfo->Adapter[i].Index = i;
                i++;
            }
            pInterfaceInfo->NumAdapters = i;

            Status = TdiCopyBufferToMdl (pInterfaceInfo,
                                         0,
                                         i*sizeof(NETBT_ADAPTER_INDEX_MAP)+sizeof(ULONG),
                                         pIrp->MdlAddress,
                                         0,
                                         (PULONG)&pIrp->IoStatus.Information);

            CTEMemFree (pInterfaceInfo);
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        //KdPrint(("GetInterfaceInfo Buffer Overflow %x\n", pIrp));
        //pIrp->IoStatus.Information = sizeof(ULONG);
        Status = STATUS_BUFFER_OVERFLOW;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //KdPrint(("GetInterfaceInfo exit status %x\n", Status));
    return Status;
}



//----------------------------------------------------------------------------
NTSTATUS
NbtFlushEntryFromRemoteHashTable(
    tNAME   *pRemoteName
    )
{
    NTSTATUS    status;
    KIRQL       OldIrq;
    tNAMEADDR   *pNameAddr = NULL;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    status = FindInHashTable (NbtConfig.pRemoteHashTbl, pRemoteName->Name, NbtConfig.pScope, &pNameAddr);
    if (NT_SUCCESS (status))
    {
        if (pNameAddr->RefCount <= 1)
        {
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
        }
        else
        {
            status = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        status = STATUS_RESOURCE_NAME_NOT_FOUND;
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return (status);
}


//----------------------------------------------------------------------------
NTSTATUS
SetTcpInfo(
    IN HANDLE       FileHandle,
    IN PVOID        pInfoBuffer,
    IN ULONG        InfoBufferLength
    )
{
    IO_STATUS_BLOCK     IoStatus;
    HANDLE              event;
    BOOLEAN             fAttached = FALSE;
    NTSTATUS            status;

    CTEAttachFsp(&fAttached, REF_FSP_SET_TCP_INFO);

    status = ZwCreateEvent (&event, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE);
    if (NT_SUCCESS(status))
    {
        //
        // Make the actual TDI call
        //
        IoStatus.Status  = STATUS_SUCCESS;
        status = ZwDeviceIoControlFile (FileHandle,
                                        event,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_TCP_SET_INFORMATION_EX,
                                        pInfoBuffer,
                                        InfoBufferLength,
                                        NULL,
                                        0);

        //
        // If the call pended and we were supposed to wait for completion,
        // then wait.
        //
        if (status == STATUS_PENDING)
        {
            status = NtWaitForSingleObject (event, FALSE, NULL);

            ASSERT(status == STATUS_SUCCESS);
        } else if (!NT_SUCCESS(status) && IoStatus.Status == STATUS_SUCCESS) {
            //
            // Set the IoStatus.Status if it hasn't been set so that we could
            // return the correct status below.
            //
            IoStatus.Status = status;
        }

        status = ZwClose (event);
        ASSERT (NT_SUCCESS(status));

        status = IoStatus.Status;
    }

    CTEDetachFsp(fAttached, REF_FSP_SET_TCP_INFO);

    return (status);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtClientSetTcpInfo(
    IN tCONNECTELE  *pConnEle,
    IN PVOID        pInfoBuffer,
    IN ULONG        InfoBufferLength
    )
/*++
Routine Description:

    Sets the Tcp connection information as requested
    by the client

Arguments:

    pConnEle        - NetBT's Connection object
    pInfoBuffer     - pointer to  TCP_REQUEST_SET_INFORMATION_EX structure
    pInfoBufferLength   - length of pInfoBuffer

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{
    NTSTATUS            status;
    tLOWERCONNECTION    *pLowerConn;
    KIRQL               OldIrq1, OldIrq2;

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        return STATUS_INVALID_HANDLE;
    }

    CTESpinLock(pConnEle, OldIrq1);

    if ((!NBT_VERIFY_HANDLE ((pLowerConn = pConnEle->pLowerConnId), NBT_VERIFY_LOWERCONN)) ||
        (pLowerConn->RefCount > 500))                               // if queued for WipeOutLowerConn
    {
        CTESpinFree(pConnEle, OldIrq1);
        return STATUS_BAD_NETWORK_PATH;
    }

    CTESpinLock(pLowerConn, OldIrq2);

    //
    // We have verified that the lower connection is up -- reference it
    // so that the FileObject does not get Dereferenced by some disconnect
    // from the transport
    //
    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_SET_TCP_INFO);

    CTESpinFree(pLowerConn, OldIrq2);
    CTESpinFree(pConnEle, OldIrq1);

    status = SetTcpInfo (pLowerConn->FileHandle, pInfoBuffer, InfoBufferLength);

    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_SET_TCP_INFO, FALSE);

    return (status);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtSetTcpInfo(
    IN HANDLE       FileHandle,
    IN ULONG        ToiId,
    IN ULONG        ToiType,
    IN ULONG        InfoBufferValue
    )
{
    NTSTATUS                        Status;
    ULONG                           BufferLength;
    TCP_REQUEST_SET_INFORMATION_EX  *pTcpInfo;
    TCPSocketOption                 *pSockOption;

    BufferLength = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(TCPSocketOption);
    if (!(pTcpInfo = (TCP_REQUEST_SET_INFORMATION_EX *) NbtAllocMem (BufferLength,NBT_TAG2('22'))))
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    CTEZeroMemory(pTcpInfo, BufferLength);
    pSockOption = (TCPSocketOption *) (&pTcpInfo->Buffer[0]);

    pTcpInfo->ID.toi_entity.tei_entity  = CO_TL_ENTITY;
    pTcpInfo->ID.toi_class              = INFO_CLASS_PROTOCOL;
    pTcpInfo->BufferSize                = sizeof (TCPSocketOption);

    //
    // Set the Configured values
    //
    pTcpInfo->ID.toi_id                 = ToiId;
    pTcpInfo->ID.toi_type               = ToiType;
    pSockOption->tso_value              = InfoBufferValue;

    Status = SetTcpInfo (FileHandle, pTcpInfo, BufferLength);
    if (!NT_SUCCESS(Status))
    {
        KdPrint (("Nbt.NbtSetTcpInfo: SetTcpInfo FAILed <%x>, Id=<0x%x>, Type=<0x%x>, Value=<%x>\n",
            Status, ToiId, ToiType, InfoBufferValue));
    }

    CTEMemFree (pTcpInfo);

    return (Status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtSetSmbBindingInfo2(
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  NETBT_SMB_BIND_REQUEST  *pSmbRequest
    )
{
    ULONG                   i, Operation;
    PLIST_ENTRY             pEntry,pHead;
    KIRQL                   OldIrq;
    ULONG                   NumBindings = 0;
    CTEULONGLONG            AddedAdapterMask = 0;
    CTEULONGLONG            DeletedAdapterMask = 0;
    CTEULONGLONG            BindListAdapterMask = 0;
    CTEULONGLONG            OriginalMask;
    tDEVICECONTEXT          *pDeviceContextBind = NULL;
    NTSTATUS LocNtStatus = STATUS_SUCCESS;

    if (!IsDeviceNetbiosless (pDeviceContext)) {
        return (STATUS_UNSUCCESSFUL);
    }

    if (NULL == pSmbRequest) {
        return STATUS_INVALID_PARAMETER;
    }

    if (pSmbRequest->RequestType == SMB_SERVER) {
        OriginalMask = NbtConfig.ServerMask;
    } else if (pSmbRequest->RequestType == SMB_CLIENT) {
        OriginalMask = NbtConfig.ClientMask;
    } else {
        ASSERT(0);
        return STATUS_INVALID_PARAMETER;
    }
    if (pSmbRequest->MultiSZBindList)
    {
        NTSTATUS    status;
        tDEVICES    *pBindings = NULL;
        ULONG       MaxBindings;

        MaxBindings = NBT_MAXIMUM_BINDINGS;
        while (MaxBindings < 5000) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            MaxBindings *= 2;
            pBindings = NbtAllocMem ((sizeof(tDEVICES)+MaxBindings*sizeof(UNICODE_STRING)), NBT_TAG2('26'));
            if (pBindings == NULL) {
                break;
            }
            NumBindings = 0;
            status = NbtParseMultiSzEntries (pSmbRequest->MultiSZBindList, (PVOID)(-1), MaxBindings, pBindings, &NumBindings);

            if (status != STATUS_BUFFER_OVERFLOW) {
                break;
            }

            CTEMemFree (pBindings);
            pBindings = NULL;
        }

        if (status != STATUS_SUCCESS) {
            if (pBindings) {        // NbtParseMultiSzEntries can return failure other than STATUS_BUFFER_OVERFLOW
                CTEMemFree (pBindings);
            }
            KdPrint(("Nbt.NbtSetSmbBindingInfo[STATUS_INSUFFICIENT_RESOURCES]: MaxBindings = <%d>\n",
                MaxBindings));
            return status;
        }
        ASSERT(pBindings);

        //
        // First, get the complete list of all bindings
        //
        for (i=0; i<NumBindings; i++)
        {
            if (pDeviceContextBind = NbtFindAndReferenceDevice (&pBindings->Names[i], FALSE))
            {
                BindListAdapterMask |= pDeviceContextBind->AdapterMask;
                NBT_DEREFERENCE_DEVICE (pDeviceContextBind, REF_DEV_FIND_REF, FALSE);
            }
        }

        CTEMemFree (pBindings);
    }
    else if (pSmbRequest->pDeviceName)
    {
        KdPrint (("Nbt.NbtSetSmbBindingInfo[WARNING]: NULL MultiSZBindList string!\n"));
        BindListAdapterMask = OriginalMask;

        if (pDeviceContextBind = NbtFindAndReferenceDevice (pSmbRequest->pDeviceName, FALSE))
        {
            switch (pSmbRequest->PnPOpCode)
            {
                case (TDI_PNP_OP_ADD):
                {
                    BindListAdapterMask |= pDeviceContextBind->AdapterMask;

                    break;
                }

                case (TDI_PNP_OP_DEL):
                {
                    BindListAdapterMask &= (~pDeviceContextBind->AdapterMask);
                    break;
                }

                default:
                {
                    break;
                }
            }

            NBT_DEREFERENCE_DEVICE (pDeviceContextBind, REF_DEV_FIND_REF, FALSE);
        }
        else
        {
            return (STATUS_SUCCESS);
        }
    }
    else
    {
        ASSERTMSG ("Nbt.NbtSetSmbBindingInfo[ERROE]: NULL MultiSZBindList and NULL pDeviceName!\n", 0);
        return (STATUS_UNSUCCESSFUL);
    }

    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint (("Nbt.NbtSetSmbBindingInfo: PnPOpCode=<%x>, Bindings=<%d>, BindMask=[%lx:%lx]==>[%lx:%lx]\n",
            pSmbRequest->PnPOpCode, NumBindings, OriginalMask, BindListAdapterMask));

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    // NetBT used to incrementally add interface to tcpip.
    // However, for some reason, the list in tcpip and netbt
    // may be different. To increase the reliability, I
    // remove the incrementally adding.
    //
    //      AddedAdapterMask = BindListAdapterMask & (~OriginalMask)
    AddedAdapterMask = BindListAdapterMask;                     // Always add device
    DeletedAdapterMask = OriginalMask & (~BindListAdapterMask); // Devices Removed

    if ((!AddedAdapterMask) && (!DeletedAdapterMask))
    {
        //
        // If there are no adapters to be added or deleted, just return
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return (STATUS_SUCCESS);
    }

    if (pSmbRequest->RequestType == SMB_SERVER) {
        NbtConfig.ServerMask = BindListAdapterMask;
    } else if (pSmbRequest->RequestType == SMB_CLIENT) {
        NbtConfig.ClientMask = BindListAdapterMask;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return STATUS_SUCCESS;
    } else {
        ASSERT(0);
    }

    pEntry = pHead = &NbtConfig.DeviceContexts;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pDeviceContextBind = CONTAINING_RECORD(pEntry, tDEVICECONTEXT, Linkage);
        if (pDeviceContext->IPInterfaceContext == (ULONG)-1)    // For Cluster devices, etc
        {
            continue;
        }

        ASSERT(0 == (AddedAdapterMask & DeletedAdapterMask));
        if (AddedAdapterMask & pDeviceContextBind->AdapterMask)
        {
            AddedAdapterMask &= ~(pDeviceContextBind->AdapterMask);
            Operation = AO_OPTION_ADD_IFLIST;
        }
        else if (DeletedAdapterMask & pDeviceContextBind->AdapterMask)
        {
            DeletedAdapterMask &= ~(pDeviceContextBind->AdapterMask);
            Operation = AO_OPTION_DEL_IFLIST;
        }
        else
        {
            continue;
        }

        NBT_REFERENCE_DEVICE (pDeviceContextBind, REF_DEV_FIND_REF, TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("Nbt.NbtSetSmbBindingInfo:  %sing Device=%wZ\n",
                (Operation == AO_OPTION_ADD_IFLIST ? "ADD" : "REMOV"), &pDeviceContextBind->BindName));

        //
        // Set the Session port info
        //
        if (pDeviceContext->hSession)
        {
            LocNtStatus = NbtSetTcpInfo (pDeviceContext->hSession,
                           Operation,
                           INFO_TYPE_ADDRESS_OBJECT,
                           pDeviceContextBind->IPInterfaceContext);
            if (!NT_SUCCESS(LocNtStatus)) {
                NbtConfig.ServerMask &= ~(pDeviceContextBind->AdapterMask);
            }
        }

        //
        // Now, set the same for the Datagram port
        //
        if ((pDeviceContext->pFileObjects) &&
            (pDeviceContext->pFileObjects->hDgram))
        {
            NbtSetTcpInfo (pDeviceContext->pFileObjects->hDgram,
                            Operation,
                           INFO_TYPE_ADDRESS_OBJECT,
                           pDeviceContextBind->IPInterfaceContext);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        NBT_DEREFERENCE_DEVICE (pDeviceContextBind, REF_DEV_FIND_REF, TRUE);

        //
        // Set to restart from the beginning
        //
        pEntry = &NbtConfig.DeviceContexts;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return STATUS_SUCCESS;
}


//----------------------------------------------------------------------------
NTSTATUS
NbtSetSmbBindingInfo(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
{
    NETBT_SMB_BIND_REQUEST  *pSmbRequest = (PNETBT_SMB_BIND_REQUEST)pIrp->AssociatedIrp.SystemBuffer;
    PWSTR                   pBindListCache = NULL;
    PWSTR                   pBindList = NULL;
    PWSTR                   pOldBindList   = NULL;
    PWSTR                   *pTarget   = NULL;
    ULONG                   uInputLength = 0;
    ULONG                   uLength = 0;
    NTSTATUS                status = STATUS_SUCCESS;
    tDEVICECONTEXT *pSavedSmbDevice = NULL;
    KIRQL OldIrq = 0;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (pNbtSmbDevice && !gbDestroyingSmbDevice) {
        pSavedSmbDevice = pNbtSmbDevice;
        NBT_REFERENCE_DEVICE (pSavedSmbDevice, REF_DEV_SMB_BIND, TRUE);
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (NULL == pSavedSmbDevice) {
        status = STATUS_DEVICE_BUSY;
        goto error;
    }

    uInputLength = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (!(IsDeviceNetbiosless (pDeviceContext)) ||
        (!pSmbRequest) ||
        (uInputLength < sizeof(NETBT_SMB_BIND_REQUEST)))
    {
        KdPrint(("Nbt.NbtSetSmbBindingInfo: ERROR: pSmbRequest=<%p>, pDevice=<%p>\n",
            pSmbRequest, pDeviceContext));

        status = STATUS_UNSUCCESSFUL;
        goto error;
    }

    if (pIrp->RequestorMode != KernelMode) {
        status = STATUS_ACCESS_DENIED;
        goto error;
    }

    status = NbtSetSmbBindingInfo2 (pDeviceContext, pSmbRequest);

    if (NT_SUCCESS(status) && pSmbRequest->MultiSZBindList) {

        //
        // Cache the binding info
        //

        pBindList = pSmbRequest->MultiSZBindList;
        uInputLength = 0;
        while (*pBindList) {
            uLength = wcslen (pBindList) + 1;
            uInputLength += uLength;
            pBindList += uLength;
        }
        uInputLength++;
        uInputLength *= sizeof(WCHAR);
        pBindList = pSmbRequest->MultiSZBindList;

        if (pSmbRequest->RequestType == SMB_SERVER) {
            pTarget = &NbtConfig.pServerBindings;
        } else if (pSmbRequest->RequestType == SMB_CLIENT) {
            pTarget = &NbtConfig.pClientBindings;
        } else {
            ASSERT(0);
        }

        pBindListCache = NbtAllocMem (uInputLength, NBT_TAG2('27'));
        if (NULL != pBindListCache) {

            RtlCopyMemory (pBindListCache, pBindList, uInputLength);
            pOldBindList = InterlockedExchangePointer (pTarget, pBindListCache);

            //
            // Free the old copy if any
            //
            if (NULL != pOldBindList) {
                CTEFreeMem (pOldBindList);
                pOldBindList = NULL;
            }

        }
    }

error:
    if (pSavedSmbDevice) {
        NBT_DEREFERENCE_DEVICE (pSavedSmbDevice, REF_DEV_SMB_BIND, FALSE);
    }
    return status;
}


NTSTATUS
NbtEnableNetbiosSmb(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    if (pNbtSmbDevice) {
        goto error;
    }

    pNbtSmbDevice = NbtCreateSmbDevice();
    if (NULL == pNbtSmbDevice) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error;
    }
    NbtConfig.SMBDeviceEnabled = TRUE;
    if (AddressCount > 0) {
        NbtNotifyTdiClients (pNbtSmbDevice, NBT_TDI_REGISTER);
    }

error:
    return status;
}

VOID
NbtSleep(
    ULONG TimeToSleep
    )
{
    KEVENT NeverTriggered = { 0 };
    NTSTATUS status = STATUS_SUCCESS;
    LARGE_INTEGER liTimeOut = { 0 };

    liTimeOut.QuadPart = UInt32x32To64(TimeToSleep, 10000UL);
    liTimeOut.QuadPart = -liTimeOut.QuadPart;

    KeInitializeEvent(&NeverTriggered, NotificationEvent, FALSE);
    status = KeWaitForSingleObject(
                    &NeverTriggered,
                    Executive,
                    KernelMode,
                    FALSE,
                    &liTimeOut
                    );
    ASSERT (status == STATUS_TIMEOUT);
}

NTSTATUS
NbtDisableNetbiosSmb(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL OldIrq = 0;
    tDEVICECONTEXT *pSavedSmbDevice = NULL;
    int i = 0;

    if (NULL == pNbtSmbDevice) {
        goto error;
    }

    //
    // Prevent the pNbtSmbDevice from being used 
    //
    // NetBT could access the pNbtSmbDevice in 2 scenarios:
    // 1. referenced, but without holding the JointLock.
    // 2. No reference but with JointLock held.
    //
    gbDestroyingSmbDevice = TRUE;

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Wait for the refcount to become 1 for at most 8 second
    //
    for(i = 0; i < 8 && (*(volatile*)(&pNbtSmbDevice->RefCount) != 1); i++) {
        NbtSleep(1000);
    }
    if (*(volatile*)(&pNbtSmbDevice->RefCount) != 1) {
        gbDestroyingSmbDevice = FALSE;
        status = STATUS_DEVICE_BUSY;
        goto error;
    }

    //
    // From now on, we're sure that scenario 1 couldn't
    // happen any more.
    //

    //
    // Set pNbtSmbDevice to NULL.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    pSavedSmbDevice = pNbtSmbDevice;
    pNbtSmbDevice = NULL;
    NbtConfig.SMBDeviceEnabled = FALSE;
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //
    // From now on, we're sure that scenario 2 couldn't
    // happen any more.
    //

    NbtNotifyTdiClients (pSavedSmbDevice, NBT_TDI_DEREGISTER);
    status = NbtDestroyDevice (pSavedSmbDevice, TRUE);

    KdPrint(("NbtDisableSmbDevice -- status=<%x>\n", status));

    status = STATUS_SUCCESS;
    gbDestroyingSmbDevice = FALSE;

error:
    return status;
}

HANDLE
NbtOpenParametersRegistry(
    VOID
    )
{
    HANDLE NbtConfigHandle = NULL;
    HANDLE ParametersHandle = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES TmpObjectAttributes = { 0 };
    ULONG Disposition = 0;
    extern NTSTATUS NbtOpenRegistry(
                IN HANDLE       NbConfigHandle,
                IN PWSTR        String,
                OUT PHANDLE     pHandle
                );

    CTEPagedCode();

    InitializeObjectAttributes (&TmpObjectAttributes,
                                &NbtConfig.pRegistry,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL
                                );
    status = ZwCreateKey (&NbtConfigHandle,
                          KEY_READ,
                          &TmpObjectAttributes,
                          0,
                          NULL,
                          0,
                          &Disposition
                          );

    if (!NT_SUCCESS(status)) {
        goto error;
    }

    status = NbtOpenRegistry (NbtConfigHandle, L"Parameters", &ParametersHandle);
    ZwClose(NbtConfigHandle);

error:
    return ParametersHandle;
}

NTSTATUS
NbtEnableDisableNetbiosSmb(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PDWORD pdwEnableSmb = (PDWORD)(pIrp->AssociatedIrp.SystemBuffer);
    DWORD dwSMBDeviceEnabled = TRUE;
    HANDLE hParm = NULL;

    if (InterlockedIncrement(&gdwPendingEnableDisableSmbDevice) > 1) {
        status = STATUS_DEVICE_BUSY;
        goto error;
    }

    if (pIrp->RequestorMode != KernelMode) {
        status = STATUS_ACCESS_DENIED;
        goto error;
    }

    if (pDeviceContext == pNbtSmbDevice || KeGetCurrentIrql() != PASSIVE_LEVEL) {
        status = STATUS_INVALID_PARAMETER;
        goto error;
    }
    
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(DWORD)) {
        status = STATUS_INVALID_PARAMETER;
        goto error;
    }

    switch (*pdwEnableSmb) {
    case NETBT_ENABLE_NETBIOS_SMB:
        dwSMBDeviceEnabled = TRUE;
        KdPrint(("Enable NetbiosSmb\n"));
        NbtTrace(NBT_TRACE_PNP, ("Enable NetbiosSmb"));
        break;

    case NETBT_DISABLE_NETBIOS_SMB:
        dwSMBDeviceEnabled = FALSE;
        KdPrint(("Disable NetbiosSmb\n"));
        NbtTrace(NBT_TRACE_PNP, ("Disable NetbiosSmb"));
        break;

    case NETBT_RESTORE_NETBIOS_SMB:
        KdPrint(("Restore NetbiosSmb\n"));
        NbtTrace(NBT_TRACE_PNP, ("Restore NetbiosSmb"));
        hParm = NbtOpenParametersRegistry();
        if (hParm == NULL) {
            status = STATUS_UNSUCCESSFUL;
            goto error;
        }

        dwSMBDeviceEnabled = CTEReadSingleIntParameter(hParm,
                                               WS_SMB_DEVICE_ENABLED,
                                               1,   // Enabled by default
                                               0);
        ZwClose(hParm);
        hParm = NULL;
        break;

    default:
        status = STATUS_INVALID_PARAMETER;
        goto error;
    }

    if (dwSMBDeviceEnabled) {
        status = NbtEnableNetbiosSmb(pDeviceContext, pIrp, pIrpSp);
        KdPrint(("NbtEanbleNetbiosSmb return 0x%08lx\n", status));
        NbtTrace(NBT_TRACE_PNP, ("NbtEnableNetbiosSmb return %!status!", status));
    } else {
        status = NbtDisableNetbiosSmb(pDeviceContext, pIrp, pIrpSp);
        KdPrint(("NbtDisableNetbiosSmb return 0x%08lx\n", status));
        NbtTrace(NBT_TRACE_PNP, ("NbtDisableNetbiosSmb return %!status!", status));
    }

error:
    InterlockedDecrement(&gdwPendingEnableDisableSmbDevice);
    return status;
}


//----------------------------------------------------------------------------
NTSTATUS
DispatchIoctls(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++
Routine Description:

    This Routine handles calling the OS independent routine depending on
    the Ioctl passed in.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                                status=STATUS_UNSUCCESSFUL;
    ULONG                                   ControlCode;
    ULONG                                   Size;
    PVOID                                   pBuffer;

    ControlCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

    NbtTrace(NBT_TRACE_IOCTL, ("pDeviceContext %p: pIrp %p, IOCTL 0x%08x function %d %Z",
                        pDeviceContext,
                        pIrp,
                        ControlCode,
                        (ControlCode >> 2) & 0xfff,
                        &pDeviceContext->BindName));

    switch (ControlCode)
    {
    case IOCTL_NETBT_REREAD_REGISTRY:
        {
            //
            // This function can be called from either IOCTL or PnP path.
            // IOCTL path can be called from non-admin, which can be potentially
            // exploited.
            // Therefore pass FALSE to tell the NTReReadRegistry not to do
            // name refreshing.
            //
            status = NTReReadRegistry(pDeviceContext, FALSE);
            break;
        }

    case IOCTL_NETBT_ENABLE_EXTENDED_ADDR:
        {
            //
            // Enable extended addressing - pass up IP addrs on Datagram Recvs.
            //
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (pIrp);
            tCLIENTELE  *pClientEle = (tCLIENTELE *)pIrpSp->FileObject->FsContext;

            if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
            {
                //
                // To make the stresser (devctl.exe) happy.  [JRuan 12/18/2000]
                //
                // ASSERTMSG ("Nbt.DispatchIoctls: ERROR - Invalid Address Handle\n", 0);
                status = STATUS_INVALID_HANDLE;
            }
            else if (pIrpSp->FileObject->FsContext2 != (PVOID)NBT_ADDRESS_TYPE)
            {
                status = STATUS_INVALID_ADDRESS;
            }
            else
            {
                pClientEle->ExtendedAddress = TRUE;
                status = STATUS_SUCCESS;
            }

            break;
        }

    case IOCTL_NETBT_DISABLE_EXTENDED_ADDR:
        {
            //
            // Disable extended addressing - dont pass up IP addrs on Datagram Recvs.
            //
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (pIrp);
            tCLIENTELE  *pClientEle = (tCLIENTELE *)pIrpSp->FileObject->FsContext;

            if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
            {
//                ASSERTMSG ("Nbt.DispatchIoctls: ERROR - Invalid Address Handle\n", 0);
                status = STATUS_INVALID_HANDLE;
            }
            else if (pIrpSp->FileObject->FsContext2 != (PVOID)NBT_ADDRESS_TYPE)
            {
                status = STATUS_INVALID_ADDRESS;
            }
            else
            {
                pClientEle->ExtendedAddress = FALSE;
                status = STATUS_SUCCESS;
            }

            break;
        }

    case IOCTL_NETBT_GET_WINS_ADDR:
        {
            if ((pIrp->MdlAddress) &&
                ((Size = MmGetMdlByteCount (pIrp->MdlAddress)) >= sizeof(tWINS_ADDRESSES)) &&
                (pBuffer = (PVOID) MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority)))
            {
                status = STATUS_SUCCESS;
                if (Size >= sizeof(tWINS_NODE_INFO))
                {
                    tWINS_NODE_INFO UNALIGNED *pWinsBuffer = (tWINS_NODE_INFO *) pBuffer;

                    CTEMemCopy (&pWinsBuffer->AllNameServers,
                                pDeviceContext->lAllNameServers,
                                (sizeof(tIPADDRESS)*(2+MAX_NUM_OTHER_NAME_SERVERS)));

                    pWinsBuffer->NumOtherServers = pDeviceContext->lNumOtherServers;
                    pWinsBuffer->LastResponsive = pDeviceContext->lLastResponsive;
                    pWinsBuffer->NetbiosEnabled = pDeviceContext->NetbiosEnabled;
                    pWinsBuffer->NodeType = NodeType;
                    pIrp->IoStatus.Information = sizeof(tWINS_NODE_INFO);
                }
                else
                {
                    tWINS_ADDRESSES UNALIGNED *pWinsBuffer = (tWINS_ADDRESSES *) pBuffer;

                    pWinsBuffer->PrimaryWinsServer = pDeviceContext->lNameServerAddress;
                    pWinsBuffer->BackupWinsServer = pDeviceContext->lBackupServer;
                    pIrp->IoStatus.Information = sizeof(tWINS_ADDRESSES);
                }
            }

            break;
        }

    case IOCTL_NETBT_GET_IP_ADDRS:
        {
            status = GetIpAddrs (pDeviceContext, pIrp);
            break;
        }

    case IOCTL_NETBT_GET_IP_SUBNET:
        {
            ULONG           Length;
            PULONG          pIpAddr;

            //
            // return this devicecontext's ip address and all the other
            // ip addrs after it.
            //
            if (pIrp->MdlAddress)
            {
                Length = MmGetMdlByteCount( pIrp->MdlAddress );
                if (Length < 2*sizeof(ULONG))
                {
                    status = STATUS_BUFFER_OVERFLOW;
                }
                else if (pIpAddr = (PULONG )MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority))
                {
                    //
                    // Put this adapter first in the list
                    //
                    *((tIPADDRESS UNALIGNED *) pIpAddr) = pDeviceContext->AssignedIpAddress;
                    pIpAddr++;
                    *((tIPADDRESS UNALIGNED *) pIpAddr) = pDeviceContext->SubnetMask;
                    pIpAddr++;
                    if (Length >= 3*sizeof(ULONG))
                    {
                        *((tIPADDRESS UNALIGNED *) pIpAddr) = pDeviceContext->DeviceType;
                    }

                    status = STATUS_SUCCESS;
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            break;
        }

    //
    // The following Ioctl is used mainly by the Server service
    //
    case IOCTL_NETBT_SET_TCP_CONNECTION_INFO:
        {
            status = NbtClientSetTcpInfo ((tCONNECTELE *) pIrpSp->FileObject->FsContext,
                                          pIrp->AssociatedIrp.SystemBuffer,
                                          pIrpSp->Parameters.DeviceIoControl.InputBufferLength);
            break;
        }

    //
    // The following Ioctls are used mainly by NbtStat.exe for diagnostic purposes
    //
    case IOCTL_NETBT_GET_INTERFACE_INFO:
        {
            status = NbtGetInterfaceInfo (pIrp);
            break;
        }

    case IOCTL_NETBT_PURGE_CACHE:
        {
            DelayedNbtResyncRemoteCache (NULL, NULL, NULL, NULL);
            status = STATUS_SUCCESS;
            break;
        }

    case IOCTL_NETBT_GET_CONNECTIONS:
        {
            if (pIrp->MdlAddress)
            {
                Size = MmGetMdlByteCount( pIrp->MdlAddress ) ;

                // return an array of netbios names that are registered
                status = NbtQueryConnectionList (pDeviceContext, &pBuffer, &Size);
            }
            break;
        }

    case IOCTL_NETBT_ADAPTER_STATUS:
        {
            if (pIrp->MdlAddress)
            {
                PIO_STACK_LOCATION      pIrpSp;
                tIPANDNAMEINFO         *pIpAndNameInfo;
                PCHAR                   pName;
                ULONG                   lNameType;
                ULONG                   NameLen;
                ULONG                   IpAddrsList[2];
                tIPADDRESS              *pIpAddrs = NULL;
                tDGRAM_SEND_TRACKING    *pTracker;

                //
                // in case the call results in a name query on the wire...
                //
                IoMarkIrpPending(pIrp);

                pIrpSp   = IoGetCurrentIrpStackLocation(pIrp);
                pIpAndNameInfo = pIrp->AssociatedIrp.SystemBuffer;
                NameLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength
                            - FIELD_OFFSET(tIPANDNAMEINFO,NetbiosAddress);

                //
                // Bug# 125288+120947:  Make sure the data passed in + the Address type are good
                //
                if ((pIpAndNameInfo) &&
                    (pIrpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(tIPANDNAMEINFO)))
                {
                    TDI_ADDRESS_NETBT_INTERNAL  TdiAddr;
                    // this routine gets a ptr to the netbios name out of the wierd
                    // TDI address syntax.
                    status = GetNetBiosNameFromTransportAddress(
                                            (PTRANSPORT_ADDRESS) &pIpAndNameInfo->NetbiosAddress,
                                            NameLen, &TdiAddr);
                    pName = TdiAddr.OEMRemoteName.Buffer;
                    NameLen = TdiAddr.OEMRemoteName.Length;
                    lNameType = TdiAddr.NameType;
                }

                if (NT_SUCCESS(status) &&
                     (lNameType == TDI_ADDRESS_NETBIOS_TYPE_UNIQUE) &&
                     (NameLen == NETBIOS_NAME_SIZE))
                {
                    //
                    // Nbtstat sends down * in the first byte on Nbtstat -A <IP address>
                    // Make sure we let that case go ahead.
                    //
                    if (!pDeviceContext->NetbiosEnabled) {
                        status = STATUS_INVALID_DEVICE_STATE;
                    }
                    else if ((pName[0] == '*') && (pIpAndNameInfo->IpAddress == 0))
                    {
                        status = STATUS_BAD_NETWORK_PATH;
                    }
                    else if (NT_SUCCESS (status = GetTracker(&pTracker, NBT_TRACKER_ADAPTER_STATUS)))
                    {
                        if (pIpAndNameInfo->IpAddress)
                        {
                            IpAddrsList[0] = pIpAndNameInfo->IpAddress;
                            IpAddrsList[1] = 0;
                            pIpAddrs = IpAddrsList;
                        }

                        pTracker->ClientContext = pIrp;
                        status = NbtSendNodeStatus(pDeviceContext,
                                                   pName,
                                                   pIpAddrs,
                                                   pTracker,
                                                   CopyNodeStatusResponseCompletion);

                        // only complete the irp (below) for failure status's
                        if (status == STATUS_PENDING)
                        {
                            return(status);
                        }

                        //
                        // We cannot have a Success status returned here!
                        //
                        if (status == STATUS_SUCCESS)
                        {
                            ASSERT (0);
                            status = STATUS_UNSUCCESSFUL;
                        }

                        FreeTracker (pTracker, RELINK_TRACKER);
                    }
                }
                else if (NT_SUCCESS(status))
                {
                    status = STATUS_INVALID_PARAMETER;  // The NameType or NameLen must be wrong!
                }

                // the request has been satisfied, so unmark the pending
                // since we will return the irp below
                //
                pIrpSp->Control &= ~SL_PENDING_RETURNED;

            }

            break;
        }

    case IOCTL_NETBT_GET_REMOTE_NAMES:
        {
            if (pIrp->MdlAddress)
            {
               Size = MmGetMdlByteCount( pIrp->MdlAddress ) ;

               // return an array of netbios names that are registered
               status = NbtQueryAdapterStatus(pDeviceContext, &pBuffer, &Size, NBT_REMOTE);
            }
            break;
        }

    case IOCTL_NETBT_GET_BCAST_NAMES:
        {
            if (pIrp->MdlAddress)
            {
                Size = MmGetMdlByteCount( pIrp->MdlAddress ) ;

                // return an array of netbios names that are registered
                status = NbtQueryBcastVsWins(pDeviceContext,&pBuffer,&Size);
            }
            break;
        }

    case IOCTL_NETBT_NAME_RELEASE_REFRESH:
        {
            status = ReRegisterLocalNames (NULL, TRUE);
            break;
        }

    //
    // The following Ioctls are used by the Cluster code
    //
    case IOCTL_NETBT_ADD_INTERFACE:
        {
            //
            // Creates a dummy devicecontext which can be primed by the layer above
            // with a DHCP address. This is to support multiple IP addresses per adapter
            // for the Clusters group; but can be used by any module that needs support
            // for more than one IP address per adapter. This private interface hides the
            // devices thus created from the setup/regisrty and that is fine since the
            // component (say, the clusters client) takes the responsibility for ensuring
            // that the server (above us) comes to know of this new device.
            //
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (pIrp);
            pBuffer = pIrp->AssociatedIrp.SystemBuffer;
            Size = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

            //
            // return the export string created.
            //
            status = NbtAddNewInterface(pIrp, pBuffer, Size);

            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.DispatchIoctls: ADD_INTERFACE -- status=<%x>\n", status));

            NTIoComplete(pIrp,status,(ULONG)-1);
            return status;
        }

    case IOCTL_NETBT_DELETE_INTERFACE:
        {
            //
            // Dereference this device for the Reference taken in the
            // Dispatch routine so that the cleanup can proceed properly
            //
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            if (pDeviceContext->DeviceType == NBT_DEVICE_CLUSTER)
            {
                //
                // Delete the device this came down on..
                //
                status = NbtDestroyDevice (pDeviceContext, TRUE);
            }
            else
            {
                KdPrint(("Nbt.DispatchIoctls: ERROR: DELETE_INTERFACE <%x>, pDevice=<%p>\n",
                    status, pDeviceContext));
            }
            break;
        }

    case IOCTL_NETBT_QUERY_INTERFACE_INSTANCE:
        {
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (pIrp);

            //
            // Validate input/output buffer size
            //
            Size = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            if (Size < sizeof(NETBT_ADD_DEL_IF))
            {
                // IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.DispatchIoctls:  QUERY_INTERFACE_INSTANCE: Output buffer too small\n"));
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                PNETBT_ADD_DEL_IF   pAddDelIf = (PNETBT_ADD_DEL_IF)pIrp->AssociatedIrp.SystemBuffer;
                status = STATUS_SUCCESS;

                ASSERT(pDeviceContext->DeviceType == NBT_DEVICE_CLUSTER);
                pAddDelIf->InstanceNumber = pDeviceContext->InstanceNumber;
                pAddDelIf->Status = status;
                pIrp->IoStatus.Information = sizeof(NETBT_ADD_DEL_IF);

                NTIoComplete(pIrp,status,(ULONG)-1);
                return status;
            }

            break;
        }

    case IOCTL_NETBT_NEW_IPADDRESS:
        {
            tNEW_IP_ADDRESS *pNewAddress = (tNEW_IP_ADDRESS *)pIrp->AssociatedIrp.SystemBuffer;

            status = STATUS_UNSUCCESSFUL;
            //
            // Bug# 202320:  Make sure the data passed in is valid
            //
            if ((pDeviceContext->DeviceType == NBT_DEVICE_CLUSTER) &&
                (pNewAddress) &&
                (pIrpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(tNEW_IP_ADDRESS)))
            {
                KdPrint (("Nbt.DispatchIoctls: Calling NbtNewDhcpAddress on ClusterDevice <%x>!\n",
                    pDeviceContext));

                pDeviceContext->AssignedIpAddress = ntohl (pNewAddress->IpAddress);
                status = NbtNewDhcpAddress (pDeviceContext, pNewAddress->IpAddress, pNewAddress->SubnetMask);
                ASSERT (pDeviceContext->AssignedIpAddress == pDeviceContext->IpAddress);

                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.DispatchIoctls: NEW_IPADDRESS, status=<%x>, IP=<%x>, pDevice=<%p>\n",
                        status, pNewAddress->IpAddress, pDeviceContext));
            }
            else
            {
                KdPrint(("Nbt.DispatchIoctls: ERROR: NEW_IPADDRESS status=<%x>, pDevice=<%p>\n",
                    status, pDeviceContext));
            }

            break;
        }

    case IOCTL_NETBT_SET_WINS_ADDRESS:
        {
            //
            // Sets the WINS addresses for a dynamic adapter
            //
            PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

            //
            // Validate input/output buffer size
            //
            Size = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
            if (Size < sizeof(NETBT_SET_WINS_ADDR))
            {
                // IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("NbtSetWinsAddr: Input buffer too small for struct\n"));
                status = STATUS_INVALID_PARAMETER;
            }
            else if (pDeviceContext->DeviceType == NBT_DEVICE_CLUSTER)
            {
                PNETBT_SET_WINS_ADDR   pSetWinsAddr = (PNETBT_SET_WINS_ADDR)pIrp->AssociatedIrp.SystemBuffer;
                status = STATUS_SUCCESS;

                pDeviceContext->lNameServerAddress = pSetWinsAddr->PrimaryWinsAddr;
                pDeviceContext->lBackupServer = pSetWinsAddr->SecondaryWinsAddr;
                pDeviceContext->SwitchedToBackup = 0;
                pDeviceContext->RefreshToBackup = 0;

                pSetWinsAddr->Status = status;
                pIrp->IoStatus.Information = 0;     // We are not copying any data to the Output buffers

                NTIoComplete (pIrp,status,(ULONG)-1);
                return status;
            }
            else
            {
                KdPrint(("Nbt.DispatchIoctls: ERROR: SET_WINS_ADDRESS <%x>, pDevice=<%p>\n",
                    status, pDeviceContext));
            }

            break;
        }

    //
    // The following Ioctls are used by the LmHost Services Dll (lmhSvc.dll) to
    // help NetBT ping addresses in user space or resolve names in Dns
    //
    case IOCTL_NETBT_DNS_NAME_RESOLVE:
        {
            if (pIrp->MdlAddress)
            {
                Size = MmGetMdlByteCount( pIrp->MdlAddress ) ;

                if (Size < sizeof (tIPADDR_BUFFER_DNS))
                {
                    // IF_DBG(NBT_DEBUG_PNP_POWER)
                        KdPrint(("Nbt.DnsNameResolve: Input buffer size=<%d> < tIPADDR_BUFFER_DNS=<%d>\n",
                            Size,  sizeof (tIPADDR_BUFFER_DNS)));
                    status = STATUS_INVALID_PARAMETER;
                }
                else if (pBuffer = MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, NormalPagePriority))
                {
                    // return an array of netbios names that are registered
                    status = NtProcessLmHSvcIrp (pDeviceContext,pBuffer,Size,pIrp,NBT_RESOLVE_WITH_DNS);
                    return(status);
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            break;
        }

    case IOCTL_NETBT_CHECK_IP_ADDR:
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Ioctl Value is %X (IOCTL_NETBT_CHECK_IP_ADDR)\n",ControlCode));

            if (pIrp->MdlAddress)
            {
                Size = MmGetMdlByteCount( pIrp->MdlAddress ) ;
                if (Size < sizeof (tIPADDR_BUFFER_DNS))
                {
                    // IF_DBG(NBT_DEBUG_PNP_POWER)
                        KdPrint(("Nbt.CheckIpAddr: Input buffer size=<%d> < tIPADDR_BUFFER_DNS=<%d>\n",
                            Size,  sizeof (tIPADDR_BUFFER_DNS)));
                    status = STATUS_INVALID_PARAMETER;
                }
                else if (pBuffer = MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, NormalPagePriority))
                {

                    // return an array of netbios names that are registered
                    status = NtProcessLmHSvcIrp (pDeviceContext,pBuffer,Size,pIrp,NBT_PING_IP_ADDRS);
                    return(status);
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            break;
        }

    //
    // The following Ioctl is used by the DNS resolver to resolve names through Wins/Bcast
    //
    case IOCTL_NETBT_FIND_NAME:
        {
            tIPADDR_BUFFER   *pIpAddrBuffer;
            PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

            //
            // in case the call results in a name query on the wire...
            //
            IoMarkIrpPending(pIrp);

            //
            // Bug# 120957:  Make sure the data passed in + the Address type are good
            // Bug# 234627:  Verify non-NULL MdlAddress ptr
            //
            pIpAddrBuffer = pIrp->AssociatedIrp.SystemBuffer;
            if ((pIrp->MdlAddress) &&   // to copy the data back!
                (pIpAddrBuffer) &&
                (pIrpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(tIPADDR_BUFFER)))
            {
                status = NbtQueryFindName((PTDI_CONNECTION_INFORMATION)pIpAddrBuffer,
                                      pDeviceContext,
                                      pIrp,
                                      TRUE);
            }

            if (status == STATUS_PENDING)
            {
                return(status);
            }

            // the request has been satisfied, so unmark the pending
            // since we will return the irp below
            //
            pIrpSp->Control &= ~SL_PENDING_RETURNED;

            break;
        }

    //
    // The following Ioctls are used by the Wins server
    //
    case IOCTL_NETBT_WINS_RCV:
        {
            tWINS_INFO      *pWins = pIrpSp->FileObject->FsContext;

            if ((pDeviceContext == pWinsDeviceContext) &&
                (NBT_VERIFY_HANDLE (pWins, NBT_VERIFY_WINS_ACTIVE)))
            {
                if (pIrp->MdlAddress)
                {
                    status = RcvIrpFromWins(pIrp);
                    return(status);
                }
            }
            else
            {
                status = STATUS_INVALID_HANDLE;
            }

            break;
        }

    case IOCTL_NETBT_WINS_SEND:
        {
            tWINS_INFO      *pWins = pIrpSp->FileObject->FsContext;
            BOOLEAN         MustSend;

            if ((pDeviceContext == pWinsDeviceContext) &&
                (NBT_VERIFY_HANDLE (pWins, NBT_VERIFY_WINS_ACTIVE)))
            {
                if ((pIrp->MdlAddress) && !(IsListEmpty(&NbtConfig.DeviceContexts)))
                {
                    status = WinsSendDatagram (pDeviceContext,pIrp,(MustSend = FALSE));
                    return(status);
                }
            }
            else
            {
                status = STATUS_INVALID_HANDLE;
            }

            break;
        }

    case IOCTL_NETBT_WINS_SET_INFO:
        {
            tWINS_INFO      *pWins = pIrpSp->FileObject->FsContext;
            tWINS_SET_INFO  *pWinsSetInfo = (tWINS_SET_INFO *) pIrp->AssociatedIrp.SystemBuffer;

            if ((pDeviceContext == pWinsDeviceContext) &&
                (NBT_VERIFY_HANDLE (pWins, NBT_VERIFY_WINS_ACTIVE)))
            {
                //
                // Validate input/output buffer size
                //
                Size = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
                if (Size >= sizeof(tWINS_SET_INFO))
                {
                    status = WinsSetInformation (pWins, pWinsSetInfo);
                }
                else
                {
                    IF_DBG(NBT_DEBUG_WINS)
                        KdPrint(("Nbt.DispatchIoctls[IOCTL_NETBT_WINS_SET_INFO]: Input buffer too small\n"));
                    status = STATUS_INVALID_PARAMETER;
                }
            }
            else
            {
                status = STATUS_INVALID_HANDLE;
            }

            break;
        }

    //
    // The following Ioctl is used by the Remote boot code
    //
    case IOCTL_NETBT_ADD_TO_REMOTE_TABLE:
        {
            tREMOTE_CACHE  *pRemoteEntry = (tREMOTE_CACHE *) pIrp->AssociatedIrp.SystemBuffer;
            PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

            //
            // Validate input/output buffer size
            //
            Size = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

            if (Size >= sizeof(tREMOTE_CACHE)) {
                //
                // We need only the name, IpAddress, name_flags, and Ttl fields
                //
                status = NbtAddEntryToRemoteHashTable (pDeviceContext,
                                                       NAME_RESOLVED_BY_CLIENT,
                                                       pRemoteEntry->name,
                                                       pRemoteEntry->IpAddress,
                                                       pRemoteEntry->Ttl,
                                                       pRemoteEntry->name_flags);
            }
            else
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.DispatchIoctls[IOCTL_NETBT_ADD_TO_REMOTE_TABLE]: Input buffer too small for struct\n"));
                status = STATUS_BUFFER_TOO_SMALL;
            }

            break;
        }

    //
    // The following Ioctl is used by DsGetDcName
    //
    case IOCTL_NETBT_REMOVE_FROM_REMOTE_TABLE:
        {
            tNAME               *pRemoteName = (tNAME *) pIrp->AssociatedIrp.SystemBuffer;
            PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

            //
            // Validate input/output buffer size
            //
            Size = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
            if (Size >= sizeof(tNAME))
            {
                //
                // We need only the name
                //
                status = NbtFlushEntryFromRemoteHashTable (pRemoteName);
            }
            else
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.DispatchIoctls[IOCTL_NETBT_REMOVE_FROM_REMOTE_TABLE]: Input buffer too small\n"));
                status = STATUS_INVALID_PARAMETER;
            }

            break;
        }

    //
    // The following Ioctl is used by the Rdr/Srv to add/remove addresses from the SmbDevice
    //
    case IOCTL_NETBT_SET_SMBDEVICE_BIND_INFO:
        {
            ASSERT (NULL == pNbtSmbDevice || pDeviceContext == pNbtSmbDevice);

            status = NbtSetSmbBindingInfo (pDeviceContext, pIrp, pIrpSp);

            break;
        }

    case IOCTL_NETBT_ENABLE_DISABLE_NETBIOS_SMB:

        //
        // Private API for the new smb driver (smb.sys)
        //
        status = NbtEnableDisableNetbiosSmb(pDeviceContext, pIrp, pIrpSp);
        break;

    default:
        {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }   // switch

    NbtTrace(NBT_TRACE_IOCTL, ("pDeviceContext %p: pIrp %p %!status!",
                        pDeviceContext,
                        pIrp,
                        status
                        ));

    //
    // copy the reponse to the client's Mdl
    //
    if (!NT_ERROR(status) &&        // allow buffer overflow to pass by
        ((ControlCode == IOCTL_NETBT_GET_REMOTE_NAMES) ||
        (ControlCode == IOCTL_NETBT_GET_BCAST_NAMES) ||
        (ControlCode == IOCTL_NETBT_GET_CONNECTIONS)) )
    {
        status = TdiCopyBufferToMdl (pBuffer, 0, Size, pIrp->MdlAddress, 0,
                                     (PULONG) &pIrp->IoStatus.Information);

        CTEMemFree((PVOID)pBuffer);
    }

    //
    // either Success or an Error
    // so complete the irp
    //
    NTIoComplete(pIrp,status,0);
    return(status);
}


//----------------------------------------------------------------------------

NTSTATUS
GetIpAddrs(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PIRP                pIrp
    )

/*++

Routine Description:

This routine performs the IOCTL_GET_IP_ADDRS function.

It is in its own routine because it is non paged.

Arguments:

    pDeviceContext -
    pIrp -

Return Value:

    NTSTATUS -

--*/

{
    ULONG           Length;
    PULONG          pIpAddr;
    PLIST_ENTRY     pEntry,pHead;
    tDEVICECONTEXT  *pDevContext;
    KIRQL           OldIrq;
    tIPADDRESS      IpAddr;

    //
    // return this devicecontext's ip address and all the other
    // ip addrs after it.
    //
    if (!pIrp->MdlAddress)
    {
        return STATUS_INVALID_PARAMETER;
    }
    else if ((Length = MmGetMdlByteCount (pIrp->MdlAddress)) < sizeof(ULONG))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    else if (!(pIpAddr = (PULONG )MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, NormalPagePriority)))
    {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Put this adapter first in the list
    // Don't include the smb device, its address is uninteresting
    if (!IsDeviceNetbiosless (pDeviceContext))
    {
        *((tIPADDRESS UNALIGNED *) pIpAddr) = pDeviceContext->AssignedIpAddress;
        pIpAddr++;
        Length -= sizeof(ULONG);
    }

    // Return the others

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pEntry = pHead = &NbtConfig.DeviceContexts;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        if (Length < sizeof(ULONG))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            return STATUS_BUFFER_OVERFLOW;
        }

        pDevContext = CONTAINING_RECORD(pEntry, tDEVICECONTEXT, Linkage);

        if ((pDevContext != pDeviceContext) &&
            (pDevContext->AssignedIpAddress))
        {
            *((tIPADDRESS UNALIGNED *) pIpAddr) = pDevContext->AssignedIpAddress;

            pIpAddr++;
            Length -= sizeof(ULONG);
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //
    // put a -1 address on the end
    //
    if (Length < sizeof(ULONG))
    {
        return STATUS_BUFFER_OVERFLOW;
    }

    IpAddr = -1;
    *((tIPADDRESS UNALIGNED *) pIpAddr) = IpAddr;

    return STATUS_SUCCESS;
} // GetIpAddrs

//----------------------------------------------------------------------------
NTSTATUS
NTReceive(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp
    )
/*++
Routine Description:

    This Routine handles Queuing a receive buffer on a connection or passing
    the recieve buffer to the transport if there is outstanding data waiting
    to be received on the connection.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                        status=STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION              pIrpSp;
    tCONNECTELE                     *pConnEle;
    KIRQL                           OldIrq, OldIrq1;
    ULONG                           ToCopy;
    ULONG                           ClientRcvLen;
    tLOWERCONNECTION                *pLowerConn;
    ULONG                           RemainingPdu;
    PTDI_REQUEST_KERNEL_RECEIVE     pParams;
    PTDI_REQUEST_KERNEL_RECEIVE     pClientParams;
    ULONG                           BytesCopied;


    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = pIrpSp->FileObject->FsContext;

    if ((pConnEle) &&
        (pConnEle->state == NBT_SESSION_UP))
    {
        CTESpinLock(pConnEle,OldIrq1);

        PUSH_LOCATION(0x30);
        if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
        {
            CTESpinFree(pConnEle,OldIrq1);
            ASSERTMSG ("Nbt.NTReceive: ERROR - Invalid Connection Handle\n", 0);
            status = STATUS_INVALID_HANDLE;
        }
        else if (pLowerConn = pConnEle->pLowerConnId)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            CTESpinFree(pConnEle,OldIrq1);
            status = STATUS_REMOTE_DISCONNECT;
        }
    }

    if (STATUS_SUCCESS != status)
    {
        PUSH_LOCATION(0x47);

        //
        // session in wrong state so reject the buffer posting
        // complete the irp, since there must have been some sort of error
        // to get to here
        //
        NTIoComplete(pIrp, status, 0);
        return(status);
    }

    PUSH_LOCATION(0x31);
    //
    // We are already holding the ConnEle lock

    CTESpinLock(pLowerConn,OldIrq);

    if (pLowerConn->StateRcv != PARTIAL_RCV)
    {
        // **** Fast Path Code ****
        //
        // Queue this receive buffer on to the Rcv Head
        //
        InsertTailList(&pConnEle->RcvHead, &pIrp->Tail.Overlay.ListEntry);

        status = NTCheckSetCancelRoutine(pIrp,(PVOID)NbtCancelReceive,pDeviceContext);

        if (!NT_SUCCESS(status))
        {
            RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
            CTESpinFree(pLowerConn,OldIrq);
            CTESpinFree(pConnEle,OldIrq1);

            NTIoComplete(pIrp,status,0);
            return(status);
        }
        else
        {
            //
            // if the irp is not cancelled, returning pending
            //
            CTESpinFree(pLowerConn,OldIrq);
            CTESpinFree(pConnEle,OldIrq1);

            return(STATUS_PENDING);
        }
    }
    else
    {
        // ***** Partial Rcv - Data Still in Transport *****

        BOOLEAN     ZeroLengthSend;

        PUSH_LOCATION(0x32);

        IF_DBG(NBT_DEBUG_RCV)
        KdPrint(("Nbt.NTReceive: A Rcv Buffer posted data in Xport,InXport= %X,InIndic %X RcvIndicated %X\n",
                pConnEle->BytesInXport,pLowerConn->BytesInIndicate,
                pConnEle->ReceiveIndicated));

        // get the MDL chain length
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;

        // Reset the Irp pending flag
        pIrpSp->Control &= ~SL_PENDING_RETURNED;

        // fill in the next irp stack location with our completion routine.
        pIrpSp = IoGetNextIrpStackLocation(pIrp);

        pIrpSp->CompletionRoutine = CompletionRcv;
        pIrpSp->Context = (PVOID)pConnEle->pLowerConnId;
        pIrpSp->Flags = 0;

        // set flags so the completion routine is always invoked.
        pIrpSp->Control = SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL;

        pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        pIrpSp->MinorFunction = TDI_RECEIVE;
        pIrpSp->DeviceObject = IoGetRelatedDeviceObject(pConnEle->pLowerConnId->pFileObject);
        pIrpSp->FileObject = pConnEle->pLowerConnId->pFileObject;

        pParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;
        pParams->ReceiveFlags = pClientParams->ReceiveFlags;

        // Since this irp is going to traverse through CompletionRcv, we
        // need to set the following, since it undoes this stuff.
        // This also prevents the LowerConn from being blown away before
        // the irp has returned from the transport
        //
        NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER);
        //
        // pass the receive buffer directly to the transport, decrementing
        // the number of receive bytes that have been indicated
        //
        ASSERT(pConnEle->TotalPcktLen >= pConnEle->BytesRcvd);
        if (pClientParams->ReceiveLength > (pConnEle->TotalPcktLen - pConnEle->BytesRcvd))
        {
            pParams->ReceiveLength = pConnEle->TotalPcktLen - pConnEle->BytesRcvd;
        }
        else
        {
            pParams->ReceiveLength = pClientParams->ReceiveLength;
        }

        ClientRcvLen = pParams->ReceiveLength;
        //
        // Set the amount of data that we will receive so when the
        // irp completes in completionRcv, we can fill in that
        // info in the Irp
        //
        pConnEle->CurrentRcvLen = ClientRcvLen;

        // if a zero length send occurs, then ReceiveIndicated is set
        // to zero with the state set to RcvPartial. Or, the client may
        // pass down an Irp with no MDL in it!!
        //
        if ((pConnEle->ReceiveIndicated == 0) || !pIrp->MdlAddress)
        {
            ZeroLengthSend = TRUE;
        }
        else
        {
            ZeroLengthSend = FALSE;
        }

        // calculate how many bytes are still remaining for the client.
        if (pConnEle->ReceiveIndicated > ClientRcvLen)
        {
            PUSH_LOCATION(0x40);
            pConnEle->ReceiveIndicated -= ClientRcvLen;
        }
        else
        {
            pConnEle->ReceiveIndicated = 0;
        }

        if (pLowerConn->BytesInIndicate || ZeroLengthSend)
        {
            PMDL    Mdl;

            PUSH_LOCATION(0x33);
            if (ClientRcvLen > pLowerConn->BytesInIndicate)
            {
                ToCopy = pLowerConn->BytesInIndicate;
            }
            else
            {
                PUSH_LOCATION(0x41);
                ToCopy = ClientRcvLen;
            }

            // copy data from the indicate buffer to the client's buffer,
            // remembering that there is a session header in the indicate
            // buffer at the start of it... so skip that.  The
            // client can pass down a null Mdl address for a zero length
            // rcv so check for that.
            //
            if (Mdl = pIrp->MdlAddress)
            {
                TdiCopyBufferToMdl(MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl),
                                   0,           // src offset
                                   ToCopy,
                                   Mdl,
                                   0,                 // dest offset
                                   &BytesCopied);
            }
            else
            {
                BytesCopied = 0;
            }

            // client's MDL is too short...
            if (BytesCopied != ToCopy)
            {
                PUSH_LOCATION(0x42);
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                    KdPrint(("Nbt:Receive Buffer too short for Indicate buff BytesCopied %X, ToCopy %X\n",
                            BytesCopied, ToCopy));

//                ToCopy = BytesCopied;

                // so the irp will be completed, below
                ClientRcvLen = BytesCopied;
            }

            pLowerConn->BytesInIndicate -= (USHORT)BytesCopied;

            // this case is only if the irp is full and should be returned
            // now.
            if (BytesCopied == ClientRcvLen)
            {
                PUSH_LOCATION(0x34);
                // check if the indicate buffer is empty now. If not, then
                // move the data forward to the start of the buffer.
                //
                if (pLowerConn->BytesInIndicate)
                {
                    PUSH_LOCATION(0x43);
                    CopyToStartofIndicate(pLowerConn,BytesCopied);
                }
                //
                // the irp is full so complete it
                //
                // the client MDL is full, so complete his irp
                // CompletionRcv increments the number of bytes rcvd
                // for this session pdu (pConnEle->BytesRcvd).
                pIrp->IoStatus.Information = BytesCopied;
                pIrp->IoStatus.Status = STATUS_SUCCESS;

                // since we are completing it and TdiRcvHandler did not set the next
                // one.
                //
                ASSERT(pIrp->CurrentLocation > 1);

                IoSetNextIrpStackLocation(pIrp);

                // we need to track how much of the client's MDL has filled
                // up to know when to return it.  CompletionRcv subtracts
                // from this value as it receives bytes.
                pConnEle->FreeBytesInMdl = ClientRcvLen;
                pConnEle->CurrentRcvLen  = ClientRcvLen;

                CTESpinFree(pLowerConn,OldIrq);
                CTESpinFree(pConnEle,OldIrq1);

                IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

                return(STATUS_SUCCESS);
            }
            else
            {
                //
                // clear the number of bytes in the indicate buffer since the client
                // has taken more than the data left in the Indicate buffer
                //
                pLowerConn->BytesInIndicate = 0;

                // decrement the client rcv len by the amount already put into the
                // client Mdl
                //
                ClientRcvLen -= BytesCopied;
                IF_DBG(NBT_DEBUG_RCV)
                    KdPrint(("Nbt: Pass Client Irp to Xport BytesinXport %X, ClientRcvLen %X\n",
                                pConnEle->BytesInXport,ClientRcvLen));
                //
                // Set the amount left inthe transport after this irp
                // completes
                if (pConnEle->BytesInXport < ClientRcvLen )
                {
                    pConnEle->BytesInXport = 0;
                }
                else
                {
                    pConnEle->BytesInXport -= ClientRcvLen;
                }

                // Adjust the number of bytes in the Mdl chain so far since the
                // completion routine will only count the bytes filled in by the
                // transport
                pConnEle->BytesRcvd += BytesCopied;

                // the client is going to take more data from the transport with
                // this Irp.  Set the new Rcv Length that accounts for the data just
                // copied to the Irp.
                //
                pParams->ReceiveLength = ClientRcvLen;

                IF_DBG(NBT_DEBUG_RCV)
                KdPrint(("Nbt:ClientRcvLen = %X, LeftinXport= %X BytesCopied= %X %X\n",ClientRcvLen,
                                pConnEle->BytesInXport,BytesCopied,pLowerConn));

                // set the state to this so we can undo the MDL footwork
                // in completion rcv - since we have made a partial MDL and
                // put that at the start of the chain.
                //
                SET_STATERCV_LOWER(pLowerConn, FILL_IRP, FillIrp);

                // Note that the Irp Mdl address changes below
                // when MakePartialMdl is called so this line cannot
                // be moved to the common code below!!
                pLowerConn->pMdl = pIrp->MdlAddress;

                // setup the next MDL so we can create a partial mdl correctly
                // in TdiReceiveHandler
                //
                pConnEle->pNextMdl = pIrp->MdlAddress;

                // Build a partial Mdl to represent the client's Mdl chain since
                // we have copied data to it, and the transport must copy
                // more data to it after that data.
                //
                // Force the system to map and lock the user buffer
                MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority);
                MakePartialMdl(pConnEle,pIrp,BytesCopied);

                // pass the Irp to the transport
                //
                //
                IF_DBG(NBT_DEBUG_RCV)
                    KdPrint(("Nbt:Calling IoCallDriver\n"));
                ASSERT(pIrp->CurrentLocation > 1);
            }
        }
        else
        {
            PUSH_LOCATION(0x36);
            IF_DBG(NBT_DEBUG_RCV)
            KdPrint(("Nbt.NTReceive: Pass Irp To Xport Bytes in Xport %X, ClientRcvLen %X, RcvIndicated %X\n",
                                    pConnEle->BytesInXport,ClientRcvLen,pConnEle->ReceiveIndicated));
            //
            // there are no bytes in the indicate buffer, so just pass the
            // irp on down to the transport
            //
            //
            // Decide the next state depending on whether the transport currently
            // has enough data for this irp
            //
            if (pConnEle->BytesInXport < ClientRcvLen)
            {
                PUSH_LOCATION(0x37);
                pConnEle->BytesInXport = 0;
                //
                // to get to here, the implication is that ReceiveIndicated
                // equals zero too!! Since ReceiveInd cannot be more than
                // BytesInXport, so we can change the state to fill irp without
                // worrying about overwriting PartialRcv
                //
                SET_STATERCV_LOWER(pLowerConn, FILL_IRP, FillIrp);
                // setup the next MDL so we can create a partial mdl correctly
                // in TdiReceiveHandler
                //
                pConnEle->pNextMdl = pIrp->MdlAddress;
            }
            else
            {
                PUSH_LOCATION(0x38);
                pConnEle->BytesInXport -= ClientRcvLen;

                // set the state to this so we know what to do in completion rcv
                //
                if (pConnEle->ReceiveIndicated == 0)
                {
                    PUSH_LOCATION(0x39);
                    SET_STATERCV_LOWER(pLowerConn, NORMAL, Normal);
                }
            }

            //
            // save the Irp so we can reconstruct things later
            //
            pLowerConn->pMdl = pIrp->MdlAddress;
        }

        // *** Common Code to passing irp to transport - when there is
        // data in the indicate buffer and when there isn't

        // keep track of data in MDL so we know when it is full
        // and we need to return it to the user
        //
        pConnEle->FreeBytesInMdl = pParams->ReceiveLength;
        // Force the system to map and lock the user buffer
        MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority);

        //
        // Null the Irp since we are passing it to the transport.
        //
        pConnEle->pIrpRcv = NULL;
        CTESpinFree(pLowerConn,OldIrq);
        CTESpinFree(pConnEle,OldIrq1);

        CHECK_COMPLETION(pIrp);

        status = IoCallDriver(IoGetRelatedDeviceObject(pLowerConn->pFileObject),pIrp);

        IF_DBG(NBT_DEBUG_RCV)
            KdPrint(("Nbt.NTReceive: Returning=<%x>, IoStatus.Status=<%x>, IoStatus.Information=<%x>\n",
                status, pIrp->IoStatus.Status, pIrp->IoStatus.Information));
    }

    return(status);
}
//----------------------------------------------------------------------------
NTSTATUS
NTReceiveDatagram(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles receiving a datagram by passing the datagram rcv
    buffer to the non-OS specific code.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                        status;
    PIO_STACK_LOCATION              pIrpSp;
    PTDI_REQUEST_KERNEL_RECEIVEDG   pTdiRequest;
    TDI_REQUEST                     Request;
    ULONG                           ReceivedLength;
    tCLIENTELE                      *pClientEle;

    IF_DBG(NBT_DEBUG_RCV)
        KdPrint(("Nbt: Got a Receive datagram that NBT was NOT \n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pClientEle = (tCLIENTELE *)pIrpSp->FileObject->FsContext;

    if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
    {
        ASSERTMSG ("Nbt.NTReceiveDatagram: ERROR - Invalid Address Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    // get the sending information out of the irp
    pTdiRequest = (PTDI_REQUEST_KERNEL_RECEIVEDG)&pIrpSp->Parameters;
    Request.Handle.AddressHandle = pClientEle;

    status = NbtReceiveDatagram(
                    &Request,
                    pTdiRequest->ReceiveDatagramInformation,
                    pTdiRequest->ReturnDatagramInformation,
                    pTdiRequest->ReceiveLength,
                    &ReceivedLength,
                    (PVOID)pIrp->MdlAddress,   // user data
                    (tDEVICECONTEXT *)pDeviceContext,
                    pIrp);

    if (status != STATUS_PENDING)
    {

        NTIoComplete(pIrp,status,ReceivedLength);

    }

    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
NTSend(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles sending session pdus across a connection.  It is
    all OS specific code.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION              pIrpSp;
    NTSTATUS                        status;
    PTDI_REQUEST_KERNEL_SEND        pTdiRequest;
    PMDL                            pMdl;
    PSINGLE_LIST_ENTRY              pSingleListEntry;
    tSESSIONHDR                     *pSessionHdr;
    tCONNECTELE                     *pConnEle;
    KIRQL                           OldIrq;
    KIRQL                           OldIrq1;
    PTDI_REQUEST_KERNEL_SEND        pParams;
    PFILE_OBJECT                    pFileObject;
    tLOWERCONNECTION                *pLowerConn;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // This function could be called directly also while bypassing the
    // Io subsystem, so we need to recheck the DeviceContext here
    //
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        // IF_DBG(NBT_DEBUG_SEND)
            KdPrint(("Nbt.NTSend:  Invalid Device=<%x>\n", pDeviceContext));
        status = STATUS_INVALID_DEVICE_STATE;
        goto ErrorInvalidDevice;
    }

    // get the sending information out of the irp
    pTdiRequest = (PTDI_REQUEST_KERNEL_SEND)&pIrpSp->Parameters;
    pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NTSend: ERROR - Invalid Connection Handle\n", 0);
        status = STATUS_INVALID_HANDLE;
        goto ErrorExit;     // Irp has to be completed in this routine! Bug# 202340
    }

    CTESpinLock(pConnEle,OldIrq);

    if (!(pLowerConn =  pConnEle->pLowerConnId))
    {
        CTESpinFree(pConnEle,OldIrq);

        IF_DBG(NBT_DEBUG_SEND)
            KdPrint(("Nbt.NTSend: attempting send when LowerConn has been freed!\n"));
        status = STATUS_INVALID_HANDLE;
        goto ErrorExit;     // to save on indent levels use a goto here
    }

    //
    // make sure lowerconn stays valid until the irp is done
    //
    CTESpinLock(pLowerConn,OldIrq1);
    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_SEND);
    CTESpinFree(pLowerConn,OldIrq1);

    // check the state of the connection
    if (pConnEle->state == NBT_SESSION_UP)
    {
        //
        // send the data on downward to tcp
        // allocate an MDL to allow us to put the session hdr in first and then
        // put the users buffer on after that, chained to the session hdr MDL.
        //
#if BACK_FILL
        {
           PMDL SmbMdl;
           SmbMdl = (PMDL)pIrp->MdlAddress;

            // Check if network header type is set
            // if yes, then we can back fill the nbt session header

            if ((SmbMdl) && (SmbMdl->MdlFlags & MDL_NETWORK_HEADER))
            {
                pSessionHdr = (tSESSIONHDR *)((ULONG_PTR)SmbMdl->MappedSystemVa - SESSION_HDR_SIZE);

                (ULONG_PTR)SmbMdl->MappedSystemVa -= SESSION_HDR_SIZE;
                SmbMdl->ByteOffset -= SESSION_HDR_SIZE;
                SmbMdl->ByteCount+= SESSION_HDR_SIZE;

                pSessionHdr->UlongLength = htonl(pTdiRequest->SendLength);

                IF_DBG(NBT_DEBUG_SEND)
                    KdPrint(("Nbt: Backfilled mdl %x %x\n", pSessionHdr, SmbMdl));
            }
            else
            {
                CTESpinLockAtDpc(&NbtConfig);

                if (NbtConfig.SessionMdlFreeSingleList.Next)
                {
                    pSingleListEntry = PopEntryList(&NbtConfig.SessionMdlFreeSingleList);
                    pMdl = CONTAINING_RECORD(pSingleListEntry,MDL,Next);
                    ASSERT ( MmGetMdlByteCount ( pMdl ) == sizeof ( tSESSIONHDR ) );
                }
                else
                {
                    NbtGetMdl(&pMdl,eNBT_FREE_SESSION_MDLS);
                    if (!pMdl)
                    {
                        IF_DBG(NBT_DEBUG_SEND)
                            KdPrint(("Nbt:Unable to get an MDL for a session send!\n"));

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        CTESpinFreeAtDpc(&NbtConfig);
                        CTESpinFree(pConnEle,OldIrq);

                        // to save on indent levels use a goto here
                        goto ErrorExit1;
                    }
                }

                CTESpinFreeAtDpc(&NbtConfig);

                // get the session hdr address out of the MDL
                pSessionHdr = (tSESSIONHDR *)MmGetMdlVirtualAddress(pMdl);

                // the type of PDU is always a session message, since the session
                // request is sent when the client issues a "connect" rather than a send
                //
                pSessionHdr->UlongLength = htonl(pTdiRequest->SendLength);

                // get the device object and file object for the TCP transport underneath
                // link the user buffer on the end of the session header Mdl on the Irp
                //
                pMdl->Next = pIrp->MdlAddress;
                pIrp->MdlAddress = pMdl;
            }
        }
#else
        CTESpinLockAtDpc(&NbtConfig);

        if (NbtConfig.SessionMdlFreeSingleList.Next)
        {
            pSingleListEntry = PopEntryList(&NbtConfig.SessionMdlFreeSingleList);
            pMdl = CONTAINING_RECORD(pSingleListEntry,MDL,Next);

            ASSERT ( MmGetMdlByteCount ( pMdl ) == sizeof ( tSESSIONHDR ) );
        }
        else
        {
            NbtGetMdl(&pMdl,eNBT_FREE_SESSION_MDLS);

            if (!pMdl)
            {
                IF_DBG(NBT_DEBUG_SEND)
                    KdPrint(("Nbt:Unable to get an MDL for a session send!\n"));

                status = STATUS_INSUFFICIENT_RESOURCES;
                CTESpinFreeAtDpc(&NbtConfig);
                CTESpinFree(pConnEle,OldIrq);

                // to save on indent levels use a goto here
                goto ErrorExit1;
            }
        }

        CTESpinFreeAtDpc(&NbtConfig);

        // get the session hdr address out of the MDL
        pSessionHdr = (tSESSIONHDR *)MmGetMdlVirtualAddress(pMdl);

        // the type of PDU is always a session message, since the session
        // request is sent when the client issues a "connect" rather than a send
        //
        pSessionHdr->UlongLength = htonl(pTdiRequest->SendLength);

        // get the device object and file object for the TCP transport underneath
        // link the user buffer on the end of the session header Mdl on the Irp
        //
        pMdl->Next = pIrp->MdlAddress;
        pIrp->MdlAddress = pMdl;

#endif //BACK_FILL

        pIrpSp = IoGetNextIrpStackLocation(pIrp);

        pParams = (PTDI_REQUEST_KERNEL_SEND)&pIrpSp->Parameters;
        pParams->SendFlags = pTdiRequest->SendFlags;
        pParams->SendLength = pTdiRequest->SendLength + sizeof(tSESSIONHDR);


        pIrpSp->CompletionRoutine = SendCompletion;
        pIrpSp->Context = (PVOID)pLowerConn;
        pIrpSp->Control = SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL;

        pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        pIrpSp->MinorFunction = TDI_SEND;

        pFileObject = pLowerConn->pFileObject;
        pLowerConn->BytesSent += pTdiRequest->SendLength;

        pIrpSp->FileObject = pFileObject;
        pIrpSp->DeviceObject = IoGetRelatedDeviceObject(pFileObject);


        CTESpinFree(pConnEle,OldIrq);

        CHECK_COMPLETION(pIrp);

#if FAST_DISP
        //if we are all set to do fast path, do so now.
        if (pLowerConn->FastSend)
        {
            IoSetNextIrpStackLocation(pIrp);

            IF_DBG(NBT_DEBUG_SEND)
                KdPrint(("Nbt.NTSend: Fasttdi path %x %x \n", pIrp, pIrpSp));

            status = pLowerConn->FastSend (pIrp, pIrpSp);
        }
        else
        {
            status = IoCallDriver (IoGetRelatedDeviceObject (pFileObject), pIrp);
        }
#else
        status = IoCallDriver(IoGetRelatedDeviceObject(pFileObject),pIrp);
#endif

        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
        return(status);
    }   //correct state

    CTESpinFree(pConnEle,OldIrq);
    IF_DBG(NBT_DEBUG_SEND)
        KdPrint(("Nbt:Invalid state for connection on an attempted send, %X\n",
            pConnEle));
    status = STATUS_INVALID_HANDLE;

ErrorExit1:

    //
    // Dereference pLowerConn->RefCount, referenced above.
    //
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_SEND, FALSE);

ErrorExit:

    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);

ErrorInvalidDevice:

    //
    // Reset the Irp pending flag
    //
    pIrpSp->Control &= ~SL_PENDING_RETURNED;
    //
    // complete the irp, since there must have been some sort of error
    // to get to here
    //
    NTIoComplete (pIrp, status, 0);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
SendCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine handles the completion event when the send completes with
    the underlying transport.  It must put the session hdr buffer back in
    the correct free list and free the active q entry and put it back on
    its free list.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the pConnectEle - the connection data structure

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PMDL               pMdl;
    tLOWERCONNECTION  *pLowerConn;

    //
    // Do some checking to keep the Io system happy - propagate the pending
    // bit up the irp stack frame.... if it was set by the driver below then
    // it must be set by me
    //
    if (Irp->PendingReturned)
    {
        IoMarkIrpPending(Irp);
    }

    // put the MDL we back on its free list and put the clients mdl back on the Irp
    // as it was before the send
    pMdl = Irp->MdlAddress;

#if BACK_FILL
    // If the header is back filled
    // we should adjust the pointers back to where it was.
    if (pMdl->MdlFlags & MDL_NETWORK_HEADER)
    {
        (ULONG_PTR)pMdl->MappedSystemVa += SESSION_HDR_SIZE;
        pMdl->ByteOffset += SESSION_HDR_SIZE;
        pMdl->ByteCount -= SESSION_HDR_SIZE;

        IF_DBG(NBT_DEBUG_SEND)
            KdPrint(("Nbt: Done with Backfilled mdl %x\n", pMdl));
    }
    else
    {
        Irp->MdlAddress = pMdl->Next;

        ASSERT ( MmGetMdlByteCount ( pMdl ) == SESSION_HDR_SIZE );

#if DBG
        IF_DBG(NBT_DEBUG_SEND)
        {
            PMDL             pMdl1;
            ULONG            ulen1,ulen2,ulen3;
            UCHAR            uc;
            tSESSIONHDR      *pSessionHdr;
            PSINGLE_LIST_ENTRY   pSingleListEntry;
            KIRQL            OldIrq;

            pSessionHdr = (tSESSIONHDR *)MmGetMdlVirtualAddress(pMdl);
            ulen1 = htonl ( pSessionHdr->UlongLength );

            for ( ulen2 = 0 , pMdl1 = pMdl ; ( pMdl1 = pMdl1->Next ) != NULL ; )
            {
                ulen3 = MmGetMdlByteCount ( pMdl1 );
                ASSERT ( ulen3 > 0 );
                uc = ( ( UCHAR * ) MmGetMdlVirtualAddress ( pMdl1 ) ) [ ulen3 - 1 ];
                ulen2 += ulen3;
            }

            ASSERT ( ulen2 == ulen1 );

            CTESpinLock(&NbtConfig,OldIrq);
            for ( pSingleListEntry = &NbtConfig.SessionMdlFreeSingleList ;
                    ( pSingleListEntry = pSingleListEntry->Next ) != NULL ;
                    )
            {
                 pMdl1 = CONTAINING_RECORD(pSingleListEntry,MDL,Next);
                 ASSERT ( pMdl1 != pMdl  );
            }
            CTESpinFree(&NbtConfig,OldIrq);
        }
#endif  // DBG

        ExInterlockedPushEntryList(&NbtConfig.SessionMdlFreeSingleList,
                               (PSINGLE_LIST_ENTRY)pMdl,
                               &NbtConfig.LockInfo.SpinLock);
    }
#else
    Irp->MdlAddress = pMdl->Next;
    ASSERT ( MmGetMdlByteCount ( pMdl ) == sizeof ( tSESSIONHDR ) );

#if DBG
    IF_DBG(NBT_DEBUG_SEND)
    {
        PMDL             pMdl1;
        ULONG            ulen1,ulen2,ulen3;
        UCHAR            uc;
        tSESSIONHDR      *pSessionHdr;
        PSINGLE_LIST_ENTRY   pSingleListEntry;
        KIRQL            OldIrq;

        pSessionHdr = (tSESSIONHDR *)MmGetMdlVirtualAddress(pMdl);
        ulen1 = htonl ( pSessionHdr->UlongLength );

        for ( ulen2 = 0 , pMdl1 = pMdl ; ( pMdl1 = pMdl1->Next ) != NULL ; )
        {
            ulen3 = MmGetMdlByteCount ( pMdl1 );
            ASSERT ( ulen3 > 0 );
            uc = ( ( UCHAR * ) MmGetMdlVirtualAddress ( pMdl1 ) ) [ ulen3 - 1 ];
            ulen2 += ulen3;
        }

        ASSERT ( ulen2 == ulen1 );

        CTESpinLock(&NbtConfig,OldIrq);
        for ( pSingleListEntry = &NbtConfig.SessionMdlFreeSingleList ;
                ( pSingleListEntry = pSingleListEntry->Next ) != NULL ;
            )
        {
            pMdl1 = CONTAINING_RECORD(pSingleListEntry,MDL,Next);
            ASSERT ( pMdl1 != pMdl  );
        }
        CTESpinFree(&NbtConfig,OldIrq);
    }
#endif  // DBG

    ExInterlockedPushEntryList(&NbtConfig.SessionMdlFreeSingleList,
                               (PSINGLE_LIST_ENTRY)pMdl,
                               &NbtConfig.LockInfo.SpinLock);

#endif //BACK_FILL
    // fill in the sent size so that it substracts off the session header size
    //
    if (Irp->IoStatus.Information > sizeof(tSESSIONHDR))
    {
        Irp->IoStatus.Information -= sizeof(tSESSIONHDR);
    }
    else
    {
        // nothing was sent
        Irp->IoStatus.Information = 0;
        IF_DBG(NBT_DEBUG_SEND)
        KdPrint(("Nbt:Zero Send Length for a session send!\n"));
    }

    //
    // we incremented this before the send: deref it now
    //
    pLowerConn = (tLOWERCONNECTION *)Context;
    ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_SEND, FALSE);

    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER( DeviceObject );
}


//----------------------------------------------------------------------------
NTSTATUS
NTSendDatagram(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles sending a datagram down to the transport.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION              pIrpSp;
    NTSTATUS                        status;
    LONG                            lSentLength;
    TDI_REQUEST                     Request;
    PTDI_REQUEST_KERNEL_SENDDG      pTdiRequest;
    tCLIENTELE                      *pClientEle;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pClientEle = (tCLIENTELE *)pIrpSp->FileObject->FsContext;

    if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
    {
        ASSERTMSG ("Nbt.SendDatagram: ERROR - Invalid Address Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    // CTEVerifyHandle(pClientEle,NBT_VERIFY_CLIENT,tCLIENTELE,&status);

    // get the sending information out of the irp
    pTdiRequest = (PTDI_REQUEST_KERNEL_SENDDG)&pIrpSp->Parameters;
    Request.Handle.AddressHandle = pClientEle;

    lSentLength = 0;

    //
    // Mark IRP pending here
    //
    IoMarkIrpPending(pIrp);
    status = NbtSendDatagram (&Request,
                              pTdiRequest->SendDatagramInformation,
                              pTdiRequest->SendLength,
                              &lSentLength,
                              (PVOID)pIrp->MdlAddress,   // user data
                              (tDEVICECONTEXT *)pDeviceContext,
                              pIrp);


    if (status != STATUS_PENDING)
    {
        //
        // either Success or an Error
        //
        NTIoComplete(pIrp,status,lSentLength);
    }

    //
    // To make driver verifier and IO system happy, always return
    // STATUS_PENDING for the request marked as PENDING
    //
    return STATUS_PENDING;
}

//----------------------------------------------------------------------------
NTSTATUS
NTSetInformation(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles sets up event handlers that the client passes in.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    // *TODO*

    CTEPagedCode();

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:************ Got a Set Information that was NOT expected *******\n"));
    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
NTSTATUS
NTQueueToWorkerThread(
    IN OUT NBT_WORK_ITEM_CONTEXT * pContext,
    IN PVOID                   DelayedWorkerRoutine,
    IN tDGRAM_SEND_TRACKING    *pTracker,
    IN PVOID                   pClientContext,
    IN PVOID                   ClientCompletion,
    IN tDEVICECONTEXT          *pDeviceContext,
    IN BOOLEAN                 fJointLockHeld
    )
/*++

Routine Description:

    This routine simply queues a request on an excutive worker thread
    for later execution.  Scanning the LmHosts file must be down this way.

Arguments:
    pContext - the workitem context. If it is NULL, this function will
                allocate one. Otherwise, it will use the pass in context.
    pTracker            - the tracker block for context
    DelayedWorkerRoutine- the routine for the Workerthread to call
    pDeviceContext      - the device context which is this delayed event
                          pertains to.  This could be NULL (meaning it's an event
                          pertaining to not any specific device context)

Return Value:


--*/
{
    KIRQL OldIrq = 0;

    if ((pDeviceContext) &&
        (!NBT_REFERENCE_DEVICE(pDeviceContext, REF_DEV_WORKER, fJointLockHeld)))
    {
        // ASSERT(NULL == pContext);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

#if 0
    //
    // Dont bother queuing a workitem if we're running
    // in the same context of the work thread and we're
    // at PASSIVE_LEVEL
    //

    if (KeGetCurrentThread() == NbtConfig.pWorkThread &&
        KeGetCurrentIrql() == PASSIVE_LEVEL) {

        KdPrint(("WorkItem: Fast Path\n"));

        (*((PNBT_WORKER_THREAD_ROUTINE)DelayedWorkerRoutine))(
                            pTracker,
                            pClientContext,
                            ClientCompletion,
                            pDeviceContext
                            );
        if (pDeviceContext) {
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_WORKER, fJointLockHeld);
        }
        return (STATUS_SUCCESS);

    }
#endif

    //
    // Allocate a context if
    //  1. the caller doesn't have one, or
    //  2. the context is already in queue
    //     this is a bug in the caller. In this case,
    //     we try to recover from the failure.
    //

    if (NULL == pContext || pContext->bQueued) {

        //
        // ASSERT out if the caller is giving us a pContext
        // which has already been in queue.
        //
        ASSERT(NULL == pContext);

        pContext = (NBT_WORK_ITEM_CONTEXT *)NbtAllocMem(sizeof(NBT_WORK_ITEM_CONTEXT),NBT_TAG2('22'));

        if (NULL == pContext) {
            if (pDeviceContext) {
                NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_WORKER, fJointLockHeld);
            }
            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        pContext->bSpecialAlloc = TRUE;
        pContext->bQueued = FALSE;
    } else {
        pContext->bSpecialAlloc = FALSE;
    }

    //
    // From now on, we cannot fail
    //

    pContext->bQueued = TRUE;
    pContext->pTracker = pTracker;
    pContext->pClientContext = pClientContext;
    pContext->ClientCompletion = ClientCompletion;
    pContext->pDeviceContext = pDeviceContext;
    pContext->WorkerRoutine = DelayedWorkerRoutine;
    InitializeListHead(&pContext->Linkage);

    CTESpinLock(&NbtConfig.WorkerQLock,OldIrq);
    InsertTailList(&NbtConfig.WorkerQList, &pContext->Linkage);
    InterlockedIncrement(&NbtConfig.NumWorkItemQueued);

    if (!NbtConfig.Unloading &&
        !InterlockedExchange(&NbtConfig.bSystemWorkThreadQueued, TRUE)) {

        ExInitializeWorkItem(&NbtConfig.SystemWorkItem, NTExecuteWorker, &NbtConfig.SystemWorkItem);
        ExQueueWorkItem(&NbtConfig.SystemWorkItem, CriticalWorkQueue);
    }
    CTESpinFree(&NbtConfig.WorkerQLock,OldIrq);

    return (STATUS_SUCCESS);
}



//----------------------------------------------------------------------------
VOID
NTExecuteWorker(
    IN PVOID pUnused
    )
/*++

Routine Description:

    This routine handles executing delayed requests at non-Dpc level.  If
    the Device is currently being unloaded, we let the Unload Handler
    complete the request.

Arguments:
    pUnused - Unused

Return Value:

    none

--*/

{
    NBT_WORK_ITEM_CONTEXT * pContext = NULL;
    PNBT_WORKER_THREAD_ROUTINE pDelayedWorkerRoutine = NULL;
    KIRQL OldIrq;
    PLIST_ENTRY pEntry = NULL;
    tDEVICECONTEXT * pDeviceContext = NULL;
    BOOL bSpecialAlloc = FALSE;

    CTESpinLock(&NbtConfig.WorkerQLock,OldIrq);

    ASSERT(NULL == NbtConfig.pWorkThread);

    NbtConfig.pWorkThread = KeGetCurrentThread();

    while(!IsListEmpty(&NbtConfig.WorkerQList)) {
        pEntry = RemoveHeadList(&NbtConfig.WorkerQList);
        InterlockedDecrement(&NbtConfig.NumWorkItemQueued);
        CTESpinFree(&NbtConfig.WorkerQLock,OldIrq);

        pContext = CONTAINING_RECORD(pEntry, NBT_WORK_ITEM_CONTEXT, Linkage);
        pContext->bQueued = FALSE;
        pDelayedWorkerRoutine = (PNBT_WORKER_THREAD_ROUTINE)pContext->WorkerRoutine;

        //
        // Save the value because pContext can be freed by the worker routine
        //

        pDeviceContext = pContext->pDeviceContext;
        bSpecialAlloc = pContext->bSpecialAlloc;

        (*pDelayedWorkerRoutine) (pContext->pTracker,
                              pContext->pClientContext,
                              pContext->ClientCompletion,
                              pDeviceContext
                              );

        //
        // Use the saved copy after the delayed worker routine is called
        //

        if (bSpecialAlloc) {
            CTEMemFree((PVOID) pContext);
        }
        pContext = NULL;

        if (pDeviceContext) {
            NBT_DEREFERENCE_DEVICE(pDeviceContext, REF_DEV_WORKER, FALSE);
        }

        CTESpinLock(&NbtConfig.WorkerQLock,OldIrq);
    }

    //
    // set the flag to FALSE before releasing the spinlock
    //

    InterlockedExchange(&NbtConfig.bSystemWorkThreadQueued, FALSE);
    NbtConfig.pWorkThread = NULL;
    CTESpinFree(&NbtConfig.WorkerQLock,OldIrq);
}


//----------------------------------------------------------------------------
VOID
SecurityDelete(
    IN  PVOID     pContext
    )
/*++

Routine Description:

    This routine handles deleting a security context at non-dpc level.

Arguments:


Return Value:

    none

--*/
{
    PSECURITY_CLIENT_CONTEXT    pClientSecurity;

    pClientSecurity = (PSECURITY_CLIENT_CONTEXT)((NBT_WORK_ITEM_CONTEXT *)pContext)->pClientContext;
    SeDeleteClientSecurity(pClientSecurity);
    CTEMemFree(pContext);
}

//----------------------------------------------------------------------------
NTSTATUS
NTSendSession(
    IN  tDGRAM_SEND_TRACKING  *pTracker,
    IN  tLOWERCONNECTION      *pLowerConn,
    IN  PVOID                 pCompletion
    )
/*++
Routine Description:

    This Routine handles seting up a DPC to send a session pdu so that the stack
    does not get wound up in multiple sends for the keep alive timeout case.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/
{
    PKDPC   pDpc;

    if (pDpc = NbtAllocMem(sizeof(KDPC),NBT_TAG('f')))
    {
        KeInitializeDpc(pDpc, DpcSendSession, (PVOID)pTracker);
        KeInsertQueueDpc(pDpc,(PVOID)pLowerConn,pCompletion);

        return (STATUS_SUCCESS);
    }

    return (STATUS_INSUFFICIENT_RESOURCES);
}

//----------------------------------------------------------------------------
VOID
DpcSendSession(
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    )
/*++

Routine Description:

    This routine simply calls TcpSendSession from a Dpc started in
    in NTSendSession (above).

Arguments:


Return Value:


--*/

{
    CTEMemFree((PVOID)pDpc);

    TcpSendSession((tDGRAM_SEND_TRACKING *)Context,
                   (tLOWERCONNECTION *)SystemArgument1,
                   (PVOID)SystemArgument2);
}


//----------------------------------------------------------------------------
NTSTATUS
NTSetEventHandler(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION  pIrpSp;
    NTSTATUS            status;
    tCLIENTELE          *pClientEle;
    PTDI_REQUEST_KERNEL_SET_EVENT   pKeSetEvent;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pClientEle = pIrpSp->FileObject->FsContext;

    if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
    {
        ASSERTMSG ("Nbt.NTSetEventHandler: ERROR - Invalid Address Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    pKeSetEvent = (PTDI_REQUEST_KERNEL_SET_EVENT)&pIrpSp->Parameters;

    // call the not NT specific routine to setup the event handler in the
    // nbt data structures
    status = NbtSetEventHandler(
                        pClientEle,
                        pKeSetEvent->EventType,
                        pKeSetEvent->EventHandler,
                        pKeSetEvent->EventContext);

    return(status);

}

//----------------------------------------------------------------------------

VOID
NTIoComplete(
    IN  PIRP            pIrp,
    IN  NTSTATUS        Status,
    IN  ULONG           SentLength)

/*++
Routine Description:

    This Routine handles calling the NT I/O system to complete an I/O.

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    KIRQL   OldIrq;

#if DBG
    if (!NT_SUCCESS(Status))
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NTIoComplete: Returning Error status = %X\n",Status));
//        ASSERTMSG("Nbt: Error Ret Code In IoComplete",0);
    }
#endif

    pIrp->IoStatus.Status = Status;

    // use -1 as a flag to mean do not adjust the sent length since it is
    // already set
    if (SentLength != -1)
    {
        pIrp->IoStatus.Information = SentLength;
    }

    NbtTrace(NBT_TRACE_IOCTL, ("pIrp %p: %!status! Information %d",
                    pIrp, Status, (ULONG)(pIrp->IoStatus.Information)));

#if DBG
    if ( (Status != STATUS_SUCCESS) &&
         (Status != STATUS_PENDING) &&
         (Status != STATUS_INVALID_DEVICE_REQUEST) &&
         (Status != STATUS_INVALID_PARAMETER) &&
         (Status != STATUS_IO_TIMEOUT) &&
         (Status != STATUS_BUFFER_OVERFLOW) &&
         (Status != STATUS_BUFFER_TOO_SMALL) &&
         (Status != STATUS_INVALID_HANDLE) &&
         (Status != STATUS_INSUFFICIENT_RESOURCES) &&
         (Status != STATUS_CANCELLED) &&
         (Status != STATUS_DUPLICATE_NAME) &&
         (Status != STATUS_TOO_MANY_NAMES) &&
         (Status != STATUS_TOO_MANY_SESSIONS) &&
         (Status != STATUS_REMOTE_NOT_LISTENING) &&
         (Status != STATUS_BAD_NETWORK_PATH) &&
         (Status != STATUS_HOST_UNREACHABLE) &&
         (Status != STATUS_CONNECTION_REFUSED) &&
         (Status != STATUS_WORKING_SET_QUOTA) &&
         (Status != STATUS_REMOTE_DISCONNECT) &&
         (Status != STATUS_LOCAL_DISCONNECT) &&
         (Status != STATUS_LINK_FAILED) &&
         (Status != STATUS_SHARING_VIOLATION) &&
         (Status != STATUS_UNSUCCESSFUL) &&
         (Status != STATUS_ACCESS_VIOLATION) &&
#ifdef MULTIPLE_WINS
         (Status != STATUS_NETWORK_UNREACHABLE) &&
#endif
         (Status != STATUS_NONEXISTENT_EA_ENTRY) )
    {
        KdPrint(("Nbt.NTIoComplete: returning unusual status = %X\n",Status));
    }
#endif

    // set the Irps cancel routine to null or the system may bugcheck
    // with a bug code of CANCEL_STATE_IN_COMPLETED_IRP
    //
    // refer to IoCancelIrp()  ..\ntos\io\iosubs.c
    //
    IoAcquireCancelSpinLock(&OldIrq);
    IoSetCancelRoutine(pIrp,NULL);
    IoReleaseCancelSpinLock(OldIrq);

    IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);
}



//----------------------------------------------------------------------------
//              ***** ***** Cancel Utilities ***** *****
//----------------------------------------------------------------------------

NTSTATUS
NTGetIrpIfNotCancelled(
    IN  PIRP            pIrp,
    IN  PIRP            *ppIrpInStruct
        )
/*++
Routine Description:

    This Routine gets the IOCancelSpinLock to coordinate with cancelling
    irps It then returns STATUS_SUCCESS. It also nulls the irp in the structure
    pointed to by the second parameter - so that the irp cancel routine
    will not also be called.

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    KIRQL       OldIrq;
    NTSTATUS    status;

    IoAcquireCancelSpinLock(&OldIrq);

    // this nulls the irp in the datastructure - i.e. pConnEle->pIrp = NULL
    *ppIrpInStruct = NULL;

    if (!pIrp->Cancel)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }
    IoSetCancelRoutine(pIrp,NULL);

    IoReleaseCancelSpinLock(OldIrq);

    return(status);
}
//----------------------------------------------------------------------------
NTSTATUS
NTCheckSetCancelRoutine(
    IN  PIRP            pIrp,
    IN  PVOID           CancelRoutine,
    IN  tDEVICECONTEXT  *pDeviceContext
    )

/*++
Routine Description:

    This Routine sets the cancel routine for an Irp.

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS status;

    //
    // Check if the irp was cancelled yet and if not, then set the
    // irp cancel routine.
    //
    IoAcquireCancelSpinLock(&pIrp->CancelIrql);
    if (pIrp->Cancel)
    {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        status = STATUS_CANCELLED;

    }
    else
    {
        // setup the cancel routine
        IoMarkIrpPending(pIrp);
        IoSetCancelRoutine(pIrp,CancelRoutine);
        status = STATUS_SUCCESS;
    }

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    return(status);

}
//----------------------------------------------------------------------------
NTSTATUS
NbtSetCancelRoutine(
    IN  PIRP            pIrp,
    IN  PVOID           CancelRoutine,
    IN  tDEVICECONTEXT  *pDeviceContext
    )

/*++
Routine Description:

    This Routine sets the cancel routine for an Irp.

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS status;

    //
    // Check if the irp was cancelled yet and if not, then set the
    // irp cancel routine.
    //
    IoAcquireCancelSpinLock(&pIrp->CancelIrql);
    if (pIrp->Cancel)
    {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        status = STATUS_CANCELLED;

        //
        // Note the cancel spin lock is released by the Cancel routine
        //

        (*(PDRIVER_CANCEL)CancelRoutine)((PDEVICE_OBJECT)pDeviceContext,pIrp);

    }
    else
    {
        // setup the cancel routine and mark the irp pending
        //
        IoMarkIrpPending(pIrp);
        IoSetCancelRoutine(pIrp,CancelRoutine);
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
        status = STATUS_SUCCESS;
    }
    return(status);

}

//----------------------------------------------------------------------------
VOID
NTClearContextCancel(
    IN NBT_WORK_ITEM_CONTEXT    *pContext
    )
/*++
Routine Description:

    This Routine sets the cancel routine for
    ((tDGRAM_SEND_TRACKING *)(pContext->pClientContext))->pClientIrp
    to NULL.

    NbtConfig.JointLock should be held when this routine is called.

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/
{
    NTSTATUS status;
    status = NbtCancelCancelRoutine( ((tDGRAM_SEND_TRACKING *)(pContext->pClientContext))->pClientIrp );
    ASSERT ( status != STATUS_CANCELLED );
}

//----------------------------------------------------------------------------
NTSTATUS
NbtCancelCancelRoutine(
    IN  PIRP            pIrp
    )

/*++
Routine Description:

    This Routine sets the cancel routine for an Irp to NULL

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS status = STATUS_SUCCESS;

    if ( pIrp )
    {
        //
        // Check if the irp was cancelled yet and if not, then set the
        // irp cancel routine.
        //
        IoAcquireCancelSpinLock(&pIrp->CancelIrql);

        if (pIrp->Cancel)
        {
            status = STATUS_CANCELLED;
        }
        IoSetCancelRoutine(pIrp,NULL);

        IoReleaseCancelSpinLock(pIrp->CancelIrql);
    }

    return(status);
}


//----------------------------------------------------------------------------
//              ***** ***** Cancel Routines ***** *****
//----------------------------------------------------------------------------


VOID
NbtCancelListen(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a listen Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tCONNECTELE          *pConnEle;
    tCLIENTELE           *pClientEle;
    KIRQL                OldIrq;
    PLIST_ENTRY          pHead;
    PLIST_ENTRY          pEntry;
    PIO_STACK_LOCATION   pIrpSp;
    tLISTENREQUESTS     *pListenReq;


    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Got a LISTEN Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;

    if ((!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN)) ||
        (!NBT_VERIFY_HANDLE2 ((pClientEle = pConnEle->pClientEle), NBT_VERIFY_CLIENT,NBT_VERIFY_CLIENT_DOWN)))
    {
        ASSERTMSG ("Nbt.NbtCancelListen: ERROR - Invalid Connection Handle\n", 0);
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
        return;
    }

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    NbtTrace(NBT_TRACE_INBOUND, ("Cancel Listen Irp %p pConnEle %p ClientEle %p", pIrp, pConnEle, pClientEle));

    // now search the client's listen queue looking for this connection
    //
    CTESpinLock(pClientEle,OldIrq);

    pHead = &pClientEle->ListenHead;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        pListenReq = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);
        if ((pListenReq->pConnectEle == pConnEle) &&
            (pListenReq->pIrp == pIrp))
        {
            RemoveEntryList(pEntry);
            CTESpinFree(pClientEle,OldIrq);

            // complete the irp
            pIrp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

            CTEMemFree((PVOID)pListenReq);

            return;

        }
        pEntry = pEntry->Flink;
    }

    CTESpinFree(pClientEle,OldIrq);
    return;
}

//----------------------------------------------------------------------------
VOID
NbtCancelSession(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a connect Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp(). It is called when
    the session setup pdu has been sent, and the state is still outbound.

    The cancel routine is only setup when the timer is started to time
    sending the session response pdu.


Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tCONNECTELE          *pConnEle;
    KIRQL                OldIrq;
    PIO_STACK_LOCATION   pIrpSp;
    BOOLEAN              DerefConnEle=FALSE;
    tTIMERQENTRY         *pTimer;
    tDGRAM_SEND_TRACKING *pTracker;
    COMPLETIONCLIENT     pCompletion;
    PVOID                pContext;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtCancelSession: Got a Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NbtCancelSession: ERROR - Invalid Connection Handle\n", 0);
        return;
    }

    NbtTrace(NBT_TRACE_OUTBOUND, ("Cancel TDI_CONNECT pIrp %p ConnEle=%p LowerConn=%p, ClientEle=%p",
                            pIrp, pConnEle, pConnEle->pLowerConnId, pConnEle->pClientEle));

#ifdef RASAUTODIAL
    //
    // Cancel the automatic connection if one's
    // in progress.  If we don't find the
    // connection block in the automatic
    // connection driver, then it's already
    // been completed.
    //
    if (pConnEle->fAutoConnecting)
    {
        if (!NbtCancelPostConnect(pIrp))
        {
            return;
        }
    }
#endif // RASAUTODIAL

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if ((!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN)) ||
        (!(pConnEle->pIrp)) ||                  // the irp could get completed while acquiring the lock
        (!(pTracker = (tDGRAM_SEND_TRACKING *)pConnEle->pIrpRcv)))
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: no tracker", pIrp));
        return;
    }

    pTracker->Flags |= TRACKER_CANCELLED;

    if (pTimer = pTracker->pTimer)          // check for SessionStartupTimeout
    {
        pTracker->pTimer = NULL;
        //
        // stop the timer and only continue if the timer was stopped before
        // it expired
        //
        StopTimer(pTimer, &pCompletion, &pContext);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: pCompletion %p", pIrp, pCompletion));

        //
        // pCompletion will be set if the timer had not expired
        // We want to cause a forced timeout, so we will just call the
        // timeout routine with STATUS_CANCELLED
        //
        if (pCompletion)
        {
            (*pCompletion) (pContext, STATUS_CANCELLED);
        }
    }
    else if (pConnEle->state == NBT_SESSION_OUTBOUND)
    {
        //
        // for some reason there is no timer, but the connection is still
        // outbound, so call the timer completion routine to kill off
        // the connection.
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p", pIrp));
        SessionStartupTimeout (pTracker, ULongToPtr(STATUS_CANCELLED), (PVOID)1);
    }
    else
    {
        //
        // Free the lock
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return;
}

//----------------------------------------------------------------------------
VOID
NbtCancelConnect(
    IN PDEVICE_OBJECT pDeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles cancelling an NTConnect Irp - which has been
    passed down by a client (e.g. net view).  Typically, when the request
    succeeds on another adapter, it will issue this cancel.
    On receiving the cancel, if we are processing a Local IRP, we just
    pass the cancel on to the Local Irp which will complete this Irp also
    in its Completion Routine.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    IN PIRP                 pLocalIrp;
    tCONNECTELE             *pConnEle;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:NbtCancelConnect ********** Got an Irp Cancel !!! **********\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = pIrpSp->FileObject->FsContext;

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NbtCancelConnect: ERROR - Invalid Connection Handle\n", 0);
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
        return;
    }

    NbtTrace(NBT_TRACE_OUTBOUND, ("Cancel Connect pIrp %p: pConnEle %p", pIrp, pConnEle));

    if ((pConnEle) &&
        (pLocalIrp = pConnEle->pIrp))
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.NbtCancelConnect: pClientIrp=<%x>, pLocalIrp=<%x>, Device=<%x>, CancelR=<%x>\n",
                pIrp, pLocalIrp, pDeviceContext, pLocalIrp->CancelRoutine));
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
        IoCancelIrp(pLocalIrp);
    }
    else
    {
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
    }

    return;
}


//----------------------------------------------------------------------------
VOID
NbtCancelReceive(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a listen Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tCONNECTELE          *pConnEle;
    tLOWERCONNECTION     *pLowerConn;
    KIRQL                OldIrq;
    KIRQL                OldIrq1;
    PLIST_ENTRY          pHead;
    PLIST_ENTRY          pEntry;
    PIO_STACK_LOCATION   pIrpSp;
    PIRP                 pRcvIrp;


    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtCancelReceive: Got a Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NbtCancelReceive: ERROR - Invalid Connection Handle\n", 0);
        return;
    }

    NbtTrace(NBT_TRACE_INBOUND, ("Cancel Receive Irp %p ConnEle=%p LowerConn=%p, ClientEle=%p",
                            pIrp, pConnEle, pConnEle->pLowerConnId, pConnEle->pClientEle));
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    pLowerConn = pConnEle->pLowerConnId;
    if (pLowerConn)
    {
        CTESpinLock(pLowerConn,OldIrq);
    }

    if (pConnEle->Verify == NBT_VERIFY_CONNECTION)
    {
        // now search the connection's receive queue looking for this Irp
        //
        pHead = &pConnEle->RcvHead;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pRcvIrp = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);
            if (pRcvIrp == pIrp)
            {
                RemoveEntryList(pEntry);

                // complete the irp
                pIrp->IoStatus.Status = STATUS_CANCELLED;

                if (pLowerConn)
                {
                    CTESpinFree(pLowerConn,OldIrq);
                }
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

                return;
            }
            pEntry = pEntry->Flink;
        }
    }

    if (pLowerConn)
    {
        CTESpinFree(pLowerConn,OldIrq);
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    return;
}


//----------------------------------------------------------------------------
VOID
NbtCancelRcvDgram(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a listen Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tCLIENTELE           *pClientEle;
    KIRQL                OldIrq;
    PLIST_ENTRY          pHead;
    PLIST_ENTRY          pEntry;
    PIO_STACK_LOCATION   pIrpSp;
    tRCVELE              *pRcvEle;


    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtCancelRcvDgram: Got a Cancel !!! *****************\n"));

    //
    // Need to acquire JointLock before Cancel lock!
    // Bug#: 124405
    //
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    IoAcquireCancelSpinLock(&pIrp->CancelIrql);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pClientEle = (tCLIENTELE *)pIrpSp->FileObject->FsContext;

    NbtTrace(NBT_TRACE_RECVDGRAM, ("Cancel RcvDgram Irp %p ClientEle=%p", pIrp, pClientEle));

    if (NBT_VERIFY_HANDLE (pClientEle, NBT_VERIFY_CLIENT))
    {
        // now search the client's listen queue looking for this connection
        //
        pHead = &pClientEle->RcvDgramHead;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pRcvEle = CONTAINING_RECORD(pEntry,tRCVELE,Linkage);
            if (pRcvEle->pIrp == pIrp)
            {
                RemoveEntryList(pEntry);

                // complete the irp
                pIrp->IoStatus.Status = STATUS_CANCELLED;

                IoReleaseCancelSpinLock(pIrp->CancelIrql);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

                CTEMemFree((PVOID)pRcvEle);

                return;
            }
            pEntry = pEntry->Flink;
        }
    }
    else
    {
        ASSERTMSG ("Nbt.NbtCancelRcvDgram: ERROR - Invalid Address Handle\n", 0);
    }

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return;

}

//----------------------------------------------------------------------------

VOID
NbtCancelFindName(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a FindName Irp - which has
    been passed down by a client (e.g. ping).  Typically, when ping succeeds
    on another adapter, it will issue this cancel.
    On receiving the cancel, we stop any timer that is running in connection
    with name query and then complete the irp with status_cancelled.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    PIO_STACK_LOCATION      pIrpSp;


    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtCancelFindName: Got a Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pTracker = pIrpSp->Parameters.Others.Argument4;

    NbtTrace(NBT_TRACE_NAMESRV, ("Cancel FindName Irp %p pTracker=%p", pIrp, pTracker));

    //
    // We want to ensure that the tracker supplied by FsContext
    // is the right Tracker for this Irp
    //
    if (pTracker && (pIrp == pTracker->pClientIrp))
    {
        //
        // if pClientIrp still valid, completion routine hasn't run yet: go ahead
        // and complete the irp here
        //
        pIrpSp->Parameters.Others.Argument4 = NULL;
        pTracker->pClientIrp = NULL;
        IoReleaseCancelSpinLock(pIrp->CancelIrql);

        NTIoComplete(pIrp,STATUS_CANCELLED,(ULONG)-1);

    } else
    {
        //
        // the completion routine has run.
        //
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
    }

    return;
}


//----------------------------------------------------------------------------
VOID
NbtCancelLmhSvcIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a DNS name query Irp  or
    the CheckIpAddrs Irp that is passed down to NBT from Lmhsvc

    This routine will get the Resource Lock, and Null the Irp ptr in the
    DnsQueries or CheckAddr structure (as approp) and then return the irp.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tLMHSVC_REQUESTS    *pLmhSvcRequest = NULL;
    KIRQL               OldIrq;


    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (pIrp == CheckAddr.QueryIrp)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtCancelLmhSvcIrp: Got a Cancel on CheckAddr Irp !!! *****************\n"));

        NbtTrace(NBT_TRACE_NAMESRV, ("Cancel LmhSvc CheckAddr Irp %p", pIrp));
        pLmhSvcRequest = &CheckAddr;
    }
    else if (pIrp == DnsQueries.QueryIrp)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtCancelLmhSvcIrp: Got a Cancel on DnsQueries Irp !!! *****************\n"));

        NbtTrace(NBT_TRACE_NAMESRV, ("Cancel LmhSvc DnsQueries Irp %p", pIrp));
        pLmhSvcRequest = &DnsQueries;
    }

    if (pLmhSvcRequest)
    {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pLmhSvcRequest->QueryIrp = NULL;
        pLmhSvcRequest->pIpAddrBuf = NULL;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return;
}

//----------------------------------------------------------------------------
VOID
NbtCancelDisconnectWait(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a Disconnect Wait Irp - which has
    been passed down by a client so that when a disconnect occurs this
    irp will complete and inform the client.  The action here is to simply
    complete the irp with status cancelled.
    down to NBT from Lmhsvc, for the purpose of resolving a name with DNS.
    Nbt will complete this irp each time it has a name to resolve with DNS.

    This routine will get the Resource Lock, and Null the Irp ptr in the
    DnsQueries structure and then return the irp.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tCONNECTELE          *pConnEle;
    PIO_STACK_LOCATION   pIrpSp;
    CTELockHandle           OldIrq;


    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Got a Disc Wait Irp Cancel !!! *****************\n"));


    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    CTESpinLock(pConnEle,OldIrq);

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NbtCancelDisconnectWait: ERROR - Invalid Connection Handle\n", 0);
        pIrp->IoStatus.Status = STATUS_INVALID_HANDLE;
    }
    else if (pConnEle->pIrpClose == pIrp)
    {
        pConnEle->pIrpClose = NULL;
        pIrp->IoStatus.Status = STATUS_CANCELLED;
    }

    CTESpinFree(pConnEle,OldIrq);

    IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

    return;
}

//----------------------------------------------------------------------------
VOID
NbtCancelWaitForLmhSvcIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a Query to DNS, so that the client's
    irp can be returned to the client.  This cancellation is instigated
    by the client (i.e. RDR).

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    BOOLEAN                 FoundIt = FALSE;
    NBT_WORK_ITEM_CONTEXT   *Context;
    CTELockHandle           OldIrq;
    tDGRAM_SEND_TRACKING    *pTracker;
    PVOID                   pClientCompletion;
    PVOID                   pClientContext;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;


    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtCancelWaitForLmhSvcIrp: Got a Cancel !!! *****************\n"));

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    //
    // First check the lmhost list, then the CheckAddr list, then the Dns list
    //
    if (!(Context = FindLmhSvcRequest (DeviceContext, pIrp, &LmHostQueries)))
    {
        if (!(Context = FindLmhSvcRequest (DeviceContext, pIrp, &CheckAddr)))
        {
            Context = FindLmhSvcRequest (DeviceContext, pIrp, &DnsQueries);
        }
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    NbtTrace(NBT_TRACE_NAMESRV, ("Cancel WaitForLmhsvc Irp %p", pIrp));

    //
    // Now complete the clients request to return the irp to the client
    //
    if (Context)
    {
        //
        // this is the name Query tracker
        //
        pTracker = Context->pTracker;
        pClientCompletion = Context->ClientCompletion;
        pClientContext = Context->pClientContext;

        // for dns names (NameLen>16), pTracker would be NULL
        if (pTracker)
        {
            // name did not resolve, so delete from table
            SetNameState (pTracker->pNameAddr, NULL, FALSE);
            NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
        }

        //
        // this should complete any name queries that are waiting on
        // this first name query - i.e. queries to the resolving name
        //
        CompleteClientReq(pClientCompletion, pClientContext, STATUS_CANCELLED);

        CTEMemFree(Context);
    }
}


//----------------------------------------------------------------------------
VOID
NbtCancelDgramSend(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling of a Datagram Send.  The action here is to simply
    complete the irp with status cancelled.

    This routine will Null the Irp ptr in the Tracker structure (if available) so that
    SendDgramContinue does not find it.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    PIO_STACK_LOCATION      pIrpSp;
    CTELockHandle           OldIrq;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtCancelDgramSend: Got a DatagramSend Irp Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pTracker = pIrpSp->Parameters.Others.Argument4;

    NbtTrace(NBT_TRACE_SENDDGRAM, ("Cancel SendDgram Irp %p", pIrp));

    if ((NBT_VERIFY_HANDLE (pTracker, NBT_VERIFY_TRACKER)) &&
        (pTracker->pClientIrp == pIrp))
    {
        pTracker->pClientIrp = NULL;
        pIrpSp->Parameters.Others.Argument4 = NULL;
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        IoReleaseCancelSpinLock(pIrp->CancelIrql);

        NTIoComplete(pIrp,STATUS_CANCELLED,(ULONG)-1);
    }
    else
    {
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
    }

    return;
}

int
check_unicode_string(IN PUNICODE_STRING str)
{
    try {
        ProbeForRead(str, sizeof (UNICODE_STRING), sizeof(BYTE));
        if ((str->MaximumLength <= 0) || (str->Length <= 0) || (str->Length >= str->MaximumLength)) {
            return (-1);
        }
        ProbeForRead(str->Buffer, str->MaximumLength, sizeof(WCHAR));
        ASSERT((str->Length&1) == 0);
        if (str->Buffer[str->Length/sizeof(WCHAR)]) {
            return (-1);
        }
        return 0;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrint (("Nbt.check_unicode_string: Exception <0x%x> trying to access unicode string 0x%x\n",
            GetExceptionCode(), str));
        return (-1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\ntpnp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NTPNP.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the
    NBT Transport and other routines that are specific to the NT implementation
    of a driver.

Author:

    Earle R. Horton (earleh) 08-Nov-1995

Revision History:

--*/


#include "precomp.h"
#include "ntddip.h"     // Needed for PNETBT_PNP_RECONFIG_REQUEST
#include "ntprocs.h"
#include <tcpinfo.h>
#include <tdiinfo.h>
#include "ntpnp.tmh"

#ifdef _NETBIOSLESS
NTSTATUS
NbtSpecialDeviceAdd(
    PUNICODE_STRING pucBindName,
    PUNICODE_STRING pucExportName,
    PWSTR pKeyName,
    USHORT DefaultSessionPort,
    USHORT DefaultDatagramPort
    );

NTSTATUS
NbtSpecialReadRegistry(
    PWSTR pKeyName,
    tDEVICECONTEXT *pDeviceContext,
    USHORT DefaultSessionPort,
    USHORT DefaultDatagramPort
    );
#endif

tDEVICECONTEXT *
CheckAddrNotification(
    IN PTA_ADDRESS         Addr,
    IN PUNICODE_STRING     pDeviceName,
    OUT ULONG*  IpAddr
    );

extern HANDLE   TdiClientHandle;
extern HANDLE   TdiProviderHandle;
DWORD    AddressCount = 0;

NET_DEVICE_POWER_STATE     LastSystemPowerState = NetDeviceStateD0;   // by default

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NbtNotifyTdiClients)
#pragma CTEMakePageable(PAGE, NbtAddressAdd)
#pragma CTEMakePageable(PAGE, NbtAddNewInterface)
#pragma CTEMakePageable(PAGE, NbtDeviceAdd)
#pragma CTEMakePageable(PAGE, TdiAddressArrival)
#pragma CTEMakePageable(PAGE, TdiAddressDeletion)
#pragma CTEMakePageable(PAGE, TdiBindHandler)
#pragma CTEMakePageable(PAGE, NbtCreateSmbDevice)
#pragma CTEMakePageable(PAGE, NbtSpecialReadRegistry)
#pragma CTEMakePageable(PAGE, NbtPnPPowerComplete)
#pragma CTEMakePageable(PAGE, TdiPnPPowerHandler)
#pragma CTEMakePageable(PAGE, LookupDeviceInRegistry)
#pragma CTEMakePageable(PAGE, CheckAddrNotification)
#endif
//*******************  Pageable Routine Declarations ****************



//
// This used at the boot time.
// We shouldn't call TdiProviderReady until all the interfaces
// we know so far have been initialized
//
// TcpipReady: set to TRUE when we receive TdiProviderReady from IP
// NumIfBeingIndicated: the # of interfaces being indicated to our clients
// JustBooted: set to FALSE after we call TdiProviderReady
//

DWORD  JustBooted = TRUE;
#define IsBootTime()    (InterlockedExchange(&JustBooted, FALSE))

//#if DBG
//
// TcpipReady is for debugging purpose only.
//
// BootTimeCounter is initialized to ONE which
// take it into account.
//
int    TcpipReady = FALSE;
//#endif

LONG   BootTimeCounter = 1;     // For the IP's ProviderReady



void
NbtUpBootCounter(void)
{
    if (!JustBooted) {
        return;
    }

    ASSERT(BootTimeCounter >= 0);

    InterlockedIncrement(&BootTimeCounter);
}

void
NbtDownBootCounter(void)
{
    LONG    CounterSnapshot;

    if (!JustBooted) {
        return;
    }

    ASSERT(BootTimeCounter > 0);
    CounterSnapshot = InterlockedDecrement(&BootTimeCounter);

    if (!CounterSnapshot && IsBootTime()) {

        //
        // Just try our best
        //
        // The caller always call us at PASSIVE_LEVEL except from
        // StartProcessNbtDhcpRequests, a timer routine which could
        // be called at DISPATCH_LEVEL
        //
        if (KeGetCurrentIrql() == PASSIVE_LEVEL) {

            TdiProviderReady (TdiProviderHandle);   // Notify our clients now

        } else {

            //
            // Although this is a benign assert, we still want it
            // to capture the normal cases in which this function
            // should be called at PASSIVE_LEVEL.
            //
            ASSERT (0);

        }

    }
}

static
IsIPv6Interface(
    PUNICODE_STRING      pDeviceName
    )
{
    return (pDeviceName->Length >= 28 && pDeviceName->Buffer[13] == '6');
}

//----------------------------------------------------------------------------
tDEVICECONTEXT *
NbtFindAndReferenceDevice(
    PUNICODE_STRING      pucBindName,
    BOOLEAN              fNameIsBindName
    )
{
    PLIST_ENTRY         pHead;
    PLIST_ENTRY         pEntry;
    tDEVICECONTEXT      *pDeviceContext;
    CTELockHandle       OldIrq;
    PUNICODE_STRING     pucNameToCompare;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pHead = &NbtConfig.DeviceContexts;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        pDeviceContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
        //
        // Reference this device so that it doesn't disappear when we release the lock!
        //
        NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        //
        // Set the right type of name to compare against
        //
        if (fNameIsBindName)
        {
            pucNameToCompare = &pDeviceContext->BindName;
        }
        else
        {
            pucNameToCompare = &pDeviceContext->ExportName;
        }

        //
        // Use case-insensitive compare since registry is case-insensitive
        //
        if (RtlCompareUnicodeString(pucBindName, pucNameToCompare, TRUE) == 0)
        {
            //
            // We have already Referenced this device above
            //
            return (pDeviceContext);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq);

        pEntry = pEntry->Flink;
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    return (tDEVICECONTEXT *)NULL;
}

VOID
NbtNotifyTdiClients(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  enum eTDI_ACTION    Action
    )
/*++

Routine Description:

    This is where all Tdi registrations and Deregistrations occur
    ASSUMPTION:  Only 1 thread will running this request at any time

Arguments:

    None.

Return Value:

    None (since this is a Worker thread)

--*/

{
    CTELockHandle       OldIrq;
    NTSTATUS            status = STATUS_SUCCESS;
    HANDLE              NetAddressRegistrationHandle, DeviceRegistrationHandle;
    PLIST_ENTRY         pEntry;

    CTEPagedCode();

    NbtTrace(NBT_TRACE_PNP, ("ExportName=%Z BindName=%Z Action=%d",
            &pDeviceContext->ExportName, &pDeviceContext->BindName, Action));
    switch (Action)
    {
        case NBT_TDI_REGISTER:
        {
            //
            // Add the "permanent" name to the local name table.  This is the IP
            // address of the node padded out to 16 bytes with zeros.
            //
#ifdef _NETBIOSLESS
            if (!IsDeviceNetbiosless(pDeviceContext))
#endif
            {
                NbtAddPermanentName(pDeviceContext);
            }

            //
            // If the device was not registered with TDI, do so now.
            //
            if (!pDeviceContext->DeviceRegistrationHandle)
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.NbtNotifyTdiClients: Calling TdiRegisterDeviceObject ...\n"));

                status = TdiRegisterDeviceObject( &pDeviceContext->ExportName,
                                             &pDeviceContext->DeviceRegistrationHandle);
                if (!NT_SUCCESS(status))
                {
                    pDeviceContext->DeviceRegistrationHandle = NULL;
                }
                NbtTrace(NBT_TRACE_PNP, ("RegisterDeviceObject: ExportName=%Z BindName=%Z status=%!status!",
                    &pDeviceContext->ExportName, &pDeviceContext->BindName, status));

                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.NbtNotifyTdiClients: TdiRegisterDeviceObject for <%x> returned <%x>\n",
                        pDeviceContext, status));
            }

            //
            // If the Net address was not registered with TDI, do so now.
            //
            if ((!pDeviceContext->NetAddressRegistrationHandle) &&
#ifdef _NETBIOSLESS
                (!IsDeviceNetbiosless(pDeviceContext)) &&
#endif
                (pDeviceContext->pPermClient))
            {
                TA_NETBIOS_ADDRESS  PermAddress;

                PermAddress.Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
                PermAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
                PermAddress.Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
                CTEMemCopy( PermAddress.Address[0].Address[0].NetbiosName,
                            pDeviceContext->pPermClient->pAddress->pNameAddr->Name,
                            NETBIOS_NAME_SIZE);

                status = TdiRegisterNetAddress(
                            (PTA_ADDRESS) PermAddress.Address,
                            &pDeviceContext->ExportName,
                            (PTDI_PNP_CONTEXT) &pDeviceContext->Context2,
                            &pDeviceContext->NetAddressRegistrationHandle);

                if (!NT_SUCCESS(status))
                {
                    pDeviceContext->NetAddressRegistrationHandle = NULL;
                }
                NbtTrace(NBT_TRACE_PNP, ("RegisterNetAddress: ExportName=%Z BindName=%Z status=%!status!",
                    &pDeviceContext->ExportName, &pDeviceContext->BindName, status));

                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.NbtNotifyTdiClients: TdiRegisterNetAddress for <%x> returned <%x>\n",
                        pDeviceContext, status));
            }
            break;
        }

        case NBT_TDI_DEREGISTER:
        {
            if (NetAddressRegistrationHandle = pDeviceContext->NetAddressRegistrationHandle)
            {
                pDeviceContext->NetAddressRegistrationHandle = NULL;
                status = TdiDeregisterNetAddress (NetAddressRegistrationHandle);

                NbtTrace(NBT_TRACE_PNP, ("DeregisterNetAddress: ExportName=%Z BindName=%Z status=%!status!",
                    &pDeviceContext->ExportName, &pDeviceContext->BindName, status));
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.NbtNbtNotifyTdiClients: TdiDeregisterNetAddress<%x> returned<%x>\n",
                        pDeviceContext, status));
            }

            if (DeviceRegistrationHandle = pDeviceContext->DeviceRegistrationHandle)
            {
                pDeviceContext->DeviceRegistrationHandle = NULL;
                status = TdiDeregisterDeviceObject (DeviceRegistrationHandle);

                NbtTrace(NBT_TRACE_PNP, ("DeregisterDeviceObject: ExportName=%Z BindName=%Z status=%!status!",
                    &pDeviceContext->ExportName, &pDeviceContext->BindName, status));
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.NbtNotifyTdiClients: TdiDeregisterDeviceObject<%x> returned<%x>\n",
                        pDeviceContext, status));
            }

            //
            // The permanent name is a function of the MAC address so remove
            // it since the Address is going away
            //
#ifdef _NETBIOSLESS
            if (!IsDeviceNetbiosless(pDeviceContext))
#endif
            {
                NbtRemovePermanentName(pDeviceContext);
            }

            break;
        }

        default:
            KdPrint(("Nbt.NbtNotifyTdiClients: ERROR: Invalid Action=<%x> on Device <%x>\n",
                Action, pDeviceContext));
    }
}

VOID
NbtUpdateSmbBinding(
    VOID
    )
{
    tDEVICECONTEXT *pSavedSmbDevice = NULL;
    KIRQL OldIrq = 0;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (pNbtSmbDevice && !gbDestroyingSmbDevice) {
        pSavedSmbDevice = pNbtSmbDevice;
        NBT_REFERENCE_DEVICE (pSavedSmbDevice, REF_DEV_SMB_BIND, TRUE);
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (pSavedSmbDevice) {

        NETBT_SMB_BIND_REQUEST  SmbRequest = { 0 };

        SmbRequest.RequestType = SMB_SERVER;
        SmbRequest.MultiSZBindList = NbtConfig.pServerBindings;
        SmbRequest.pDeviceName = NULL;
        SmbRequest.PnPOpCode = TDI_PNP_OP_ADD;

        if (SmbRequest.MultiSZBindList) {
            NbtSetSmbBindingInfo2(
                    pSavedSmbDevice,
                    &SmbRequest
                    );
        }

        SmbRequest.RequestType = SMB_CLIENT;
        SmbRequest.MultiSZBindList = NbtConfig.pClientBindings;
        SmbRequest.pDeviceName = NULL;
        SmbRequest.PnPOpCode = TDI_PNP_OP_ADD;
        if (SmbRequest.MultiSZBindList) {
            NbtSetSmbBindingInfo2(
                    pSavedSmbDevice,
                    &SmbRequest
                    );
        }
        NBT_DEREFERENCE_DEVICE (pSavedSmbDevice, REF_DEV_SMB_BIND, FALSE);
    }
}

VOID
SmbNotifyTdiClients (
    IN  enum eTDI_ACTION    Action
    )
{
    tDEVICECONTEXT *pSavedSmbDevice = NULL;
    KIRQL OldIrq = 0;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (pNbtSmbDevice && !gbDestroyingSmbDevice) {
        pSavedSmbDevice = pNbtSmbDevice;
        NBT_REFERENCE_DEVICE (pSavedSmbDevice, REF_DEV_SMB_BIND, TRUE);
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (pSavedSmbDevice) {
        NbtNotifyTdiClients (pSavedSmbDevice, Action);
        NBT_DEREFERENCE_DEVICE (pSavedSmbDevice, REF_DEV_SMB_BIND, FALSE);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
NbtAddressAdd(
    ULONG           IpAddr,
    tDEVICECONTEXT  *pDeviceContext,
    PUNICODE_STRING pucBindString
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    tADDRARRAY          DeviceAddressArray;
    tIPADDRESS          pIpAddresses[MAX_IP_ADDRS];
    tIPADDRESS          SubnetMask;
    ULONG               NumAddressesRead;

    CTEPagedCode();

    ASSERT(pucBindString && IpAddr);

    //
    // Find the bind and export devices to use from the device
    // described in the registry that uses this address.
    //
    if (status != STATUS_SUCCESS) {
        return status;
    }

    status = LookupDeviceInRegistry(pucBindString, &DeviceAddressArray, NULL);
    if (!NT_SUCCESS(status)) {
        KdPrint(("netbt!NbtAddressAdd: Cannot find device in the registry: status <%x>\n", status));
        NbtTrace(NBT_TRACE_PNP, ("BindName=%Z IP=%!ipaddr! status=%!status!",
                    pucBindString, IpAddr, status));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Fetch a static IP address from the registry.
    //
    *pIpAddresses = 0;
    status = GetIPFromRegistry (pucBindString,
                                pIpAddresses,
                                &SubnetMask,
                                MAX_IP_ADDRS,
                                &NumAddressesRead,
                                NBT_IP_STATIC);

    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint (("Nbt.NbtAddressAdd: GetIPFromRegistry for NBT_IP_STATIC returned <%x>\n",status));
    NbtTrace(NBT_TRACE_PNP, ("GetIPFromRegistry return status=%!status! for NBT_IP_STATIC BindName=%Z IP=%!ipaddr!",
                    status, pucBindString, IpAddr));

    if ((status != STATUS_SUCCESS) || (*pIpAddresses != IpAddr)) {
        //
        // This one doesn't have a valid static address.  Try DHCP.
        //
        *pIpAddresses = 0;              // Cleanup any previously-read entries!
        status = GetIPFromRegistry (pucBindString,
                                    pIpAddresses,
                                    &SubnetMask,
                                    MAX_IP_ADDRS,
                                    &NumAddressesRead,
                                    NBT_IP_DHCP);
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint (("Nbt.NbtAddressAdd: GetIPFromRegistry for NBT_IP_DHCP returned <%x>\n",status));
        NbtTrace(NBT_TRACE_PNP, ("GetIPFromRegistry return status=%!status! for NBT_IP_DHCP BindName=%Z IP=%!ipaddr!",
                    status, pucBindString, IpAddr));
    }

    if ((status != STATUS_SUCCESS) || (*pIpAddresses != IpAddr)) {
        //
        // Check for Autoconfiguration IP address
        //
        *pIpAddresses = 0;              // Cleanup any previously-read entries!
        status = GetIPFromRegistry (pucBindString,
                                    pIpAddresses,
                                    &SubnetMask,
                                    MAX_IP_ADDRS,
                                    &NumAddressesRead,
                                    NBT_IP_AUTOCONFIGURATION);
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint (("Nbt.NbtAddressAdd: GetIPFromRegistry for NBT_IP_AUTOCONFIGURATION returned <%x>\n",
                status));
        NbtTrace(NBT_TRACE_PNP, ("GetIPFromRegistry return status=%!status! for NBT_IP_AUTO BindName=%Z IP=%!ipaddr!",
                    status, pucBindString, IpAddr));
    }

    //
    // The Device must have been created beforehand by using the BindHandler
    //
    if ((status == STATUS_SUCCESS) && (*pIpAddresses == IpAddr)) {
        BOOLEAN     IsDuplicateNotification = FALSE;
#ifdef MULTIPLE_WINS
        int i;
#endif

        pDeviceContext->RasProxyFlags = DeviceAddressArray.RasProxyFlags;
        pDeviceContext->EnableNagling = DeviceAddressArray.EnableNagling;
        //
        // Initialize the WINs server addresses
        //
        if ((IpAddr == pDeviceContext->IpAddress) &&
            (DeviceAddressArray.NetbiosEnabled == pDeviceContext->NetbiosEnabled))
        {
            IsDuplicateNotification = TRUE;
            NbtTrace(NBT_TRACE_PNP, ("Duplicate notification: %Z %!ipaddr!", pucBindString, IpAddr));
        }

        pDeviceContext->lNameServerAddress  = DeviceAddressArray.NameServerAddress;
        pDeviceContext->lBackupServer       = DeviceAddressArray.BackupServer;
        pDeviceContext->RefreshToBackup     = 0;
        pDeviceContext->SwitchedToBackup    = 0;
#ifdef MULTIPLE_WINS
        pDeviceContext->lNumOtherServers    = DeviceAddressArray.NumOtherServers;
        pDeviceContext->lLastResponsive     = 0;
        for (i = 0; i < DeviceAddressArray.NumOtherServers; i++) {
            pDeviceContext->lOtherServers[i] = DeviceAddressArray.Others[i];
        }
#endif
#ifdef _NETBIOSLESS
        pDeviceContext->NetbiosEnabled       = DeviceAddressArray.NetbiosEnabled;
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("NbtAddressAdd: %wZ, enabled = %d\n",
                 &pDeviceContext->ExportName, pDeviceContext->NetbiosEnabled));
        NbtTrace(NBT_TRACE_PNP, ("NetbiosEnabled=%x: %Z %!ipaddr!",
                pDeviceContext->NetbiosEnabled, pucBindString, IpAddr));
#endif

        //
        // Open the addresses with the transports
        // these are passed into here in the reverse byte order, wrt to the IOCTL
        // from DHCP.
        //
        if (IsDuplicateNotification) {
            status = STATUS_UNSUCCESSFUL;
        } else {
            ULONG       i;

            //
            // We may have read more than Ip address for this Device
            // so save all of them
            //
            if (NumAddressesRead > 1) {
                for (i=1; i<NumAddressesRead; i++) {
                    pDeviceContext->AdditionalIpAddresses[i-1] = pIpAddresses[i];
                }
            }
            ASSERT (NumAddressesRead > 0);
#if 0
            //
            // TcpIp does not support opening of multiple addresses
            // per handle, so disable this option for now!
            //
            pDeviceContext->NumAdditionalIpAddresses = NumAddressesRead - 1;
#endif
            pDeviceContext->AssignedIpAddress = IpAddr;

            NbtNewDhcpAddress(pDeviceContext,htonl(*pIpAddresses),htonl(SubnetMask));

            NbtUpdateSmbBinding();
        }
    } else {
        KdPrint (("Nbt.NbtAddressAdd: ERROR -- pDeviceContext=<%x>, status=<%x>, IpAddr=<%x>, ulIpAddress=<%x>\n",
            pDeviceContext, status, IpAddr, *pIpAddresses));
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

NTSTATUS
NbtAddNewInterface (
    IN  PIRP            pIrp,
    IN  PVOID           *pBuffer,
    IN  ULONG            Size
    )
/*++

Routine Description:

    Creates a device context by coming up with a unique export string to name
    the device.

Arguments:

Return Value:

Notes:


--*/
{
    ULONG               nextIndex = InterlockedIncrement(&NbtConfig.InterfaceIndex);
    WCHAR               Suffix[16];
    WCHAR               Bind[60] = L"\\Device\\If";
    WCHAR               Export[60] = L"\\Device\\NetBt_If";
    UNICODE_STRING      ucSuffix;
    UNICODE_STRING      ucBindStr;
    UNICODE_STRING      ucExportStr;
    NTSTATUS            status;
    ULONG               OutSize;
    BOOLEAN             Attached = FALSE;
    tADDRARRAY          *pAddrArray = NULL;
    tDEVICECONTEXT      *pDeviceContext = NULL;
    PNETBT_ADD_DEL_IF   pAddDelIf = (PNETBT_ADD_DEL_IF)pBuffer;

    CTEPagedCode();

    //
    // Validate output buffer size
    //
    if (Size < sizeof(NETBT_ADD_DEL_IF))
    {
        KdPrint(("Nbt.NbtAddNewInterface: Output buffer too small for struct\n"));
        NbtTrace(NBT_TRACE_PNP, ("Output buffer too small for struct size=%d, required=%d",
                Size, sizeof(NETBT_ADD_DEL_IF)));
        return(STATUS_INVALID_PARAMETER);
    }
    //
    // Create the bind/export strings as:
    //      Bind: \Device\IF<1>   Export: \Device\NetBt_IF<1>
    //      where 1 is a unique interface index.
    //
    ucSuffix.Buffer = Suffix;
    ucSuffix.Length = 0;
    ucSuffix.MaximumLength = sizeof(Suffix);

    RtlIntegerToUnicodeString(nextIndex, 10, &ucSuffix);

    RtlInitUnicodeString(&ucBindStr, Bind);
    ucBindStr.MaximumLength = sizeof(Bind);
    RtlInitUnicodeString(&ucExportStr, Export);
    ucExportStr.MaximumLength = sizeof(Export);

    RtlAppendUnicodeStringToString(&ucBindStr, &ucSuffix);
    RtlAppendUnicodeStringToString(&ucExportStr, &ucSuffix);

    OutSize = FIELD_OFFSET (NETBT_ADD_DEL_IF, IfName[0]) +
               ucExportStr.Length + sizeof(UNICODE_NULL);

    if (Size < OutSize)
    {
        KdPrint(("Nbt.NbtAddNewInterface: Buffer too small for name\n"));
        NbtTrace(NBT_TRACE_PNP, ("Buffer too small for name size=%d, required=%d", Size, OutSize));
        pAddDelIf->Length = ucExportStr.Length + sizeof(UNICODE_NULL);
        pAddDelIf->Status = STATUS_BUFFER_TOO_SMALL;
        pIrp->IoStatus.Information = sizeof(NETBT_ADD_DEL_IF);
        return STATUS_SUCCESS;
    }

    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint(( "Nbt.NbtAddNewInterface: Creating ucBindStr: %ws ucExportStr: %ws\n",
                ucBindStr.Buffer, ucExportStr.Buffer ));
    //
    // Attach to the system process so that all handles are created in the
    // proper context.
    //
    CTEAttachFsp(&Attached, REF_FSP_ADD_INTERFACE);

    status = NbtCreateDeviceObject (&ucBindStr,
                                    &ucExportStr,
                                    &pAddrArray[0],
                                    &pDeviceContext,
                                    NBT_DEVICE_CLUSTER);

    CTEDetachFsp(Attached, REF_FSP_ADD_INTERFACE);

    if (pDeviceContext)
    {
        //
        // Fill up the output buffer with the export name
        //
        RtlCopyMemory(&pAddDelIf->IfName[0], ucExportStr.Buffer, ucExportStr.Length+sizeof(UNICODE_NULL));
        pAddDelIf->Length = ucExportStr.Length + sizeof(UNICODE_NULL);
        pAddDelIf->InstanceNumber = pDeviceContext->InstanceNumber;
        pAddDelIf->Status = STATUS_SUCCESS;
        pIrp->IoStatus.Information = OutSize;
        //
        // By-pass the TDI PnP mechanism for logical interfaces (ie don't register with TDI)
        //
        return (STATUS_SUCCESS);
    }

    NbtTrace(NBT_TRACE_PNP, ("NbtCreateDeviceObject return %!status! for BindName=%Z ExportName=%Z",
            status, &ucBindStr, &ucExportStr));

    return  status;
}


NTSTATUS
NbtDeviceAdd(
    PUNICODE_STRING pucBindString
    )
{
    tDEVICECONTEXT      *pDeviceContext;
    UNICODE_STRING      ucExportString;
    tADDRARRAY          DeviceAddressArray;
    BOOLEAN             Attached = FALSE;
    NTSTATUS            Status;
    PLIST_ENTRY         pHead, pEntry;
    NTSTATUS            dontcarestatus;
    int i;


    CTEPagedCode();

    //
    // Ignore it if we already bind to the device
    //
    if (pDeviceContext = NbtFindAndReferenceDevice (pucBindString, TRUE)) {
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, FALSE);

        KdPrint (("Nbt.NbtDeviceAdd: ERROR: Device=<%ws> already exists!\n", pucBindString->Buffer));
        NbtTrace(NBT_TRACE_PNP, ("Device %Z already exists!", pucBindString));
        return STATUS_SUCCESS;
    }

    //
    // Can we find the new device in registry file? If not, ignore it.
    //
    Status = LookupDeviceInRegistry(pucBindString, &DeviceAddressArray, &ucExportString);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("netbt!NbtDeviceAdd: Cannot find device in the registry: status <%x>\n", Status));
        NbtTrace(NBT_TRACE_PNP, ("LookupDeviceInRegistry return %!status! for device %Z",
            Status, pucBindString));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Attach to the system process so that all handles are created in the
    // proper context.
    //
    CTEAttachFsp(&Attached, REF_FSP_DEVICE_ADD);

    Status = NbtCreateDeviceObject (pucBindString,
                                    &ucExportString,
                                    &DeviceAddressArray,
                                    &pDeviceContext,
                                    NBT_DEVICE_REGULAR);
    CTEMemFree(ucExportString.Buffer);

    CTEDetachFsp(Attached, REF_FSP_DEVICE_ADD);

    //
    // Call Tdi to re-enumerate the addresses for us
    //
    if (NT_SUCCESS (Status)) {
        TdiEnumerateAddresses(TdiClientHandle);
    } else {
        KdPrint (("Nbt.NbtDeviceAdd:  ERROR: NbtCreateDeviceObject returned <%x>\n", Status));
        NbtTrace(NBT_TRACE_PNP, ("NbtCreateDeviceObject return %!status! for device %Z",
            Status, pucBindString));
    }

    return (Status);
}


//  TdiAddressArrival - PnP TDI_ADD_ADDRESS_HANDLER
//              Handles an IP address arriving
//              Called by TDI when an address arrives.
//
//  Input:      Addr            - IP address that's coming.
//
//  Returns:    Nothing.
//
VOID
TdiAddressArrival(
    PTA_ADDRESS Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
{
    ULONG               IpAddr, LastAssignedIpAddress;
    tDEVICECONTEXT      *pDeviceContext;
    PTDI_PNP_CONTEXT    pTdiContext;
    NTSTATUS            status;

    CTEPagedCode();

    pDeviceContext = CheckAddrNotification(Addr, pDeviceName, &IpAddr);
    if (pDeviceContext == NULL) {
        return;
    }

    //
    // Now the device is referenced!!!
    //
    NbtTrace(NBT_TRACE_PNP, ("TdiAddressArrival for %Z, IpAddr=%!ipaddr!, "
            "pDeviceContext->AssignedIpAddress=%!ipaddr!, pDeviceContext->IpAddress=%!ipaddr!",
            pDeviceName, IpAddr, pDeviceContext->AssignedIpAddress, pDeviceContext->IpAddress));

    //
    // Update the PDO in Context2
    //
    pTdiContext = (PTDI_PNP_CONTEXT) &pDeviceContext->Context2;
    pTdiContext->ContextSize = Context->ContextSize;
    pTdiContext->ContextType = Context->ContextType;
    *(PVOID UNALIGNED*) pTdiContext->ContextData = *(PVOID UNALIGNED*) Context->ContextData;

    LastAssignedIpAddress = pDeviceContext->AssignedIpAddress;
    if (NT_SUCCESS (status = NbtAddressAdd(IpAddr, pDeviceContext, pDeviceName))) {
        // Register Smb Device
        // Assumption 1: tdi can assign multiple addresses to same device
        // Assumption 2: tdi will always delete an assignment it made
        // THIS IS CODED FOR ONE ADDRESS PER DEVICE
        // First assigned address wins (and is reference counted)
        if (LastAssignedIpAddress == 0) {
            if ((1 == InterlockedIncrement (&AddressCount)) && (NbtConfig.SMBDeviceEnabled)) {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.TdiAddressArrival:  Registering NetbiosSmb Device\n"));
                SmbNotifyTdiClients (NBT_TDI_REGISTER);
            }
        }
    } else {
        NbtTrace(NBT_TRACE_PNP, ("NbtAddressAdd return %!status! for device %Z",
            status, pDeviceName));
    }

    //
    // Derefenece the device
    //
    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, FALSE);
    SetNodeType();
}

//  TdiAddressDeletion - PnP TDI_DEL_ADDRESS_HANDLER
//              Handles an IP address going away.
//              Called by TDI when an address is deleted. If it's an address we
//              care about we'll clean up appropriately.
//
//  Input:      Addr            - IP address that's going.
//
//  Returns:    Nothing.
//
VOID
TdiAddressDeletion(
    PTA_ADDRESS Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
{
    ULONG IpAddr;
    tDEVICECONTEXT      *pDeviceContext;

    CTEPagedCode();

    pDeviceContext = CheckAddrNotification(Addr, pDeviceName, &IpAddr);
    if (pDeviceContext == NULL) {
        return;
    }

    //
    // Now the device is referenced!!!
    //
    NbtTrace(NBT_TRACE_PNP, ("TdiAddressDeletion for %Z, IpAddr=%!ipaddr!, "
            "pDeviceContext->AssignedIpAddress=%!ipaddr!, pDeviceContext->IpAddress=%!ipaddr!",
            pDeviceName, IpAddr, pDeviceContext->AssignedIpAddress, pDeviceContext->IpAddress));

    // Deregister Smb Device
    // THIS IS CODED FOR ONE ADDRESS PER DEVICE
    // Only deletion of an assigned address wins (and is ref counted)
    if (pDeviceContext->AssignedIpAddress == IpAddr) {
        if ((0 == InterlockedDecrement (&AddressCount))) {
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiAddressDeletion:  Deregistering NetbiosSmb Device\n"));
            SmbNotifyTdiClients (NBT_TDI_DEREGISTER);
        }

        pDeviceContext->AssignedIpAddress = 0;
        if (IpAddr == pDeviceContext->IpAddress) {
            NbtNewDhcpAddress(pDeviceContext, 0, 0);
        }
    }

    //
    // Derefenece the device
    //
    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, FALSE);
    SetNodeType();
}

VOID
TdiBindHandler(
    TDI_PNP_OPCODE  PnPOpCode,
    PUNICODE_STRING pDeviceName,
    PWSTR           MultiSZBindList)
{
    NTSTATUS        Status;
    tDEVICECONTEXT  *pDeviceContext;

    CTEPagedCode();

    switch (PnPOpCode)
    {
        case (TDI_PNP_OP_ADD):
        {
            //
            // Ignore TCPIP6 interface
            //
            if (IsIPv6Interface(pDeviceName)) {
                return;
            }

            Status = NbtDeviceAdd (pDeviceName);
            if (!NT_SUCCESS(Status))
            {
                KdPrint(("Nbt.TdiBindHandler[TDI_PNP_OP_ADD]: ERROR <%x>, AdapterCount=<%x>\n",
                    Status, NbtConfig.AdapterCount));
                NbtLogEvent (EVENT_NBT_CREATE_DEVICE, Status, 0x111);
            }
            NbtTrace(NBT_TRACE_PNP, ("NbtDeviceAdd return %!status! for %Z", Status, pDeviceName));

            break;
        }

        case (TDI_PNP_OP_DEL):
        {
            //
            // If the Device is Valid, Dereference it!
            //
            if (pDeviceContext  = NbtFindAndReferenceDevice (pDeviceName, TRUE))
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.TdiBindHandler[TDI_PNP_OP_DEL]: Dereferencing Device <%wZ>\n",
                        &pDeviceContext->BindName));

                // Deref it since we referenced it above!
                NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, FALSE);

                Status = NbtDestroyDevice (pDeviceContext, TRUE);
                NbtTrace(NBT_TRACE_PNP, ("NbtDestoryDevice return %!status! for %Z", Status, pDeviceName));
            }
            else
            {
                KdPrint(("Nbt.TdiBindHandler[TDI_PNP_OP_DEL]: ERROR -- Device=<%wZ>\n", pDeviceName));
                NbtTrace(NBT_TRACE_PNP, ("NbtFindAndReferenceDevice return NULL for %Z", pDeviceName));
            }

            break;
        }

        case (TDI_PNP_OP_UPDATE):
        {
            tDEVICES            *pBindDevices = NULL;
            tDEVICES            *pExportDevices = NULL;
            tADDRARRAY          *pAddrArray = NULL;

            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiBindHandler[TDI_PNP_OP_UPDATE]:  Got Update Notification\n"));
            //
            // Re-read the registry
            //
            CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
            NbtReadRegistry (&pBindDevices, &pExportDevices, &pAddrArray);
            NbtReadRegistryCleanup (&pBindDevices, &pExportDevices, &pAddrArray);
            CTEExReleaseResource(&NbtConfig.Resource);
            SetNodeType();
            NbtTrace(NBT_TRACE_PNP, ("[TDI_PNP_OP_UPDATE]"));
            break;
        }

        case (TDI_PNP_OP_PROVIDERREADY):
        {
            WCHAR               wcIpDeviceName[60]  = DD_IP_DEVICE_NAME;
            UNICODE_STRING      ucIpDeviceName;

            RtlInitUnicodeString(&ucIpDeviceName, wcIpDeviceName);
            ucIpDeviceName.MaximumLength = sizeof (wcIpDeviceName);

            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiBindHandler[TDI_PNP_OP_NETREADY]: Comparing <%wZ> with <%wZ>\n",
                    pDeviceName, &ucIpDeviceName));
            NbtTrace(NBT_TRACE_PNP, ("[TDI_PNP_OP_NETREADY]: <%Z> <==> <%Z>", pDeviceName, &ucIpDeviceName));

            //
            // Use case-insensitive compare since registry is case-insensitive
            //
            if (RtlCompareUnicodeString(pDeviceName, &ucIpDeviceName, TRUE) == 0)
            {
                //
                // This is the notification we were waiting for from Ip, so now
                // notify our clients of our completion status as a provider!
                //
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.TdiBindHandler[TDI_PNP_OP_NETREADY]:  Got Ip Notification\n"));

//#if DBG
                TcpipReady = TRUE;
//#endif
                NbtDownBootCounter();
            }

            break;
        }

        case (TDI_PNP_OP_NETREADY):
        {
            // Nothing to do!
            NbtTrace(NBT_TRACE_PNP, ("[TDI_PNP_OP_NETREADY]"));
            break;
        }

        default:
        {
            KdPrint(("Nbt.TdiBindHandler: Unknown Opcode=<%x>\n", PnPOpCode));
            NbtTrace(NBT_TRACE_PNP, ("Unknown Opcode=<%x>", PnPOpCode));
            ASSERT (0);
        }
    }
}



tDEVICECONTEXT *
NbtCreateSmbDevice(
    )

/*++

Routine Description:

The model of this device is different from the rest of the Netbt devices in that netbt devices
are per-adapter.  For this device there is only one instance across all adapters.

This is the code that creates the Smb device.  We create it at DriverEntry and Destory it
at driver Unload time.

We try to call existing routines to create the new device, so that we can reuse as much code
as possible and have the new device initialized identically to the other netbt devices.  Then
we customize this device by setting some variables controlling port and endpoint.

In the current design, a message-only Netbt device is only single session.  Different sessions,
or applications, use different Tcp ports.  Each message-only Netbt device is assigned a single
port, such as Smb.  If you want to
support a different application over Netbt, The easiest thing is to instantiate a new message-only
device with a different Tcp port.  Perhaps there is a way to delay the binding of the port on the
client side from device creation to connection creation?

Another idea to consider is to modularize the construction of these message-only devices.  You
could have a table in the registry naming the device, with its unique initialization parameters.
This code could then read the table.

Create and initialize the message special device.
This function is not driven by Pnp because it is not adapter specific.

The idea here was to abstract the details of special devices as much as possible.  The way
the current code is written, you must have a single port for each device.  This means you
typically will get one application for each special device.  Right now the only case is
rdr/srv using message-mode for smb traffic.  In the future, if you had another netbios session
application that wanted an internet pure device, you could just call this routine with the
new parameters.

Two issues that I can think of:
1. The default session name is still hardcoded.  You might want to pass that in here if you
didn't want *smbserver as the session name.
2. Binding is per application.  Currently there is a .Inf file to get Smb bound to the rdr
and srv.  If you have a new application and a new special device, you will need another .inf
file.

Arguments:


Return Value:

    NTSTATUS -

--*/

{
    NTSTATUS                Status;
    BOOLEAN                 Attached = FALSE;
    tDEVICECONTEXT          *pDeviceContext = NULL;
    NBT_WORK_ITEM_CONTEXT   *pContext;
    UNICODE_STRING          ucSmbDeviceBindName;
    UNICODE_STRING          ucSmbDeviceExportName;
    WCHAR                   Path[MAX_PATH];
    UNICODE_STRING          ParamPath;
    OBJECT_ATTRIBUTES       TmpObjectAttributes;
    HANDLE                  Handle;
    ULONG                   Metric;

    CTEPagedCode();

    NbtTrace(NBT_TRACE_PNP, ("Creating Smb device"));

    RtlInitUnicodeString(&ucSmbDeviceBindName, WC_SMB_DEVICE_BIND_NAME);
    ucSmbDeviceBindName.MaximumLength = sizeof (WC_SMB_DEVICE_BIND_NAME);
    RtlInitUnicodeString(&ucSmbDeviceExportName, WC_SMB_DEVICE_EXPORT_NAME);
    ucSmbDeviceExportName.MaximumLength = sizeof (WC_SMB_DEVICE_EXPORT_NAME);

    CTEAttachFsp(&Attached, REF_FSP_CREATE_SMB_DEVICE);

    //
    // Create the SMBDevice
    //
    Status = NbtCreateDeviceObject (&ucSmbDeviceBindName,   // Bind name, ignored, but must match for delete
                                    &ucSmbDeviceExportName, // Export name
                                    NULL,
                                    &pDeviceContext,
                                    NBT_DEVICE_NETBIOSLESS);// message-only Netbt device

    if (NT_SUCCESS(Status))
    {
        pDeviceContext->SessionPort = NbtConfig.DefaultSmbSessionPort;
        pDeviceContext->DatagramPort = NbtConfig.DefaultSmbDatagramPort;
        pDeviceContext->NameServerPort = 0;  // Disable this port for security reasons

        RtlCopyMemory (pDeviceContext->MessageEndpoint, "*SMBSERVER      ", NETBIOS_NAME_SIZE );

        //
        // Here is where we initialize the handles in the special device
        // Create the handles to the transport. This does not depend on dhcp
        // Use LOOP_BACK because we need to put something non-zero here
        //
        // This device is registered based on address notifications
        //
//        Status = NbtCreateAddressObjects (LOOP_BACK, 0, pDeviceContext);
        Status = NbtCreateAddressObjects (INADDR_LOOPBACK, 0, pDeviceContext);
        pDeviceContext->BroadcastAddress = LOOP_BACK;   // Make sure no broadcasts
        if (NT_SUCCESS(Status))
        {
            //
            // Now clear the If lists and add the INADDR_LOOPBACK address
            //
            if (pDeviceContext->hSession)
            {
                NbtSetTcpInfo (pDeviceContext->hSession,
                               AO_OPTION_IFLIST,
                               INFO_TYPE_ADDRESS_OBJECT,
                               (ULONG) TRUE);
                NbtSetTcpInfo (pDeviceContext->hSession,
                               AO_OPTION_ADD_IFLIST,
                               INFO_TYPE_ADDRESS_OBJECT,
                               pDeviceContext->IPInterfaceContext);
            }

            //
            // Now, set the same for the Datagram port
            //
            if ((pDeviceContext->pFileObjects) &&
                (pDeviceContext->pFileObjects->hDgram))
            {
                NbtSetTcpInfo (pDeviceContext->pFileObjects->hDgram,
                               AO_OPTION_IFLIST,
                               INFO_TYPE_ADDRESS_OBJECT,
                               (ULONG) TRUE);
                NbtSetTcpInfo (pDeviceContext->pFileObjects->hDgram,
                               AO_OPTION_ADD_IFLIST,
                               INFO_TYPE_ADDRESS_OBJECT,
                               pDeviceContext->IPInterfaceContext);
            }
            NbtTrace(NBT_TRACE_PNP, ("Successful creating Smb device"));
        }
        else
        {
            KdPrint (("Nbt.NbtCreateSmbDevice: NbtCreateAddressObjects Failed, status = <%x>\n", Status));
            NbtTrace(NBT_TRACE_PNP, ("NbtCreateAddressObject Failed with %!status!", Status));
        }
    }
    else
    {
        KdPrint (("Nbt.NbtCreateSmbDevice: NbtCreateDeviceObject Failed, status = <%x>\n", Status));
        NbtTrace(NBT_TRACE_PNP, ("NbtCreateDeviceObject Failed with %!status!", Status));
    }

    CTEDetachFsp(Attached, REF_FSP_CREATE_SMB_DEVICE);

    return (pDeviceContext);
}



VOID
NbtPnPPowerComplete(
    IN PNET_PNP_EVENT  NetEvent,
    IN NTSTATUS        ProviderStatus
    )
{
    CTEPagedCode();

    TdiPnPPowerComplete (TdiClientHandle, NetEvent, ProviderStatus);
    NbtTrace(NBT_TRACE_PNP, ("[NbtPnPPowerComplete]"));
}


NTSTATUS
TdiPnPPowerHandler(
    IN  PUNICODE_STRING     pDeviceName,
    IN  PNET_PNP_EVENT      PnPEvent,
    IN  PTDI_PNP_CONTEXT    Context1,
    IN  PTDI_PNP_CONTEXT    Context2
    )
{
    tDEVICECONTEXT              *pDeviceContext = NULL;
    NTSTATUS                    status = STATUS_SUCCESS;    // Success by default!
    PNETBT_PNP_RECONFIG_REQUEST PnPEventBuffer = (PNETBT_PNP_RECONFIG_REQUEST) PnPEvent->Buffer;
    PNET_DEVICE_POWER_STATE     pPowerState = (PNET_DEVICE_POWER_STATE) PnPEventBuffer;   // Power requests
    BOOLEAN                     fWait = FALSE;
#ifdef _NETBIOSLESS
    BOOLEAN                     fOldNetbiosEnabledState;
#endif

    CTEPagedCode();

    //
    // Pass the request up first
    //
    if ((pDeviceName) && (pDeviceName->Length)) {
        if (!(pDeviceContext = NbtFindAndReferenceDevice (pDeviceName, TRUE))) {
            return (STATUS_SUCCESS);
        }

#ifdef _NETBIOSLESS
        fOldNetbiosEnabledState = pDeviceContext->NetbiosEnabled;
#endif
    } else if (PnPEvent->NetEvent != NetEventReconfigure) {
        //
        // pDeviceName is not set for Reconfigure events
        // The only valid case for no Device to be specified is Reconfigure!
        //
        return STATUS_UNSUCCESSFUL;
    }

    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint(("Nbt.NbtTdiPnpPowerHandler: Device=<%wZ>, Event=<%d>, C1=<%p>, C2=<%p>\n",
                 pDeviceName, PnPEvent->NetEvent, Context1, Context2 ));
    NbtTrace(NBT_TRACE_PNP, ("Device=<%Z>, Event=<%d>, C1=<%p>, C2=<%p>",
                 pDeviceName, PnPEvent->NetEvent, Context1, Context2));

    switch (PnPEvent->NetEvent)
    {
        case (NetEventQueryPower):
        {
            //
            // Check if we should veto this request
            //
            if ((*pPowerState != NetDeviceStateD0) &&
                (NbtConfig.MinimumRefreshSleepTimeout == 0))
            {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            status = TdiPnPPowerRequest (&pDeviceContext->ExportName, PnPEvent, Context1, Context2, NbtPnPPowerComplete);
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiPnPPowerHandler[QueryPower]: Device=<%x>, PowerState=<%x>, status=<%x>\n",
                    pDeviceContext, *pPowerState, status));
            NbtTrace(NBT_TRACE_PNP, ("[QueryPower]: Device=<%Z>, PowerState=<%x>, status=%!status!",
                    pDeviceName, *pPowerState, status));

            //
            // NetBt doesn't need to do anything here, so we'll just return!
            //
            break;
        }
        case (NetEventSetPower):
        {
            //
            // Check if we should veto this request (if requested by user)
            //
            if ((*pPowerState != NetDeviceStateD0) &&
                (NbtConfig.MinimumRefreshSleepTimeout == 0))
            {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            status = TdiPnPPowerRequest (&pDeviceContext->ExportName, PnPEvent, Context1, Context2, NbtPnPPowerComplete);
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiPnPPowerHandler[SetPower]: Device=<%x>, PowerState=<%d=>%d>, status=<%x>\n",
                    pDeviceContext, LastSystemPowerState, *pPowerState, status));
            NbtTrace(NBT_TRACE_PNP, ("[SetPower]: Device=<%Z>, PowerState=<%x>, status=%!status!",
                    pDeviceName, *pPowerState, status));

            CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);

            if (*pPowerState != LastSystemPowerState)  // this is a state transition
            {
                switch (*pPowerState)
                {
                    case NetDeviceStateD0:
                    {
                        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESH_SLEEPING;

                        if (NbtConfig.pWakeupRefreshTimer)
                        {
                            if (NT_SUCCESS (NTQueueToWorkerThread(NULL, DelayedNbtStopWakeupTimer,
                                                                          NULL,
                                                                          NbtConfig.pWakeupRefreshTimer,
                                                                          NULL, NULL, FALSE)))
                            {
                                NbtConfig.pWakeupRefreshTimer->RefCount++;
                                NbtConfig.pWakeupRefreshTimer = NULL;
                            }

                            // Ignore the return status!    (Best effort!)
                            StartTimer(RefreshTimeout,
                                       NbtConfig.InitialRefreshTimeout/NbtConfig.RefreshDivisor,
                                       NULL,            // context value
                                       NULL,            // context2 value
                                       NULL,
                                       NULL,
                                       NULL,            // This Timer is Global!
                                       &NbtConfig.pRefreshTimer,
                                       0,
                                       FALSE);
                        }
                        break;
                    }

                    case NetDeviceStateD1:
                    case NetDeviceStateD2:
                    case NetDeviceStateD3:
                    {
                        if (LastSystemPowerState != NetDeviceStateD0)  // Don't differentiate bw D1, D2, & D3
                        {
                            break;
                        }

                        //
                        // Reset the Refresh Timer to function accordingly
                        //
                        NbtStopRefreshTimer();
                        ASSERT (!NbtConfig.pWakeupRefreshTimer);
                        NbtConfig.GlobalRefreshState |= NBT_G_REFRESH_SLEEPING;

                        KeClearEvent (&NbtConfig.WakeupTimerStartedEvent);
                        if (NT_SUCCESS (NTQueueToWorkerThread(NULL, DelayedNbtStartWakeupTimer,
                                                                      NULL,
                                                                      NULL,
                                                                      NULL,
                                                                      NULL,
                                                                      FALSE)))
                        {
                            fWait = TRUE;
                        }

                        break;
                    }

                    default:
                    {
                        ASSERT (0);
                    }
                }

                LastSystemPowerState = *pPowerState;
            }

            CTEExReleaseResource(&NbtConfig.Resource);

            if (fWait)
            {
                NTSTATUS   status;
                status = KeWaitForSingleObject (&NbtConfig.WakeupTimerStartedEvent,   // Object to wait on.
                                       Executive,            // Reason for waiting
                                       KernelMode,           // Processor mode
                                       FALSE,                // Alertable
                                       NULL);                // Timeout
                ASSERT(status == STATUS_SUCCESS);
            }

            break;
        }

        case (NetEventQueryRemoveDevice):
        {
            status = TdiPnPPowerRequest (&pDeviceContext->ExportName, PnPEvent, Context1, Context2, NbtPnPPowerComplete);
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiPnPPowerHandler: NetEventQueryRemoveDevice -- status=<%x>\n",status));
            NbtTrace(NBT_TRACE_PNP, ("[NetEventQueryRemoveDevice]: Device=<%Z>, status=%!status!",
                    pDeviceName, status));
            break;
        }
        case (NetEventCancelRemoveDevice):
        {
            status = TdiPnPPowerRequest (&pDeviceContext->ExportName, PnPEvent, Context1, Context2, NbtPnPPowerComplete);
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiPnPPowerHandler: NetEventCancelRemoveDevice -- status=<%x>\n",status));
            NbtTrace(NBT_TRACE_PNP, ("[NetEventCancelRemoveDevice]: Device=<%Z>, status=%!status!",
                    pDeviceName, status));
            break;
        }
        case (NetEventReconfigure):
        {
            //
            // First check if the WINs server entries have been modified
            //
            if (pDeviceContext)
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.TdiPnPPowerHandler: WINs servers have changed for <%x>\n",pDeviceContext));
                status = NTReReadRegistry (pDeviceContext, TRUE);
                NbtTrace(NBT_TRACE_PNP, ("[NetEventReconfigure]: WINs servers have changed for %Z, status=%!status!",
                        pDeviceName, status));
            }
            else    // check the rest of the options
            {
#if 0
// EnumDnsOption is no longer set through the UI, so we can ignore this!
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.TdiPnPPowerHandler: Checking EnumDNS option for <%x>\n",pDeviceContext));

                switch (PnPEventBuffer->enumDnsOption)
                {
                    case (WinsOnly):
                        NbtConfig.UseDnsOnly = FALSE;
                        NbtConfig.ResolveWithDns = FALSE;
                        break;

                    case (DnsOnly):
                        NbtConfig.UseDnsOnly = TRUE;
                        NbtConfig.ResolveWithDns = TRUE;
                        break;

                    case (WinsThenDns):
                        NbtConfig.UseDnsOnly = FALSE;
                        NbtConfig.ResolveWithDns = TRUE;
                        break;

                    default:
                        KdPrint (("Nbt.TdiPnPPowerHandler: ERROR bad option for enumDnsOption <%x>\n",
                                    PnPEventBuffer->enumDnsOption));
                }
#endif  // 0

                if (PnPEventBuffer->fLmhostsEnabled)
                {
                    if ((!NbtConfig.EnableLmHosts) ||       // if the user is re-enabling LmHosts
                        (PnPEventBuffer->fLmhostsFileSet))  // the user wants to use a new LmHosts file
                    {
                        tDEVICES        *pBindDevices=NULL;
                        tDEVICES        *pExportDevices=NULL;
                        tADDRARRAY      *pAddrArray=NULL;

                        IF_DBG(NBT_DEBUG_PNP_POWER)
                            KdPrint (("Nbt.TdiPnPPowerHandler: Reading LmHosts file\n"));


                        //
                        // ReRead the registry for the LmHost options
                        //
                        CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
                        status = NbtReadRegistry (&pBindDevices, &pExportDevices, &pAddrArray);
                        NbtReadRegistryCleanup(&pBindDevices, &pExportDevices, &pAddrArray);
                        CTEExReleaseResource(&NbtConfig.Resource);

                        DelayedNbtResyncRemoteCache(NULL, NULL, NULL, NULL);
                    }
                }
                else
                {
                    NbtConfig.EnableLmHosts = PnPEventBuffer->fLmhostsEnabled;
                }
            }

            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiPnPPowerHandler: NetEventReconfigure -- status=<%x>\n",status));
            NbtTrace(NBT_TRACE_PNP, ("NetEventReconfigure -- %Z status=%!status!", pDeviceName, status));

            break;
        }
        case (NetEventBindList):
        {
            //
            // Just do a general reread of the registry parameters since we could
            // get WINS address change notifications through here!
            //
            if (pDeviceContext)
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.TdiPnPPowerHandler: NetEventBindList request for <%x>\n",pDeviceContext));
                status = NTReReadRegistry (pDeviceContext, TRUE);
            }
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiPnPPowerHandler: NetEventBindList -- status=<%x>\n",status));
            break;
        }
        case (NetEventPnPCapabilities):
        {
            //
            // Query into TcpIp to get the latest Pnp properties on this device!
            //
            if (pDeviceContext)
            {
                PULONG  pResult = NULL;
                ULONG   BufferLen = sizeof (ULONG);
                ULONG   Input = pDeviceContext->IPInterfaceContext;

                //
                // Query the latest WOL capabilities on this adapter!
                //
                if (NT_SUCCESS (status = NbtProcessIPRequest (IOCTL_IP_GET_WOL_CAPABILITY,
                                                              &Input,      // Input buffer
                                                              BufferLen,
                                                              (PVOID) &pResult,
                                                              &BufferLen)))
                {
                    ASSERT (pResult);
                    pDeviceContext->WOLProperties = *pResult;
                    CTEMemFree (pResult);
                }


                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.TdiPnPPowerHandler[NetEventPnPCapabilities] <%x>, pDeviceContext=<%p>, Input=<%x>, Result=<%x>\n",status, pDeviceContext, Input, pDeviceContext->WOLProperties));

                status = STATUS_SUCCESS;
            }
            break;
        }

        default:
            KdPrint(("Nbt.TdiPnPPowerHandler: Invalid NetEvent=<%x> -- status=<%x>\n",
                PnPEvent->NetEvent,status));

    }

    if (pDeviceContext) {
#ifdef _NETBIOSLESS
        //
        // Check for transition in Netbios enable state
        //
        if (fOldNetbiosEnabledState != pDeviceContext->NetbiosEnabled)
        {
            if (pDeviceContext->NetbiosEnabled)
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.NbtTdiPnpPowerHandler: Enabling address on %wZ\n",
                        &pDeviceContext->ExportName));

                // We don't know what the right IP address is,
                // so we tell TDI to Enumerate!
                TdiEnumerateAddresses(TdiClientHandle);
            }
            else
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("NbtTdiPnp: disabling address on %wZ", &pDeviceContext->ExportName ));
                NbtNewDhcpAddress(pDeviceContext, 0, 0);    // Get rid of IP address to disable adapter
            }
        }
#endif

        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, FALSE);
        SetNodeType();
    }

    return (status);
}


//----------------------------------------------------------------------------
NTSTATUS
CheckSetWakeupPattern(
    tDEVICECONTEXT  *pDeviceContext,
    PUCHAR          pName,
    BOOLEAN         RequestAdd
    )
{
    NTSTATUS                            Status = STATUS_UNSUCCESSFUL;
    CTELockHandle                       OldIrq;
    ULONG                               InBufLen = 0;

    IP_WAKEUP_PATTERN_REQUEST           IPWakeupPatternReq; // Ioctl Data Format    (12 bytes)
    NET_PM_WAKEUP_PATTERN_DESC          WakeupPatternDesc;  // IP data              (8 Bytes)
    NETBT_WAKEUP_PATTERN                PatternData;        // Data Storage for the Wakeup Data itself (72)

    BOOLEAN                             fAttached = FALSE;

    if (pDeviceContext->DeviceType != NBT_DEVICE_REGULAR)
    {
        return STATUS_UNSUCCESSFUL;
    }

    CTESpinLock(pDeviceContext,OldIrq);
    //
    // Only 1 pattern (the first one) can be set at any time
    //
    if (RequestAdd)
    {
        if (pDeviceContext->WakeupPatternRefCount)
        {
            //
            // There is already a pattern registered on this device
            //
            if (CTEMemEqu (pDeviceContext->WakeupPatternName, pName, NETBIOS_NAME_SIZE-1))
            {
                pDeviceContext->WakeupPatternRefCount++;
                Status = STATUS_SUCCESS;
            }

            CTESpinFree(pDeviceContext,OldIrq);
            return (Status);
        }

        // This is the first pattern
        CTEMemCopy(&pDeviceContext->WakeupPatternName,pName,NETBIOS_NAME_SIZE);
        pDeviceContext->WakeupPatternRefCount++;
    }
    //
    // This is a Delete pattern request
    //
    else
    {
        if ((!pDeviceContext->WakeupPatternRefCount) ||        // No pattern currently registered
            (!CTEMemEqu (pDeviceContext->WakeupPatternName, pName, NETBIOS_NAME_SIZE-1))) // Not this pattern
        {
            CTESpinFree(pDeviceContext,OldIrq);
            return (STATUS_UNSUCCESSFUL);
        }
        //
        // The pattern for deletion matched the pattern that was set earlier
        //
        else if (--pDeviceContext->WakeupPatternRefCount)
        {
            //
            // This pattern is still referenced
            //
            CTESpinFree(pDeviceContext,OldIrq);
            return (STATUS_SUCCESS);
        }
    }
    CTESpinFree(pDeviceContext,OldIrq);

    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint(("Nbt.SetWakeupPattern: %s<%-16.16s:%x> on Device=<%wZ>\n",
            (RequestAdd ? "Add" : "Remove"), pName, pName[15], &pDeviceContext->BindName));

    //
    // Initialize the Pattern Data
    //
    CTEZeroMemory((PVOID) &PatternData, sizeof(NETBT_WAKEUP_PATTERN));
    ConvertToHalfAscii((PCHAR) &PatternData.nbt_NameRR, pName, NULL, 0);
    PatternData.iph_protocol       = 0x11;     // UDP Protocol
    PatternData.udph_src           = htons (NBT_NAMESERVICE_UDP_PORT);
    PatternData.udph_dest          = htons (NBT_NAMESERVICE_UDP_PORT);
    PatternData.nbt_OpCodeFlags    = htons (0x0010);
    //
    // Initialize the WakeupPattern Description
    //
    WakeupPatternDesc.Next    = NULL;
    WakeupPatternDesc.Ptrn    = (PUCHAR) &PatternData;
    WakeupPatternDesc.Mask    = NetBTPatternMask;
    WakeupPatternDesc.PtrnLen = NetBTPatternLen;
    //
    // Initialize the WakeupPattern Request
    //
    IPWakeupPatternReq.PtrnDesc         = &WakeupPatternDesc;
    IPWakeupPatternReq.AddPattern       = RequestAdd;   // Add = TRUE, Remove = FALSE

    IPWakeupPatternReq.InterfaceContext = pDeviceContext->IPInterfaceContext;

    //
    // Now, register the Wakeup pattern on this adapter
    //
    Status = NbtProcessIPRequest (IOCTL_IP_WAKEUP_PATTERN,
                                  &IPWakeupPatternReq,      // Input buffer
                                  sizeof (IP_WAKEUP_PATTERN_REQUEST),
                                  NULL,
                                  NULL
                                  );

    //
    // If we were doing an add, we need to Deref since we failed to register this pattern
    //
    if ((RequestAdd) &&
        (!NT_SUCCESS (Status)))
    {
        CTESpinLock(pDeviceContext,OldIrq);
        pDeviceContext->WakeupPatternRefCount--;
        CTESpinFree(pDeviceContext,OldIrq);
    }

    return Status;
}

/*
 * bug #88696
 *  Set the global variable NodeType based on RegistryNodeType and WINS configuration
 */
void
SetNodeType(void)
{
    /* We only need to check if the registry NodeType is broadcast */
    if (RegistryNodeType & (BNODE| DEFAULT_NODE_TYPE)) {
        /*
         * If there exist at least one active link with WINS server,
         * we set NodeType to hybrid.
         */
        PLIST_ENTRY         head, item;
        CTELockHandle       OldIrq;

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        NodeType = RegistryNodeType;
        head = &NbtConfig.DeviceContexts;
        for (item = head->Flink; item != head; item = item->Flink) {
            tDEVICECONTEXT* dev;

            dev = CONTAINING_RECORD(item, tDEVICECONTEXT, Linkage);
            if (dev->IsDestroyed || dev->IpAddress == 0 ||
                    !dev->NetbiosEnabled) {
                continue;
            }
            if ((dev->lNameServerAddress!=LOOP_BACK && dev->lNameServerAddress) || (dev->lBackupServer!=LOOP_BACK && dev->lBackupServer)) {
                NodeType = (MSNODE | (NodeType & PROXY));
                /* We don't need to check further */
                break;
            }
        }

        // A broadcast node cannot have proxy
        if ((NodeType & BNODE) && (NodeType & PROXY)) {
            NodeType &= (~PROXY);
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}

NTSTATUS
LookupDeviceInRegistry(
    IN PUNICODE_STRING pBindName,
    OUT tADDRARRAY* pAddrs,
    OUT PUNICODE_STRING pExportName
    )
{
    tDEVICES    *pBindDevices = NULL;
    tDEVICES    *pExportDevices = NULL;
    tADDRARRAY  *pAddrArray = NULL;
    NTSTATUS    Status;
    int         i;

    CTEPagedCode();

    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    Status = NbtReadRegistry (&pBindDevices, &pExportDevices, &pAddrArray);

    if (!NT_SUCCESS(Status) || !pBindDevices || !pExportDevices || !pAddrArray) {
        KdPrint (("NetBT!LookupDeviceInRegistry: Registry incomplete: pBind=<%x>, pExport=<%x>, pAddrArray=<%x>\n",
            pBindDevices, pExportDevices, pAddrArray));
        CTEExReleaseResource(&NbtConfig.Resource);
        NbtReadRegistryCleanup(&pBindDevices, &pExportDevices, &pAddrArray);

        return STATUS_REGISTRY_CORRUPT;
    }

    Status = STATUS_UNSUCCESSFUL;
    for (i=0; i<pNbtGlobConfig->uNumDevicesInRegistry; i++ ) {
        if (RtlCompareUnicodeString(pBindName, &pBindDevices->Names[i], TRUE) == 0) {
            Status = STATUS_SUCCESS;
            if (pAddrs) {
                RtlCopyMemory(pAddrs, &pAddrArray[i], sizeof(pAddrArray[i]));
            }
            if (pExportName) {
                pExportName->MaximumLength = pExportDevices->Names[i].MaximumLength;
                pExportName->Buffer = NbtAllocMem(pExportDevices->Names[i].MaximumLength, NBT_TAG2('17'));
                if (pExportName->Buffer == NULL) {
                    KdPrint (("NetBT!LookupDeviceInRegistry: fail to allocate memory\n"));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    RtlCopyUnicodeString(pExportName, &pExportDevices->Names[i]);
                }
            }
            break;
        }
    }

    NbtReadRegistryCleanup(&pBindDevices, &pExportDevices, &pAddrArray);
    CTEExReleaseResource(&NbtConfig.Resource);
    return Status;
}

tDEVICECONTEXT *
CheckAddrNotification(
    IN PTA_ADDRESS         Addr,
    IN PUNICODE_STRING     pDeviceName,
    OUT ULONG              *IpAddr
    )
/*++
       Check if the TDI address notification is for us,
       if so, return a Referenced device context and the IP address
       otherwise, return NULL.

       Note: it is the caller's responsibility to dereference the device context.
 --*/
{
    CTEPagedCode();

    if (IsIPv6Interface(pDeviceName)) {
        return NULL;
    }

    //
    // Ignore any other type of address except IP
    //
    if (Addr->AddressType != TDI_ADDRESS_TYPE_IP) {
        return NULL;
    }

    *IpAddr = ntohl(((PTDI_ADDRESS_IP)&Addr->Address[0])->in_addr);
    IF_DBG(NBT_DEBUG_PNP_POWER)
    {
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("netbt!CheckAddrNotification: %d.%d.%d.%d\n",
                    ((*IpAddr)>>24)&0xFF,((*IpAddr)>>16)&0xFF,((*IpAddr)>>8)&0xFF,(*IpAddr)&0xFF));
    }

    //
    // Filter out zero address notifications
    //
    if (*IpAddr == 0) {
        KdPrint (("Nbt.TdiAddressDeletion: ERROR: Address <%x> not assigned to any device!\n", IpAddr));
        return NULL;
    }

    //
    // Ignore this notification if we don't bind to this device
    //
    return NbtFindAndReferenceDevice (pDeviceName, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\registry.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Registry.c

Abstract:

    This contains all routines necessary to load device pathnames from the
    registry.

Author:

    Jim Stewart (Jimst) October 9 1992

Revision History:
    Jiandong Ruan (jruan) April 6 2000  Add NbtReadRegistryCleanup

Notes:

--*/

#include "precomp.h"


//
// Local functions used to access the registry.
//

NTSTATUS
NbtOpenRegistry(
    IN HANDLE       NbConfigHandle,
    IN PWSTR        String,
    OUT PHANDLE     pHandle
    );

VOID
NbtCloseRegistry(
    IN HANDLE LinkageHandle,
    IN HANDLE ParametersHandle
    );

NTSTATUS
NbtReadLinkageInformation(
    IN  PWSTR       pName,
    IN  HANDLE      LinkageHandle,
    IN  ULONG       MaxBindings,
    OUT tDEVICES    *pDevices,      // place to put read in config data
    OUT ULONG       *pNumDevices
    );

NTSTATUS
OpenAndReadElement(
    IN  PUNICODE_STRING pucRootPath,
    IN  PWSTR           pwsValueName,
    OUT PUNICODE_STRING pucString
    );

NTSTATUS
GetIpAddressesList (
    IN  HANDLE      ParametersHandle,
    IN  PWSTR       pwsKeyName,
    IN  ULONG       MaxAddresses,
    OUT tIPADDRESS  *pAddrArray,
    OUT ULONG       *pNumGoodAddresses
    );

NTSTATUS
GetServerAddress (
    IN  HANDLE      ParametersHandle,
    IN  PWSTR       KeyName,
    OUT PULONG      pIpAddr
    );

NTSTATUS
NbtAppendString (
    IN  PWSTR               FirstString,
    IN  PWSTR               SecondString,
    OUT PUNICODE_STRING     pucString
    );

NTSTATUS
ReadStringRelative(
    IN  PUNICODE_STRING pRegistryPath,
    IN  PWSTR           pRelativePath,
    IN  PWSTR           pValueName,
    OUT PUNICODE_STRING pOutString
    );

VOID
NbtFindLastSlash(
    IN  PUNICODE_STRING pucRegistryPath,
    OUT PWSTR           *ppucLastElement,
    IN  int             *piLength
    );

NTSTATUS
ReadSmbDeviceInfo(
    IN HANDLE       NbConfigHandle
    );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NbtReadRegistry)
#pragma CTEMakePageable(PAGE, NbtReadRegistryCleanup)
#pragma CTEMakePageable(PAGE, ReadNameServerAddresses)
#pragma CTEMakePageable(PAGE, GetIpAddressesList)
#pragma CTEMakePageable(PAGE, GetServerAddress)
#pragma CTEMakePageable(PAGE, NTReadIniString)
#pragma CTEMakePageable(PAGE, GetIPFromRegistry)
#pragma CTEMakePageable(PAGE, NbtOpenRegistry)
#pragma CTEMakePageable(PAGE, NbtParseMultiSzEntries)
#pragma CTEMakePageable(PAGE, NbtReadLinkageInformation)
#pragma CTEMakePageable(PAGE, NbtReadSingleParameter)
#pragma CTEMakePageable(PAGE, OpenAndReadElement)
#pragma CTEMakePageable(PAGE, ReadElement)
#pragma CTEMakePageable(PAGE, NTGetLmHostPath)
#pragma CTEMakePageable(PAGE, ReadStringRelative)
#pragma CTEMakePageable(PAGE, NbtFindLastSlash)
#pragma CTEMakePageable(PAGE, ReadSmbDeviceInfo)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
NTSTATUS
NbtReadRegistry(
    OUT tDEVICES        **ppBindDevices,
    OUT tDEVICES        **ppExportDevices,
    OUT tADDRARRAY      **ppAddrArray
    )
/*++

Routine Description:

    This routine is called to get information from the registry,
    starting at RegistryPath to get the parameters.
    This routine must be called with the NbtConfig.Resource lock HELD

Arguments:

    Before calling this routine, the following Global parameters
    must have been initialized (in DriverEntry):

        NbtConfig.pRegistry

Return Value:

    NTSTATUS - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/
{
    NTSTATUS            OpenStatus;
    HANDLE              LinkageHandle;
    HANDLE              ParametersHandle;
    HANDLE              NbtConfigHandle;
    NTSTATUS            Status;
    ULONG               Disposition;
    OBJECT_ATTRIBUTES   TmpObjectAttributes;
    PWSTR               LinkageString = L"Linkage";
    PWSTR               ParametersString = L"Parameters";
    tDEVICES            *pBindDevices;
    tDEVICES            *pExportDevices;
    UNICODE_STRING      ucString;
    ULONG               NumBindings;

    CTEPagedCode();

	*ppExportDevices = *ppBindDevices = NULL;
	*ppAddrArray = NULL;

    //
    // Open the registry.
    //
    InitializeObjectAttributes (&TmpObjectAttributes,
                                &NbtConfig.pRegistry,                       // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,   // attributes
                                NULL,                                       // root
                                NULL);                                      // security descriptor

    Status = ZwCreateKey (&NbtConfigHandle,
                          KEY_READ,
                          &TmpObjectAttributes,
                          0,                 // title index
                          NULL,              // class
                          0,                 // create options
                          &Disposition);     // disposition

    if (!NT_SUCCESS(Status))
    {
        KdPrint (("Nbt.NbtReadRegistry:  ZwCreateKey FAILed, status=<%x>\n", Status));
        NbtLogEvent (EVENT_NBT_CREATE_DRIVER, Status, 0x114);
        return STATUS_UNSUCCESSFUL;
    }

    OpenStatus = NbtOpenRegistry (NbtConfigHandle, LinkageString, &LinkageHandle);
    if (NT_SUCCESS(OpenStatus))
    {
        OpenStatus = NbtOpenRegistry (NbtConfigHandle, ParametersString, &ParametersHandle);
        if (NT_SUCCESS(OpenStatus))
        {
            //
            // Read in the binding information (if none is present
            // the array will be filled with all known drivers).
            //
            if (pBindDevices = NbtAllocMem ((sizeof(tDEVICES)+2*NBT_MAXIMUM_BINDINGS*sizeof(UNICODE_STRING)),
                                            NBT_TAG2('25')))
            {
                if (pExportDevices=NbtAllocMem((sizeof(tDEVICES)+2*NBT_MAXIMUM_BINDINGS*sizeof(UNICODE_STRING)),
                                     NBT_TAG2('26')))
                {
                    ReadParameters (&NbtConfig, ParametersHandle);// Read various parameters from the registry
                    ReadSmbDeviceInfo (NbtConfigHandle); // Set the information for the SmbDevice

                    //
                    // From now on, the only failures we can encounter are in reading the
                    // Bind, Export or Name Server address entries, hence if we fail here,
                    // we will still return success, but will assume 0 devices configured!
                    //
                    pBindDevices->RegistryData = pExportDevices->RegistryData = NULL;
                    Status = NbtReadLinkageInformation (NBT_BIND,
                                                        LinkageHandle,
                                                        2*NBT_MAXIMUM_BINDINGS,
                                                        pBindDevices,
                                                        &NumBindings);
					if (!NT_SUCCESS(Status))
                    {
                        KdPrint (("Nbt.NbtReadRegistry: NbtReadLinkageInformation FAILed - BIND <%x>\n",
                            Status));
                        NbtLogEvent (EVENT_NBT_READ_BIND, Status, 0x115);
                    }
                    else    // if (NT_SUCCESS(Status))
					{
	                    IF_DBG(NBT_DEBUG_NTUTIL)
	                        KdPrint(("Binddevice = %ws\n",pBindDevices->Names[0].Buffer));

                        NbtConfig.uNumDevicesInRegistry = (USHORT) NumBindings;
                        NumBindings = 0;

	                    //  Read the EXPORT information as well.
	                    Status = NbtReadLinkageInformation (NBT_EXPORT,
	                                                        LinkageHandle,
                                                            2*NBT_MAXIMUM_BINDINGS,
	                                                        pExportDevices,
	                                                        &NumBindings);
	                    if (NT_SUCCESS(Status))
                        {
	                        // we want the lowest number for num devices in case there
	                        // are more bindings than exports or viceversa
	                        //
//                            ASSERT (NumBindings == NbtConfig.uNumDevicesInRegistry);
	                        NbtConfig.uNumDevicesInRegistry = (USHORT)
                                                              (NbtConfig.uNumDevicesInRegistry > NumBindings ?
	                                                           NumBindings : NbtConfig.uNumDevicesInRegistry);

                            if (NbtConfig.uNumDevicesInRegistry == 0)
                            {
                                KdPrint (("Nbt.NbtReadRegistry: WARNING - NumDevicesInRegistry = 0\n"));
                            }
                        }
                        else
                        {
                            KdPrint (("Nbt.NbtReadRegistry: NbtReadLinkageInformation FAILed - EXPORT <%x>\n",
                                Status));
                            NbtLogEvent (EVENT_NBT_READ_EXPORT, Status, 0x116);
                        }
                    }

                    if ((NT_SUCCESS(Status)) &&
                        (NbtConfig.uNumDevicesInRegistry))
					{
	                    IF_DBG(NBT_DEBUG_NTUTIL)
	                        KdPrint(("Exportdevice = %ws\n",pExportDevices->Names[0].Buffer));

	                    //
	                    // read in the NameServer IP address now
	                    //
	                    Status = ReadNameServerAddresses (NbtConfigHandle,
	                                                      pBindDevices,
	                                                      NbtConfig.uNumDevicesInRegistry,
	                                                      ppAddrArray);

	                    if (!NT_SUCCESS(Status))
                        {
                            if (!(NodeType & BNODE))        // Post Warning!
                            {
                                NbtLogEvent (EVENT_NBT_NAME_SERVER_ADDRS, Status, 0x118);
                            }
                            KdPrint(("Nbt.NbtReadRegistry: ReadNameServerAddresses returned <%x>\n", Status));
                        }
                        else    // if (NT_SUCCESS(Status))
                        {
                            //
                            // check if any WINS servers have been configured change
                            // to Hnode
                            //
                            if (NodeType & (BNODE | DEFAULT_NODE_TYPE))
                            {
                                ULONG i;
                                for (i=0; i<NbtConfig.uNumDevicesInRegistry; i++)
                                {
                                    if (((*ppAddrArray)[i].NameServerAddress != LOOP_BACK) ||
                                        ((*ppAddrArray)[i].BackupServer != LOOP_BACK))
                                    {
                                        NodeType = MSNODE | (NodeType & PROXY);
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    if ((!NT_SUCCESS(Status)) ||
                        (0 == NbtConfig.uNumDevicesInRegistry))
                    {
                        //
                        // We had problems reading the Bind or Export or Address entries
                        //
                        if (pBindDevices->RegistryData)
                        {
                            CTEMemFree(pBindDevices->RegistryData);
                        }
                        CTEMemFree(pBindDevices);

                        if (pExportDevices->RegistryData)
                        {
                            CTEMemFree(pExportDevices->RegistryData);
                        }
                        CTEMemFree(pExportDevices);

                        pBindDevices = pExportDevices = NULL;
                        NbtConfig.uNumDevicesInRegistry = 0;
                        Status = STATUS_SUCCESS;
                    }

                    //
                    // we have done the check for default node so turn off
                    // the flag
                    //
                    NodeType &= ~DEFAULT_NODE_TYPE;
                    //
                    // A Bnode cannot be a proxy too
                    //
                    if (NodeType & BNODE)
                    {
                        if (NodeType & PROXY)
                        {
                            NodeType &= ~PROXY;
                        }
                    }

                    // keep the size around for allocating memory, so that when we run over
                    // OSI, only this value should change (in theory at least)
                    NbtConfig.SizeTransportAddress = sizeof(TDI_ADDRESS_IP);

                    // fill in the node type value that is put into all name service Pdus
                    // that go out identifying this node type
                    switch (NodeType & NODE_MASK)
                    {
                        case BNODE:
                            NbtConfig.PduNodeType = 0;
                            break;
                        case PNODE:
                            NbtConfig.PduNodeType = 1 << 13;
                            break;
                        case MNODE:
                            NbtConfig.PduNodeType = 1 << 14;
                            break;
                        case MSNODE:
                            NbtConfig.PduNodeType = 3 << 13;
                            break;

                    }

                    // read the name of the transport to bind to
                    //
                    if (NT_SUCCESS(ReadElement(ParametersHandle, WS_TRANSPORT_BIND_NAME, &ucString)))
                    {
                        UNICODE_STRING  StreamsString;

                        //
                        // if there is already a bind string, free it before
                        // allocating another
                        //
                        if (NbtConfig.pTcpBindName)
                        {
                            //
                            // CreateDeviceString in tdicnct.c could access the pTcpBindName right
                            // after it is freed. The right way is using a lock. But, ...
                            //
                            // Hack!!!:
                            // Although this doesn't completely fix the problem, it has the minimum
                            // side-effect.
                            //
                            // The value of WS_TRANSPORT_BIND_NAME won't change. By doing this,
                            // we avoid the possible access-after-free problem in most cases.
                            //
                            RtlInitUnicodeString(&StreamsString, NbtConfig.pTcpBindName);
                            if (RtlCompareUnicodeString(&ucString,&StreamsString,TRUE)) {
                                CTEMemFree(NbtConfig.pTcpBindName);
                                NbtConfig.pTcpBindName = ucString.Buffer;
                            } else {
                                CTEMemFree(ucString.Buffer);
                                ucString = StreamsString;
                            }
                        } else {
                            NbtConfig.pTcpBindName = ucString.Buffer;
                        }

                        // ********** REMOVE LATER ***********
                        RtlInitUnicodeString(&StreamsString,NBT_TCP_BIND_NAME);
                        if (RtlCompareUnicodeString(&ucString,&StreamsString,TRUE))
                        {
                            StreamsStack = FALSE;
                        }
                        else
                        {
                            StreamsStack = TRUE;
                        }
                    }
                    else
                    {
                        StreamsStack = TRUE;
                    }

                    ZwClose(ParametersHandle);
                    ZwClose(LinkageHandle);
                    ZwClose(NbtConfigHandle);

                    *ppExportDevices = pExportDevices;
                    *ppBindDevices   = pBindDevices;
                    return (Status);
                }
                else
                {
                    KdPrint (("Nbt.NbtReadRegistry:  FAILed to allocate pExportDevices\n"));
                }
                CTEMemFree(pBindDevices);
            }
            else
            {
                KdPrint (("Nbt.NbtReadRegistry:  FAILed to allocate pBindDevices\n"));
            }
            ZwClose(ParametersHandle);
        }
        else
        {
            KdPrint (("Nbt.NbtReadRegistry:  NbtOpenRegistry FAILed for PARAMETERS, status=<%x>\n", Status));
            NbtLogEvent (EVENT_NBT_OPEN_REG_PARAMS, OpenStatus, 0x119);
        }
        ZwClose(LinkageHandle);
    }
    else
    {
        KdPrint (("Nbt.NbtReadRegistry:  NbtOpenRegistry FAILed for LINKAGE, status=<%x>\n", Status));
        NbtLogEvent (EVENT_NBT_OPEN_REG_LINKAGE, OpenStatus, 0x120);
    }

    ZwClose (NbtConfigHandle);

    return STATUS_UNSUCCESSFUL;
}

//----------------------------------------------------------------------------
VOID
NbtReadRegistryCleanup(
    IN tDEVICES        **ppBindDevices,
    IN tDEVICES        **ppExportDevices,
    IN tADDRARRAY      **ppAddrArray
    )
/*++

Routine Description:

    This routine is called to release resources allocated by NbtReadRegistry
++*/

{
    CTEPagedCode();
    if (ppBindDevices[0]) {
        CTEMemFree((PVOID)ppBindDevices[0]->RegistryData);
        CTEMemFree((PVOID)ppBindDevices[0]);
        ppBindDevices[0] = NULL;
    }
    if (ppExportDevices[0]) {
        CTEMemFree((PVOID)ppExportDevices[0]->RegistryData);
        CTEMemFree((PVOID)ppExportDevices[0]);
        ppExportDevices[0] = NULL;
    }
    if (ppAddrArray[0]) {
        CTEMemFree((PVOID)ppAddrArray[0]);
        ppAddrArray[0] = NULL;
    }
}


NTSTATUS
ReadSmbDeviceInfo(
    IN HANDLE       NbtConfigHandle
    )
{
    HANDLE      SmbHandle;
    NTSTATUS    Status;

    CTEPagedCode();

    Status = NbtOpenRegistry (NbtConfigHandle, WC_SMB_PARAMETERS_LOCATION, &SmbHandle);
    if (NT_SUCCESS(Status))
    {
        NbtConfig.DefaultSmbSessionPort =  (USHORT) CTEReadSingleIntParameter (SmbHandle,
                                                                               SESSION_PORT,
                                                                               NBT_SMB_SESSION_TCP_PORT,
                                                                               1);

        NbtConfig.DefaultSmbDatagramPort =  (USHORT) CTEReadSingleIntParameter (SmbHandle,
                                                                                DATAGRAM_PORT,
                                                                                NBT_SMB_DATAGRAM_UDP_PORT,
                                                                                1);
        ZwClose (SmbHandle);
    }
    else
    {
        NbtConfig.DefaultSmbSessionPort = NBT_SMB_SESSION_TCP_PORT;
        NbtConfig.DefaultSmbDatagramPort = NBT_SMB_DATAGRAM_UDP_PORT;
    }

    return (Status);
}



//----------------------------------------------------------------------------
NTSTATUS
ReadNameServerAddresses (
    IN  HANDLE      NbtConfigHandle,
    IN  tDEVICES    *BindDevices,
    IN  ULONG       NumberDevices,
    OUT tADDRARRAY  **ppAddrArray
    )

/*++

Routine Description:

    This routine is called to read the name server addresses from the registry.
    It stores them in a data structure that it allocates.  This memory is
    subsequently freed in driver.c when the devices have been created.

Arguments:

    ConfigurationInfo - A pointer to the configuration information structure.

Return Value:

    None.

--*/
{
#define ADAPTER_SIZE_MAX    400

    UNICODE_STRING  ucString;
    NTSTATUS        status = STATUS_UNSUCCESSFUL;
    HANDLE          Handle;
    LONG            i,j,Len;
    PWSTR           pwsAdapter = L"Parameters\\Interfaces\\";
    PWSTR           BackSlash = L"\\";
    tADDRARRAY      *pAddrArray;
    ULONG           LenAdapter;
#ifdef _NETBIOSLESS
    ULONG           Options;
#endif
    ULONG           NumNameServerAddresses = 0;

    CTEPagedCode();

    *ppAddrArray = NULL;

    // this is large enough for 400 characters of adapter name.
    ucString.Buffer = NbtAllocMem (ADAPTER_SIZE_MAX, NBT_TAG2('27'));
    if (!ucString.Buffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pAddrArray = NbtAllocMem (sizeof(tADDRARRAY)*NumberDevices, NBT_TAG2('28'));
    if (!pAddrArray)
    {
        CTEMemFree(ucString.Buffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    CTEZeroMemory(pAddrArray,sizeof(tADDRARRAY)*NumberDevices);
    *ppAddrArray = pAddrArray;

    // get the adapter name out of the Bind string, and use it to open
    // a key by the same name, to get the name server addresses
    //
    for (i = 0;i < (LONG)NumberDevices ;i ++ )
    {
        WCHAR   *pBuffer;

        Len = BindDevices->Names[i].Length/sizeof(WCHAR);
        Len--;
        //
        // start at the end a work backwards looking for a '\'
        //
        j  = Len;
        pBuffer = &BindDevices->Names[i].Buffer[j];
        while (j)
        {
            if (*pBuffer != *BackSlash)
            {
                j--;
                pBuffer--;
            }
            else
                break;
        }

        // if we don't find a backslash or at least one
        // character name then continue around again, or the name
        // is longer than the buffer, then go to the next device in the
        // bind list
        //
        if ((j == 0) ||
            (j == Len) ||
            (j == Len -1) ||
            ((Len - j) > ADAPTER_SIZE_MAX / sizeof(WCHAR)))
        {
            continue;
        }

        // copy the string "Adapter\" to the buffer since the adapters all
        // appear under this key in the registery
        //
        LenAdapter = wcslen(pwsAdapter);
        CTEMemCopy(ucString.Buffer, pwsAdapter, LenAdapter*sizeof(WCHAR));
        //
        // copy just the adapter name from the Bind string, since that is
        // the name of the key to open to find the name server ip addresses
        //
        CTEMemCopy(&ucString.Buffer[LenAdapter], ++pBuffer, (Len - j)*sizeof(WCHAR));
        ucString.Buffer[Len - j + LenAdapter] = 0;

        pAddrArray->NameServerAddress = LOOP_BACK;
        pAddrArray->BackupServer = LOOP_BACK;
#ifdef MULTIPLE_WINS
        pAddrArray->Others[0] = LOOP_BACK;          // For Safety
        pAddrArray->NumOtherServers = 0;
        pAddrArray->LastResponsive = 0;
#endif

        status = NbtOpenRegistry (NbtConfigHandle, ucString.Buffer, &Handle);
        if (NT_SUCCESS(status))
        {
            status = GetIpAddressesList(Handle,         // Generic routine to read in list of Ip addresses
                                        PWS_NAME_SERVER_LIST,
                                        2+MAX_NUM_OTHER_NAME_SERVERS,
                                        pAddrArray->AllNameServers,
                                        &NumNameServerAddresses);

            if (!NT_SUCCESS(status) ||
                (pAddrArray->NameServerAddress == LOOP_BACK))
            {
                NumNameServerAddresses = 0;
                status = GetIpAddressesList(Handle,
                                            PWS_DHCP_NAME_SERVER_LIST,
                                            2+MAX_NUM_OTHER_NAME_SERVERS,
                                            pAddrArray->AllNameServers,
                                            &NumNameServerAddresses);

            }

            //
            // Continue even if we failed to read in any IP addresses
            //
            if (NumNameServerAddresses > 2)
            {
                pAddrArray->NumOtherServers = (USHORT) NumNameServerAddresses - 2;
            }

#ifdef _NETBIOSLESS
            // NbtReadSingle doesn't quite do what we want.  In this case, if the non-dhcp-
            // decorated option is present but zero, we DO want to go on to the dhcp-
            // decorated one.  So, try the dhcp-decorated one explicitly if we get back zero.
            Options = NbtReadSingleParameter( Handle, PWS_NETBIOS_OPTIONS, 0, 0 );
            if (Options == 0)
            {
                Options = NbtReadSingleParameter( Handle, PWS_DHCP_NETBIOS_OPTIONS, 0, 0 );
            }
            // Options is encoded as four bytes
            // Each byte can be an independent set of flags
            // The high order three bytes can be used for controlling other aspects
            // Enabled option, default is TRUE
            pAddrArray->NetbiosEnabled = ((Options & 0xff) != NETBT_MODE_NETBIOS_DISABLED);
#endif
            pAddrArray->RasProxyFlags = NbtReadSingleParameter(Handle, PWS_RAS_PROXY_FLAGS, 0, 0);
            pAddrArray->EnableNagling = (NbtReadSingleParameter(Handle, PWS_ENABLE_NAGLING, 0, 0) != FALSE);

            // don't want to fail this routine just because the
            // name server address was not set
            status = STATUS_SUCCESS;

            ZwClose(Handle);
        }
        pAddrArray++;

    }

    CTEMemFree(ucString.Buffer);
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
GetIpAddressesList (
    IN  HANDLE      ParametersHandle,
    IN  PWSTR       pwsKeyName,
    IN  ULONG       MaxAddresses,
    OUT tIPADDRESS  *pAddrArray,
    OUT ULONG       *pNumGoodAddresses
    )

/*++

Routine Description:

    This routine is called to read a list of Ip addresses from the registry.

Arguments:


Return Value:

    None.

--*/
{
    ULONG           NumEntriesRead, NumGoodAddresses, NumAddressesAttempted;
    tDEVICES        *pucAddressList;
    NTSTATUS        Status;
    STRING          String;
    ULONG           IpAddr;
    PWSTR           DhcpName = L"Dhcp";
    UNICODE_STRING  DhcpKeyName;

    CTEPagedCode();

    pucAddressList=NbtAllocMem((sizeof(tDEVICES)+2*NBT_MAXIMUM_BINDINGS*sizeof(UNICODE_STRING)),NBT_TAG('i'));
    if (!pucAddressList)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Since NbtReadLinkageInformation very conveniently reads in the values for
    // a MULTI_SZ registry entry, we will re-use this function here!
    //
    //
    NumEntriesRead = 0;
    Status = NbtReadLinkageInformation (pwsKeyName,
                                        ParametersHandle,
                                        2*NBT_MAXIMUM_BINDINGS,
                                        pucAddressList,
                                        &NumEntriesRead);
    if ((STATUS_ILL_FORMED_SERVICE_ENTRY == Status) || (!NT_SUCCESS(Status)))
    {
        IF_DBG(NBT_DEBUG_NTUTIL)
            KdPrint(("GetIpAddressesList: ERROR -- NbtReadLinkageInformation=<%x>, <%ws>\n",
                Status, pwsKeyName));

        CTEMemFree(pucAddressList);
        return STATUS_UNSUCCESSFUL;
    }

    String.Buffer = NbtAllocMem (REGISTRY_BUFF_SIZE, NBT_TAG2('29'));
    if (!String.Buffer)
    {
        KdPrint(("GetNameServerAddresses: Failed to Allocate memory\n"));
        CTEMemFree((PVOID)pucAddressList->RegistryData);
        CTEMemFree(pucAddressList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    String.MaximumLength = REGISTRY_BUFF_SIZE;

    //
    // NumGoodAddresses will be bound by MaxAddresses, while
    // NumAddressesAttempted will be bound by NumEntriesRead
    // Also, we could have read NumEntriesRead > MaxAddresses
    // (some of the entries could be invalid), but we will not
    // attempt to read > 2*MaxAddresses entires
    //
    NumGoodAddresses = 0;
    NumAddressesAttempted = 0;
    while ((NumGoodAddresses < MaxAddresses) &&
           (NumAddressesAttempted < NumEntriesRead) &&
           (NumAddressesAttempted < (2*MaxAddresses)))
    {
        Status  = RtlUnicodeStringToAnsiString(&String, &pucAddressList->Names[NumAddressesAttempted], FALSE);
        if (NT_SUCCESS(Status))
        {
            Status = ConvertDottedDecimalToUlong((PUCHAR) String.Buffer, &IpAddr);
            if (NT_SUCCESS(Status) && IpAddr)
            {
                pAddrArray[NumGoodAddresses++] = IpAddr;
            }
        }
        NumAddressesAttempted++;
    }

    CTEMemFree ((PVOID)String.Buffer);
    CTEMemFree ((PVOID)pucAddressList->RegistryData);
    CTEMemFree ((PVOID)pucAddressList);

    //
    // If we were able to read in at least 1 good Ip address,
    // return success, otherwise return failure!
    //
    if (NumGoodAddresses)
    {
        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = STATUS_INVALID_ADDRESS;
    }

    *pNumGoodAddresses = NumGoodAddresses;
    return(Status);
}

NTSTATUS
GetServerAddress (
    IN  HANDLE      ParametersHandle,
    IN  PWSTR       KeyName,
    OUT PULONG      pIpAddr
    )

/*++

Routine Description:

    This routine is called to read the name server addresses from the registry.

Arguments:

    ConfigurationInfo - A pointer to the configuration information structure.

Return Value:

    None.

--*/
{
    NTSTATUS        status;
    ULONG           IpAddr;
    PUCHAR          NameServer;

    CTEPagedCode();

    status = CTEReadIniString(ParametersHandle,KeyName,&NameServer);

    if (NT_SUCCESS(status))
    {
        status = ConvertDottedDecimalToUlong(NameServer,&IpAddr);
        if (NT_SUCCESS(status) && IpAddr)
        {
            *pIpAddr = IpAddr;
        }
        else
        {
            if (IpAddr != 0)
            {
                NbtLogEvent (EVENT_NBT_BAD_PRIMARY_WINS_ADDR, 0, 0x121);
            }
            *pIpAddr = LOOP_BACK;
        }

        CTEMemFree((PVOID)NameServer);


    }
    else
    {
        *pIpAddr = LOOP_BACK;
    }

    return(status);
}
//----------------------------------------------------------------------------
NTSTATUS
NbtAppendString (
    IN  PWSTR               FirstString,
    IN  PWSTR               SecondString,
    OUT PUNICODE_STRING     pucString
    )

/*++

Routine Description:

    This routine is called to append the second string to the first string.
    It allocates memory for this, so the caller must be sure to free it.

Arguments:


Return Value:

    None.

--*/
{
    NTSTATUS        status = STATUS_INSUFFICIENT_RESOURCES;
    ULONG           Length;
    PWSTR           pDhcpKeyName;

    CTEPagedCode();

    Length = (wcslen(FirstString) + wcslen(SecondString) + 1)*sizeof(WCHAR);
    pDhcpKeyName = NbtAllocMem (Length, NBT_TAG2('30'));
    if (pDhcpKeyName)
    {
        pucString->Buffer = pDhcpKeyName;
        pucString->Length = (USHORT)0;
        pucString->MaximumLength = (USHORT)Length;
        pucString->Buffer[0] = UNICODE_NULL;

        status = RtlAppendUnicodeToString(pucString,FirstString);
        if (NT_SUCCESS(status))
        {
            status = RtlAppendUnicodeToString(pucString,SecondString);
            if (NT_SUCCESS(status))
            {
                return status;
            }
        }
        CTEMemFree(pDhcpKeyName);

    }
    return(status);
}
//----------------------------------------------------------------------------
NTSTATUS
NTReadIniString (
    IN  HANDLE      ParametersHandle,
    IN  PWSTR       KeyName,
    OUT PUCHAR      *ppString
    )

/*++

Routine Description:

    This routine is called to read a string of configuration information from
    the registry.

Arguments:

    ParametersHandle    - handle to open key in registry
    KeyName             - key to read
    ppString            - returned string

Return Value:

    None.

--*/
{
    UNICODE_STRING  ucString;
    STRING          String;
    NTSTATUS        status;
    PUCHAR          pBuffer;
    PWSTR           Dhcp = L"Dhcp";

    CTEPagedCode();
    //
    // read in the Scope Id
    //
    // if the key is not there or it is set to a null string try to read the
    // dhcp key
    //
    status = ReadElement (ParametersHandle, KeyName, &ucString);
    if (!NT_SUCCESS(status) || (ucString.Length == 0))
    {
        UNICODE_STRING  String;

        // free the string allocated in ReadElement
        if (NT_SUCCESS(status))
        {
            CTEMemFree(ucString.Buffer);
        }
        //
        // try to read a similar string that is prefixed with "DHCP"
        // incase there is only the DHCP configuration information present
        // and not overrides keys.
        //
        status = NbtAppendString(Dhcp,KeyName,&String);
        if (NT_SUCCESS(status))
        {
            status = ReadElement (ParametersHandle, String.Buffer, &ucString);
            CTEMemFree(String.Buffer);  // Free the buffer allocated in NbtAppendString
        }
    }
    // the scope must be less than
    // 255-16 characters since the whole name is limited to 255 as per the
    // RFC
    //
    IF_DBG(NBT_DEBUG_NTUTIL)
    KdPrint(("Nbt: ReadIniString = %ws\n",ucString.Buffer));

    if (NT_SUCCESS(status))
    {
        if ((ucString.Length > 0) &&
           (ucString.Length <= (255 - NETBIOS_NAME_SIZE)*sizeof(WCHAR)))
        {

            pBuffer = NbtAllocMem (ucString.MaximumLength/sizeof(WCHAR), NBT_TAG2('31'));
            if (pBuffer)
            {
                // convert to an ascii string and store in the config data structure
                // increment pBuffer to leave room for the length byte
                //
                String.Buffer = pBuffer;
                String.MaximumLength = ucString.MaximumLength/sizeof(WCHAR);
                status = RtlUnicodeStringToAnsiString (&String, &ucString, FALSE);
                if (NT_SUCCESS(status))
                {
                    *ppString = pBuffer;
                }
                else
                {
                    CTEMemFree(pBuffer);
                }
            }
            else
            {
                status = STATUS_UNSUCCESSFUL;
            }


        }
        else if (NT_SUCCESS(status))
        {
            // force the code to setup a null scope since the one in the
            // registry is null
            //
            status = STATUS_UNSUCCESSFUL;
        }

        // free the string allocated in ReadElement
        CTEMemFree(ucString.Buffer);
    }

    return(status);
}

VOID
NbtFreeRegistryInfo (
    )

/*++

Routine Description:

    This routine is called by Nbt to free any storage that was allocated
    by NbConfigureTransport in producing the specified CONFIG_DATA structure.

Arguments:

    ConfigurationInfo - A pointer to the configuration information structure.

Return Value:

    None.

--*/
{

}

//----------------------------------------------------------------------------
NTSTATUS
GetIPFromRegistry(
    IN  PUNICODE_STRING         pucBindDevice,
    OUT tIPADDRESS              *pIpAddresses,
    OUT tIPADDRESS              *pSubnetMask,
    IN  ULONG                   MaxIpAddresses,
    OUT ULONG                   *pNumIpAddresses,
    IN  enum eNbtIPAddressType  IPAddressType
    )
/*++

Routine Description:

    This routine is called to get the IP address of an adapter from the
    Registry.  The Registry path variable contains the path name
    for NBT's registry entries.  The last element of this path name is
    removed to give the path to any card in the registry.

    The BindDevice path contains a Bind string for NBT.  We remove the last
    element of this path (which is the adapter name \Elnkii01) and tack it
    onto the modified registry path from above.  We then tack on
    \Parameters which will give the full path to the Tcpip key, which
    we open to get the Ip address.


Arguments:

    Before calling this routine, the following Global parameters
    must have been initialized (in DriverEntry):

        NbtConfig.pRegistry

Return Value:

    NTSTATUS - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/
{
    ULONG               i, Len, Disposition;
    PVOID               pBuffer;
    NTSTATUS            Status = STATUS_UNSUCCESSFUL;   // by default
    PWSTR               pwsIpAddressName, pwsSubnetMask;
    PWSTR               pwsAdapterGuid, pwsLastSlash;
    PWSTR               pwsTcpParams        = L"Tcpip\\Parameters\\Interfaces\\"; // key to open
    PWSTR               pwsUnderScore       = L"_";
    UNICODE_STRING      Path;
    HANDLE              TcpGuidHandle;
    OBJECT_ATTRIBUTES   TmpObjectAttributes;

    CTEPagedCode();

    switch (IPAddressType)
    {
        case (NBT_IP_STATIC):
            pwsIpAddressName = STATIC_IPADDRESS_NAME;
            pwsSubnetMask = STATIC_IPADDRESS_SUBNET;
            break;

        case (NBT_IP_DHCP):
            pwsIpAddressName = DHCP_IPADDRESS_NAME;
            pwsSubnetMask = DHCP_IPADDRESS_SUBNET;
            break;

        case (NBT_IP_AUTOCONFIGURATION):
            pwsIpAddressName = DHCP_IPAUTOCONFIGURATION_NAME;
            pwsSubnetMask = DHCP_IPAUTOCONFIGURATION_SUBNET;
            break;

        default:
            IF_DBG(NBT_DEBUG_NTUTIL)
                KdPrint(("Invalid IP Address Type <%x>\n", IPAddressType));
            return STATUS_INVALID_ADDRESS;
    }

    // Extract the Adapter Guid from the BindDevice name
    // pucBindDevice:   \Device\TCPIP_<AdapterGuid>
    // Find the last back slash in the path name to the bind device
    NbtFindLastSlash (pucBindDevice, &pwsAdapterGuid, &Len);
    if (pwsAdapterGuid)
    {
        //
        // Now, search the string to find the first underscore in "TCPIP_"
        //
        Len = wcslen(pwsAdapterGuid);
        for(i=0; i<Len; i++)
        {
            if (pwsAdapterGuid[i] == *pwsUnderScore)
            {
                // want ptr to point at character after the slash
                pwsAdapterGuid = &pwsAdapterGuid[i+1];
                break;
            }
        }

        //
        // If we found the underscore, then we have found the Guid!
        //
        if (i < Len-1)
        {
            Status = STATUS_SUCCESS;
        }
    }

    if (Status != STATUS_SUCCESS)
    {
        //
        // We could not find the Guid!
        //
        return Status;
    }

    // Initialize the Registry key name
    // Get the total length of the Registry key to open (+1 for unicode null)
    Len =  NbtConfig.pRegistry.MaximumLength
         + (wcslen(pwsTcpParams) + wcslen(pwsAdapterGuid) + 1) * sizeof(WCHAR);
    pBuffer = NbtAllocMem (Len, NBT_TAG2('32'));
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    Path.Buffer = pBuffer;
    Path.MaximumLength = (USHORT)Len;
    Path.Length = 0;

    RtlCopyUnicodeString(&Path, &NbtConfig.pRegistry);  // \REGISTRY\Machine\System\ControlSet\Services\NetBT
    NbtFindLastSlash(&Path, &pwsLastSlash, &Len);       // \REGISTRY\Machine\System\ControlSet\Services
    Path.Length = (USHORT)Len;
    *pwsLastSlash = UNICODE_NULL;

    RtlAppendUnicodeToString(&Path, pwsTcpParams);      // ...Tcpip\Parameters\Interfaces
    RtlAppendUnicodeToString(&Path, pwsAdapterGuid);    // ......AdapterGuid

    //
    // Open the registry.
    //
    InitializeObjectAttributes (&TmpObjectAttributes,
                                &Path,                                      // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,   // attributes
                                NULL,                                       // root
                                NULL);                                      // security descriptor

    Status = ZwCreateKey (&TcpGuidHandle,
                          KEY_READ,          // We don't need to write any values
                          &TmpObjectAttributes,
                          0,                 // title index
                          NULL,              // class
                          0,                 // create options
                          &Disposition);     // disposition

    // We are done with the Path buffer, so free it
    CTEMemFree(pBuffer);

    if (!NT_SUCCESS(Status))
    {
        KdPrint(("Nbt.GetIPFromRegistry: Error, ZwCreateKey <%x>\n", Status));
        return STATUS_UNSUCCESSFUL;
    }

    Status = STATUS_INVALID_ADDRESS;
    *pNumIpAddresses = 0;
    if (NT_SUCCESS (GetIpAddressesList(TcpGuidHandle,
                                       pwsIpAddressName,
                                       MaxIpAddresses,
                                       pIpAddresses,
                                       pNumIpAddresses)))
    {
        //
        // DHCP may put a 0 Ip address in the registry - we don't want to
        // set the address under these conditions.
        //
        if ((*pNumIpAddresses) && (*pIpAddresses))
        {
            i = 0;
            if (NT_SUCCESS (GetIpAddressesList(TcpGuidHandle,
                                               pwsSubnetMask,
                                               1,
                                               pSubnetMask,
                                               &i)))
            {
                Status = STATUS_SUCCESS;
            }
        }
    }

    ZwClose (TcpGuidHandle);

    return Status;
} // GetIPFromRegistry


//----------------------------------------------------------------------------
NTSTATUS
NbtOpenRegistry(
    IN HANDLE       NbConfigHandle,
    IN PWSTR        String,
    OUT PHANDLE     pHandle
    )

/*++

Routine Description:

    This routine is called by Nbt to open the registry. If the registry
    tree for Nbt exists, then it opens it and returns TRUE. If not, it
    creates the appropriate keys in the registry, opens it, and
    returns FALSE.


Arguments:

    NbConfigHandle  - this is the root handle which String is relative to
    String          - the name of the key to open below the root handle
    pHandle         - returns the handle to the String key.

Return Value:

    The status of the request.

--*/
{

    NTSTATUS        Status;
    UNICODE_STRING  KeyName;
    OBJECT_ATTRIBUTES TmpObjectAttributes;

    CTEPagedCode();

    //
    // Open the Nbt key.
    //
    RtlInitUnicodeString (&KeyName, String);

    InitializeObjectAttributes (&TmpObjectAttributes,
                                &KeyName,                                   // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,   // attributes
                                NbConfigHandle,                             // root
                                NULL);                                      // security descriptor

    Status = ZwOpenKey (pHandle, KEY_READ, &TmpObjectAttributes);

    return Status;
}   /* NbOpenRegistry */


NTSTATUS
NbtParseMultiSzEntries(
    IN  PWSTR       StartBindValue,
    IN  PWSTR       EndBindValue,
    IN  ULONG       MaxBindings,
    OUT tDEVICES    *pDevices,
    OUT ULONG       *pNumDevices
    )
{
    USHORT                      ConfigBindings = 0;
    NTSTATUS                    status = STATUS_SUCCESS;

    CTEPagedCode();

    try {
        while ((StartBindValue < EndBindValue) && (*StartBindValue != 0)) {
            if (ConfigBindings >= MaxBindings) {
                status = STATUS_BUFFER_OVERFLOW;
                break;
            }

            // this sets the buffer ptr in Names to point to CurBindValue, so
            // this value must be real memory and not stack, hence the need
            // to allocate memory above...
            RtlInitUnicodeString (&pDevices->Names[ConfigBindings], (PCWSTR)StartBindValue);
            ++ConfigBindings;

            //
            // Now advance the "Bind" value.
            //
            // wcslen => wide character string length for a unicode string
            StartBindValue += wcslen((PCWSTR)StartBindValue) + 1;
        }

        *pNumDevices = ConfigBindings;
        return (status);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrint (("Nbt.NbtParseMultiSzEntries: Exception <0x%x>\n", GetExceptionCode()));
        for (ConfigBindings = 0; ConfigBindings < MaxBindings; ConfigBindings++) {
            pDevices->Names[ConfigBindings].Buffer = NULL;
            pDevices->Names[ConfigBindings].Length = pDevices->Names[ConfigBindings].MaximumLength = 0;
        }
        *pNumDevices = 0;
        return STATUS_ACCESS_VIOLATION;
    }
}


//----------------------------------------------------------------------------
NTSTATUS
NbtReadLinkageInformation(
    IN  PWSTR       pName,
    IN  HANDLE      LinkageHandle,
    IN  ULONG       MaxBindings,
    OUT tDEVICES    *pDevices,      // place to put read in config data
    OUT ULONG       *pNumDevices
    )

/*++

Routine Description:

    This routine is called by Nbt to read its linkage information
    from the registry. If there is none present, then ConfigData
    is filled with a list of all the adapters that are known
    to Nbt.

Arguments:

    RegistryHandle - A pointer to the open registry.

Return Value:

    Status

--*/

{
    NTSTATUS                    RegistryStatus;
    UNICODE_STRING              BindString;
    ULONG                       BytesWritten = 0;
    PKEY_VALUE_FULL_INFORMATION RegistryData;

    CTEPagedCode();

    pDevices->RegistryData = NULL;
    RtlInitUnicodeString (&BindString, pName); // copy "Bind" or "Export" into the unicode string

    //
    // Determine how many bytes we need to allocate for the Read buffer
    RegistryStatus = ZwQueryValueKey (LinkageHandle,
                                      &BindString,               // string to retrieve
                                      KeyValueFullInformation,
                                      NULL,
                                      0,
                                      &BytesWritten);            // # of bytes to read

    if ((RegistryStatus != STATUS_BUFFER_TOO_SMALL) ||
        (BytesWritten == 0))
    {
        return STATUS_ILL_FORMED_SERVICE_ENTRY;
    }

    if (!(RegistryData = (PKEY_VALUE_FULL_INFORMATION) NbtAllocMem (BytesWritten, NBT_TAG2('33'))))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RegistryStatus = ZwQueryValueKey (LinkageHandle,
                                      &BindString,                      // string to retrieve
                                      KeyValueFullInformation,
                                      (PVOID) RegistryData,             // returned info
                                      BytesWritten,
                                      &BytesWritten);                   // # of bytes valid data

    if (!NT_SUCCESS(RegistryStatus) ||
        (RegistryStatus == STATUS_BUFFER_OVERFLOW))
    {
        CTEMemFree(RegistryData);
        return RegistryStatus;
    }

    if (BytesWritten == 0)
    {
        CTEMemFree(RegistryData);
        return STATUS_ILL_FORMED_SERVICE_ENTRY;
    }

    pDevices->RegistryData = RegistryData;
    NbtParseMultiSzEntries ((PWCHAR)((PUCHAR)RegistryData+RegistryData->DataOffset),
                            (PWSTR) ((PUCHAR)RegistryData+RegistryData->DataOffset+RegistryData->DataLength),
                            MaxBindings,
                            pDevices,
                            pNumDevices);

    return STATUS_SUCCESS;

}   /* NbtReadLinkageInformation */

//----------------------------------------------------------------------------
ULONG
NbtReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN ULONG DefaultValue,
    IN ULONG MinimumValue
    )

/*++

Routine Description:

    This routine is called by Nbt to read a single parameter
    from the registry. If the parameter is found it is stored
    in Data.

Arguments:

    ParametersHandle - A pointer to the open registry.

    ValueName - The name of the value to search for.

    DefaultValue - The default value.

Return Value:

    The value to use; will be the default if the value is not
    found or is not in the correct range.

--*/

{
    static ULONG InformationBuffer[60];
    PKEY_VALUE_FULL_INFORMATION Information =
        (PKEY_VALUE_FULL_INFORMATION)InformationBuffer;
    UNICODE_STRING ValueKeyName;
    ULONG       InformationLength;
    ULONG       ReturnValue=DefaultValue;
    NTSTATUS    Status;
    ULONG       Count=2;
    PWSTR       Dhcp = L"Dhcp";
    BOOLEAN     FreeString = FALSE;

    CTEPagedCode();
    RtlInitUnicodeString (&ValueKeyName, ValueName);

    while (Count--)
    {

        Status = ZwQueryValueKey(
                     ParametersHandle,
                     &ValueKeyName,
                     KeyValueFullInformation,
                     (PVOID)Information,
                     sizeof (InformationBuffer),
                     &InformationLength);


        if ((Status == STATUS_SUCCESS) && (Information->DataLength == sizeof(ULONG)))
        {

            RtlMoveMemory(
                (PVOID)&ReturnValue,
                ((PUCHAR)Information) + Information->DataOffset,
                sizeof(ULONG));

            if (ReturnValue < MinimumValue)
            {
                ReturnValue = MinimumValue;
            }

        }
        else
        {
            //
            // try to read the Dhcp key instead if the first read failed.
            //
            Status = STATUS_SUCCESS;
            if (Count)
            {
                Status = NbtAppendString(Dhcp,ValueName,&ValueKeyName);
            }

            if (!NT_SUCCESS(Status))
            {
                Count = 0;
                ReturnValue = DefaultValue;
            }
            else
                FreeString = TRUE;


        }
    } // of while

    // nbt append string allocates memory.
    if (FreeString)
    {
        CTEMemFree(ValueKeyName.Buffer);

    }
    return ReturnValue;

}   /* NbtReadSingleParameter */


//----------------------------------------------------------------------------
NTSTATUS
OpenAndReadElement(
    IN  PUNICODE_STRING pucRootPath,
    IN  PWSTR           pwsValueName,
    OUT PUNICODE_STRING pucString
    )
/*++

Routine Description:

    This routine is called by Nbt to read in the Ip address appearing in the
    registry at the path pucRootPath, with a key of pwsKeyName

Arguments:
    pucRootPath - the registry path to the key to read
    pwsKeyName  - the key to open (i.e. Tcpip)
    pwsValueName- the name of the value to read (i.e. IPAddress)

Return Value:

    pucString - the string returns the string read from the registry

--*/

{

    NTSTATUS        Status;
    HANDLE          hRootKey;
    OBJECT_ATTRIBUTES TmpObjectAttributes;

    CTEPagedCode();

    InitializeObjectAttributes (&TmpObjectAttributes,
                                pucRootPath,                                // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,   // attributes
                                NULL,                                       // root
                                NULL);                                      // security descriptor

    Status = ZwOpenKey (&hRootKey, KEY_READ, &TmpObjectAttributes);
    if (!NT_SUCCESS(Status))
    {
        return STATUS_UNSUCCESSFUL;
    }

    Status = ReadElement(hRootKey,pwsValueName,pucString);

    ZwClose (hRootKey);

    return(Status);
}


//----------------------------------------------------------------------------
NTSTATUS
ReadElement(
    IN  HANDLE          HandleToKey,
    IN  PWSTR           pwsValueName,
    OUT PUNICODE_STRING pucString
    )
/*++

Routine Description:

    This routine is will read a string value given by pwsValueName, under a
    given Key (which must be open) - given by HandleToKey. This routine
    allocates memory for the buffer in the returned pucString, so the caller
    must deallocate that.

Arguments:

    pwsValueName- the name of the value to read (i.e. IPAddress)

Return Value:

    pucString - the string returns the string read from the registry

--*/

{
    ULONG           ReadStorage[150];   // 600 bytes
    ULONG           BytesRead;
    NTSTATUS        Status;
    PWSTR           pwsSrcString;
    PKEY_VALUE_FULL_INFORMATION ReadValue = (PKEY_VALUE_FULL_INFORMATION)ReadStorage;

    CTEPagedCode();

    // now put the name of the value to read into a unicode string
    RtlInitUnicodeString(pucString,pwsValueName);

    // this read the value of IPAddress under the key opened above
    Status = ZwQueryValueKey(
                         HandleToKey,
                         pucString,               // string to retrieve
                         KeyValueFullInformation,
                         (PVOID)ReadValue,                 // returned info
                         sizeof(ReadStorage),
                         &BytesRead               // # of bytes returned
                         );

    if ( Status == STATUS_BUFFER_OVERFLOW )
    {
        ReadValue = (PKEY_VALUE_FULL_INFORMATION) NbtAllocMem (BytesRead, NBT_TAG2('35'));
        if (ReadValue == NULL)
        {
            IF_DBG(NBT_DEBUG_NTUTIL)
                KdPrint(("ReadElement: failed to allocate %d bytes for element\n",BytesRead));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ReadElement_Return;
        }
        Status = ZwQueryValueKey(
                             HandleToKey,
                             pucString,               // string to retrieve
                             KeyValueFullInformation,
                             (PVOID)ReadValue,                 // returned info
                             BytesRead,
                             &BytesRead               // # of bytes returned
                             );
    }
    if (!NT_SUCCESS(Status))
    {
        IF_DBG(NBT_DEBUG_NTUTIL)
        KdPrint(("failed to Query Value Status = %X\n",Status));
        goto ReadElement_Return;
    }

    if ( BytesRead == 0 )
    {
        Status = STATUS_ILL_FORMED_SERVICE_ENTRY;
        goto ReadElement_Return;
    }
    else
    if (ReadValue->DataLength == 0)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto ReadElement_Return;
    }
    
    if (ReadValue->Type != REG_SZ && ReadValue->Type != REG_EXPAND_SZ) {
        Status = STATUS_UNSUCCESSFUL;
        goto ReadElement_Return;
    }

    // create the pucString and copy the data returned to it
    // assumes that the ReadValue string ends in a UNICODE_NULL
    //bStatus = RtlCreateUnicodeString(pucString,pwSrcString);
    pwsSrcString = (PWSTR)NbtAllocMem ((USHORT)ReadValue->DataLength, NBT_TAG2('36'));
    if (!pwsSrcString)
    {
        ASSERTMSG((PVOID)pwsSrcString,
                    (PCHAR)"Unable to allocate memory for a Unicode string");
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        // move the read in data from the stack to the memory allocated
        // from the nonpaged pool
        RtlMoveMemory(
            (PVOID)pwsSrcString,
            ((PUCHAR)ReadValue) + ReadValue->DataOffset,
            ReadValue->DataLength);

        RtlInitUnicodeString(pucString,pwsSrcString);
        // if there isn't a null on the end of the pwsSrcString, then
        // it will not work correctly. - a null string comes out with a
        // length of 1!! since the null is counted therefore use
        // rtlinitunicode string afterall.
 //       pucString->MaximumLength = ReadValue->DataLength;
 //       pucString->Length = ReadValue->DataLength;
 //       pucString->Buffer = pwsSrcString;
    }

ReadElement_Return:

    if ((ReadValue != (PKEY_VALUE_FULL_INFORMATION)ReadStorage)
        && (ReadValue != NULL))
    {
        CTEMemFree(ReadValue);
    }

    return(Status);
}

//----------------------------------------------------------------------------
NTSTATUS
NTGetLmHostPath(
    OUT PUCHAR *ppPath
    )
/*++

Routine Description:

    This routine will read the DataBasePath from under
     ...\tcpip\parameters\databasepath

Arguments:

    pPath - ptr to a buffer containing the path name.

Return Value:


--*/

{
    NTSTATUS        status;
    UNICODE_STRING  ucDataBase;
    STRING          StringPath;
    STRING          LmhostsString;
    ULONG           StringMax;
    PWSTR           LmHosts = L"lmhosts";
    PWSTR           TcpIpParams = L"TcpIp\\Parameters";
    PWSTR           TcpParams = L"Tcp\\Parameters";
    PWSTR           DataBase = L"DataBasePath";
    PCHAR           ascLmhosts="\\lmhosts";
    PCHAR           pBuffer;

    CTEPagedCode();

    *ppPath = NULL;
    status = ReadStringRelative(&NbtConfig.pRegistry,
                                TcpIpParams,
                                DataBase,
                                &ucDataBase);

    if (!NT_SUCCESS(status))
    {
        // check for the new TCP stack which a slightly different registry
        // key name.
        //
        status = ReadStringRelative(&NbtConfig.pRegistry,
                                    TcpParams,
                                    DataBase,
                                    &ucDataBase);
        if (!NT_SUCCESS(status))
        {
            return STATUS_UNSUCCESSFUL;
        }
    }


    StringMax = ucDataBase.Length/sizeof(WCHAR) + strlen(ascLmhosts) + 1;
    pBuffer = NbtAllocMem (StringMax, NBT_TAG2('37'));
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    StringPath.Buffer = (PCHAR)pBuffer;
    StringPath.MaximumLength = (USHORT)StringMax;
    StringPath.Length = (USHORT)StringMax;

    // convert to ascii from unicode
    status = RtlUnicodeStringToAnsiString(&StringPath, &ucDataBase, FALSE);
    CTEMemFree(ucDataBase.Buffer);  // this memory was allocated in OpenAndReadElement

    if (!NT_SUCCESS(status))
    {
        CTEMemFree(StringPath.Buffer);
        return(STATUS_UNSUCCESSFUL);
    }

    // now put the "\lmhosts" name on the end of the string
    //
    RtlInitString(&LmhostsString, ascLmhosts);
    status = RtlAppendStringToString(&StringPath, &LmhostsString);
    if (NT_SUCCESS(status))
    {
        //
        // is the first part of the directory "%SystemRoot%" ?
        //
        // If so, it must be changed to "\\SystemRoot\\".
        //
        //          0123456789 123456789 1
        //          %SystemRoot%\somewhere
        //
        //
        if (strncmp(StringPath.Buffer, "%SystemRoot%", 12) == 0)
        {

            StringPath.Buffer[0]  = '\\';
            StringPath.Buffer[11] = '\\';
            if (StringPath.Buffer[12] == '\\')
            {
                ASSERT(StringPath.Length >= 13);

                if (StringPath.Length > 13)
                {
                    // overlapped copy
                    RtlMoveMemory (&(StringPath.Buffer[12]),        // Destination
                                   &(StringPath.Buffer[13]),        // Source
                                   (ULONG) StringPath.Length - 13); // Length

                    StringPath.Buffer[StringPath.Length - 1] = (CHAR) NULL;
                }

                StringPath.Length--;
            }
        }

        *ppPath = (PCHAR)StringPath.Buffer;
    }
    else
    {
        CTEMemFree(StringPath.Buffer);
    }

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
ReadStringRelative(
    IN  PUNICODE_STRING pRegistryPath,
    IN  PWSTR           pRelativePath,
    IN  PWSTR           pValueName,
    OUT PUNICODE_STRING pOutString
    )

/*++

Routine Description:

    This routine reads a string from a registry key parallel to the
    Netbt key - such as ..\tcpip\parameters\database

Arguments:

    pRegistryPath = ptr to the Netbt Registry path
    pRelativePath = path to value relative to same root as nbt.
    pValueName    = value to read



Return Value:

    The length of the path up to and including the last slash and a ptr
    to the first character of the last element of the string.

--*/

{
    NTSTATUS        status;
    UNICODE_STRING  RegistryPath;
    UNICODE_STRING  RelativePath;
    ULONG           StringMax;
    PVOID           pBuffer;
    PWSTR           pLastElement;
    ULONG           Length;

    CTEPagedCode();

    StringMax = (pRegistryPath->MaximumLength + wcslen(pRelativePath)*sizeof(WCHAR)+2);
    //
    // allocate some memory for the registry path so that it is large enough
    // to append a string on to, for the relative key to be read
    //
    if (!(pBuffer = NbtAllocMem (StringMax, NBT_TAG2('38'))))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RegistryPath.MaximumLength = (USHORT)StringMax;
    RegistryPath.Buffer = pBuffer;
    RtlCopyUnicodeString(&RegistryPath,pRegistryPath);

    //
    // find the last backslash and truncate the string
    NbtFindLastSlash(&RegistryPath,&pLastElement,&Length);
    RegistryPath.Length = (USHORT)Length;

    if (pLastElement)
    {
        *pLastElement = UNICODE_NULL;
        RtlInitUnicodeString(&RelativePath,pRelativePath);
        status = RtlAppendUnicodeStringToString(&RegistryPath,&RelativePath);

        if (NT_SUCCESS(status))
        {
            status = OpenAndReadElement(&RegistryPath,pValueName,pOutString);

            if (NT_SUCCESS(status))
            {
                // free the registry path
                //
                CTEMemFree(pBuffer);
                return(status);
            }
        }
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }

    CTEMemFree(pBuffer);
    return(status);
}
//----------------------------------------------------------------------------
VOID
NbtFindLastSlash(
    IN  PUNICODE_STRING pucRegistryPath,
    OUT PWSTR           *ppucLastElement,
    IN  int             *piLength
    )

/*++

Routine Description:

    This routine is called by Nbt to find the last slash in a registry
    path name.

Arguments:


Return Value:

    The length of the path up to and including the last slash and a ptr
    to the first character of the last element of the string.

--*/

{
    int             i;
    PWSTR           pwsSlash = L"\\";
    int             iStart;

    CTEPagedCode();

    // search starting at the end of the string for the last back slash
    iStart = wcslen(pucRegistryPath->Buffer)-1;
    for(i=iStart;i>=0 ;i-- )
    {
        if (pucRegistryPath->Buffer[i] == *pwsSlash)
        {
            if (i==pucRegistryPath->Length-1)
            {
                // name ends a back slash... this is an error
                break;
            }
            // increase one to allow for the slash
            *piLength = (i+1)*sizeof(WCHAR);
            if (ppucLastElement != NULL)
            {
                // want ptr to point at character after the slash
                *ppucLastElement = &pucRegistryPath->Buffer[i+1];
            }
            return;
        }
    }

    // null the pointer if one is passed in
    if (ppucLastElement != NULL)
    {
        *ppucLastElement = NULL;
    }
    *piLength = 0;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\tdiaddr.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Tdihndlr.c

Abstract:

    This file contains code relating to manipulation of address objects
    that is specific to the NT operating system.  It creates address endpoints
    with the transport provider.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NbtTdiOpenAddress)
#pragma CTEMakePageable(PAGE, NbtTdiOpenControl)
#pragma CTEMakePageable(PAGE, SetEventHandler)
#pragma CTEMakePageable(PAGE, SubmitTdiRequest)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
NTSTATUS
NbtTdiOpenAddress (
    OUT PHANDLE             pHandle,
    OUT PDEVICE_OBJECT      *ppDeviceObject,
    OUT PFILE_OBJECT        *ppFileObject,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  USHORT               PortNumber,
    IN  ULONG               IpAddress,
    IN  ULONG               Flags
    )
/*++

Routine Description:

    Note: This synchronous call may take a number of seconds. It runs in
    the context of the caller.  The code Opens an Address object with the
    transport provider and then sets up event handlers for Receive,
    Disconnect, Datagrams and Errors.

    THIS ROUTINE MUST BE CALLED IN THE CONTEXT OF THE FSP (I.E.
    PROBABLY AN EXECUTIVE WORKER THREAD).

    The address data structures are found in tdi.h , but they are rather
    confusing since the definitions have been spread across several data types.
    This section shows the complete data type for Ip address:

    typedef struct
    {
        int     TA_AddressCount;
        struct _TA_ADDRESS
        {
            USHORT  AddressType;
            USHORT  AddressLength;
            struct _TDI_ADDRESS_IP
            {
                USHORT  sin_port;
                USHORT  in_addr;
                UCHAR   sin_zero[8];
            } TDI_ADDRESS_IP

        } TA_ADDRESS[AddressCount];

    } TRANSPORT_ADDRESS

    An EA buffer is allocated (for the IRP), with an EA name of "TransportAddress"
    and value is a structure of type TRANSPORT_ADDRESS.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{


    OBJECT_ATTRIBUTES           AddressAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    PFILE_FULL_EA_INFORMATION   EaBuffer;
    NTSTATUS                    status, locstatus;
    PWSTR                       pNameTcp=L"Tcp";
    PWSTR                       pNameUdp=L"Udp";
    UNICODE_STRING              ucDeviceName;
    PTRANSPORT_ADDRESS          pTransAddressEa;
    PTRANSPORT_ADDRESS          pTransAddr;
    TDI_ADDRESS_IP              IpAddr;
    BOOLEAN                     Attached = FALSE;
    PFILE_OBJECT                pFileObject;
    HANDLE                      FileHandle;
    ULONG                       i, NumAddresses, EaBufferSize;

    CTEPagedCode();
    *ppFileObject = NULL;
    *ppDeviceObject = NULL;
    // copy device name into the unicode string - either Udp or Tcp
    //
    if (Flags & TCP_FLAG)
    {
        status = CreateDeviceString(pNameTcp,&ucDeviceName);
    }
    else
    {
        status = CreateDeviceString(pNameUdp,&ucDeviceName);
    }

    if (!NT_SUCCESS(status))
    {
        return(status);
    }

    NumAddresses = 1 + pDeviceContext->NumAdditionalIpAddresses;
    EaBufferSize = sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                    TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                    sizeof(TRANSPORT_ADDRESS) +
                    NumAddresses*sizeof(TDI_ADDRESS_IP);

    EaBuffer = NbtAllocMem (EaBufferSize, NBT_TAG('j'));
    if (EaBuffer == NULL)
    {
        DbgPrint ("Nbt.NbtTdiOpenAddress: FAILed to allocate memory for Eabuffer");
        CTEMemFree(ucDeviceName.Buffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // allocate Memory for the transport address
    //
    pTransAddr = NbtAllocMem (sizeof(TRANSPORT_ADDRESS)+NumAddresses*sizeof(TDI_ADDRESS_IP),NBT_TAG('k'));
    if (pTransAddr == NULL)
    {
        CTEMemFree(ucDeviceName.Buffer);
        CTEMemFree(EaBuffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    EaBuffer->EaValueLength = (USHORT)(sizeof(TRANSPORT_ADDRESS) -1 + NumAddresses*sizeof(TDI_ADDRESS_IP));
    RtlMoveMemory (EaBuffer->EaName, TdiTransportAddress, EaBuffer->EaNameLength+1); // "TransportAddress"

    IF_DBG(NBT_DEBUG_TDIADDR)
        KdPrint(("EaValueLength = %d\n",EaBuffer->EaValueLength));

    // fill in the IP address and Port number
    //
    pTransAddressEa = (TRANSPORT_ADDRESS *)&EaBuffer->EaName[EaBuffer->EaNameLength+1];

#ifdef _NETBIOSLESS
    //
    // For message-mode, open the ANY address regardless of what is passed in
    // This gives us an adapter independent handle
    //
    if (IsDeviceNetbiosless(pDeviceContext))
    {
        IpAddress = IP_ANY_ADDRESS;
    }
#endif

    IpAddr.sin_port = htons(PortNumber);    // put in network order
    IpAddr.in_addr = htonl(IpAddress);

    // zero fill the  last component of the IP address
    //
    RtlFillMemory((PVOID)&IpAddr.sin_zero, sizeof(IpAddr.sin_zero), 0);

    // copy the ip address to the end of the structure
    //
    RtlMoveMemory(pTransAddr->Address[0].Address, (CONST PVOID)&IpAddr, sizeof(IpAddr));
    pTransAddr->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    pTransAddr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;

    for (i=0; i<pDeviceContext->NumAdditionalIpAddresses; i++)
    {
        IpAddr.sin_port = htons(PortNumber);    // put in network order
        IpAddr.in_addr = htonl(pDeviceContext->AdditionalIpAddresses[i]);

        // copy the ip address to the structure
        RtlMoveMemory(pTransAddr->Address[i+1].Address, (CONST PVOID)&IpAddr, sizeof(IpAddr));
        pTransAddr->Address[i+1].AddressLength = sizeof(TDI_ADDRESS_IP);
        pTransAddr->Address[i+1].AddressType = TDI_ADDRESS_TYPE_IP;
    }

    pTransAddr->TAAddressCount = NumAddresses;

    // copy the ip address to the end of the name in the EA structure
    //
    RtlMoveMemory((PVOID)pTransAddressEa,
                  (CONST PVOID)pTransAddr,
                  NumAddresses*sizeof(TDI_ADDRESS_IP) + sizeof(TRANSPORT_ADDRESS)-1);


    IF_DBG(NBT_DEBUG_TDIADDR)
        KdPrint(("creating Address named %ws\n",ucDeviceName.Buffer));

#ifdef HDL_FIX
    InitializeObjectAttributes (&AddressAttributes,
                                &ucDeviceName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);
#else
    InitializeObjectAttributes (&AddressAttributes,
                                &ucDeviceName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);
#endif  // HDL_FIX

    status = ZwCreateFile (&FileHandle,
                           GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                           &AddressAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           (PortNumber)? 0: FILE_SHARE_READ | FILE_SHARE_WRITE, // bug 296639: allow sharing for port 0
                           FILE_OPEN_IF,
                           0,
                           (PVOID)EaBuffer,
                           sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                               EaBuffer->EaNameLength + 1 +
                               EaBuffer->EaValueLength);

    IF_DBG(NBT_DEBUG_HANDLES)
        KdPrint (("\t===><%x>\tNbtTdiOpenAddress->ZwCreateFile, Status = <%x>\n", FileHandle, status));

    CTEMemFree((PVOID)pTransAddr);
    CTEMemFree((PVOID)EaBuffer);
    CTEMemFree(ucDeviceName.Buffer);

    if (NT_SUCCESS(status))
    {
        // if the ZwCreate passed set the status to the IoStatus
        status = IoStatusBlock.Status;
        if (!NT_SUCCESS(status))
        {
            IF_DBG(NBT_DEBUG_TDIADDR)
                KdPrint(("Nbt.NbtTdiOpenAddress:  Failed to Open the Address to the transport, status = %X\n",
                            status));

            return(status);
        }

        // dereference the file object to keep the device ptr around to avoid
        // this dereference at run time
        //
        status = ObReferenceObjectByHandle (FileHandle,
                                            (ULONG)0,
                                            0,
                                            KernelMode,
                                            (PVOID *)&pFileObject,
                                            NULL);

            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t  ++<%x>====><%x>\tNbtTdiOpenAddress->ObReferenceObjectByHandle, Status = <%x>\n", FileHandle, pFileObject, status));

        if (NT_SUCCESS(status))
        {
            // return the handle to the caller
            //
            *pHandle = FileHandle;
            *ppFileObject = pFileObject;
	    *ppDeviceObject = IoGetRelatedDeviceObject(*ppFileObject);

            status = SetEventHandler (*ppDeviceObject,
                                      *ppFileObject,
                                      TDI_EVENT_ERROR,
                                      (PVOID)TdiErrorHandler,
                                      (PVOID)pDeviceContext);

            if (NT_SUCCESS(status))
            {
                // if this is a TCP address being opened, then create different
                // event handlers for connections
                //
                if (Flags & TCP_FLAG)
                {
                    status = SetEventHandler (*ppDeviceObject,
                                              *ppFileObject,
                                              TDI_EVENT_RECEIVE,
                                              (PVOID)TdiReceiveHandler,
                                              (PVOID)pDeviceContext);

                    if (NT_SUCCESS(status))
                    {
                        status = SetEventHandler (*ppDeviceObject,
                                                  *ppFileObject,
                                                  TDI_EVENT_DISCONNECT,
                                                  (PVOID)TdiDisconnectHandler,
                                                  (PVOID)pDeviceContext);

                        if (NT_SUCCESS(status))
                        {
                            // only set a connect handler if the session flag is set.
                            // In this case the address being opened is the Netbios session
                            // port 139
                            //
                            if (Flags & SESSION_FLAG)
                            {
                                status = SetEventHandler (*ppDeviceObject,
                                                          *ppFileObject,
                                                          TDI_EVENT_CONNECT,
                                                          (PVOID)TdiConnectHandler,
                                                          (PVOID)pDeviceContext);

                                if (NT_SUCCESS(status))
                                {
                                     return(status);
                                }
                            }
                            else
                                return(status);
                        }
                    }
                }
                else
                {
                    // Datagram ports only need this event handler
#ifdef _NETBIOSLESS
                    if (PortNumber == pDeviceContext->DatagramPort)
#else
                    if (PortNumber == NBT_DATAGRAM_UDP_PORT)
#endif
                    {
                        // Datagram Udp Handler
                        status = SetEventHandler (*ppDeviceObject,
                                                  *ppFileObject,
                                                  TDI_EVENT_RECEIVE_DATAGRAM,
                                                  (PVOID)TdiRcvDatagramHandler,
                                                  (PVOID)pDeviceContext);
                        if (NT_SUCCESS(status))
                        {
                            return(status);
                        }
                    }
                    else
                    {
                        // Name Service Udp handler
                        status = SetEventHandler (*ppDeviceObject,
                                                  *ppFileObject,
                                                  TDI_EVENT_RECEIVE_DATAGRAM,
                                                  (PVOID)TdiRcvNameSrvHandler,
                                                  (PVOID)pDeviceContext);

                        if (NT_SUCCESS(status))
                        {
                            return(status);
                        }
                    }
                }

                //
                // ERROR Case
                //
                ObDereferenceObject(pFileObject);
                IF_DBG(NBT_DEBUG_HANDLES)
                    KdPrint (("\t  --<   ><====<%x>\tNbtTdiOpenAddress->ObDereferenceObject\n", pFileObject));

                locstatus = ZwClose(FileHandle);
                IF_DBG(NBT_DEBUG_HANDLES)
                    KdPrint (("\t<===<%x>\tNbtTdiOpenAddress1->ZwClose, status = <%x>\n", FileHandle, locstatus));

                // NULL out the returned data to avoid double close and overdereferencing
                *pHandle = NULL;
                *ppFileObject = NULL;
                *ppDeviceObject = NULL;
                return(status);
            }

        }
        else
        {
            IF_DBG(NBT_DEBUG_TDIADDR)
                KdPrint(("Failed Open Address (Dereference Object) status = %X\n", status));

            locstatus = ZwClose(FileHandle);
            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t<===<%x>\tNbtTdiOpenAddress2->ZwClose, status = <%x>\n", FileHandle, locstatus));
        }

    }
    else
    {
        IF_DBG(NBT_DEBUG_TDIADDR)
            KdPrint(("Nbt.NbtTdiOpenAddress:  ZwCreateFile Failed, status = %X\n", status));
    }


    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtTdiOpenControl (
    IN  tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description:

    This routine opens a control object with the transport.  It is very similar
    to opening an address object, above.

Arguments:



Return Value:

    Status of the operation.

--*/
{
    IO_STATUS_BLOCK             IoStatusBlock;
    NTSTATUS                    Status, locstatus;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    PWSTR                       pName=L"Tcp";
    PFILE_FULL_EA_INFORMATION   EaBuffer;
    UNICODE_STRING              DeviceName;
    BOOLEAN                     Attached = FALSE;


    CTEPagedCode();
    // copy device name into the unicode string
    Status = CreateDeviceString(pName,&DeviceName);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

#ifdef HDL_FIX
    InitializeObjectAttributes (&ObjectAttributes,
                                &DeviceName,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);
#else
    InitializeObjectAttributes (&ObjectAttributes,
                                &DeviceName,
                                0,
                                NULL,
                                NULL);
#endif  // HDL_FIX

    IF_DBG(NBT_DEBUG_TDIADDR)
        KdPrint(("Nbt.NbtTdiOpenControl: Tcp device to open = %ws\n", DeviceName.Buffer));

    EaBuffer = NULL;

    Status = ZwCreateFile ((PHANDLE)&pDeviceContext->hControl,
                           GENERIC_READ | GENERIC_WRITE,
                           &ObjectAttributes,     // object attributes.
                           &IoStatusBlock,        // returned status information.
                           NULL,                  // block size (unused).
                           FILE_ATTRIBUTE_NORMAL, // file attributes.
                           0,
                           FILE_CREATE,
                           0,                     // create options.
                           (PVOID)EaBuffer,       // EA buffer.
                           0); // Ea length


    CTEMemFree(DeviceName.Buffer);

    IF_DBG(NBT_DEBUG_HANDLES)
        KdPrint (("\t===><%x>\tNbtTdiOpenControl->ZwCreateFile, Status = <%x>\n", pDeviceContext->hControl, Status));

    if ( NT_SUCCESS( Status ))
    {
        // if the ZwCreate passed set the status to the IoStatus
        Status = IoStatusBlock.Status;

        if (!NT_SUCCESS(Status))
        {
            IF_DBG(NBT_DEBUG_TDIADDR)
                KdPrint(("Nbt:Failed to Open the control connection to the transport, status = %X\n",Status));

        }
        else
        {
            // get a reference to the file object and save it since we can't
            // dereference a file handle at DPC level so we do it now and keep
            // the ptr around for later.
            Status = ObReferenceObjectByHandle (pDeviceContext->hControl,
                                                0L,
                                                NULL,
                                                KernelMode,
                                                (PVOID *)&pDeviceContext->pControlFileObject,
                                                NULL);

            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t  ++<%x>====><%x>\tNbtTdiOpenControl->ObReferenceObjectByHandle, Status = <%x>\n", pDeviceContext->hControl, pDeviceContext->pControlFileObject, Status));

            if (!NT_SUCCESS(Status))
            {
                locstatus = ZwClose(pDeviceContext->hControl);
                IF_DBG(NBT_DEBUG_HANDLES)
                    KdPrint (("\t<===<%x>\tNbtTdiOpenControl->ZwClose, status = <%x>\n", pDeviceContext->hControl, locstatus));
                pDeviceContext->hControl = NULL;
            }
            else
            {
                pDeviceContext->pControlDeviceObject =
			       IoGetRelatedDeviceObject(pDeviceContext->pControlFileObject);
            }
        }

    }
    else
    {
        IF_DBG(NBT_DEBUG_TDIADDR)
            KdPrint(("Nbt:Failed to Open the control connection to the transport, status1 = %X\n", Status));

        // set control file object ptr to null so we know that we didnot open
        // the control point.
        //
        pDeviceContext->pControlFileObject = NULL;
    }

    return Status;

} /* NbtTdiOpenControl */


//----------------------------------------------------------------------------
NTSTATUS
NbtTdiCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine does not complete the Irp. It is used to signal to a
    synchronous part of the NBT driver that it can proceed (i.e.
    to allow some code that is waiting on a "KeWaitForSingleObject" to
    proceeed.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the event associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    IF_DBG(NBT_DEBUG_TDIADDR)
        KdPrint( ("Nbt.NbtTdiCompletionRoutine: CompletionEvent: %X, Irp: %X, DeviceObject: %X\n",
                Context, Irp, DeviceObject));

    KeSetEvent((PKEVENT )Context, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}

//----------------------------------------------------------------------------
NTSTATUS
SetEventHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine registers an event handler with a TDI transport provider.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies the device object of the transport provider.
    IN PFILE_OBJECT FileObject - Supplies the address object's file object.
    IN ULONG EventType, - Supplies the type of event.
    IN PVOID EventHandler - Supplies the event handler.
    IN PVOID Context - Supplies the context passed into the event handler when it runs

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS Status;
    PIRP Irp;

    CTEPagedCode();
    Irp = IoAllocateIrp(IoGetRelatedDeviceObject(FileObject)->StackSize, FALSE);

    if (Irp == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildSetEventHandler(Irp, DeviceObject, FileObject,
                            NULL, NULL,
                            EventType, EventHandler, Context);

    Status = SubmitTdiRequest(FileObject, Irp);

    IoFreeIrp(Irp);

    return Status;
}


//----------------------------------------------------------------------------
NTSTATUS
NbtProcessIPRequest(
    IN ULONG        IOControlCode,
    IN PVOID        pInBuffer,
    IN ULONG        InBufferLen,
    OUT PVOID       *pOutBuffer,
    IN OUT ULONG    *pOutBufferLen
    )

/*++

Routine Description:

    This routine performs iIOCTL queries into IP

Arguments:

    IOControlCode   - Ioctl to be made into IP
    pInBuffer       - Buffer containing data to be passed into IP
    InBufferLen     - Length of Input Buffer data
    pOutBuffer      - Returned information
    pOutBufferLen   - Initial expected length of Output Buffer + final length

Return Value:

    NTSTATUS - Final status of the operation

--*/

{
    NTSTATUS                Status;
    HANDLE                  hIP;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    UNICODE_STRING          ucDeviceName;
    PWSTR                   pNameIP = L"IP";
    IO_STATUS_BLOCK         IoStatusBlock;
    UCHAR                   *pIPInfo = NULL;
    ULONG                   OutBufferLen = 0;
    BOOLEAN                 fAttached = FALSE;
    HANDLE                  Event = NULL;

    CTEPagedCode();

    ucDeviceName.Buffer = NULL;
    Status = CreateDeviceString (pNameIP, &ucDeviceName);
    if (!NT_SUCCESS (Status))
    {
        KdPrint (("Nbt.NbtProcessIPRequest: ERROR <%x> -- CreateDeviceString\n", Status));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    if (pOutBuffer)
    {
        ASSERT (pOutBufferLen);
        OutBufferLen = *pOutBufferLen;  // Save the initial buffer length
        *pOutBuffer = NULL;
        *pOutBufferLen = 0;     // Initialize the return parameter in case we fail below

        if (!OutBufferLen ||
            !(pIPInfo = NbtAllocMem (OutBufferLen, NBT_TAG2('a9'))))
        {
            if (ucDeviceName.Buffer)
            {
                CTEMemFree (ucDeviceName.Buffer);
            }
            KdPrint (("Nbt.NbtProcessIPRequest: ERROR <STATUS_INSUFFICIENT_RESOURCES>\n"));
            return (STATUS_INSUFFICIENT_RESOURCES);
        }
    }

#ifdef HDL_FIX
    InitializeObjectAttributes (&ObjectAttributes,
                                &ucDeviceName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);
#else
    InitializeObjectAttributes (&ObjectAttributes,
                                &ucDeviceName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);
#endif  // HDL_FIX

    CTEAttachFsp(&fAttached, REF_FSP_PROCESS_IP_REQUEST);

    Status = ZwCreateFile (&hIP,
                           SYNCHRONIZE | GENERIC_READ,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           0,
                           FILE_OPEN,
                           0,
                           NULL,
                           0);

    CTEMemFree(ucDeviceName.Buffer);

    //
    // If we succeeded above, let us also try to create the Event handle
    //
    if ((NT_SUCCESS (Status)) &&
        (!NT_SUCCESS (Status = ZwCreateEvent(&Event, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE))))
    {
        ZwClose (hIP);
    }

    if (!NT_SUCCESS (Status))
    {
        CTEDetachFsp(fAttached, REF_FSP_PROCESS_IP_REQUEST);
        KdPrint (("Nbt.NbtProcessIPRequest: ERROR <%x> -- ZwCreate\n", Status));
        if (pIPInfo)
        {
            CTEMemFree (pIPInfo);
        }
        return (Status);
    }

    //
    // At this point, we have succeeded in creating the hIP and Event handles,
    // and possibly also the output buffer memory (pIPInfo)
    //
    do
    {
        Status = ZwDeviceIoControlFile(hIP,                 // g_hIPDriverHandle
                                       Event,
                                       NULL,
                                       NULL,
                                       &IoStatusBlock,
                                       IOControlCode,       // Ioctl
                                       pInBuffer,
                                       InBufferLen,
                                       pIPInfo,
                                       OutBufferLen);

        if (Status == STATUS_PENDING)
        {
            Status = NtWaitForSingleObject (Event,  FALSE, NULL);
            ASSERT(Status == STATUS_SUCCESS);
        }

        Status = IoStatusBlock.Status;
        if (Status == STATUS_BUFFER_OVERFLOW)
        {
            if (!OutBufferLen)
            {
                KdPrint (("Nbt.NbtProcessIPRequest: <%x> => overflow when no data expected\n",IOControlCode));
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
            
            CTEMemFree (pIPInfo);
            OutBufferLen *=2;
            if (NULL == (pIPInfo = NbtAllocMem (OutBufferLen, NBT_TAG2('b0'))))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    } while (Status == STATUS_BUFFER_OVERFLOW);

    ZwClose (Event);
    ZwClose (hIP);
    CTEDetachFsp(fAttached, REF_FSP_PROCESS_IP_REQUEST);

    if (NT_SUCCESS(Status))
    {
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("Nbt.NbtProcessIPRequest: Success, Ioctl=<%x>\n", IOControlCode));

        if ((pOutBuffer) && (pOutBufferLen))
        {
            *pOutBuffer = pIPInfo;
            *pOutBufferLen = OutBufferLen;
        }
        else if (pIPInfo)
        {
            CTEMemFree (pIPInfo);
        }
    }
    else
    {
        KdPrint(("Nbt.NbtProcessIPRequest: IOCTL <%x> FAILed <%x>\n", IOControlCode, Status));

        if (pIPInfo)
        {
            CTEMemFree (pIPInfo);
        }
    }

    return (Status);
}



#if FAST_DISP
//----------------------------------------------------------------------------
NTSTATUS
NbtQueryIpHandler(
    IN  PFILE_OBJECT    FileObject,
    IN  ULONG           IOControlCode,
    OUT PVOID           *EntryPoint
    )
/*++

Routine Description:

    This routine iIOCTL queries for fast send entry

Arguments:

    IN PFILE_OBJECT FileObject - Supplies the address object's file object.
    IN PLONG EntryPoint  - Holder of fast send address

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK iosb;

    CTEPagedCode();

    if (!(Irp = IoAllocateIrp(IoGetRelatedDeviceObject(FileObject)->StackSize, FALSE)))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    //Build IRP for sync io.

    Irp->MdlAddress = NULL;

    Irp->Flags = (LONG)IRP_SYNCHRONOUS_API;
    Irp->RequestorMode = KernelMode;
    Irp->PendingReturned = FALSE;

    Irp->UserIosb = &iosb;

    Irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

    Irp->AssociatedIrp.SystemBuffer = NULL;
    Irp->UserBuffer = NULL;

    Irp->Tail.Overlay.Thread = PsGetCurrentThread();
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.AuxiliaryBuffer = NULL;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;


    irpSp = IoGetNextIrpStackLocation( Irp );
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = IoGetRelatedDeviceObject(FileObject);

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->MinorFunction = 0;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOControlCode;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = EntryPoint;

    // Now submit the Irp to know if tcp supports fast path

    Status = SubmitTdiRequest(FileObject, Irp);
    if (!NT_SUCCESS(Status))
    {
        *EntryPoint = NULL;
        IF_DBG(NBT_DEBUG_TDIADDR)
            KdPrint(("Nbt.NbtQueryDirectSendEntry: Query failed status %x \n", Status));
    }

    Irp->UserIosb = NULL;
    IoFreeIrp(Irp);

    return Status;
}
#endif

//----------------------------------------------------------------------------
NTSTATUS
SubmitTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PFILE_OBJECT FileObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    KEVENT Event;
    NTSTATUS Status;


    CTEPagedCode();
    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    // set the address of the routine to be executed when the IRP
    // finishes.  This routine signals the event and allows the code
    // below to continue (i.e. KeWaitForSingleObject)
    //
    IoSetCompletionRoutine(Irp,
                (PIO_COMPLETION_ROUTINE)NbtTdiCompletionRoutine,
                (PVOID)&Event,
                TRUE, TRUE, TRUE);

    CHECK_COMPLETION(Irp);
    Status = IoCallDriver(IoGetRelatedDeviceObject(FileObject), Irp);

    //
    //  If it failed immediately, return now, otherwise wait.
    //

    if (!NT_SUCCESS(Status))
    {
        IF_DBG(NBT_DEBUG_TDIADDR)
            KdPrint(("Nbt.SubmitTdiRequest: Failed to Submit Tdi Request, status = %X\n",Status));
        return Status;
    }

    if (Status == STATUS_PENDING)
    {

        Status = KeWaitForSingleObject ((PVOID)&Event, // Object to wait on.
                                        Executive,  // Reason for waiting
                                        KernelMode, // Processor mode
                                        FALSE,      // Alertable
                                        NULL);      // Timeout
        ASSERT(Status == STATUS_SUCCESS);
        if (!NT_SUCCESS(Status))
        {
            IF_DBG(NBT_DEBUG_TDIADDR)
                KdPrint(("Nbt.SubmitTdiRequest: Failed on return from KeWaitForSingleObj, status = %X\n",
                    Status));
            return Status;
        }

        Status = Irp->IoStatus.Status;

        IF_DBG(NBT_DEBUG_TDIADDR)
            KdPrint(("Nbt.SubmitTdiRequest: Io Status from setting event = %X\n",Status));
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\ntutil.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Ntutil.c

Abstract:

    This file contains a number of utility and support routines that are
    NT specific.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"
#include "ntprocs.h"
#include "stdio.h"
#include <ntddtcp.h>
#undef uint     // undef to avoid a warning where tdiinfo.h redefines it
#include <tcpinfo.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include "ntddip.h"     // Needed for PNETBT_PNP_RECONFIG_REQUEST
#include <align.h>
#include "ntutil.tmh"

NTSTATUS
CreateControlObject(
    tNBTCONFIG  *pConfig
    );

NTSTATUS
NbtProcessDhcpRequest(
    tDEVICECONTEXT  *pDeviceContext);
VOID
GetExtendedAttributes(
    tDEVICECONTEXT  *pDeviceContext
     );

PSTRM_PROCESSOR_LOG      LogAlloc ;
PSTRM_PROCESSOR_LOG      LogFree ;

extern      tTIMERQ TimerQ;

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NbtAllocAndInitDevice)
#pragma CTEMakePageable(PAGE, CreateControlObject)
#pragma CTEMakePageable(PAGE, NbtProcessDhcpRequest)
#pragma CTEMakePageable(PAGE, NbtCreateAddressObjects)
#pragma CTEMakePageable(PAGE, GetExtendedAttributes)
#pragma CTEMakePageable(PAGE, ConvertToUlong)
#pragma CTEMakePageable(PAGE, NbtInitMdlQ)
#pragma CTEMakePageable(PAGE, NTZwCloseFile)
#pragma CTEMakePageable(PAGE, NTReReadRegistry)
#pragma CTEMakePageable(PAGE, DelayedNbtLogDuplicateNameEvent)
#pragma CTEMakePageable(PAGE, DelayedNbtCloseFileHandles)
#pragma CTEMakePageable(PAGE, SaveClientSecurity)
#endif
//*******************  Pageable Routine Declarations ****************

ulong
GetUnique32BitValue(
    void
    )

/*++

Routine Description:

    Returns a reasonably unique 32-bit number based on the system clock.
    In NT, we take the current system time, convert it to milliseconds,
    and return the low 32 bits.

Arguments:

    None.

Return Value:

    A reasonably unique 32-bit value.

--*/

{
    LARGE_INTEGER  ntTime, tmpTime;

    KeQuerySystemTime(&ntTime);

    tmpTime = CTEConvert100nsToMilliseconds(ntTime);

    return(tmpTime.LowPart);
}



//----------------------------------------------------------------------------
NTSTATUS
NbtAllocAndInitDevice(
    PUNICODE_STRING      pucBindName,
    PUNICODE_STRING      pucExportName,
    tDEVICECONTEXT       **ppDeviceContext,
    enum eNbtDevice      DeviceType
    )
/*++

Routine Description:

    This routine mainly allocates the device object and initializes some
    of its fields.

Arguments:


Return Value:

    status

--*/

{
    NTSTATUS            Status;
    PUCHAR              Buffer;
    ULONG               LinkOffset;
    tDEVICECONTEXT      *pDeviceContext;
    PDEVICE_OBJECT      DeviceObject = NULL;

    CTEPagedCode();

    *ppDeviceContext = NULL;

    Buffer = NbtAllocMem(pucExportName->MaximumLength+pucBindName->MaximumLength,NBT_TAG('w'));
    if (Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = IoCreateDevice (NbtConfig.DriverObject,                                  // Driver Object
                             sizeof(tDEVICECONTEXT)-sizeof(DEVICE_OBJECT),  // Device Extension
                             pucExportName,                                 // Device Name
                             FILE_DEVICE_NETWORK,                           // Device type 0x12
                             FILE_DEVICE_SECURE_OPEN,                       // Device Characteristics
                             FALSE,                                         // Exclusive
                             &DeviceObject);

    if (!NT_SUCCESS( Status ))
    {
        KdPrint(("Nbt.NbtAllocAndInitDevice:  FAILed <%x> ExportDevice=%wZ\n",Status,pucExportName));
        CTEMemFree (Buffer);
        return Status;
    }

    *ppDeviceContext = pDeviceContext = (tDEVICECONTEXT *)DeviceObject;

    //
    // zero out the data structure, beyond the OS specific part
    //
    LinkOffset = FIELD_OFFSET(tDEVICECONTEXT, Linkage);
    CTEZeroMemory (&pDeviceContext->Linkage, sizeof(tDEVICECONTEXT)-LinkOffset);

    // initialize the pDeviceContext data structure.  There is one of
    // these data structured tied to each "device" that NBT exports
    // to higher layers (i.e. one for each network adapter that it
    // binds to.
    InitializeListHead (&pDeviceContext->Linkage);  // Sets the forward link = back link = list head
    InitializeListHead (&pDeviceContext->UpConnectionInUse);
    InitializeListHead (&pDeviceContext->LowerConnection);
    InitializeListHead (&pDeviceContext->LowerConnFreeHead);
    InitializeListHead (&pDeviceContext->WaitingForInbound);
#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
    pDeviceContext->DelayedNotification = NBT_TDI_NOACTION;
    KeInitializeEvent(&pDeviceContext->DelayedNotificationCompleteEvent, NotificationEvent, FALSE);
#endif

    // put a verifier value into the structure so that we can check that
    // we are operating on the right data when the OS passes a device context
    // to NBT
    pDeviceContext->Verify      = NBT_VERIFY_DEVCONTEXT;
    pDeviceContext->DeviceType  = DeviceType;   // Default
    CTEInitLock(&pDeviceContext->LockInfo.SpinLock);     // setup the spin lock
#if DBG
    pDeviceContext->LockInfo.LockNumber  = DEVICE_LOCK;
#endif

    pDeviceContext->RefCount = 1;       // Dereferenced when the Device is destroyed
// #if DBG
    pDeviceContext->ReferenceContexts[REF_DEV_CREATE]++;
// #endif  // DBG
    pDeviceContext->IPInterfaceContext = (ULONG)-1;    // by default

    pDeviceContext->ExportName.MaximumLength = pucExportName->MaximumLength;
    pDeviceContext->ExportName.Buffer = (PWSTR)Buffer;
    RtlCopyUnicodeString(&pDeviceContext->ExportName,pucExportName);
    pDeviceContext->BindName.MaximumLength = pucBindName->MaximumLength;
    pDeviceContext->BindName.Buffer = (PWSTR)(Buffer+pucExportName->MaximumLength);
    RtlCopyUnicodeString(&pDeviceContext->BindName,pucBindName);
    KeInitializeEvent (&pDeviceContext->DeviceCleanedupEvent, NotificationEvent, FALSE);

    pDeviceContext->EnableNagling = FALSE;

    // IpAddress, AssignedIpAddress, and NumAdditionalIpAddresses fields should be = 0
    // DeviceRegistrationHandle and NetAddressRegistrationHandle should be NULL
    // DeviceRefreshState and WakeupPatternRefCount should also be = 0
    return (Status);
}


NTSTATUS
NTQueryIPForInterfaceInfo(
    tDEVICECONTEXT  *pDeviceContext
    )
{
    PVOID               *pIPInfo;
    PIP_INTERFACE_INFO  pIPIfInfo;
    ULONG               BufferLen;
    NTSTATUS            status;
    ULONG               NextAdapterNumber;
    UNICODE_STRING      ucDeviceName;
    ULONG               Input, Metric, IfContext;

    if (NT_SUCCESS (status = NbtQueryIpHandler (pDeviceContext->pControlFileObject,
                                                IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER,
                                                (PVOID *) &pDeviceContext->pFastSend)))
    {
        BufferLen = sizeof(PVOID *);
        if (NT_SUCCESS (status = NbtProcessIPRequest (IOCTL_IP_GET_BESTINTFC_FUNC_ADDR,
                                                      NULL,         // No Input buffer
                                                      0,
                                                      (PVOID *) &pIPInfo,
                                                      &BufferLen)))
        {
            pDeviceContext->pFastQuery = *pIPInfo;
            CTEMemFree (pIPInfo);
            pIPInfo = NULL;
            if (pDeviceContext->pFastQuery) {
                /*
                 * Get the context for loopback IP address.
                 */
                IfContext = 0xffff;
                pDeviceContext->pFastQuery (ntohl(INADDR_LOOPBACK), &IfContext, &Metric);
                if (IfContext != 0xffff) {
                    NbtConfig.LoopbackIfContext = IfContext;
                }
            }
        }
        else
        {
            KdPrint (("Nbt.NTQueryIPForInterfaceInfo: ERROR: <%x> pFastQuery on Device:\n\t<%wZ>!\n",
                        status, &pDeviceContext->BindName));
            pDeviceContext->pFastQuery = NULL;
        }
    }
    else
    {
        KdPrint (("Nbt.NTQueryIPForInterfaceInfo: ERROR:<%x>, Irql=<%d>,pFastSend on Device:\n\t<%wZ>!\n",
                    status, KeGetCurrentIrql(), &pDeviceContext->BindName));
        pDeviceContext->pFastSend = NULL;
    }

    if ((pDeviceContext->DeviceType == NBT_DEVICE_NETBIOSLESS) ||
        (pDeviceContext->DeviceType == NBT_DEVICE_CLUSTER))
    {
        //
        // Cluster devices do not have any real InterfaceContext -- initialized to -1 by default
        //
        // Determine the InterfaceContext for the Loopback address
        //
        if ((NT_SUCCESS (status)) &&
            (pDeviceContext->DeviceType == NBT_DEVICE_NETBIOSLESS))
        {
            ASSERT (pDeviceContext->pFastQuery);
            pDeviceContext->pFastQuery (ntohl(INADDR_LOOPBACK), &pDeviceContext->IPInterfaceContext, &Metric);
        }
    }
    else if (NT_SUCCESS (status))
    {
        //
        // Get the InterfaceContext for this adapter
        //
        BufferLen = sizeof(IP_ADAPTER_INDEX_MAP) * (NbtConfig.AdapterCount+2);
        status = NbtProcessIPRequest (IOCTL_IP_INTERFACE_INFO,
                                      NULL,         // No Input buffer
                                      0,
                                      &pIPIfInfo,
                                      &BufferLen);

        if (NT_SUCCESS(status))
        {
            status = STATUS_UNSUCCESSFUL;
            for(NextAdapterNumber=0; NextAdapterNumber<(ULONG)pIPIfInfo->NumAdapters; NextAdapterNumber++)
            {
                ucDeviceName.Buffer = pIPIfInfo->Adapter[NextAdapterNumber].Name;
                ucDeviceName.Length = ucDeviceName.MaximumLength =
                                    (sizeof (WCHAR)) * wcslen(pIPIfInfo->Adapter[NextAdapterNumber].Name);

                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("[%d/%d]\t<%wZ>\n",
                        NextAdapterNumber+1, pIPIfInfo->NumAdapters, &ucDeviceName));

                if (RtlCompareUnicodeString (&ucDeviceName, &pDeviceContext->BindName, TRUE) == 0)
                {
                    pDeviceContext->IPInterfaceContext = pIPIfInfo->Adapter[NextAdapterNumber].Index;
                    status = STATUS_SUCCESS;
                    break;
                }
            }

            if (NT_SUCCESS(status))
            {
                BufferLen = sizeof (ULONG);
                Input = pDeviceContext->IPInterfaceContext;

                //
                // Query the latest WOL capabilities on this adapter!
                //
                if (NT_SUCCESS (status = NbtProcessIPRequest (IOCTL_IP_GET_WOL_CAPABILITY,
                                                              &Input,      // Input buffer
                                                              BufferLen,
                                                              (PVOID) &pIPInfo,
                                                              &BufferLen)))
                {
                    ASSERT (pIPInfo);
                    pDeviceContext->WOLProperties = * ((PULONG) pIPInfo);
                    CTEMemFree (pIPInfo);
                    pIPInfo = NULL;
                }

                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.NTQueryIPForInterfaceInfo[GET_WOL_CAPABILITY]: <%x>, pDeviceContext=<%p>, Input=<%x>, Result=<%x>\n",status, pDeviceContext, Input, pDeviceContext->WOLProperties));
            }
            else
            {
                KdPrint (("Nbt.NTQueryIPForInterfaceInfo:  Could not find IpInterface from [%d]:\n<%wZ>\n",
                    (ULONG)pIPIfInfo->NumAdapters, &pDeviceContext->BindName));
            }

            CTEMemFree (pIPIfInfo);
        }
        else
        {
            KdPrint (("Nbt.NTQueryIPForInterfaceInfo: ERROR<%x>, No InterfaceContext for Device:<%wZ>!\n",
                &pDeviceContext->BindName));
        }
    }

    return (status);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtCreateDeviceObject(
    PUNICODE_STRING      pucBindName,
    PUNICODE_STRING      pucExportName,
    tADDRARRAY           *pAddrs,
    tDEVICECONTEXT       **ppDeviceContext,
    enum eNbtDevice      DeviceType
    )

/*++

Routine Description:

    This routine initializes a Driver Object from the device object passed
    in and the name of the driver object passed in.  After the Driver Object
    has been created, clients can "Open" the driver by that name.

    For the Netbiosless device, do not insert on device list.

Arguments:


Return Value:

    status - the outcome

--*/

{

    NTSTATUS            status;
    PDEVICE_OBJECT      DeviceObject = NULL;
    tDEVICECONTEXT      *pDeviceContext;
    tDEVICECONTEXT      *pDeviceContextOther;
    ULONG               ulIpAddress;
    CTELockHandle       OldIrq1;
    CTEULONGLONG        NextAdapterMask;
    ULONG               NextAdapterNumber;
    BOOLEAN             fAttached = FALSE;
    BOOLEAN             fInserted;
#ifdef _NETBIOSLESS
    BOOLEAN             fStopInitTimers = FALSE;

    if (DeviceType != NBT_DEVICE_NETBIOSLESS)
#endif
    {
        //
        // We need to acquire this lock since we can have multiple devices
        // being added simultaneously and hence we will need to have a unique
        // Adapter Number for each device
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
        //
        // Check to make sure we have not yet crossed the limit!
        //
        if (NbtConfig.AdapterCount >= NBT_MAXIMUM_BINDINGS)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            KdPrint(("Nbt.NbtCreateDeviceObject: ERROR -- Cannot add new device=<%ws>, Max=<%d> reached\n",
                pucBindName->Buffer, NBT_MAXIMUM_BINDINGS));

            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        NbtConfig.AdapterCount++;

        //
        // If this is the first Device, we need to start the Timers
        //
        if (NbtConfig.AdapterCount == 1)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            status = InitTimersNotOs();

            CTESpinLock(&NbtConfig.JointLock,OldIrq1);
            //
            // If we failed and no one else also started the timers, then fail
            //
            if ((status != STATUS_SUCCESS) && (!(--NbtConfig.AdapterCount)))
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                KdPrint(("Nbt.NbtCreateDeviceObject: InitTimersNotOs FAILed, failing to add device %ws\n",
                    pucBindName->Buffer));

                NbtLogEvent (EVENT_NBT_TIMERS, status, 0x112);
                StopInitTimers();
                return status;
            }
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    }

    status = NbtAllocAndInitDevice (pucBindName, pucExportName, ppDeviceContext, DeviceType);
    if (!NT_SUCCESS(status))
    {
        KdPrint(("Nbt.NbtCreateDeviceObject: NbtAllocAndInitDevice returned status=%X\n",status));

        //
        // If we failed to add the first device stop the timers
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq1);

#ifdef _NETBIOSLESS
        // SmbDevice does not affect adapter count
        if ((DeviceType != NBT_DEVICE_NETBIOSLESS) &&
            (!(--NbtConfig.AdapterCount)))
#else
        if (!(--NbtConfig.AdapterCount))
#endif
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            StopInitTimers();
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        }

        return(status);
    }

    DeviceObject = (PDEVICE_OBJECT) (pDeviceContext = *ppDeviceContext);

    //
    // for a Bnode pAddrs is NULL
    //
    if (pAddrs)
    {
#ifdef MULTIPLE_WINS
        int i;
#endif

        pDeviceContext->lNameServerAddress  = pAddrs->NameServerAddress;
        pDeviceContext->lBackupServer       = pAddrs->BackupServer;
        pDeviceContext->RefreshToBackup     = 0;
        pDeviceContext->SwitchedToBackup    = 0;
#ifdef MULTIPLE_WINS
        pDeviceContext->lNumOtherServers    = pAddrs->NumOtherServers;
        pDeviceContext->lLastResponsive     = 0;
        for (i = 0; i < pAddrs->NumOtherServers; i++)
        {
            pDeviceContext->lOtherServers[i] = pAddrs->Others[i];
        }
#endif
#ifdef _NETBIOSLESS
        pDeviceContext->NetbiosEnabled       = pAddrs->NetbiosEnabled;
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("Nbt.NbtCreateDeviceObject: %wZ NetbiosEnabled = %d\n",
                 &pDeviceContext->ExportName, pDeviceContext->NetbiosEnabled));
#endif
        pDeviceContext->RasProxyFlags        = pAddrs->RasProxyFlags;
        pDeviceContext->EnableNagling        = pAddrs->EnableNagling;
        //
        // if the node type is set to Bnode by default then switch to Hnode if
        // there are any WINS servers configured.
        //
        if ((NodeType & DEFAULT_NODE_TYPE) &&
            (pAddrs->NameServerAddress || pAddrs->BackupServer))
        {
            NodeType = MSNODE | (NodeType & PROXY);
        }
    }
#ifdef _NETBIOSLESS
    else
    {
        pDeviceContext->NetbiosEnabled = TRUE;
        pDeviceContext->RasProxyFlags  = 0;
        pDeviceContext->EnableNagling  = FALSE;
    }
#endif

    CTEAttachFsp(&fAttached, REF_FSP_CREATE_DEVICE);

    status = NbtTdiOpenControl(pDeviceContext);
    if (NT_SUCCESS (status))
    {
        status = NTQueryIPForInterfaceInfo (pDeviceContext);
    }
    else
    {
        KdPrint(("Nbt.NbtCreateDeviceObject: NbtTdiOpenControl returned status=%X\n",status));
    }

    CTEDetachFsp(fAttached, REF_FSP_CREATE_DEVICE);

    if (NT_SUCCESS(status))
    {
        // increase the stack size of our device object, over that of the transport
        // so that clients create Irps large enough
        // to pass on to the transport below.
        // In theory, we should just add 1 here, to account for our presence in the
        // driver chain.
        //
        DeviceObject->StackSize = pDeviceContext->pControlDeviceObject->StackSize + 1;
        if (NbtConfig.MaxIrpStackSize < DeviceObject->StackSize) {
            NbtConfig.MaxIrpStackSize = DeviceObject->StackSize;
        }

        //
        // Get an Irp for the out of resource queue (used to disconnect sessions
        // when really low on memory)
        //
        if (!NbtConfig.OutOfRsrc.pIrp)
        {
            NbtConfig.OutOfRsrc.pIrp = IoAllocateIrp(pDeviceContext->DeviceObject.StackSize, FALSE);
            if (NbtConfig.OutOfRsrc.pIrp)
            {
                //
                // allocate a dpc structure and keep it: we might need if we hit an
                // out-of-resource condition
                //
                NbtConfig.OutOfRsrc.pDpc = NbtAllocMem(sizeof(KDPC),NBT_TAG('a'));
                if (!NbtConfig.OutOfRsrc.pDpc)
                {
                    IoFreeIrp(NbtConfig.OutOfRsrc.pIrp);
                    NbtConfig.OutOfRsrc.pIrp = NULL;
                }
            }

            if ((!NbtConfig.OutOfRsrc.pIrp) || (!NbtConfig.OutOfRsrc.pDpc))
            {
                KdPrint(("Nbt.NbtCreateDeviceObject: Could not create OutOfRsrc Irps!\n"));
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (!NT_SUCCESS (status))
    {
        //
        // We failed somewhere, so clean up!
        //
        if (pDeviceContext->hControl)
        {
            CTEAttachFsp(&fAttached, REF_FSP_CREATE_DEVICE);
            ObDereferenceObject(pDeviceContext->pControlFileObject);
            NTZwCloseFile(pDeviceContext->hControl);
            pDeviceContext->pControlFileObject = NULL;
            pDeviceContext->hControl = NULL;
            CTEDetachFsp(fAttached, REF_FSP_CREATE_DEVICE);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
        //
        // If this was the last Device to go away, stop the timers
        // (SmbDevice does not affect adapter count)
        //
        if (DeviceType == NBT_DEVICE_NETBIOSLESS)
        {
            if (!(NbtConfig.AdapterCount))
            {
                fStopInitTimers = TRUE;
            }
        }
        else if (!(--NbtConfig.AdapterCount))
        {
            fStopInitTimers = TRUE;
        }
        else if (NbtConfig.AdapterCount == 1)
        {
            NbtConfig.MultiHomed = FALSE;
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);

        if (fStopInitTimers)
        {
            StopInitTimers();
        }

        *ppDeviceContext = NULL;
        CTEMemFree (pDeviceContext->ExportName.Buffer);
        IoDeleteDevice((PDEVICE_OBJECT)pDeviceContext);

        NbtLogEvent (EVENT_NBT_CREATE_DEVICE, status, 0x113);

        return (status);
    }

    pDeviceContext->DeviceObject.Flags &= ~DO_DEVICE_INITIALIZING;
#ifdef _NETBIOSLESS
    pDeviceContext->SessionPort = NBT_SESSION_TCP_PORT;
    pDeviceContext->NameServerPort = NBT_NAMESERVICE_UDP_PORT;
    pDeviceContext->DatagramPort = NBT_DATAGRAM_UDP_PORT;
    RtlZeroMemory (pDeviceContext->MessageEndpoint, NETBIOS_NAME_SIZE);
#endif

    //
    // An instance number is assigned to each device so that the service which
    // creates logical devices in Nbt can re-use these devices in case it fails
    // to destroy them in a prev. instance.
    //
    pDeviceContext->InstanceNumber = GetUnique32BitValue();

    //
    // Now set the Adapter number for this device
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    //
    // See if we have a gap in the AdapterMask of the current set of Devices
    // which we can utilize
    //
#ifdef _NETBIOSLESS
    // SmbDevice does not affect adapter count
    if (IsDeviceNetbiosless(pDeviceContext))
    {
        NextAdapterNumber = 0;
        NextAdapterMask = 0xffffffffffffffff;
    }
    else
#endif
    {
        NextAdapterNumber = 1;  // 0 is for the SmbDevice!
        NextAdapterMask = 1;
        fInserted = FALSE;
        if (!IsListEmpty(&NbtConfig.DeviceContexts))
        {
            PLIST_ENTRY         pHead, pEntry;
            tDEVICECONTEXT      *pTmpDevContext;

            pHead = &NbtConfig.DeviceContexts;
            pEntry = pHead;
            while ((pEntry = pEntry->Flink) != pHead)
            {
                pTmpDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
                if (pTmpDevContext->AdapterMask > NextAdapterMask)
                {
                    pDeviceContext->Linkage.Flink = pEntry;
                    pDeviceContext->Linkage.Blink = pEntry->Blink;
                    pEntry->Blink->Flink = &pDeviceContext->Linkage;
                    pEntry->Blink = &pDeviceContext->Linkage;
                    fInserted = TRUE;
                    break;
                }

                NextAdapterNumber++;
                NextAdapterMask = (pTmpDevContext->AdapterMask) << 1;
            }
        }
        if (!fInserted)
        {
            // add this new device context on to end of the List in the
            // configuration data structure
            InsertTailList(&NbtConfig.DeviceContexts, &pDeviceContext->Linkage);
        }
        NbtConfig.CurrentAdaptersMask |= NextAdapterMask;
    }

    if ((1+NbtConfig.AdapterCount) > NbtConfig.RemoteCacheLen)  // Add 1 for the SmbDevice
    {
        NbtConfig.RemoteCacheLen += REMOTE_CACHE_INCREMENT;
    }

    // We keep a bit mask around to keep track of this adapter number so we can
    // quickly find if a given name is registered on a particular adapter,
    // by a corresponding bit set in the tNAMEADDR - local hash table entry
    //
    pDeviceContext->AdapterMask = NextAdapterMask;
    pDeviceContext->AdapterNumber = NextAdapterNumber;

    IF_DBG(NBT_DEBUG_NTUTIL)
        KdPrint (("Nbt.NbtCreateDeviceObject: Device=<%x>, New AdapterCount=<%d>, AdapterMask=<%lx:%lx>\n",
            pDeviceContext, NbtConfig.AdapterCount, NextAdapterMask));

    if (NbtConfig.AdapterCount > 1)
    {
        NbtConfig.MultiHomed = TRUE;
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
tDEVICECONTEXT *
GetDeviceWithIPAddress(
    tIPADDRESS  IpAddress
    )
/*++
Routine Description:

    This Routine references the device with preferably the requested
    IP address, otherwise, it will pick the first device with
    a valid IP address

    This routine must be called with the JointLock held!

Arguments:


Return Value:

    pDeviceContext

--*/

{
    LIST_ENTRY      *pEntry;
    LIST_ENTRY      *pHead;
    tDEVICECONTEXT  *pDeviceContext;
    tDEVICECONTEXT  *pDeviceContextWithIp = NULL;

    if (!IpAddress)
    {
        return NULL;
    }

    //
    // Find the device with this Ip address
    //
    pHead = pEntry = &NbtConfig.DeviceContexts;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pDeviceContext = CONTAINING_RECORD (pEntry,tDEVICECONTEXT,Linkage);
        if (pDeviceContext->IpAddress)
        {
            if (IpAddress == pDeviceContext->IpAddress)
            {
                return pDeviceContext;
            }
            else if (!pDeviceContextWithIp)
            {
                pDeviceContextWithIp = pDeviceContext;
            }
        }
    }

    //
    // Couldn't find a Device with the requested IP address!
    // So, in the meantime return the first valid Device with an IP address (if any)
    //
    return pDeviceContextWithIp;
}


//----------------------------------------------------------------------------
#define MAX_REFERENCES  5000

BOOLEAN
NBT_REFERENCE_DEVICE(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN ULONG            ReferenceContext,
    IN BOOLEAN          fLocked
    )
{
    BOOLEAN         fStatus;
    CTELockHandle   OldIrq;

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    if (NBT_VERIFY_HANDLE (pDeviceContext, NBT_VERIFY_DEVCONTEXT))
    {
        InterlockedIncrement(&pDeviceContext->RefCount);
// #if DBG
        pDeviceContext->ReferenceContexts[ReferenceContext]++;
        ASSERT (pDeviceContext->ReferenceContexts[ReferenceContext] <= MAX_REFERENCES);
// #endif  // DBG
        fStatus = TRUE;
    }
    else
    {
        fStatus = FALSE;
    }

    if (!fLocked)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return (fStatus);
}


VOID
NBT_DEREFERENCE_DEVICE(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN ULONG            ReferenceContext,
    IN BOOLEAN          fLocked
    )
/*++
Routine Description:

    This Routine Dereferences the DeviceContext and queues it on
    to the worker thread if the the Device needs to be deleted

    This routine may be called with the JointLock held!

Arguments:

    pContext

Return Value:

    NONE

--*/

{
    CTELockHandle           OldIrq;

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    ASSERT (NBT_VERIFY_HANDLE2(pDeviceContext, NBT_VERIFY_DEVCONTEXT, NBT_VERIFY_DEVCONTEXT_DOWN));
    ASSERT (pDeviceContext->ReferenceContexts[ReferenceContext]);
// #if DBG
    pDeviceContext->ReferenceContexts[ReferenceContext]--;
// #endif  // DBG

    if (!(--pDeviceContext->RefCount))
    {
#if DBG
        {
            ULONG   i;
            for (i=0; i<REF_DEV_MAX; i++)
            {
                ASSERT(0 == pDeviceContext->ReferenceContexts[i]);
            }
        }
#endif  // DBG

        //
        // We cannot delete the device directly here since we are at raised Irql
        //
        NTQueueToWorkerThread(
                    &pDeviceContext->WorkItemDeleteDevice,
                    DelayedNbtDeleteDevice,
                    NULL,
                    pDeviceContext,
                    NULL,
                    NULL,
                    TRUE);
    }

    if (!fLocked)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}


NTSTATUS
NbtDestroyDevice(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN BOOLEAN          fWait
    )
{
    LIST_ENTRY              *pEntry;
    LIST_ENTRY              *pHead;
    tTIMERQENTRY            *pTimer;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   Context;
    CTELockHandle           OldIrq;
    BOOLEAN                 fRemoveFromSmbList = FALSE;
    tDEVICECONTEXT *pSavedSmbDevice = NULL;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (!NBT_VERIFY_HANDLE(pDeviceContext, NBT_VERIFY_DEVCONTEXT))
    {
        ASSERT (NBT_VERIFY_HANDLE(pDeviceContext, NBT_VERIFY_DEVCONTEXT_DOWN));
        return (STATUS_INVALID_DEVICE_REQUEST);
    }
    //
    // First remove the Device from the NbtConfig list
    // (no-op for Wins and SmbDevice)
    //
    RemoveEntryList (&pDeviceContext->Linkage);
    if ((pDeviceContext->DeviceType != NBT_DEVICE_NETBIOSLESS) &&
        (pDeviceContext->IPInterfaceContext != (ULONG)-1))
    {
        if (pDeviceContext->AdapterMask & NbtConfig.ServerMask) {
            fRemoveFromSmbList = TRUE;
            NbtConfig.ServerMask &= (~pDeviceContext->AdapterMask);
        }
        NbtConfig.ClientMask &= (~pDeviceContext->AdapterMask);
    }

    pDeviceContext->Verify = NBT_VERIFY_DEVCONTEXT_DOWN;
    //
    // Clear out the DeviceContext entry from the IPContext-to-Device Map
    //
    if (!IsDeviceNetbiosless(pDeviceContext)) {
        NbtConfig.CurrentAdaptersMask &= ~pDeviceContext->AdapterMask;
    }

    //
    // Remove any pending requests in the LmHosts or Dns or CheckAddrs Q's
    // This has to be done immediately after we change the device
    // state before releasing the lock.
    //
    TimeoutLmHRequests (NULL, pDeviceContext, TRUE, &OldIrq);

    if ((fRemoveFromSmbList) &&
        (pNbtSmbDevice) && !gbDestroyingSmbDevice &&
        (NBT_REFERENCE_DEVICE (pNbtSmbDevice, REF_DEV_SMB_BIND, TRUE)))
    {
        pSavedSmbDevice = pNbtSmbDevice;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        //
        // Set the Session port info
        //
        if (pSavedSmbDevice->hSession)
        {
            NbtSetTcpInfo (pSavedSmbDevice->hSession,
                           AO_OPTION_DEL_IFLIST,
                           INFO_TYPE_ADDRESS_OBJECT,
                           pDeviceContext->IPInterfaceContext);
        }

        //
        // Now, set the same for the Datagram port
        //
        if ((pSavedSmbDevice->pFileObjects) &&
            (pSavedSmbDevice->pFileObjects->hDgram))
        {
            NbtSetTcpInfo (pSavedSmbDevice->pFileObjects->hDgram,
                           AO_OPTION_DEL_IFLIST,
                           INFO_TYPE_ADDRESS_OBJECT,
                           pDeviceContext->IPInterfaceContext);
        }
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        NBT_DEREFERENCE_DEVICE (pSavedSmbDevice, REF_DEV_SMB_BIND, TRUE);
    }

    //
    // If we still have any timers running on this Device, stop them!
    //
    pHead = &TimerQ.ActiveHead;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        pTimer = CONTAINING_RECORD(pEntry,tTIMERQENTRY,Linkage);
        if (pTimer->pDeviceContext == (PVOID) pDeviceContext)
        {
            StopTimer(pTimer,&pClientCompletion,&Context);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            if (pClientCompletion)
            {
                (*pClientCompletion)(Context, STATUS_TIMEOUT);
            }

            IF_DBG(NBT_DEBUG_NTUTIL)
                KdPrint(("NbtDestroyDevice: stopped timer on this Device")) ;

            CTESpinLock(&NbtConfig.JointLock,OldIrq);

            pEntry = pHead->Flink;  // Restart from the beginning since we released the lock
        }
        else
        {
            pEntry = pEntry->Flink;
        }
    }

    // Now do the Dereference which will cause this Device to be destroyed!
    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_CREATE, TRUE);

    if (fWait)
    {
        NTSTATUS   status;

        InitializeListHead (&pDeviceContext->Linkage);

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("Nbt.NbtDestroyDevice: Waiting on Device=<%p>:\n\t%wZ\n",
                pDeviceContext, &pDeviceContext->ExportName));
        //
        // Wait for all pending Timer and worker requests which have referenced this
        // Device to complete!
        //
        status = KeWaitForSingleObject (&pDeviceContext->DeviceCleanedupEvent,  // Object to wait on.
                               Executive,            // Reason for waiting
                               KernelMode,           // Processor mode
                               FALSE,                // Alertable
                               NULL);                // Timeout
        ASSERT(status == STATUS_SUCCESS);

        KdPrint(("Nbt.NbtDestroyDevice: *** Destroying Device *** \n\t%wZ\n", &pDeviceContext->ExportName));

        RemoveEntryList(&pDeviceContext->Linkage);

        CTEMemFree (pDeviceContext->ExportName.Buffer);
        IoDeleteDevice((PDEVICE_OBJECT)pDeviceContext);
    }
    else
    {
        //
        // Put it here so that the Cleanup routine can find this Device
        //
        InsertTailList(&NbtConfig.DevicesAwaitingDeletion,&pDeviceContext->Linkage);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return (STATUS_SUCCESS);
}


/*******************************************************************

    NAME:       DelayedNbtDeleteDevice

    SYNOPSIS:   This Routine is the worker thread for Deleting the
                DeviceObject at PASSIVE level Irql

    ENTRY:      pDeviceContext - name of the device/ device ptr

    Return Value: NONE

********************************************************************/

VOID
DelayedNbtDeleteDevice(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pContext,
    IN  PVOID                   pUnused2,
    IN  tDEVICECONTEXT          *pUnused3
    )
{
    LIST_ENTRY            * pEntry;
    LIST_ENTRY            * pHead;
    LIST_ENTRY            * pClientEntry;
    LIST_ENTRY              TempList;
    tDEVICECONTEXT        * pTmpDeviceContext;
    tDEVICECONTEXT        * pNextDeviceContext;
    tCLIENTELE            * pClientEle;
    tCLIENTELE            * pLastClient;
    tADDRESSELE           * pAddress;
    tADDRESSELE           * pLastAddress;
    tNAMEADDR             * pNameAddr;
    tCONNECTELE           * pConnEle;
    tLOWERCONNECTION      * pLowerConn;
    tTIMERQENTRY          * pTimer;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   Context;
    tDGRAM_SEND_TRACKING  * pTracker;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    CTELockHandle           OldIrq2;
    int                     i;
    WCHAR                   Buffer[MAX_PATH];
    UNICODE_STRING          ucExportName;
    PUNICODE_STRING         pucExportName;
    BOOLEAN                 Attached;
#ifdef _PNP_POWER_
    NTSTATUS                Status;
#endif  // _PNP_POWER_
    BOOLEAN                 fDelSmbDevice = FALSE;
    BOOLEAN                 fStopInitTimers = FALSE;
    BOOLEAN                 fNameReferenced = FALSE;
    tDEVICECONTEXT        * pDeviceContext = (tDEVICECONTEXT *) pContext;

    ASSERT (NBT_VERIFY_HANDLE(pDeviceContext, NBT_VERIFY_DEVCONTEXT_DOWN));

    //
    // Mark in the device extension that this is not a valid device anymore
    //
    pDeviceContext->Verify += 10;

    //
    // DeRegister this Device for our clients
    //
    if (pDeviceContext->NetAddressRegistrationHandle)
    {
        Status = TdiDeregisterNetAddress (pDeviceContext->NetAddressRegistrationHandle);
        pDeviceContext->NetAddressRegistrationHandle = NULL;
        NbtTrace(NBT_TRACE_PNP, ("DeregisterNetAddress: ExportName=%Z BindName=%Z status=%!status!",
            &pDeviceContext->ExportName, &pDeviceContext->BindName, Status));
    }
    if (pDeviceContext->DeviceRegistrationHandle)
    {
        Status = TdiDeregisterDeviceObject (pDeviceContext->DeviceRegistrationHandle);
        pDeviceContext->DeviceRegistrationHandle = NULL;
        NbtTrace(NBT_TRACE_PNP, ("DeregisterDevice: ExportName=%Z BindName=%Z status=%!status!",
            &pDeviceContext->ExportName, &pDeviceContext->BindName, Status));
    }
    if (!IsDeviceNetbiosless(pDeviceContext)) {
        NbtRemovePermanentName(pDeviceContext);
    }

    if (pDeviceContext->IpAddress)
    {
        if (IsDeviceNetbiosless(pDeviceContext))
        {
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint (("Nbt.DelayedNbtDeleteDevice: device %wZ deregistered\n",
                          &(pDeviceContext->ExportName) ));
        }

        CloseAddressesWithTransport(pDeviceContext);

        //
        // Dhcp is has passed down a null IP address meaning that it has
        // lost the lease on the previous address, so close all connections
        // to the transport - pLowerConn.
        //
        CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
        DisableInboundConnections (pDeviceContext);
        CTEExReleaseResource(&NbtConfig.Resource);
    }

    if (pDeviceContext->pControlFileObject)
    {
        BOOLEAN Attached;

        CTEAttachFsp(&Attached, REF_FSP_DELETE_DEVICE);

        ObDereferenceObject(pDeviceContext->pControlFileObject);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t  --<   ><====<%x>\tDelayedNbtDeleteDevice->ObDereferenceObject\n", pDeviceContext->pControlFileObject));
        Status = ZwClose(pDeviceContext->hControl);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t<===<%x>\tDelayedNbtDeleteDevice->ZwClose, status = <%x>\n", pDeviceContext->hControl, Status));

        pDeviceContext->pControlFileObject = NULL;
        pDeviceContext->hControl = NULL;

        CTEDetachFsp(Attached, REF_FSP_DELETE_DEVICE);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLock(pDeviceContext,OldIrq1);

    ASSERT(IsListEmpty(&pDeviceContext->LowerConnFreeHead));

    //
    // walk through all names and see if any is being registered on this
    // device context: if so, stop and complete it!
    //
    for (i=0;i < NbtConfig.pLocalHashTbl->lNumBuckets ;i++ )
    {
        pHead = &NbtConfig.pLocalHashTbl->Bucket[i];
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);

            //
            // if a name registration or refresh or release was started for this name
            // on this device context, stop the timer.  (Completion routine will take care of
            // doing registration on other device contexts if applicable)
            //
            if ((pTimer = pNameAddr->pTimer) &&
                (pTracker = pTimer->Context) &&
                (pTracker->pDeviceContext == pDeviceContext))
            {
                ASSERT(pTracker->pNameAddr == pNameAddr);

                pNameAddr->pTimer = NULL;

                StopTimer(pTimer,&pClientCompletion,&Context);

                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_DELETE_DEVICE);
                fNameReferenced = TRUE;

                CTESpinFree(pDeviceContext,OldIrq1);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                if (pClientCompletion)
                {
                    (*pClientCompletion)(Context,STATUS_TIMEOUT);
                }

                IF_DBG(NBT_DEBUG_NTUTIL)
                    KdPrint(("DelayedNbtDeleteDevice: stopped name reg timer")) ;

                CTESpinLock(&NbtConfig.JointLock,OldIrq);
                CTESpinLock(pDeviceContext,OldIrq1);
            }

            pEntry = pEntry->Flink;
            if (fNameReferenced)
            {
                fNameReferenced = FALSE;
                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_DELETE_DEVICE);
            }
        }
    }

    CTESpinFree(pDeviceContext,OldIrq1);

    //
    // Walk through the AddressHead list.  If any addresses exist and they
    // point to this device context, put the next device context.  Also, update
    // adapter mask to reflect that this device context is now gone.
    //
    pLastAddress = NULL;
    pLastClient = NULL;
    pHead = pEntry = &NbtConfig.AddressHead;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pAddress = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);
        ASSERT (pAddress->Verify == NBT_VERIFY_ADDRESS);

        //
        // Keep this Address around until we are done
        //
        NBT_REFERENCE_ADDRESS (pAddress, REF_ADDR_DEL_DEVICE);

        //
        // If we had referenced a previous address, Deref it now!
        //
        if (pLastAddress)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            //
            // The last Client may need to have the address present
            // while dereferencing, so deref it if we need to!
            //
            if (pLastClient)
            {
                NBT_DEREFERENCE_CLIENT(pLastClient);
                pLastClient = NULL;
            }

            NBT_DEREFERENCE_ADDRESS (pLastAddress, REF_ADDR_DEL_DEVICE);
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
        }

        pLastAddress = pAddress;    // => Save this so that we can Deref it later

        //
        // Need AddressLock to traverse ClientHead
        //
        CTESpinLock (pAddress, OldIrq2);

        pClientEntry = &pAddress->ClientHead;
        while ((pClientEntry = pClientEntry->Flink) != &pAddress->ClientHead)
        {
            pClientEle = CONTAINING_RECORD (pClientEntry,tCLIENTELE,Linkage);

            if (pClientEle->pDeviceContext == pDeviceContext)
            {
                CTESpinFree(pAddress, OldIrq2);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                KdPrint(("Nbt.DelayedNbtDeleteDevice: Client:Context <%-16.16s:%x>:<%x>, EVReceive:EVContext=<%x:%x>\n\tFAILed to Cleanup on Device<%x>\n",
                    pAddress->pNameAddr->Name, pAddress->pNameAddr->Name[15],
                    pClientEle, pClientEle->evReceive, pClientEle->RcvEvContext, pDeviceContext));

                if (pLastClient)
                {
                    NBT_DEREFERENCE_CLIENT(pLastClient);
                }

                pClientEle->pIrp = NULL;
                NbtCleanUpAddress(pClientEle,pDeviceContext);

                CTESpinLock(&NbtConfig.JointLock,OldIrq);
                CTESpinLock (pAddress, OldIrq2);
                pLastClient = pClientEle;   // pClientEle still needs one more Deref
            }
        }

        if (!IsDeviceNetbiosless(pDeviceContext)) {
            pAddress->pNameAddr->AdapterMask &= (~pDeviceContext->AdapterMask);   // Clear Adapter Mask
            pAddress->pNameAddr->ConflictMask &= (~pDeviceContext->AdapterMask);
        }

        if ((!(pAddress->pNameAddr->AdapterMask)) &&
            (pAddress->pNameAddr->NameTypeState & STATE_CONFLICT))
        {
            pAddress->pNameAddr->NameTypeState &= (~NAME_STATE_MASK);
            pAddress->pNameAddr->NameTypeState |= STATE_RESOLVED;
        }
        CTESpinFree(pAddress, OldIrq2);
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //
    // If we had referenced a previous Client or Address, Deref it now!
    //
    if (pLastClient)
    {
        NBT_DEREFERENCE_CLIENT(pLastClient);
    }
    if (pLastAddress)
    {
        NBT_DEREFERENCE_ADDRESS (pLastAddress, REF_ADDR_DEL_DEVICE);
    }

    //
    // if a call was started, but aborted then we could have some memory here!
    //
    while (!IsListEmpty(&pDeviceContext->UpConnectionInUse))
    {
        pEntry = RemoveHeadList(&pDeviceContext->UpConnectionInUse);
        pConnEle = CONTAINING_RECORD(pEntry,tCONNECTELE,Linkage);
        NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CREATE);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLock(pDeviceContext,OldIrq1);
    //
    //  We have finished our regular cleanup, so now close all the remaining TDI handles
    //
    while (!IsListEmpty(&pDeviceContext->LowerConnection))
    {
        pEntry = RemoveHeadList(&pDeviceContext->LowerConnection);
        InitializeListHead (pEntry);
        pLowerConn = CONTAINING_RECORD(pEntry,tLOWERCONNECTION,Linkage);
        IF_DBG(NBT_DEBUG_NTUTIL)
            KdPrint (("Nbt.DelayedNbtDeleteDevice:  Dereferencing pLowerConn <%x>\n", pLowerConn));
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, TRUE);
    }
    CTESpinFree(pDeviceContext,OldIrq1);

    //
    // If this was the last Device to go away, stop the timers
    // (SmbDevice does not affect adapter count)
    //
    if (IsDeviceNetbiosless(pDeviceContext))
    {
        if (!(NbtConfig.AdapterCount))
        {
            //
            // No more devices funtioning, so stop the timers now!
            //
            fStopInitTimers = TRUE;
        }
    }
    else if (!(--NbtConfig.AdapterCount))
    {
        fStopInitTimers = TRUE;
    }
    else if (NbtConfig.AdapterCount == 1)
    {
        NbtConfig.MultiHomed = FALSE;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (fStopInitTimers)
    {
        StopInitTimers();
    }

    //
    // Now set the event for the waiting thread to complete!
    //
    KeSetEvent(&pDeviceContext->DeviceCleanedupEvent, 0, FALSE);
}



tDEVICECONTEXT *
GetDeviceFromInterface(
    IN  tIPADDRESS      IpAddress,
    IN  BOOLEAN         fReferenceDevice
    )
{
    LIST_ENTRY      *pEntry;
    LIST_ENTRY      *pHead;
    CTELockHandle   OldIrq;
    ULONG           IPInterfaceContext, Metric;
    tDEVICECONTEXT  *pDeviceContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (IsListEmpty(&NbtConfig.DeviceContexts))
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return (NULL);
    }

    pDeviceContext = CONTAINING_RECORD(NbtConfig.DeviceContexts.Flink, tDEVICECONTEXT, Linkage);
    NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    pDeviceContext->pFastQuery(IpAddress, &IPInterfaceContext, &Metric);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);

    pHead = pEntry = &NbtConfig.DeviceContexts;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pDeviceContext = CONTAINING_RECORD (pEntry,tDEVICECONTEXT,Linkage);
        if (pDeviceContext->IPInterfaceContext == IPInterfaceContext)
        {
            if (fReferenceDevice)
            {
                NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_OUT_FROM_IP, TRUE);
            }
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            return pDeviceContext;
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return (NULL);
}

//----------------------------------------------------------------------------

tDEVICECONTEXT *
GetAndRefNextDeviceFromNameAddr(
    IN  tNAMEADDR               *pNameAddr
    )
/*++

Routine Description:

    This routine finds the first adapter as specified in the name's adapter
    mask and set the DeviceContext associated with it.  It then clears the
    bit  in the adapter mask of pNameAddr.

Arguments:


Return Value:

    pDeviceContext if found a successful device!

--*/
{
    CTEULONGLONG    AdapterMask = 1;
    tDEVICECONTEXT  *pDeviceContext = NULL;
    PLIST_ENTRY     pHead;
    PLIST_ENTRY     pEntry;

    //
    // We may encounter an adapter for which the device is no
    // longer there, so we loop until we find the first valid
    // adapter or the mask is clear
    //
    while (pNameAddr->ReleaseMask)
    {
        //
        // Get the lowest AdapterMask bit and clear it in pNameAddr since
        // we are releasing the Name on that Adapter now
        //
        AdapterMask = ~(pNameAddr->ReleaseMask - 1) & pNameAddr->ReleaseMask;
        pNameAddr->ReleaseMask &= ~AdapterMask;

        //
        // Get the DeviceContext for this adapter mask
        //
        pHead = &NbtConfig.DeviceContexts;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pDeviceContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
            if (pDeviceContext->AdapterMask == AdapterMask)
            {
                //
                // Found a valid device on which this name is registered
                //
#ifndef VXD
                NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_GET_REF, TRUE);
#endif
                return pDeviceContext;
            }

            //
            // Go to next device
            //
            pEntry = pEntry->Flink;
        }
    }

    return NULL;
}


//----------------------------------------------------------------------------
NTSTATUS
CreateControlObject(
    tNBTCONFIG  *pConfig)

/*++

Routine Description:

    This routine allocates memory for the provider info block, tacks it
    onto the global configuration and sets default values for each item.

Arguments:


Return Value:


    NTSTATUS

--*/

{
    tCONTROLOBJECT      *pControl;


    CTEPagedCode();
    pControl = (tCONTROLOBJECT *) NbtAllocMem (sizeof(tCONTROLOBJECT), NBT_TAG2('21'));
    if (!pControl)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pControl->Verify = NBT_VERIFY_CONTROL;

    pControl->ProviderInfo.Version = 1;
    pControl->ProviderInfo.MaxSendSize = 0;
    pControl->ProviderInfo.MaxConnectionUserData = 0;

    // we need to get these values from the transport underneath...*TODO*
    // since the RDR uses this value
    pControl->ProviderInfo.MaxDatagramSize = 0;

    pControl->ProviderInfo.ServiceFlags = 0;
/*    pControl->ProviderInfo.TransmittedTsdus = 0;
    pControl->ProviderInfo.ReceivedTsdus = 0;
    pControl->ProviderInfo.TransmissionErrors = 0;
    pControl->ProviderInfo.ReceiveErrors = 0;
*/
    pControl->ProviderInfo.MinimumLookaheadData = 0;
    pControl->ProviderInfo.MaximumLookaheadData = 0;
/*    pControl->ProviderInfo.DiscardedFrames = 0;
    pControl->ProviderInfo.OversizeTsdusReceived = 0;
    pControl->ProviderInfo.UndersizeTsdusReceived = 0;
    pControl->ProviderInfo.MulticastTsdusReceived = 0;
    pControl->ProviderInfo.BroadcastTsdusReceived = 0;
    pControl->ProviderInfo.MulticastTsdusTransmitted = 0;
    pControl->ProviderInfo.BroadcastTsdusTransmitted = 0;
    pControl->ProviderInfo.SendTimeouts = 0;
    pControl->ProviderInfo.ReceiveTimeouts = 0;
    pControl->ProviderInfo.ConnectionIndicationsReceived = 0;
    pControl->ProviderInfo.ConnectionIndicationsAccepted = 0;
    pControl->ProviderInfo.ConnectionsInitiated = 0;
    pControl->ProviderInfo.ConnectionsAccepted = 0;
*/
    // put a ptr to this info into the pConfig so we can locate it
    // when we want to cleanup
    pConfig->pControlObj = pControl;

    /* KEEP THIS STUFF HERE SINCE WE MAY NEED TO ALSO CREATE PROVIDER STATS!!
        *TODO*
    DeviceList[i].ProviderStats.Version = 2;
    DeviceList[i].ProviderStats.OpenConnections = 0;
    DeviceList[i].ProviderStats.ConnectionsAfterNoRetry = 0;
    DeviceList[i].ProviderStats.ConnectionsAfterRetry = 0;
    DeviceList[i].ProviderStats.LocalDisconnects = 0;
    DeviceList[i].ProviderStats.RemoteDisconnects = 0;
    DeviceList[i].ProviderStats.LinkFailures = 0;
    DeviceList[i].ProviderStats.AdapterFailures = 0;
    DeviceList[i].ProviderStats.SessionTimeouts = 0;
    DeviceList[i].ProviderStats.CancelledConnections = 0;
    DeviceList[i].ProviderStats.RemoteResourceFailures = 0;
    DeviceList[i].ProviderStats.LocalResourceFailures = 0;
    DeviceList[i].ProviderStats.NotFoundFailures = 0;
    DeviceList[i].ProviderStats.NoListenFailures = 0;

    DeviceList[i].ProviderStats.DatagramsSent = 0;
    DeviceList[i].ProviderStats.DatagramBytesSent.HighPart = 0;
    DeviceList[i].ProviderStats.DatagramBytesSent.LowPart = 0;

    DeviceList[i].ProviderStats.DatagramsReceived = 0;
    DeviceList[i].ProviderStats.DatagramBytesReceived.HighPart = 0;
    DeviceList[i].ProviderStats.DatagramBytesReceived.LowPart = 0;

    DeviceList[i].ProviderStats.PacketsSent = 0;
    DeviceList[i].ProviderStats.PacketsReceived = 0;

    DeviceList[i].ProviderStats.DataFramesSent = 0;
    DeviceList[i].ProviderStats.DataFrameBytesSent.HighPart = 0;
    DeviceList[i].ProviderStats.DataFrameBytesSent.LowPart = 0;

    DeviceList[i].ProviderStats.DataFramesReceived = 0;
    DeviceList[i].ProviderStats.DataFrameBytesReceived.HighPart = 0;
    DeviceList[i].ProviderStats.DataFrameBytesReceived.LowPart = 0;

    DeviceList[i].ProviderStats.DataFramesResent = 0;
    DeviceList[i].ProviderStats.DataFrameBytesResent.HighPart = 0;
    DeviceList[i].ProviderStats.DataFrameBytesResent.LowPart = 0;

    DeviceList[i].ProviderStats.DataFramesRejected = 0;
    DeviceList[i].ProviderStats.DataFrameBytesRejected.HighPart = 0;
    DeviceList[i].ProviderStats.DataFrameBytesRejected.LowPart = 0;

    DeviceList[i].ProviderStats.ResponseTimerExpirations = 0;
    DeviceList[i].ProviderStats.AckTimerExpirations = 0;
    DeviceList[i].ProviderStats.MaximumSendWindow = 0;
    DeviceList[i].ProviderStats.AverageSendWindow = 0;
    DeviceList[i].ProviderStats.PiggybackAckQueued = 0;
    DeviceList[i].ProviderStats.PiggybackAckTimeouts = 0;

    DeviceList[i].ProviderStats.WastedPacketSpace.HighPart = 0;
    DeviceList[i].ProviderStats.WastedPacketSpace.LowPart = 0;
    DeviceList[i].ProviderStats.WastedSpacePackets = 0;
    DeviceList[i].ProviderStats.NumberOfResources = 0;
    */
    return(STATUS_SUCCESS);

}


VOID
DelayedNbtCloseFileHandles(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pContext,
    IN  PVOID                   pUnused2,
    IN  tDEVICECONTEXT          *pUnused3
    )
{
    BOOLEAN         Attached = FALSE;
    NTSTATUS        Status;
    tFILE_OBJECTS   *pFileObjects = (tFILE_OBJECTS *) pContext;

    CTEPagedCode();
    CTEAttachFsp(&Attached, REF_FSP_CLOSE_FILE_HANDLES);

    if (pFileObjects->pNameServerFileObject)
    {
        ObDereferenceObject((PVOID *)pFileObjects->pNameServerFileObject);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t  --<   ><====<%x>\tDelayedNbtCloseFileHandles->ObDereferenceObject\n",
                pFileObjects->pNameServerFileObject));

        Status = ZwClose(pFileObjects->hNameServer);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t<===<%x>\tDelayedNbtCloseFileHandles->ZwClose, status = <%x>\n",
                pFileObjects->hNameServer, Status));
        NbtTrace(NBT_TRACE_PNP, ("close NameServer UDP handle pFileObjects %p", pFileObjects));
    }

    if (pFileObjects->pDgramFileObject)
    {
        ObDereferenceObject((PVOID *) pFileObjects->pDgramFileObject);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t  --<   ><====<%x>\tDelayedNbtCloseFileHandles->ObDereferenceObject\n",
                pFileObjects->pDgramFileObject));

        Status = ZwClose(pFileObjects->hDgram);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t<===<%x>\tDelayedNbtCloseFileHandles->ZwClose, status = <%x>\n",
                pFileObjects->hDgram, Status));
        NbtTrace(NBT_TRACE_PNP, ("close Datagram UDP handle on pFileObjects %p", pFileObjects));
    }

    CTEDetachFsp(Attached, REF_FSP_CLOSE_FILE_HANDLES);

    CTEMemFree (pFileObjects);
}


//----------------------------------------------------------------------------
NTSTATUS
CloseAddressesWithTransport(
    IN  tDEVICECONTEXT  *pDeviceContext
        )
/*++

Routine Description:

    This routine checks each device context to see if there are any open
    connections, and returns SUCCESS if there are.

Arguments:

Return Value:

    none

--*/

{
    BOOLEAN       Attached;
    CTELockHandle OldIrq;
    PFILE_OBJECT  pNSFileObject, pSFileObject, pDGFileObject;
#ifdef _PNP_POWER_
    PFILE_OBJECT  pCFileObject;
    NTSTATUS        Status;
#endif  // _PNP_POWER_
    tFILE_OBJECTS  *pFileObjects = NULL;
    HANDLE  hSession = NULL;

    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    pDeviceContext->IpAddress = 0;

    //
    // Check for the existence of Objects under SpinLock and
    // then Close them outside of the SpinLock
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pSFileObject = pDeviceContext->pSessionFileObject;
    pDeviceContext->pSessionFileObject = NULL;
    hSession = pDeviceContext->hSession;
    pDeviceContext->hSession = NULL;

    pFileObjects = pDeviceContext->pFileObjects;
    pDeviceContext->pFileObjects = NULL;
    if ((pFileObjects) &&
        (--pFileObjects->RefCount > 0))
    {
        NbtTrace(NBT_TRACE_PNP, ("closing UDP handle on deivce %p will be delayed. (pFileObjects %p)",
                                pDeviceContext, pFileObjects));
        pFileObjects = NULL;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    CTEExReleaseResource(&NbtConfig.Resource);

    //
    // Now close all the necessary objects as appropriate
    //
    CTEAttachFsp(&Attached, REF_FSP_CLOSE_ADDRESSES);
    if (pSFileObject)
    {
        ObDereferenceObject((PVOID *)pSFileObject);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t  --<   ><====<%x>\tCloseAddressesWithTransport2->ObDereferenceObject\n", pSFileObject));
        Status = ZwClose(hSession);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t<===<%x>\tCloseAddressesWithTransport2->ZwClose, status = <%x>\n", hSession, Status));
        NbtTrace(NBT_TRACE_PNP, ("close TCP session handle on device %p", pDeviceContext));
    }

    if (pFileObjects)
    {
        DelayedNbtCloseFileHandles (NULL, pFileObjects, NULL, NULL);
    }

    CTEDetachFsp(Attached, REF_FSP_CLOSE_ADDRESSES);
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtCreateAddressObjects(
    IN  ULONG                IpAddress,
    IN  ULONG                SubnetMask,
    OUT tDEVICECONTEXT       *pDeviceContext)

/*++

Routine Description:

    This routine gets the ip address and subnet mask out of the registry
    to calcuate the broadcast address.  It then creates the address objects
    with the transport.

Arguments:

    pucRegistryPath - path to NBT config info in registry
    pucBindName     - name of the service to bind to.
    pDeviceContext  - ptr to the device context... place to store IP addr
                      and Broadcast address permanently

Return Value:

    none

--*/

{
    NTSTATUS                        status, locstatus;
    ULONG                           ValueMask;
    UCHAR                           IpAddrByte;
    tFILE_OBJECTS                   *pFileObjects;

    CTEPagedCode();

    if (!(pFileObjects = (tFILE_OBJECTS *) NbtAllocMem (sizeof(tFILE_OBJECTS), NBT_TAG2('39'))))
    {
        KdPrint(("Nbt.NbtCreateAddressObjects:  Failed to allocate memory for FileObject context!\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    CTEZeroMemory(pFileObjects, sizeof(tFILE_OBJECTS));
    pFileObjects->RefCount = 1;

    //
    // to get the broadcast address combine the IP address with the subnet mask
    // to yield a value with 1's in the "local" portion and the IP address
    // in the network portion
    //
    ValueMask = (SubnetMask & IpAddress) | (~SubnetMask & -1);

    IF_DBG(NBT_DEBUG_NTUTIL)
        KdPrint(("Broadcastaddress = %X\n",ValueMask));

    //
    // the registry can be configured to set the subnet broadcast address to
    // -1 rather than use the actual subnet broadcast address.  This code
    // checks for that and sets the broadcast address accordingly.
    //
    if (NbtConfig.UseRegistryBcastAddr)
    {
        pDeviceContext->BroadcastAddress = NbtConfig.RegistryBcastAddr;
    }
    else
    {
        pDeviceContext->BroadcastAddress = ValueMask;
    }

    pDeviceContext->IpAddress = IpAddress;

    pDeviceContext->SubnetMask = SubnetMask;
    //
    // get the network number by checking the top bits in the ip address,
    // looking for 0 or 10 or 110 or 1110
    //
    IpAddrByte = ((PUCHAR)&IpAddress)[3];
    if ((IpAddrByte & 0x80) == 0)
    {
        // class A address - one byte netid
        IpAddress &= 0xFF000000;
    }
    else if ((IpAddrByte & 0xC0) ==0x80)
    {
        // class B address - two byte netid
        IpAddress &= 0xFFFF0000;
    }
    else if ((IpAddrByte & 0xE0) ==0xC0)
    {
        // class C address - three byte netid
        IpAddress &= 0xFFFFFF00;
    }
    pDeviceContext->NetMask = IpAddress;

    // now create the address objects.

    // open the Ip Address for inbound Datagrams.
    status = NbtTdiOpenAddress (&pFileObjects->hDgram,
                                &pFileObjects->pDgramDeviceObject,
                                &pFileObjects->pDgramFileObject,
                                pDeviceContext,
#ifdef _NETBIOSLESS
                                pDeviceContext->DatagramPort,
#else
                                (USHORT)NBT_DATAGRAM_UDP_PORT,
#endif
                                pDeviceContext->IpAddress,
                                0);     // not a TCP port

    if (NT_SUCCESS(status))
    {
#ifdef _NETBIOSLESS
        if (pDeviceContext->NameServerPort == 0)
        {
            pFileObjects->hNameServer = NULL;
            pFileObjects->pNameServerDeviceObject = NULL;
            pFileObjects->pNameServerFileObject = NULL;
        }
        else
#endif
        {
            // open the Nameservice UDP port ..
            status = NbtTdiOpenAddress (&pFileObjects->hNameServer,
                                        &pFileObjects->pNameServerDeviceObject,
                                        &pFileObjects->pNameServerFileObject,
                                        pDeviceContext,
#ifdef _NETBIOSLESS
                                        pDeviceContext->NameServerPort,
#else
                                        (USHORT)NBT_NAMESERVICE_UDP_PORT,
#endif
                                        pDeviceContext->IpAddress,
                                        0); // not a TCP port
        }

        if (NT_SUCCESS(status))
        {
#ifdef _NETBIOSLESS
            IF_DBG(NBT_DEBUG_NTUTIL)
                KdPrint(("Nbt.NbtCreateAddressObjects: Open Session Port=<%d>, pDeviceContext=<%x>\n",
                     pDeviceContext->SessionPort, pDeviceContext));
#endif

            // Open the TCP port for Session Services
            status = NbtTdiOpenAddress (&pDeviceContext->hSession,
                                        &pDeviceContext->pSessionDeviceObject,
                                        &pDeviceContext->pSessionFileObject,
                                        pDeviceContext,
#ifdef _NETBIOSLESS
                                        pDeviceContext->SessionPort,
#else
                                        (USHORT)NBT_SESSION_TCP_PORT,
#endif
                                        pDeviceContext->IpAddress,
                                        TCP_FLAG | SESSION_FLAG);      // TCP port

            if (NT_SUCCESS(status))
            {
                //
                // This will get the MAC address for a RAS connection
                // which is zero until there really is a connection to
                // the RAS server
                //
                GetExtendedAttributes(pDeviceContext);

                //
                // If this is P-to-P, and the Subnet mask is all 1's, set broadcast
                // address to all 1's and limit broadcast to this interface only
                //
                if ((pDeviceContext->IpInterfaceFlags & (IP_INTFC_FLAG_P2P | IP_INTFC_FLAG_P2MP)) &&
                    (SubnetMask == DEFAULT_BCAST_ADDR))   // If SubnetMask == -1 and connection is P-to-P
                {
                    pDeviceContext->BroadcastAddress = DEFAULT_BCAST_ADDR;

                    if (pFileObjects->hNameServer)
                    {
                        NbtSetTcpInfo (pFileObjects->hNameServer,
                                       AO_OPTION_LIMIT_BCASTS,
                                       INFO_TYPE_ADDRESS_OBJECT,
                                       (ULONG)TRUE);
                    }

                    if (pFileObjects->hDgram)
                    {
                        NbtSetTcpInfo (pFileObjects->hDgram,
                                       AO_OPTION_LIMIT_BCASTS,
                                       INFO_TYPE_ADDRESS_OBJECT,
                                       (ULONG)TRUE);
                    }
                }

                ASSERT (!pDeviceContext->pFileObjects);
                pDeviceContext->pFileObjects = pFileObjects;

                return(status);
            }

            IF_DBG(NBT_DEBUG_NTUTIL)
                KdPrint(("Nbt.NbtCreateAddressObjects: Error opening Session address with TDI, status=<%x>\n",status));

            //
            // Ensure that the Object pointers are NULLed out!
            //
            pDeviceContext->pSessionFileObject = NULL;

            ObDereferenceObject(pFileObjects->pNameServerFileObject);
            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t  --<   ><====<%x>\tNbtCreateAddressObjects1->ObDereferenceObject\n", pFileObjects->pNameServerFileObject));
            pFileObjects->pNameServerFileObject = NULL;

            locstatus = NTZwCloseFile(pFileObjects->hNameServer);
            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t<===<%x>\tNbtCreateAddressObjects1->NTZwCloseFile (NameServer), status = <%x>\n", pFileObjects->hNameServer, locstatus));
        }
        ObDereferenceObject(pFileObjects->pDgramFileObject);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t  --<   ><====<%x>\tNbtCreateAddressObjects2->ObDereferenceObject\n", pFileObjects->pDgramFileObject));
        pFileObjects->pDgramFileObject = NULL;

        locstatus = NTZwCloseFile(pFileObjects->hDgram);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t<===<%x>\tNbtCreateAddressObjects2->NTZwCloseFile (Dgram), status = <%x>\n", pFileObjects->hDgram, locstatus));

        IF_DBG(NBT_DEBUG_NTUTIL)
            KdPrint(("Unable to Open NameServer port with TDI, status = %X\n",status));
    }

    CTEMemFree (pFileObjects);
    return(status);
}

//----------------------------------------------------------------------------
VOID
GetExtendedAttributes(
    tDEVICECONTEXT  *pDeviceContext
     )
/*++

Routine Description:

    This routine converts a unicode dotted decimal to a ULONG

Arguments:


Return Value:

    none

--*/

{
    NTSTATUS                            status;
    TCP_REQUEST_QUERY_INFORMATION_EX    QueryReq;
    IO_STATUS_BLOCK                     IoStatus;
    HANDLE                              event;
    IO_STATUS_BLOCK                     IoStatusBlock;
    NTSTATUS                            Status;
    OBJECT_ATTRIBUTES                   ObjectAttributes;
    PFILE_FULL_EA_INFORMATION           EaBuffer;
    UNICODE_STRING                      DeviceName;
    HANDLE                              hTcp;
    ULONG                               Length;
    UCHAR                               pBuffer[256];
    ULONG                               BufferSize = 256;
    BOOLEAN                             Attached = FALSE;
    PWSTR                               pName = L"Tcp";

    CTEPagedCode();

    //
    // Open a control channel to TCP for this IOCTL.
    //
    // NOTE: We cannot use the hControl in the DeviceContext since that was created in the context
    // of the system process (address arrival from TCP/IP). Here, we are in the context of the service
    // process (Ioctl down from DHCP) and so we need to open another control channel.
    //
    // NOTE: We still need to maintain the earlier call to create a control channel since that is
    // used to submit TDI requests down to TCP/IP.
    //

    // copy device name into the unicode string
    Status = CreateDeviceString(pName,&DeviceName);
    if (!NT_SUCCESS(Status))
    {
        return;
    }

#ifdef HDL_FIX
    InitializeObjectAttributes (&ObjectAttributes, &DeviceName, OBJ_KERNEL_HANDLE, NULL, NULL);
#else
    InitializeObjectAttributes (&ObjectAttributes, &DeviceName, 0, NULL, NULL);
#endif  // HDL_FIX

    IF_DBG(NBT_DEBUG_TDIADDR)
        KdPrint(("Nbt.GetExtendedAttributes: Tcp device to open = %ws\n", DeviceName.Buffer));

    EaBuffer = NULL;

    Status = ZwCreateFile (&hTcp,
                           GENERIC_READ | GENERIC_WRITE,
                           &ObjectAttributes,     // object attributes.
                           &IoStatusBlock,        // returned status information.
                           NULL,                  // block size (unused).
                           FILE_ATTRIBUTE_NORMAL, // file attributes.
                           0,
                           FILE_CREATE,
                           0,                     // create options.
                           (PVOID)EaBuffer,       // EA buffer.
                           0); // Ea length

    CTEMemFree(DeviceName.Buffer);

    IF_DBG(NBT_DEBUG_TDIADDR)
        KdPrint( ("OpenControl CreateFile Status:%X, IoStatus:%X\n", Status, IoStatusBlock.Status));

    if ( NT_SUCCESS( Status ))
    {
        //
        // Initialize the TDI information buffers.
        //
        //
        // pass in the ipaddress as the first ULONG of the context array
        //
        *(ULONG *)QueryReq.Context = htonl(pDeviceContext->IpAddress);

        QueryReq.ID.toi_entity.tei_entity   = CL_NL_ENTITY;
        QueryReq.ID.toi_entity.tei_instance = 0;
        QueryReq.ID.toi_class               = INFO_CLASS_PROTOCOL;
        QueryReq.ID.toi_type                = INFO_TYPE_PROVIDER;
        QueryReq.ID.toi_id                  = IP_INTFC_INFO_ID;

        status = ZwCreateEvent(&event, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE);
        if (!NT_SUCCESS(status))
        {
            ZwClose( hTcp );
            return;
        }

        //
        // Make the actual TDI call
        //
        status = ZwDeviceIoControlFile (hTcp,
                                        event,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_TCP_QUERY_INFORMATION_EX,
                                        &QueryReq,
                                        sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                                        pBuffer,
                                        BufferSize);

        //
        // If the call pended and we were supposed to wait for completion,
        // then wait.
        //
        if ( status == STATUS_PENDING )
        {
            status = NtWaitForSingleObject (event, FALSE, NULL);
            ASSERT(status == STATUS_SUCCESS);
        }

        if (NT_SUCCESS(status))
        {
            pDeviceContext->IpInterfaceFlags = ((IPInterfaceInfo *) pBuffer)->iii_flags;

            //
            // get the length of the mac address in case is is less than 6 bytes
            //
            Length =   (((IPInterfaceInfo *)pBuffer)->iii_addrlength < sizeof(tMAC_ADDRESS))
                ? ((IPInterfaceInfo *)pBuffer)->iii_addrlength : sizeof(tMAC_ADDRESS);
            CTEZeroMemory(pDeviceContext->MacAddress.Address,sizeof(tMAC_ADDRESS));
            CTEMemCopy(&pDeviceContext->MacAddress.Address[0], ((IPInterfaceInfo *)pBuffer)->iii_addr,Length);
        }

        status = ZwClose(event);
        ASSERT (NT_SUCCESS(status));

        //
        // Close the handle to TCP since we dont need it anymore; all TDI requests go thru the
        // Control handle in the DeviceContext.
        //
        status = ZwClose(hTcp);
        ASSERT (NT_SUCCESS(status));

        status = IoStatus.Status;
    }
    else
    {
        KdPrint(("Nbt:Failed to Open the control connection to the transport, status1 = %X\n", Status));
    }

    return;
}


//----------------------------------------------------------------------------
NTSTATUS
ConvertToUlong(
    IN  PUNICODE_STRING      pucAddress,
    OUT ULONG                *pulValue)

/*++

Routine Description:

    This routine converts a unicode dotted decimal to a ULONG

Arguments:


Return Value:

    none

--*/

{
    NTSTATUS        status;
    OEM_STRING      OemAddress;

    // create integer from unicode string

    CTEPagedCode();
    status = RtlUnicodeStringToAnsiString(&OemAddress, pucAddress, TRUE);
    if (!NT_SUCCESS(status))
    {
        return(status);
    }

    status = ConvertDottedDecimalToUlong(OemAddress.Buffer,pulValue);

    RtlFreeAnsiString(&OemAddress);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_NTUTIL)
            KdPrint(("ERR: Bad Dotted Decimal Ip Address(must be <=255 with 4 dots) = %ws\n",
                        pucAddress->Buffer));

        return(status);
    }

    return(STATUS_SUCCESS);


}



//----------------------------------------------------------------------------
VOID
NbtGetMdl(
    PMDL    *ppMdl,
    enum eBUFFER_TYPES eBuffType)

/*++

Routine Description:

    This routine allocates an Mdl.

Arguments:

    ppListHead  - a ptr to a ptr to the list head to add buffer to
    iNumBuffers - the number of buffers to add to the queue

Return Value:

    none

--*/

{
    PMDL           pMdl;
    ULONG          lBufferSize;
    PVOID          pBuffer;

    *ppMdl = NULL;
    if (NbtConfig.iCurrentNumBuff[eBuffType] >= NbtConfig.iMaxNumBuff[eBuffType])
    {
        return;
    }

    lBufferSize = NbtConfig.iBufferSize[eBuffType];

    pBuffer = NbtAllocMem((USHORT)lBufferSize,NBT_TAG('g'));
    if (!pBuffer)
    {
        return;
    }

    // allocate a MDL to hold the session hdr
    pMdl = IoAllocateMdl(
                (PVOID)pBuffer,
                lBufferSize,
                FALSE,      // want this to be a Primary buffer - the first in the chain
                FALSE,
                NULL);

    if (!pMdl)
    {
        CTEMemFree(pBuffer);
        return;
    }

    // fill in part of the session hdr since it is always the same
    if (eBuffType == eNBT_FREE_SESSION_MDLS)
    {
        ((tSESSIONHDR *)pBuffer)->Flags = NBT_SESSION_FLAGS;
        ((tSESSIONHDR *)pBuffer)->Type = NBT_SESSION_MESSAGE;
    }

    // map the Mdl properly to fill in the pages portion of the MDL
    MmBuildMdlForNonPagedPool(pMdl);

    NbtConfig.iCurrentNumBuff[eBuffType]++;
    *ppMdl = pMdl;
}

//----------------------------------------------------------------------------
NTSTATUS
NbtInitMdlQ(
    PSINGLE_LIST_ENTRY pListHead,
    enum eBUFFER_TYPES eBuffType)

/*++

Routine Description:

    This routine allocates Mdls for use later.

Arguments:

    ppListHead  - a ptr to a ptr to the list head to add buffer to
    iNumBuffers - the number of buffers to add to the queue

Return Value:

    none

--*/

{
    int             i;
    PMDL            pMdl;


    CTEPagedCode();
    // Initialize the list head, so the last element always points to NULL
    pListHead->Next = NULL;

    // create a small number first and then lis the list grow with time
    for (i=0;i < NBT_INITIAL_NUM ;i++ )
    {
        NbtGetMdl (&pMdl,eBuffType);
        if (!pMdl)
        {
            KdPrint(("NBT:Unable to allocate MDL at initialization time!!\n"));\
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        // put on free list
        PushEntryList (pListHead, (PSINGLE_LIST_ENTRY)pMdl);
    }

    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
NTSTATUS
NTZwCloseFile(
    IN  HANDLE      Handle
    )

/*++
Routine Description:

    This Routine handles closing a handle with NT within the context of NBT's
    file system process.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS    status;
    BOOLEAN     Attached = FALSE;

    CTEPagedCode();
    //
    // Attach to NBT's FSP (file system process) to free the handle since
    // the handle is only valid in that process.
    //
    CTEAttachFsp(&Attached, REF_FSP_CLOSE_FILE);
    status = ZwClose(Handle);
    CTEDetachFsp(Attached, REF_FSP_CLOSE_FILE);

    return(status);
}
//----------------------------------------------------------------------------
NTSTATUS
NTReReadRegistry(
    IN tDEVICECONTEXT * pDeviceContext,
    IN BOOL bDoRefresh
    )

/*++
Routine Description:

    This Routine re-reads the registry values when DHCP issues the Ioctl
    to do so.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    tADDRARRAY          DeviceAddressArray;
    PLIST_ENTRY         pHead;
    PLIST_ENTRY         pEntry;
#ifdef MULTIPLE_WINS
    int j;
#endif

    CTEPagedCode();


    ASSERT (NBT_VERIFY_HANDLE2 (pDeviceContext, NBT_VERIFY_DEVCONTEXT, NBT_VERIFY_DEVCONTEXT_DOWN));

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("NBT:Found BindName: %lx\n", pDeviceContext->BindName));


    if (LookupDeviceInRegistry(&pDeviceContext->BindName, &DeviceAddressArray, NULL) == STATUS_SUCCESS) {
        //
        // We found a match
        //
        pDeviceContext->lNameServerAddress  = DeviceAddressArray.NameServerAddress;
        pDeviceContext->lBackupServer       = DeviceAddressArray.BackupServer;
        pDeviceContext->SwitchedToBackup    = 0;
        pDeviceContext->RefreshToBackup     = 0;
#ifdef MULTIPLE_WINS
        pDeviceContext->lNumOtherServers    = DeviceAddressArray.NumOtherServers;
        pDeviceContext->lLastResponsive     = 0;
        for (j = 0; j < DeviceAddressArray.NumOtherServers; j++) {
            pDeviceContext->lOtherServers[j] = DeviceAddressArray.Others[j];
        }
#endif
#ifdef _NETBIOSLESS
        pDeviceContext->NetbiosEnabled       = DeviceAddressArray.NetbiosEnabled;
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NTReReadRegistry: <%wZ> NetbiosEnabled=<%d>\n",
                 &pDeviceContext->ExportName, pDeviceContext->NetbiosEnabled));
#endif
        pDeviceContext->RasProxyFlags        = DeviceAddressArray.RasProxyFlags;
        pDeviceContext->EnableNagling        = DeviceAddressArray.EnableNagling;
        SetNodeType();
    } else {
        KdPrint(("netbt!NtReReadRegistry: Cannot find device in the registry\n"));
    }

    if (pDeviceContext->IpAddress)
    {
        if (!(NodeType & BNODE))
        {
            if (bDoRefresh) {
                // Probably the Ip address just changed and Dhcp is informing us
                // of a new Wins Server addresses, so refresh all the names to the
                // new wins server
                //
                ReRegisterLocalNames(pDeviceContext, FALSE);
            }
        }
        else
        {
            //
            // no need to refresh
            // on a Bnode
            //
            NbtStopRefreshTimer();
        }
    }

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
ULONG   EventLogSequenceNumber = 0;

NTSTATUS
NbtLogEventDetailed(
    IN ULONG    EventCode,
    IN NTSTATUS NtStatusCode,
    IN ULONG    Info,
    IN PVOID    RawDataBuffer,
    IN USHORT   RawDataLength,
    IN USHORT   NumberOfInsertionStrings,
    ...
    )

#define LAST_NAMED_ARGUMENT NumberOfInsertionStrings


/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:



Return Value:

    None.


--*/
{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    va_list                 ParmPtr;                    // Pointer to stack parms.
    PCHAR                   DumpData;
    LONG                    Length;
    ULONG                   i, SizeOfRawData, RemainingSpace, TotalErrorLogEntryLength;
    ULONG                   SizeOfStringData = 0;
    PWSTR                   StringOffset, InsertionString;

    if (NumberOfInsertionStrings != 0)
    {
        va_start (ParmPtr, LAST_NAMED_ARGUMENT);

        for (i = 0; i < NumberOfInsertionStrings; i += 1)
        {
            InsertionString = va_arg (ParmPtr, PWSTR);
            Length = wcslen (InsertionString);
            while ((Length > 0) && (InsertionString[Length-1] == L' '))
            {
                Length--;
            }

            SizeOfStringData += (Length + 1) * sizeof(WCHAR);
        }
    }

    //
    //  Ideally we want the packet to hold the servername and ExtraInformation.
    //  Usually the ExtraInformation gets truncated.
    //
    TotalErrorLogEntryLength = min (RawDataLength + sizeof(IO_ERROR_LOG_PACKET) + 1 + SizeOfStringData,
                                    ERROR_LOG_MAXIMUM_SIZE);

    RemainingSpace = TotalErrorLogEntryLength - FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData);
    if (RemainingSpace > SizeOfStringData)
    {
        SizeOfRawData = RemainingSpace - SizeOfStringData;
    }
    else
    {
        SizeOfStringData = RemainingSpace;
        SizeOfRawData = 0;
    }

    ErrorLogEntry = IoAllocateErrorLogEntry (NbtConfig.DriverObject, (UCHAR) TotalErrorLogEntryLength);
    if (ErrorLogEntry == NULL)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt:  Unable to allocate Error Packet for Error logging\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Fill in the error log entry
    //
    ErrorLogEntry->ErrorCode                = EventCode;
    ErrorLogEntry->UniqueErrorValue         = Info;
    ErrorLogEntry->FinalStatus              = NtStatusCode;
    ErrorLogEntry->MajorFunctionCode        = 0;
    ErrorLogEntry->RetryCount               = 0;
    ErrorLogEntry->IoControlCode            = 0;
    ErrorLogEntry->DeviceOffset.LowPart     = 0;
    ErrorLogEntry->DeviceOffset.HighPart    = 0;
    ErrorLogEntry->DumpDataSize             = 0;
    ErrorLogEntry->NumberOfStrings          = 0;
    ErrorLogEntry->SequenceNumber           = EventLogSequenceNumber++;
    ErrorLogEntry->StringOffset = (USHORT) (ROUND_UP_COUNT (FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData)
                                                            + SizeOfRawData, ALIGN_WORD));


    //
    // Append the dump data.  This information is typically an SMB header.
    //
    if ((RawDataBuffer) && (SizeOfRawData))
    {
        DumpData = (PCHAR) ErrorLogEntry->DumpData;
        Length = min (RawDataLength, (USHORT)SizeOfRawData);
        RtlCopyMemory (DumpData, RawDataBuffer, Length);
        ErrorLogEntry->DumpDataSize = (USHORT)Length;
    }

    //
    // Add the debug informatuion strings
    //
    if (NumberOfInsertionStrings)
    {
        StringOffset = (PWSTR) ((PCHAR)ErrorLogEntry + ErrorLogEntry->StringOffset);

        //
        // Set up ParmPtr to point to first of the caller's parameters.
        //
        va_start(ParmPtr, LAST_NAMED_ARGUMENT);

        for (i = 0 ; i < NumberOfInsertionStrings ; i+= 1)
        {
            InsertionString = va_arg(ParmPtr, PWSTR);
            Length = wcslen(InsertionString);
            while ( (Length > 0) && (InsertionString[Length-1] == L' '))
            {
                Length--;
            }

            if (((Length + 1) * sizeof(WCHAR)) > SizeOfStringData)
            {
                Length = (SizeOfStringData/sizeof(WCHAR)) - 1;
            }

            if (Length > 0)
            {
                RtlCopyMemory (StringOffset, InsertionString, Length*sizeof(WCHAR));
                StringOffset += Length;
                *StringOffset++ = L'\0';

                SizeOfStringData -= (Length + 1) * sizeof(WCHAR);

                ErrorLogEntry->NumberOfStrings += 1;
            }
        }
    }

    IoWriteErrorLogEntry(ErrorLogEntry);

    return(STATUS_SUCCESS);
}



NTSTATUS
NbtLogEvent(
    IN ULONG             EventCode,
    IN NTSTATUS          Status,
    IN ULONG             Location
    )

/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.


Arguments:

    EventCode         - Identifies the error message.
    Status            - The status value to log: this value is put into the
                        data portion of the log message.


Return Value:

    STATUS_SUCCESS                  - The error was successfully logged..
    STATUS_BUFER_OVERFLOW           - The error data was too large to be logged.
    STATUS_INSUFFICIENT_RESOURCES   - Unable to allocate memory.


--*/

{
    return (NbtLogEventDetailed (EventCode, Status, Location, NULL, 0, 0));
}


VOID
DelayedNbtLogDuplicateNameEvent(
    IN  PVOID                   Context1,
    IN  PVOID                   Context2,
    IN  PVOID                   Context3,
    IN  tDEVICECONTEXT          *pDeviceContext
    )
{
    tNAMEADDR               *pNameAddr      = (tNAMEADDR *) Context1;
    tIPADDRESS              RemoteIpAddress = (tIPADDRESS) PtrToUlong (Context2);
    ULONG                   Location        = (ULONG) PtrToUlong (Context3);
    UCHAR                   *pszNameOrig    = pNameAddr->Name;

    NTSTATUS                status;
    UCHAR                   *pAddr;
    WCHAR                   wstrName[22];
    WCHAR                   wstrDeviceIp[22];
    WCHAR                   wstrRemoteServerIp[22];

    UCHAR                   pszName[22];
    STRING                  TmpOEMString;
    UNICODE_STRING          UnicodeString;

    CTEPagedCode();

    UnicodeString.MaximumLength = sizeof(WCHAR)*(22);

    sprintf (pszName,"%-15.15s:%x", pszNameOrig, pszNameOrig[15]);
    UnicodeString.Length = 0;
    UnicodeString.Buffer = wstrName;
    RtlInitString (&TmpOEMString, pszName);
    status = RtlOemStringToUnicodeString (&UnicodeString, &TmpOEMString, FALSE);
    UnicodeString.Buffer[UnicodeString.Length/sizeof(WCHAR)] = L'\0';

    pAddr = (PUCHAR) &pDeviceContext->IpAddress;
    swprintf (wstrDeviceIp, L"%d.%d.%d.%d", pAddr[3], pAddr[2], pAddr[1], pAddr[0]);

    pAddr = (PUCHAR) &RemoteIpAddress;
    swprintf (wstrRemoteServerIp, L"%d.%d.%d.%d", pAddr[3], pAddr[2], pAddr[1], pAddr[0]);

    status = NbtLogEventDetailed (EVENT_NBT_DUPLICATE_NAME_ERROR,
                                  STATUS_UNSUCCESSFUL,
                                  Location,
                                  NULL,
                                  0,
                                  3,
                                  &wstrName,
                                  &wstrDeviceIp,
                                  &wstrRemoteServerIp);

    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT, FALSE);
}



#if DBG
//----------------------------------------------------------------------------
VOID
AcquireSpinLockDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN PKIRQL          pOldIrq,
    IN INT             LineNumber
    )

/*++

Routine Description:

    This function gets the spin lock, and then sets the mask in Nbtconfig, per
    processor.


Arguments:


Return Value:


--*/

{
    CCHAR  CurrProc;
    UCHAR  LockFree;

    CTEGetLock(&pLockInfo->SpinLock,pOldIrq);

    CurrProc = (CCHAR)KeGetCurrentProcessorNumber();
    NbtConfig.CurrProc = CurrProc;

    LockFree = (pLockInfo->LockNumber > (UCHAR)NbtConfig.CurrentLockNumber[CurrProc]);
    if (!LockFree)
    {
        KdPrint(("Nbt.AcquireSpinLockDebug: CurrProc = %X, CurrentLockNum = %X DataSTructLock = %X\n",
        CurrProc,NbtConfig.CurrentLockNumber[CurrProc],pLockInfo->LockNumber));
    }                                                                       \

    ASSERTMSG("Possible DeadLock, Getting SpinLock at a lower level\n",LockFree);
    NbtConfig.CurrentLockNumber[CurrProc]|= pLockInfo->LockNumber;

    pLockInfo->LastLockLine = LineNumber;
}

//----------------------------------------------------------------------------
VOID
FreeSpinLockDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN KIRQL           OldIrq,
    IN INT             LineNumber
    )

/*++

Routine Description:

    This function clears the spin lock from the mask in Nbtconfig, per
    processor and then releases the spin lock.


Arguments:


Return Value:
     none

--*/

{
    CCHAR  CurrProc;

    CurrProc = (CCHAR)KeGetCurrentProcessorNumber();

    NbtConfig.CurrentLockNumber[CurrProc] &= ~pLockInfo->LockNumber;

    pLockInfo->LastReleaseLine = LineNumber;
    CTEFreeLock(&pLockInfo->SpinLock,OldIrq);
}
//----------------------------------------------------------------------------
VOID
AcquireSpinLockAtDpcDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN INT             LineNumber
    )

/*++

Routine Description:

    This function gets the spin lock, and then sets the mask in Nbtconfig, per
    processor.


Arguments:


Return Value:


--*/

{
    CCHAR  CurrProc;
    UCHAR  LockFree;

    CTEGetLockAtDPC(&pLockInfo->SpinLock);
    pLockInfo->LastLockLine = LineNumber;

    CurrProc = (CCHAR)KeGetCurrentProcessorNumber();
    NbtConfig.CurrProc = CurrProc;

    LockFree = (pLockInfo->LockNumber > (UCHAR)NbtConfig.CurrentLockNumber[CurrProc]);
    if (!LockFree)
    {
        KdPrint(("Nbt.AcquireSpinLockAtDpcDebug: CurrProc = %X, CurrentLockNum = %X DataSTructLock = %X\n",
        CurrProc,NbtConfig.CurrentLockNumber[CurrProc],pLockInfo->LockNumber));
    }                                                                       \

    ASSERTMSG("Possible DeadLock, Getting SpinLock at a lower level\n",LockFree);
    NbtConfig.CurrentLockNumber[CurrProc]|= pLockInfo->LockNumber;

}

//----------------------------------------------------------------------------
VOID
FreeSpinLockAtDpcDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN INT             LineNumber
    )

/*++

Routine Description:

    This function clears the spin lock from the mask in Nbtconfig, per
    processor and then releases the spin lock.


Arguments:


Return Value:
     none

--*/

{
    CCHAR  CurrProc;

    CurrProc = (CCHAR)KeGetCurrentProcessorNumber();

    NbtConfig.CurrentLockNumber[CurrProc] &= ~pLockInfo->LockNumber;

    pLockInfo->LastReleaseLine = LineNumber;
    CTEFreeLockFromDPC(&pLockInfo->SpinLock);
}
#endif //if Dbg

NTSTATUS
NbtBuildDeviceAcl(
    OUT PACL * DeviceAcl
    )
/*++

Routine Description:

    (Lifted from TCP - TcpBuildDeviceAcl)
    This routine builds an ACL which gives Administrators, LocalService and NetworkService
    principals full access. All other principals have no access.

Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/
{
    PGENERIC_MAPPING GenericMapping;
    PSID AdminsSid, ServiceSid, NetworkSid;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask(&AccessMask, GenericMapping);

    AdminsSid = SeExports->SeAliasAdminsSid;
    ServiceSid = SeExports->SeLocalServiceSid;
    NetworkSid = SeExports->SeNetworkServiceSid;

    AclLength = sizeof(ACL) +
        3 * sizeof(ACCESS_ALLOWED_ACE) +
        RtlLengthSid(AdminsSid) +
        RtlLengthSid(ServiceSid) +
        RtlLengthSid(NetworkSid) -
        3 * sizeof(ULONG);

    NewAcl = ExAllocatePool(PagedPool, AclLength);

    if (NewAcl == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    Status = RtlCreateAcl(NewAcl, AclLength, ACL_REVISION);

    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewAcl);
        return (Status);
    }
    Status = RtlAddAccessAllowedAce(
                                    NewAcl,
                                    ACL_REVISION2,
                                    AccessMask,
                                    AdminsSid
                                    );

    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewAcl);
        return (Status);
    }

    Status = RtlAddAccessAllowedAce(
                                    NewAcl,
                                    ACL_REVISION2,
                                    AccessMask,
                                    ServiceSid
                                    );

    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewAcl);
        return (Status);
    }

    Status = RtlAddAccessAllowedAce(
                                    NewAcl,
                                    ACL_REVISION2,
                                    AccessMask,
                                    NetworkSid
                                    );

    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewAcl);
        return (Status);
    }

    *DeviceAcl = NewAcl;

    return (STATUS_SUCCESS);
}

NTSTATUS
NbtCreateAdminSecurityDescriptor(PDEVICE_OBJECT dev)
/*++

Routine Description:

    (Lifted from TCP - TcpCreateAdminSecurityDescriptor)
    This routine creates a security descriptor which gives access
    only to Administrtors and LocalService. This descriptor is used
    to access check raw endpoint opens and exclisive access to transport
    addresses.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PACL rawAcl = NULL;
    NTSTATUS status;
    CHAR buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR localSecurityDescriptor = (PSECURITY_DESCRIPTOR) & buffer;
    SECURITY_INFORMATION securityInformation = DACL_SECURITY_INFORMATION;

    //
    // Build a local security descriptor with an ACL giving only
    // administrators and service access.
    //
    status = NbtBuildDeviceAcl(&rawAcl);

    if (!NT_SUCCESS(status)) {
        KdPrint(("TCP: Unable to create Raw ACL, error: %x\n", status));
        return (status);
    }

    (VOID) RtlCreateSecurityDescriptor(
                                       localSecurityDescriptor,
                                       SECURITY_DESCRIPTOR_REVISION
                                       );

    (VOID) RtlSetDaclSecurityDescriptor(
                                        localSecurityDescriptor,
                                        TRUE,
                                        rawAcl,
                                        FALSE
                                        );

    //
    // Now apply the local descriptor to the raw descriptor.
    //
    status = SeSetSecurityDescriptorInfo(
                                         NULL,
                                         &securityInformation,
                                         localSecurityDescriptor,
                                         &dev->SecurityDescriptor,
                                         PagedPool,
                                         IoGetFileObjectGenericMapping()
                                         );

    if (!NT_SUCCESS(status)) {
        KdPrint(("Nbt: SeSetSecurity failed, %lx\n", status));
    }

    ExFreePool(rawAcl);
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\tdicnct.c ===
//
//
//  NBTCONNCT.C
//
//  This file contains code relating to opening connections with the transport
//  provider.  The Code is NT specific.

#include "precomp.h"

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NbtTdiOpenConnection)
#pragma CTEMakePageable(PAGE, NbtTdiAssociateConnection)
#pragma CTEMakePageable(PAGE, NbtTdiCloseConnection)
#pragma CTEMakePageable(PAGE, CreateDeviceString)
#pragma CTEMakePageable(PAGE, NbtTdiCloseAddress)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
NTSTATUS
NbtTdiOpenConnection (
    IN tLOWERCONNECTION     *pLowerConn,
    IN  tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description:

    This routine opens a connection with the transport provider.

Arguments:

    pLowerConn - Pointer to where the handle to the Transport for this virtual
        connection should be stored.

    pNbtConfig - the name of the adapter to connect to is in this structure

Return Value:

    Status of the operation.

--*/
{
    IO_STATUS_BLOCK             IoStatusBlock;
    NTSTATUS                    Status, Status1;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    PWSTR                       pName=L"Tcp";
    PFILE_FULL_EA_INFORMATION   EaBuffer;
    UNICODE_STRING              RelativeDeviceName = {0,0,NULL};
    PMDL                        pMdl;
    PVOID                       pBuffer;
    BOOLEAN                     Attached = FALSE;

    CTEPagedCode();
    // zero out the connection data structure
    CTEZeroMemory(pLowerConn,sizeof(tLOWERCONNECTION));
    SET_STATE_LOWER (pLowerConn, NBT_IDLE);
    pLowerConn->pDeviceContext = pDeviceContext;
    CTEInitLock(&pLowerConn->LockInfo.SpinLock);
#if DBG
    pLowerConn->LockInfo.LockNumber = LOWERCON_LOCK;
#endif
    pLowerConn->Verify = NBT_VERIFY_LOWERCONN;

    //
    // Allocate an MDL for the Indication buffer since we may need to buffer
    // up to 128 bytes
    //
    pBuffer = NbtAllocMem(NBT_INDICATE_BUFFER_SIZE,NBT_TAG('l'));
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pMdl = IoAllocateMdl(pBuffer,NBT_INDICATE_BUFFER_SIZE,FALSE,FALSE,NULL);

    if (pMdl)
    {

        MmBuildMdlForNonPagedPool(pMdl);

        pLowerConn->pIndicateMdl = pMdl;

#ifdef HDL_FIX
        InitializeObjectAttributes (&ObjectAttributes,
                                    &RelativeDeviceName,
                                    OBJ_KERNEL_HANDLE,
                                    pDeviceContext->hSession,   // Use a relative File Handle
                                    NULL);
#else
        InitializeObjectAttributes (&ObjectAttributes,
                                    &RelativeDeviceName,
                                    0,
                                    pDeviceContext->hSession,   // Use a relative File Handle
                                    NULL);
#endif  // HDL_FIX

        // Allocate memory for the address info to be passed to the transport
        EaBuffer = (PFILE_FULL_EA_INFORMATION)NbtAllocMem (
                        sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                        TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                        sizeof(CONNECTION_CONTEXT),NBT_TAG('m'));

        if (EaBuffer)
        {
            EaBuffer->NextEntryOffset = 0;
            EaBuffer->Flags = 0;
            EaBuffer->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
            EaBuffer->EaValueLength = sizeof (CONNECTION_CONTEXT);

            // TdiConnectionContext is a macro that = "ConnectionContext" - so move
            // this text to EaName
            RtlMoveMemory( EaBuffer->EaName, TdiConnectionContext, EaBuffer->EaNameLength + 1 );

            // put the context value into the EaBuffer too - i.e. the value that the
            // transport returns with each indication on this connection
            RtlMoveMemory (
                (PVOID)&EaBuffer->EaName[EaBuffer->EaNameLength + 1],
                (CONST PVOID)&pLowerConn,
                sizeof (CONNECTION_CONTEXT));

            {

                Status = ZwCreateFile (&pLowerConn->FileHandle,
                                       GENERIC_READ | GENERIC_WRITE,
                                       &ObjectAttributes,     // object attributes.
                                       &IoStatusBlock,        // returned status information.
                                       NULL,                  // block size (unused).
                                       FILE_ATTRIBUTE_NORMAL, // file attributes.
                                       0,
                                       FILE_CREATE,
                                       0,                     // create options.
                                       (PVOID)EaBuffer,       // EA buffer.
                                       sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                                          TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                                          sizeof(CONNECTION_CONTEXT));
            }

            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t===><%x>\tNbtTdiOpenConnection->ZwCreateFile, Status = <%x>\n", pLowerConn->FileHandle, Status));

            IF_DBG(NBT_DEBUG_TDICNCT)
                KdPrint( ("Nbt.NbtTdiOpenConnection: CreateFile Status:%X, IoStatus:%X\n", Status, IoStatusBlock.Status));

            CTEMemFree((PVOID)EaBuffer);

            if ( NT_SUCCESS( Status ))
            {

                // if the ZwCreate passed set the status to the IoStatus
                //
                Status = IoStatusBlock.Status;

                if (NT_SUCCESS(Status))
                {
                    // get a reference to the file object and save it since we can't
                    // dereference a file handle at DPC level so we do it now and keep
                    // the ptr around for later.
                    Status = ObReferenceObjectByHandle (pLowerConn->FileHandle,
                                                        0L,
                                                        NULL,
                                                        KernelMode,
                                                        (PVOID *)&pLowerConn->pFileObject,
                                                        NULL);

            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t  ++<%x>====><%x>\tNbtTdiOpenConnection->ObReferenceObjectByHandle, Status = <%x>\n", pLowerConn->FileHandle, pLowerConn->pFileObject, Status));

                    if (NT_SUCCESS(Status))
                    {
#if FAST_DISP
                        // Go ahead and query transport for fast dispath path.
                        IF_DBG(NBT_DEBUG_TDICNCT)
                        KdPrint(("Nbt.NbtTdiOpenConnection: Querying for TCPSendData File object %x\n",pLowerConn->pFileObject ));

                        pLowerConn->FastSend = pDeviceContext->pFastSend;
#endif
                        return(Status);
                    }

                    Status1 = ZwClose(pLowerConn->FileHandle);
                    IF_DBG(NBT_DEBUG_HANDLES)
                        KdPrint (("\t<===<%x>\tNbtTdiOpenConnection->ZwClose, status = <%x>\n", pLowerConn->FileHandle, Status1));
                }

            }

        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }


        IoFreeMdl(pMdl);
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    CTEMemFree(pBuffer);

    return Status;

} /* NbtTdiOpenConnection */

//----------------------------------------------------------------------------
NTSTATUS
NbtTdiAssociateConnection(
    IN  PFILE_OBJECT        pFileObject,
    IN  HANDLE              Handle
    )
/*++

Routine Description:

    This routine associates an open connection with the address object.

Arguments:


    pFileObject - the connection file object
    Handle      - the address object to associate the connection with

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS        status;
    PIRP            pIrp;
    KEVENT          Event;
    BOOLEAN         Attached = FALSE;
    PDEVICE_OBJECT  DeviceObject;

    CTEPagedCode();

    KeInitializeEvent (&Event, SynchronizationEvent, FALSE);

    DeviceObject = IoGetRelatedDeviceObject(pFileObject);
    pIrp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (!pIrp)
    {
        IF_DBG(NBT_DEBUG_TDICNCT)
            KdPrint(("Nbt.NbtTdiAssociateConnection: Failed to build internal device Irp\n"));
        return(STATUS_UNSUCCESSFUL);
    }

    TdiBuildAssociateAddress (pIrp,
                              pFileObject->DeviceObject,
                              pFileObject,
                              NbtTdiCompletionRoutine,
                              &Event,
                              Handle);

    status = SubmitTdiRequest(pFileObject,pIrp);
    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDICNCT)
            KdPrint (("Nbt.NbtTdiAssociateConnection:  ERROR -- SubmitTdiRequest returned <%x>\n", status));
    }

    IoFreeIrp(pIrp);
    return status;
}
//----------------------------------------------------------------------------
NTSTATUS
CreateDeviceString(
    IN  PWSTR               AppendingString,
    IN OUT PUNICODE_STRING  pucDeviceName
    )
/*++

Routine Description:

    This routine creates a string name for the transport device such as
    "\Device\Streams\Tcp"

Arguments:


Return Value:

    Status of the operation.

--*/
{
    NTSTATUS            status;
    ULONG               Len;
    PVOID               pBuffer;
    PWSTR               pTcpBindName = NbtConfig.pTcpBindName;

    CTEPagedCode();

    if (!pTcpBindName)
    {
        pTcpBindName = NBT_TCP_BIND_NAME;
    }

    // copy device name into the unicode string - either Udp or Tcp
    //
    Len = (wcslen(pTcpBindName) + wcslen(AppendingString) + 1) * sizeof(WCHAR);
    if (pBuffer = NbtAllocMem(Len,NBT_TAG('n')))
    {
        pucDeviceName->MaximumLength = (USHORT)Len;
        pucDeviceName->Length = 0;
        pucDeviceName->Buffer = pBuffer;

        // this puts \Device\Streams into the string
        //
        if ((NT_SUCCESS (status = RtlAppendUnicodeToString (pucDeviceName, pTcpBindName))) &&
            (NT_SUCCESS (status = RtlAppendUnicodeToString (pucDeviceName, AppendingString))))
        {
            return(status);
        }

        CTEMemFree(pBuffer);
    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Error case -- cleanup!
    //
    pucDeviceName->MaximumLength = 0;
    pucDeviceName->Length = 0;
    pucDeviceName->Buffer = NULL;

    return(status);
}

//----------------------------------------------------------------------------

NTSTATUS
NbtTdiCloseConnection(
    IN tLOWERCONNECTION * pLowerConn
    )
/*++

Routine Description:

    This routine closes a TDI connection

Arguments:


Return Value:

    Status of the operation.

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    BOOLEAN     Attached= FALSE;

    CTEPagedCode();
    ASSERT( pLowerConn != NULL ) ;

    CTEAttachFsp(&Attached, REF_FSP_CLOSE_CONNECTION);

    if (pLowerConn->FileHandle)
    {
        status = ZwClose(pLowerConn->FileHandle);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t<===<%x>\tNbtTdiCloseConnection->ZwClose, status = <%x>\n", pLowerConn->FileHandle, status));
        pLowerConn->FileHandle = NULL;
    }

#if DBG
    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDICNCT)
            KdPrint(("Nbt.NbtTdiCloseConnection: Failed to close LowerConn FileHandle pLower %X, status %X\n",
                pLowerConn,status));
    }
#endif

    CTEDetachFsp(Attached, REF_FSP_CLOSE_CONNECTION);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtTdiCloseAddress(
    IN tLOWERCONNECTION * pLowerConn
    )
/*++

Routine Description:

    This routine closes a TDI address

Arguments:


Return Value:

    Status of the operation.

--*/
{
    NTSTATUS    status;
    BOOLEAN     Attached= FALSE;

    CTEPagedCode();

    ASSERT( pLowerConn != NULL ) ;

    CTEAttachFsp(&Attached, REF_FSP_CLOSE_ADDRESS);

    status = ZwClose(pLowerConn->AddrFileHandle);
    IF_DBG(NBT_DEBUG_HANDLES)
        KdPrint (("\t<===<%x>\tNbtTdiCloseAddress->ZwClose, status = <%x>\n", pLowerConn->AddrFileHandle, status));
#if DBG
    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDICNCT)
            KdPrint(("Nbt.NbtTdiCloseAddress: Failed to close Address FileHandle pLower %X,status %X\n",
                pLowerConn,status));
    }
#endif

    CTEDetachFsp(Attached, REF_FSP_CLOSE_ADDRESS);

    return(status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\flt\debug.c ===
#include "precomp.h"

#if DBG
ULONG   DbgLevel = DEF_DBG_LEVEL;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\tdihndlr.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Tdihndlr.c

Abstract:


    This file contains the TDI handlers that are setup for Connects,
    Receives, Disconnects, and Errors on various objects such as connections
    and udp endpoints .

    This file represents the inbound TDI interface on the Bottom of NBT.  Therefore
    the code basically decodes the incoming information and passes it to
    a non-Os specific routine to do what it can.  Upon return from that
    routine additional Os specific work may need to be done.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

    Will Lees (wlees)    Sep 11, 1997
        Added support for message-only devices

--*/

#include "precomp.h"
#include "ctemacro.h"
#include "tdihndlr.tmh"

// this macro checks that the types field is always zero in the Session
// Pdu
//
#if DBG
#define CHECK_PDU( _Size,_Offset) \
    if (_Size > 1)              \
        ASSERT(((PUCHAR)pTsdu)[_Offset] == 0)
#else
#define CHECK_PDU( _Size,_Offset )
#endif

#if DBG
UCHAR   pLocBuff[256];
UCHAR   CurrLoc;

ULONG   R1;
ULONG   R2;
ULONG   R3;
ULONG   R4;

ULONG   C1;
ULONG   C2;
ULONG   C3;
ULONG   C4;

ULONG   HitCounter;

#define INCR_COUNT(_Count) _Count++
#else
#define INCR_COUNT(_Count)
#endif


//
// This ntohl swaps just three bytes, since the 4th byte could be a session
// keep alive message type.
//
__inline long
myntohl(long x)
{
    return((((x) >> 24) & 0x000000FFL) |
                        (((x) >>  8) & 0x0000FF00L) |
                        (((x) <<  8) & 0x00FF0000L));
}

NTSTATUS
LessThan4BytesRcvd(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    OUT PVOID                *ppIrp
    );
NTSTATUS
ClientTookSomeOfTheData(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    IN  ULONG                BytesTaken,
    IN  ULONG                PduSize
    );
NTSTATUS
MoreDataRcvdThanNeeded(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PVOID                *ppIrp
    );
NTSTATUS
NotEnoughDataYet(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  ULONG                PduSize,
    OUT PVOID                *ppIrp
    );
NTSTATUS
ProcessIrp(
    IN tLOWERCONNECTION *pLowerConn,
    IN PIRP     pIrp,
    IN PVOID    pBuffer,
    IN PULONG   BytesTaken,
    IN ULONG    BytesIndicted,
    IN ULONG    BytesAvailable
    );

NTSTATUS
NtBuildIndicateForReceive (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               Length,
    OUT PVOID               *ppIrp
    );

NTSTATUS
AcceptCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );

VOID
DpcNextOutOfRsrcKill(
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    );

VOID
DpcGetRestOfIndication(
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    );

NTSTATUS
ClientBufferOverFlow(
    IN tLOWERCONNECTION     *pLowerConn,
    IN tCONNECTELE          *pConnEle,
    IN PIRP                 pIrp,
    IN ULONG                BytesRcvd
    );
VOID
DpcHandleNewSessionPdu (
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    );
VOID
HandleNewSessionPdu (
    IN  tLOWERCONNECTION *pLowerConn,
    IN  ULONG           Offset,
    IN  ULONG           ToGet
    );
NTSTATUS
NewSessionCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );
NTSTATUS
BuildIrpForNewSessionInIndication (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  PIRP                pIrpIn,
    IN  ULONG               BytesAvailable,
    IN  ULONG               RemainingPdu,
    OUT PIRP                *ppIrp
    );
VOID
TrackIndicatedBytes(
    IN ULONG            BytesIndicated,
    IN ULONG            BytesTaken,
    IN tCONNECTELE      *pConnEle
    );

__inline
VOID
DerefLowerConnFast (
    IN tLOWERCONNECTION *pLowerConn,
    IN CTELockHandle    OldIrq
    );

NTSTATUS
CopyDataandIndicate(
    IN PVOID                ReceiveEventContext,
    IN PVOID                ConnectionContext,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PIRP                *ppIrp
    );

VOID
SumMdlLengths (
    IN PMDL         pMdl,
    IN ULONG        BytesAvailable,
    IN tCONNECTELE  *pConnectEle
    );



NTSTATUS
RsrcKillCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );

VOID
NbtCancelFillIrpRoutine(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

NTSTATUS
NameSrvCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef _NETBIOSLESS
NTSTATUS
PerformInboundProcessing(
    tDEVICECONTEXT *pDeviceContext,
    tLOWERCONNECTION *pLowerConn,
    PTA_IP_ADDRESS pIpAddress
    );
#endif

//----------------------------------------------------------------------------
__inline
NTSTATUS
Normal(
    IN  PVOID                ReceiveEventContext,
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  USHORT               ReceiveFlags,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an session packet arrives from the network. It calls
    a non OS specific routine to decide what to do.  That routine passes back
    either a RcvElement (buffer) or a client rcv handler to call.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    ASSERTMSG("Should not execute this procedure",0);
    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
NTSTATUS
LessThan4BytesRcvd(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine handles the case when data has arrived on a connection but
    there isn't 128 bytes yet or a whole pdu.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    tCONNECTELE  *pConnectEle;
    NTSTATUS     status;

    // for short indications less than 4 bytes we can't determine
    // the pdu size so just get the header first then get the
    // whole pdu next.

    status = NtBuildIrpForReceive(pLowerConn,
                                  sizeof(tSESSIONHDR),
                                  (PVOID *)ppIrp);

    pConnectEle = pLowerConn->pUpperConnection;

    pConnectEle->BytesInXport = BytesAvailable;

    if (!NT_SUCCESS(status))
    {
        CTESpinFreeAtDpc(pLowerConn);
        OutOfRsrcKill(pLowerConn);
        CTESpinLockAtDpc(pLowerConn);
        return( STATUS_DATA_NOT_ACCEPTED);
    }
    //
    // set the irp mdl length to size of session hdr so that
    // we don't get more than one session pdu into the buffer
    //
    SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, IndicateBuffer);

    *BytesTaken = 0;
    IF_DBG(NBT_DEBUG_INDICATEBUFF)
    KdPrint(("Nbt:Switching to Ind Buff(<4 bytes), Avail = %X\n",
            BytesAvailable));

    PUSH_LOCATION(0);
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

//----------------------------------------------------------------------------
NTSTATUS
ClientTookSomeOfTheData(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    IN  ULONG                BytesTaken,
    IN  ULONG                PduSize
    )
/*++

Routine Description:

    This routine handles the case when data has arrived on a connection but
    the client has not taken all of the data indicated to it.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    tCONNECTELE  *pConnectEle;

    //
    // took some of the data, so keep track of the
    // rest of the data left here by going to the PARTIALRCV
    // state.
    //
    PUSH_LOCATION(0x5);

    SET_STATERCV_LOWER(pLowerConn, PARTIAL_RCV, PartialRcv);

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
    KdPrint(("Nbt.ClientTookSomeOfTheData: Switch to Partial Rcv Indicated=%X, PduSize=%X\n",
            BytesIndicated,PduSize-4));

    // Note: PduSize must include the 4 byte session header for this to
    // work correctly.
    //
    pConnectEle = pLowerConn->pUpperConnection;
    //
    // We always indicate the whole Pdu size to the client, so the amount
    // indicated is that minus what was taken - typically the 4 byte
    // session hdr
    //
    pConnectEle->ReceiveIndicated = PduSize - BytesTaken;

    // amount left in the transport...
    pConnectEle->BytesInXport = BytesAvailable - BytesTaken;

    // need to return this status since we took the 4 bytes
    // session header at least, even if the client took none.
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
MoreDataRcvdThanNeeded(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine handles the case when data has arrived on a connection but
    there isn't 128 bytes yet or a whole pdu.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    tCONNECTELE  *pConnectEle;
    ULONG        Length;
    ULONG        Remaining;
    ULONG        PduSize;
    NTSTATUS     status;
    tSESSIONHDR  UNALIGNED *pSessionHdr;


    PUSH_LOCATION(0x6);
    //
    // there is too much data, so keep track of the
    // fact that there is data left in the transport
    // and get it with the indicate buffer
    //
    SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, IndicateBuffer);

    ASSERT(pLowerConn->BytesInIndicate == 0);
#if DBG
    if (pLowerConn->BytesInIndicate)
    {
        KdPrint(("Nbt:Bytes in indicate should be ZERO, but are = %X\n",
            pLowerConn->BytesInIndicate));
    }
#endif
    pConnectEle = pLowerConn->pUpperConnection;
    pConnectEle->BytesInXport = BytesAvailable - *BytesTaken;

    //
    // for short indications less than 4 bytes we can't determine
    // the pdu size so just get the header first then get the
    // whole pdu next.
    //
    Remaining = BytesIndicated - *BytesTaken;
    if ((LONG) Remaining < (LONG) sizeof(tSESSIONHDR))
    {
        status = NtBuildIrpForReceive(pLowerConn,sizeof(tSESSIONHDR),(PVOID *)ppIrp);
        if (!NT_SUCCESS(status))
        {
            // this is a serious error - we must
            // kill of the connection and let the
            // redirector restart it
            KdPrint(("Nbt:Unable to get an Irp for RCv - Closing Connection!! %X\n",pLowerConn));
            CTESpinFreeAtDpc(pLowerConn);

            OutOfRsrcKill(pLowerConn);
            CTESpinLockAtDpc(pLowerConn);

            return(STATUS_DATA_NOT_ACCEPTED);
        }
        IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:< 4 Bytes,BytesTaken=%X,Avail=%X,Ind=%X,Remain=%X\n",
            *BytesTaken,BytesAvailable,BytesIndicated,
            Remaining));

        // DEBUG
        CTEZeroMemory(MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl),
                        NBT_INDICATE_BUFFER_SIZE);

        PUSH_LOCATION(0x7);
        status = STATUS_MORE_PROCESSING_REQUIRED;
    }
    else
    {
        // if we get to here there are enough bytes left to determine
        // the next pdu size...so we can determine how much
        // data to get for the indicate buffer
        //
        pSessionHdr = (tSESSIONHDR UNALIGNED *)((PUCHAR)pTsdu + *BytesTaken);

        PduSize = myntohl(pSessionHdr->UlongLength) + sizeof(tSESSIONHDR);


        Length = (PduSize > NBT_INDICATE_BUFFER_SIZE) ?
                         NBT_INDICATE_BUFFER_SIZE : PduSize;

        //
        // The NewSessionCompletion routine recalculates
        // what is left in the transport  when the
        // irp completes
        //
        status = NtBuildIrpForReceive(pLowerConn,Length,(PVOID *)ppIrp);
        if (!NT_SUCCESS(status))
        {
            // this is a serious error - we must
            // kill of the connection and let the
            // redirector restart it
            KdPrint(("Nbt:Unable to get an Irp for RCV(2) - Closing Connection!! %X\n",pLowerConn));
            CTESpinFreeAtDpc(pLowerConn);
            OutOfRsrcKill(pLowerConn);
            CTESpinLockAtDpc(pLowerConn);
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:Switch to Ind Buff, InXport = %X, Pdusize=%X,ToGet=%X\n",
                pConnectEle->BytesInXport,PduSize-4,Length));

    }

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

//----------------------------------------------------------------------------
NTSTATUS
NotEnoughDataYet(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  ULONG                PduSize,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine handles the case when data has arrived on a connection but
    there isn't 128 bytes yet or a whole pdu.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS            status;
    tCONNECTELE         *pConnectEle;
    ULONG               Length;

    PUSH_LOCATION(0x9);
    //
    // not enough data indicated, so use the indicate buffer
    //
    Length = (PduSize > NBT_INDICATE_BUFFER_SIZE) ?
                     NBT_INDICATE_BUFFER_SIZE : PduSize;

    status = NtBuildIrpForReceive(pLowerConn,Length,(PVOID *)ppIrp);
    if (!NT_SUCCESS(status))
    {
        CTESpinFreeAtDpc(pLowerConn);
        OutOfRsrcKill(pLowerConn);
        CTESpinLockAtDpc(pLowerConn);
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    *BytesTaken = 0;

    SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, IndicateBuffer);

    pConnectEle = pLowerConn->pUpperConnection;
    pConnectEle->BytesInXport = BytesAvailable;

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
    KdPrint(("Nbt:Not Enough data indicated in Tdihndlr, using indic. buffer Indicated = %X,Avail=%X,PduSize= %X\n",
            BytesIndicated, BytesAvailable,PduSize-4));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

//----------------------------------------------------------------------------
NTSTATUS
FillIrp(
    IN  PVOID                ReceiveEventContext,
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  USHORT               ReceiveFlags,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an session packet arrives from the network. It calls
    a non OS specific routine to decide what to do.  That routine passes back
    either a RcvElement (buffer) or a client rcv handler to call.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    ASSERTMSG("Should not execute this procedure",0);
    return(STATUS_SUCCESS);
    // do nothing

}
//----------------------------------------------------------------------------
NTSTATUS
IndicateBuffer(
    IN  PVOID                ReceiveEventContext,
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  USHORT               ReceiveFlags,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine handles reception of data while in the IndicateBuffer state.
    In this state the indicate buffer is receiveing data until at least
    128 bytes have been receive, or a whole pdu has been received.


Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    tCONNECTELE         *pConnectEle;
    NTSTATUS            status;
    ULONG               PduSize;
    ULONG               ToCopy;
    PVOID               pIndicateBuffer;
    ULONG               Taken;

    //
    // there is data in the indicate buffer and we got a new
    // indication, so copy some or all of the indication to the
    // indicate buffer
    //
    PVOID       pDest;
    ULONG       RemainPdu;
    ULONG       SpaceLeft;
    ULONG       TotalBytes;
    ULONG       ToCopy1=0;

    INCR_COUNT(R3);
    PUSH_LOCATION(0xe);
    pConnectEle = pLowerConn->pUpperConnection;
    ASSERT(pLowerConn->StateRcv == INDICATE_BUFFER);
    //
    // The indicate buffer always starts with a pdu
    //
    pIndicateBuffer = MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl);

    // the location to start copying the new data into is right
    // after the existing data in the buffer
    //
    pDest = (PVOID)((PUCHAR)pIndicateBuffer + pLowerConn->BytesInIndicate);

    //
    // the session header may not be all into the indicate
    // buffer yet, so check that before getting the pdu length.
    //
    if (pLowerConn->BytesInIndicate < sizeof(tSESSIONHDR))
    {
        PUSH_LOCATION(0xe);
        IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:Too Few in Indicate Buff, Adding InIndicate %X\n",
            pLowerConn->BytesInIndicate));

        ToCopy1 = sizeof(tSESSIONHDR) - pLowerConn->BytesInIndicate;
        if (ToCopy1 > BytesIndicated)
        {
            ToCopy1 = BytesIndicated;
        }
        CTEMemCopy(pDest,pTsdu,ToCopy1);

        pDest = (PVOID)((PUCHAR)pDest + ToCopy1);
        pTsdu = (PVOID)((PUCHAR)pTsdu + ToCopy1);

        pLowerConn->BytesInIndicate += (USHORT)ToCopy1;

        *BytesTaken = ToCopy1;
    }

    // now check again, and pass down an irp to get more data if necessary
    //
    if (pLowerConn->BytesInIndicate < sizeof(tSESSIONHDR))
    {
        IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:< 4 Bytes in IndicBuff, BytesinInd= %X, BytesIndicated=%x\n",
                    pLowerConn->BytesInIndicate,BytesIndicated));

        PUSH_LOCATION(0xF);

        //
        // the data left in the transport is what was Available
        // minus what we just copied to the indicate buffer
        //
        pConnectEle->BytesInXport = BytesAvailable - ToCopy1;

        if (pConnectEle->BytesInXport)
        {
            PUSH_LOCATION(0x10);
            //
            // pass the indicate buffer down to get some more data
            // to fill out to the end of the session hdr
            //
            NtBuildIndicateForReceive(pLowerConn,
                                      sizeof(tSESSIONHDR)-pLowerConn->BytesInIndicate,
                                      (PVOID *)ppIrp);

            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:INDIC_BUF...need more data for hdr Avail= %X, InXport = %X\n",
                        BytesAvailable,pConnectEle->BytesInXport,pLowerConn));

            return(STATUS_MORE_PROCESSING_REQUIRED);
        }

        // if we get to here there isn't 4 bytes in the indicate buffer and
        // there is no more data in the Transport, so just wait for the next
        // indication.
        //
        return(STATUS_SUCCESS);
    }

    PduSize = myntohl(((tSESSIONHDR *)pIndicateBuffer)->UlongLength)
                        + sizeof(tSESSIONHDR);

    // copy up to 132 bytes or the whole pdu to the indicate buffer
    //
    RemainPdu = PduSize - pLowerConn->BytesInIndicate;

    SpaceLeft = NBT_INDICATE_BUFFER_SIZE - pLowerConn->BytesInIndicate;

    if (RemainPdu < SpaceLeft)
        ToCopy = RemainPdu;
    else
        ToCopy = SpaceLeft;

    if (ToCopy > (BytesIndicated-ToCopy1))
    {
        ToCopy = (BytesIndicated - ToCopy1);
    }

    //
    // Copy the indication or part of it to the indication
    // buffer
    //
    CTEMemCopy(pDest,pTsdu,ToCopy);

    pLowerConn->BytesInIndicate += (USHORT)ToCopy;

    TotalBytes = pLowerConn->BytesInIndicate;

    // the amount of data taken is the amount copied to the
    // indicate buffer
    //
    *BytesTaken = ToCopy + ToCopy1;

#if DBG
    {
        tSESSIONHDR  UNALIGNED  *pSessionHdr;
        pSessionHdr = (tSESSIONHDR UNALIGNED *)pIndicateBuffer;
        ASSERT((pSessionHdr->Type == NBT_SESSION_KEEP_ALIVE) ||
                (pSessionHdr->Type == NBT_SESSION_MESSAGE));
    }
#endif

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
    KdPrint(("Nbt:INDIC_BUFF, TotalBytes= %X, InIndic=%X, Copied(0/1)= %X %X Avail %X\n",
                TotalBytes,pLowerConn->BytesInIndicate,ToCopy,ToCopy1,BytesAvailable));


    // the data left in the transport is what was Available
    // minus what we just copied to the indicate buffer
    //
    pConnectEle->BytesInXport = BytesAvailable - *BytesTaken;

    // now check if we have a whole pdu or 132 bytes, either way
    // enough to indicate to the client.
    //
    ASSERT(TotalBytes <= NBT_INDICATE_BUFFER_SIZE);

    if ((TotalBytes < NBT_INDICATE_BUFFER_SIZE) && (TotalBytes < PduSize) && (pConnectEle->BytesInXport)) {
        //
        // This could happen if BytesIndicated < BytesAvailable
        //
        ToCopy = PduSize;
        if (ToCopy > NBT_INDICATE_BUFFER_SIZE) {
            ToCopy = NBT_INDICATE_BUFFER_SIZE;
        }

        ASSERT (TotalBytes == pLowerConn->BytesInIndicate);
        NtBuildIndicateForReceive(pLowerConn, ToCopy - TotalBytes, (PVOID *)ppIrp);
#if DBG
        HitCounter++;
#endif
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    if ((TotalBytes == NBT_INDICATE_BUFFER_SIZE) ||
        (TotalBytes == PduSize))
    {

        status = CopyDataandIndicate(
                        ReceiveEventContext,
                        (PVOID)pLowerConn,
                        ReceiveFlags,
                        TotalBytes,
                        pConnectEle->BytesInXport + TotalBytes,
                        &Taken,
                        pIndicateBuffer,
                        (PIRP *)ppIrp);

    }
    else
    {

        // not enough data in the indicate buffer yet
        // NOTE: *BytesTaken should be set correctly above...
        // = ToCopy + ToCopy1;

        PUSH_LOCATION(0x11);
        IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:Not Enough data indicated(INDICBUFF state), Indicated = %X,PduSize= %X,InIndic=%X\n",
                BytesIndicated, PduSize, pLowerConn->BytesInIndicate));


        status = STATUS_SUCCESS;
    }
    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
PartialRcv(
    IN  PVOID                ReceiveEventContext,
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  USHORT               ReceiveFlags,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an session packet arrives from the network. It calls
    a non OS specific routine to decide what to do.  That routine passes back
    either a RcvElement (buffer) or a client rcv handler to call.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    tCONNECTELE     *pConnectEle;
    //
    // the data for the client may be in the indicate buffer and
    // in this case the transport could indicate us with more data. Therefore
    // track the number of bytes available in the transport which
    // we will get when the client finally posts a buffer.
    // This state could also happen on a zero length Rcv when the
    // client does not accept the data, and later posts a rcv
    // buffer for the zero length rcv.
    //
    INCR_COUNT(R4);
    PUSH_LOCATION(0x13);
    ASSERT(pLowerConn->StateRcv == PARTIAL_RCV);
    pConnectEle = pLowerConn->pUpperConnection;

//    ASSERT(pConnectEle->BytesInXport == 0);
#if DBG
    if (pConnectEle->BytesInXport != 0)
    {
        KdPrint(("Nbt.PartialRcv: pConnectEle->BytesInXport != 0 Avail %X, InIndicate=%X,InXport %X %X\n",
                    BytesAvailable,pLowerConn->BytesInIndicate,
                    pConnectEle->BytesInXport,pLowerConn));
    }
#endif  // DBG
    pConnectEle->BytesInXport = BytesAvailable;

    IF_DBG(NBT_DEBUG_NAMESRV)
    KdPrint(("Nbt:Got Indicated while in PartialRcv state Avail %X, InIndicate=%X,InXport %X %X\n",
                BytesAvailable,pLowerConn->BytesInIndicate,
                pConnectEle->BytesInXport,pLowerConn));

    *BytesTaken = 0;
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
TdiReceiveHandler (
    IN  PVOID                ReceiveEventContext,
    IN  PVOID                ConnectionContext,
    IN  USHORT               ReceiveFlags,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PIRP                 *ppIrp
    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an session packet arrives from the network. It calls
    a non OS specific routine to decide what to do.  That routine passes back
    either a RcvElement (buffer) or a client rcv handler to call.

Arguments:

    IN PVOID ReceiveEventContext - Context provided for this event when event set
    IN PVOID ConnectionContext  - Connection Context, (pLowerConnection)
    IN USHORT ReceiveFlags      - Flags describing the message
    IN ULONG BytesIndicated     - Number of bytes available at indication time
    IN ULONG BytesAvailable     - Number of bytes available to receive
    OUT PULONG BytesTaken       - Number of bytes consumed by redirector.
    IN PVOID pTsdu              - Data from remote machine.
    OUT PIRP *ppIrp             - I/O request packet filled in if received data


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    register tLOWERCONNECTION    *pLowerConn;
    PIRP                pIrp;
    CTELockHandle       OldIrq;
    NTSTATUS            status;
    tCONNECTELE         *pConnEle;
    ULONG               BTaken;

    *ppIrp = NULL;
    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;

    // NOTE:
    // Access is synchronized through the spin lock on pLowerConn for all
    // Session related stuff.  This includes the case where the client
    // posts another Rcv Buffer in NTReceive. - so there is no need to get the
    // pConnEle Spin lock too.
    //

    CTESpinLock(pLowerConn,OldIrq);
//    pLowerConn->InRcvHandler = TRUE;
    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER);

    // save this on the stack in case we need to dereference it below.
    pConnEle = pLowerConn->pUpperConnection;

    // call the correct routine depending on the state of the connection
    // Normal/FillIrp/PartialRcv/IndicateBuffer/Inbound/OutBound
    //

    if ((pLowerConn->State == NBT_SESSION_UP) &&
        (pLowerConn->StateRcv == FILL_IRP))
    {
        PIO_STACK_LOCATION              pIrpSp;
        PMDL                            pNewMdl;
        PFILE_OBJECT                    pFileObject;
        ULONG                           RemainingPdu;
        PVOID                           NewAddress;
        PTDI_REQUEST_KERNEL_RECEIVE     pClientParams;
        PTDI_REQUEST_KERNEL_RECEIVE     pParams;
        KIRQL                           OldIrq2;
        ULONG                           RcvLength;


        PUSH_LOCATION(0xa);

        pIrp = pConnEle->pIrpRcv;

        if (!pIrp)
        {
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint (("Nbt:TdiReceiveHandler:  No pIrpRcv for pConnEle=<%x>, pLowerConn=<%d>\n",
                    pConnEle, pLowerConn));
            *BytesTaken = 0;
            DerefLowerConnFast(pLowerConn,OldIrq);
            return (STATUS_SUCCESS);
        }

        // we are still waiting for the rest of the session pdu so
        // do not call the RcvHandlrNotOs, since we already have the buffer
        // to put this data in.
        // too much data may have arrived... i.e. part of the next session pdu..
        // so check and set the receive length accordingly
        //

        RemainingPdu = pConnEle->TotalPcktLen - pConnEle->BytesRcvd;
        RcvLength = RemainingPdu;
        //
        // try high runner case first
        //
        if (BytesAvailable <= RemainingPdu)
        {
            PUSH_LOCATION(0xb);
            //
            //  if the client buffer is too small to take all of the rest of the
            //  data, shorten the receive length and keep track of how many
            //  bytes are left in the transport. ReceiveIndicated should have
            //  been set when the irp was passed down originally.
            //
            if (BytesAvailable > pConnEle->FreeBytesInMdl)
            {
                PUSH_LOCATION(0xb);

                RcvLength = pConnEle->FreeBytesInMdl;
                pConnEle->BytesInXport = BytesAvailable - RcvLength;
            }
            if (RcvLength > pConnEle->FreeBytesInMdl) {
                ASSERT(BytesAvailable <= pConnEle->FreeBytesInMdl);
                RcvLength = pConnEle->FreeBytesInMdl;
                pConnEle->BytesInXport = 0;
            }
        }
        else
        {
            //
            // start of session pdu in the middle of the indication
            //
            PUSH_LOCATION(0xc);
            //
            // It is possible that the client buffer is too short, so check
            // for that case.
            //
            if (RemainingPdu > pConnEle->FreeBytesInMdl)
            {
                RcvLength = pConnEle->FreeBytesInMdl;
                PUSH_LOCATION(0xd);
            }
            /* Remember how much data is left in the transport
             when this irp passes through the completionrcv routine
             it will pass the indication buffer back to the transport
             to get at least 4 bytes of header information so we
             can determine the next session pdu's size before receiving
             it.  The trick is to avoid having more than one session
             pdu in the buffer at once.
            */
            pConnEle->BytesInXport = BytesAvailable - RcvLength;

            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:End of FILL_IRP, found new Pdu BytesInXport=%X\n",
                        pConnEle->BytesInXport));

        }

        // if the transport has all of the data it says is available, then
        // do the copy here ( if the client buffer is large enough - checked
        // by !ReceiveIndicated)
        //
        if ((BytesAvailable == BytesIndicated) &&
            (RcvLength >= BytesIndicated) &&
            !pConnEle->ReceiveIndicated)
        {
            ULONG   BytesCopied;
            ULONG   TotalBytes;

            PUSH_LOCATION(0x70);

            if (RcvLength > BytesIndicated)
                RcvLength = BytesIndicated;

            status = TdiCopyBufferToMdl(
                                    pTsdu,
                                    0,
                                    RcvLength,
                                    pConnEle->pNextMdl,
                                    pConnEle->OffsetFromStart,
                                    &BytesCopied);

            //
            // if the irp is not yet full, or the free bytes have not
            // been exhausted by this copy, then adjust some counts and return
            // quickly, otherwise call the completion rcv routine as if the
            // irp has completed normally from the transport -
            //
            TotalBytes = pConnEle->BytesRcvd + BytesCopied;

            if ((TotalBytes < pConnEle->TotalPcktLen) &&
                (BytesCopied < pConnEle->FreeBytesInMdl))
            {
                PMDL    pMdl;

                //
                // take the short cut and do not call completion rcv since we
                // are still waiting for more data
                //
                PUSH_LOCATION(0x81);
                pConnEle->BytesRcvd      += BytesCopied;
                pConnEle->FreeBytesInMdl -= BytesCopied;

                // clean up the partial mdl.
                //
                pMdl = pConnEle->pNewMdl;
                MmPrepareMdlForReuse(pMdl);

                // set where the next rcvd data will start, by setting the pNextMdl and
                // offset from start.
                //
                pMdl = pConnEle->pNextMdl;
                if ((BytesCopied + pConnEle->OffsetFromStart) < MmGetMdlByteCount(pMdl))
                {
                    PUSH_LOCATION(0x82);
                    //
                    // All of this data will fit into the current Mdl, and
                    // the next data will start in the same Mdl (if there is more data)
                    //
                    pConnEle->OffsetFromStart  += BytesCopied;
                }
                else
                {
                    PUSH_LOCATION(0x83)
                    SumMdlLengths(pMdl,
                                  pConnEle->OffsetFromStart + BytesCopied,
                                  pConnEle);
                }
                *BytesTaken = BytesCopied;
                status = STATUS_SUCCESS;

                IF_DBG(NBT_DEBUG_FASTPATH)
                KdPrint(("I"));
                goto ExitRoutine;
            }
            else
            {
                IF_DBG(NBT_DEBUG_FASTPATH)
                KdPrint(("i"));
                CTESpinFree(pLowerConn,OldIrq);
                //
                // the values are set to this so that when Completion Rcv is
                // called it will increment the BytesRcvd by BytesCopied.
                //
                pIrp->IoStatus.Status = STATUS_SUCCESS;
                pIrp->IoStatus.Information = BytesCopied;

                //
                //   now call the irp completion routine, shorting out the io
                //   subsystem - to process the irp
                //
                status = CompletionRcv(NULL,pIrp,(PVOID)pLowerConn);
                //
                // complete the irp back to the client if required
                //
                if (status != STATUS_MORE_PROCESSING_REQUIRED)
                {
                    IoAcquireCancelSpinLock(&OldIrq2);
                    IoSetCancelRoutine(pIrp,NULL);
                    IoReleaseCancelSpinLock(OldIrq2);

                    IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);
                }
            }

            //
            // tell the transport we took all the data that we did take.
            // Since CompletionRcv has unlocked the spin lock and decremented
            // the refcount, return here.
            //
            *BytesTaken = BytesCopied;
            return(STATUS_SUCCESS);
        }
        else
        {
            //
            // Either BytesIndicated != BytesAvailable or the RcvBuffer
            // is too short, so make up an Irp with a partial Mdl and pass it
            // to the transport.
            //
            PUSH_LOCATION(0x71);

            NewAddress = (PVOID)((PCHAR)MmGetMdlVirtualAddress(pConnEle->pNextMdl)
                                + pConnEle->OffsetFromStart);

            /* create a partial MDL so that the new data is copied after the existing data
             in the MDL.  Use the pNextMdl field stored in the pConnEle
             that was set up during the last receive.( since at that time
             we knew the BytesAvailable then).  Without this we would have to
             traverse the list of Mdls for each receive.

             0 for length means map the rest of the buffer
            */
            pNewMdl = pConnEle->pNewMdl;

            if ((MmGetMdlByteCount(pConnEle->pNextMdl) - pConnEle->OffsetFromStart) > MAXUSHORT)
            {
                IoBuildPartialMdl(pConnEle->pNextMdl,pNewMdl,NewAddress,MAXUSHORT);
            }
            else
            {
                IoBuildPartialMdl(pConnEle->pNextMdl,pNewMdl,NewAddress,0);
            }
            //
            // hook the new partial mdl to the front of the MDL chain
            //
            pNewMdl->Next = pConnEle->pNextMdl->Next;

            pIrp->MdlAddress = pNewMdl;
            ASSERT(pNewMdl);

            CHECK_PTR(pConnEle);
            pConnEle->pIrpRcv = NULL;

            IoAcquireCancelSpinLock(&OldIrq2);
            IoSetCancelRoutine(pIrp,NULL);
            IoReleaseCancelSpinLock(OldIrq2);

            pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

            pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;

            /* this code is sped up somewhat by expanding the code here rather than calling
             the TdiBuildReceive macro

             make the next stack location the current one.  Normally IoCallDriver
             would do this but we are not going through IoCallDriver here, since the
             Irp is just passed back with RcvIndication.
            */
            ASSERT(pIrp->CurrentLocation > 1);
            IoSetNextIrpStackLocation(pIrp);
            pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
            pParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;
            pParams->ReceiveLength = RcvLength;

            pIrpSp->CompletionRoutine = CompletionRcv;
            pIrpSp->Context = (PVOID)pLowerConn;

            /* set flags so the completion routine is always invoked.
            */
            pIrpSp->Control = SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL;
            pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            pIrpSp->MinorFunction = TDI_RECEIVE;

            pFileObject = pLowerConn->pFileObject;
            ASSERT (pFileObject->Type == IO_TYPE_FILE);
            pIrpSp->FileObject = pFileObject;
            pIrpSp->DeviceObject = IoGetRelatedDeviceObject(pFileObject);

            pParams->ReceiveFlags = pClientParams->ReceiveFlags;

            /*
              pass the Irp back to the transport
            */
            *ppIrp = (PVOID)pIrp;
            *BytesTaken = 0;

            status = STATUS_MORE_PROCESSING_REQUIRED;
        }
    }
    else
    if ((pLowerConn->State == NBT_SESSION_UP) &&
        (pLowerConn->StateRcv == NORMAL))
    {
        ULONG               PduSize;
        UCHAR               Passit;

        INCR_COUNT(R1);
        /*
         check indication and if less than 1 pdu or 132 bytes then
         copy to the indicate buffer and go to Indic_buffer state
         The while loop allows us to indicate multiple Pdus to the
         client in the event that several indications arrive in one
         indication from the transport
         NOTE:
         It is possible to get an indication that occurs in the middle
         of the pdu if the client took the first indication rather
         than passing an irp back, and thence going to the FILL_IRP
         state. So check if BytesRcvd is zero, meaning that we are
         expecting a new PDU.
        */
        ASSERT(pConnEle->BytesInXport == 0);
        ASSERT(pLowerConn->StateRcv == NORMAL);

        if (pConnEle->BytesRcvd == 0)
        {
            if (BytesIndicated >= sizeof(tSESSIONHDR))
            {
                PduSize = myntohl(((tSESSIONHDR UNALIGNED *)pTsdu)->UlongLength)
                                          + sizeof(tSESSIONHDR);
                Passit = FALSE;

            }
            else
            {
                status = LessThan4BytesRcvd(pLowerConn,
                                            BytesAvailable,
                                            BytesTaken,
                                            ppIrp);
                goto ExitRoutine;
            }

        }
        else
        {
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Got rest of PDU in indication BytesInd %X, BytesAvail %X\n",
                BytesIndicated, BytesAvailable));

            /* This is the remaining pdu size
            */
            PduSize = pConnEle->TotalPcktLen - pConnEle->BytesRcvd;
            /* a flag to pass the if below, since we are passing the
             remaining data of a pdu to the client and we do not have
             to adhere to the 128 bytes restriction.
            */
            PUSH_LOCATION(0x1);
            if (pConnEle->JunkMsgFlag)
            {
                //
                // in this case the client has indicated that it took the
                // entire message on the previous indication, so don't
                // indicate any more to it.
                //
                PUSH_LOCATION(0x1);

                if (BytesAvailable < PduSize)
                {
                    BTaken = BytesAvailable;
                }
                else
                {
                    BTaken = PduSize;
                }
                pConnEle->BytesRcvd += BTaken;
                if (pConnEle->BytesRcvd == pConnEle->TotalPcktLen)
                {
                    PUSH_LOCATION(0x1);
                    pConnEle->BytesRcvd = 0; // reset for the next session pdu
                    pConnEle->JunkMsgFlag = FALSE;
                }
                status = STATUS_SUCCESS;
                goto SkipIndication;
            }
            Passit = TRUE;

        }
        /*
         be sure that there is at least 132 bytes or a whole pdu
         Since a keep alive has a zero length byte, we check for
         that because the 4 byte session hdr is added to the 0 length
         giving 4, so a 4 byte Keep Alive pdu will pass this test.
        */
        if ((BytesIndicated >= NBT_INDICATE_BUFFER_SIZE) ||
            (BytesIndicated >= PduSize) || Passit )
        {

            PUSH_LOCATION(0x2);

            /*
            // Indicate to the client
            */
            status = RcvHandlrNotOs(
                            ReceiveEventContext,
                            (PVOID)pLowerConn,
                            ReceiveFlags,
                            BytesIndicated,
                            BytesAvailable,
                            &BTaken,
                            pTsdu,
                            (PVOID)&pIrp
                            );

            if (status == STATUS_MORE_PROCESSING_REQUIRED)
            {
                ULONG               RemainingPdu;
                PIO_STACK_LOCATION  pIrpSp;
                PTDI_REQUEST_KERNEL_RECEIVE pClientParams;

                ASSERT(BTaken <= BytesIndicated);

                RemainingPdu = pConnEle->TotalPcktLen - pConnEle->BytesRcvd;
                pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
                pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;

                // check if we can copy to the client's irp directly - meaning
                // that we have received the whole pdu in this indication and
                // the client's buffer is large enough, and there is no more
                // data in the transport.
                //

                if ((RemainingPdu == (BytesIndicated - BTaken)) &&
                    (BytesIndicated == BytesAvailable) &&
                    (pClientParams->ReceiveLength >= RemainingPdu) &&
                    pIrp->MdlAddress)
                {
                    ULONG   BytesCopied;

                    PUSH_LOCATION(0x88);

                    status = TdiCopyBufferToMdl(
                                            (PVOID)((PUCHAR)pTsdu + BTaken),
                                            0,
                                            RemainingPdu,
                                            pIrp->MdlAddress,
                                            0,
                                            &BytesCopied);

                    IF_DBG(NBT_DEBUG_INDICATEBUFF)
                    KdPrint(("Nbt:Copy to client Buffer RcvLen=%X,StateRcv=%X\n",
                                RemainingPdu,pLowerConn->StateRcv));

                    pIrp->IoStatus.Information = BytesCopied;
                    pIrp->IoStatus.Status = STATUS_SUCCESS;

                    // reset a few things since this pdu has been fully recv'd
                    //
                    CHECK_PTR(pConnEle);
                    pConnEle->BytesRcvd = 0;
                    CHECK_PTR(pConnEle);
                    pConnEle->pIrpRcv = NULL;

                    //
                    //   tell the transport we took all the data that we did take.
                    //
                    *BytesTaken = BytesCopied + BTaken;

                    //
                    // complete the irp back to the client if required
                    //
                    IF_DBG(NBT_DEBUG_FASTPATH)
                    KdPrint(("F"));

                    IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

                    pLowerConn->BytesRcvd += BytesCopied;

                    DerefLowerConnFast(pLowerConn,OldIrq);
                    return(STATUS_SUCCESS);
                }
                else
                {
                    PUSH_LOCATION(0x3);

                    status = ProcessIrp(pLowerConn,
                                        pIrp,
                                        pTsdu,
                                        &BTaken,
                                        BytesIndicated,
                                        BytesAvailable);

                    *BytesTaken = BTaken;
                    ASSERT(*BytesTaken <= (pConnEle->TotalPcktLen + sizeof(tSESSIONHDR)) );
                    if (status == STATUS_RECEIVE_EXPEDITED)
                    {
                        // in this case the processirp routine has completed the
                        // irp, so just return since the completion routine will
                        // have adjusted the RefCount and InRcvHandler flag
                        //
                        *ppIrp = NULL;
                        CTESpinFree(pLowerConn,OldIrq);
                        return(STATUS_SUCCESS);
                    }
                    else
                    if (status == STATUS_SUCCESS)
                    {
                        *ppIrp = NULL;

                    }
                    else
                    {
                        *ppIrp = (PVOID)pIrp;
                    }
                }


             }
             else
             {
                // for the skip indication case the client has told us it
                // does not want to be indicated with any more of the data
                //
SkipIndication:
                //
                // the client received some, all or none of the data
                // For Keep Alives the PduSize is 4 and BytesTaken = 4
                // so this check and return status success
                //
                *BytesTaken = BTaken;

                pLowerConn->BytesRcvd += BTaken - sizeof(tSESSIONHDR);

                //
                // if the connection has disonnected, then just return
                //
                if (!pLowerConn->pUpperConnection)
                {
                    *BytesTaken = BytesAvailable;
                    status = STATUS_SUCCESS;
                }
                else
                if (BTaken > BytesAvailable)
                {
                    //
                    // in this case the client has taken all of the message
                    // which could be larger than the available because
                    // we set bytesavail to the message length. So set a flag
                    // that tells us to discard the rest of the message as
                    // it comes in.
                    //
                    pConnEle->JunkMsgFlag = TRUE;
                    pConnEle->BytesRcvd = BytesAvailable - sizeof(tSESSIONHDR);
                    *BytesTaken = BytesAvailable;

                }
                else
                if (pLowerConn->StateRcv == PARTIAL_RCV)
                {
                    // this may be a zero length send -that the client has
                    // decided not to accept.  If so then the state will be set
                    // to PartialRcv.  In this case do NOT go down to the transport
                    // and get the rest of the data, but wait for the client
                    // to post a rcv buffer.
                    //

                    // amount left in the transport...
                    pConnEle->BytesInXport = BytesAvailable - BTaken;
                    status = STATUS_SUCCESS;
                }
                else
                if (BTaken == PduSize)
                {
                    /*
                     Must have taken all of the pdu data, so check for
                     more data available - if so send down the indicate
                     buffer to get it.
                    */
                    ASSERT(BTaken <= BytesIndicated);
                    if (BytesAvailable <= BTaken)
                    {
                        /* FAST PATH
                        */
                        PUSH_LOCATION(0x8);

                        status = STATUS_SUCCESS;

                    }
                    else
                    {
                        /*
                         get remaining data with the indicate buffer
                        */
                        status = MoreDataRcvdThanNeeded(pLowerConn,
                                                        BytesIndicated,
                                                        BytesAvailable,
                                                        BytesTaken,
                                                        pTsdu,
                                                        ppIrp);
                    }
                }
                else
                {
                    //
                    // the client may have taken all the data in the
                    // indication!!, in which case return status success
                    // Note: that we check bytes available here not bytes
                    // indicated - since the client could take all indicated
                    // data but still leave data in the transport.
                    //
                    if (BTaken == BytesAvailable)
                    {
                        PUSH_LOCATION(0x4);
                        status = STATUS_SUCCESS;

                    }
                    else
                    {
                        PUSH_LOCATION(0x87);
                        if (BTaken > PduSize)
                        {
#ifndef VXD
#if DBG
                        DbgBreakPoint();
#endif
#endif
                            //
                            // the client took more than a PDU size worth,
                            // which is odd....
                            //
                            PUSH_LOCATION(0x87);
                            ASSERT(BTaken <= PduSize);

                            CTESpinFreeAtDpc(pLowerConn);
                            OutOfRsrcKill(pLowerConn);
                            CTESpinLockAtDpc(pLowerConn);

                            status = STATUS_SUCCESS;

                        }
                        else
                        {
                            //
                            // otherwise the client did not take all of the data,
                            // which can mean that
                            // the client did not take all that it could, so
                            // go to the partial rcv state to keep track of it.
                            //
                            status = ClientTookSomeOfTheData(pLowerConn,
                                                    BytesIndicated,
                                                    BytesAvailable,
                                                    *BytesTaken,
                                                    PduSize);
                        }
                    }
                }

             }

        }
        else
        {
            status = NotEnoughDataYet(pLowerConn,
                             BytesIndicated,
                             BytesAvailable,
                             BytesTaken,
                             PduSize,
                             (PVOID *)ppIrp);
        }
    }
    else
    {
        status = (*pLowerConn->CurrentStateProc)(ReceiveEventContext,
                                         pLowerConn,
                                         ReceiveFlags,
                                         BytesIndicated,
                                         BytesAvailable,
                                         BytesTaken,
                                         pTsdu,
                                         ppIrp);
    }

    //
    // in the IndicateBuffer state we have sent the indicate buffer
    // down the the transport and expect it to come back in
    // NewSessionCompletionRoutine. Therefore do not dereference the lower
    // connection and do not change the InRcvHandler flag.

    // If an Irp
    // is returned, then do not undo the reference - but rather
    // wait for CompletionRcv to be called.
    //
ExitRoutine:
    if (status != STATUS_MORE_PROCESSING_REQUIRED)
    {
        //
        // quickly check if we can just decrement the ref count without calling
        // NBT_DEREFERENCE_LOWERCONN
        //
        PUSH_LOCATION(0x50);
        DerefLowerConnFast (pLowerConn, OldIrq);
    }
    else
    {
        CTESpinFree(pLowerConn,OldIrq);
    }

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
ProcessIrp(
    IN tLOWERCONNECTION *pLowerConn,
    IN PIRP     pIrp,
    IN PVOID    pBuffer,
    IN PULONG   BytesTaken,
    IN ULONG    BytesIndicated,
    IN ULONG    BytesAvailable
    )
/*++

Routine Description:

    This routine handles a Receive Irp that the client has returned on an
    indication.  The idea here is to check the Irp's MDL length to be
    sure the pdu fits into the MDL, and also keep track of the situation where
    more than one data is required to fill the pdu.

Arguments:


Return Value:

    The final status from the operation (success or an exception).

--*/
{
    NTSTATUS                    status;
    PTDI_REQUEST_KERNEL_RECEIVE pParams;
    PIO_STACK_LOCATION          pIrpSp;
    tCONNECTELE                 *pConnectEle;
    PTDI_REQUEST_KERNEL_RECEIVE pClientParams;
    ULONG                       RemainingPdu;
    PMDL                        pMdl;
    PFILE_OBJECT                pFileObject;
    ULONG                       ReceiveLength;
    BOOLEAN                     QuickRoute;
    BOOLEAN                     FromCopyData;

    pConnectEle = pLowerConn->pUpperConnection;

    status = STATUS_SUCCESS;

    // subtract session header and any bytes that the client took
    //
    BytesAvailable -= *BytesTaken;

    //
    // put together an Irp stack location to process the receive and pass down
    // to the transport.
    //
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;

    //
    // check if this will be a multiple rcv session pdu.  If it is then
    // allocate a partial MDL to be used for mapping part of the first
    // MDL in each chunk received
    //
    RemainingPdu = pConnectEle->TotalPcktLen - pConnectEle->BytesRcvd;
    ReceiveLength = RemainingPdu;
    PUSH_LOCATION(0x19);
    pIrpSp = IoGetNextIrpStackLocation(pIrp);

    // this code should not be hit if called by CopyDataandIndicate
    // which is in the indicate buffer state since it adjusts the bytesInXport
    // which is also set by the code in TdiReceiveHndlr in the INDICATE_BUFFER
    // state before calling CopyDataandIndicate.  Also, CopyDataandIndicate
    // does not want this routine to set the state to fillIrp when Bytes
    // Available < RemainingPdu
    //
    FromCopyData = (pLowerConn->StateRcv == INDICATE_BUFFER);
    if (!FromCopyData)
    {

        QuickRoute = TRUE;
        // we need this code within the check since this routine is also called by the
        // HandleNewSessionPdu routine, which calls IoCallDriver, which
        // increments the stack location itself.
        //
        ASSERT(pIrp->CurrentLocation > 1);

        if (BytesAvailable == RemainingPdu)
        {
            if (pClientParams->ReceiveLength >= BytesAvailable)
            {
                // *** FAST PATH CASE ****
                goto ExitCode;
            }
        }
        else
        if (BytesAvailable < RemainingPdu ) // need more data from transport
        {
            PUSH_LOCATION(0x14);
            // it is possible for the client to pass down an irp with no
            // MDL in it, so we check for that here
            //
            if (pIrp->MdlAddress)
            {
                PUSH_LOCATION(0x14);

                //
                // save the client's irp address since the session pdu will arrive
                // in several chunks, and we need to continually pass the irp to the
                // transport for each chunk.
                //
                //pConnectEle->pIrpRcv = pIrp;
                // NOTE: the pIrp is NOT saved here because the irp is about
                // to be passed back to the transport.  Hence we do not want
                // to accidently complete it in DisconnectHandlrNotOs
                // if a disconnect comes in while the irp is in the transport.
                // pIrpRcv is set to pIrp in Completion Rcv while we have
                // the irp in our possession.

                //
                // keep the initial Mdl(chain) since we need to
                // to copy new data after the existing data, when the session pdu arrives
                // as several chunks from TCP. Keeping the Mdl around allows us to
                // reconstruct the original Mdl chain when we are all done.
                //
                pLowerConn->pMdl = pIrp->MdlAddress;
                //
                // this call maps the client's Mdl so that on each partial Mdl creation
                // we don't go through  a mapping and unmapping (when MmPrepareMdlForReuse)
                // is called in the completion routine.
                //
                (PVOID)MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority);

                pMdl = pIrp->MdlAddress;

                // the nextmdl is setup to allow us to create a partial Mdl starting
                // from the next one.  CompletionRcv will adjust this if it needs to.
                //
                pConnectEle->pNextMdl = pMdl;

                // need more data from the transport to fill this
                // irp
                //
                CHECK_PTR(pConnectEle);
                pConnectEle->pIrpRcv = NULL;
                SET_STATERCV_LOWER(pLowerConn, FILL_IRP, FillIrp);
            }

            status = STATUS_MORE_PROCESSING_REQUIRED;

            // if the client buffer is big enough, increment to the next
            // io stack location and jump to the code that sets up the
            // irp, since we always want to pass it to the transport in this
            // case because the transport will hold onto the irp till it is full
            // if it can. (faster)
            //
            if (pClientParams->ReceiveLength >= RemainingPdu)
            {
                // *** FAST PATH CASE ****
                IoSetNextIrpStackLocation(pIrp);
                pConnectEle->FreeBytesInMdl = ReceiveLength;
                pConnectEle->CurrentRcvLen  = RemainingPdu;
                goto ExitCode2;
            }

            //
            // if there is no mdl then we want to be able to go through the
            // quick route below to return the null mdl right away, so
            // don't set Quickroute false here.
            //


        }
        else
        if (BytesAvailable > RemainingPdu)
        {
            PUSH_LOCATION(0x15);
            //
            // there is too much data, so keep track of the
            // fact that there is data left in the transport
            // and get it when the irp completes through
            // completion recv.
            //
            SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, IndicateBuffer);

            // this calculation may have to be adjusted below if the client's
            // buffer is too short. NOTE: BytesTaken have already been subtracted
            // from BytesAvailable (above).
            //
            pConnectEle->BytesInXport = BytesAvailable - RemainingPdu;

            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Switching to Indicate Buff(Irp), Indic = %X, Pdusize=%X\n",
                    BytesIndicated,pConnectEle->TotalPcktLen));


            status = STATUS_DATA_NOT_ACCEPTED;
        }

        // DEBUG*
        //IoSetNextIrpStackLocation(pIrp);
    }
    else
    {
        QuickRoute = FALSE;
    }

    //
    // if the receive buffer is too short then flag it so when the client
    // passes another buffer to NBT, nbt will pass it to the transport
    //
    //if (BytesAvailable > pClientParams->ReceiveLength )
    {

        // so just check for too short of a client buffer.
        //
        if (RemainingPdu > pClientParams->ReceiveLength)
        {
            PUSH_LOCATION(0x17);

            ReceiveLength = pClientParams->ReceiveLength;
            //
            // Adjust the number of bytes left in the transport up by the number of
            // bytes not taken by the client.  Be sure not to add in the number
            // of bytes in the transport twice, since it could have been done
            // above where the state is set to INDICATE_BUFFER
            //
            if (status == STATUS_DATA_NOT_ACCEPTED)
            {
                // BytesInXport was already incremented to account for any
                // amount over remainingPdu, so just add the amount that the
                // client buffer is short of RemainingPdu
                //
                PUSH_LOCATION(0x18);
                if (BytesAvailable > ReceiveLength )
                {
                    pConnectEle->BytesInXport += (RemainingPdu - ReceiveLength);
                }
                // the client has not taken all of the data , but has returned
                // a buffer that is ReceiveLength long, therefore the amount
                // that the client needs to take is just the total pdu - rcvlength.
                //
                pConnectEle->ReceiveIndicated = (RemainingPdu - ReceiveLength);
            }
            else
            {
                //
                // BytesInXport has not been incremented yet so add the entire
                // amount that the client buffer is too short by. Check if
                // the client's buffer will take all of the data.
                //
                if (BytesAvailable > ReceiveLength )
                {
                    pConnectEle->BytesInXport += (BytesAvailable - ReceiveLength);
                }
                // the client has not taken all of the data , but has returned
                // a buffer that is ReceiveLength long, therefore the amount
                // that the client needs to take is just what was indicated
                // to the client - recvlength.
                //
                pConnectEle->ReceiveIndicated = (RemainingPdu - ReceiveLength);
            }


            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Switching to PartialRcv for Irp. RecvInd. =%X, RemainPdu %X Avail %X\n",
                    pConnectEle->ReceiveIndicated,RemainingPdu,BytesAvailable));
        }

    }

ExitCode:

    // keep track of data in MDL so we know when it is full and we need to
    // return it to the user. CurrentRcvLen tells us how many bytes the current
    // Irp can have max when the Mdl is full.
    //
    pConnectEle->FreeBytesInMdl = ReceiveLength;
    pConnectEle->CurrentRcvLen  = ReceiveLength;
    if (ReceiveLength > RemainingPdu)
    {
        pConnectEle->CurrentRcvLen  = RemainingPdu;
    }
    if (QuickRoute)
    {
        //
        // check if we can copy the data  to the client's MDL
        // right here. If the indication is too short pass an Irp down
        // to the transport.
        //
        BytesIndicated -= *BytesTaken;

        if ((ReceiveLength <= BytesIndicated))
        {
            ULONG   BytesCopied;

            PUSH_LOCATION(0x76);

            if (pIrp->MdlAddress)
            {

                status = TdiCopyBufferToMdl(
                                        (PVOID)((PUCHAR)pBuffer + *BytesTaken),
                                        0,
                                        ReceiveLength,
                                        pIrp->MdlAddress,
                                        0,
                                        &BytesCopied);

            }
            else
            {
                //
                // No Mdl, so just return the irp to the client, and then
                // return success to the caller so we tell the transport that
                // we took only BytesTaken
                //
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Nbt:No MDL, so complete Irp\n"));


                PUSH_LOCATION(0x77);
                BytesCopied = 0;
            }

            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Copy to client Buffer RcvLen=%X,StateRcv=%X\n",
                        ReceiveLength,pLowerConn->StateRcv));

            pIrp->IoStatus.Information = BytesCopied;
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            //
            //   now call the irp completion routine, shorting out the io
            //   subsystem - to process the irp
            //
            CTESpinFreeAtDpc(pLowerConn);
            status = CompletionRcv(NULL,pIrp,(PVOID)pLowerConn);

            //
            //   tell the transport we took all the data that we did take.
            //
            *BytesTaken += BytesCopied;

            IF_DBG(NBT_DEBUG_FASTPATH)
            KdPrint(("f"));
            //
            // complete the irp back to the client if required
            //
            if (status != STATUS_MORE_PROCESSING_REQUIRED)
            {
                PUSH_LOCATION(0x76);
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Nbt:Completing Irp Quickly\n"));

                IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

            }

            // since we have called CompletionRcv, that routine has
            // adjusted the refcount and InRcvHandlr flag, so return this
            // status to cause the caller to return directly
            CTESpinLockAtDpc(pLowerConn);
            return(STATUS_RECEIVE_EXPEDITED);

        }
        else
        {
            //
            // make the next stack location the current one.  Normally IoCallDriver
            // would do this but we are not going through IoCallDriver here, since the
            // Irp is just passed back with RcvIndication.
            //
            IoSetNextIrpStackLocation(pIrp);
        }
    }
ExitCode2:
    pIrpSp->CompletionRoutine = CompletionRcv;
    pIrpSp->Context           = (PVOID)pLowerConn;

    // set Control flags so the completion routine is always invoked.
    pIrpSp->Control       = SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL;

    pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pIrpSp->MinorFunction = TDI_RECEIVE;

    pFileObject           = pLowerConn->pFileObject;
    ASSERT (pFileObject->Type == IO_TYPE_FILE);
    pIrpSp->FileObject    = pFileObject;
    pIrpSp->DeviceObject  = IoGetRelatedDeviceObject(pFileObject);

    pParams               = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;
    pParams->ReceiveFlags = pClientParams->ReceiveFlags;

    // Set the correct receive length in the irp in case the client has
    // passed one down that is larger than the message
    //
    pParams->ReceiveLength = ReceiveLength;

    //
    // just check for a zero length send, where the client has
    // passed down an Irp with a null mdl, or the pdu size is zero.  We don't want to pass
    // that to the transport because it will hold onto it till the next
    // pdu comes in from the wire - we want to complete the irp when this routine
    // returns. When this is called from CopyDataAndIndicate don't
    // to this because copydataandindicate does all the checks.
    //
    if (!FromCopyData)
    {
        if ((RemainingPdu == 0) || !pIrp->MdlAddress)
        {
            //
            // the call to IoCompleteRequest will call completionRcv which will
            // decrement the RefCount. Similarly returning status success will
            // cause the caller to decrement the ref count, so increment one
            // more time here to account for this second decrement.
            //
            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER);
            CTESpinFreeAtDpc(pLowerConn);

            IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

            CTESpinLockAtDpc(pLowerConn);

            status = STATUS_SUCCESS;
        }
        else
            status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
ClientBufferOverFlow(
    IN tLOWERCONNECTION     *pLowerConn,
    IN tCONNECTELE          *pConnEle,
    IN PIRP                 pIrp,
    IN ULONG                BytesRcvd
    )
/*++

Routine Description:

    This routine completes the Irp by tracking the number of bytes received

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the pLowerConn - the connection data structure

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    // *TODO*

    ASSERT(0);

    switch (pLowerConn->StateRcv)
    {
        case PARTIAL_RCV:
        case FILL_IRP:
        case NORMAL:
        case INDICATE_BUFFER:
        default:
            ;
    }
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
CompletionRcv(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine completes the Irp by tracking the number of bytes received

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the pLowerConn - the connection data structure

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    register tCONNECTELE        *pConnectEle;
    NTSTATUS                    status;
    ULONG                       BytesRcvd;
    tLOWERCONNECTION            *pLowerConn;
    PKDPC                       pDpc;
    CTELockHandle               OldIrq;
    CTELockHandle               OldIrq2;
    PMDL                        pMdl;
    PIO_STACK_LOCATION          pIrpSp;
    PTDI_REQUEST_KERNEL_RECEIVE pParams;
    BOOLEAN                     AllowDereference=TRUE;

    //
    // Do some checking to keep the Io system happy - propagate the pending
    // bit up the irp stack frame.... if it was set by the driver below then
    // it must be set by me
    //
    if (Irp->PendingReturned)
    {
        IoMarkIrpPending(Irp);
    }

    // check the bytes recvd
    pLowerConn = (tLOWERCONNECTION *)Context;
    //
    // if the link has disconnected, do not process the irp, just pass it
    // up the chain.
    //
    CTESpinLock(pLowerConn,OldIrq);
    if (!NT_SUCCESS(Irp->IoStatus.Status) || !pLowerConn->pUpperConnection)
    {
        PUSH_LOCATION(0x1);
        if (pLowerConn->StateRcv == FILL_IRP)
        {
            PUSH_LOCATION(0x1);
            Irp->MdlAddress = pLowerConn->pMdl;
            ASSERT(Irp->MdlAddress);

        }
        SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, RejectAnyData);
        //
        // the rcv failed so kill the connection since
        // we can't keep track of message boundaries any more.
        //
        CTESpinFree(pLowerConn,OldIrq);
        OutOfRsrcKill(pLowerConn);
        CTESpinLock(pLowerConn,OldIrq);

        status = STATUS_SUCCESS;
        goto ExitCode;
    }

    pConnectEle = pLowerConn->pUpperConnection;

    // keep track of how many bytes have been received
    //
    BytesRcvd = (ULONG)Irp->IoStatus.Information;
    pConnectEle->BytesRcvd += BytesRcvd;
    //
    // subtract the number of bytes rcvd from the length of the client
    // buffer
    // so when more data arrives we can determine if we are going to
    // overflow the client buffer.
    //
    pConnectEle->FreeBytesInMdl -= BytesRcvd;

    pIrpSp = IoGetCurrentIrpStackLocation(Irp);
    pParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;

    pLowerConn->BytesRcvd += BytesRcvd;

    CHECK_PTR(pConnectEle);
    if (Irp->IoStatus.Status == STATUS_BUFFER_OVERFLOW)
    {
        //
        // the client's buffer was too short - probably because he said it
        // was longer than it really was
        //
        PUSH_LOCATION(0x1a);
        KdPrint(("Nbt:Client Buffer Too short on CompletionRcv\n"));

        if (pLowerConn->StateRcv == FILL_IRP)
        {
            PUSH_LOCATION(0x1a);
            Irp->MdlAddress = pLowerConn->pMdl;
            ASSERT(Irp->MdlAddress);
        }
        pConnectEle->BytesRcvd = 0; // reset for the next session pdu
        status = ClientBufferOverFlow(pLowerConn,pConnectEle,Irp,BytesRcvd);

        //
        // the client's buffer was too short so kill the connection since
        // we can't keep track of message boundaries any more.
        //
        SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, RejectAnyData);
        CTESpinFree(pLowerConn,OldIrq);
        OutOfRsrcKill(pLowerConn);
        CTESpinLock(pLowerConn,OldIrq);

        goto ExitCode;
    }
    else if ((pConnectEle->FreeBytesInMdl == 0) ||
       (pConnectEle->BytesRcvd == pConnectEle->TotalPcktLen))
    {
        INCR_COUNT(C1);
    //
    // this case handles when the Irp MDL is full or the whole pdu has been
    // received.
    //

        //
        // reset the MDL fields back to where they were
        // if this was a multi-rcv session pdu
        //
        //
        if (pLowerConn->StateRcv == FILL_IRP)
        {

            INCR_COUNT(C2);
            PUSH_LOCATION(0x1b);

            Irp->MdlAddress = pLowerConn->pMdl;
            ASSERT(Irp->MdlAddress);

            //
            // allow the MDL to be used again for the next session PDU
            //
            pMdl = pConnectEle->pNewMdl;
            MmPrepareMdlForReuse(pMdl);

            pConnectEle->OffsetFromStart  = 0;

        }

        CHECK_PTR(pConnectEle);
        pConnectEle->pIrpRcv = NULL;
        //
        // we have received all of the data
        // so complete back to the client
        //
        status = STATUS_SUCCESS;
        //
        // the amount of data in this irp is the CurrentRcvLen which
        // could be less than BytesRcvd when the client passes down
        // short rcv buffers.
        //
        Irp->IoStatus.Information = pConnectEle->CurrentRcvLen;

        if (pConnectEle->BytesRcvd == pConnectEle->TotalPcktLen)
        {

            pConnectEle->BytesRcvd = 0; // reset for the next session pdu
            Irp->IoStatus.Status = STATUS_SUCCESS;
        }
        else
        {
            PUSH_LOCATION(0x27);
            //
            // this MDL must be too short to take the whole pdu, so set the
            // status to buffer overflow.
            //
            Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

        }

        //
        // The client may have passed down a  too short irp which we are
        // tracking with ReceiveIndicated, so set state to partialrcv if
        // necessary.
        //
        if (pConnectEle->ReceiveIndicated == 0)
        {
            SET_STATERCV_LOWER(pLowerConn, NORMAL, Normal);
        }
        else
        {
            PUSH_LOCATION(0x26);
            //
            // there may still be data left in the transport
            //
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Short Rcv, still data indicated to client\n"));

            SET_STATERCV_LOWER(pLowerConn, PARTIAL_RCV, PartialRcv);
        }

        //
        // Check if there is still more data in the transport or if the client
        // has been indicated with more data and has subsequently posted a rcv
        // which we must get now and pass to the transport.
        //
        if ((pConnectEle->BytesInXport) || (pLowerConn->StateRcv == PARTIAL_RCV))
        {
            INCR_COUNT(C3);
            //
            // send down another
            // irp to get the data and complete the client's current irp.
            //
            PUSH_LOCATION(0x1c);
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:ComplRcv BytesInXport= %X, %X\n",pConnectEle->BytesInXport,
                                pLowerConn));

            if (pLowerConn->StateRcv != PARTIAL_RCV)
            {
                SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, IndicateBuffer);
                pLowerConn->BytesInIndicate = 0;
            }

            CTESpinFree(pLowerConn,OldIrq);

            IoAcquireCancelSpinLock(&OldIrq);
            IoSetCancelRoutine(Irp,NULL);
            IoReleaseCancelSpinLock(OldIrq);

            // Complete the current Irp
            IoCompleteRequest(Irp,IO_NETWORK_INCREMENT);

            CTESpinLock(pLowerConn,OldIrq);

            // rather than call HandleNewSessionPdu directly, we queue a
            // Dpc since streams does not currently expect to get a recv
            // posted while it is processing an indication response.  The
            // Dpc will run when streams is all done, and it should handle
            // this posted receive ok.


            if (pLowerConn->StateRcv == PARTIAL_RCV)
            {
                //
                // check if the client has passed down another rcv buffer
                // and if so, start a Dpc which will pass down the client's
                // buffer.
                //
                if (!IsListEmpty(&pConnectEle->RcvHead))
                {
                    if (pDpc = NbtAllocMem(sizeof(KDPC),NBT_TAG('p')))
                    {
                        KeInitializeDpc(pDpc, DpcGetRestOfIndication, (PVOID)pLowerConn);
                        KeInsertQueueDpc(pDpc,NULL,NULL);
                        //
                        // we don't want to dereference pLowerConn at the end
                        // since we will use it in the DPC routine.
                        //
                        CTESpinFree(pLowerConn,OldIrq);
                        return(STATUS_MORE_PROCESSING_REQUIRED);
                    }
                    else
                    {
                        CTESpinFreeAtDpc(pLowerConn);
                        OutOfRsrcKill(pLowerConn);
                        CTESpinLockAtDpc(pLowerConn);
                    }
                }
            }
            else if (pLowerConn->StateRcv != FILL_IRP)
            {
                if (pDpc = NbtAllocMem(sizeof(KDPC),NBT_TAG('q')))
                {
                    //
                    // just get the session hdr to start with so we know how large
                    // the pdu is, then get the rest of the pdu after that completes.
                    //
                    KeInitializeDpc(pDpc, DpcHandleNewSessionPdu, (PVOID)pLowerConn);
                    KeInsertQueueDpc(pDpc,NULL,(PVOID)sizeof(tSESSIONHDR));
                    //
                    // we don't want to dereference pLowerConn at the end
                    // since we will use it in the DPC routine.
                    //
                    CTESpinFree(pLowerConn,OldIrq);
                    return(STATUS_MORE_PROCESSING_REQUIRED);
                }
                else
                {
                    CTESpinFreeAtDpc(pLowerConn);
                    OutOfRsrcKill(pLowerConn);
                    CTESpinLockAtDpc(pLowerConn);
                }
            }
            else
            {
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                    KdPrint (("Nbt.CompletionRcv: * pLowerConn=<%p>, IP=<%x>\n",
                        pLowerConn, pLowerConn->SrcIpAddr));
            }

            status = STATUS_MORE_PROCESSING_REQUIRED;
            goto ExitCode;
        }
    }
    else if (pConnectEle->BytesRcvd < pConnectEle->TotalPcktLen)
    {
        ULONG   Bytes;

        INCR_COUNT(C4);
        PUSH_LOCATION(0x1d);
        //
        // in this case we have not received all of the data from the transport
        // for this session pdu, so tell the io subystem not to finish processing
        // the irp yet if it is not a partial Rcv.
        //
        status = STATUS_MORE_PROCESSING_REQUIRED;

        // clean up the partial mdl.
        //
        pMdl = pConnectEle->pNewMdl;
        MmPrepareMdlForReuse(pMdl);

        // set where the next rcvd data will start, by setting the pNextMdl and
        // offset from start.
        //
        pMdl = pConnectEle->pNextMdl;
        ASSERT(pMdl);

        Bytes = BytesRcvd + pConnectEle->OffsetFromStart;
        if (Bytes < MmGetMdlByteCount(pMdl))
        {
            PUSH_LOCATION(0x74);
            //
            // All of this data will fit into the current Mdl, and
            // the next data will start in the same Mdl (if there is more data)
            //
            pConnectEle->OffsetFromStart  += BytesRcvd;

            IF_DBG(NBT_DEBUG_FILLIRP)
            KdPrint(("~"));
        }
        else
        {
            //
            // sum the Mdl lengths until we find enough space for the data
            // to fit into.
            //
            IF_DBG(NBT_DEBUG_FILLIRP)
            KdPrint(("^"));
            PUSH_LOCATION(0x75);

            SumMdlLengths(pMdl,Bytes,pConnectEle);

        }

        // since we are holding on to the rcv Irp, set up a cancel routine
        IoAcquireCancelSpinLock(&OldIrq2);

        // if the session was disconnected while the transport had the
        // irp, then cancel the irp now...
        //
        if ((pConnectEle->state != NBT_SESSION_UP) || Irp->Cancel)
        {
            CHECK_PTR(pConnectEle);
            pConnectEle->pIrpRcv = NULL;
            SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, RejectAnyData);

            IoReleaseCancelSpinLock(OldIrq2);
            CTESpinFree(pLowerConn,OldIrq);

            // since the irp has been cancelled, don't touch it.
            // return status success so the IO subsystem passes the irp
            // back to the owner.
            //
            status = STATUS_SUCCESS;

//            Irp->IoStatus.Status = STATUS_CANCELLED;
//            IoCompleteRequest(Irp,IO_NETWORK_INCREMENT);

            // the irp is being cancelled in mid session pdu.  We can't
            // recover since we have given the client only part of a pdu,
            // therefore disconnect the connection.

            OutOfRsrcKill(pLowerConn);

            CTESpinLock(pLowerConn,OldIrq);

        }
        else
        {
            // setup the cancel routine
            IoSetCancelRoutine(Irp, NbtCancelFillIrpRoutine);

            // the pIrpRcv value is set to Zero when the irp is in the
            // tranport, so we can't accidently complete it twice in
            // disconnectHandlrNotOs when a disconnect occurs and the
            // transport has the irp. So here we save the value again so FillIrp
            // will work correctly.
            //
            pConnectEle->pIrpRcv = Irp;
            // set the irp mdl back to its original so that a cancel will
            // find the irp in the right state
            //
            Irp->MdlAddress = pLowerConn->pMdl;

            IoReleaseCancelSpinLock(OldIrq2);

        }
    }
    else
    {
        //IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Too Many Bytes Rcvd!! Rcvd# = %d, TotalLen = %d,NewBytes =%d,%X\n",
                    pConnectEle->BytesRcvd,pConnectEle->TotalPcktLen,
                    Irp->IoStatus.Information,pLowerConn));
        ASSERT(0);
        // this status will return the irp to the user
        //
        status = STATUS_SUCCESS;
        if (pLowerConn->StateRcv == FILL_IRP)
        {

            PUSH_LOCATION(0x1f);

            Irp->MdlAddress = pLowerConn->pMdl;
            Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
            Irp->IoStatus.Information = 0;

            //
            // allow the MDL to be used again for the next session PDU
            //
            pMdl = pConnectEle->pNewMdl;
            MmPrepareMdlForReuse(pMdl);


        }
        pConnectEle->OffsetFromStart  = 0;
        pConnectEle->BytesRcvd = 0;

        SET_STATERCV_LOWER(pLowerConn, NORMAL, pLowerConn->CurrentStateProc);

        //WHAT ELSE TO DO HERE OTHER THAN KILL THE CONNECTION, SINCE WE ARE
        // PROBABLY OFF WITH RESPECT TO THE SESSION HDR....
        // ....RESET THE CONNECTION ????

        CTESpinFree(pLowerConn,OldIrq);

        OutOfRsrcKill(pLowerConn);

        CTESpinLock(pLowerConn,OldIrq);

    }

ExitCode:
    //
    // quickly check if we can just decrement the ref count without calling
    // NBT_DEREFERENCE_LOWERCONN - this function is __inline!!
    //
    PUSH_LOCATION(0x52);
    DerefLowerConnFast (pLowerConn, OldIrq);

    return(status);

    UNREFERENCED_PARAMETER( DeviceObject );
}
//----------------------------------------------------------------------------

__inline
NTSTATUS
RcvHandlrNotOs (
    IN  PVOID               ReceiveEventContext,
    IN  PVOID               ConnectionContext,
    IN  USHORT              ReceiveFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *RcvBuffer

    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an session packet arrives from the network, when the
    session has already been established (NBT_SESSION_UP state). The routine
    looks for a receive buffer first and failing that looks for a receive
    indication handler to pass the message to.

Arguments:

    pClientEle      - ptr to the connecition record for this session


Return Value:

    NTSTATUS - Status of receive operation

--*/
{

    NTSTATUS               status;
    PLIST_ENTRY            pRcv;
    PVOID                  pRcvElement;
    tCLIENTELE             *pClientEle;
    tSESSIONHDR UNALIGNED  *pSessionHdr;
    tLOWERCONNECTION       *pLowerConn;
    tCONNECTELE            *pConnectEle;
    CTELockHandle          OldIrq;
    PIRP                   pIrp;
    ULONG                  ClientBytesTaken;
    BOOLEAN                DebugMore;
    ULONG                  RemainingPdu;
    ULONG uSavedBytesIndicated = BytesIndicated;

//********************************************************************
//********************************************************************
//
//  NOTE: A copy of this procedure is in Tdihndlr.c - it is inlined for
//        the NT case.  Therefore, only change this procedure and then
//        copy the procedure body to Tdihndlr.c
//
//
//********************************************************************
//********************************************************************

    // get the ptr to the lower connection, and from that get the ptr to the
    // upper connection block
    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;
    pSessionHdr = (tSESSIONHDR UNALIGNED *)pTsdu;

    //
    // Session ** UP ** processing
    //
    *BytesTaken = 0;

    pConnectEle = pLowerConn->pUpperConnection;

    ASSERT(pConnectEle->pClientEle);

    ASSERT(BytesIndicated >= sizeof(tSESSIONHDR));

    // this routine can get called by the next part of a large pdu, so that
    // we don't always started at the begining of  a pdu.  The Bytes Rcvd
    // value is set to zero in CompletionRcv when a new pdu is expected
    //
    if (pConnectEle->BytesRcvd == 0)
    {

        if (pSessionHdr->Type == NBT_SESSION_MESSAGE)
        {

            //
            // expecting the start of a new session Pkt, so get the length out
            // of the pTsdu passed in
            //
            pConnectEle->TotalPcktLen = myntohl(pSessionHdr->UlongLength);

            // remove the Session header by adjusting the data pointer
            pTsdu = (PVOID)((PUCHAR)pTsdu + sizeof(tSESSIONHDR));

            // shorten the number of bytes since we have stripped off the
            // session header
            BytesIndicated  -= sizeof(tSESSIONHDR);
            BytesAvailable -= sizeof(tSESSIONHDR);
            *BytesTaken = sizeof(tSESSIONHDR);
        }
        //
        // Session Keep Alive
        //
        else
        if (pSessionHdr->Type == NBT_SESSION_KEEP_ALIVE)
        {
            // session keep alives are simply discarded, since the act of sending
            // a keep alive indicates the session is still alive, otherwise the
            // transport would report an error.

            // tell the transport that we took the Pdu
            *BytesTaken = sizeof(tSESSIONHDR);
            return(STATUS_SUCCESS);

        }
        else
        {
//            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.RcvHandlrNotOs: Unexpected SessionPdu rcvd:type=%X\n",
                    pSessionHdr->Type));

//            ASSERT(0);
            *BytesTaken = BytesIndicated;
            return(STATUS_SUCCESS);
        }
    }

    //
    // check if there are any receive buffers queued against this connection
    //
    if (!IsListEmpty(&pConnectEle->RcvHead))
    {
        // get the first buffer off the receive list
        pRcv = RemoveHeadList(&pConnectEle->RcvHead);
#ifndef VXD
        pRcvElement = CONTAINING_RECORD(pRcv,IRP,Tail.Overlay.ListEntry);

        // the cancel routine was set when this irp was posted to Nbt, so
        // clear it now, since the irp is being passed to the transport
        //
        IoAcquireCancelSpinLock(&OldIrq);
        IoSetCancelRoutine((PIRP)pRcvElement,NULL);
        IoReleaseCancelSpinLock(OldIrq);

#else
        pRcvElement = CONTAINING_RECORD(pRcv, RCV_CONTEXT, ListEntry ) ;
#endif

        //
        // this buffer is actually an Irp, so pass it back to the transport
        // as a return parameter
        //
        *RcvBuffer = pRcvElement;
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    //
    //  No receives on this connection. Is there a receive event handler for this
    //  address?
    //
    pClientEle = pConnectEle->pClientEle;

    //
    // For safe
    //
    if (NULL == pClientEle) {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

#ifdef VXD
    //
    // there is always a receive event handler in the Nt case - it may
    // be the default handler, but it is there, so no need for test.
    //
    if (pClientEle->evReceive)
#endif
    {


        // check that we have not received more data than we should for
        // this session Pdu. i.e. part of the next session pdu. BytesRcvd may
        // have a value other than zero if the pdu has arrived in two chunks
        // and the client has taken the previous one in the indication rather
        // than passing back an Irp.
        //
#if DBG
        DebugMore = FALSE;
#endif
        RemainingPdu = pConnectEle->TotalPcktLen - pConnectEle->BytesRcvd;
        if (BytesAvailable >= RemainingPdu)
        {
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt.RcvHandlrNotOs: More Data Recvd than expecting! Avail= %X,TotalLen= %X,state=%x\n",
                        BytesAvailable,pConnectEle->TotalPcktLen,pLowerConn->StateRcv));
#if DBG
            DebugMore =TRUE;
#endif
            // shorten the indication to the client so that they don't
            // get more data than the end of the pdu
            //
            BytesAvailable = RemainingPdu;
            if (BytesIndicated > BytesAvailable)
            {
                BytesIndicated = BytesAvailable;
            }
            //
            // We always indicated at raised IRQL since we call freelockatdispatch
            // below
            //
            ReceiveFlags |= TDI_RECEIVE_ENTIRE_MESSAGE | TDI_RECEIVE_AT_DISPATCH_LEVEL;
        }
        else
        {
            // the transport may have has this flag on.  We need to
            // turn it off if the entire message is not present, where entire
            // message means within the bytesAvailable length. We deliberately
            // use bytesavailable so that Rdr/Srv can know that the next
            // indication will be a new message if they set bytestaken to
            // bytesavailable.
            //
            ReceiveFlags &= ~TDI_RECEIVE_ENTIRE_MESSAGE;
            ReceiveFlags |= TDI_RECEIVE_AT_DISPATCH_LEVEL;
#ifndef VXD
            BytesAvailable = RemainingPdu;
#endif
        }

        IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt.RcvHandlrNotOs: Calling Client's EventHandler <%x> BytesIndicated=<%x>, BytesAvailable=<%x>\n",
                pClientEle->evReceive, BytesIndicated, BytesAvailable));

        //
        //  NT-specific code locks pLowerConn before calling this routine,
        //
        CTESpinFreeAtDpc(pLowerConn);

        // call the Client Event Handler
        ClientBytesTaken = 0;
        status = (*pClientEle->evReceive)(
                      pClientEle->RcvEvContext,
                      pConnectEle->ConnectContext,
                      ReceiveFlags,
                      BytesIndicated,
                      BytesAvailable,
                      &ClientBytesTaken,
                      pTsdu,
                      &pIrp);
        CTESpinLockAtDpc(pLowerConn);

        IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt.RcvHandlrNotOs: Client's EventHandler returned <%x>, BytesTaken=<%x>, pIrp=<%x>\n",
                status, ClientBytesTaken, pIrp));

#if DBG
        if (DebugMore)
        {
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(( "Nbt.RcvHandlrNotOs: Client TOOK %X bytes, pIrp = %X,status =%X\n",
                   ClientBytesTaken,pIrp,status));
        }
#endif
        if (!pLowerConn->pUpperConnection)
        {
            // the connection was disconnected in the interim
            // so do nothing.
            if (status == STATUS_MORE_PROCESSING_REQUIRED)
            {
                CTEIoComplete(pIrp,STATUS_CANCELLED,0);
                *BytesTaken = BytesAvailable;
                return(STATUS_SUCCESS);
            }
        }
        else
        if (status == STATUS_MORE_PROCESSING_REQUIRED)
        {
            ASSERT(pIrp);
            //
            // the client may pass back a receive in the pIrp.
            // In this case pIrp is a valid receive request Irp
            // and the status is MORE_PROCESSING
            //

            // don't put these lines outside the if incase the client
            // does not set ClientBytesTaken when it returns an error
            // code... we don't want to use the value then
            //
            // count the bytes received so far.  Most of the bytes
            // will be received in the CompletionRcv handler in TdiHndlr.c
            pConnectEle->BytesRcvd += ClientBytesTaken;

            // The client has taken some of the data at least...
            *BytesTaken += ClientBytesTaken;
            ASSERT(*BytesTaken <= uSavedBytesIndicated);

            *RcvBuffer = pIrp;

            // ** FAST PATH **
            return(status);
        }
        else
        //
        // no irp was returned... the client just took some of the bytes..
        //
        if (status == STATUS_SUCCESS)
        {

            // count the bytes received so far.
            pConnectEle->BytesRcvd += ClientBytesTaken;
            *BytesTaken += ClientBytesTaken;

            //
            // In STATUS_SUCCESS case, the client take part of the data or simply set
            // ClientBytesTake to BytesAvailable to tell us that it want to skip to
            // the next message
            //
            ASSERT(ClientBytesTaken <= BytesIndicated || ClientBytesTaken == BytesAvailable);


            //
            // look at how much data was taken and adjust some counts
            //
            if (pConnectEle->BytesRcvd == pConnectEle->TotalPcktLen)
            {
                // ** FAST PATH **
                CHECK_PTR(pConnectEle);
                pConnectEle->BytesRcvd = 0; // reset for the next session pdu
                return(status);
            }
            else
            if (pConnectEle->BytesRcvd > pConnectEle->TotalPcktLen)
            {
                //IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Too Many Bytes Rcvd!! Rcvd# = %d, TotalLen = %d\n",
                            pConnectEle->BytesRcvd,pConnectEle->TotalPcktLen));

                ASSERTMSG("Nbt:Client Took Too Much Data!!!\n",0);

                //
                // try to recover by saying that the client took all of the
                // data so at least the transport is not confused too
                //
                *BytesTaken = uSavedBytesIndicated;

            }
            else
            // the client did not take all of the data so
            // keep track of the fact
            {
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("NBT:Client took Indication BytesRcvd=%X, TotalLen=%X BytesAvail %X ClientTaken %X\n",
                            pConnectEle->BytesRcvd,
                            pConnectEle->TotalPcktLen,
                            BytesAvailable,
                            ClientBytesTaken));

                //
                // the next time the client sends down a receive buffer
                // the code will pass it to the transport and decrement the
                // ReceiveIndicated counter which is set in Tdihndlr.c

            }
        }
        else
        if (status == STATUS_DATA_NOT_ACCEPTED)
        {
            // client has not taken ANY data...
            //
            // In this case the *BytesTaken is set to 4, the session hdr.
            // since we really have taken that data to setup the PduSize
            // in the pConnEle structure.
            //

            IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Nbt.RcvHandlrNotOs: Status DATA NOT ACCEPTED returned from client Avail %X %X\n",
                    BytesAvailable,pConnectEle));

            // the code in tdihndlr.c normally looks after incrementing
            // the ReceiveIndicated count for data that is not taken by
            // the client, but if it is a zero length send that code cannot
            // detect it, so we put code here to handle that case
            //
            // It is possible for the client to do a disconnect after
            // we release the spin lock on pLowerConn to call the Client's
            // disconnect indication.  If that occurs, do not overwrite
            // the StateProc with PartialRcv
            //
            if ((pConnectEle->TotalPcktLen == 0) &&
                (pConnectEle->state == NBT_SESSION_UP))
            {
                SET_STATERCV_LOWER(pLowerConn, PARTIAL_RCV, PartialRcv);
                CHECK_PTR(pConnectEle);
                pConnectEle->ReceiveIndicated = 0;  // zero bytes waiting for client
            }
            else
            {
                //
                // if any bytes were taken (i.e. the session hdr) then
                // return status success. (otherwise the status is
                // statusNotAccpeted).
                //
                if (*BytesTaken)
                {
                    ASSERT(*BytesTaken <= uSavedBytesIndicated);
                    status = STATUS_SUCCESS;
                }
            }

            //
            // the next time the client sends down a receive buffer
            // the code will pass it to the transport and decrement this
            // counter.
        }
        else
            ASSERT(0);


        return(status);

    }
#ifdef VXD
    //
    // there is always a receive event handler in the Nt case - it may
    // be the default handler, but it is there, so no need for test.
    //
    else
    {
        //
        // there is no client buffer to pass the data to, so keep
        // track of the fact so when the next client buffer comes down
        // we can get the data from the transport.
        //
        KdPrint(("NBT:Client did not have a Buffer posted, rcvs indicated =%X,BytesRcvd=%X, TotalLen=%X\n",
                    pConnectEle->ReceiveIndicated,
                    pConnectEle->BytesRcvd,
                    pConnectEle->TotalPcktLen));

        // the routine calling this one increments ReceiveIndicated and sets the
        // state to PartialRcv to keep track of the fact that there is data
        // waiting in the transport
        //
        return(STATUS_DATA_NOT_ACCEPTED);
    }
#endif
}

//----------------------------------------------------------------------------
__inline
VOID
DerefLowerConnFast(
    IN tLOWERCONNECTION *pLowerConn,
    IN CTELockHandle    OldIrq
    )
/*++

Routine Description:

    This routine dereferences the lower connection and if someone has
    tried to do that during the execution of the routine that called
    this one, the pConnEle is dereferenced too.

Arguments:


Return Value:


--*/

{
    if (pLowerConn->RefCount > 1)
    {
        // This is the FAST PATH
        IF_DBG(NBT_DEBUG_REF)
            KdPrint(("\t--pLowerConn=<%x:%d->%d>, <%d:%s>\n",
                pLowerConn,pLowerConn->RefCount,(pLowerConn->RefCount-1),__LINE__,__FILE__));
        pLowerConn->RefCount--; 
        ASSERT (pLowerConn->References[REF_LOWC_RCV_HANDLER]--);
        CTESpinFree(pLowerConn,OldIrq);
    }
    else
    {
        CTESpinFree(pLowerConn,OldIrq);
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER, FALSE);
    }
}
//----------------------------------------------------------------------------
VOID
DpcGetRestOfIndication(
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    )
/*++

Routine Description:

    This routine is called when the client has been  indicated with more
    data than they will take and there is a rcv buffer on their RcvHead
    list when completion rcv runs.

Arguments:


Return Value:


--*/

{
    NTSTATUS            status;
    CTELockHandle       OldIrq;
    tCONNECTELE         *pConnEle;
    PIRP                pIrp;
    PIO_STACK_LOCATION  pIrpSp;
    tLOWERCONNECTION    *pLowerConn=(tLOWERCONNECTION *)Context;
    PLIST_ENTRY         pEntry;

    CTEMemFree((PVOID)pDpc);

    CTESpinLockAtDpc(&NbtConfig.JointLock);

    // a disconnect indication can come in any time and separate the lower and
    // upper connections, so check for that
    if (!pLowerConn->pUpperConnection || pLowerConn->StateRcv != PARTIAL_RCV)
    {
        PUSH_LOCATION(0xA4);
        //
        // Dereference pLowerConn
        //
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER, TRUE);
        CTESpinFreeAtDpc(&NbtConfig.JointLock);
        return;
    }

    CTESpinLockAtDpc(pLowerConn);

    pConnEle = (tCONNECTELE *)pLowerConn->pUpperConnection;
    if (!IsListEmpty(&pConnEle->RcvHead))
    {
        PUSH_LOCATION(0xA5);
        pEntry = RemoveHeadList(&pConnEle->RcvHead);

        CTESpinFreeAtDpc(pLowerConn);
        CTESpinFreeAtDpc(&NbtConfig.JointLock);

        pIrp = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);

        IoAcquireCancelSpinLock(&OldIrq);
        IoSetCancelRoutine(pIrp,NULL);
        IoReleaseCancelSpinLock(OldIrq);

        //
        // call the same routine that the client would call to post
        // a recv buffer, except now we are in the PARTIAL_RCV state
        // and the buffer will be passed to the transport.
        //
        status = NTReceive (pLowerConn->pDeviceContext, pIrp);
    }
    else
    {
        CTESpinFreeAtDpc(pLowerConn);
        CTESpinFreeAtDpc(&NbtConfig.JointLock);
        PUSH_LOCATION(0xA6);
    }
    //
    // Dereference pLowerConn
    //
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER, FALSE);
}

//----------------------------------------------------------------------------
VOID
DpcHandleNewSessionPdu (
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    )
/*++

Routine Description:

    This routine simply calls HandleNewSessionPdu from a Dpc started in
    NewSessionCompletionRoutine.

Arguments:


Return Value:


--*/

{
    CTEMemFree((PVOID)pDpc);


    HandleNewSessionPdu((tLOWERCONNECTION *)Context,
                        PtrToUlong(SystemArgument1),
                        PtrToUlong(SystemArgument2));

}

//----------------------------------------------------------------------------
VOID
HandleNewSessionPdu (
    IN  tLOWERCONNECTION *pLowerConn,
    IN  ULONG           Offset,
    IN  ULONG           ToGet
    )
/*++

Routine Description:

    This routine handles the case when a session pdu starts in the middle of
    a data indication from the transport. It gets an Irp from the free list
    and formulates a receive to pass to the transport to get that data.  The
    assumption is that the client has taken all data preceding the next session
    pdu. If the client hasn't then this routine should not be called yet.

Arguments:


Return Value:

    pConnectionContext      - connection context returned to the transport(connection to use)

    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS            status;
    ULONG               BytesTaken;
    PIRP                pIrp;
    PFILE_OBJECT        pFileObject;
    PMDL                pMdl;
    ULONG               BytesToGet;
    tCONNECTELE         *pConnEle;

    pIrp = NULL;
    BytesTaken = 0;

    // we grab the joint lock because it is needed to separate the lower and
    // upper connections, so with it we can check if they have been separated.
    //
    CTESpinLockAtDpc(&NbtConfig.JointLock);
    pConnEle = pLowerConn->pUpperConnection;

    // a disconnect indication can come in any time and separate the lower and
    // upper connections, so check for that
    if (!pLowerConn->pUpperConnection)
    {
        //
        // remove the reference from CompletionRcv
        //
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER, TRUE);
        CTESpinFreeAtDpc(&NbtConfig.JointLock);
        return;
    }

    //
    // get an Irp from the list
    //
    status = GetIrp(&pIrp);
    if (!NT_SUCCESS(status))
    {
        CTESpinFreeAtDpc(&NbtConfig.JointLock);
        KdPrint(("Nbt:Unable to get an Irp - Closing Connection!!\n",0));
        status = OutOfRsrcKill(pLowerConn);
        //
        // remove the reference from CompletionRcv
        //
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER, FALSE);
        return;
    }

    CTESpinLockAtDpc(pLowerConn);
    //
    // be sure the connection has not disconnected in the meantime...
    //
    if (pLowerConn->State != NBT_SESSION_UP)
    {
        NbtFreeIrp(pIrp);
        CTESpinFreeAtDpc(pLowerConn);
        //
        // remove the reference from CompletionRcv
        //
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER, TRUE);
        CTESpinFreeAtDpc(&NbtConfig.JointLock);
        return;
    }

    pFileObject = pLowerConn->pFileObject;
    ASSERT (pFileObject->Type == IO_TYPE_FILE);

    // use the indication buffer for the receive.
    pMdl = pLowerConn->pIndicateMdl;

    // this flag is set below so we know if there is data in the indicate buffer
    // or not.
    if (Offset)
    {
        PVOID       NewAddress;
        PMDL        pNewMdl;

        // there is still data in the indication buffer ,so only
        // fill the empty space.  This means adjusting the Mdl to
        // to only map the last portion of the Indication Buffer
        NewAddress = (PVOID)((PCHAR)MmGetMdlVirtualAddress(pMdl)
                            + Offset);

        // create a partial MDL so that the new data is copied after the existing data
        // in the MDL.
        //
        // 0 for length means map the rest of the buffer
        //
        pNewMdl = pConnEle->pNewMdl;

        IoBuildPartialMdl(pMdl,pNewMdl,NewAddress,0);

        pMdl = pNewMdl;

        IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:Mapping IndicBuffer to partial Mdl Offset=%X, ToGet=%X %X\n",
                    Offset,ToGet,
                    pLowerConn));
    }
    else
    {
        CHECK_PTR(pLowerConn);
        pLowerConn->BytesInIndicate = 0;
    }

    //
    // Only get the amount of data specified, which is either the 4 byte header
    // or the rest of the pdu so that we never have
    // more than one session pdu in the indicate buffer.
    //
    BytesToGet = ToGet;

    ASSERT (pFileObject->Type == IO_TYPE_FILE);
    TdiBuildReceive(
        pIrp,
        IoGetRelatedDeviceObject(pFileObject),
        pFileObject,
        NewSessionCompletionRoutine,
        (PVOID)pLowerConn,
        pMdl,
        (ULONG)TDI_RECEIVE_NORMAL,
        BytesToGet); // only ask for the number of bytes left and no more

    CTESpinFreeAtDpc(pLowerConn);
    CTESpinFreeAtDpc(&NbtConfig.JointLock);

    CHECK_COMPLETION(pIrp);
    status = IoCallDriver(IoGetRelatedDeviceObject(pFileObject),pIrp);

}

//----------------------------------------------------------------------------
NTSTATUS
NewSessionCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
/*++

Routine Description:

    This routine handles the completion of the receive to get the remaining
    data left in the transport when a session PDU starts in the middle of
    an indication from the transport.  This routine is run as the completion
    of a recv Irp passed to the transport by NBT, to get the remainder of the
    data in the transport.

    The routine then calls the normal receive handler, which can either
    consume the data or pass back an Irp.  If an Irp is passed back then
    the data is copied into that irp in this routine.

Arguments:


Return Value:

    pConnectionContext      - connection context returned to the transport(connection to use)

    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS            status, IrpStatus;
    ULONG               BytesTaken;
    tCONNECTELE         *pConnEle;
    PVOID               pData;
    KIRQL               OldIrq;
    PMDL                pMdl;
    ULONG               BytesIndicated;
    ULONG               BytesAvailable;
    PKDPC               pDpc;
    tLOWERCONNECTION    *pLowerConn;
    ULONG               Length;
    ULONG               PduLen;
    PIRP                pRetIrp;

    // we grab the joint lock because it is needed to separate the lower and
    // upper connections, so with it we can check if they have been separated.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pLowerConn = (tLOWERCONNECTION *)pContext;
    pConnEle = pLowerConn->pUpperConnection;

    CTESpinLockAtDpc(pLowerConn);

    // a disconnect indication can come in any time and separate the lower and
    // upper connections, so check for that
    //
    if (!pConnEle)
    {
        CTESpinFreeAtDpc(&NbtConfig.JointLock);
        status = STATUS_UNSUCCESSFUL;
        goto ExitRoutine;
    }

    CTESpinFreeAtDpc(&NbtConfig.JointLock);


    BytesTaken = 0;

    pMdl = pLowerConn->pIndicateMdl;

    pData = MmGetMdlVirtualAddress(pMdl);

    //
    // The Indication buffer may have more data in it than what we think
    // was left in the transport, because the transport may have received more
    // data in the intervening time.  Check for this case.
    //
    if (pIrp->IoStatus.Information > pConnEle->BytesInXport)
    {
        // no data left in transport
        //
        CHECK_PTR(pConnEle);
        pConnEle->BytesInXport = 0;
    }
    else
    {
        //
        // subtract what we just retrieved from the transport, from the count
        // of data left in the transport
        //
        pConnEle->BytesInXport -= (ULONG)pIrp->IoStatus.Information;
    }

    //
    // there may be data still in the indication buffer,
    // so add that amount to what we just received.
    //
    pLowerConn->BytesInIndicate += (USHORT)pIrp->IoStatus.Information;
    BytesIndicated = pLowerConn->BytesInIndicate;

    // put the irp back on its free list
    CHECK_PTR(pIrp);
    pIrp->MdlAddress = NULL;
    IrpStatus = pIrp->IoStatus.Status;
    NbtFreeIrp(pIrp);

    //
    // we need to set the bytes available to be the data in the Xport + the
    // bytes in the indicate buffer, so that
    // ReceiveIndicated gets set to the correct value if the client does
    // not take all of data
    //
    BytesAvailable = pConnEle->BytesInXport + BytesIndicated;
    pRetIrp = NULL;

    // if the number of bytes is 4 then we just have the header and must go
    // back to the transport for the rest of the pdu, or we have a keep
    // alive pdu...
    //
    //
    // This could be a session keep alive pdu so check the pdu type.  Keep
    // alives just go to the RcvHndlrNotOs routine and return, doing nothing.
    // They have a length of zero, so the overall length is 4 and they could
    // be confused for session pdus otherwise.
    //
    status = STATUS_SUCCESS;
    if (BytesIndicated == sizeof(tSESSIONHDR))
    {
        PUSH_LOCATION(0x1e)
        if (((tSESSIONHDR UNALIGNED *)pData)->Type == NBT_SESSION_MESSAGE)
        {
            // if there is still data in the transport we must send down an
            // irp to get the data, however, if there is no data left in
            // the transport, then the data will come up on its own, into
            // the indicate_buffer case in the main Receivehandler.
            //
            if (pConnEle->BytesInXport)
            {
                PUSH_LOCATION(0x1e);

                // tell the DPC routine to get the data at an offset of 4 for length Length

                //
                // this is the first indication to find out how large the pdu is, so
                // get the length and go get the rest of the pdu.
                //
                Length = myntohl(((tSESSIONHDR UNALIGNED *)pData)->UlongLength);

                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Nbt:Got Pdu Hdr in sessioncmplionroutine, PduLen =%X\n",Length));

                //  it is possible to get a zero length pdu, in which case we
                // do NOT need to go to the transport to get more data
                //
                if (Length)
                {
                    PUSH_LOCATION(0x1e);
                    //
                    // now go get this amount of data and add it to the header
                    //
                    CTESpinFree(pLowerConn,OldIrq);
                    if (pDpc = NbtAllocMem(sizeof(KDPC),NBT_TAG('r')))
                    {
                        // check that the pdu is not going to overflow the indicate buffer.
                        //
                        if (Length > NBT_INDICATE_BUFFER_SIZE - sizeof(tSESSIONHDR))
                        {
                            Length = NBT_INDICATE_BUFFER_SIZE - sizeof(tSESSIONHDR);
                        }
                        ASSERTMSG("Nbt:Getting ZERO bytes from Xport!!\n",Length);

                        KeInitializeDpc(pDpc, DpcHandleNewSessionPdu, (PVOID)pLowerConn);
                        KeInsertQueueDpc(pDpc, ULongToPtr(sizeof(tSESSIONHDR)), ULongToPtr(Length));

                        // clean up the partial mdl since we are going to turn around and reuse
                        // it in HandleNewSessionPdu above..
                        //
                        // THIS CALL SHOULD NOT BE NEEDED SINCE THE INDICATE BUFFER IS NON_PAGED
                        // POOL
//                        MmPrepareMdlForReuse(pConnEle->pNewMdl);

                        // return this status to stop to tell the io subsystem to stop processing
                        // this irp when we return it.
                        //
                        return(STATUS_MORE_PROCESSING_REQUIRED);
                    }

                    OutOfRsrcKill(pLowerConn);
                    CTESpinLock (pLowerConn,OldIrq);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ExitRoutine;
                }
            }
        }
    }

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:NewSessComplRcv BytesinXport= %X,InIndicate=%X Indic. %X,Avail=%X %X\n",
            pConnEle->BytesInXport,pLowerConn->BytesInIndicate,BytesIndicated,
            BytesAvailable,pConnEle->pLowerConnId));

    if (!NT_SUCCESS(IrpStatus))
    {
        ASSERTMSG("Nbt:Not Expecting a Bad Status Code\n",0);
        goto ExitRoutine;
    }

    //
    // check if we have a whole pdu in the indicate buffer or not.  IF not
    // then just return and wait for more data to hit the TdiReceiveHandler
    // code. This check passes KeepAlives correctly since they have a pdu
    // length of 0, and adding the header gives 4, their overall length.
    //
    PduLen = myntohl(((tSESSIONHDR UNALIGNED *)pData)->UlongLength);
    if ((BytesIndicated < PduLen + sizeof(tSESSIONHDR)) &&
        (BytesIndicated != NBT_INDICATE_BUFFER_SIZE))

    {
        PUSH_LOCATION(0x1f);

        IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Returning in NewSessionCompletion BytesIndicated = %X\n", BytesIndicated));
    }
    else
    {
        PUSH_LOCATION(0x20);

        status = CopyDataandIndicate (NULL,
                                     (PVOID)pLowerConn,
                                     0,            // rcv flags
                                     BytesIndicated,
                                     BytesAvailable,
                                     &BytesTaken,
                                     pData,
                                     (PVOID)&pRetIrp);

    }

ExitRoutine:
    //
    // check if an irp is passed back, so we don't Deref in that case.
    //
    if (status != STATUS_MORE_PROCESSING_REQUIRED)
    {
        //
        // quickly check if we can just decrement the ref count without calling
        // NBT_DEREFERENCE_LOWERCONN
        //
        PUSH_LOCATION(0x51);
        DerefLowerConnFast(pLowerConn,OldIrq);
    }
    else
    {
        CTESpinFree(pLowerConn,OldIrq);
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);
}
//----------------------------------------------------------------------------
NTSTATUS
NtBuildIndicateForReceive (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               Length,
    OUT PVOID               *ppIrp
    )
/*++

Routine Description:

    This routine sets up the indicate buffer to get data from the transport
    when the indicate buffer already has some data in it.  A partial MDL is
    built and the attached to the irp.
    before we indicate.

Arguments:


Return Value:


    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS                    status;
    PIRP                        pIrp;
    PTDI_REQUEST_KERNEL_RECEIVE pParams;
    PIO_STACK_LOCATION          pIrpSp;
    tCONNECTELE                 *pConnEle;
    PMDL                        pNewMdl;
    PVOID                       NewAddress;

    //
    // get an Irp from the list
    //

    status = GetIrp(&pIrp);

    if (!NT_SUCCESS(status))
    {
        KdPrint(("NBT:Unable to get Irp, Kill connection\n"));

        CTESpinFreeAtDpc(pLowerConn);
        OutOfRsrcKill(pLowerConn);
        CTESpinLockAtDpc(pLowerConn);

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pConnEle= pLowerConn->pUpperConnection;

    NewAddress = (PVOID)((PCHAR)MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl)
                        + pLowerConn->BytesInIndicate);

    // create a partial MDL so that the new data is copied after the existing data
    // in the MDL.
    //
    // 0 for length means map the rest of the buffer
    //
    pNewMdl = pConnEle->pNewMdl;

    IoBuildPartialMdl(pLowerConn->pIndicateMdl,pNewMdl,NewAddress,0);

    ASSERT (pLowerConn->pFileObject->Type == IO_TYPE_FILE);
    TdiBuildReceive(
        pIrp,
        IoGetRelatedDeviceObject(pLowerConn->pFileObject),
        pLowerConn->pFileObject,
        NewSessionCompletionRoutine,
        (PVOID)pLowerConn,
        pNewMdl,
        (ULONG)TDI_RECEIVE_NORMAL,
        Length);

    //
    // we need to set the next Irp stack location because this irp is returned
    // as a return parameter rather than being passed through IoCallDriver
    // which increments the stack location itself
    //
    ASSERT(pIrp->CurrentLocation > 1);
    IoSetNextIrpStackLocation(pIrp);

    *ppIrp = (PVOID)pIrp;

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
NtBuildIrpForReceive (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               Length,
    OUT PVOID               *ppIrp
    )
/*++

Routine Description:

    This routine gets an Irp to be used to receive data and hooks the indication
    Mdl to it, so we can accumulate at least 128 bytes of data for the client
    before we indicate.

Arguments:


Return Value:


    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS                    status;
    PIRP                        pIrp;
    PTDI_REQUEST_KERNEL_RECEIVE pParams;
    PIO_STACK_LOCATION          pIrpSp;

    //
    // get an Irp from the list
    //
    status = GetIrp(&pIrp);

    if (!NT_SUCCESS(status))
    {
        KdPrint(("NBT:Unable to get Irp, Kill connection\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    CHECK_PTR(pLowerConn);
    pLowerConn->BytesInIndicate = 0;

    ASSERT (pLowerConn->pFileObject->Type == IO_TYPE_FILE);
    TdiBuildReceive(
        pIrp,
        IoGetRelatedDeviceObject(pLowerConn->pFileObject),
        pLowerConn->pFileObject,
        NewSessionCompletionRoutine,
        (PVOID)pLowerConn,
        pLowerConn->pIndicateMdl,
        (ULONG)TDI_RECEIVE_NORMAL,
        Length);

    //
    // we need to set the next Irp stack location because this irp is returned
    // as a return parameter rather than being passed through IoCallDriver
    // which increments the stack location itself
    //
    ASSERT(pIrp->CurrentLocation > 1);
    IoSetNextIrpStackLocation(pIrp);

    *ppIrp = (PVOID)pIrp;

    return(STATUS_SUCCESS);
}

#pragma inline_depth(0)
//----------------------------------------------------------------------------
NTSTATUS
CopyDataandIndicate(
    IN PVOID                ReceiveEventContext,
    IN PVOID                ConnectionContext,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PIRP                *ppIrp
    )
/*++

Routine Description:


    This routine combines data indicated with the indicate buffer to
    indicate the total to the client. Any bytes Indicated are those bytes
    in the indicate buffer. Bytes available adds in any bytes in the transport.

    The idea here is to copy as much as possible from the indicate buffer and
    then pass back an irp if there is still more data in the transport.  If
    no data left in the transport, this routine completes the client irp and
    returns STATUS_SUCCESS.

Arguments:


Return Value:


    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS                    status;
    tLOWERCONNECTION            *pLowerConn;
    tCONNECTELE                 *pConnEle;
    ULONG                       BytesCopied;
    ULONG                       Indicated;
    ULONG                       Available;
    ULONG                       Taken;
    ULONG                       AmountAlreadyInIndicateBuffer;
    PVOID                       pBuffer;
    PIRP                        pIrp;
    BOOLEAN                     bReIndicate=FALSE;
    ULONG                       RemainingPdu;
    ULONG                       ToCopy;
    PKDPC                       pDpc;
    ULONG                       SaveInXport;
    ULONG                       PduSize;

    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;
    pConnEle = pLowerConn->pUpperConnection;

    AmountAlreadyInIndicateBuffer = pLowerConn->BytesInIndicate;

    //
    // set the parameters for the call to the TdiReceiveHandler routine
    //

    Indicated = BytesIndicated;
    Available = BytesAvailable;
    Taken = 0;


//    ASSERT(pLowerConn->StateRcv == INDICATE_BUFFER);

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
    KdPrint(("Nbt:Amount In Indicate = %X\n",AmountAlreadyInIndicateBuffer));

    // now that we have 128 bytes (plus the session hdr = 132 total) we
    // can indicate to the client

    pBuffer = MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl);

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
    KdPrint(("Nbt:FromCopyData, BytesAvail= %X,BytesInd= %X,BytesRcvd= %X,Amount=%X, %X,state=%X,RcvEC=%X\n",
                    Available,Indicated,pConnEle->BytesRcvd,
                    AmountAlreadyInIndicateBuffer,pLowerConn,pLowerConn->StateRcv,
                    ReceiveEventContext));

    pIrp = NULL;

    //
    // Reset this count so that the routine processes the Session header correctly
    //
    CHECK_PTR(pConnEle);
    pConnEle->BytesRcvd = 0;
    PUSH_LOCATION(0x21);
    status = RcvHandlrNotOs(
                    NULL,
                    ConnectionContext,
                    ReceiveFlags,
                    Indicated,
                    Available,
                    &Taken,
                    pBuffer,
                    (PVOID)&pIrp
                    );

    //
    // if the connection has disonnected, then just return
    //
    if (!pLowerConn->pUpperConnection)
    {
        *BytesTaken = BytesAvailable;
        return(STATUS_SUCCESS);
    }

    // do not use pConnEle->TotalPcktLen here becauase it won't be set for
    // keep alives - must use actual buffer to get length.
    PduSize = myntohl(((tSESSIONHDR UNALIGNED *)pBuffer)->UlongLength) + sizeof(tSESSIONHDR);

    RemainingPdu = pConnEle->TotalPcktLen - pConnEle->BytesRcvd;

    if (Taken <= pLowerConn->BytesInIndicate)
    {
        pLowerConn->BytesInIndicate -= (USHORT)Taken;
    }
    else
    {
        pLowerConn->BytesInIndicate = 0;
    }

    if (pIrp)
    {
        PIO_STACK_LOCATION            pIrpSp;
        PTDI_REQUEST_KERNEL_RECEIVE   pParams;
        ULONG                         ClientRcvLen;

        PUSH_LOCATION(0x22);
        //
        // BytesInXport will be recalculated by ProcessIrp based on BytesAvailable
        // and the ClientRcvLength, so set it to 0 here.
        //
        SaveInXport = pConnEle->BytesInXport;
        CHECK_PTR(pConnEle);
        pConnEle->BytesInXport = 0;
        status = ProcessIrp(pLowerConn,
                            pIrp,
                            pBuffer,
                            &Taken,
                            Indicated,
                            Available);

        //
        // copy the data in the indicate buffer that was not taken by the client
        // into the MDL and then update the bytes taken and pass the irp on downwar
        // to the transport
        //
        ToCopy = Indicated - Taken;

        // the Next stack location has the correct info in it because we
        // called TdiRecieveHandler with a null ReceiveEventContext,
        // so that routine does not increment the stack location
        //
        pIrpSp = IoGetNextIrpStackLocation(pIrp);
        pParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;
        ClientRcvLen = pParams->ReceiveLength;

        // did the client's Pdu fit entirely into the indication buffer?
        //
        if (ClientRcvLen <= ToCopy)
        {
            PUSH_LOCATION(0x23);
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Took some(or all) RemainingPdu= %X, ClientRcvLen= %X,InXport=%X %X\n",
                        RemainingPdu,ClientRcvLen,pConnEle->BytesInXport,pLowerConn));

            // if ProcessIrp has recalculated the bytes in the Xport
            // then set it back to where it should be, Since ProcessIrp will
            // put all not taken bytes as bytes in the transport - but some
            // of the bytes are still in the indicate buffer.
            //
            pConnEle->BytesInXport = SaveInXport;

            // it could be a zero length send where the client returns a null
            // mdl, or the client returns an mdl and the RcvLen is really zero.
            //
            if (pIrp->MdlAddress && ClientRcvLen)
            {
                TdiCopyBufferToMdl(pBuffer,     // indicate buffer
                                   Taken,       // src offset
                                   ClientRcvLen,
                                   pIrp->MdlAddress,
                                   0,                 // dest offset
                                   &BytesCopied);
            }
            else
                BytesCopied = 0;

            //
            // check for data still in the transport - subtract data copied to
            // Irp, since Taken was already subtracted.
            //
            pLowerConn->BytesInIndicate -= (USHORT)BytesCopied;

            *BytesTaken = Taken + BytesCopied;
            ASSERT(BytesCopied == ClientRcvLen);

            // the client has received all of the data, so complete his irp
            //
            pIrp->IoStatus.Information = BytesCopied;
            pIrp->IoStatus.Status = STATUS_SUCCESS;

            // since we are completing it and TdiRcvHandler did not set the next
            // one.
            //
            ASSERT(pIrp->CurrentLocation > 1);

            // since we are completing the irp here, no need to call
            // this, because it will complete through completionrcv.
            IoSetNextIrpStackLocation(pIrp);

            // there should not be any data in the indicate buffer since it
            // only holds either 132 bytes or a whole pdu unless the client
            // receive length is too short...
            //
            if (pLowerConn->BytesInIndicate)
            {
                PUSH_LOCATION(0x23);
                // when the irp goes through completionRcv it should set the
                // state to PartialRcv and the next posted buffer from
                // the client should pickup this data.
                CopyToStartofIndicate(pLowerConn,(Taken+BytesCopied));
            }
            else
            {
                //
                // this will complete through CompletionRcv and for that
                // reason it will get any more data left in the transport.  The
                // Completion routine will set the correct state for the rcv when
                // it processes this Irp ( to INDICATED, if needed). ProcessIrp
                // may have set ReceiveIndicated, so that CompletionRcv will
                // set the state to PARTIAL_RCV when it runs.
                //
                SET_STATERCV_LOWER(pLowerConn, NORMAL, Normal);
            }

            CTESpinFreeAtDpc(pLowerConn);
            IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

            CTESpinLockAtDpc(pLowerConn);
            //
            // this was undone by CompletionRcv, so redo them, since the
            // caller will undo them again.
            //
            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER);
            return(STATUS_SUCCESS);
        }
        else
        {

            PUSH_LOCATION(0x24);
            //
            // there is still data that we need to get to fill the PDU.  There
            // may be more data left in the transport or not after the irp is
            // filled.
            // In either case the Irps' Mdl must be adjusted to account for
            // filling part of it.
            //
            TdiCopyBufferToMdl(pBuffer,     // IndicateBuffer
                               Taken,       // src offset
                               ToCopy,
                               pIrp->MdlAddress,
                               0,                 // dest offset
                               &BytesCopied);

            //
            // save the Mdl so we can reconstruct things later
            //
            pLowerConn->pMdl  = pIrp->MdlAddress;
            pConnEle->pNextMdl = pIrp->MdlAddress;
            ASSERT(pIrp->MdlAddress);
            //
            // The irp is being passed back to the transport, so we NULL
            // our ptr to it so we don't try to cancel it on a disconnect
            //
            CHECK_PTR(pConnEle);
            pConnEle->pIrpRcv = NULL;

            // Adjust the number of bytes in the Mdl chain so far since the
            // completion routine will only count the bytes filled in by the
            // transport
            //
            pConnEle->BytesRcvd += BytesCopied;

            *BytesTaken = BytesIndicated;

            //
            // clear the number of bytes in the indicate buffer since the client
            // has taken more than the data left in the Indicate buffer
            //
            CHECK_PTR(pLowerConn);
            pLowerConn->BytesInIndicate = 0;

            // decrement the client rcv len by the amount already put into the
            // client Mdl
            //
            ClientRcvLen -= BytesCopied;
            //
            // if ProcessIrp did recalculate the bytes in the transport
            // then set back to what it was.  Process irp will do this
            // recalculation if the clientrcv buffer is too short only.
            //
            pConnEle->BytesInXport = SaveInXport;

            //
            // adjust the number of bytes downward due to the client rcv
            // buffer
            //
            if (ClientRcvLen < SaveInXport)
            {
                PUSH_LOCATION(0x24);
                pConnEle->BytesInXport -= ClientRcvLen;
            }
            else
            {
                pConnEle->BytesInXport = 0;
            }

            // ProcessIrp will set bytesinXport and ReceiveIndicated - since
            // the indicate buffer is empty that calculation of BytesInXport
            // will be correct.
            //

            // We MUST set the state to FILL_IRP so that completion Rcv
            // undoes the partial MDL stuff - i.e. it puts the original
            // MdlAddress in the Irp, rather than the partial Mdl address.
            // CompletionRcv will set the state to partial Rcv if ReceiveIndicated
            // is not zero.
            //
            SET_STATERCV_LOWER(pLowerConn, FILL_IRP, FillIrp);

            // the client is going to take more data from the transport with
            // this Irp.  Set the new Rcv Length that accounts for the data just
            // copied to the Irp.
            //
            pParams->ReceiveLength = ClientRcvLen;

            // keep track of data in MDL so we know when it is full and we need to
            // return it to the user - ProcessIrp set it to ClientRcvLen, so
            // shorten it here.
            //
            pConnEle->FreeBytesInMdl -= BytesCopied;

            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:ClientRcvLen = %X, LeftinXport= %X RemainingPdu= %X %X\n",ClientRcvLen,
                            pConnEle->BytesInXport,RemainingPdu,pLowerConn));


            // Build a partial Mdl to represent the client's Mdl chain since
            // we have copied data to it, and the transport must copy
            // more data to it after that data.
            //
            MakePartialMdl(pConnEle,pIrp,BytesCopied);

            *ppIrp = pIrp;

            // increments the stack location, since TdiReceiveHandler did not.
            //
            if (ReceiveEventContext)
            {
                ASSERT(pIrp->CurrentLocation > 1);
                IoSetNextIrpStackLocation(pIrp);

                return(STATUS_MORE_PROCESSING_REQUIRED);
            }
            else
            {
                // pass the Irp to the transport since we were called from
                // NewSessionCompletionRoutine
                //
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                    KdPrint(("Nbt:Calling IoCallDriver\n"));
                ASSERT(pIrp->CurrentLocation > 1);

                CTESpinFreeAtDpc(pLowerConn);
                CHECK_COMPLETION(pIrp);
                ASSERT (pLowerConn->pFileObject->Type == IO_TYPE_FILE);
                IoCallDriver(IoGetRelatedDeviceObject(pLowerConn->pFileObject),pIrp);
                CTESpinLockAtDpc(pLowerConn);

                return(STATUS_MORE_PROCESSING_REQUIRED);
            }
        }
    }
    else
    {
        PUSH_LOCATION(0x54);
        //
        // no Irp passed back, the client just took some or all of the data
        //
        *BytesTaken = Taken;
        pLowerConn->BytesRcvd += Taken - sizeof(tSESSIONHDR);

        ASSERT(*BytesTaken < 0x7FFFFFFF );

        //
        // if more than the indicate buffer is taken, then the client
        // is probably trying to say it doesn't want any more of the
        // message.
        //
        if (Taken > BytesIndicated)
        {
            //
            // in this case the client has taken more than the indicated.
            // We set bytesavailable to the message length in RcvHndlrNotOs,
            // so the client has probably said BytesTaken=BytesAvailable.
            // So kill the connection
            // because we have no way of handling this case here, since
            // part of the message may still be in the transport, and we
            // might have to send the indicate buffer down there multiple
            // times to get all of it...a mess!  The Rdr only sets bytestaken =
            // bytesAvailable under select error conditions anyway.
            //
            CTESpinFreeAtDpc(pLowerConn);
            OutOfRsrcKill(pLowerConn);
            CTESpinLockAtDpc(pLowerConn);

            *BytesTaken = BytesAvailable;

        }
        else if (pLowerConn->StateRcv == PARTIAL_RCV)
        {
            // this may be a zero length send -that the client has
            // decided not to accept.  If so then the state will be set
            // to PartialRcv.  In this case do NOT go down to the transport
            // and get the rest of the data, but wait for the client
            // to post a rcv buffer.
            //
            PUSH_LOCATION(0x54);
            return(STATUS_SUCCESS);
        }
        else if (Taken == PduSize)
        {
            //
            // Must have taken all of the pdu data, so check for
            // more data available - if so send down the indicate
            // buffer to get it.
            //
            if (pConnEle->BytesInXport)
            {
                PUSH_LOCATION(0x28);
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Nbt:CopyData BytesInXport= %X, %X\n",pConnEle->BytesInXport,
                                    pLowerConn));

                //
                // there is still data in the transport so Q a Dpc to use
                // the indicate buffer to get the data
                //
                pDpc = NbtAllocMem(sizeof(KDPC),NBT_TAG('s'));

                if (pDpc)
                {
                    KeInitializeDpc(pDpc, DpcHandleNewSessionPdu, (PVOID)pLowerConn);

                    SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, IndicateBuffer);

                    // get just the header first to see how large the pdu is
                    //
                    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER);
                    KeInsertQueueDpc(pDpc,NULL,(PVOID)sizeof(tSESSIONHDR));
                }
                else
                {
                    CTESpinFreeAtDpc(pLowerConn);
                    OutOfRsrcKill(pLowerConn);
                    CTESpinLockAtDpc(pLowerConn);
                }
            }
            else
            {
                PUSH_LOCATION(0x29);
                //
                // clear the flag saying that we are using the indicate buffer
                //
                SET_STATERCV_LOWER(pLowerConn, NORMAL, Normal);
            }

            PUSH_LOCATION(0x2a);
            return(STATUS_SUCCESS);
        }
        else
        {
            //
            // the client may have taken all the data in the
            // indication!!, in which case return status success
            // Note: that we check bytes available here not bytes
            // indicated - since the client could take all indicated
            // data but still leave data in the transport. If the client
            // got told there was more available but only took the indicated,
            // the we need to do the else and track ReceiveIndicated, but if
            // Indicated == Available, then we take the if and wait for
            // another indication from the transport.
            //
            if (Taken == BytesAvailable)
            {
                PUSH_LOCATION(0x4);
                status = STATUS_SUCCESS;

            }
            else
            {

                // did not take all of the data in the Indication
                //

                PUSH_LOCATION(0x2b);
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Nbt:Took Part of indication... BytesRemaining= %X, LeftInXport= %X, %X\n",
                            pLowerConn->BytesInIndicate,pConnEle->BytesInXport,pLowerConn));

                //
                // The amount of data Indicated to the client should not exceed
                // the Pdu size, so check that, since this routine could get
                // called with bytesAvailable > than the Pdu size.
                //
                // That is checked above where we check if Taken > BytesIndicated.

                SaveInXport = pConnEle->BytesInXport;
                ASSERT(Taken <= PduSize);
                status = ClientTookSomeOfTheData(pLowerConn,
                                        Indicated,
                                        Available,
                                        Taken,
                                        PduSize);

                //
                // Since the data may be divided between some in the transport
                // and some in the indicate buffer do not let ClientTookSomeOf...
                // recalculate the amount in the transport, since it assumes all
                // untaken data is in the transport. Since the client did not
                // take of the indication, the Bytes in Xport have not changed.
                //
                pConnEle->BytesInXport = SaveInXport;
                //
                // need to move the data forward in the indicate buffer so that
                // it begins at the start of the buffer
                //
                if (Taken)
                {
                    CopyToStartofIndicate(pLowerConn,Taken);
                }

            }
        }

    }
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
TdiConnectHandler (
    IN PVOID                pConnectEventContext,
    IN int                  RemoteAddressLength,
    IN PVOID                pRemoteAddress,
    IN int                  UserDataLength,
    IN PVOID                pUserData,
    IN int                  OptionsLength,
    IN PVOID                pOptions,
    OUT CONNECTION_CONTEXT  *pConnectionContext,
    OUT PIRP                *ppAcceptIrp
    )
/*++

Routine Description:

    This routine is connect event handler.  It is invoked when a request for
    a connection has been received by the provider.  NBT accepts the connection
    on one of its connections in its LowerConnFree list

    Initially a TCP connection is setup with this port.  Then a Session Request
    packet is sent across the connection to indicate the name of the destination
    process.  This packet is received in the RcvHandler.

    For message-only mode, make session establishment automatic without the exchange of
    messages.  In this case, the best way to do this is to force the code through its paces.
    The code path for "inbound" setup includes AcceptCompletionRoutine, Inbound, and
    CompleteSessionSetup.  We do this by creating a fake session request and feeding it into
    the state machine.

    As part of connection/session establishment, Netbt must notify
    the consumer.  Normally this is done after connection establishment when the session request
    comes in.  We must move this process up so that the consumer gets his notification and
    yah/nay opportunity during connection acceptance, so we gets a chance to reject the connection.

Arguments:

    pConnectEventContext    - the context passed to the transport when this event was setup
    RemoteAddressLength     - the length of the source address (4 bytes for IP)
    pRemoteAddress          - a ptr to the source address
    UserDataLength          - the number of bytes of user data - includes the session Request hdr
    pUserData               - ptr the the user data passed in
    OptionsLength           - number of options to pass in
    pOptions                - ptr to the options

Return Value:

    pConnectionContext      - connection context returned to the transport(connection to use)

    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS            status;
    PFILE_OBJECT        pFileObject;
    PIRP                pRequestIrp;
    CONNECTION_CONTEXT  pConnectionId;
    tDEVICECONTEXT      *pDeviceContext;

    *pConnectionContext = NULL;

    // convert the context value into the device context record ptr
    pDeviceContext = (tDEVICECONTEXT *)pConnectEventContext;

    IF_DBG(NBT_DEBUG_TDIHNDLR)
        KdPrint(("pDeviceContxt = %X ConnectEv = %X",pDeviceContext,pConnectEventContext));
    ASSERTMSG("Bad Device context passed to the Connection Event Handler",
        pDeviceContext->Verify == NBT_VERIFY_DEVCONTEXT);

    // get an Irp from the list
    status = GetIrp(&pRequestIrp);

    if (!NT_SUCCESS(status))
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // call the non-OS specific routine to find a free connection.

    status = ConnectHndlrNotOs(
                pConnectEventContext,
                RemoteAddressLength,
                pRemoteAddress,
                UserDataLength,
                pUserData,
                &pConnectionId);


    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDIHNDLR)
            KdPrint(("NO FREE CONNECTIONS in connect handler\n"));

        NbtFreeIrp(pRequestIrp);
        NbtTrace(NBT_TRACE_INBOUND, ("ConnectHndlrNotOs return %!status!", status));

        return(STATUS_DATA_NOT_ACCEPTED);
    }

#ifdef _NETBIOSLESS
    //
    // MessageOnly mode.  Establish session automatically.
    //
    // ******************************************************************************************

    if (IsDeviceNetbiosless(pDeviceContext))
    {
        status = PerformInboundProcessing (pDeviceContext,
                                           (tLOWERCONNECTION *) pConnectionId,
                                           pRemoteAddress);
        if (!NT_SUCCESS(status))
        {
//            IF_DBG(NBT_DEBUG_TDIHNDLR)
                KdPrint(("MessageOnly connect processing rejected with status 0x%x\n", status));

            NbtFreeIrp(pRequestIrp);
            NbtTrace(NBT_TRACE_INBOUND, ("PerformInboundProecessing return %!status!", status));

            return(STATUS_DATA_NOT_ACCEPTED);
        }
    }
    // ******************************************************************************************
    //
    //
#endif

    pFileObject = ((tLOWERCONNECTION *)pConnectionId)->pFileObject;
    ASSERT (pFileObject->Type == IO_TYPE_FILE);

    TdiBuildAccept(
        pRequestIrp,
        IoGetRelatedDeviceObject(pFileObject),
        pFileObject,
        AcceptCompletionRoutine,
        (PVOID)pConnectionId,
        NULL,
        NULL);

    // we need to null the MDL address because the transport KEEPS trying to
    // release buffers!! which do not exist!!!
    //
    CHECK_PTR(pRequestIrp);
    pRequestIrp->MdlAddress = NULL;


    // return the connection id to accept the connect indication on.
    *pConnectionContext = (CONNECTION_CONTEXT)pConnectionId;
    *ppAcceptIrp = pRequestIrp;
    //
    // make the next stack location the current one.  Normally IoCallDriver
    // would do this but we are not going through IoCallDriver here, since the
    // Irp is just passed back with Connect Indication.
    //
    ASSERT(pRequestIrp->CurrentLocation > 1);
    IoSetNextIrpStackLocation(pRequestIrp);

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


#ifdef _NETBIOSLESS
//----------------------------------------------------------------------------

static void
Inet_ntoa_nb(
    ULONG Address,
    PCHAR Buffer
    )
/*++

Routine Description:

This routine converts an IP address into its "dotted quad" representation.  The IP address is
expected to be in network byte order. No attempt is made to handle the other dotted notions as
defined in in.h.  No error checking is done: all address values are permissible including 0
and -1.  The output string is blank padded to 16 characters to make the name look like a netbios
name.

The string representation is in ANSI, not UNICODE.

The caller must allocate the storage, which should be 16 characters.

Arguments:

    Address - IP address in network byte order
    Buffer - Pointer to buffer to receive string representation, ANSI

Return Value:

void

--*/

{
    ULONG i;
    UCHAR byte, c0, c1, c2;
    PCHAR p = Buffer;

    for( i = 0; i < 4; i++ )
    {
        byte = (UCHAR) (Address & 0xff);

        c0 = byte % 10;
        byte /= 10;
        c1 = byte % 10;
        byte /= 10;
        c2 = byte;

        if (c2 != 0)
        {
            *p++ = c2 + '0';
            *p++ = c1 + '0';
        } else if (c1 != 0)
        {
            *p++ = c1 + '0';
        }
        *p++ = c0 + '0';

        if (i != 3)
            *p++ = '.';

        Address >>= 8;
    }

    // space pad up to 16 characters
    while (p < (Buffer + 16))
    {
        *p++ = ' ';
    }
} // Inet_ntoa1


//----------------------------------------------------------------------------

NTSTATUS
PerformInboundProcessing(
    tDEVICECONTEXT *pDeviceContext,
    tLOWERCONNECTION *pLowerConn,
    PTA_IP_ADDRESS pIpAddress
    )

/*++

Routine Description:

This routine is called by the connection handler to force the state machine through a session
establishment even though no message has been received.  We create a session request and feed
it into Inbound processing.  Inbound will find the listening consumer and give him a chance to
accept.

Arguments:

    pDeviceContext -
    pLowerConn -
    pIpAddress - Ip address of the source of the connect request

Return Value:

    NTSTATUS -

--*/

{
    ULONG status;
    ULONG BytesTaken;
    USHORT sLength;
    tSESSIONREQ *pSessionReq = NULL;
    PUCHAR pCopyTo;
    CHAR SourceName[16];

    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint(("Nbt.TdiConnectHandler: skipping session setup\n"));

    if (pIpAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_IP)
    {
        return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    Inet_ntoa_nb( pIpAddress->Address[0].Address[0].in_addr, SourceName );

    // the length is the 4 byte session hdr length + the half ascii calling
    // and called names + the scope length times 2, one for each name
    //
    sLength = (USHORT) (sizeof(tSESSIONREQ)  + (NETBIOS_NAME_SIZE << 2) + (NbtConfig.ScopeLength <<1));
    pSessionReq = (tSESSIONREQ *)NbtAllocMem(sLength,NBT_TAG('G'));
    if (!pSessionReq)
    {
        NbtTrace(NBT_TRACE_INBOUND, ("Out of resource for %!ipaddr!:%d",
            pIpAddress->Address[0].Address[0].in_addr, pIpAddress->Address[0].Address[0].sin_port));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pSessionReq->Hdr.Type   = NBT_SESSION_REQUEST;
    pSessionReq->Hdr.Flags  = NBT_SESSION_FLAGS;
    pSessionReq->Hdr.Length = (USHORT)htons(sLength- (USHORT)sizeof(tSESSIONHDR));  // size of called and calling NB names.

    // put the Dest HalfAscii name into the Session Pdu
    pCopyTo = ConvertToHalfAscii( (PCHAR)&pSessionReq->CalledName.NameLength,
                                  pDeviceContext->MessageEndpoint,
                                  NbtConfig.pScope,
                                  NbtConfig.ScopeLength);

    // put the Source HalfAscii name into the Session Pdu
    pCopyTo = ConvertToHalfAscii(pCopyTo,
                                 SourceName,
                                 NbtConfig.pScope,
                                 NbtConfig.ScopeLength);

    // Inbound expects this lock to be held!
    CTESpinLockAtDpc(pLowerConn);

    status = Inbound(
        NULL,                            // ReceiveEventContext - not used
        pLowerConn,                      // ConnectionContext
        0,                               // ReceiveFlags - not used
        sLength,                         // BytesIndicated
        sLength,                         // BytesAvailable - not used
        &BytesTaken,                     // BytesTaken
        pSessionReq,                     // pTsdu
        NULL                             // RcvBuffer
        );

    CTESpinFreeAtDpc(pLowerConn);

    if (!NT_SUCCESS(status)) {
        NbtTrace(NBT_TRACE_INBOUND, ("Inbound() returns %!status! for %!ipaddr!:%d %!NBTNAME!<%02x>",
            status, pIpAddress->Address[0].Address[0].in_addr,
            pIpAddress->Address[0].Address[0].sin_port, pCopyTo, (unsigned)pCopyTo[15]));
    }

    CTEMemFree( pSessionReq );

    return status;
} // PerformInboundProcessing

#endif

//----------------------------------------------------------------------------
NTSTATUS
AcceptCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
/*++

Routine Description:

    This routine handles the completion of an Accept to the transport.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    tLOWERCONNECTION    *pLowerConn;
    CTELockHandle       OldIrq;
    tDEVICECONTEXT      *pDeviceContext;

    pLowerConn = (tLOWERCONNECTION *)pContext;
    pDeviceContext = pLowerConn->pDeviceContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLockAtDpc(pDeviceContext);
    CTESpinLockAtDpc(pLowerConn);
    //
    // if the connection disconnects before the connect accept irp (this irp)
    // completes do not put back on the free list here but let  nbtdisconnect
    // handle it.
    // (i.e if the state is no longer INBOUND, then don't touch the connection
    //

    NbtTrace(NBT_TRACE_INBOUND, ("TDI_ACCEPT pIrp %p: pLowerConn %p %!status!",
                            pIrp, pLowerConn, pIrp->IoStatus.Status));

#ifdef _NETBIOSLESS
    if (!NT_SUCCESS(pIrp->IoStatus.Status))
    {
        if (pLowerConn->State == NBT_SESSION_INBOUND)
        {
#else
    if ((!NT_SUCCESS(pIrp->IoStatus.Status)) &&
        (pLowerConn->State == NBT_SESSION_INBOUND))
    {
#endif
            //
            // the accept failed, so close the connection and create
            // a new one to be sure all activity is run down on the connection.
            //

            //
            // Previously, the LowerConnection was in the SESSION_INBOUND state
            // hence we have to remove it from the WaitingForInbound Q and put
            // it on the active LowerConnection list!
            //
            RemoveEntryList (&pLowerConn->Linkage);
            InsertTailList (&pLowerConn->pDeviceContext->LowerConnection, &pLowerConn->Linkage);
            SET_STATE_LOWER (pLowerConn, NBT_IDLE);

            //
            // Change the RefCount Context to Connected!
            //
            NBT_SWAP_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND, REF_LOWC_CONNECTED, TRUE);
            InterlockedDecrement (&pLowerConn->pDeviceContext->NumWaitingForInbound);
            CTESpinFreeAtDpc(pLowerConn);

            CTESpinFreeAtDpc(pDeviceContext);

            KdPrint(("Nbt.AcceptCompletionRoutine: error: %lx\n", pIrp->IoStatus.Status));

            if (!NBT_VERIFY_HANDLE (pLowerConn->pDeviceContext, NBT_VERIFY_DEVCONTEXT))
            {
                pDeviceContext = NULL;
            }

            NTQueueToWorkerThread(
                            &pLowerConn->WorkItemCleanUpAndWipeOut,
                            DelayedCleanupAfterDisconnect,
                            NULL,
                            pLowerConn,
                            NULL,
                            pDeviceContext,
                            TRUE
                            );

            CTESpinFree(&NbtConfig.JointLock,OldIrq);
#ifdef _NETBIOSLESS
        }
        else if (pLowerConn->State == NBT_SESSION_UP)
        {
            NTSTATUS status;
            // We are in message only mode and we need to clean up because the client rejected
            // the accept for some reason.  We are in the UP state so we need to do a heavy
            // duty cleanup.
            ASSERT( IsDeviceNetbiosless(pLowerConn->pDeviceContext) );

            CTESpinFreeAtDpc(pLowerConn);
            CTESpinFreeAtDpc(pDeviceContext);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            KdPrint(("Nbt.AcceptCompletionRoutine: Message only error: %lx\n", pIrp->IoStatus.Status));
            NbtTrace(NBT_TRACE_INBOUND, ("Message only error: %!status!", pIrp->IoStatus.Status));

            // this call will indicate the disconnect to the client and clean up abit.
            //
            status = DisconnectHndlrNotOs (NULL,
                                           (PVOID)pLowerConn,
                                           0,
                                           NULL,
                                           0,
                                           NULL,
                                           TDI_DISCONNECT_ABORT);

        }
        else
        {
            // Already disconnected
            CTESpinFreeAtDpc(pLowerConn);
            CTESpinFreeAtDpc(pDeviceContext);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }
#endif
    }
    else
    {
        CTESpinFreeAtDpc(pLowerConn);
        CTESpinFreeAtDpc(pDeviceContext);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }


    NbtFreeIrp(pIrp);

    // return this status to stop the IO subsystem from further processing the
    // IRP - i.e. trying to complete it back to the initiating thread! -since
    // there is not initiating thread - we are the initiator
    return(STATUS_MORE_PROCESSING_REQUIRED);

}

//----------------------------------------------------------------------------
NTSTATUS
TdiDisconnectHandler (
    IN PVOID                EventContext,
    IN PVOID                ConnectionContext,
    IN ULONG                DisconnectDataLength,
    IN PVOID                pDisconnectData,
    IN ULONG                DisconnectInformationLength,
    IN PVOID                pDisconnectInformation,
    IN ULONG                DisconnectIndicators
    )
/*++

Routine Description:

    This routine is called when a session is disconnected from a remote
    machine.

Arguments:

    IN PVOID EventContext,
    IN PCONNECTION_CONTEXT ConnectionContext,
    IN ULONG DisconnectDataLength,
    IN PVOID DisconnectData,
    IN ULONG DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectIndicators

Return Value:

    NTSTATUS - Status of event indicator

--*/

{

    NTSTATUS            status;
    tDEVICECONTEXT      *pDeviceContext;

    // convert the context value into the device context record ptr
    pDeviceContext = (tDEVICECONTEXT *)EventContext;

    IF_DBG(NBT_DEBUG_TDIHNDLR)
        KdPrint(("pDeviceContxt = %X ConnectEv = %X\n",pDeviceContext,ConnectionContext));
    ASSERTMSG("Bad Device context passed to the Connection Event Handler",
            pDeviceContext->Verify == NBT_VERIFY_DEVCONTEXT);

    // call the non-OS specific routine to find a free connection.

    status = DisconnectHndlrNotOs(
                EventContext,
                ConnectionContext,
                DisconnectDataLength,
                pDisconnectData,
                DisconnectInformationLength,
                pDisconnectInformation,
                DisconnectIndicators);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDIHNDLR)
            KdPrint(("NO FREE CONNECTIONS in connect handler\n"));
        return(STATUS_DATA_NOT_ACCEPTED);
    }


    return status;

}


//----------------------------------------------------------------------------
NTSTATUS
TdiRcvDatagramHandler(
    IN PVOID                pDgramEventContext,
    IN int                  SourceAddressLength,
    IN PVOID                pSourceAddress,
    IN int                  OptionsLength,
    IN PVOID                pOptions,
    IN ULONG                ReceiveDatagramFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT ULONG               *pBytesTaken,
    IN PVOID                pTsdu,
    OUT PIRP                *pIoRequestPacket
    )
/*++

Routine Description:

    This routine is the receive datagram event indication handler.

    It is called when an Datagram arrives from the network, it will look for a
    the address with an appropriate read datagram outstanding or a Datagrm
    Event handler setup.

Arguments:

    pDgramEventContext      - Context provided for this event - pab
    SourceAddressLength,    - length of the src address
    pSourceAddress,         - src address
    OptionsLength,          - options length for the receive
    pOptions,               - options
    BytesIndicated,         - number of bytes this indication
    BytesAvailable,         - number of bytes in complete Tsdu
    pTsdu                   - pointer to the datagram


Return Value:

    *pBytesTaken            - number of bytes used
    *IoRequestPacket        - Receive IRP if MORE_PROCESSING_REQUIRED.
    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS            status;
    tDEVICECONTEXT      *pDeviceContext = (tDEVICECONTEXT *)pDgramEventContext;
    tDGRAMHDR UNALIGNED *pDgram = (tDGRAMHDR UNALIGNED *)pTsdu;
    PIRP                pIrp = NULL;
    ULONG               lBytesTaken;
    tCLIENTLIST         *pClientList;
    CTELockHandle       OldIrq;

    IF_DBG(NBT_DEBUG_TDIHNDLR)
        KdPrint(( "NBT receive datagram handler pDeviceContext: %X\n",
                pDeviceContext ));

    *pIoRequestPacket = NULL;

    ASSERTMSG("NBT:Invalid Device Context passed to DgramRcv Handler!!\n",
                pDeviceContext->Verify == NBT_VERIFY_DEVCONTEXT );

    // call a non-OS specific routine to decide what to do with the datagrams
    pIrp = NULL;
    pClientList = NULL;
    status = DgramHndlrNotOs(
                    pDgramEventContext,
                    SourceAddressLength,
                    pSourceAddress,
                    OptionsLength,
                    pOptions,
                    ReceiveDatagramFlags,
                    BytesIndicated,
                    BytesAvailable,
                    &lBytesTaken,
                    pTsdu,
                    (PVOID *)&pIrp,
                    &pClientList);


    if ( !NT_SUCCESS(status) )
    {
        // fail the request back to the transport provider since we
        // could not find a receive buffer or receive handler or the
        // data was taken in the indication handler.
        //
        return(STATUS_DATA_NOT_ACCEPTED);

    }
    else
    {
        // a rcv buffer was returned, so use it for the receive.(an Irp)
        PTDI_REQUEST_KERNEL_RECEIVEDG   pParams;
        PIO_STACK_LOCATION              pIrpSp;
        ULONG                           lRcvLength;
        ULONG                           lRcvFlags;

        // When the client list is returned, we need to make up an irp to
        // send down to the transport, which we will use in the completion
        // routine to copy the data to all clients, ONLY if we are not
        // using a client buffer, so check that flag first.
        //
        if (pClientList && !pClientList->fUsingClientBuffer)
        {
            PMDL            pMdl;
            PVOID           pBuffer;

            //
            // get an irp to do the receive with and attach
            // a buffer to it.
            //
            while (1)
            {
                if (NT_SUCCESS(GetIrp(&pIrp)))
                {
                    if (pBuffer = NbtAllocMem (BytesAvailable, NBT_TAG('t')))
                    {
                        if (pMdl = IoAllocateMdl (pBuffer, BytesAvailable, FALSE, FALSE, NULL))
                        {
                            break;
                        }

                        KdPrint(("Nbt.TdiRcvDatagramHandler:  Unable to IoAllocateMdl, Kill Connection\n"));
                        CTEMemFree(pBuffer);
                    }
                    else
                    {
                        KdPrint(("Nbt.TdiRcvDatagramHandler:  Unable to allocate Buffer, Kill Connection\n"));
                    }

                    NbtFreeIrp(pIrp);
                }
                else
                {
                    KdPrint(("Nbt.TdiRcvDatagramHandler:  Unable to GetIrp, Kill Connection\n"));
                }

                if (!pClientList->fProxy)   
                {
                    //
                    // We failed, so Dereference the Client + Address we had
                    // reference earlier for multiple clients
                    //
                    NBT_DEREFERENCE_CLIENT (pClientList->pClientEle);
                    NBT_DEREFERENCE_ADDRESS (pClientList->pAddress, REF_ADDR_MULTICLIENTS);
                    CTEMemFree(pClientList->pRemoteAddress);
                }

                CTEMemFree(pClientList);
                return (STATUS_DATA_NOT_ACCEPTED);
            }

            // Map the pages in memory...
            MmBuildMdlForNonPagedPool(pMdl);
            pIrp->MdlAddress = pMdl;
            lRcvFlags = 0;
            lRcvLength = BytesAvailable;
        }
        else
        {
            ASSERT(pIrp);
            // *TODO* may have to keep track of the case where the
            // client returns a buffer that is not large enough for all of the
            // data indicated.  So the next posting of a buffer gets passed
            // directly to the transport.
            pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
            lRcvFlags = ((PTDI_REQUEST_KERNEL_RECEIVEDG)&pIrpSp->Parameters)->ReceiveFlags;
            lRcvLength = ((PTDI_REQUEST_KERNEL_RECEIVEDG)&pIrpSp->Parameters)->ReceiveLength;

            if (lRcvLength < BytesIndicated - lBytesTaken)
            {
                IF_DBG(NBT_DEBUG_TDIHNDLR)
                    KdPrint(("Nbt:Clients Buffer is too short on Rcv Dgram size= %X, needed = %X\n",
                          lRcvLength, BytesIndicated-lBytesTaken));
            }
        }

        // this code is sped up somewhat by expanding the code here rather than calling
        // the TdiBuildReceive macro
        // make the next stack location the current one.  Normally IoCallDriver
        // would do this but we are not going through IoCallDriver here, since the
        // Irp is just passed back with RcvIndication.
        ASSERT(pIrp->CurrentLocation > 1);
        IoSetNextIrpStackLocation(pIrp);
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pIrpSp->CompletionRoutine = CompletionRcvDgram;

        // pass the ClientList to the completion routine so it can
        // copy the datagram to several clients that may be listening on the
        // same name
        //
        pIrpSp->Context = (PVOID)pClientList;
        CHECK_PTR(pIrpSp);
        pIrpSp->Flags = 0;

        // set flags so the completion routine is always invoked.
        pIrpSp->Control = SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL;

        pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        pIrpSp->MinorFunction = TDI_RECEIVE_DATAGRAM;
        //
        // Verify that we have a valid Device and FileObject for TcpIp below
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        if (pDeviceContext->pFileObjects)
        {
            pIrpSp->DeviceObject = pDeviceContext->pFileObjects->pDgramDeviceObject;
            pIrpSp->FileObject = pDeviceContext->pFileObjects->pDgramFileObject;
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        pParams = (PTDI_REQUEST_KERNEL_RECEIVEDG)&pIrpSp->Parameters;
        pParams->ReceiveFlags = lRcvFlags;
        pParams->ReceiveLength = lRcvLength;

        // pass back the irp to the transport provider and increment the stack
        // location so it can write to the irp if it needs to.
        *pIoRequestPacket = pIrp;
        *pBytesTaken = lBytesTaken;

        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    //
    //  Transport will complete the processing of the request, we don't
    //  want the datagram.
    //

    IF_DBG (NBT_DEBUG_TDIHNDLR)
        KdPrint(( "NBT receive datagram handler ignored receive, pDeviceContext: %X\n",
                    pDeviceContext ));

    return STATUS_DATA_NOT_ACCEPTED;

    // to keep the compiler from generating warnings...
    UNREFERENCED_PARAMETER( SourceAddressLength );
    UNREFERENCED_PARAMETER( BytesIndicated );
    UNREFERENCED_PARAMETER( BytesAvailable );
    UNREFERENCED_PARAMETER( pBytesTaken );
    UNREFERENCED_PARAMETER( pTsdu );
    UNREFERENCED_PARAMETER( OptionsLength );
    UNREFERENCED_PARAMETER( pOptions );

}

//----------------------------------------------------------------------------
NTSTATUS
TdiRcvNameSrvHandler(
    IN PVOID             pDgramEventContext,
    IN int               SourceAddressLength,
    IN PVOID             pSourceAddress,
    IN int               OptionsLength,
    IN PVOID             pOptions,
    IN ULONG             ReceiveDatagramFlags,
    IN ULONG             BytesIndicated,
    IN ULONG             BytesAvailable,
    OUT ULONG            *pBytesTaken,
    IN PVOID             pTsdu,
    OUT PIRP             *pIoRequestPacket
    )
/*++

Routine Description:

    This routine is the Name Service datagram event indication handler.
    It gets all datagrams destined for UDP port 137


Arguments:

    pDgramEventContext      - Context provided for this event - pab
    SourceAddressLength,    - length of the src address
    pSourceAddress,         - src address
    OptionsLength,          - options length for the receive
    pOptions,               - options
    BytesIndicated,         - number of bytes this indication
    BytesAvailable,         - number of bytes in complete Tsdu
    pTsdu                   - pointer to the datagram


Return Value:

    *pBytesTaken            - number of bytes used
    *IoRequestPacket        - Receive IRP if MORE_PROCESSING_REQUIRED.
    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS            status;
    tDEVICECONTEXT      *pDeviceContext = (tDEVICECONTEXT *)pDgramEventContext;
    tNAMEHDR UNALIGNED  *pNameSrv = (tNAMEHDR UNALIGNED *)pTsdu;
    USHORT              OpCode;


    IF_DBG(NBT_DEBUG_TDIHNDLR)
        KdPrint(( "NBT: NAMEHDR datagram handler pDeviceContext: %X\n",
                pDeviceContext ));

    *pIoRequestPacket = NULL;
    //
    // check if the whole datagram has arrived yet
    //
    if (BytesIndicated != BytesAvailable)
    {
        PIRP    pIrp;
        PVOID   pBuffer;
        PMDL    pMdl;
        ULONG   Length;

        //
        // get an irp to do the receive with and attach
        // a buffer to it.
        //
        status = GetIrp(&pIrp);

        if (!NT_SUCCESS(status))
        {
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        //
        // make an Mdl for a buffer to get all of the data from
        // the transprot
        //
        Length = BytesAvailable + SourceAddressLength + sizeof(ULONG);
        Length = ((Length + 3)/sizeof(ULONG)) * sizeof(ULONG);
        pBuffer = NbtAllocMem(Length,NBT_TAG('u'));
        if (pBuffer)
        {
            PVOID   pSrcAddr;

            //
            // save the source address and length in the buffer for later
            // indication back to this routine.
            //
            *(ULONG UNALIGNED *)((PUCHAR)pBuffer + BytesAvailable) = SourceAddressLength;
            pSrcAddr = (PVOID)((PUCHAR)pBuffer + BytesAvailable + sizeof(ULONG));

            CTEMemCopy(pSrcAddr,
                       pSourceAddress,
                       SourceAddressLength);

            // Allocate a MDL and set the header sizes correctly
            pMdl = IoAllocateMdl(
                            pBuffer,
                            BytesAvailable,
                            FALSE,
                            FALSE,
                            NULL);

            if (pMdl)
            {
                // Map the pages in memory...
                MmBuildMdlForNonPagedPool(pMdl);
                pIrp->MdlAddress = pMdl;
                ASSERT(pDeviceContext);

                //
                // Build a Datagram Receive Irp (as opposed to a Connect Receive Irp)
                // Bug# 125816
                //
                TdiBuildReceiveDatagram(
                           pIrp,
                           &pDeviceContext->DeviceObject,
                           pDeviceContext->pFileObjects->pNameServerFileObject,
                           NameSrvCompletionRoutine,
                           ULongToPtr(BytesAvailable),
                           pMdl,
                           BytesAvailable,
                           NULL,
                           NULL,
                           (ULONG)TDI_RECEIVE_NORMAL);

                *pBytesTaken = 0;
                *pIoRequestPacket = pIrp;

                // make the next stack location the current one.  Normally IoCallDriver
                // would do this but we are not going through IoCallDriver here, since the
                // Irp is just passed back with RcvIndication.
                //
                ASSERT(pIrp->CurrentLocation > 1);
                IoSetNextIrpStackLocation(pIrp);

                return(STATUS_MORE_PROCESSING_REQUIRED);
            }

            CTEMemFree(pBuffer);
        }

        NbtFreeIrp(pIrp);

        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // Bug# 125279: Ensure that we have received enough data to be able to
    // read most data fields
    if (BytesIndicated < NBT_MINIMUM_QUERY) // should this be limited to 12 ?
    {
        KdPrint (("Nbt.TdiRcvNameSrvHandler: WARNING!!! Rejecting Request -- BytesIndicated=<%d> < <%d>\n",
            BytesIndicated, NBT_MINIMUM_QUERY));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    if (pWinsInfo)
    {
        USHORT  TransactionId;
        ULONG   SrcAddress;

        SrcAddress = ntohl(((PTDI_ADDRESS_IP)&((PTRANSPORT_ADDRESS)pSourceAddress)->Address[0].Address[0])->in_addr);
        //
        // Pass To Wins if:
        //
        //   1) It is a response pdu with the transaction id in the WINS range
        //               that is not a WACK...                        OR
        //   2) It is a request that is NOT broadcast....and...
        //   2) It is a name query(excluding node status requests),
        //          Allowing queries from other netbt clients
        //          allowing queries from anyone not on this machine OR
        //   3) It is a name release request.                        OR
        //   4) It is a name refresh                                 OR
        //   5) It is a name registration
        //
        OpCode = pNameSrv->OpCodeFlags;
        TransactionId = ntohs(pNameSrv->TransactId);

        if (((OpCode & OP_RESPONSE) && (TransactionId <= WINS_MAXIMUM_TRANSACTION_ID) && (OpCode != OP_WACK))
                ||
            ((!(OpCode & (OP_RESPONSE | FL_BROADCAST)))
                    &&
             ((((OpCode & NM_FLAGS_MASK) == OP_QUERY) &&
               (OpCode & FL_RECURDESIRE) &&          // not node status request
               ((TransactionId > WINS_MAXIMUM_TRANSACTION_ID) || (!SrcIsUs(SrcAddress))))
                    ||
              (OpCode & (OP_RELEASE | OP_REFRESH))
                    ||
              (OpCode & OP_REGISTRATION))))
        {
            status = PassNamePduToWins(
                              pDeviceContext,
                              pSourceAddress,
                              pNameSrv,
                              BytesIndicated);

//            NbtConfig.DgramBytesRcvd += BytesIndicated;

            //
            // if WINS took the data then tell the transport to dump the data
            // since we have buffered it already.  Otherwise, let nbt take
            // a look at the data
            //
            if (NT_SUCCESS(status))
            {
                return(STATUS_DATA_NOT_ACCEPTED);
            }
        }
    }


    // DO a quick check of the name to see if it is in the local name table
    // and reject it otherwise - for name queries only, if not the proxy
    //
    if (!(NodeType & PROXY))
    {
        ULONG       UNALIGNED   *pHdr;
        ULONG                   i,lValue;
        UCHAR                   pNameStore[NETBIOS_NAME_SIZE];
        UCHAR                   *pName;
        tNAMEADDR               *pNameAddr;
        CTELockHandle           OldIrq;

        // it must be a name query request, not a response, and not a
        // node status request, to enter this special check
        //
        OpCode = pNameSrv->OpCodeFlags;
        if (((OpCode & NM_FLAGS_MASK) == OP_QUERY) &&
            (!(OpCode & OP_RESPONSE)) &&
            (OpCode & FL_RECURDESIRE))   // not node status request
        {
            pHdr = (ULONG UNALIGNED *)pNameSrv->NameRR.NetBiosName;
            pName = pNameStore;

            // the Half Ascii portion of the netbios name is always 32 bytes long
            for (i=0; i < NETBIOS_NAME_SIZE*2 ;i +=4 )
            {
                lValue = *pHdr - 0x41414141;  // four A's
                pHdr++;
                lValue =    ((lValue & 0x0F000000) >> 16) +
                            ((lValue & 0x0F0000) >> 4) +
                            ((lValue & 0x0F00) >> 8) +
                            ((lValue & 0x0F) << 4);
                *(PUSHORT)pName = (USHORT)lValue;
                ((PUSHORT)pName)++;

            }
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            status = FindInHashTable(NbtConfig.pLocalHashTbl,
                                            pNameStore,
                                            NULL,
                                            &pNameAddr);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            if (!NT_SUCCESS(status))
            {
                *pBytesTaken = BytesIndicated;
                return(STATUS_DATA_NOT_ACCEPTED);
            }
        }
    }

    ASSERT(pDeviceContext);

    // call a non-OS specific routine to decide what to do with the datagrams
    status = NameSrvHndlrNotOs(
                    pDeviceContext,
                    pSourceAddress,
                    pNameSrv,
                    BytesIndicated,
                    (BOOLEAN)((ReceiveDatagramFlags & TDI_RECEIVE_BROADCAST) != 0));

//    NbtConfig.DgramBytesRcvd += BytesIndicated


    return status;

    // to keep the compiler from generating warnings...
    UNREFERENCED_PARAMETER( SourceAddressLength );
    UNREFERENCED_PARAMETER( BytesIndicated );
    UNREFERENCED_PARAMETER( BytesAvailable );
    UNREFERENCED_PARAMETER( pBytesTaken );
    UNREFERENCED_PARAMETER( pTsdu );
    UNREFERENCED_PARAMETER( OptionsLength );
    UNREFERENCED_PARAMETER( pOptions );

}
//----------------------------------------------------------------------------
NTSTATUS
NameSrvCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine handles the case when a name service datagram is too
    short and and Irp has to be passed back to the transport to get the
    rest of the datagram.  The irp completes through here when full.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the pConnectEle - the connection data structure

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    NTSTATUS        status;
    PIRP            pIoRequestPacket;
    ULONG           BytesTaken;
    ULONG           Offset = PtrToUlong(Context);
    PVOID           pBuffer;
    ULONG           SrcAddressLength;
    PVOID           pSrcAddress;


    IF_DBG (NBT_DEBUG_TDIHNDLR)
        KdPrint(("NameSrvCompletionRoutine pRcvBuffer: %X, Status: %X Length %X\n",
            Context, pIrp->IoStatus.Status, pIrp->IoStatus.Information));

    if (pBuffer = MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority))
    {
        SrcAddressLength = *(ULONG UNALIGNED *)((PUCHAR)pBuffer + Offset);
        pSrcAddress = (PVOID)((PUCHAR)pBuffer + Offset + sizeof(ULONG));

        if (!DeviceObject)
        {
            DeviceObject = (IoGetNextIrpStackLocation (pIrp))->DeviceObject;
        }

        //
        // just call the regular indication routine as if UDP had done it.
        //
        TdiRcvNameSrvHandler (DeviceObject,
                              SrcAddressLength,
                              pSrcAddress,
                              0,
                              NULL,
                              TDI_RECEIVE_NORMAL,
                              (ULONG) pIrp->IoStatus.Information,
                              (ULONG) pIrp->IoStatus.Information,
                              &BytesTaken,
                              pBuffer,
                              &pIoRequestPacket);

        CTEMemFree (pBuffer);
    }

    //
    // put our Irp back on its free list
    //
    IoFreeMdl (pIrp->MdlAddress);
    NbtFreeIrp(pIrp);

    return (STATUS_MORE_PROCESSING_REQUIRED);
}


//----------------------------------------------------------------------------
NTSTATUS
CompletionRcvDgram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine completes the Irp by removing the Rcv Element off the queue
    and putting it back on the free list.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the pConnectEle - the connection data structure

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    NTSTATUS                status;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    PTA_NETBIOS_ADDRESS     pRemoteAddress;
    ULONG                   RemoteAddressLength;
    ULONG                   BytesCopied;
    PVOID                   pTsdu;
    ULONG                   ReceiveFlags;
    tCLIENTLIST             *pClientList;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    ULONG                   ClientBytesTaken;
    ULONG                   DataLength;
    tADDRESSELE             *pAddress;
    tRCVELE                 *pRcvEle;
    PLIST_ENTRY             pRcvEntry;
    tDEVICECONTEXT          *pDeviceContext;
    CTEULONGLONG            AdapterMask;

    IF_DBG (NBT_DEBUG_TDIHNDLR)
        KdPrint(("CompletionRcvDgram pRcvBuffer: %X, Status: %X Length %X\n",
            Context,
            Irp->IoStatus.Status,
            Irp->IoStatus.Information ));


    // there may be several clients that want to see this datagram so check
    // the client list to see...
    //
    if (Context)
    {
        tCLIENTELE    *pClientPrev = NULL;

        //
        // Bug# 124683: Data may be invalid if Completion status was failure
        //
        if (NT_SUCCESS (Irp->IoStatus.Status))
        {
            DataLength = (ULONG)Irp->IoStatus.Information;
        }
        else
        {
            ASSERT (0);
            DataLength = 0;
        }

        pTsdu = MmGetSystemAddressForMdlSafe (Irp->MdlAddress, HighPagePriority);
        pClientList = (tCLIENTLIST *) Context;

#ifdef PROXY_NODE
        if (pClientList->fProxy)
        {
            //
            // Call the ProxyDoDgramDist
            //
            status = ProxyDoDgramDist( pTsdu, DataLength,
                                       (tNAMEADDR *)pClientList->pAddress, //NameAddr
                                       pClientList->pRemoteAddress);    //device context
        }
        else
#endif
        {
            CTESpinLock(&NbtConfig.JointLock,OldIrq);

            // for the multihomed host, we only want to distribute the inbound
            // datagram to clients on this same adapter, to avoid giving the
            // datagram to the same client several times, once for each adapter
            // it is bound to.
            //
            pDeviceContext      = pClientList->pClientEle->pDeviceContext;
            AdapterMask         = pDeviceContext->AdapterMask;

            pAddress            = pClientList->pAddress;
            pRemoteAddress      = pClientList->pRemoteAddress;
            RemoteAddressLength = pClientList->RemoteAddressLength;
            ReceiveFlags        = pClientList->ReceiveDatagramFlags;

            //
            // Since we will be traversing the ClientHead, lock
            // the Address (we have already referenced the Address
            // + Client in DgramRcvNotOs)
            //
            CTESpinLock(pAddress, OldIrq1);

            pHead               = &pClientList->pAddress->ClientHead;
            pEntry              = pHead->Flink;
            if (!pClientList->fUsingClientBuffer)
            {
                while (pEntry != pHead)
                {
                    PTDI_IND_RECEIVE_DATAGRAM  EvRcvDgram;
                    PVOID                      RcvDgramEvContext;
                    tCLIENTELE                 *pClientEle;
                    PIRP                       pRcvIrp;


                    pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

                    // for multihomed hosts only distribute the datagram to
                    // clients hooked to this device context to avoid duplicate
                    // indications
                    //
                    if ((pClientEle->Verify == NBT_VERIFY_CLIENT) &&   // as opposed to CLIENT_DOWN!
                        (pClientEle->pDeviceContext->AdapterMask == AdapterMask))
                    {
                        EvRcvDgram = pClientEle->evRcvDgram;
                        RcvDgramEvContext = pClientEle->RcvDgramEvContext;
                        RemoteAddressLength = FIELD_OFFSET(TA_NETBIOS_ADDRESS,
                                                    Address[0].Address[0].NetbiosName[NETBIOS_NAME_SIZE]);

                        //
                        // Bug # 452211 -- since one of the clients may have the Extended
                        // addressing field set, set the # of addresses accordingly
                        //
                        if (pClientEle->ExtendedAddress)
                        {
                            pRemoteAddress->TAAddressCount = 2;
                            RemoteAddressLength += FIELD_OFFSET(TA_ADDRESS, Address) + sizeof(TDI_ADDRESS_IP);
                        }
                        else
                        {
                            pRemoteAddress->TAAddressCount = 1;
                        }

                        NBT_REFERENCE_CLIENT(pClientEle);

                        CTESpinFree(pAddress, OldIrq1);
                        CTESpinFree(&NbtConfig.JointLock, OldIrq);

                        // dereference the previous client in the list
                        if (pClientPrev)
                        {
                            NBT_DEREFERENCE_CLIENT(pClientPrev);
                        }
                        pClientPrev = pClientEle;

                        pRcvIrp = NULL;

                        ClientBytesTaken = 0;

                        status = (*EvRcvDgram) (RcvDgramEvContext,
                                                RemoteAddressLength,
                                                pRemoteAddress,
                                                0,
                                                NULL,
#ifndef VXD
                                                ReceiveFlags,
#endif
                                                DataLength,
                                                DataLength,
                                                &ClientBytesTaken,
                                                pTsdu,
                                                &pRcvIrp);

                        if (!pRcvIrp)
                        {
                            // if no buffer is returned, then the client is done
                            // with the data so go to the next client ...since it may
                            // be possible to process all clients in this loop without
                            // ever sending an irp down to the transport
                            // free the remote address mem block

                            status = STATUS_DATA_NOT_ACCEPTED;
                        }
                        else
                        {

                            // the client has passed back an irp so
                            // copy the data to the client's Irp
                            //
                            TdiCopyBufferToMdl(pTsdu,
                                            ClientBytesTaken,
                                            DataLength - ClientBytesTaken,
                                            pRcvIrp->MdlAddress,
                                            0,
                                            &BytesCopied);

                            // length is copied length (since the MDL may be
                            // too short to take it all)
                            //
                            if (BytesCopied < (DataLength-ClientBytesTaken))
                            {
                                pRcvIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

                            }
                            else
                            {
                                pRcvIrp->IoStatus.Status = STATUS_SUCCESS;
                            }

                            pRcvIrp->IoStatus.Information = BytesCopied;

                            IoCompleteRequest(pRcvIrp,IO_NETWORK_INCREMENT);
                        }

                        CTESpinLock(&NbtConfig.JointLock, OldIrq);
                        CTESpinLock(pAddress, OldIrq1);
                    }
                    // this code is protected from a client removing itself
                    // from the list of clients attached to an address by
                    // referencing the client prior to releasing the spin lock
                    // on the address.  The client element does not get
                    // removed from the address list until its ref count goes
                    // to zero. We must hold the joint spin lock to prevent the
                    // next client from deleting itself from the list before we
                    // can increment its reference count.
                    //
                    pEntry = pEntry->Flink;

                } // of while(pEntry != pHead)
            }
            else
            {
                // *** Client Has posted a receive Buffer, rather than using
                // *** receive handler - VXD case!
                // ***
                while (pEntry != pHead)
                {
                    tCLIENTELE                 *pClientEle;
                    PIRP                       pRcvIrp;

                    pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

                    // for multihomed hosts only distribute the datagram to
                    // clients hooked to this device context to avoid duplicate
                    // indications
                    //
                    if (pClientEle->pDeviceContext->AdapterMask == AdapterMask)
                    {
                        if (pClientEle == pClientList->pClientEle)
                        {
                            // this is the client whose buffer we are using - it is
                            // passed up to the client after all other clients
                            // have been processed.
                            //
                            pEntry = pEntry->Flink;
                            continue;
                        }

                        // check for datagrams posted to this name
                        //
                        if (!IsListEmpty(&pClientEle->RcvDgramHead))
                        {

                            pRcvEntry = RemoveHeadList(&pClientEle->RcvDgramHead);
                            pRcvEle   = CONTAINING_RECORD(pRcvEntry,tRCVELE,Linkage);
                            pRcvIrp   = pRcvEle->pIrp;

                            //
                            // copy the data to the client's Irp
                            //
                            TdiCopyBufferToMdl(pTsdu,
                                            0,
                                            DataLength,
                                            pRcvIrp->MdlAddress,
                                            0,
                                            &BytesCopied);

                            // length is copied length (since the MDL may be too short to take it all)
                            if (BytesCopied < DataLength)
                            {
                                pRcvIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

                            }
                            else
                            {
                                pRcvIrp->IoStatus.Status = STATUS_SUCCESS;
                            }

                            pRcvIrp->IoStatus.Information = BytesCopied;

                            //
                            // Increment the RefCount so that this Client hangs around!
                            //
                            NBT_REFERENCE_CLIENT (pClientEle);
                            CTESpinFree(pAddress, OldIrq1);
                            CTESpinFree(&NbtConfig.JointLock, OldIrq);

                            //
                            // undo the InterlockedIncrement to the Previous client
                            //
                            if (pClientPrev)
                            {
                                NBT_DEREFERENCE_CLIENT(pClientPrev);
                            }
                            pClientPrev = pClientEle;

                            IoCompleteRequest(pRcvIrp,IO_NETWORK_INCREMENT);

                            // free the receive block
                            CTEMemFree((PVOID)pRcvEle);
                            CTESpinLock(&NbtConfig.JointLock, OldIrq);
                            CTESpinLock(pAddress, OldIrq1);
                        }

                        pEntry = pEntry->Flink;
                    }
                } // of while(pEntry != pHead)

                CTESpinFree(pAddress, OldIrq1);
                CTESpinFree(&NbtConfig.JointLock, OldIrq);

                // undo the InterlockedIncrement on the refcount
                if (pClientPrev)
                {
                    NBT_DEREFERENCE_CLIENT(pClientPrev);
                }

                //
                // The Client + Address were referenced in DgramRcvNotOs to be sure they did not
                // disappear until this dgram rcv was done, which is now.
                //
                NBT_DEREFERENCE_CLIENT (pClientList->pClientEle); // Bug#: 124675
                NBT_DEREFERENCE_ADDRESS (pClientList->pAddress, REF_ADDR_MULTICLIENTS);

                // free the remote address structure and the client list
                // allocated in DgramHndlrNotOs
                //
                CTEMemFree (pClientList->pRemoteAddress);
                CTEMemFree (pClientList);

                // returning success allows the IO subsystem to complete the
                // irp that we used to get the data - i.e. one client's
                // buffer
                //
                return(STATUS_SUCCESS);
            }

            CTESpinFree(pAddress, OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            // dereference the previous client in the list from the RcvHANDLER
            // case a page or so above...
            //
            if (pClientPrev)
            {
                NBT_DEREFERENCE_CLIENT(pClientPrev);
            }

            //
            // The Client + Address were referenced in DgramRcvNotOs to be sure they did not
            // disappear until this dgram rcv was done, which is now.
            //
            NBT_DEREFERENCE_CLIENT (pClientList->pClientEle); // Bug#: 124675
            NBT_DEREFERENCE_ADDRESS (pClientList->pAddress, REF_ADDR_MULTICLIENTS);
        }

        //
        // Free the buffers allocated
        //
        if (!pClientList->fProxy)
        {
            CTEMemFree (pClientList->pRemoteAddress);
        }
        CTEMemFree (pClientList);

        CTEMemFree(pTsdu);

        //
        // Free the Mdl + put the Irp back on its free list
        //
        IF_DBG(NBT_DEBUG_RCV)
            KdPrint(("****Freeing Mdl: Irp = %X Mdl = %X\n",Irp,Irp->MdlAddress));
        IoFreeMdl(Irp->MdlAddress);
        NbtFreeIrp(Irp);

        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    // for the single receive case this passes the rcv up to the client
    //
    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER( DeviceObject );
}


//----------------------------------------------------------------------------
NTSTATUS
TdiErrorHandler (
    IN PVOID Context,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine is called on any error indications passed back from the
    transport. It implements LAN_STATUS_ALERT.

Arguments:

    Context     - Supplies the pfcb for the address.

    Status      - Supplies the error.

Return Value:

    NTSTATUS - Status of event indication

--*/

{
#ifdef _NETBIOSLESS
    tDEVICECONTEXT *pDeviceContext = (tDEVICECONTEXT *)Context;

    // If NB-full trys to contact NB-less host, we may get this error
    if ( (Status == STATUS_PORT_UNREACHABLE) ||
         (Status == STATUS_HOST_UNREACHABLE))
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }
    // TODO: Log a message here
    KdPrint(("Nbt.TdiErrorHandler: TDI error event notification\n\tDevice %x\n\tStatus: 0x%x\n",
            pDeviceContext, Status));
#else
    KdPrint(("Nbt.TdiErrorHandler: Error Event HAndler hit unexpectedly\n"));
#endif
    return(STATUS_DATA_NOT_ACCEPTED);
}


//----------------------------------------------------------------------------
VOID
SumMdlLengths (
    IN PMDL         pMdl,
    IN ULONG        BytesCopied,
    IN tCONNECTELE  *pConnectEle
    )

/*++

Routine Description:

    This routine is called to sum the lengths of MDLs in a chain.

Arguments:


Return Value:

    NTSTATUS - Status of event indication

--*/

{
    ULONG       TotalLength;

    TotalLength = 0;

    do
    {
        if ((TotalLength + MmGetMdlByteCount(pMdl)) > BytesCopied)
        {
            pConnectEle->OffsetFromStart = BytesCopied - TotalLength;
            pConnectEle->pNextMdl = pMdl;
            break;
        }
        else
        {
            TotalLength += MmGetMdlByteCount(pMdl);
        }
    }
    while (pMdl=(PMDL)pMdl->Next);

    return;
}


//----------------------------------------------------------------------------
VOID
MakePartialMdl (
    IN tCONNECTELE      *pConnEle,
    IN PIRP             pIrp,
    IN ULONG            ToCopy
    )

/*++

Routine Description:

    This routine is called to build a partial Mdl that accounts for ToCopy
    bytes of data being copied to the start of the Client's Mdl.

Arguments:

    pConnEle    - ptr to the connection element

Return Value:

    NTSTATUS - Status of event indication

--*/

{
    PMDL        pNewMdl;
    PVOID       NewAddress;

    // Build a partial Mdl to represent the client's Mdl chain since
    // we have copied data to it, and the transport must copy
    // more data to it after that data.
    //
    SumMdlLengths(pIrp->MdlAddress,ToCopy,pConnEle);

    // this routine has set the Mdl that the next data starts at and
    // the offset from the start of that Mdl, so create a partial Mdl
    // to map that buffer and tack it on the mdl chain instead of the
    // original
    //
    pNewMdl = pConnEle->pNewMdl;
    NewAddress = (PVOID)((PUCHAR)MmGetMdlVirtualAddress(pConnEle->pNextMdl)
                        + pConnEle->OffsetFromStart);

    if ((MmGetMdlByteCount(pConnEle->pNextMdl) - pConnEle->OffsetFromStart) > MAXUSHORT)
    {
        IoBuildPartialMdl(pConnEle->pNextMdl,pNewMdl,NewAddress,MAXUSHORT);
    }
    else
    {
        IoBuildPartialMdl(pConnEle->pNextMdl,pNewMdl,NewAddress,0);
    }

    // hook the new partial mdl to the front of the MDL chain
    //
    pNewMdl->Next = pConnEle->pNextMdl->Next;

    pIrp->MdlAddress = pNewMdl;
    ASSERT(pNewMdl);
}
//----------------------------------------------------------------------------
VOID
CopyToStartofIndicate (
    IN tLOWERCONNECTION       *pLowerConn,
    IN ULONG                  DataTaken
    )

/*++

Routine Description:

    This routine is called to copy data remaining in the indicate buffer to
    the head of the indicate buffer.

Arguments:

    pLowerConn    - ptr to the lower connection element

Return Value:

    none

--*/

{
    PVOID       pSrc;
    ULONG       DataLeft;
    PVOID       pMdl;


    DataLeft = pLowerConn->BytesInIndicate;

    pMdl = (PVOID)MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl);

    pSrc = (PVOID)( (PUCHAR)pMdl + DataTaken);

    CTEMemCopy(pMdl,pSrc,DataLeft);

}

//----------------------------------------------------------------------------

ULONG   FailuresSinceLastLog = 0;

NTSTATUS
OutOfRsrcKill(
    OUT tLOWERCONNECTION    *pLowerConn)

/*++
Routine Description:

    This Routine handles killing a connection when an out of resource condition
    occurs.  It uses a special Irp that it has saved away, and a linked list
    if that irp is currently in use.

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                    status;
    CTELockHandle               OldIrq;
    CTELockHandle               OldIrq1;
    PIRP                        pIrp;
    PFILE_OBJECT                pFileObject;
    PDEVICE_OBJECT              pDeviceObject;
    tDEVICECONTEXT              *pDeviceContext = pLowerConn->pDeviceContext;
    CTESystemTime               CurrentTime;

    CTESpinLock(pDeviceContext,OldIrq);
    CTESpinLock(&NbtConfig,OldIrq1);

    //
    // TCP could fail a TDI_RECEIVE requests upon a disconnection.
    // Don't go through the OutOfRsrcKill logic in this case.
    //

    if (pLowerConn->bNoOutRsrcKill) {
        CTESpinFree(&NbtConfig,OldIrq1);
        CTESpinFree(pDeviceContext,OldIrq);

        return STATUS_SUCCESS;
    }

    //
    // If we have not logged any event recently, then log an event!
    //
    CTEQuerySystemTime (CurrentTime);

    FailuresSinceLastLog++;
    if (pLowerConn->pUpperConnection &&     // Log it only when the connection hasn't been disconnected
            (CurrentTime.QuadPart-NbtConfig.LastOutOfRsrcLogTime.QuadPart) > ((ULONGLONG) ONE_HOUR*10000))
    {
        NbtLogEvent (EVENT_NBT_NO_RESOURCES, FailuresSinceLastLog, 0x117);
        NbtConfig.LastOutOfRsrcLogTime = CurrentTime;
        FailuresSinceLastLog = 0;
    }

    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_OUT_OF_RSRC);
    if (NbtConfig.OutOfRsrc.pIrp)
    {
        // get an Irp to send the message in
        pIrp = NbtConfig.OutOfRsrc.pIrp;
        NbtConfig.OutOfRsrc.pIrp = NULL;

        pFileObject = pLowerConn->pFileObject;
        ASSERT (pFileObject->Type == IO_TYPE_FILE);
        pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

        CTESpinFree(&NbtConfig,OldIrq1);
        CTESpinFree(pDeviceContext,OldIrq);

        // store some context stuff in the Irp stack so we can call the completion
        // routine set by the Udpsend code...
        TdiBuildDisconnect(
            pIrp,
            pDeviceObject,
            pFileObject,
            RsrcKillCompletion,
            pLowerConn,               //context value passed to completion routine
            NULL,               // Timeout...
            TDI_DISCONNECT_ABORT,
            NULL,               // send connection info
            NULL);              // return connection info

        CHECK_PTR(pIrp);
        pIrp->MdlAddress = NULL;

        CHECK_COMPLETION(pIrp);
        status = IoCallDriver(pDeviceObject,pIrp);

        IF_DBG(NBT_DEBUG_REF)
        KdPrint(("Nbt.OutOfRsrcKill: Kill connection, %X\n",pLowerConn));

        return(status);

    }
    else
    {
        //
        // The lower conn could get removed here, then get dequed from the ConnectionHead and come here
        // (via DpcNextOutOfRsrcKill), and fail to get an Irp; we re-enque it into the OutOfRsrc list,
        // but should not try to deque it here.
        //
        if (!pLowerConn->OutOfRsrcFlag)
        {
            RemoveEntryList(&pLowerConn->Linkage);

            //
            // The lower conn gets removed from the inactive list here and again when
            // DelayedCleanupAfterDisconnect calls NbtDeleteLowerConn. In order to prevent
            // the second deque, we set a flag here and test for it in NbtDeleteLowerConn.
            //
            pLowerConn->OutOfRsrcFlag = TRUE;
        }

        pLowerConn->Linkage.Flink = pLowerConn->Linkage.Blink = (PLIST_ENTRY)0x00006041;
        InsertTailList(&NbtConfig.OutOfRsrc.ConnectionHead,&pLowerConn->Linkage);

        CTESpinFree(&NbtConfig,OldIrq1);
        CTESpinFree(pDeviceContext,OldIrq);
    }

    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
NTSTATUS
RsrcKillCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
/*++

Routine Description:

    This routine handles the completion of a disconnect to the transport.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS            status;
    KIRQL               OldIrq;
    PLIST_ENTRY         pEntry;
    tLOWERCONNECTION    *pLowerConn;
    PKDPC               pDpc;



    pLowerConn = (tLOWERCONNECTION *)pContext;

    // this call will indicate the disconnect to the client and clean up
    // abit.
    //
    status = DisconnectHndlrNotOs (NULL,
                                   (PVOID)pLowerConn,
                                   0,
                                   NULL,
                                   0,
                                   NULL,
                                   TDI_DISCONNECT_ABORT);

    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_OUT_OF_RSRC, FALSE);

    CTESpinLock(&NbtConfig,OldIrq);
    NbtConfig.OutOfRsrc.pIrp = pIrp;

    if (!IsListEmpty(&NbtConfig.OutOfRsrc.ConnectionHead))
    {
        if (NbtConfig.OutOfRsrc.pDpc)
        {
            pDpc = NbtConfig.OutOfRsrc.pDpc;
            NbtConfig.OutOfRsrc.pDpc = NULL;

            pEntry = RemoveHeadList(&NbtConfig.OutOfRsrc.ConnectionHead);
            pLowerConn = CONTAINING_RECORD(pEntry,tLOWERCONNECTION,Linkage);

            pLowerConn->Linkage.Flink = pLowerConn->Linkage.Blink = (PLIST_ENTRY)0x00006109;
            KeInitializeDpc(pDpc, DpcNextOutOfRsrcKill, (PVOID)pLowerConn);
            KeInsertQueueDpc(pDpc,NULL,NULL);

            CTESpinFree(&NbtConfig,OldIrq);
        }
        else
        {
            CTESpinFree(&NbtConfig,OldIrq);
        }
    }
    else
    {
        CTESpinFree(&NbtConfig,OldIrq);
    }

    //
    // return this status to stop the IO subsystem from further processing the
    // IRP - i.e. trying to complete it back to the initiating thread! -since
    // there is no initiating thread - we are the initiator
    //
    return(STATUS_MORE_PROCESSING_REQUIRED);
}


//----------------------------------------------------------------------------
VOID
DpcNextOutOfRsrcKill(
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    )
/*++

Routine Description:

    This routine simply calls OutOfRsrcKill from a Dpc started in
    RsrcKillCompletion.

Arguments:


Return Value:
--*/
{

    KIRQL               OldIrq;
    tLOWERCONNECTION   *pLowerConn;


    pLowerConn = (tLOWERCONNECTION *)Context;

    CTESpinLock(&NbtConfig,OldIrq);
    NbtConfig.OutOfRsrc.pDpc = pDpc;
    CTESpinFree(&NbtConfig,OldIrq);

    OutOfRsrcKill(pLowerConn);

    //
    // to remove the extra reference put on pLowerConn when OutOfRsrc called
    //
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_OUT_OF_RSRC, FALSE);
}


//----------------------------------------------------------------------------
VOID
NbtCancelFillIrpRoutine(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a Receive Irp that has been saved
    during the FILL_IRP state. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tCONNECTELE          *pConnEle;
    KIRQL                OldIrq;
    KIRQL                OldIrq1;
    KIRQL                OldIrq2;
    PIO_STACK_LOCATION   pIrpSp;
    tLOWERCONNECTION     *pLowerConn;
    BOOLEAN              CompleteIt = FALSE;

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt.NbtCancelFillIrpRoutine: Got a Receive Cancel Irp !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NbtCancelFillIrpRoutine: ERROR - Invalid Connection Handle\n", 0);
        // complete the irp
        pIrp->IoStatus.Status = STATUS_INVALID_HANDLE;
        IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

        return;
    }

    // now look for an Irp to cancel
    //
    CHECK_PTR(pConnEle);
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    CTESpinLock(pConnEle,OldIrq);

    pLowerConn = pConnEle->pLowerConnId;
    if (pLowerConn)
    {
        CTESpinLock(pLowerConn,OldIrq2);
        SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, RejectAnyData);
    }

    pConnEle->pIrpRcv = NULL;

    if (pLowerConn)
    {
        CTESpinFree(pLowerConn,OldIrq2);
    }

    CTESpinFree(pConnEle,OldIrq);
    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    // complete the irp
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

    if (pLowerConn)
    {
        //
        // Cancelling a Rcv Irp in the fill irp state will cause netbt
        // to lose track of where it is in the message so it must kill
        // the connection.
        //
        OutOfRsrcKill(pLowerConn);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\flt\debug.h ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	debug.h
//
// Description: Debug macros definitions
//
// Author:	Stefan Solomon (stefans)    October 4, 1993.
//
// Revision History:
//
//***

#ifndef _IPXFLT_DEBUG_
#define _IPXFLT_DEBUG_

#if DBG
extern ULONG DbgLevel;
#define DBG_IOCTLS		0x00000001
#define DBG_FWDIF		0x00000002
#define DBG_IFHASH		0x00000010
#define DBG_PKTCACHE	0x00000020
#define DBG_PKTLOGS		0x00000100
#define DBG_ERRORS		0x10000000

#define DEF_DBG_LEVEL	(DBG_IOCTLS|DBG_FWDIF|DBG_ERRORS|DBG_IFHASH)

#define IpxFltDbgPrint(LEVEL,ARGS)										\
	do {															    \
		if (DbgLevel & (LEVEL)) {										\
			DbgPrint ARGS;											    \
		}															    \
	} while (0)

#else
#define IpxFltDbgPrint(LEVEL,ARGS) do {NOTHING;} while (0)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\tdiout.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Tdiout.c

Abstract:


    This file represents the TDI interface on the bottom edge of NBT.
    The procedures herein conform to the TDI I/F spec. and then convert
    the information to NT specific Irps etc.  This implementation can be
    changed out to run on another OS.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/


#include "precomp.h"   // procedure headings

#include "tdiout.tmh"

// function prototypes for completion routines used in this file
NTSTATUS
TdiSendDatagramCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pSendbufferMdl
    );
NTSTATUS
TcpConnectComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );
NTSTATUS
TcpDisconnectComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );
NTSTATUS
SendSessionCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );

// DEBUG
VOID
CheckIrpList(
    );

//----------------------------------------------------------------------------
NTSTATUS
TdiSendDatagram(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  PTDI_CONNECTION_INFORMATION     pSendDgramInfo,
    IN  ULONG                           SendLength,
    OUT PULONG                          pSentSize,
    IN  tDGRAM_SEND_TRACKING            *pDgramTracker
    )
/*++

Routine Description:

    This routine sends a datagram to the transport

Arguments:

    pSendBuffer     - this is really an Mdl in NT land.  It must be tacked on
                      the end of the Mdl created for the Nbt datagram header.

Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS         status;
    PIRP             pRequestIrp;
    PMDL             pMdl;
    PDEVICE_OBJECT   pDeviceObject;
    PFILE_OBJECT     pFileObject;
    PVOID            pCompletionRoutine;
    tBUFFER          *pSendBuffer = &pDgramTracker->SendBuffer;

    // get an Irp to send the message in
    pFileObject = (PFILE_OBJECT)pRequestInfo->Handle.AddressHandle;
    pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

    status = GetIrp(&pRequestIrp);      // get an Irp from the list
    if (NT_SUCCESS(status))
    {
        pRequestIrp->CancelRoutine = NULL;

        // set up the completion routine passed in from Udp Send using the APC
        // fields in the Irp that would normally be used to complete the request
        // back to the client - although we are really the client here so we can
        // use these fields our self!
        pRequestIrp->Overlay.AsynchronousParameters.UserApcRoutine =
                                (PIO_APC_ROUTINE)pRequestInfo->RequestNotifyObject;
        pRequestIrp->Overlay.AsynchronousParameters.UserApcContext = (PVOID)pRequestInfo->RequestContext;

        // Allocate a MDL and set the head sizes correctly
        if (!(pMdl = IoAllocateMdl (pSendBuffer->pDgramHdr, pSendBuffer->HdrLength, FALSE, FALSE, NULL)))
        {
            NbtFreeIrp(pRequestIrp);

            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        IF_DBG(NBT_DEBUG_TDIOUT)
            KdPrint(("Nbt.TdiSendDatagram: Failed to get an Irp"));
    }

    // tack the client's send buffer (MDL) onto the end of the datagram header
    // Mdl, and then pass the irp on downward to the transport
    if (NT_SUCCESS(status) && pSendBuffer->pBuffer) {
        pMdl->Next = IoAllocateMdl (pSendBuffer->pBuffer, pSendBuffer->Length, FALSE, FALSE, NULL);
        if (pMdl->Next == NULL) {
            NbtFreeIrp(pRequestIrp);

            status = STATUS_INSUFFICIENT_RESOURCES;
            IoFreeMdl(pMdl);
            pMdl = NULL;
        }
    }

    if (!NT_SUCCESS(status))
    {
        if (pRequestInfo->RequestNotifyObject)  // call the completion routine (if there is one)
        {
            NBT_DEREFERENCE_DEVICE (pDgramTracker->pDeviceContext, REF_DEV_UDP_SEND, FALSE);

            (*((NBT_COMPLETION)pRequestInfo->RequestNotifyObject))
                        ((PVOID)pRequestInfo->RequestContext,
                         STATUS_INSUFFICIENT_RESOURCES,
                         0L);
        }

        return(STATUS_PENDING);         // so the Irp is not completed twice.
    }

    // Map the pages in memory...
    ASSERT(!pSendBuffer->pBuffer || pMdl->Next);
    MmBuildMdlForNonPagedPool(pMdl);
    if (pMdl->Next) {
        MmBuildMdlForNonPagedPool(pMdl->Next);
    }
    pCompletionRoutine = TdiSendDatagramCompletion;

    // store some context stuff in the Irp stack so we can call the completion
    // routine set by the Udpsend code...
    TdiBuildSendDatagram (pRequestIrp,
                          pDeviceObject,
                          pFileObject,
                          pCompletionRoutine,
                          (PVOID)pMdl->Next,   // The completion routine will know that we have allocated an extra MDL
                          pMdl,
                          SendLength,
                          pSendDgramInfo);

    CHECK_COMPLETION(pRequestIrp);
    status = IoCallDriver(pDeviceObject,pRequestIrp);
    *pSentSize = SendLength;            // Fill in the SentSize

    // The transport always completes the IRP, so as long as the irp made it
    // to the transport it got completed. The return code from the transport
    // does not indicate if the irp was completed or not.  The real status
    // of the operation is in the Irp Iostatus return code.
    // What we need to do is make sure NBT does not complete the irp AND the
    // transport complete the Irp.  Therefore this routine returns
    // status pending if the Irp was passed to the transport, regardless of
    // the return code from the transport.  This return code signals the caller
    // that the irp will be completed via the completion routine and the
    // actual status of the send can be found in the Irpss IoStatus.Status
    // variable.
    //
    // If the Caller of this routine gets a bad return code, they can assume
    // that this routine failed to give the Irp to the transport and it
    // is safe for them to complete the Irp themselves.
    //
    // If the Completion routine is set to null, then there is no danger
    // of the irp completing twice and this routine will return the transport
    // return code in that case.

    if (pRequestInfo->RequestNotifyObject)
    {
        return(STATUS_PENDING);
    }
    else
    {
        return(status);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
TdiSendDatagramCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pSendbufferMdl
    )
/*++

Routine Description:

    This routine handles the completion of a datagram send to the transport.
    It must call the client completion routine and free the Irp and Mdl.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    KIRQL                   OldIrq;
    tDGRAM_SEND_TRACKING    *pTracker = pIrp->Overlay.AsynchronousParameters.UserApcContext;
    tDEVICECONTEXT          *pDeviceContext;

    // check for a completion routine of the clients to call...
    if (pIrp->Overlay.AsynchronousParameters.UserApcRoutine)
    {
        //
        // The Tracker can be free'ed in the routine below, so save the Device ptr
        //
        pDeviceContext = pTracker->pDeviceContext;

        (*((NBT_COMPLETION)pIrp->Overlay.AsynchronousParameters.UserApcRoutine))
                        ((PVOID)pIrp->Overlay.AsynchronousParameters.UserApcContext,
                         pIrp->IoStatus.Status,
                         (ULONG)pIrp->IoStatus.Information);    // sent length

        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_UDP_SEND, FALSE);
    }

    // Don't depend on pIrp->MdlAddress->Next which may occassionally changed by others
    ASSERT((PMDL)pSendbufferMdl == pIrp->MdlAddress->Next);
    if (pSendbufferMdl) {
        IoFreeMdl((PMDL)pSendbufferMdl);
    }
    // deallocate the MDL.. this is done by the IO subsystem in IoCompleteRequest
    pIrp->MdlAddress->Next = NULL;
    IoFreeMdl(pIrp->MdlAddress);
    NbtFreeIrp(pIrp);

    // return this status to stop the IO subsystem from further processing the
    // IRP - i.e. trying to complete it back to the initiating thread! -since
    // there is no initiating thread - we are the initiator
    return(STATUS_MORE_PROCESSING_REQUIRED);
}



//----------------------------------------------------------------------------
PIRP
NTAllocateNbtIrp(
    IN PDEVICE_OBJECT   DeviceObject
    )
/*++

Routine Description:

    This routine allocates an irp by calling the IO system, and then it
    undoes the queuing of the irp to the current thread, since these are
    NBTs own irps, and should not be attached to a thread.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    PIRP                pIrp;



    // call the IO subsystem to allocate the irp

    pIrp = IoAllocateIrp(DeviceObject->StackSize,FALSE);

    if (!pIrp)
    {
        return(NULL);
    }
    //
    // Simply return a pointer to the packet.
    //

    return pIrp;

}

//----------------------------------------------------------------------------
NTSTATUS
TdiConnect(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  ULONG_PTR                       lTimeout,
    IN  PTDI_CONNECTION_INFORMATION     pSendInfo,
    IN  PIRP                            pClientIrp
    )
/*++

Routine Description:

    This routine sends a connect request to the tranport provider, to setup
    a connection to the other side...

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS         status;
    PIRP             pRequestIrp;
    PDEVICE_OBJECT   pDeviceObject;
    PFILE_OBJECT     pFileObject;

    // get an Irp to send the message in
    pFileObject = (PFILE_OBJECT)pRequestInfo->Handle.AddressHandle;
    pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

    // get an Irp from the list
    status = GetIrp(&pRequestIrp);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDIOUT)
            KdPrint(("Nbt.TdiConnect: Failed to get an Irp"));
        // call the completion routine with this status
       (*((NBT_COMPLETION)pRequestInfo->RequestNotifyObject))
                   ((PVOID)pRequestInfo->RequestContext,
                    STATUS_INSUFFICIENT_RESOURCES,
                    0L);
        return(STATUS_PENDING);
    }
    pRequestIrp->CancelRoutine = NULL;

    // set up the completion routine passed in from Tcp SessionStart using the APC
    // fields in the Irp that would normally be used to complete the request
    // back to the client - although we are really the client here so we can
    // use these fields ourselves
    pRequestIrp->Overlay.AsynchronousParameters.UserApcRoutine =
                            (PIO_APC_ROUTINE)pRequestInfo->RequestNotifyObject;
    pRequestIrp->Overlay.AsynchronousParameters.UserApcContext =
                            (PVOID)pRequestInfo->RequestContext;

    // store some context stuff in the Irp stack so we can call the completion
    // routine set by the Udpsend code...
    TdiBuildConnect(
        pClientIrp,
        pDeviceObject,
        pFileObject,
        TcpConnectComplete,
        (PVOID)pRequestIrp,   //context value passed to completion routine
        lTimeout,           // use timeout on connect
        pSendInfo,
        NULL);

    NbtTrace(NBT_TRACE_LOWER_EDGE, ("TCP TDI_CONNECT pIrp %p", pClientIrp));

    pRequestIrp->MdlAddress = NULL;

    CHECK_COMPLETION(pClientIrp);
    status = IoCallDriver(pDeviceObject,pClientIrp);

    // the transport always completes the IRP, so we always return status pending
    return(STATUS_PENDING);

}


//----------------------------------------------------------------------------
NTSTATUS
TdiDisconnect(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  PVOID                           lTimeout,
    IN  ULONG                           Flags,
    IN  PTDI_CONNECTION_INFORMATION     pSendInfo,
    IN  PCTE_IRP                        pClientIrp,
    IN  BOOLEAN                         Wait
    )
/*++

Routine Description:

    This routine sends a connect request to the tranport provider, to setup
    a connection to the other side...

Arguments:

    pClientIrp - this is the irp that the client used when it issued an
                 NbtDisconnect.  We pass this irp to the transport so that
                 the client can do a Ctrl C and cancel the irp if the
                 disconnect takes too long.

Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS         status;
    PIRP             pRequestIrp;
    PDEVICE_OBJECT   pDeviceObject;
    PFILE_OBJECT     pFileObject;

    // get an Irp to send the message in
    pFileObject = (PFILE_OBJECT)pRequestInfo->Handle.AddressHandle;
    pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

    status = GetIrp(&pRequestIrp);
    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDIOUT)
            KdPrint(("Nbt.TdiDisconnect: Failed to get an Irp"));

        //
        // When Wait is set, the caller doesn't expect the completion routine
        // to be called!!!
        //
        if (!Wait) {
            // call the completion routine with this status
            (*((NBT_COMPLETION)pRequestInfo->RequestNotifyObject))
                       ((PVOID)pRequestInfo->RequestContext,
                        STATUS_INSUFFICIENT_RESOURCES,
                        0L);
            return STATUS_PENDING;
        } else {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    if (!pClientIrp)
    {
        // if no client irp was passed in, then just use our Irp
        pClientIrp = pRequestIrp;
    }
    pRequestIrp->CancelRoutine = NULL;

    // set up the completion routine passed in from Tcp SessionStart using the APC
    // fields in the Irp that would normally be used to complete the request
    // back to the client - although we are really the client here so we can
    // use these fields ourselves
    pRequestIrp->Overlay.AsynchronousParameters.UserApcRoutine =
                            (PIO_APC_ROUTINE)pRequestInfo->RequestNotifyObject;
    pRequestIrp->Overlay.AsynchronousParameters.UserApcContext =
                            (PVOID)pRequestInfo->RequestContext;

    // store some context stuff in the Irp stack so we can call the completion
    // routine set by the Udpsend code...
    // Note that pRequestIrp is passed to the completion routine as a context
    // value so we will know the routine to call for the client's completion.
    TdiBuildDisconnect(
        pClientIrp,
        pDeviceObject,
        pFileObject,
        TcpConnectComplete,
        (PVOID)pRequestIrp,   //context value passed to completion routine
        lTimeout,
        Flags,
        NULL,          // send connection info
        NULL);              // return connection info

    NbtTrace(NBT_TRACE_LOWER_EDGE, ("TCP TDI_DISCONNECT pIrp %p", pClientIrp));

    pRequestIrp->MdlAddress = NULL;

    // if Wait is set, then this means do a synchronous disconnect and block
    // until the irp is returned.
    //
    if (Wait)
    {
        status = SubmitTdiRequest(pFileObject,pClientIrp);
        if (!NT_SUCCESS(status))
        {
            IF_DBG(NBT_DEBUG_TDIOUT)
                KdPrint (("Nbt.TdiDisconnect:  ERROR -- SubmitTdiRequest returned <%x>\n", status));
        }

        NbtFreeIrp(pRequestIrp);
        return(status);
    }
    else
    {
        CHECK_COMPLETION(pClientIrp);
        status = IoCallDriver(pDeviceObject,pClientIrp);
        // the transport always completes the IRP, so we always return status pending
        return(STATUS_PENDING);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
TcpConnectComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
/*++

Routine Description:

    This routine handles the completion of a TCP session setup.  The TCP
    connection is either setup or not depending on the status returned here.
    It must called the clients completion routine (in udpsend.c).  Which should
    look after sending the NetBios sesion startup pdu across the TCP connection.

    The pContext value is actually one of NBTs irps that is JUST used to store
    the calling routines completion routine.  The real Irp used is the original
    client's irp.  This is done so that IoCancelIrp will cancel the connect
    properly.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    KIRQL   OldIrq;
    PIRP    pMyIrp;

    NbtTrace(NBT_TRACE_LOWER_EDGE, ("TCP TDI_CONNECT/TDI_DISCONNECT pIrp %p: %!status!",
                        pIrp, pIrp->IoStatus.Status));

    pMyIrp = (PIRP)pContext;

    // check for a completion routine of the clients to call...
    if (pMyIrp->Overlay.AsynchronousParameters.UserApcRoutine)
    {
       (*((NBT_COMPLETION)pMyIrp->Overlay.AsynchronousParameters.UserApcRoutine))
                   ((PVOID)pMyIrp->Overlay.AsynchronousParameters.UserApcContext,
                    pIrp->IoStatus.Status,
                    0L);

    }

    NbtFreeIrp(pMyIrp);

    // return this status to stop the IO subsystem from further processing the
    // IRP - i.e. trying to complete it back to the initiating thread! -since
    // there is not initiating thread - we are the initiator
    return(STATUS_MORE_PROCESSING_REQUIRED);

}
//----------------------------------------------------------------------------
NTSTATUS
TdiSend(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  USHORT                          sFlags,
    IN  ULONG                           SendLength,
    OUT PULONG                          pSentSize,
    IN  tBUFFER                         *pSendBuffer,
    IN  ULONG                           Flags
    )
/*++

Routine Description:

    This routine sends a packet to the transport on a TCP connection

Arguments:

    pSendBuffer     - this is really an Mdl in NT land.  It must be tacked on
                      the end of the Mdl created for the Nbt datagram header.

Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS         status;
    PIRP             pRequestIrp;
    PMDL             pMdl;
    PDEVICE_OBJECT   pDeviceObject;
    PFILE_OBJECT     pFileObject;

    // get an Irp to send the message in
    pFileObject = (PFILE_OBJECT)pRequestInfo->Handle.AddressHandle;
    pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

    // get an Irp from the list
    status = GetIrp(&pRequestIrp);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDIOUT)
            KdPrint(("Nbt.TdiSend: Failed to get an Irp"));
        // call the completion routine with  this status
        if (pRequestInfo->RequestNotifyObject)
        {
            (*((NBT_COMPLETION)pRequestInfo->RequestNotifyObject))
                        ((PVOID)pRequestInfo->RequestContext,
                         STATUS_INSUFFICIENT_RESOURCES,
                         0L);
        }

        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    pRequestIrp->CancelRoutine = NULL;


    // set up the completion routine passed in from Udp Send using the APC
    // fields in the Irp that would normally be used to complete the request
    // back to the client - although we are really the client here so we can
    // use these fields our self!
    pRequestIrp->Overlay.AsynchronousParameters.UserApcRoutine =
                            (PIO_APC_ROUTINE)pRequestInfo->RequestNotifyObject;
    pRequestIrp->Overlay.AsynchronousParameters.UserApcContext =
                            (PVOID)pRequestInfo->RequestContext;


    // get the MDL that is currently linked to the IRP (i.e. created at the
    // same time that we created the IRP list. Set the sizes correctly in
    // the MDL header.
    pMdl = IoAllocateMdl(
                    pSendBuffer->pDgramHdr,
                    pSendBuffer->HdrLength,
                    FALSE,
                    FALSE,
                    NULL);

    if (!pMdl)
    {
        NbtFreeIrp(pRequestIrp);

        // call the completion routine will  this status
        if (pRequestInfo->RequestNotifyObject)
        {
            (*((NBT_COMPLETION)pRequestInfo->RequestNotifyObject))
                        ((PVOID)pRequestInfo->RequestContext,
                         STATUS_INSUFFICIENT_RESOURCES,
                         0L);
        }
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // Map the pages in memory...
    MmBuildMdlForNonPagedPool(pMdl);

    TdiBuildSend(
        pRequestIrp,
        pDeviceObject,
        pFileObject,
        SendSessionCompletionRoutine,
        NULL,                     //context value passed to completion routine
        pMdl,
        sFlags,
        SendLength);    // include session hdr length (ULONG)
    //
    // tack the Client's buffer on the end, if there is one
    //
    if (pSendBuffer->Length)
    {
        pMdl->Next = pSendBuffer->pBuffer;
    }

    CHECK_COMPLETION(pRequestIrp);
    status = IoCallDriver(pDeviceObject,pRequestIrp);

    *pSentSize = SendLength; // the size we attempted to send

    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
SendSessionCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
/*++

Routine Description:

    This routine handles the completion of a send to the transport.
    It must call any client supplied completion routine and free the Irp
    and Mdl back to its pool.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    KIRQL       OldIrq;

    //
    // check for a completion routine of the clients to call...
    //
    if (pIrp->Overlay.AsynchronousParameters.UserApcRoutine)
    {
       (*((NBT_COMPLETION)pIrp->Overlay.AsynchronousParameters.UserApcRoutine))
                   ((PVOID)pIrp->Overlay.AsynchronousParameters.UserApcContext,
                    pIrp->IoStatus.Status,
                    (ULONG)pIrp->IoStatus.Information);    // sent length

    }



    IoFreeMdl(pIrp->MdlAddress);

    NbtFreeIrp(pIrp);
    //
    // return this status to stop the IO subsystem from further processing the
    // IRP - i.e. trying to complete it back to the initiating thread! -since
    // there is no initiating thread - we are the initiator
    //
    return(STATUS_MORE_PROCESSING_REQUIRED);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\flt\filter.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\flt\filter.c

Abstract:
    IPX Filter driver filtering and maintanance routines


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

	// Masks to test components of the filter descriptor
	// (Have to use globals in lue of constants to get correct
	// byte ordering)
const union {
		struct {
			UCHAR			Src[4];
			UCHAR			Dst[4];
		}				FD_Network;
		ULONGLONG		FD_NetworkSrcDst;
	} FltSrcNetMask = {{{0xFF, 0xFF, 0xFF, 0xFF}, {0, 0, 0, 0}}};
#define FLT_SRC_NET_MASK FltSrcNetMask.FD_NetworkSrcDst

const union {
		struct {
			UCHAR			Src[4];
			UCHAR			Dst[4];
		}				FD_Network;
		ULONGLONG		FD_NetworkSrcDst;
	} FltDstNetMask = {{{0, 0, 0, 0}, {0xFF, 0xFF, 0xFF, 0xFF}}};
#define FLT_DST_NET_MASK FltDstNetMask.FD_NetworkSrcDst

const union {
		struct {
			UCHAR			Node[6];
			UCHAR			Socket[2];
		}				FD_NS;
		ULONGLONG		FD_NodeSocket;
	} FltNodeMask = {{{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, {0, 0}}};
#define FLT_NODE_MASK FltNodeMask.FD_NodeSocket

const union {
		struct {
			UCHAR			Node[6];
			UCHAR			Socket[2];
		}				FD_NS;
		ULONGLONG		FD_NodeSocket;
	} FltSocketMask = {{{0, 0, 0, 0, 0, 0}, {0xFF, 0xFF}}};
#define FLT_SOCKET_MASK FltSocketMask.FD_NodeSocket

	// Hash tables of interface control blocks with filter descriptions
		// Input filters
LIST_ENTRY	InterfaceInHash[FLT_INTERFACE_HASH_SIZE];
		// Output filters
LIST_ENTRY	InterfaceOutHash[FLT_INTERFACE_HASH_SIZE];
		// Serializes access to interface table
FAST_MUTEX		InterfaceTableLock;
LIST_ENTRY		LogIrpQueue;
USHORT			LogSeqNum;


	// Hash function for interface hash tables
#define InterfaceIndexHash(Index) (Index%FLT_INTERFACE_HASH_SIZE)

	// Packet descriptor block
typedef struct _PACKET_DESCR {
	union {
		struct {
			ULONG			Src;			// Source network
			ULONG			Dst;			// Destination network
		}				PD_Network;
		ULONGLONG		PD_NetworkSrcDst;	// Combined field
	};
	ULONGLONG			PD_SrcNodeSocket;	// Source node & socket
	ULONGLONG			PD_DstNodeSocket;	// Destination node & socket
	LONG				PD_ReferenceCount;	// Filter reference count
	UCHAR				PD_PacketType;		// Packet type
	BOOLEAN				PD_LogMatches;
} PACKET_DESCR, *PPACKET_DESCR;

	// Packet cache (only though that pass the filter)
PPACKET_DESCR	PacketCache[FLT_PACKET_CACHE_SIZE];
KSPIN_LOCK		PacketCacheLock;


/*++
	A c q u i r e P a c k e t R e f e r e n c e

Routine Description:

	Returns reference to the packet descriptor in the cache

Arguments:
	idx			- cache index
	pd			- pointer to packet descriptor to be returned

Return Value:
	None

--*/
//VOID
//AcquirePacketReference (
//	IN UINT				idx,
//	OUT PPACKET_DESCR	pd
//	);
#define AcquirePacketReference(idx,pd)	{				\
	KIRQL		oldIRQL;								\
	KeAcquireSpinLock (&PacketCacheLock, &oldIRQL);		\
	if ((pd=PacketCache[idx])!=NULL)					\
		InterlockedIncrement (&pd->PD_ReferenceCount);	\
	KeReleaseSpinLock (&PacketCacheLock, oldIRQL);		\
}

/*++
	R e l e a s e P a c k e t R e f e r e n c e

Routine Description:

	Releases reference to the cached packet descriptor

Arguments:
	pd			- pointer to packet descriptor to release

Return Value:
	None

--*/
//VOID
//ReleasePacketReference (
//	IN PPACKET_DESCR	pd
//	);
#define ReleasePacketReference(pd)	{						\
	if (InterlockedDecrement (&pd->PD_ReferenceCount)>=0)	\
		NOTHING;											\
	else													\
		ExFreePool (pd);									\
}

/*++
	R e p l a c e P a c k e t R e f e r e n c e

Routine Description:

	Replaces packet cache entry

Arguments:
	idx			- cache index
	pd			- pointer to packet descriptor to be installed in the cache

Return Value:
	None

--*/
//VOID
//ReplacePacket (
//	IN UINT				idx,
//	IN PPACKET_DESCR	pd
//	);
#define ReplacePacket(idx,pd)	{							\
	KIRQL			oldIRQL;								\
	PPACKET_DESCR	oldPD;									\
	KeAcquireSpinLock (&PacketCacheLock, &oldIRQL);			\
	oldPD = PacketCache[idx];								\
	PacketCache[idx] = pd;									\
	KeReleaseSpinLock (&PacketCacheLock, oldIRQL);			\
	IpxFltDbgPrint (DBG_PKTCACHE,							\
		 ("IpxFlt: Replaced packet descriptor %08lx"		\
			" with %08lx in cache at index %ld.\n",			\
			oldPD, pd, idx));								\
	if (oldPD!=NULL) {										\
		ReleasePacketReference(oldPD);						\
	}														\
}

	// Defined below
VOID
FlushPacketCache (
	VOID
	);

/*++
	I n i t i a l i z e T a b l e s

Routine Description:

	Initializes hash and cash tables and protection stuff
Arguments:
	None
Return Value:
	STATUS_SUCCESS

--*/
NTSTATUS
InitializeTables (
	VOID
	) {
	UINT	i;
	for (i=0; i<FLT_INTERFACE_HASH_SIZE; i++) {
		InitializeListHead (&InterfaceInHash[i]);
		InitializeListHead (&InterfaceOutHash[i]);
	}

	for (i=0; i<FLT_PACKET_CACHE_SIZE; i++) {
		PacketCache[i] = NULL;
	}
	KeInitializeSpinLock (&PacketCacheLock);
	ExInitializeFastMutex (&InterfaceTableLock);
	InitializeListHead (&LogIrpQueue);
	LogSeqNum = 0;
	return STATUS_SUCCESS;
}

/*++
	D e l e t e T a b l e s

Routine Description:

	Deletes hash and cash tables
Arguments:
	None
Return Value:
	None

--*/
VOID
DeleteTables (
	VOID
	) {
	UINT	i;

	for (i=0; i<FLT_INTERFACE_HASH_SIZE; i++) {
		while (!IsListEmpty (&InterfaceInHash[i])) {
			NTSTATUS		status;
			PINTERFACE_CB	ifCB = CONTAINING_RECORD (InterfaceInHash[i].Flink,
									INTERFACE_CB, ICB_Link);
			status = FwdSetFilterInContext (ifCB->ICB_Index, NULL);
			ASSERT (status==STATUS_SUCCESS);
			RemoveEntryList (&ifCB->ICB_Link);
			ExFreePool (ifCB);
		}
		while (!IsListEmpty (&InterfaceOutHash[i])) {
			NTSTATUS		status;
			PINTERFACE_CB	ifCB = CONTAINING_RECORD (InterfaceOutHash[i].Flink,
									INTERFACE_CB, ICB_Link);
			status = FwdSetFilterOutContext (ifCB->ICB_Index, NULL);
			ASSERT (status==STATUS_SUCCESS);
			RemoveEntryList (&ifCB->ICB_Link);
			ExFreePool (ifCB);
		}
	}
	for (i=0; i<FLT_PACKET_CACHE_SIZE; i++) {
		if (PacketCache[i] != NULL)
			ExFreePool (PacketCache[i]);
	}
	return ;
}


/*++
	S e t F i l t e r s

Routine Description:
	
	Sets/replaces filter information for an interface
Arguments:
	HashTable	- input or output hash table
	Index		- interface index
	FilterAction - default action if there is no filter match
	FilterInfoSize - size of the info array
	FilterInfo	- array of filter descriptions (UI format)
Return Value:
	STATUS_SUCCESS - filter info was set/replaced ok
	STATUS_UNSUCCESSFUL - could not set filter context in forwarder
	STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate
						filter info block for interface

--*/
NTSTATUS
SetFilters (
	IN PLIST_ENTRY					HashTable,
	IN ULONG						Index,
	IN ULONG						FilterAction,
	IN ULONG						FilterInfoSize,
	IN PIPX_TRAFFIC_FILTER_INFO		FilterInfo
	) {
	PINTERFACE_CB	ifCB = NULL, oldCB = NULL;
	ULONG			FilterCount 
						= FilterInfoSize/sizeof (IPX_TRAFFIC_FILTER_INFO);
	ULONG			i;
	PFILTER_DESCR	fd;
	PLIST_ENTRY		HashBucket = &HashTable[InterfaceIndexHash(Index)], cur;
	NTSTATUS		status = STATUS_SUCCESS;

	if (FilterCount>0) {
		ifCB = ExAllocatePoolWithTag (
					NonPagedPool,
					FIELD_OFFSET (INTERFACE_CB, ICB_Filters[FilterCount]),
					IPX_FLT_TAG
					);
		if (ifCB==NULL) {
			IpxFltDbgPrint (DBG_IFHASH|DBG_ERRORS,
				("IpxFlt: Could not allocate interface CB for if %ld.\n",
				Index));
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		ifCB->ICB_Index = Index;
		ifCB->ICB_FilterAction = (FilterAction==IPX_TRAFFIC_FILTER_ACTION_PERMIT)
									? FILTER_PERMIT : FILTER_DENY;
		ifCB->ICB_FilterCount = FilterCount;
			// Copy/Map UI filters to the internal format
		for (i=0, fd = ifCB->ICB_Filters; i<FilterCount; i++, fd++, FilterInfo++) {
			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_SRCNET) {
				memcpy (fd->FD_Network.Src, FilterInfo->SourceNetwork, 4);
				memcpy (fd->FD_NetworkMask.Src, FilterInfo->SourceNetworkMask, 4);
			}
			else {
				memset (fd->FD_Network.Src, 0, 4);
				memset (fd->FD_NetworkMask.Src, 0, 4);
			}

			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_DSTNET) {
				memcpy (fd->FD_Network.Dst, FilterInfo->DestinationNetwork, 4);
				memcpy (fd->FD_NetworkMask.Dst, FilterInfo->DestinationNetworkMask, 4);
			}
			else {
				memset (fd->FD_Network.Dst, 0, 4);
				memset (fd->FD_NetworkMask.Dst, 0, 4);
			}

			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_SRCNODE) {
				memcpy (fd->FD_SrcNS.Node, FilterInfo->SourceNode, 6);
				memset (fd->FD_SrcNSMask.Node, 0xFF, 6);
			}
			else {
				memset (fd->FD_SrcNS.Node, 0, 6);
				memset (fd->FD_SrcNSMask.Node, 0, 6);
			}

			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_SRCSOCKET) {
				memcpy (fd->FD_SrcNS.Socket, FilterInfo->SourceSocket, 2);
				memset (fd->FD_SrcNSMask.Socket, 0xFF, 2);
			}
			else {
				memset (fd->FD_SrcNS.Socket, 0, 2);
				memset (fd->FD_SrcNSMask.Socket, 0, 2);
			}

			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_DSTNODE) {
				memcpy (fd->FD_DstNS.Node, FilterInfo->DestinationNode, 6);
				memset (fd->FD_DstNSMask.Node, 0xFF, 6);
			}
			else {
				memset (fd->FD_DstNS.Node, 0, 6);
				memset (fd->FD_DstNSMask.Node, 0, 6);
			}

			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_DSTSOCKET) {
				memcpy (fd->FD_DstNS.Socket, FilterInfo->DestinationSocket, 2);
				memset (fd->FD_DstNSMask.Socket, 0xFF, 2);
			}
			else {
				memset (fd->FD_DstNS.Socket, 0, 2);
				memset (fd->FD_DstNSMask.Socket, 0, 2);
			}
			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_PKTTYPE) {
				fd->FD_PacketType = FilterInfo->PacketType;
				fd->FD_PacketTypeMask = 0xFF;
			}
			else {
				fd->FD_PacketType = 0;
				fd->FD_PacketTypeMask = 0;
			}

			fd->FD_LogMatches = (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_LOG_MATCHES)!=0;
		}
	}

	ExAcquireFastMutex (&InterfaceTableLock);

		// Find the old block and/or a place for a new one
	cur = HashBucket->Flink;
	while (cur!=HashBucket) {
		oldCB = CONTAINING_RECORD (cur, INTERFACE_CB, ICB_Link);
		if (oldCB->ICB_Index==Index) {
				// Found the old one, place new after it
			cur = cur->Flink;
			break;
		}
		else if (oldCB->ICB_Index>Index) {
				// No chance to see the old one anymore, place where
				// we are now
			oldCB = NULL;
			break;
		}
		cur = cur->Flink;
	}
		
		// Set context in forwarder
	if (HashTable==InterfaceInHash) {
		status = FwdSetFilterInContext (Index, ifCB);
	}
	else {
		ASSERT (HashTable==InterfaceOutHash);
		status = FwdSetFilterOutContext (Index, ifCB);
	}

	if (NT_SUCCESS (status)) {
			// Update table if we succeded
		IpxFltDbgPrint (DBG_IFHASH,
			("IpxFlt: Set filters for if %ld (ifCB:%08lx).\n",
			Index, ifCB));

		if (oldCB!=NULL) {
			IpxFltDbgPrint (DBG_IFHASH,
				("IpxFlt: Deleting replaced filters for if %ld (ifCB:%08lx).\n",
				Index, oldCB));
			RemoveEntryList (&oldCB->ICB_Link);
			ExFreePool (oldCB);
		}



		if (ifCB!=NULL) {
			InsertTailList (cur, &ifCB->ICB_Link);
		}

		FlushPacketCache ();
	}
	else {
		IpxFltDbgPrint (DBG_IFHASH|DBG_ERRORS,
			("IpxFlt: Failed to set context for if %ld (ifCB:%08lx).\n",
			Index, ifCB));
	}

	ExReleaseFastMutex (&InterfaceTableLock);
	return status;
}

/*++
	G e t F i l t e r s

Routine Description:
	
	Gets filter information for an interface
Arguments:
	HashTable	- input or output hash table
	Index		- interface index
	FilterAction - default action if there is no filter match
	TotalSize	- total memory required to hold all filter descriptions
	FilterInfo	- array of filter descriptions (UI format)
	FilterInfoSize - on input: size of the info array
					on output: size of the info placed in the array
Return Value:
	STATUS_SUCCESS - filter info was returned ok
	STATUS_BUFFER_OVERFLOW - array is not big enough to hold all
					filter info, only placed the info that fit

--*/
NTSTATUS
GetFilters (
	IN PLIST_ENTRY					HashTable,
	IN ULONG						Index,
	OUT ULONG						*FilterAction,
	OUT ULONG						*TotalSize,
	OUT PIPX_TRAFFIC_FILTER_INFO	FilterInfo,
	IN OUT ULONG					*FilterInfoSize
	) {
	PINTERFACE_CB	oldCB = NULL;
	ULONG			i, AvailBufCount = 
						(*FilterInfoSize)/sizeof (IPX_TRAFFIC_FILTER_INFO);
	PFILTER_DESCR	fd;
	PLIST_ENTRY		HashBucket = &HashTable[InterfaceIndexHash(Index)], cur;
	NTSTATUS		status = STATUS_SUCCESS;

		// Locate interface filters block
	ExAcquireFastMutex (&InterfaceTableLock);
	cur = HashBucket->Flink;
	while (cur!=HashBucket) {
		oldCB = CONTAINING_RECORD (cur, INTERFACE_CB, ICB_Link);
		if (oldCB->ICB_Index==Index) {
			cur = cur->Flink;
			break;
		}
		else if (oldCB->ICB_Index>Index) {
			oldCB = NULL;
			break;
		}
		cur = cur->Flink;
	}

	if (oldCB!=NULL) {
		*FilterAction = IS_FILTERED(oldCB->ICB_FilterAction)
				? IPX_TRAFFIC_FILTER_ACTION_DENY
                : IPX_TRAFFIC_FILTER_ACTION_PERMIT;
		*TotalSize = oldCB->ICB_FilterCount*sizeof (IPX_TRAFFIC_FILTER_INFO);
			// Copy/Map as many descriptors as fit
		for (i=0, fd = oldCB->ICB_Filters;
					(i<oldCB->ICB_FilterCount) && (i<AvailBufCount);
					i++, fd++, FilterInfo++) {
			FilterInfo->FilterDefinition = 0;
			if (fd->FD_NetworkMaskSrcDst&FLT_SRC_NET_MASK) {
				memcpy (FilterInfo->SourceNetwork, fd->FD_Network.Src, 4);
				memcpy (FilterInfo->SourceNetworkMask, fd->FD_NetworkMask.Src, 4);
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNET;
			}

			if (fd->FD_NetworkMaskSrcDst&FLT_DST_NET_MASK) {
				memcpy (FilterInfo->DestinationNetwork, fd->FD_Network.Dst, 4);
				memcpy (FilterInfo->DestinationNetworkMask, fd->FD_NetworkMask.Dst, 4);
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNET;
			}

			if (fd->FD_SrcNodeSocketMask&FLT_NODE_MASK) {
				memcpy (FilterInfo->SourceNode, fd->FD_SrcNS.Node, 6);
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNODE;
			}

			if (fd->FD_DstNodeSocketMask&FLT_NODE_MASK) {
				memcpy (FilterInfo->DestinationNode, fd->FD_DstNS.Node, 6);
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNODE;
			}

			if (fd->FD_SrcNodeSocketMask&FLT_SOCKET_MASK) {
				memcpy (FilterInfo->SourceSocket, fd->FD_SrcNS.Socket, 2);
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCSOCKET;
			}
			if (fd->FD_DstNodeSocketMask&FLT_SOCKET_MASK) {
				memcpy (FilterInfo->DestinationSocket, fd->FD_DstNS.Socket, 2);
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTSOCKET;
			}
			if (fd->FD_PacketTypeMask&0xFF) {
				FilterInfo->PacketType = fd->FD_PacketType;
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_PKTTYPE;
			}
			if (fd->FD_LogMatches)
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_LOG_MATCHES;
		}

		*FilterInfoSize = i*sizeof (IPX_TRAFFIC_FILTER_INFO);

		IpxFltDbgPrint (DBG_IFHASH, 
			("IpxFlt: Returning %d filters (%d available)"
				" for interface %d (ifCB: %08lx).\n",
				i, oldCB->ICB_FilterCount, Index));
		if (i<oldCB->ICB_FilterCount)
			status = STATUS_BUFFER_OVERFLOW;
		ExReleaseFastMutex (&InterfaceTableLock);
	}
	else {
			// No interface block -> we are passing all the packets
			// unfiltered
		ExReleaseFastMutex (&InterfaceTableLock);
		IpxFltDbgPrint (DBG_IFHASH, 
			("IpxFlt: No filters for interface %d.\n", Index));
		*FilterAction = IPX_TRAFFIC_FILTER_ACTION_PERMIT;
		*TotalSize = 0;
		*FilterInfoSize = 0;
	}
	return status;
}


VOID
LogPacket (
	IN PUCHAR	ipxHdr,
	IN ULONG	ipxHdrLength,
	IN PVOID	ifInContext,
	IN PVOID	ifOutContext
	) {
	PIRP				irp;
	PIO_STACK_LOCATION	irpStack;
    ULONG				outBufLength;
    PUCHAR				outBuffer;
	ULONG_PTR			offset;
	KIRQL				cancelIRQL;

	IoAcquireCancelSpinLock (&cancelIRQL);
	LogSeqNum += 1;
	while (!IsListEmpty (&LogIrpQueue)) {
		irp = CONTAINING_RECORD (LogIrpQueue.Flink,IRP,Tail.Overlay.ListEntry);
		irpStack = IoGetCurrentIrpStackLocation(irp);
		outBufLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
		if (irp->MdlAddress == NULL)
		{
		    outBuffer = NULL;
		}
		else
		{
    		outBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe (irp->MdlAddress, NormalPagePriority);
		}
		if (outBuffer != NULL)
		{
    		offset = (PUCHAR) ALIGN_UP ((ULONG_PTR)outBuffer + (ULONG_PTR)irp->IoStatus.Information, ULONG) - outBuffer;
    		if (offset+ipxHdrLength+FIELD_OFFSET (FLT_PACKET_LOG, Header)<outBufLength) {
    			PFLT_PACKET_LOG	pLog = (PFLT_PACKET_LOG) (outBuffer+offset);
    			pLog->SrcIfIdx = ifInContext 
    								? ((PINTERFACE_CB)ifInContext)->ICB_Index
    								: -1;
    			pLog->DstIfIdx = ifOutContext 
    								? ((PINTERFACE_CB)ifOutContext)->ICB_Index
    								: -1;
    			pLog->DataSize = (USHORT)ipxHdrLength;
    			pLog->SeqNum = LogSeqNum;
    			memcpy (pLog->Header, ipxHdr, ipxHdrLength);
    			irp->IoStatus.Information = offset+FIELD_OFFSET (FLT_PACKET_LOG, Header[ipxHdrLength]);
    			if (irp->Tail.Overlay.ListEntry.Flink!=&LogIrpQueue) {
    				RemoveEntryList (&irp->Tail.Overlay.ListEntry);
    				IoSetCancelRoutine (irp, NULL);
    				irp->IoStatus.Status = STATUS_SUCCESS;
    				IoReleaseCancelSpinLock (cancelIRQL);
    				IpxFltDbgPrint (DBG_PKTLOGS,
    					("IpxFlt: completing logging request"
    					" with %d bytes of data.\n",
    					irp->IoStatus.Information));
    				IoCompleteRequest (irp, IO_NO_INCREMENT);
    				return;
    			}
    			else
    				break;
    		}
        }    		
		RemoveEntryList (&irp->Tail.Overlay.ListEntry);
        IoSetCancelRoutine (irp, NULL);
		irp->IoStatus.Status = STATUS_SUCCESS;
		IoReleaseCancelSpinLock (cancelIRQL);
	    IpxFltDbgPrint (DBG_ERRORS|DBG_PKTLOGS,
			("IpxFlt: completing logging request"
			" with %d bytes of data (not enough space).\n",
			irp->IoStatus.Information));
		IoCompleteRequest (irp, IO_NO_INCREMENT);
		IoAcquireCancelSpinLock (&cancelIRQL);
	}
	IoReleaseCancelSpinLock (cancelIRQL);
}


/*++
	F i l t e r

Routine Description:
	
	Filters the packet supplied by the forwarder

Arguments:
	ipxHdr			- pointer to packet header
	ipxHdrLength	- size of the header buffer (must be at least 30)
	ifInContext		- context associated with interface on which packet
						was received
	ifOutContext	- context associated with interface on which packet
						will be sent
Return Value:
	FILTER_PERMIT		- packet should be passed on by the forwarder
	FILTER_DENY_IN		- packet should be dropped because of input filter
	FILTER_DENY_OUT		- packet should be dropped because of output filter
--*/
FILTER_ACTION
Filter (
	IN PUCHAR	ipxHdr,
	IN ULONG	ipxHdrLength,
	IN PVOID	ifInContext,
	IN PVOID	ifOutContext
	) {
	PACKET_DESCR	pd;
	FILTER_ACTION	res = FILTER_PERMIT;
	UINT			idx;

	ASSERT (ipxHdrLength>=IPXH_HDRSIZE);
		// Copy packet to aligned buffer
	pd.PD_Network.Dst = *((UNALIGNED ULONG *)(ipxHdr+IPXH_DESTNET));
	pd.PD_Network.Src = *((UNALIGNED ULONG *)(ipxHdr+IPXH_SRCNET));
	pd.PD_DstNodeSocket = *((UNALIGNED ULONGLONG *)(ipxHdr+IPXH_DESTNODE));
	pd.PD_SrcNodeSocket = *((UNALIGNED ULONGLONG *)(ipxHdr+IPXH_SRCNODE));
	pd.PD_PacketType = *(ipxHdr+IPXH_PKTTYPE);
	pd.PD_LogMatches = FALSE;
		// We do not cache netbios broadcast
	if (pd.PD_PacketType!=IPX_NETBIOS_TYPE) {
		PPACKET_DESCR	cachedPD;
			// Get cached packet
		idx = (UINT)((pd.PD_Network.Dst
								+pd.PD_DstNodeSocket
								+pd.PD_PacketType)
							%FLT_PACKET_CACHE_SIZE);
		AcquirePacketReference (idx, cachedPD);
		if (cachedPD!=NULL) {
				// Fast path: packet in the cache matches
			if ((pd.PD_NetworkSrcDst==cachedPD->PD_NetworkSrcDst)
					&& (pd.PD_SrcNodeSocket==cachedPD->PD_SrcNodeSocket)
					&& (pd.PD_DstNodeSocket==cachedPD->PD_DstNodeSocket)
					&& (pd.PD_PacketType==cachedPD->PD_PacketType)) {
				if (cachedPD->PD_LogMatches)
					LogPacket (ipxHdr,ipxHdrLength,ifInContext,ifOutContext);
				ReleasePacketReference (cachedPD);
				return FILTER_PERMIT;
			}
				// Do not need cached packet anymore
			ReleasePacketReference (cachedPD);
		}
	}
		// Slow path: check all filters
	if (ifInContext!=NO_FILTER_CONTEXT) {
		PFILTER_DESCR	fd,	fdEnd;
			// Read default result (no filter match)
		res = NOT_FILTER_ACTION(((PINTERFACE_CB)ifInContext)->ICB_FilterAction);
		fd = ((PINTERFACE_CB)ifInContext)->ICB_Filters;
		fdEnd = &((PINTERFACE_CB)ifInContext)->ICB_Filters
					[((PINTERFACE_CB)ifInContext)->ICB_FilterCount];
		while (fd<fdEnd) {
			if (	((pd.PD_NetworkSrcDst & fd->FD_NetworkMaskSrcDst)
						== fd->FD_NetworkSrcDst)
				&&	((pd.PD_SrcNodeSocket & fd->FD_SrcNodeSocketMask)
						== fd->FD_SrcNodeSocket)
				&&	((pd.PD_DstNodeSocket & fd->FD_DstNodeSocketMask)
						== fd->FD_DstNodeSocket)
				&&	((pd.PD_PacketType & fd->FD_PacketTypeMask)
						== fd->FD_PacketType) ) {
					// Filter match: reverse the result
				res = NOT_FILTER_ACTION(res);
				if (fd->FD_LogMatches) {
					pd.PD_LogMatches = TRUE;
					LogPacket (ipxHdr,ipxHdrLength,ifInContext,ifOutContext);
				}
				break;
			}
			fd++;
		}
					// Return right away if told to drop
		if (IS_FILTERED(res))
			return FILTER_DENY_IN;
	}

	if (ifOutContext!=NO_FILTER_CONTEXT) {
		PFILTER_DESCR	fd,	fdEnd;
			// Read default result (no filter match)
		res = NOT_FILTER_ACTION(((PINTERFACE_CB)ifOutContext)->ICB_FilterAction);
		fd = ((PINTERFACE_CB)ifOutContext)->ICB_Filters;
		fdEnd = &((PINTERFACE_CB)ifOutContext)->ICB_Filters
					[((PINTERFACE_CB)ifOutContext)->ICB_FilterCount];
		while (fd<fdEnd) {
			if (	((pd.PD_NetworkSrcDst & fd->FD_NetworkMaskSrcDst)
						== fd->FD_NetworkSrcDst)
				&&	((pd.PD_SrcNodeSocket & fd->FD_SrcNodeSocketMask)
						== fd->FD_SrcNodeSocket)
				&&	((pd.PD_DstNodeSocket & fd->FD_DstNodeSocketMask)
						== fd->FD_DstNodeSocket)
				&&	((pd.PD_PacketType & fd->FD_PacketTypeMask)
						== fd->FD_PacketType) ) {
					// Filter match: reverse the result
				res = NOT_FILTER_ACTION(res);
				if (fd->FD_LogMatches&&!pd.PD_LogMatches) {
					pd.PD_LogMatches = TRUE;
					LogPacket (ipxHdr,ipxHdrLength,ifInContext,ifOutContext);
				}
				break;
			}
			fd++;
		}
					// Return right away if told to drop
		if (IS_FILTERED(res))
			return FILTER_DENY_OUT;
	}

			// Cache the packet (we know that it is a pass
			// because we would have returned if it was a drop)
	if (pd.PD_PacketType!=IPX_NETBIOS_TYPE) {
		PPACKET_DESCR	cachedPD;
		cachedPD = ExAllocatePoolWithTag (
					NonPagedPool,
					sizeof (PACKET_DESCR),
					IPX_FLT_TAG
					);
		if (cachedPD!=NULL) {
			*cachedPD = pd;
			cachedPD->PD_ReferenceCount = 0;
			ReplacePacket (idx, cachedPD);
		}
	}

	return res;
}


/*++
	I n t e r f a c e D e l e t e d

Routine Description:
	
	Frees interface filters blocks when forwarder indicates that
	interface is deleted
Arguments:
	ifInContext		- context associated with input filters block	
	ifOutContext	- context associated with output filters block
Return Value:
	None

--*/
VOID
InterfaceDeleted (
	IN PVOID	ifInContext,
	IN PVOID	ifOutContext
	) {
	IpxFltDbgPrint (DBG_FWDIF,
		("IpxFlt: InterfaceDeleted indication,"
			"(inContext: %08lx, outContext: %08lx).\n",
			ifInContext, ifOutContext));
	ExAcquireFastMutex (&InterfaceTableLock);
	if (ifInContext!=NULL) {
		PINTERFACE_CB	ifCB = (PINTERFACE_CB)ifInContext;
		IpxFltDbgPrint (DBG_IFHASH,
			("IpxFlt: Deleting filters for if %ld (ifCB:%08lx)"
			" on InterfaceDeleted indication from forwarder.\n",
			ifCB->ICB_Index, ifCB));
		RemoveEntryList (&ifCB->ICB_Link);
		ExFreePool (ifCB);
	}

	if (ifOutContext!=NULL) {
		PINTERFACE_CB	ifCB = (PINTERFACE_CB)ifOutContext;
		IpxFltDbgPrint (DBG_IFHASH,
			("IpxFlt: Deleting filters for if %ld (ifCB:%08lx)"
			" on InterfaceDeleted indication from forwarder.\n",
			ifCB->ICB_Index, ifCB));
		RemoveEntryList (&ifCB->ICB_Link);
		ExFreePool (ifCB);
	}
	ExReleaseFastMutex (&InterfaceTableLock);
	FlushPacketCache ();
	return ;
}

/*++
	F l u s h P a c k e t C a c h e

Routine Description:
	
	Deletes all cached packet descriptions
Arguments:
	None
Return Value:
	None

--*/
VOID
FlushPacketCache (
	VOID
	) {
	UINT	i;
	IpxFltDbgPrint (DBG_PKTCACHE, ("IpxFlt: Flushing packet chache.\n"));
	for (i=0; i<FLT_PACKET_CACHE_SIZE; i++) {
		ReplacePacket (i, NULL);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\flt\filter.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\flt\filter.h

Abstract:
    IPX Filter driver filtering and maintanance routines


Author:

    Vadim Eydelman

Revision History:

--*/
#ifndef _IPXFLT_FILTER_
#define _IPXFLT_FILTER_

	// IPX header constants
#define IPXH_HDRSIZE	    30	    // Size of the IPX header
#define IPXH_CHECKSUM	    0	    // Checksum
#define IPXH_LENGTH			2	    // Length
#define IPXH_XPORTCTL	    4	    // Transport Control
#define IPXH_PKTTYPE	    5	    // Packet Type
#define IPXH_DESTADDR	    6	    // Dest. Address (Total)
#define IPXH_DESTNET	    6	    // Dest. Network Address
#define IPXH_DESTNODE	    10	    // Dest. Node Address
#define IPXH_DESTSOCK	    16	    // Dest. Socket Number
#define IPXH_SRCADDR	    18	    // Source Address (Total)
#define IPXH_SRCNET			18	    // Source Network Address
#define IPXH_SRCNODE	    22	    // Source Node Address
#define IPXH_SRCSOCK	    28	    // Source Socket Number

//*** Packet Types we care about
#define IPX_NETBIOS_TYPE    20	   // Netbios propagated packet

// Conversions from/to on-the-wire format
#define GETUSHORT(src) (            \
    (USHORT)(                       \
        (((UCHAR *)src)[0]<<8)      \
        + (((UCHAR *)src)[1])       \
    )                               \
)

#define GETULONG(src) (             \
    (ULONG)(                        \
        (((UCHAR *)src)[0]<<24)     \
        + (((UCHAR *)src)[1]<<16)   \
        + (((UCHAR *)src)[2]<<8)    \
        + (((UCHAR *)src)[3])       \
    )                               \
)

#define PUTUSHORT(src,dst) {                \
    ((UCHAR *)dst)[0] = ((UCHAR)(src>>8));  \
    ((UCHAR *)dst)[1] = ((UCHAR)src);       \
}

#define PUTULONG(src,dst) {                 \
    ((UCHAR *)dst)[0] = ((UCHAR)(src>>24)); \
    ((UCHAR *)dst)[1] = ((UCHAR)(src>>16)); \
    ((UCHAR *)dst)[2] = ((UCHAR)(src>>8));  \
    ((UCHAR *)dst)[3] = ((UCHAR)src);       \
}

	// Other important constatns
#define FLT_INTERFACE_HASH_SIZE	257
#define FLT_PACKET_CACHE_SIZE	257
#define IPX_FLT_TAG				'lFwN'


	// Filter description
typedef struct _FILTER_DESCR {
	union {
		struct {
			UCHAR			Src[4];
			UCHAR			Dst[4];
		}				FD_Network;
		ULONGLONG		FD_NetworkSrcDst;
	};
	union {
		struct {
			UCHAR			Src[4];
			UCHAR			Dst[4];
		}				FD_NetworkMask;
		ULONGLONG		FD_NetworkMaskSrcDst;
	};
	union {
		struct {
			UCHAR			Node[6];
			UCHAR			Socket[2];
		}				FD_SrcNS;
		ULONGLONG		FD_SrcNodeSocket;
	};
	union {
		struct {
			UCHAR			Node[6];
			UCHAR			Socket[2];
		}				FD_SrcNSMask;
		ULONGLONG		FD_SrcNodeSocketMask;
	};
	union {
		struct {
			UCHAR			Node[6];
			UCHAR			Socket[2];
		}				FD_DstNS;
		ULONGLONG		FD_DstNodeSocket;
	};
	union {
		struct {
			UCHAR			Node[6];
			UCHAR			Socket[2];
		}				FD_DstNSMask;
		ULONGLONG		FD_DstNodeSocketMask;
	};
	UCHAR				FD_PacketType;
	UCHAR				FD_PacketTypeMask;
	BOOLEAN				FD_LogMatches;
} FILTER_DESCR, *PFILTER_DESCR;

	// Interface filters block
typedef struct _INTERFACE_CB {
	LIST_ENTRY		ICB_Link;
	ULONG			ICB_Index;
	ULONG			ICB_FilterAction;
	ULONG			ICB_FilterCount;
	FILTER_DESCR	ICB_Filters[1];
} INTERFACE_CB, *PINTERFACE_CB;

	// Interface hash tables
extern LIST_ENTRY		InterfaceInHash[FLT_INTERFACE_HASH_SIZE];
extern LIST_ENTRY		InterfaceOutHash[FLT_INTERFACE_HASH_SIZE];
extern LIST_ENTRY		LogIrpQueue;

/*++
	I n i t i a l i z e T a b l e s

Routine Description:

	Initializes hash and cash tables and protection stuff
Arguments:
	None
Return Value:
	STATUS_SUCCESS

--*/
NTSTATUS
InitializeTables (
	VOID
	);

/*++
	D e l e t e T a b l e s

Routine Description:

	Deletes hash and cash tables
Arguments:
	None
Return Value:
	None

--*/
VOID
DeleteTables (
	VOID
	);

/*++
	S e t F i l t e r s

Routine Description:
	
	Sets/replaces filter information for an interface
Arguments:
	HashTable	- input or output hash table
	Index		- interface index
	FilterAction - default action if there is no filter match
	FilterInfoSize - size of the info array
	FilterInfo	- array of filter descriptions (UI format)
Return Value:
	STATUS_SUCCESS - filter info was set/replaced ok
	STATUS_UNSUCCESSFUL - could not set filter context in forwarder
	STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate
						filter info block for interface

--*/
NTSTATUS
SetFilters (
	IN PLIST_ENTRY					HashTable,
	IN ULONG						InterfaceIndex,
	IN ULONG						FilterAction,
	IN ULONG						FilterInfoSize,
	IN PIPX_TRAFFIC_FILTER_INFO		FilterInfo
	);
#define SetInFilters(Index,Action,InfoSize,Info) \
			SetFilters(InterfaceInHash,Index,Action,InfoSize,Info)
#define SetOutFilters(Index,Action,InfoSize,Info) \
			SetFilters(InterfaceOutHash,Index,Action,InfoSize,Info)


/*++
	G e t F i l t e r s

Routine Description:
	
	Gets filter information for an interface
Arguments:
	HashTable	- input or output hash table
	Index		- interface index
	FilterAction - default action if there is no filter match
	TotalSize	- total memory required to hold all filter descriptions
	FilterInfo	- array of filter descriptions (UI format)
	FilterInfoSize - on input: size of the info array
					on output: size of the info placed in the array
Return Value:
	STATUS_SUCCESS - filter info was returned ok
	STATUS_BUFFER_OVERFLOW - array is not big enough to hold all
					filter info, only placed the info that fit

--*/
NTSTATUS
GetFilters (
	IN PLIST_ENTRY					HashTable,
	IN ULONG						InterfaceIndex,
	OUT ULONG						*FilterAction,
	OUT ULONG						*TotalSize,
	OUT PIPX_TRAFFIC_FILTER_INFO	FilterInfo,
	IN OUT ULONG					*FilterInfoSize
	);
#define GetInFilters(Index,Action,TotalSize,Info,InfoSize) \
			GetFilters(InterfaceInHash,Index,Action,TotalSize,Info,InfoSize)
#define GetOutFilters(Index,Action,TotalSize,Info,InfoSize) \
			GetFilters(InterfaceOutHash,Index,Action,TotalSize,Info,InfoSize)

/*++
	F i l t e r

Routine Description:
	
	Filters the packet supplied by the forwarder

Arguments:
	ipxHdr			- pointer to packet header
	ipxHdrLength	- size of the header buffer (must be at least 30)
	ifInContext		- context associated with interface on which packet
						was received
	ifOutContext	- context associated with interface on which packet
						will be sent
Return Value:
	FILTER_PERMIT	- packet should be passed on by the forwarder
	FILTER_DEDY		- packet should be dropped
--*/
FILTER_ACTION
Filter (
	IN PUCHAR	ipxHdr,
	IN ULONG	ipxHdrLength,
	IN PVOID	ifInContext,
	IN PVOID	ifOutContext
	);

/*++
	I n t e r f a c e D e l e t e d

Routine Description:
	
	Frees interface filters blocks when forwarder indicates that
	interface is deleted
Arguments:
	ifInContext		- context associated with input filters block	
	ifOutContext	- context associated with output filters block
Return Value:
	None

--*/
VOID
InterfaceDeleted (
	IN PVOID	ifInContext,
	IN PVOID	ifOutContext
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\flt\driver.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\flt\driver.c

Abstract:
    IPX Filter driver dispatch routines


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

PFILE_OBJECT		RouterFile;

NTSTATUS
IpxFltDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
IpxFltUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
IpxFltCancel (
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				irp
	);
	
/*++
	D r i v e r E n t r y

Routine Description:

	Installable driver initialization entry point.
	This entry point is called directly by the I/O system.

Arguments:

	DriverObject - pointer to the driver object

	RegistryPath - pointer to a unicode string representing the path
				   to driver-specific key in the registry

Return Value:

	STATUS_SUCCESS if successful,
	STATUS_UNSUCCESSFUL otherwise

--*/
NTSTATUS
DriverEntry (
	IN PDRIVER_OBJECT  DriverObject,
	IN PUNICODE_STRING RegistryPath
	) {

	PDEVICE_OBJECT deviceObject = NULL;
	NTSTATUS       status;
	UNICODE_STRING deviceNameUnicodeString;

	IpxFltDbgPrint (DBG_IOCTLS, ("IpxFlt: Driver Entry.\n"));

	RtlInitUnicodeString (&deviceNameUnicodeString,
						  IPXFLT_NAME);

	status = IoCreateDevice (DriverObject,
							   0,
							   &deviceNameUnicodeString,
							   FILE_DEVICE_IPXFLT,
							   0,
							   FALSE,		// Non-Exclusive
							   &deviceObject
							   );

	if (NT_SUCCESS(status)) {
		//
		// Create dispatch points for device control, create, close.
		//
		DriverObject->MajorFunction[IRP_MJ_CREATE]
			= DriverObject->MajorFunction[IRP_MJ_CLEANUP]
			= DriverObject->MajorFunction[IRP_MJ_CLOSE]
			= DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]
			= IpxFltDispatch;
		DriverObject->DriverUnload = IpxFltUnload;
		status = BindToFwdDriver (KernelMode);
		if (NT_SUCCESS (status)) {
			RouterFile = NULL;
			return STATUS_SUCCESS;
		}
		else {
		    IoDeleteDevice (DriverObject->DeviceObject);
		}
	}
	else
		IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS,
						("IpxFlt: Could not create device object.\n"));

	return status;
}



/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
NTSTATUS
IpxFltDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    ) {
    PIO_STACK_LOCATION	IrpStack;
    PVOID				inBuffer, outBuffer;
    ULONG				inpBufLength;
    ULONG				outBufLength;
    NTSTATUS			status;
	KIRQL				cancelIRQL;
    ULONG               ulBytes;

    ulBytes = 0;
    Irp->IoStatus.Information = 0;
	status = STATUS_SUCCESS;

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    IrpStack = IoGetCurrentIrpStackLocation(Irp);


    switch (IrpStack->MajorFunction) {
	case IRP_MJ_CREATE:
		IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IRP_MJ_CREATE.\n"));
		break;

	case IRP_MJ_CLOSE:
		IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IRP_MJ_CLOSE.\n"));
		if (IrpStack->FileObject == RouterFile) {
			DeleteTables ();
			RouterFile = NULL;
		}
		break;

	case IRP_MJ_CLEANUP:
		IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IRP_MJ_CLEANUP.\n"));
		if (IrpStack->FileObject==RouterFile) {
			IoAcquireCancelSpinLock (&cancelIRQL);
			while (!IsListEmpty (&LogIrpQueue)) {
				PIRP irp = CONTAINING_RECORD (LogIrpQueue.Blink,
										IRP, Tail.Overlay.ListEntry);
				irp->Cancel = TRUE;
				irp->CancelIrql = cancelIRQL;
				irp->CancelRoutine = NULL;
				IpxFltCancel(DeviceObject, irp);
				IoAcquireCancelSpinLock (&cancelIRQL);
			}
			IoReleaseCancelSpinLock(cancelIRQL);
		}
		break;

	case IRP_MJ_DEVICE_CONTROL:
    //
    // Get the pointer to the input/output buffer and it's length
    //
		status = STATUS_INVALID_PARAMETER;
		inpBufLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
		outBufLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
		switch (IrpStack->Parameters.DeviceIoControl.IoControlCode&3) {
		case METHOD_BUFFERED:
			inBuffer = outBuffer = Irp->AssociatedIrp.SystemBuffer;
			break;

		case METHOD_IN_DIRECT:
		case METHOD_OUT_DIRECT:
			inBuffer = Irp->AssociatedIrp.SystemBuffer;
			if (outBufLength>0) {
				outBuffer = MmGetSystemAddressForMdlSafe (Irp->MdlAddress, NormalPagePriority);
				if (outBuffer == NULL)
				{
        			IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS, ("IpxFlt: System out of PTE's.\n"));
        			goto DispatchExit;
				}
			}
			else {
				outBuffer = NULL; 
			}
			break;
		default:
			IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS, ("IpxFlt: Unsupported io method.\n"));
			goto DispatchExit;
		}


		if (IrpStack->FileObject==RouterFile) {
			switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
			case IOCTL_FLT_IF_SET_IN_FILTERS:
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_IF_SET_IN_FILTERS.\n"));
				if ((inpBufLength==sizeof (FLT_IF_SET_PARAMS))
						&& (((PFLT_IF_SET_PARAMS)inBuffer)->FilterSize
								==sizeof (IPX_TRAFFIC_FILTER_INFO)))
					status = SetInFilters (
								((PFLT_IF_SET_PARAMS)inBuffer)->InterfaceIndex,
								((PFLT_IF_SET_PARAMS)inBuffer)->FilterAction,
								outBufLength,
								(PIPX_TRAFFIC_FILTER_INFO)outBuffer);
			
				break;

			case IOCTL_FLT_IF_SET_OUT_FILTERS:
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_IF_SET_OUT_FILTERS.\n"));
				if ((inpBufLength==sizeof (FLT_IF_SET_PARAMS))
						&& (((PFLT_IF_SET_PARAMS)inBuffer)->FilterSize
								==sizeof (IPX_TRAFFIC_FILTER_INFO)))
					status = SetOutFilters (
								((PFLT_IF_SET_PARAMS)inBuffer)->InterfaceIndex,
								((PFLT_IF_SET_PARAMS)inBuffer)->FilterAction,
								outBufLength,
								(PIPX_TRAFFIC_FILTER_INFO)outBuffer);
			
				break;
			case IOCTL_FLT_IF_RESET_IN_FILTERS:
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_IF_RESET_IN_FILTERS.\n"));
				if ((inpBufLength==sizeof (ULONG))
						&& (outBufLength==0))
					status = SetInFilters (
								*((PULONG)inBuffer),
								IPX_TRAFFIC_FILTER_ACTION_DENY,
								0, NULL);
			
				break;
			case IOCTL_FLT_IF_RESET_OUT_FILTERS:
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_IF_RESET_OUT_FILTERS.\n"));
				if ((inpBufLength==sizeof (ULONG))
						&& (outBufLength==0))
					status = SetOutFilters (
								*((PULONG)inBuffer),
								IPX_TRAFFIC_FILTER_ACTION_DENY,
								0, NULL);
			
				break;
			case IOCTL_FLT_IF_GET_IN_FILTERS:
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_IF_GET_IN_FILTERS.\n"));
				if ((inpBufLength==sizeof (ULONG))
						&& (outBufLength>=sizeof (FLT_IF_GET_PARAMS))) {
					Irp->IoStatus.Information 
							= outBufLength-sizeof (FLT_IF_GET_PARAMS);
				    ulBytes = (ULONG)Irp->IoStatus.Information;
					status = GetInFilters (
								*((PULONG)inBuffer),
								&((PFLT_IF_GET_PARAMS)outBuffer)->FilterAction,
								&((PFLT_IF_GET_PARAMS)outBuffer)->TotalSize,
								(PIPX_TRAFFIC_FILTER_INFO)
										((PUCHAR)outBuffer+sizeof (FLT_IF_GET_PARAMS)),
							    &ulBytes);
					Irp->IoStatus.Information = ulBytes;
					if (NT_SUCCESS (status)) {
						Irp->IoStatus.Information += sizeof (FLT_IF_GET_PARAMS);
						((PFLT_IF_GET_PARAMS)outBuffer)->FilterSize
							= sizeof (IPX_TRAFFIC_FILTER_INFO);
					}
					else
						Irp->IoStatus.Information = 0;
				}
				break;
			case IOCTL_FLT_IF_GET_OUT_FILTERS:
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_IF_GET_OUT_FILTERS.\n"));
				if ((inpBufLength==sizeof (ULONG))
						&& (outBufLength>=sizeof (FLT_IF_GET_PARAMS))) {
					Irp->IoStatus.Information 
							= outBufLength-sizeof (FLT_IF_GET_PARAMS);
				    ulBytes = (ULONG)Irp->IoStatus.Information;
					status = GetOutFilters (
								*((PULONG)inBuffer),
								&((PFLT_IF_GET_PARAMS)outBuffer)->FilterAction,
								&((PFLT_IF_GET_PARAMS)outBuffer)->TotalSize,
								(PIPX_TRAFFIC_FILTER_INFO)
										((PUCHAR)outBuffer+sizeof (FLT_IF_GET_PARAMS)),
							    &ulBytes);
					Irp->IoStatus.Information = ulBytes;
					if (NT_SUCCESS (status)) {
						Irp->IoStatus.Information += sizeof (FLT_IF_GET_PARAMS);
						((PFLT_IF_GET_PARAMS)outBuffer)->FilterSize
							= sizeof (IPX_TRAFFIC_FILTER_INFO);
					}
					else
						Irp->IoStatus.Information = 0;
				}
			
				break;
			case IOCTL_FLT_GET_LOGGED_PACKETS:
				IpxFltDbgPrint (DBG_PKTLOGS, ("IpxFlt: IOCTL_FLT_GET_LOGGED_PACKETS.\n"));
				Irp->IoStatus.Status = status = STATUS_PENDING;
				IoMarkIrpPending (Irp);
				IoAcquireCancelSpinLock (&cancelIRQL);
				InsertTailList (&LogIrpQueue,
								&Irp->Tail.Overlay.ListEntry);
				IoSetCancelRoutine (Irp, IpxFltCancel);
				if (LogIrpQueue.Flink!=&Irp->Tail.Overlay.ListEntry) {
					PIRP	irp = CONTAINING_RECORD (
										LogIrpQueue.Flink,
										IRP,
										Tail.Overlay.ListEntry);
					if (irp->IoStatus.Information>0) {
						RemoveEntryList (&irp->Tail.Overlay.ListEntry);
						IoSetCancelRoutine (irp, NULL);
						irp->IoStatus.Status = STATUS_SUCCESS;
						IoReleaseCancelSpinLock (cancelIRQL);
						IpxFltDbgPrint (DBG_PKTLOGS,
							("IpxFlt: completing logging request"
							" with %d bytes of data.\n",
							irp->IoStatus.Information));
						IoCompleteRequest (irp, IO_NO_INCREMENT);
						break;
					}
				}
				IoReleaseCancelSpinLock (cancelIRQL);
				break;
			default:
				IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS,
						("IpxFlt: Unsupported IOCTL %lx.\n",
						IrpStack->Parameters.DeviceIoControl.IoControlCode));
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}
		}
		else if (RouterFile==NULL) {
			if (IrpStack->Parameters.DeviceIoControl.IoControlCode
					==IOCTL_FLT_START) {
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_START.\n"));
				status = InitializeTables ();
				if (NT_SUCCESS (status)) {
					RouterFile  = IrpStack->FileObject;
					status = STATUS_SUCCESS;
				}
			}
			else {
				IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS,
						("IpxFlt: Unsupported IOCTL %lx (driver is not started yet)).\n",
						IrpStack->Parameters.DeviceIoControl.IoControlCode));
				status = STATUS_INVALID_DEVICE_REQUEST;
			}
		}
		else {
			IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS,
					("IpxFlt: Unsupported IOCTL %lx from non-router client.\n",
					IrpStack->Parameters.DeviceIoControl.IoControlCode));
			status = STATUS_INVALID_DEVICE_REQUEST;
		}

		break;
	default:
		IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS,
							("IpxFlt: Unsupported function %lx.\n",
											IrpStack->MajorFunction));
		status = STATUS_INVALID_DEVICE_REQUEST;
		break;
    }

DispatchExit:
    if (status!=STATUS_PENDING) {
	Irp->IoStatus.Status = status;
	if (NT_SUCCESS (status))
		;
	else
		IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS,
							("IpxFlt: Failed call with status %lx.\n",
							status));
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}



/*++

Routine Description:
	Cleans up on driver unload

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/
VOID
IpxFltUnload(
    IN PDRIVER_OBJECT DriverObject
    ) {
	IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: Unloading\n"));
	if (RouterFile!=NULL) {
		DeleteTables ();
		RouterFile = NULL;
	}
	UnbindFromFwdDriver (KernelMode);
    IoDeleteDevice (DriverObject->DeviceObject);
}


/*++
	I p x F l t C a n c e l

Routine Description:
	Cancels specified IRP

Arguments:
	DeviceObject	- forwarder device object
	irp				- irp to cancel

Return Value:
	None
--*/
VOID
IpxFltCancel (
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				irp
	) {
    RemoveEntryList (&irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock (irp->CancelIrql);

    irp->IoStatus.Status = STATUS_CANCELLED;
    IpxFltDbgPrint(DBG_IOCTLS, ("IpxFlt: completing cancelled irp.\n"));
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\winsif.c ===
/*++

Copyright (c) 1989-1994  Microsoft Corporation

Module Name:

    Winsif.c

Abstract:

    This module implements all the code surrounding the WINS interface to
    netbt that allows WINS to share the same 137 socket as netbt.

Author:

    Jim Stewart (Jimst)    1-30-94

Revision History:

--*/


#include "precomp.h"

VOID
NbtCancelWinsIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );
VOID
NbtCancelWinsSendIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );
VOID
WinsDgramCompletion(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status,
    IN  ULONG                   Length
    );

NTSTATUS
CheckIfLocalNameActive(
    IN  tREM_ADDRESS    *pSendAddr
    );

PVOID
WinsAllocMem(
    IN  tWINS_INFO      *pWinsContext,
    IN  ULONG           Size,
    IN  BOOLEAN         Rcv
    );

VOID
WinsFreeMem(
    IN  tWINS_INFO      *pWinsContext,
    IN  PVOID           pBuffer,
    IN  ULONG           Size,
    IN  BOOLEAN         Rcv
    );

VOID
InitiateRefresh (
    );

BOOLEAN RefreshedYet;

//
// take this define from Winsock.h since including winsock.h causes
// redefinition problems with various types.
//
#define AF_UNIX 1
#define AF_INET 2

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGENBT, NTCloseWinsAddr)
#pragma CTEMakePageable(PAGENBT, InitiateRefresh)
#pragma CTEMakePageable(PAGENBT, PassNamePduToWins)
#pragma CTEMakePageable(PAGENBT, NbtCancelWinsIrp)
#pragma CTEMakePageable(PAGENBT, NbtCancelWinsSendIrp)
#pragma CTEMakePageable(PAGENBT, CheckIfLocalNameActive)
#pragma CTEMakePageable(PAGENBT, WinsDgramCompletion)
#pragma CTEMakePageable(PAGENBT, WinsFreeMem)
#pragma CTEMakePageable(PAGENBT, WinsAllocMem)
#endif
//*******************  Pageable Routine Declarations ****************

tWINS_INFO      *pWinsInfo;
LIST_ENTRY      FreeWinsList;
HANDLE           NbtDiscardableCodeHandle={0};
tDEVICECONTEXT  *pWinsDeviceContext = NULL;
ULONG           LastWinsSignature = 0x8000;

#define COUNT_MAX   10

//----------------------------------------------------------------------------
NTSTATUS
NTOpenWinsAddr(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  tIPADDRESS      IpAddress
    )
/*++
Routine Description:

    This Routine handles opening the Wins Object that is used by
    by WINS to send and receive name service datagrams on port 137.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION          pIrpSp;
    NTSTATUS                    status;
    tWINS_INFO                  *pWins;
    CTELockHandle               OldIrq;

    //
    // Page in the Wins Code, if it hasn't already been paged in.
    //
    if ((!NbtDiscardableCodeHandle) &&
        (!(NbtDiscardableCodeHandle = MmLockPagableCodeSection (NTCloseWinsAddr))))
    {
        return (STATUS_UNSUCCESSFUL);
    }

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // if the WINs endpoint structure is not allocated, then allocate it
    // and initialize it.
    //
    if (pWinsInfo)
    {
        status = STATUS_UNSUCCESSFUL;
    }
    else if (!(pWins = NbtAllocMem(sizeof(tWINS_INFO),NBT_TAG('v'))))
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        CTEZeroMemory(pWins,sizeof(tWINS_INFO));
        pWins->Verify = NBT_VERIFY_WINS_ACTIVE;
        InitializeListHead(&pWins->Linkage);
        InitializeListHead(&pWins->RcvList);
        InitializeListHead(&pWins->SendList);

        pWins->RcvMemoryMax  = NbtConfig.MaxDgramBuffering;
        pWins->SendMemoryMax = NbtConfig.MaxDgramBuffering;
        pWins->IpAddress     = IpAddress;

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        pWins->pDeviceContext= GetDeviceWithIPAddress(IpAddress);
        pWins->WinsSignature = LastWinsSignature++;
        pWinsInfo = pWins;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        pIrpSp->FileObject->FsContext   = (PVOID) pWinsInfo;
        pIrpSp->FileObject->FsContext2  = (PVOID) NBT_WINS_TYPE;

        RefreshedYet = FALSE;
        status = STATUS_SUCCESS;
    }

    IF_DBG(NBT_DEBUG_WINS)
        KdPrint(("Nbt:Open Wins Address Rcvd, status= %X\n",status));

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
NTCleanUpWinsAddr(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp
    )
/*++
Routine Description:

    This Routine handles closing the Wins Object that is used by
    by WINS to send and receive name service datagrams on port 137.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION          pIrpSp;
    NTSTATUS                    status;
    CTELockHandle               OldIrq;
    PLIST_ENTRY                 pHead, pEntry;
    tWINSRCV_BUFFER             *pRcv;
    tWINS_INFO                  *pWins = NULL;
    PIRP                        pSendIrp, pRcvIrp;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pWins = pIrpSp->FileObject->FsContext;

    if (pWinsInfo && (pWins == pWinsInfo))
    {
        ASSERT (NBT_VERIFY_HANDLE (pWins, NBT_VERIFY_WINS_ACTIVE));
        pWins->Verify = NBT_VERIFY_WINS_DOWN;

        //
        // prevent any more dgram getting queued up
        //
        pWinsInfo = NULL;

        //
        // free any rcv buffers that may be queued up
        //
        pHead = &pWins->RcvList;
        while (!IsListEmpty(pHead))
        {
            IF_DBG(NBT_DEBUG_WINS)
                KdPrint(("Nbt.NTCleanUpWinsAddr: Freeing Rcv buffered for Wins\n"));

            pEntry = RemoveHeadList(pHead);
            pRcv = CONTAINING_RECORD(pEntry,tWINSRCV_BUFFER,Linkage);

            WinsFreeMem (pWins, pRcv, pRcv->DgramLength,TRUE);
        }

        //
        // return any Send buffers that may be queued up
        //
        pHead = &pWins->SendList;
        while (!IsListEmpty(pHead))
        {

            IF_DBG(NBT_DEBUG_WINS)
                KdPrint(("Nbt.NTCleanUpWinsAddr: Freeing Send Wins Address!\n"));

            pEntry = RemoveHeadList(pHead);
            pSendIrp = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);

            CTESpinFree (&NbtConfig. JointLock, OldIrq);
            NbtCancelCancelRoutine (pSendIrp);
            CTEIoComplete (pSendIrp, STATUS_CANCELLED, 0);
            CTESpinLock (&NbtConfig.JointLock, OldIrq);
        }

        pWins->pDeviceContext = NULL;
        InsertTailList (&FreeWinsList, &pWins->Linkage);

        //
        // Complete any Rcv Irps that may be hanging on this request
        //
        if (pRcvIrp = pWins->RcvIrp)
        {
            pWins->RcvIrp = NULL;
            pRcvIrp->IoStatus.Status = STATUS_CANCELLED;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            NbtCancelCancelRoutine (pRcvIrp);
            CTEIoComplete (pRcvIrp, STATUS_CANCELLED, 0);
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }

        status = STATUS_SUCCESS;
    }
    else
    {
        ASSERT (0);
        status = STATUS_INVALID_HANDLE;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    IF_DBG(NBT_DEBUG_WINS)
        KdPrint(("Nbt.NTCleanUpWinsAddr:  pWins=<%p>, status=<%x>\n", pWins, status));

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
NTCloseWinsAddr(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp
    )
/*++
Routine Description:

    This Routine handles closing the Wins Object that is used by
    by WINS to send and receive name service datagrams on port 137.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION          pIrpSp;
    NTSTATUS                    status;
    CTELockHandle               OldIrq;
    tWINS_INFO                  *pWins = NULL;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // if the WINs endpoint structure is allocated, then deallocate it
    //
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pWins = pIrpSp->FileObject->FsContext;

    if (NBT_VERIFY_HANDLE (pWins, NBT_VERIFY_WINS_DOWN))
    {
        pWins->Verify += 10;
        RemoveEntryList (&pWins->Linkage);
        CTEMemFree (pWins);

        pIrpSp->FileObject->FsContext2 = (PVOID)NBT_CONTROL_TYPE;
        status = STATUS_SUCCESS;
    }
    else
    {
        ASSERT (0);
        status = STATUS_INVALID_HANDLE;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    IF_DBG(NBT_DEBUG_WINS)
        KdPrint(("Nbt.NTCloseWinsAddr:  pWins=<%p>, status=<%x>\n", pWins, status));

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
WinsSetInformation(
    IN  tWINS_INFO      *pWins,
    IN  tWINS_SET_INFO  *pWinsSetInfo
    )
{
    CTELockHandle               OldIrq;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if ((pWins == pWinsInfo) &&
        (pWinsSetInfo->IpAddress))
    {
        pWins->IpAddress        = pWinsSetInfo->IpAddress;
        pWins->pDeviceContext   = GetDeviceWithIPAddress (pWinsSetInfo->IpAddress);
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
VOID
InitiateRefresh (
    )
/*++

Routine Description:

    This routine tries to refresh all names with WINS on THIS node.

Arguments:

    pIrp            - Wins Rcv Irp

Return Value:

    STATUS_PENDING if the buffer is to be held on to , the normal case.

Notes:


--*/

{
    CTELockHandle               OldIrq;
    PLIST_ENTRY                 pHead;
    PLIST_ENTRY                 pEntry;
    ULONG                       Count;
    ULONG                       NumberNames;


    //
    // be sure all net cards have this card as the primary wins
    // server since Wins has to answer name queries for this
    // node.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (!(NodeType & BNODE))
    {
        LONG    i;

        Count = 0;
        NumberNames = 0;

        for (i=0 ;i < NbtConfig.pLocalHashTbl->lNumBuckets ;i++ )
        {
            pHead = &NbtConfig.pLocalHashTbl->Bucket[i];
            pEntry = pHead;
            while ((pEntry = pEntry->Flink) != pHead)
            {
                NumberNames++;
            }
        }

        while (Count < COUNT_MAX)
        {
            if (!(NbtConfig.GlobalRefreshState & NBT_G_REFRESHING_NOW))
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                ReRegisterLocalNames(NULL, FALSE);

                break;
            }
            else
            {
                LARGE_INTEGER   Timout;
                NTSTATUS        Locstatus;

                IF_DBG(NBT_DEBUG_WINS)
                    KdPrint(("Nbt:Waiting for Refresh to finish, so names can be reregistered\n"));

                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                //
                // set a timeout that should be long enough to wait
                // for all names to fail registration with a down
                // wins server.
                //
                // 2 sec*3 retries * 8 names / 5 = 9 seconds a shot.
                // for a total of 90 seconds max.
                //
                Timout.QuadPart = Int32x32To64(
                             MILLISEC_TO_100NS/(COUNT_MAX/2),
                             (NbtConfig.uRetryTimeout*NbtConfig.uNumRetries)
                             *NumberNames);

                Timout.QuadPart = -(Timout.QuadPart);

                //
                // wait for a few seconds and try again.
                //
                Locstatus = KeDelayExecutionThread(
                                            KernelMode,
                                            FALSE,      // Alertable
                                            &Timout);      // Timeout



                Count++;
                if (Count < COUNT_MAX)
                {
                    CTESpinLock(&NbtConfig.JointLock,OldIrq);
                }
            }
        }

    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
RcvIrpFromWins(
    IN  PCTE_IRP        pIrp
    )
/*++

Routine Description:

    This function takes the rcv irp posted by WINS and decides if there are
    any datagram queued waiting to go up to WINS.  If so then the datagram
    is copied to the WINS buffer and passed back up.  Otherwise the irp is
    held by Netbt until a datagram does come in.

Arguments:

    pIrp            - Wins Rcv Irp

Return Value:

    STATUS_PENDING if the buffer is to be held on to , the normal case.

Notes:


--*/

{
    NTSTATUS                status;
    NTSTATUS                Locstatus;
    tREM_ADDRESS            *pWinsBuffer;
    tWINSRCV_BUFFER         *pBuffer;
    PLIST_ENTRY             pEntry;
    CTELockHandle           OldIrq;
    tWINS_INFO              *pWins;
    PIO_STACK_LOCATION      pIrpSp;
    PMDL                    pMdl;
    ULONG                   CopyLength;
    ULONG                   DgramLength;
    ULONG                   BufferLength;

    status = STATUS_INVALID_HANDLE;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pWins = pIrpSp->FileObject->FsContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (!RefreshedYet)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        InitiateRefresh();
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        RefreshedYet = TRUE;
    }

    if ((!pWins) || (pWins != pWinsInfo))
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NTIoComplete(pIrp,status,0);
        return(status);
    }

    if (!IsListEmpty(&pWins->RcvList))
    {
        //
        // There is at least one datagram waiting to be received
        //
        pEntry = RemoveHeadList(&pWins->RcvList);
        pBuffer = CONTAINING_RECORD(pEntry,tWINSRCV_BUFFER,Linkage);

        //
        // Copy the datagram and the source address to WINS buffer and return to WINS
        //
        if ((pMdl = pIrp->MdlAddress) &&
            (pWinsBuffer = MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority)))
        {
            BufferLength = MmGetMdlByteCount(pMdl);
            DgramLength = pBuffer->DgramLength;
            CopyLength = (DgramLength <= BufferLength) ? DgramLength : BufferLength;

            CTEMemCopy ((PVOID)pWinsBuffer, (PVOID)&pBuffer->Address.Family, CopyLength);

            ASSERT(pWinsBuffer->Port);
            ASSERT(pWinsBuffer->IpAddress);

            if (CopyLength < DgramLength)
            {
                Locstatus = STATUS_BUFFER_OVERFLOW;
            }
            else
            {
                Locstatus = STATUS_SUCCESS;
            }
        }
        else
        {
            CopyLength = 0;
            Locstatus = STATUS_UNSUCCESSFUL;
        }

        //
        // subtract from the total amount buffered for WINS since we are
        // passing a datagram up to WINS now.
        //
        pWins->RcvMemoryAllocated -= pBuffer->DgramLength;
        CTEMemFree(pBuffer);

        //
        // pass the irp up to WINS
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        IF_DBG(NBT_DEBUG_WINS)
            KdPrint(("Nbt:Returning Wins rcv Irp immediately with queued dgram, status=%X,pIrp=%X\n"
                        ,status,pIrp));

        pIrp->IoStatus.Information = CopyLength;
        pIrp->IoStatus.Status = Locstatus;

        IoCompleteRequest(pIrp,IO_NO_INCREMENT);

        return Locstatus;
    }

    if (pWins->RcvIrp)
    {
        status = STATUS_NOT_SUPPORTED;
    }
    else
    {
        status = NTCheckSetCancelRoutine(pIrp, NbtCancelWinsIrp, NULL);
        if (NT_SUCCESS(status))
        {
            IF_DBG(NBT_DEBUG_WINS)
                KdPrint(("Nbt:Holding onto Wins Rcv Irp, pIrp =%Xstatus=%X\n", status,pIrp));

            pWins->RcvIrp = pIrp;
            status = STATUS_PENDING;
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (!NT_SUCCESS(status))
    {
        NTIoComplete(pIrp,status,0);
    }

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
PassNamePduToWins (
    IN tDEVICECONTEXT           *pDeviceContext,
    IN PVOID                    pSrcAddress,
    IN tNAMEHDR UNALIGNED       *pNameSrv,
    IN ULONG                    uNumBytes
    )
/*++

Routine Description:

    This function is used to allow NBT to pass name query service Pdu's to
    WINS.  Wins posts a Rcv irp to Netbt.  If the Irp is here then simply
    copy the data to the irp and return it, otherwise buffer the data up
    to a maximum # of bytes. Beyond that limit the datagrams are discarded.

    If Retstatus is not success then the pdu will also be processed by
    nbt. This allows nbt to process packets when wins pauses and
    its list of queued buffers is exceeded.

Arguments:

    pDeviceContext  - card that the request can in on
    pSrcAddress     - source address
    pNameSrv        - ptr to the datagram
    uNumBytes       - length of datagram

Return Value:

    STATUS_PENDING if the buffer is to be held on to , the normal case.

Notes:


--*/

{
    NTSTATUS                Retstatus;
    NTSTATUS                status;
    tREM_ADDRESS            *pWinsBuffer;
    PCTE_IRP                pIrp;
    CTELockHandle           OldIrq;
    PTRANSPORT_ADDRESS      pSourceAddress;
    ULONG                   SrcAddress;
    SHORT                   SrcPort;


    //
    // Get the source port and ip address, since WINS needs this information.
    //
    pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;
    SrcAddress     = ((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr;
    SrcPort     = ((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->sin_port;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    Retstatus = STATUS_SUCCESS;
    if (pWinsInfo)
    {
        if (!pWinsInfo->RcvIrp)
        {
            //
            // Queue the name query pdu if we have not exeeded our current queue
            // length
            //
            if (pWinsInfo->RcvMemoryAllocated < pWinsInfo->RcvMemoryMax)
            {
                tWINSRCV_BUFFER    *pBuffer;

                pBuffer = NbtAllocMem(uNumBytes + sizeof(tWINSRCV_BUFFER)+8,NBT_TAG('v'));
                if (pBuffer)
                {
                    //
                    // check if it is a name reg from this node
                    //
                    if (pNameSrv->AnCount == WINS_SIGNATURE)
                    {
                        pNameSrv->AnCount = 0;
                        pBuffer->Address.Family = AF_UNIX;
                    }
                    else
                    {
                        pBuffer->Address.Family = AF_INET;
                    }

                    CTEMemCopy((PUCHAR)((PUCHAR)pBuffer + sizeof(tWINSRCV_BUFFER)),
                                (PVOID)pNameSrv,uNumBytes);

                    pBuffer->Address.Port = SrcPort;
                    pBuffer->Address.IpAddress = SrcAddress;
                    pBuffer->Address.LengthOfBuffer = uNumBytes;

                    ASSERT(pBuffer->Address.Port);
                    ASSERT(pBuffer->Address.IpAddress);

                    // total amount allocated
                    pBuffer->DgramLength = uNumBytes + sizeof(tREM_ADDRESS);


                    //
                    // Keep track of the total amount buffered so that we don't
                    // eat up all non-paged pool buffering for WINS
                    //
                    pWinsInfo->RcvMemoryAllocated += pBuffer->DgramLength;

                    IF_DBG(NBT_DEBUG_WINS)
                        KdPrint(("Nbt:Buffering Wins Rcv - no Irp, status=%X\n"));
                    InsertTailList(&pWinsInfo->RcvList,&pBuffer->Linkage);

                }
            }
            else
            {
                // this ret status will allow netbt to process the packet.
                //
                Retstatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }
        else
        {
            PMDL    pMdl;
            ULONG   CopyLength;
            ULONG   BufferLength;

            //
            // The recv irp is here so copy the data to its buffer and
            // pass it up to WINS
            //
            pIrp = pWinsInfo->RcvIrp;
            pWinsInfo->RcvIrp = NULL;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            //
            // Copy the datagram and the source address to WINS buffer and return to WINS
            //
            if ((!(pMdl = pIrp->MdlAddress)) ||
                ((BufferLength = MmGetMdlByteCount(pMdl)) <  sizeof(tREM_ADDRESS)) ||
                (!(pWinsBuffer = MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority))))
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                CopyLength = 0;
            }
            else
            {
                if (BufferLength >= (uNumBytes + sizeof(tREM_ADDRESS)))
                {
                    CopyLength = uNumBytes;
                }
                else
                {
                    CopyLength = BufferLength - sizeof(tREM_ADDRESS);
                }

                //
                // check if it is a name reg from this node
                //
                if (pNameSrv->AnCount == WINS_SIGNATURE)
                {
                    pNameSrv->AnCount = 0;
                    pWinsBuffer->Family = AF_UNIX;
                }
                else
                {
                    pWinsBuffer->Family     = AF_INET;
                }
                CTEMemCopy((PVOID)((PUCHAR)pWinsBuffer + sizeof(tREM_ADDRESS)), (PVOID)pNameSrv, CopyLength);

                pWinsBuffer->Port       = SrcPort;
                pWinsBuffer->IpAddress  = SrcAddress;
                pWinsBuffer->LengthOfBuffer = uNumBytes;

                ASSERT(pWinsBuffer->Port);
                ASSERT(pWinsBuffer->IpAddress);

                //
                // pass the irp up to WINS
                //
                if (CopyLength < uNumBytes)
                {
                    status = STATUS_BUFFER_OVERFLOW;
                }
                else
                {
                    status = STATUS_SUCCESS;
                }

                IF_DBG(NBT_DEBUG_WINS)
                    KdPrint(("Nbt:Returning Wins Rcv Irp - data from net, Length=%X,pIrp=%X\n"
                        ,uNumBytes,pIrp));
            }

            NTIoComplete(pIrp,status,CopyLength);
        }
    }
    else
    {
        //
        // this ret status will allow netbt to process the packet.
        //
        Retstatus = STATUS_INSUFFICIENT_RESOURCES;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(Retstatus);

}

//----------------------------------------------------------------------------
VOID
NbtCancelWinsIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a WinsRcv Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    KIRQL                OldIrq;
    PIO_STACK_LOCATION   pIrpSp;
    tWINS_INFO           *pWins;


    IF_DBG(NBT_DEBUG_WINS)
        KdPrint(("Nbt.NbtCancelWinsIrp: Got a Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pWins = (tWINS_INFO *)pIrpSp->FileObject->FsContext;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // Be sure that PassNamePduToWins has not taken the RcvIrp for a
    // Rcv just now.
    //
    if ((NBT_VERIFY_HANDLE (pWins, NBT_VERIFY_WINS_ACTIVE)) &&
        (pWins->RcvIrp == pIrp))
    {
        pWins->RcvIrp = NULL;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        pIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

    }


}
//----------------------------------------------------------------------------
VOID
NbtCancelWinsSendIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a WinsRcv Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    KIRQL                OldIrq;
    PLIST_ENTRY          pHead;
    PLIST_ENTRY          pEntry;
    PIO_STACK_LOCATION   pIrpSp;
    tWINS_INFO           *pWins;
    BOOLEAN              Found;
    PIRP                 pIrpList;


    IF_DBG(NBT_DEBUG_WINS)
        KdPrint(("Nbt.NbtCancelWinsSendIrp: Got a Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pWins = (tWINS_INFO *)pIrpSp->FileObject->FsContext;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (pWins == pWinsInfo)
    {
        //
        // find the matching irp on the list and remove it
        //
        pHead = &pWinsInfo->SendList;
        pEntry = pHead;
        Found = FALSE;

        while ((pEntry = pEntry->Flink) != pHead)
        {
            pIrpList = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);
            if (pIrp == pIrpList)
            {
                RemoveEntryList(pEntry);
                Found = TRUE;
            }
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        if (Found)
        {
            pIrp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);
        }
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}
//----------------------------------------------------------------------------
NTSTATUS
WinsSendDatagram(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  BOOLEAN         MustSend)

/*++
Routine Description:

    This Routine handles sending a datagram down to the transport. MustSend
    it set true by the Send Completion routine when it attempts to send
    one of the queued datagrams, in case we still don't pass the memory
    allocated check and refuse to do the send - sends will just stop then without
    this boolean.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION              pIrpSp;
    NTSTATUS                        status;
    tWINS_INFO                      *pWins;
    tREM_ADDRESS                    *pSendAddr;
    PVOID                           pDgram;
    ULONG                           DgramLength;
    tDGRAM_SEND_TRACKING            *pTracker;
    CTELockHandle                   OldIrq;
    BOOLEAN                         fIsWinsDevice = FALSE;
    ULONG                           DataSize;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pWins = (tWINS_INFO *)pIrpSp->FileObject->FsContext;

    status = STATUS_UNSUCCESSFUL;

    if (!(pSendAddr = (tREM_ADDRESS *) MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority)))
    {
        pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Bug# 234600:  Check if the DataSize is correct
    //
    DataSize = MmGetMdlByteCount (pIrp->MdlAddress);
    if ((DataSize < sizeof(tREM_ADDRESS)) ||
        ((DataSize - sizeof(tREM_ADDRESS)) < pSendAddr->LengthOfBuffer))
    {
        pIrp->IoStatus.Status = STATUS_INVALID_BLOCK_LENGTH;
        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
        return STATUS_INVALID_BLOCK_LENGTH;
    }

    //
    // check if it is a name that is registered on this machine
    //
    if (pSendAddr->Family == AF_UNIX)
    {
        status = CheckIfLocalNameActive(pSendAddr);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if ((pWins) &&
        (pWins == pWinsInfo))
    {
        if (pDeviceContext == pWinsDeviceContext)
        {
            fIsWinsDevice = TRUE;
            if (!(pDeviceContext = pWinsInfo->pDeviceContext) ||
                !(NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_WINS, TRUE)))
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

//                status = STATUS_INVALID_HANDLE;
                status = STATUS_SUCCESS;
                pIrp->IoStatus.Status = status;
                IoCompleteRequest(pIrp,IO_NO_INCREMENT);
                return (status);
            }
        }

        if ((pWins->SendMemoryAllocated < pWins->SendMemoryMax) || MustSend)
        {
            if (pSendAddr->IpAddress != 0)
            {
                DgramLength = pSendAddr->LengthOfBuffer;
                pDgram = WinsAllocMem (pWins, DgramLength, FALSE);

                if (pDgram)
                {
                    CTEMemCopy(pDgram, (PVOID)((PUCHAR)pSendAddr+sizeof(tREM_ADDRESS)), DgramLength);

                    //
                    // get a buffer for tracking Dgram Sends
                    //
                    status = GetTracker(&pTracker, NBT_TRACKER_SEND_WINS_DGRAM);
                    if (NT_SUCCESS(status))
                    {
                        pTracker->SendBuffer.pBuffer   = NULL;
                        pTracker->SendBuffer.Length    = 0;
                        pTracker->SendBuffer.pDgramHdr = pDgram;
                        pTracker->SendBuffer.HdrLength = DgramLength;
                        pTracker->pClientIrp           = NULL;
                        pTracker->pDeviceContext       = pDeviceContext;
                        pTracker->pNameAddr            = NULL;
                        pTracker->pDestName            = NULL;
                        pTracker->UnicodeDestName      = NULL;
                        pTracker->pClientEle           = NULL;
                        pTracker->AllocatedLength      = DgramLength;
                        pTracker->ClientContext        = IntToPtr(pWins->WinsSignature);

                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                        // send the Datagram...
                        status = UdpSendDatagram (pTracker,
                                                  ntohl(pSendAddr->IpAddress),
                                                  WinsDgramCompletion,
                                                  pTracker,               // context for completion
                                                  (USHORT)ntohs(pSendAddr->Port),
                                                  NBT_NAME_SERVICE);

                        IF_DBG(NBT_DEBUG_WINS)
                            KdPrint(("Nbt:Doing Wins Send, status=%X\n",status));

                        // sending the datagram could return status pending,
                        // but since we have buffered the dgram, return status
                        // success to the client
                        //
                        status = STATUS_SUCCESS;
                        //
                        // Fill in the sent size
                        //
                        pIrp->IoStatus.Information = DgramLength;
                    }
                    else
                    {
                        WinsFreeMem (pWins, (PVOID)pDgram,DgramLength,FALSE);

                        CTESpinFree(&NbtConfig.JointLock,OldIrq);
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                else
                {
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            else
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                status = STATUS_INVALID_PARAMETER;
            }

            pIrp->IoStatus.Status = status;
            IoCompleteRequest(pIrp,IO_NO_INCREMENT);
        }
        else
        {
            IF_DBG(NBT_DEBUG_WINS)
                KdPrint(("Nbt:Holding onto Buffering Wins Send, status=%X\n"));

            //
            // Hold onto the datagram till memory frees up
            //
            InsertTailList(&pWins->SendList,&pIrp->Tail.Overlay.ListEntry);

            status = NTCheckSetCancelRoutine(pIrp,NbtCancelWinsSendIrp,NULL);
            if (!NT_SUCCESS(status))
            {
                RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                NTIoComplete(pIrp,status,0);
            }
            else
            {
                status = STATUS_PENDING;
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
            }
        }

        if (fIsWinsDevice)
        {
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_WINS, FALSE);
        }
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        status = STATUS_INVALID_HANDLE;

        pIrp->IoStatus.Status = status;
        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
    }

    return(status);

}


//----------------------------------------------------------------------------
NTSTATUS
CheckIfLocalNameActive(
    IN  tREM_ADDRESS    *pSendAddr
    )

/*++
Routine Description

    This routine checks if this is a name query response and if the
    name is still active on the local node.

Arguments:

    pMdl = ptr to WINS Mdl

Return Values:

    VOID

--*/

{
    NTSTATUS            status;
    tNAMEHDR UNALIGNED  *pNameHdr;
    tNAMEADDR           *pResp;
    UCHAR               pName[NETBIOS_NAME_SIZE];
    PUCHAR              pScope;
    ULONG               lNameSize;
    CTELockHandle       OldIrq;

    pNameHdr = (tNAMEHDR UNALIGNED *)((PUCHAR)pSendAddr + sizeof(tREM_ADDRESS));
    //
    // Be sure it is a name query PDU that we are checking
    //
    if (((pNameHdr->OpCodeFlags & NM_FLAGS_MASK) == OP_QUERY) ||
         ((pNameHdr->OpCodeFlags & NM_FLAGS_MASK) == OP_RELEASE))
    {
        status = ConvertToAscii ((PCHAR)&pNameHdr->NameRR.NameLength,
                                 pSendAddr->LengthOfBuffer,
                                 pName,
                                 &pScope,
                                 &lNameSize);

        if (NT_SUCCESS(status))
        {
            //
            // see if the name is still active in the local hash table
            //
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            status = FindInHashTable(NbtConfig.pLocalHashTbl, pName, pScope, &pResp);

            if ((pNameHdr->OpCodeFlags & NM_FLAGS_MASK) == OP_QUERY)
            {
                if (NT_SUCCESS(status))
                {
                    //
                    // if not resolved then set to negative name query resp.
                    //
                    if (!(pResp->NameTypeState & STATE_RESOLVED))
                    {
                        pNameHdr->OpCodeFlags |= htons(NAME_ERROR);
                    }
                }
                //
                // We can have a scenario where the local machine was a DC
                // at one time, so it set the UNIX to tell Wins when registering
                // the local name.A  However, once that machine is downgraded,
                // Wins will still have the UNIX flag set for that record if
                // there were other DC's also present.
                // Thus, we can have the following scenario where the machine
                // is currently not a DC, but the UNIX flag is set in the response
                // so we should not mark the name in Error.  This would not
                // be a problem if the client is configured with other Wins
                // server addresses, but otherwise it could cause problems!
                // Bug # 54659
                //
                else if (pName[NETBIOS_NAME_SIZE-1] != SPECIAL_GROUP_SUFFIX)
                {
                    pNameHdr->OpCodeFlags |= htons(NAME_ERROR);
                }
            }
            else
            {
                //
                // check if it is a release response - if so we must have
                // received a name release request, so mark the name in
                // conflict and return a positive release response.
                //
                // Note:  The case we are looking at here is if another Wins
                // sent a NameRelease demand for some name to the local machine.
                // Since we pass all name releases up to Wins, NetBT will
                // not get a chance to determine if it is a local name when
                // the release first came in.
                // Typically, Wins should make the call properly as to whether
                // NetBT should mark the local name in conflict or not, but
                // it has been observed that Wins displayed inconsistent behavior
                // setting the UNIX flag only if the local machine was the last
                // to register/refresh the name (Bug # 431042).
                // For now, we will remove this functionality for Group names.
                // 
                if (pNameHdr->OpCodeFlags & OP_RESPONSE)
                {
                    //
                    // Bug # 206192:  If we are sending the response to
                    // ourselves, don't put the name into conflict
                    // (could be due to NbtStat -RR!)
                    //
                    if (NT_SUCCESS(status) &&
                       (pResp->NameTypeState & STATE_RESOLVED) &&
                       (pResp->NameTypeState & NAMETYPE_UNIQUE) &&
                       !(pNameHdr->OpCodeFlags & FL_RCODE) &&       // Only for positive name release response
                       !(SrcIsUs(ntohl(pSendAddr->IpAddress))))
                    {
                        NbtLogEvent (EVENT_NBT_NAME_RELEASE, pSendAddr->IpAddress, 0x122);

                        pResp->NameTypeState &= ~NAME_STATE_MASK;
                        pResp->NameTypeState |= STATE_CONFLICT;
                        pResp->ConflictMask |= pResp->AdapterMask;
                    }
                }
            }
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }
    }

    //
    // the name is not in the local table so fail the datagram send attempt
    //
    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
VOID
WinsDgramCompletion(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status,
    IN  ULONG                   Length
    )

/*++
Routine Description

    This routine cleans up after a data gram send.

Arguments:

    pTracker
    status
    Length

Return Values:

    VOID

--*/

{
    CTELockHandle           OldIrq;
    LIST_ENTRY              *pEntry;
    PIRP                    pIrp;
    BOOLEAN                 MustSend;
#ifdef _PNP_POWER_
    tDEVICECONTEXT          *pDeviceContext;
#endif

    //
    // free the buffer used for sending the data and the tracker - note
    // that the datagram header and the send buffer are allocated as one
    // chunk.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if ((pWinsInfo) &&
        (pTracker->ClientContext == IntToPtr(pWinsInfo->WinsSignature)))
    {
        WinsFreeMem(pWinsInfo,
                    (PVOID)pTracker->SendBuffer.pDgramHdr,
                    pTracker->AllocatedLength,
                    FALSE);

        if (!IsListEmpty(&pWinsInfo->SendList))
        {
#ifdef _PNP_POWER_
            //
            // If there are no devices available to send this request on,
            // complete all pending requests gracefully
            //
            if (!(pDeviceContext = pWinsInfo->pDeviceContext) ||
                !(NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_WINS, TRUE)))
            {
                status = STATUS_PLUGPLAY_NO_DEVICE;

                while (!IsListEmpty(&pWinsInfo->SendList))
                {
                    pEntry = RemoveHeadList(&pWinsInfo->SendList);
                    pIrp = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);

                    NbtCancelCancelRoutine (pIrp);
                    pIrp->IoStatus.Status = status;
                    IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

                    CTESpinLock(&NbtConfig.JointLock,OldIrq);
                }

                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                FreeTracker (pTracker, RELINK_TRACKER);

                return;
            }
#endif  // _PNP_POWER_

            IF_DBG(NBT_DEBUG_WINS)
                KdPrint(("Nbt:Sending another Wins Dgram that is Queued to go\n"));

            pEntry = RemoveHeadList(&pWinsInfo->SendList);
            pIrp = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            NbtCancelCancelRoutine (pIrp);

            //
            // Send this next datagram
            //
            status = WinsSendDatagram(pDeviceContext,
                                      pIrp,
                                      MustSend = TRUE);

            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_WINS, FALSE);
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }
    }
    else
    {
        //
        // just free the memory since WINS has closed its address handle.
        //
        CTEMemFree((PVOID)pTracker->SendBuffer.pDgramHdr);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    FreeTracker (pTracker, RELINK_TRACKER);
}

//----------------------------------------------------------------------------
PVOID
WinsAllocMem(
    IN  tWINS_INFO      *pWinsContext,
    IN  ULONG           Size,
    IN  BOOLEAN         Rcv
    )

/*++
Routine Description:

    This Routine handles allocating memory and keeping track of how
    much has been allocated.

Arguments:

    Size    - number of bytes to allocate
    Rcv     - boolean that indicates if it is rcv or send buffering

Return Value:

    ptr to the memory allocated

--*/

{
    if (Rcv)
    {
        if (pWinsContext->RcvMemoryAllocated > pWinsContext->RcvMemoryMax)
        {
            return NULL;
        }
        else
        {
            pWinsContext->RcvMemoryAllocated += Size;
            return (NbtAllocMem(Size,NBT_TAG('v')));
        }
    }
    else
    {
        if (pWinsContext->SendMemoryAllocated > pWinsContext->SendMemoryMax)
        {
            return(NULL);
        }
        else
        {
            pWinsContext->SendMemoryAllocated += Size;
            return(NbtAllocMem(Size,NBT_TAG('v')));
        }
    }
}
//----------------------------------------------------------------------------
VOID
WinsFreeMem(
    IN  tWINS_INFO      *pWinsContext,
    IN  PVOID           pBuffer,
    IN  ULONG           Size,
    IN  BOOLEAN         Rcv
    )

/*++
Routine Description:

    This Routine handles freeing memory and keeping track of how
    much has been allocated.

Arguments:

    pBuffer - buffer to free
    Size    - number of bytes to allocate
    Rcv     - boolean that indicates if it is rcv or send buffering

Return Value:

    none

--*/

{
    if (pWinsContext)
    {
        if (Rcv)
        {
            pWinsContext->RcvMemoryAllocated -= Size;
        }
        else
        {
            pWinsContext->SendMemoryAllocated -= Size;
        }
    }

    CTEMemFree(pBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\flt\fwdbind.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\flt\fwdbind.c

Abstract:
    IPX Filter driver binding with forwarder routines


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

	// Buffer to keep forwarder entry points
IPX_FLT_BIND_OUTPUT	FltBindOutput;
// global handle of the FWD driver
HANDLE					HdlFwdFile = NULL;


/*++
	B i n d T o F w d D r i v e r

Routine Description:

	Opens  forwarder driver and exchages entry points
Arguments:
	None
Return Value:
	STATUS_SUCCESS if successful,
	STATUS_UNSUCCESSFUL otherwise

--*/
NTSTATUS
BindToFwdDriver (
	KPROCESSOR_MODE requestorMode
	) {
    NTSTATUS					status;
    IO_STATUS_BLOCK				IoStatusBlock;
    OBJECT_ATTRIBUTES			ObjectAttributes;
	UNICODE_STRING				UstrFwdFileName;
	IPX_FLT_BIND_INPUT			FltBindInput = {Filter, InterfaceDeleted};

	ASSERT (HdlFwdFile == NULL);

	RtlInitUnicodeString (&UstrFwdFileName, IPXFWD_NAME);
	InitializeObjectAttributes(
				&ObjectAttributes,
				&UstrFwdFileName,
				OBJ_CASE_INSENSITIVE,
				NULL,
				NULL
				);

	if (requestorMode==UserMode)
		status = ZwCreateFile(&HdlFwdFile,
							SYNCHRONIZE | GENERIC_READ,
							&ObjectAttributes,
							&IoStatusBlock,
							NULL,
							FILE_ATTRIBUTE_NORMAL,
							FILE_SHARE_READ | FILE_SHARE_WRITE,
							FILE_OPEN,
							FILE_SYNCHRONOUS_IO_NONALERT,
							NULL,
							0L);
	else
		status = NtCreateFile(&HdlFwdFile,
							SYNCHRONIZE | GENERIC_READ,
							&ObjectAttributes,
							&IoStatusBlock,
							NULL,
							FILE_ATTRIBUTE_NORMAL,
							FILE_SHARE_READ | FILE_SHARE_WRITE,
							FILE_OPEN,
							FILE_SYNCHRONOUS_IO_NONALERT,
							NULL,
							0L);

	if (NT_SUCCESS(status)) {

		if (requestorMode==UserMode)
			status = ZwDeviceIoControlFile(
							HdlFwdFile,		    // HANDLE to File
							NULL,			    // HANDLE to Event
							NULL,			    // ApcRoutine
							NULL,			    // ApcContext
							&IoStatusBlock,	    // IO_STATUS_BLOCK
							IOCTL_FWD_INTERNAL_BIND_FILTER,	 // IoControlCode
							&FltBindInput,		// Input Buffer
							sizeof(FltBindInput), // Input Buffer Length
							&FltBindOutput,		// Output Buffer
							sizeof(FltBindOutput));// Output Buffer Length
		else
			status = NtDeviceIoControlFile(
							HdlFwdFile,		    // HANDLE to File
							NULL,			    // HANDLE to Event
							NULL,			    // ApcRoutine
							NULL,			    // ApcContext
							&IoStatusBlock,	    // IO_STATUS_BLOCK
							IOCTL_FWD_INTERNAL_BIND_FILTER,	 // IoControlCode
							&FltBindInput,		// Input Buffer
							sizeof(FltBindInput), // Input Buffer Length
							&FltBindOutput,		// Output Buffer
							sizeof(FltBindOutput));// Output Buffer Length
		if (NT_SUCCESS (status))
			return STATUS_SUCCESS;
		else
			IpxFltDbgPrint (DBG_ERRORS,
					("IpxFlt: Failed to bind to forwarder %08lx.\n", status));
		if (requestorMode==KernelMode)
			ZwClose (HdlFwdFile);
		else
			NtClose (HdlFwdFile);
	
	}
	else
		IpxFltDbgPrint (DBG_ERRORS,
				("IpxFlt: Failed create forwarder file %08lx.\n", status));
	HdlFwdFile = NULL;
	return status;
}



/*++
	U n i n d T o F w d D r i v e r

Routine Description:

	Closes forwarder driver
Arguments:
	None
Return Value:
	None

--*/
VOID
UnbindFromFwdDriver (
	KPROCESSOR_MODE requestorMode
	) {
	NTSTATUS	status;

	ASSERT (HdlFwdFile != NULL);

	if (requestorMode==UserMode)
		status = ZwClose (HdlFwdFile);
	else
		status = NtClose (HdlFwdFile);
	ASSERT (NT_SUCCESS (status));
	HdlFwdFile = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\flt\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\precomp.h

Abstract:
    IPX Forwarder driver precompiled header file


Author:

    Vadim Eydelman

Revision History:

--*/

#define ISN_NT 1
#define NT 1

#if DBG
#define DEBUG 1
#endif

// System includes
#include <ntosp.h>
#include <ndis.h>
#include <zwapi.h>

// Routing includes
#include <ipxfltdf.h>
#include <ipxfwd.h>
#include <ipxtfflt.h>

// IPX shared includes
#include "ipxfltif.h"

// Internal module prototypes
#include "filter.h"
#include "fwdbind.h"
#include "debug.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\debug.c ===
#include "precomp.h"

#if DBG
ULONG   DbgLevel = DEF_DBG_LEVEL;
LONGLONG ActivityTreshhold = _I64_MAX;
LARGE_INTEGER CounterFrequency;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\flt\fwdbind.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\flt\fwdbind.h

Abstract:
    IPX Filter driver binding with forwarder routines


Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFLT_FWDBIND_
#define _IPXFLT_FWDBIND_


	// Buffer to keep forwarder entry points
extern IPX_FLT_BIND_OUTPUT	FltBindOutput;

	// Forwarder entry points macros
#define FwdSetFilterInContext (FltBindOutput.SetIfInContextHandler)
#define FwdSetFilterOutContext (FltBindOutput.SetIfOutContextHandler)


/*++
	B i n d T o F w d D r i v e r

Routine Description:

	Opens  forwarder driver and exchages entry points
Arguments:
	None
Return Value:
	STATUS_SUCCESS if successful,
	STATUS_UNSUCCESSFUL otherwise

--*/
NTSTATUS
BindToFwdDriver (
	KPROCESSOR_MODE requestorMode
	);

/*++
	U n i n d T o F w d D r i v e r

Routine Description:

	Closes forwarder driver
Arguments:
	None
Return Value:
	None

--*/
VOID
UnbindFromFwdDriver (
	KPROCESSOR_MODE requestorMode
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\ddreqs.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\ddreqs.c

Abstract:
	Management of demand dial request queues


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

LIST_ENTRY	ConnectionIrpQueue;
LIST_ENTRY	ConnectionRequestQueue;

/*++
	Q u e u e C o n n e c t i o n R e q u e s t

Routine Description:
	Adds request to connected the interface to the queue

Arguments:
	ifCB	- control block of the interface that needs to be
				connected
    packet  - packet that prompted the connection request
    data    - pointer to actual data in the packet
	oldIRQL	- IRQL at which interface lock was acquired

Return Value:
	None

	Note that interface lock must be acquired before calling this
	routine which will release it

--*/
VOID
QueueConnectionRequest (
	PINTERFACE_CB	ifCB,
    PNDIS_PACKET    packet,
    PUCHAR          data,
	KIRQL			oldIRQL
	) {
	KIRQL	cancelIRQL;

	IoAcquireCancelSpinLock (&cancelIRQL);
	SET_IF_CONNECTING (ifCB);
	if (!IsListEmpty (&ConnectionIrpQueue)) {
	    ULONG ulBytes = 0;
		PIRP				irp = CONTAINING_RECORD (
										ConnectionIrpQueue.Flink,
										IRP,
										Tail.Overlay.ListEntry);
		PIO_STACK_LOCATION	irpStack=IoGetCurrentIrpStackLocation(irp);
		RemoveEntryList (&irp->Tail.Overlay.ListEntry);
		ASSERT (irpStack->Parameters.DeviceIoControl.IoControlCode
										==IOCTL_FWD_GET_DIAL_REQUEST);
		ASSERT ((irpStack->Parameters.DeviceIoControl.IoControlCode&3)
										==METHOD_BUFFERED);
        IoSetCancelRoutine (irp, NULL);
		IoReleaseCancelSpinLock (cancelIRQL);

        FillConnectionRequest (
                ifCB->ICB_Index,
                packet,
                data,
				(PFWD_DIAL_REQUEST)irp->AssociatedIrp.SystemBuffer,
				irpStack->Parameters.DeviceIoControl.OutputBufferLength,
				&ulBytes);
		irp->IoStatus.Information = ulBytes;
        irp->IoStatus.Status = STATUS_SUCCESS;

		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
    	IpxFwdDbgPrint (DBG_DIALREQS, DBG_WARNING,
	    	("IpxFwd: Passing dial request for if %ld (icb:%08lx) with %d bytes of data.\n",
		    ifCB->ICB_Index, ifCB, irp->IoStatus.Information));
		IoCompleteRequest (irp, IO_NO_INCREMENT);
	}
	else {
    	InsertTailList (&ConnectionRequestQueue, &ifCB->ICB_ConnectionLink);
		IoReleaseCancelSpinLock (cancelIRQL);
        ifCB->ICB_ConnectionPacket = packet;
        ifCB->ICB_ConnectionData = data;
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
	}
}

/*++
	D e q u e u e C o n n e c t i o n R e q u e s t

Routine Description:
	Removes conection requset for the interface from the queue

Arguments:
	ifCB	- control block of the interface that needs to be
				removed

Return Value:
	None

--*/
VOID
DequeueConnectionRequest (
	PINTERFACE_CB	ifCB
	) {
	KIRQL	cancelIRQL;
	IoAcquireCancelSpinLock (&cancelIRQL);
	if (IsListEntry (&ifCB->ICB_ConnectionLink)) {
		RemoveEntryList (&ifCB->ICB_ConnectionLink);
		InitializeListEntry (&ifCB->ICB_ConnectionLink);
	}
	IoReleaseCancelSpinLock (cancelIRQL);
}

/*++
	F i l l C o n n e c t i o n R e q u e s t

Routine Description:
	Fills the provided buffer with index of interface that needs
	to be connected and packet that prompted the request
	
Arguments:
    index   - if index
    packet  - packet that prompted the request
    data    - pointer to IPX data (IPX header) inside of the packet
	request	- request buffer to fill
    reqSize - size of request buffer
    bytesCopied - bytesCopied into the request buffer

Return Value:
	STATUS_SUCCESS - array was filled successfully
	This routine assumes that there it is called only when there
	are outstanding requests in the request queue

--*/
VOID
FillConnectionRequest (
    IN ULONG                    index,
    IN PNDIS_PACKET             packet,
    IN PUCHAR                   data,
	IN OUT PFWD_DIAL_REQUEST	request,
    IN ULONG                    reqSize,
    OUT PULONG                  bytesCopied
    ) {
    PNDIS_BUFFER    buf;

    *bytesCopied = 0;
	request->IfIndex = index;
    NdisQueryPacket (packet, NULL, NULL, &buf, NULL);
    do {
        PVOID   va;
        UINT    length;

        NdisQueryBuffer (buf, &va, &length);
        if (((PUCHAR)va<=data)
                && ((PUCHAR)va+length>data)) {
            TdiCopyMdlToBuffer (buf,
                    (ULONG)(data-(PUCHAR)va),
                    request,
                    FIELD_OFFSET (FWD_DIAL_REQUEST, Packet),
                    reqSize,
                    bytesCopied);
            *bytesCopied += FIELD_OFFSET (FWD_DIAL_REQUEST, Packet);
            break;
        }
        NdisGetNextBuffer (buf, &buf);
    }
    while (buf!=NULL);
}

/*++
	F a i l C o n n e c t i o n R e q u e s t s

Routine Description:
	Cleans up on connection request failure
	
Arguments:
	InterfaceIndex - index of interface that could not be connected

Return Value:
	STATUS_SUCCESS - clean up was successfull
	STATUS_UNSUCCESSFUL - interface with this index does not exist

--*/
NTSTATUS
FailConnectionRequest (
	IN ULONG	InterfaceIndex
	) {
	PINTERFACE_CB	ifCB;
	KIRQL			oldIRQL;

	ASSERT (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX);

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
	    IpxFwdDbgPrint (DBG_DIALREQS, DBG_WARNING,
			("IpxFwd: Dial request failed for if %ld (icb:%08lx).\n",
			ifCB->ICB_Index, ifCB));
		ProcessInternalQueue (ifCB);
		ProcessExternalQueue (ifCB);
		KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
		if (IS_IF_CONNECTING (ifCB)) {
			SET_IF_NOT_CONNECTING (ifCB);
			DequeueConnectionRequest (ifCB);
		}
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
		ReleaseInterfaceReference (ifCB);
		return STATUS_SUCCESS;
	}
	else
		return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\ddreqs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\ddreqs.h

Abstract:
	Management of demand dial request queues


Author:

    Vadim Eydelman

Revision History:

--*/
#ifndef _IPXFWD_DDREQS_
#define _IPXFWD_DDREQS_

// Connection requests to DIM
//	Queue of request that need to be satisfied by DIM
extern LIST_ENTRY ConnectionRequestQueue;
//	Queue of request IRPs posted by the router manager
extern LIST_ENTRY ConnectionIrpQueue;

/*++
	I n i t i a l i z e C o n n e c t i o n Q u e u e s

Routine Description:
	Initializes connection request and irp queues
	
Arguments:
	None

Return Value:
	None

--*/
//VOID
//InitializeConnectionQueues (
//	void
//	);
#define InitializeConnectionQueues() {									\
	InitializeListHead (&ConnectionIrpQueue);							\
	InitializeListHead (&ConnectionRequestQueue);						\
}

/*++
	F i l l C o n n e c t i o n R e q u e s t

Routine Description:
	Fills the provided buffer with index of interface that needs
	to be connected and packet that prompted the request
	
Arguments:
    index   - if index
    packet  - packet that prompted the request
    data    - pointer to IPX data (IPX header) inside of the packet
	request	- request buffer to fill
    reqSize - size of request buffer
    bytesCopied - bytesCopied into the request buffer

Return Value:
	STATUS_SUCCESS - array was filled successfully
	This routine assumes that there it is called only when there
	are outstanding requests in the request queue

--*/
VOID
FillConnectionRequest (
    IN ULONG                    index,
    IN PNDIS_PACKET             packet,
    IN PUCHAR                   data,
	IN OUT PFWD_DIAL_REQUEST	request,
    IN ULONG                    reqSize,
    OUT PULONG                  bytesCopied
	);

/*++
	F a i l C o n n e c t i o n R e q u e s t s

Routine Description:
	Cleans up on connection request failure
	
Arguments:
	InterfaceIndex - index of interface that could not be connected

Return Value:
	STATUS_SUCCESS - clean up was successfull
	STATUS_UNSUCCESSFUL - interface with this index does not exist

--*/
NTSTATUS
FailConnectionRequest (
	IN ULONG	InterfaceIndex
	);
	
/*++
	Q u e u e C o n n e c t i o n R e q u e s t

Routine Description:
	Adds request to connected the interface to the queue

Arguments:
	ifCB	- control block of the interface that needs to be
				connected
    packet  - packet that prompted the connection request
    data    - pointer to actual data in the packet
	oldIRQL	- IRQL at which interface lock was acquired

Return Value:
	None

	Note that interface lock must be acquired before calling this
	routine which will release it

--*/
VOID
QueueConnectionRequest (
	PINTERFACE_CB	ifCB,
    PNDIS_PACKET    packet,
    PUCHAR          data,
	KIRQL			oldIRQL
	);

/*++
	D e q u e u e C o n n e c t i o n R e q u e s t

Routine Description:
	Removes conection requset for the interface from the queue

Arguments:
	ifCB	- control block of the interface that needs to be
				removed

Return Value:
	None

--*/
VOID
DequeueConnectionRequest (
	PINTERFACE_CB	ifCB
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\driver.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\driver.h

Abstract:
    IPX Forwarder driver dispatch routines


Author:

    Vadim Eydelman

Revision History:

--*/


#ifndef _IPXFWD_DRIVER_
#define _IPXFWD_DRIVER_

// Pseudo constant 0xFFFFFFFFFFFFF
extern const UCHAR BROADCAST_NODE[6];

// Performance measurement:
//	Enabling flag
extern BOOLEAN			MeasuringPerformance;
//	Access control
extern KSPIN_LOCK		PerfCounterLock;
//	Statistic accumulators (counters)
extern FWD_PERFORMANCE	PerfBlock;

// Access control for external callers (ipx stack, filter driver)
//	Flag set upon completion of initialization of all components
extern volatile BOOLEAN IpxFwdInitialized;
//	Number of clients executing forwarder code (if -1, the forwarder
//	is being stopped)
extern LONG		ClientCount;
//	Event to be signalled by the last client inside forwarder
extern KEVENT	ClientsGoneEvent;

 
/*++
	E n t e r F o r w a r d e r

Routine Description:
	Checks if forwarder is initialized and grants access
	to it (records the entrance as well

Arguments:
	None

Return Value:
	TRUE - access granted
	FALSE - forwarder is not yet initialized or is being stopped

--*/
//BOOLEAN
//EnterForwarder (
//	void
//	);
#define EnterForwarder() (									\
	(InterlockedIncrement(&ClientCount), IpxFwdInitialized) \
			? TRUE											\
			: (DoLeaveForwarder(), FALSE)						\
	)

/*++
	L e a v e F o r w a r d e r

Routine Description:
	Records the fact that external client stopped using forwarder
	
Arguments:
	None

Return Value:
	None

--*/
//BOOLEAN
//EnterForwarder (
//	void
//	);
#define LeaveForwarder()							\
	((InterlockedDecrement(&ClientCount)<0)			\
		? KeSetEvent (&ClientsGoneEvent,0,FALSE)	\
		: 0											\
	)

// Same as above but implemented as a routine to be used in
// the EnterForwarder macro above (this reduces code size
// and aids in debugging by improving readability of disassembly
BOOLEAN
DoLeaveForwarder (
	VOID
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\debug.h ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	debug.h
//
// Description: Debug macros definitions
//
// Author:	Stefan Solomon (stefans)    October 4, 1993.
//
// Revision History:
//
//***

#ifndef _IPXFWD_DEBUG_
#define _IPXFWD_DEBUG_

#if DBG
#define DBG_PACKET_ALLOC	((ULONG)0x00000001)
#define DBG_INTF_TABLE		((ULONG)0x00000002)
#define DBG_ROUTE_TABLE		((ULONG)0x00000004)
#define DBG_NBROUTE_TABLE	((ULONG)0x00000008)
#define DBG_IOCTLS			((ULONG)0x00000010)
#define DBG_LINEIND			((ULONG)0x00000020)
#define DBG_IPXBIND			((ULONG)0x00000040)
#define DBG_REGISTRY		((ULONG)0x00000080)
#define DBG_INT_RECV		((ULONG)0x00000100)
#define DBG_RECV			((ULONG)0x00000200)
#define DBG_SEND			((ULONG)0x00000400)
#define DBG_INT_SEND		((ULONG)0x00000800)
#define DBG_NETBIOS			((ULONG)0x00001000)
#define DBG_IPXROUTE		((ULONG)0x00002000)
#define DBG_DIALREQS		((ULONG)0x00004000)
#define DBG_SPOOFING		((ULONG)0x00008000)

#define DBG_INFORMATION		((ULONG)0x10000000)
#define DBG_WARNING			((ULONG)0x20000000)
#define DBG_ERROR			((ULONG)0x40000000)

#define DEF_DBG_LEVEL (					\
			DBG_ERROR|DBG_WARNING		\
			| DBG_INTF_TABLE			\
			| DBG_LINEIND				\
			| DBG_IPXBIND				\
			| DBG_REGISTRY				\
			| DBG_IPXROUTE				\
			| DBG_IOCTLS				\
			| DBG_DIALREQS				\
			| DBG_SPOOFING				\
		)

extern ULONG DbgLevel;
extern LONGLONG ActivityTreshhold;
extern LARGE_INTEGER CounterFrequency;

#define IpxFwdDbgPrint(COMPONENT,LEVEL,ARGS)							\
	do {															    \
		if ((DbgLevel & ((COMPONENT)|(LEVEL)))==((COMPONENT)|(LEVEL))){ \
			DbgPrint ARGS;											    \
		}															    \
	} while (0)

#else
#define IpxFwdDbgPrint(COMPONENT,LEVEL,ARGS) do {NOTHING;} while (0)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\filterif.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\filterif.c

Abstract:
    IPX Forwarder driver interface with filter driver


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

	// Filter driver entry points
IPX_FLT_BIND_INPUT FltBindInput = {NULL, NULL};
	// Protects access to filter driver contexts
RW_LOCK		FltLock;


/*++
	D o F i l t e r

Routine Description:
	
	Calls filter driver entry point while holding reader access
	to interface contexts

Arguments:
	ipxHdr			- pointer to packet header
	ipxHdrLength	- size of the header buffer (must be at least 30)
	ifInContext		- context associated with interface on which packet
						was received
	ifOutContext	- context associated with interface on which packet
						will be sent
Return Value:
	FILTER_PERMIT	- packet should be passed on by the forwarder
	FILTER_DENY		- packet should be dropped

--*/
FILTER_ACTION
DoFilter (
	IN PUCHAR	ipxHdr,
	IN ULONG	ipxHdrLength,
	IN PVOID	ifInContext,
	IN PVOID	ifOutContex
	) {
	RWCOOKIE		cookie;
	FILTER_ACTION	result;
	AcquireReaderAccess (&FltLock, cookie);
	result = FltBindInput.FilterHandler (ipxHdr,
							ipxHdrLength,
							ifInContext,
							ifOutContex); 
	ReleaseReaderAccess (&FltLock, cookie);
	return result;
}

/*++
	D o I n t e r f a c e D e l e t e d

Routine Description:
	Resets interface contexts and calls filter dirver entry point
	making sure that all no one holds reader access to filter driver
	interface contexts
Arguments:
	ifCB	 - interface to be deleted
Return Value:
	None

--*/
VOID
DoInterfaceDeleted (
	PINTERFACE_CB	ifCB
	) {
	PVOID	inContext = ifCB->ICB_FilterInContext,
			outContext = ifCB->ICB_FilterOutContext;
	ifCB->ICB_FilterInContext = NO_FILTER_CONTEXT;
	ifCB->ICB_FilterOutContext = NO_FILTER_CONTEXT;
	WaitForAllReaders (&FltLock);
	FltBindInput.InterfaceDeletedHandler(inContext,
							outContext);
}

/*++
	S e t I f I n C o n t e x t

Routine Description:
	Associates filter driver context with
	the packets received on the interface
Arguments:
	InterfaceIndex	- index of the interface
	ifInContext		- filter driver context
Return Value:
	STATUS_SUCCESS	- context associated ok
	STATUS_UNSUCCESSFUL - interface does not exist
--*/
NTSTATUS
SetIfInContext (
	IN ULONG	InterfaceIndex,
	IN PVOID	ifInContext
	) {
	PINTERFACE_CB	ifCB;
    NTSTATUS        status = STATUS_SUCCESS;

    if (EnterForwarder ()) { 
	    ifCB = GetInterfaceReference (InterfaceIndex);
	    if (ifCB!=NULL) {
		    ifCB->ICB_FilterInContext = ifInContext;
		    WaitForAllReaders (&FltLock);
    	    ReleaseInterfaceReference(ifCB);
	    }
	    else
		    status = STATUS_UNSUCCESSFUL;
        LeaveForwarder ();
    }
    return status;
}

/*++
	S e t I f O u t C o n t e x t

Routine Description:
	Associates filter driver context with
	the packets sent on the interface
Arguments:
	InterfaceIndex	- index of the interface
	ifOutContext	- filter driver context
Return Value:
	STATUS_SUCCESS	- context associated ok
	STATUS_UNSUCCESSFUL - interface does not exist
--*/
NTSTATUS
SetIfOutContext (
	IN ULONG	InterfaceIndex,
	IN PVOID	ifOutContext
	) {
	PINTERFACE_CB	ifCB;
    NTSTATUS        status = STATUS_SUCCESS;

    if (EnterForwarder ()) { 
    	ifCB = GetInterfaceReference (InterfaceIndex);
	    if (ifCB!=NULL) {
		    ifCB->ICB_FilterOutContext = ifOutContext;
		    WaitForAllReaders (&FltLock);
    	    ReleaseInterfaceReference(ifCB);
    	}
	    else
		    status = STATUS_UNSUCCESSFUL;
        LeaveForwarder ();
    }
    return status;
}

/*++
	B i n d F i l t e r D r i v e r

Routine Description:
	Exchanges entry points with filter driver
Arguments:
	bindInput	- filter driver entry points
	bindOutput	- forwarder driver entry points
Return Value:
	None
--*/
VOID
BindFilterDriver (
	IN PIPX_FLT_BIND_INPUT		bindInput,
	OUT PIPX_FLT_BIND_OUTPUT	bindOutput
	) {
	memcpy (&FltBindInput, bindInput, sizeof (IPX_FLT_BIND_INPUT));
	bindOutput->Size = sizeof (IPX_FLT_BIND_OUTPUT);
	bindOutput->SetIfInContextHandler = SetIfInContext;
	bindOutput->SetIfOutContextHandler = SetIfOutContext;
	InitializeRWLock (&FltLock); 
}

/*++
	U n b i n d F i l t e r D r i v e r

Routine Description:
	Resets locally stored filter driver entry points
	and resets filter driver contexts on all interfaces
Arguments:
	None
Return Value:
	None
--*/
VOID
UnbindFilterDriver (
	VOID
	) {
	PINTERFACE_CB	ifCB = NULL;
	FltBindInput.FilterHandler = NULL;
	FltBindInput.InterfaceDeletedHandler = NULL;
	
	while ((ifCB=GetNextInterfaceReference (ifCB))!=NULL) {
		ifCB->ICB_FilterInContext = NO_FILTER_CONTEXT;
		ifCB->ICB_FilterOutContext = NO_FILTER_CONTEXT;
	}
	InternalInterface->ICB_FilterInContext = NO_FILTER_CONTEXT;
	InternalInterface->ICB_FilterOutContext = NO_FILTER_CONTEXT;
	WaitForAllReaders (&FltLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\driver.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\driver.c

Abstract:
    IPX Forwarder driver dispatch routines


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

const UCHAR BROADCAST_NODE[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
const LONGLONG WaitTimeout = -50000000i64;
volatile BOOLEAN IpxFwdInitialized = FALSE;

BOOLEAN			MeasuringPerformance = FALSE;
KSPIN_LOCK		PerfCounterLock;
FWD_PERFORMANCE PerfBlock;

LONG		ClientCount = 0;
KEVENT		ClientsGoneEvent;

PFILE_OBJECT	RouterFile, FilterFile;

NTSTATUS
IpxFwdDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
IpxFwdUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DoStart (
	IN ULONG	RouteHashTableSize,
	IN BOOLEAN	thisMachineOnly
	);

NTSTATUS
DoStop (
	void
	);

NTSTATUS
DoSetInterface (
	IN ULONG		InterfaceIndex,
	IN BOOLEAN		NetbiosAccept,
	IN UCHAR		NetbiosDeliver
	);

NTSTATUS
DoGetInterface (
	IN ULONG			InterfaceIndex,
	OUT PFWD_IF_STATS	stats,
	OUT BOOLEAN			*NetbiosAccept,
	OUT UCHAR			*NetbiosDeliver
	);

NTSTATUS
DoSetNbNames (
	IN ULONG			InterfaceIndex,
	IN ULONG			Count,
	IN PFWD_NB_NAME		Names
	);

NTSTATUS
DoGetNbNames (
	IN ULONG			InterfaceIndex,
	IN OUT ULONG    	*BufferSize,
	OUT ULONG			*Count,
	OUT PFWD_NB_NAME	Names
	);

NTSTATUS
DoBindInterface (
	IN ULONG						InterfaceIndex,
	IN PFWD_ADAPTER_BINDING_INFO	info
	);

NTSTATUS
DoUnbindInterface (
	IN ULONG					InterfaceIndex
	);

NTSTATUS
DoDisableInterface (
	IN ULONG					InterfaceIndex
	);

NTSTATUS
DoEnableInterface (
	IN ULONG					InterfaceIndex
	);

NTSTATUS
DoSetRoutes (
	IN PFWD_ROUTE_SET_PARAMS	routeArray,
	IN ULONG					nRoutes,
	OUT PULONG					nProcessed
	);

VOID
IpxFwdCancel (
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				irp
	);

NTSTATUS
DoGetPerfCounters (
	OUT PFWD_PERFORMANCE_PARAMS	perfParams,
	OUT ULONG* plSize
	);

// [pmay] Keep the forwarder sync'd with the stack's nic id
// numbering scheme.
NTSTATUS DecrementNicids (USHORT usThreshold);
NTSTATUS IncrementNicids (USHORT usThreshold);
NTSTATUS DoGetIfTable    (FWD_INTERFACE_TABLE_ROW * pRows,
                          ULONG dwRowBufferSize);

	
/*++
	D r i v e r E n t r y

Routine Description:

	Installable driver initialization entry point.
	This entry point is called directly by the I/O system.

Arguments:

	DriverObject - pointer to the driver object

	RegistryPath - pointer to a unicode string representing the path
				   to driver-specific key in the registry

Return Value:

	STATUS_SUCCESS if successful,
	STATUS_UNSUCCESSFUL otherwise

--*/
NTSTATUS
DriverEntry (
	IN PDRIVER_OBJECT  DriverObject,
	IN PUNICODE_STRING RegistryPath
	) {

	PDEVICE_OBJECT deviceObject = NULL;
	NTSTATUS       status;
	WCHAR          deviceNameBuffer[] = IPXFWD_NAME;
	UNICODE_STRING deviceNameUnicodeString;

	IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION,
								("IpxFwd: Entering DriverEntry\n"));

	//
	// Create an non-EXCLUSIVE device object
	//

	RtlInitUnicodeString (&deviceNameUnicodeString,
						  deviceNameBuffer);

	status = IoCreateDevice (DriverObject,
							   0,
							   &deviceNameUnicodeString,
							   FILE_DEVICE_IPXFWD,
							   0,
							   FALSE,		// Non-Exclusive
							   &deviceObject
							   );

	if (NT_SUCCESS(status)) {
		//
		// Create dispatch points for device control, create, close.
		//
		GetForwarderParameters (RegistryPath);
		DriverObject->MajorFunction[IRP_MJ_CREATE]
			= DriverObject->MajorFunction[IRP_MJ_CLEANUP]
			= DriverObject->MajorFunction[IRP_MJ_CLOSE]
			= DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]
			= IpxFwdDispatch;
		DriverObject->DriverUnload = IpxFwdUnload;
		status = BindToIpxDriver (KernelMode);
		if (NT_SUCCESS (status)) {

#if DBG
			KeQueryPerformanceCounter (&CounterFrequency);
#endif
			FilterFile = RouterFile = NULL;
			ClientCount = 0;
			return STATUS_SUCCESS;
		}
    IoDeleteDevice (DriverObject->DeviceObject);
	}
	else
		IpxFwdDbgPrint (DBG_IOCTLS, DBG_ERROR,
							("IpxFwd: IoCreateDevice failed\n"));

	return status;
}



/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
NTSTATUS
IpxFwdDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    ) {
    PIO_STACK_LOCATION	IrpStack;
    PVOID				inBuffer, outBuffer;
    ULONG				inpBufLength;
    ULONG				outBufLength;
    NTSTATUS			status;
	KIRQL				cancelIRQL;
    LONG                lNumProcessed;
    ULONG               ulBytesCopied;

    ulBytesCopied = 0;
    lNumProcessed = 0;
    Irp->IoStatus.Information = 0;
	status = STATUS_SUCCESS;

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    IrpStack = IoGetCurrentIrpStackLocation(Irp);


    switch (IrpStack->MajorFunction) {
	case IRP_MJ_CREATE:
		IpxFwdDbgPrint(DBG_IOCTLS, DBG_WARNING, ("IpxFwd: IRP_MJ_CREATE\n"));
		break;

	case IRP_MJ_CLOSE:
		IpxFwdDbgPrint(DBG_IOCTLS,  DBG_WARNING, ("IpxFwd: IRP_MJ_CLOSE\n"));
		if (EnterForwarder ()) {
			if (IrpStack->FileObject==RouterFile) {
				LeaveForwarder ();
				IpxFwdInitialized = FALSE;
				while (InterlockedDecrement (&ClientCount)>=0) {
					KeWaitForSingleObject (&ClientsGoneEvent,
												Executive,
												KernelMode,
												FALSE,
												(PLARGE_INTEGER)&WaitTimeout);
					InterlockedIncrement (&ClientCount);
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_ERROR,
							("IpxFwd: Waiting for all clients (%ld) to exit.\n",
							ClientCount));
				}
				status = DoStop ();
				ClientCount = 0;
				RouterFile = NULL;
			}
			else if (IrpStack->FileObject==FilterFile) {
				UnbindFilterDriver ();
				FilterFile = NULL;
				LeaveForwarder ();
			}
			else
				LeaveForwarder ();
		}
		break;

	case IRP_MJ_CLEANUP:
		IpxFwdDbgPrint(DBG_IOCTLS, DBG_WARNING, ("IpxFwd: IRP_MJ_CLEANUP\n"));
		if (EnterForwarder ()) {
			if (IrpStack->FileObject==RouterFile) {
				IoAcquireCancelSpinLock (&cancelIRQL);
				while (!IsListEmpty (&ConnectionIrpQueue)) {
					PIRP irp = CONTAINING_RECORD (ConnectionIrpQueue.Blink,
										IRP, Tail.Overlay.ListEntry);
					irp->Cancel = TRUE;
					irp->CancelIrql = cancelIRQL;
					irp->CancelRoutine = NULL;
					IpxFwdCancel(DeviceObject, irp);
					IoAcquireCancelSpinLock (&cancelIRQL);
				}
				IoReleaseCancelSpinLock(cancelIRQL);
			}
			LeaveForwarder ();
		}
		break;

	case IRP_MJ_DEVICE_CONTROL:
    //
    // Get the pointer to the input/output buffer and it's length
    //

		status = STATUS_INVALID_PARAMETER;
		inpBufLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
		outBufLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
		switch (IrpStack->Parameters.DeviceIoControl.IoControlCode&3) {
		case METHOD_BUFFERED:
			inBuffer = outBuffer = Irp->AssociatedIrp.SystemBuffer;
			break;

		case METHOD_IN_DIRECT:
		case METHOD_OUT_DIRECT:
			inBuffer = Irp->AssociatedIrp.SystemBuffer;
			if (outBufLength>0) {
				outBuffer = MmGetSystemAddressForMdlSafe (Irp->MdlAddress, NormalPagePriority);
				if (outBuffer == NULL)
				{
        			IpxFwdDbgPrint(DBG_IOCTLS, DBG_ERROR,
        				("IpxFwd: System too low on memory to allocate mdl buffer.\n"));
        			goto DispatchExit;
				}
			}
			else {
				outBuffer = NULL;
				IpxFwdDbgPrint(DBG_IOCTLS, DBG_ERROR,
					("IpxFwd: IOCTL...METHOD_DIRECT with 0 output buffer ???\n"));
			}
			break;
		default:
			IpxFwdDbgPrint(DBG_IOCTLS, DBG_ERROR,
				("IpxFwd: IOCTL...METHOD_NEITHER ???\n"));
			goto DispatchExit;
		}


		if (EnterForwarder ()) {
			if (IrpStack->FileObject==RouterFile) {
				switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
				case IOCTL_FWD_SET_ROUTES:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_SET_ROUTES\n"));
					if (inpBufLength>=sizeof (FWD_ROUTE_SET_PARAMS))
						status = DoSetRoutes (
									(PFWD_ROUTE_SET_PARAMS)inBuffer,
									inpBufLength/sizeof(FWD_ROUTE_SET_PARAMS),
									&lNumProcessed);
				
					break;

				case IOCTL_FWD_SET_NB_NAMES:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_SET_NB_NAMES\n"));
					if (inpBufLength==sizeof (ULONG))
						status = DoSetNbNames (
								*((PULONG)inBuffer),
								outBufLength/sizeof (FWD_NB_NAME),
								(PFWD_NB_NAME)outBuffer);
					break;
									
				case IOCTL_FWD_RESET_NB_NAMES:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_RESET_NB_NAMES\n"));
					if (inpBufLength==sizeof (ULONG))
						status = DoSetNbNames (*((PULONG)inBuffer), 0, NULL);

					break;
				case IOCTL_FWD_GET_NB_NAMES:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_GET_NB_NAMES\n"));
					if ((inpBufLength==sizeof (ULONG))
							&& (outBufLength>=sizeof(ULONG))) {
						Irp->IoStatus.Information = outBufLength
								-FIELD_OFFSET (FWD_NB_NAMES_PARAMS, Names);
						status = DoGetNbNames (
								*((PULONG)inBuffer),
								&ulBytesCopied,
								&((PFWD_NB_NAMES_PARAMS)outBuffer)->TotalCount,
								((PFWD_NB_NAMES_PARAMS)outBuffer)->Names);
						Irp->IoStatus.Information = ulBytesCopied;
						if (NT_SUCCESS (status)) {
							Irp->IoStatus.Information += FIELD_OFFSET (
											FWD_NB_NAMES_PARAMS, Names);
						}
					}
					break;
									
				case IOCTL_FWD_CREATE_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_CREATE_INTERFACE\n"));
					if (inpBufLength==sizeof(FWD_IF_CREATE_PARAMS))
						status = AddInterface (
								((PFWD_IF_CREATE_PARAMS)inBuffer)->Index,
								((PFWD_IF_CREATE_PARAMS)inBuffer)->InterfaceType,
								((PFWD_IF_CREATE_PARAMS)inBuffer)->NetbiosAccept,
								((PFWD_IF_CREATE_PARAMS)inBuffer)->NetbiosDeliver);
					break;

				case IOCTL_FWD_DELETE_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_DELETE_INTERFACE\n"));
					if (inpBufLength==sizeof(ULONG))
						status = DeleteInterface (
									*((PULONG)inBuffer));
							
					break;

				case IOCTL_FWD_SET_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_SET_INTERFACE\n"));
					if (inpBufLength==sizeof(FWD_IF_SET_PARAMS))
						status = DoSetInterface (
								((PFWD_IF_SET_PARAMS)inBuffer)->Index,
								((PFWD_IF_SET_PARAMS)inBuffer)->NetbiosAccept,
								((PFWD_IF_SET_PARAMS)inBuffer)->NetbiosDeliver);
					break;

				case IOCTL_FWD_GET_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_GET_INTERFACE\n"));
					if ((inpBufLength==sizeof(ULONG))
							&& (outBufLength==sizeof(FWD_IF_GET_PARAMS))) {
						status = DoGetInterface (
								*((PULONG)inBuffer),
								&((PFWD_IF_GET_PARAMS)outBuffer)->Stats,
								&((PFWD_IF_GET_PARAMS)outBuffer)->NetbiosAccept,
								&((PFWD_IF_GET_PARAMS)outBuffer)->NetbiosDeliver);
						if (NT_SUCCESS (status))
							Irp->IoStatus.Information = sizeof(FWD_IF_GET_PARAMS);
					}
					break;

				case IOCTL_FWD_BIND_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_BIND_INTERFACE\n"));
					if (inpBufLength==sizeof(FWD_IF_BIND_PARAMS))
						status = DoBindInterface (
									((PFWD_IF_BIND_PARAMS)inBuffer)->Index,
									&((PFWD_IF_BIND_PARAMS)inBuffer)->Info);
					break;

				case IOCTL_FWD_UNBIND_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_UNBIND_INTERFACE\n"));
					if (inpBufLength==sizeof(ULONG))
						status = DoUnbindInterface (*((PULONG)inBuffer));
					break;

                case IOCTL_FWD_RENUMBER_NICS:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_RENUMBER_NICS\n"));
					if (inpBufLength == sizeof(FWD_RENUMBER_NICS_DATA)) {
					    if (((FWD_RENUMBER_NICS_DATA*)inBuffer)->ulOpCode == FWD_NIC_OPCODE_DECREMENT)
					        status = DecrementNicids (((FWD_RENUMBER_NICS_DATA*)inBuffer)->usThreshold);
					    else
					        status = IncrementNicids (((FWD_RENUMBER_NICS_DATA*)inBuffer)->usThreshold);
					}
                    break;

				case IOCTL_FWD_GET_DIAL_REQUEST:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_GET_DIAL_REQUEST\n"));
					if (outBufLength>=sizeof (ULONG)) {
						IoAcquireCancelSpinLock (&cancelIRQL);
						if (!IsListEmpty (&ConnectionRequestQueue)) {
                            PINTERFACE_CB ifCB = CONTAINING_RECORD (
                                            ConnectionRequestQueue.Flink,
                                            INTERFACE_CB,
                                            ICB_ConnectionLink);
		                    RemoveEntryList (&ifCB->ICB_ConnectionLink);
		                    InitializeListEntry (&ifCB->ICB_ConnectionLink);
    						IoReleaseCancelSpinLock (cancelIRQL);
                            KeAcquireSpinLock (&ifCB->ICB_Lock, &cancelIRQL);
							FillConnectionRequest (
                                        ifCB->ICB_Index,
                                        ifCB->ICB_ConnectionPacket,
                                        ifCB->ICB_ConnectionData,
										(PFWD_DIAL_REQUEST)outBuffer,
										outBufLength,
										&ulBytesCopied);
                            Irp->IoStatus.Information = ulBytesCopied;
                            status = STATUS_SUCCESS;
                            KeReleaseSpinLock (&ifCB->ICB_Lock, cancelIRQL);
						}
						else {
							InsertTailList (&ConnectionIrpQueue,
											&Irp->Tail.Overlay.ListEntry);
							IoSetCancelRoutine (Irp, IpxFwdCancel);
							IoMarkIrpPending (Irp);
							Irp->IoStatus.Status = status = STATUS_PENDING;
    						IoReleaseCancelSpinLock (cancelIRQL);
						}
					}
					break;
				case IOCTL_FWD_DIAL_REQUEST_FAILED:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_DIAL_REQUEST_FAILED\n"));
					if (inpBufLength==sizeof (ULONG))
						status = FailConnectionRequest (
										*((PULONG)inBuffer));
					break;
				case IOCTL_FWD_DISABLE_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_DISABLE_INTERFACE\n"));
					if (inpBufLength==sizeof (ULONG))
						status = DoDisableInterface (
										*((PULONG)inBuffer));
					break;
				case IOCTL_FWD_ENABLE_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_ENABLE_INTERFACE\n"));
					if (inpBufLength==sizeof (ULONG))
						status = DoEnableInterface (
										*((PULONG)inBuffer));
					break;
			    case IOCTL_FWD_UPDATE_CONFIG:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_UPDATE_CONFIG\n"));
					if (inpBufLength==sizeof (FWD_UPDATE_CONFIG_PARAMS)) {
					    ThisMachineOnly = ((FWD_UPDATE_CONFIG_PARAMS*)inBuffer)->bThisMachineOnly;
						status = STATUS_SUCCESS;
				    }
					break;
				default:
					IpxFwdDbgPrint (DBG_IOCTLS, DBG_WARNING, ("IpxFwd: unknown IRP_MJ_DEVICE_CONTROL\n"));
					break;

				}
			}
			else if (IrpStack->Parameters.DeviceIoControl.IoControlCode
							==IOCTL_FWD_INTERNAL_BIND_FILTER)
            {
				IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_INTERNAL_BIND_FILTER\n"));
			    //
			    // pmay: 218246
			    // We only allow the kernel-mode ipx filter driver
			    // to bind to us.
			    //
				if (
				     (ExGetPreviousMode() == KernelMode)           &&
				     (inpBufLength == sizeof(IPX_FLT_BIND_INPUT) ) &&
				     (outBufLength >= sizeof(ULONG) )
				   )
				{
					if (outBufLength >= sizeof (IPX_FLT_BIND_OUTPUT)) {
						BindFilterDriver (
								(PIPX_FLT_BIND_INPUT)inBuffer,
								(PIPX_FLT_BIND_OUTPUT)outBuffer);
						Irp->IoStatus.Information = sizeof (IPX_FLT_BIND_OUTPUT);
						FilterFile = IrpStack->FileObject;
						status = STATUS_SUCCESS;
					}
					else {
						IPX_FLT_BIND_OUTPUT	bindOutput;
						BindFilterDriver (
								(PIPX_FLT_BIND_INPUT)inBuffer,
								&bindOutput);
						memcpy (outBuffer, &bindOutput, outBufLength);
						Irp->IoStatus.Information = outBufLength;
						status = STATUS_BUFFER_OVERFLOW;
					}
			    }
			}
			else if (IrpStack->Parameters.DeviceIoControl.IoControlCode
							==IOCTL_FWD_GET_PERF_COUNTERS) {
				IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_GET_PERF_COUNTERS\n"));
				if (outBufLength==sizeof (FWD_PERFORMANCE_PARAMS))
				{
					status = DoGetPerfCounters (
									((PFWD_PERFORMANCE_PARAMS)outBuffer),
									&ulBytesCopied);
                    Irp->IoStatus.Information = ulBytesCopied;
                }
			}
			else if (IrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_FWD_GET_IF_TABLE) {
				IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_GET_IF_TABLE\n"));
				status = DoGetIfTable (outBuffer, outBufLength);
    			Irp->IoStatus.Information = outBufLength;
            }
			else {
				status = STATUS_ACCESS_DENIED;
				IpxFwdDbgPrint(DBG_IOCTLS, DBG_WARNING,
					("IpxFwd: IOCTL: %08lx on non-router file object!\n",
						IrpStack->Parameters.DeviceIoControl.IoControlCode));
			}
			LeaveForwarder ();
		} else {
			if (IrpStack->Parameters.DeviceIoControl.IoControlCode==IOCTL_FWD_START) {
				IpxFwdDbgPrint (DBG_IOCTLS, DBG_WARNING,
											("IpxFwd: IOCTL_FWD_START\n"));
				if (inpBufLength==sizeof (FWD_START_PARAMS)) {
					KeInitializeEvent (&ClientsGoneEvent,
										SynchronizationEvent,
										FALSE);
					status = DoStart (
								((PFWD_START_PARAMS)inBuffer)->RouteHashTableSize,
								((PFWD_START_PARAMS)inBuffer)->ThisMachineOnly);
					if (NT_SUCCESS (status)) {
						RouterFile = IrpStack->FileObject;
						IpxFwdInitialized = TRUE;
					}
				}
			}
			else {
				IpxFwdDbgPrint (DBG_IOCTLS, DBG_ERROR,
						("IpxFwd: IOCTL: %08lx but fwd not started.\n",
						IrpStack->Parameters.DeviceIoControl.IoControlCode));
			}
		}
		break;
	default:
		IpxFwdDbgPrint (DBG_IOCTLS, DBG_ERROR,
					("IpxFwd: unknown MajorFunction.\n"));
		break;
    }

DispatchExit:
	if (status!=STATUS_PENDING) {
		IpxFwdDbgPrint(DBG_IOCTLS,
			NT_ERROR(status) ? DBG_WARNING : DBG_INFORMATION,
			("IpxFwd: completing IOCTL %08lx with status %08lx.\n",
			IrpStack->Parameters.DeviceIoControl.IoControlCode,
			status));
		Irp->IoStatus.Status = status;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
	}

    return status;
}



/*++

Routine Description:
	Cleans up on driver unload

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/
VOID
IpxFwdUnload(
    IN PDRIVER_OBJECT DriverObject
    ) {
    IpxFwdDbgPrint(DBG_IOCTLS, DBG_WARNING, ("IpxFwd: unloading\n"));
	if (EnterForwarder ()) {
		LeaveForwarder ();
		IpxFwdInitialized = FALSE;
		while (InterlockedDecrement (&ClientCount)>=0) {
			KeWaitForSingleObject (&ClientsGoneEvent,
										Executive,
										KernelMode,
										FALSE,
										(PLARGE_INTEGER)&WaitTimeout);
			InterlockedIncrement (&ClientCount);
			IpxFwdDbgPrint(DBG_IOCTLS, DBG_ERROR,
					("IpxFwd: Waiting for all clients (%ld) to exit.\n",
					ClientCount));
		}
		DoStop ();
	}

	UnbindFromIpxDriver (KernelMode);
    IoDeleteDevice (DriverObject->DeviceObject);
}



/*++
	D o S t a r t

Routine Description:
	Initializes all driver components and binds to IPX
	stack driver at strat up

Arguments:
	RouteHashTableSize	- size of route hash table
	thisMachineOnly		- whether to forward dialin client packets
							to other dests on the net

Return Value:
	STATUS_SUCCESS - initialization succeded
	STATUS_UNSUCCESSFULL - failure

--*/
NTSTATUS
DoStart (
	IN ULONG	RouteHashTableSize,
	IN BOOLEAN	thisMachineOnly
	) {
	NTSTATUS		status;

	InitializeConnectionQueues ();
	RouteHashSize = RouteHashTableSize;
	status = CreateTables ();
	if (NT_SUCCESS (status)) {
		InitializePacketAllocator ();
		InitializeNetbiosQueue ();
		InitializeRecvQueue ();
		InitializeSendQueue ();
		MeasuringPerformance = FALSE;
		KeInitializeSpinLock (&PerfCounterLock);
		ThisMachineOnly = thisMachineOnly;

		return STATUS_SUCCESS;
	}
	return status;
}

/*++
	D o S t o p

Routine Description:
	Cleans up allocated resources and unbinds from IPX stack
	driver when forwarder is stopped

Arguments:
	None

Return Value:
	STATUS_SUCCESS - cleanup succeded

--*/
NTSTATUS
DoStop (
	void
	) {
	if (FilterFile!=NULL) {
		UnbindFilterDriver ();
		FilterFile = NULL;
	}
	DeleteSendQueue ();
	DeleteRecvQueue ();
	DeleteNetbiosQueue ();
	DeleteTables ();	// Unbinds all bound interfaces
	if (WanPacketListId!=-1) {
		DeregisterPacketConsumer (WanPacketListId);
		WanPacketListId = -1;
	}
	DeletePacketAllocator ();
	return STATUS_SUCCESS;
}

/*++
	D o S e t R o u t e s

Routine Description:
	Updates route table with supplied routes

Arguments:
	routeArray - array of routes to add/de;ete/update
	nRoutes		- number of routes in the array
	nProcessed	- number of routes that were processed successfully

Return Value:
	STATUS_SUCCESS - all routes were processed ok
	error status - reason of failure for the first unprocessed route

--*/
NTSTATUS
DoSetRoutes (
	IN PFWD_ROUTE_SET_PARAMS	routeArray,
	IN ULONG				nRoutes,
	OUT PULONG				nProcessed
	) {
	NTSTATUS	status=STATUS_SUCCESS;
	UINT		i;

	for (i=0; i<nRoutes; i++, routeArray++) {
		switch (routeArray->Action) {
		case FWD_ADD_ROUTE:
			status = AddRoute (routeArray->Network,
									routeArray->NextHopAddress,
									routeArray->TickCount,
									routeArray->HopCount,
									routeArray->InterfaceIndex);
			break;
		case FWD_DELETE_ROUTE:
			status = DeleteRoute (routeArray->Network);
			break;
		case FWD_UPDATE_ROUTE:
			status = UpdateRoute (routeArray->Network,
									routeArray->NextHopAddress,
									routeArray->TickCount,
									routeArray->HopCount,
									routeArray->InterfaceIndex);
			break;
		default:
			status = STATUS_INVALID_PARAMETER;
			break;
		}
		if (!NT_SUCCESS (status))
			break;
	}
	*nProcessed = i;
	return status;
}


/*++
	D o S e t N b N a m e s

Routine Description:
	Sets static Netbios Names on the interface

Arguments:
	InterfaceIndex - index oc interface on which to set names
	Count			- number of names to set
	Names			- array of netbios names

Return Value:
	STATUS_SUCCESS - names were set OK
	STATUS_UNSUCCESSFULL - interface does not exist
	STATUS_INSUFFICIENT_RESOURCES - not enough resources to complete
							the operation

--*/
NTSTATUS
DoSetNbNames (
	IN ULONG			InterfaceIndex,
	IN ULONG			Count,
	IN PFWD_NB_NAME		Names
	) {
	PINTERFACE_CB	ifCB;
	KIRQL			oldIRQL;
	PNB_ROUTE		nbRoutes;
	NTSTATUS		status=STATUS_SUCCESS;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		if (ifCB->ICB_NBRoutes!=NULL) {
			DeleteNBRoutes (ifCB->ICB_NBRoutes, ifCB->ICB_NBRouteCount);
			ifCB->ICB_NBRoutes = NULL;
			ifCB->ICB_NBRouteCount = 0;
		}
		if (Count>0) {
			status = AddNBRoutes (ifCB, Names, Count, &nbRoutes);
			if (NT_SUCCESS (status)) {
				ifCB->ICB_NBRoutes = nbRoutes;
				ifCB->ICB_NBRouteCount = Count;
			}
		}
		ReleaseInterfaceReference (ifCB);
	}
	else
		status = STATUS_UNSUCCESSFUL;

	return status;
}


/*++
	D o G e t N b N a m e s

Routine Description:
	Gets all static Netbios Names on the interface

Arguments:
	InterfaceIndex - index of interface from which to get names
	ArraySize - on input: size of the buffer to put names into
				on output: size of data put into the array
	Names			- buffer to put names into names, if buffer
				is to small to hold all names, this orutine stuffs
				total number of names into the first ULONG in the
				array (this is the only way to return in to the
				caller through the IOCTL interface)

Return Value:
	STATUS_SUCCESS - names were copied into the array
	STATUS_UNSUCCESSFULL - interface does not exist
	STATUS_BUFFER_OVERFLOW - buffer is too small to copy all the
				names, number of names are in the first ULONG of
				the buffer

--*/
NTSTATUS
DoGetNbNames (
	IN ULONG			InterfaceIndex,
	IN OUT ULONG        *ArraySize,
	OUT ULONG			*TotalCount,
	OUT PFWD_NB_NAME	Names
	) {
	PINTERFACE_CB	ifCB;
	KIRQL			oldIRQL;
	NTSTATUS		status=STATUS_SUCCESS;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		if (ifCB->ICB_NBRoutes!=NULL) {
			ULONG			i;
			PFWD_NB_NAME	nameLM = Names+(*ArraySize/sizeof(FWD_NB_NAME));
			for (i=0; (i<ifCB->ICB_NBRouteCount)&&(Names<nameLM); i++, Names++)
				NB_NAME_CPY (Names,	&ifCB->ICB_NBRoutes[i].NBR_Name);
			*ArraySize = sizeof (FWD_NB_NAME)*i;
			*TotalCount = ifCB->ICB_NBRouteCount;
		}
		else {
			*ArraySize = 0;
			*TotalCount = 0;
		}
		ReleaseInterfaceReference (ifCB);
	}
	else
		status = STATUS_UNSUCCESSFUL;

	return status;
}


/*++
	D o S e t I n t e r f a c e

Routine Description:
	Sets interface configurable parameters

Arguments:
	InterfaceIndex - index of interface to set
	NetbiosAccept	- whether to accept nb packets on the interface
	NetbiosDeliver - whether to deliver nb packets on the interface

Return Value:
	STATUS_SUCCESS - interface was set OK
	STATUS_UNSUCCESSFULL - interface does not exist

--*/
NTSTATUS
DoSetInterface (
	IN ULONG		InterfaceIndex,
	IN BOOLEAN		NetbiosAccept,
	IN UCHAR		NetbiosDeliver
	) {
	PINTERFACE_CB	ifCB;
	KIRQL			oldIRQL;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
		ifCB->ICB_NetbiosAccept = NetbiosAccept;
		ifCB->ICB_NetbiosDeliver = NetbiosDeliver;
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
		ReleaseInterfaceReference (ifCB);
		return STATUS_SUCCESS;
	}
	else
		return STATUS_UNSUCCESSFUL;
}


/*++
	D o G e t I n t e r f a c e

Routine Description:
	Gets interface configurable parameters and statistics

Arguments:
	InterfaceIndex - index of interface to query
	stats			- interface statistics
	NetbiosAccept	- whether nb packets accepter on the interface
	NetbiosDeliver - whether nb packets delivered on the interface

Return Value:
	STATUS_SUCCESS - interface data was queried OK
	STATUS_UNSUCCESSFULL - interface does not exist

--*/
NTSTATUS
DoGetInterface (
	IN ULONG			InterfaceIndex,
	OUT PFWD_IF_STATS	stats,
	OUT BOOLEAN			*NetbiosAccept,
	OUT UCHAR			*NetbiosDeliver
	) {
	PINTERFACE_CB	ifCB;
	KIRQL			oldIRQL;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		*NetbiosAccept = ifCB->ICB_NetbiosAccept;
		*NetbiosDeliver = ifCB->ICB_NetbiosDeliver;
		IF_STATS_CPY (stats, &ifCB->ICB_Stats);
		if (!IS_IF_ENABLED(ifCB))
			stats->OperationalState = FWD_OPER_STATE_DOWN;
		ReleaseInterfaceReference (ifCB);
		return STATUS_SUCCESS;
	}
	else
		return STATUS_UNSUCCESSFUL;
}

/*++
	D o B i n d I n t e r f a c e

Routine Description:
	Binds interface to the specified adapter and sets binding
	parameters

Arguments:
	InterfaceIndex - index of interface to bind
	info			- binding info

Return Value:
	STATUS_SUCCESS - interface was bound OK
	STATUS_UNSUCCESSFULL - interface does not exist or could not be
							bound
--*/
NTSTATUS
DoBindInterface (
	IN ULONG					InterfaceIndex,
	IN PFWD_ADAPTER_BINDING_INFO	info
	) {
	PINTERFACE_CB	ifCB;
	NTSTATUS		status;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		if (ifCB->ICB_InterfaceType==FWD_IF_PERMANENT)
			status = BindInterface (ifCB,
									(USHORT)info->AdapterIndex,
									info->MaxPacketSize,
									info->Network,
									info->LocalNode,
									info->RemoteNode);
		else
			status = STATUS_SUCCESS;
		ReleaseInterfaceReference (ifCB);
		return status;
	}
	else
		return STATUS_UNSUCCESSFUL;
}


/*++
	D o U n b i n d I n t e r f a c e

Routine Description:
	Unbinds interface from the adapter and invalidates binding
	parameters

Arguments:
	InterfaceIndex - index of interface to unbind

Return Value:
	STATUS_SUCCESS - interface was unbound OK
	STATUS_UNSUCCESSFULL - interface does not exist
--*/
NTSTATUS
DoUnbindInterface (
	IN ULONG					InterfaceIndex
	) {
	PINTERFACE_CB	ifCB;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		if (ifCB->ICB_InterfaceType==FWD_IF_PERMANENT)
			UnbindInterface (ifCB);

		ReleaseInterfaceReference (ifCB);
		return STATUS_SUCCESS;
	}
	else
		return STATUS_UNSUCCESSFUL;
}

/*++
	D o D i s a b l e I n t e r f a c e

Routine Description:
	Disables all packet traffic through the interface

Arguments:
	InterfaceIndex - index of interface to disable

Return Value:
	STATUS_SUCCESS - interface was disabled OK
	STATUS_UNSUCCESSFULL - interface does not exist
--*/
NTSTATUS
DoDisableInterface (
	IN ULONG					InterfaceIndex
	) {
	PINTERFACE_CB	ifCB;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		KIRQL	oldIRQL;
		KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
		if (IS_IF_ENABLED (ifCB)) {
			SET_IF_DISABLED (ifCB);
			KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
			if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX) {
				ProcessInternalQueue (ifCB);
				ProcessExternalQueue (ifCB);
			}
		}
		else
			KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
		ReleaseInterfaceReference (ifCB);
		return STATUS_SUCCESS;
	}
	else
		return STATUS_UNSUCCESSFUL;
}


/*++
	D o E n a b l e I n t e r f a c e

Routine Description:
	Enables all packet traffic through the interface

Arguments:
	InterfaceIndex - index of interface to enable

Return Value:
	STATUS_SUCCESS - interface was disabled OK
	STATUS_UNSUCCESSFULL - interface does not exist
--*/
NTSTATUS
DoEnableInterface (
	IN ULONG					InterfaceIndex
	) {
	PINTERFACE_CB	ifCB;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		SET_IF_ENABLED (ifCB);
		ReleaseInterfaceReference (ifCB);
		return STATUS_SUCCESS;
	}
	else
		return STATUS_UNSUCCESSFUL;
}



/*++
	I p x F w d C a n c e l

Routine Description:
	Cancels specified IRP

Arguments:
	DeviceObject	- forwarder device object
	irp				- irp to cancel

Return Value:
	None
--*/
VOID
IpxFwdCancel (
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				irp
	) {
    RemoveEntryList (&irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock (irp->CancelIrql);

    irp->IoStatus.Information = 0;
    irp->IoStatus.Status = STATUS_CANCELLED;
    IpxFwdDbgPrint(DBG_IOCTLS, DBG_WARNING, ("IpxFwd: completing cancelled irp.\n"));
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

/*++
	D o G e t P e r f C o u n t e r s

Routine Description:
	Gets performance counters

Arguments:
	perfParams	- buffer ot pu counters into

Return Value:
	STATUS_SUCCESS - counter were copied ok
	STATUS_UNSUCCESSFULL - performance measurement were not enabled
--*/
NTSTATUS
DoGetPerfCounters (
	OUT PFWD_PERFORMANCE_PARAMS	perfParams,
	OUT ULONG* pulSize
	) {
	LONGLONG	lTotalPacketProcessingTime;
	LONGLONG	lMaxPacketProcessingTime;
	LONG		lPacketCounter;
	LONGLONG	lTotalNbPacketProcessingTime;
	LONGLONG	lMaxNbPacketProcessingTime;
	LONG		lNbPacketCounter;
	KIRQL		oldIRQL;
	
	if (!MeasuringPerformance)
		return STATUS_UNSUCCESSFUL;

	KeAcquireSpinLock (&PerfCounterLock, &oldIRQL);
	*perfParams = PerfBlock;
	memset (&PerfBlock, 0, sizeof (PerfBlock));
	KeReleaseSpinLock (&PerfCounterLock, oldIRQL);

	*pulSize = sizeof(PerfBlock);
	
	return STATUS_SUCCESS;
}


BOOLEAN
DoLeaveForwarder (
	VOID
	) {
	return LeaveForwarder () != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\filterif.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\filterif.h

Abstract:
    IPX Forwarder interface with filter driver


Author:

    Vadim Eydelman

Revision History:

--*/


#ifndef _IPXFWD_FILTERIF_
#define _IPXFWD_FILTERIF_
	// Filter driver entry points
extern IPX_FLT_BIND_INPUT FltBindInput;

	// Macros to improve performance when filter driver
	// is not bound or has not associated its contexts
	// with interfaces of interest
#define FltFilter(hdr,hdrSize,inContext,outContext)	(			\
	((FltBindInput.FilterHandler==NULL)							\
			|| ((inContext==NO_FILTER_CONTEXT)					\
					&&(outContext==NO_FILTER_CONTEXT)))			\
		? FILTER_PERMIT											\
		: DoFilter (hdr,hdrSize,inContext,outContext)			\
)

#define FltInterfaceDeleted(ifCB)	{									\
	if ((FltBindInput.InterfaceDeletedHandler!=NULL)					\
			&& ((ifCB->ICB_FilterInContext!=NO_FILTER_CONTEXT)			\
				||(ifCB->ICB_FilterOutContext!=NO_FILTER_CONTEXT)))		\
		DoInterfaceDeleted (ifCB);										\
}

/*++
	B i n d F i l t e r D r i v e r

Routine Description:
	Exchanges entry points with filter driver
Arguments:
	bindInput	- filter driver entry points
	bindOutput	- forwarder driver entry points
Return Value:
	None
--*/
VOID
BindFilterDriver (
	IN PIPX_FLT_BIND_INPUT		bindInput,
	OUT PIPX_FLT_BIND_OUTPUT	bindOutput
	);

/*++
	U n b i n d F i l t e r D r i v e r

Routine Description:
	Resets locally stored filter driver entry points
	and resets filter driver contexts on all interfaces
Arguments:
	None
Return Value:
	None
--*/
VOID
UnbindFilterDriver (
	VOID
	);


/*++
	D o F i l t e r

Routine Description:
	
	Calls filter driver entry point while holding reader access
	to interface contexts

Arguments:
	ipxHdr			- pointer to packet header
	ipxHdrLength	- size of the header buffer (must be at least 30)
	ifInContext		- context associated with interface on which packet
						was received
	ifOutContext	- context associated with interface on which packet
						will be sent
Return Value:
	FILTER_PERMIT	- packet should be passed on by the forwarder
	FILTER_DENY		- packet should be dropped

--*/
FILTER_ACTION
DoFilter (
	IN PUCHAR	ipxHdr,
	IN ULONG	ipxHdrLength,
	IN PVOID	ifInContext,
	IN PVOID	ifOutContex
	);

/*++
	D o I n t e r f a c e D e l e t e d

Routine Description:
	Resets interface contexts and calls filter dirver entry point
	making sure that all no one holds reader access to filter driver
	interface contexts
Arguments:
	ifCB	 - interface to be deleted
Return Value:
	None

--*/
VOID
DoInterfaceDeleted (
	PINTERFACE_CB	ifCB
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\fwddefs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\fwddefs.h

Abstract:
	IPX Forwarder driver constants and general macro definitions

Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFWD_FWDDEFS_
#define _IPXFWD_FWDDEFS_


// Forwarder tag used in memory allocations
#define FWD_POOL_TAG					'wFwN'

//*** Offsets into the IPX header
#define IPXH_HDRSIZE	    30	    // Size of the IPX header
#define IPXH_CHECKSUM	    0	    // Checksum
#define IPXH_LENGTH			2	    // Length
#define IPXH_XPORTCTL	    4	    // Transport Control
#define IPXH_PKTTYPE	    5	    // Packet Type
#define IPXH_DESTADDR	    6	    // Dest. Address (Total)
#define IPXH_DESTNET	    6	    // Dest. Network Address
#define IPXH_DESTNODE	    10	    // Dest. Node Address
#define IPXH_DESTSOCK	    16	    // Dest. Socket Number
#define IPXH_SRCADDR	    18	    // Source Address (Total)
#define IPXH_SRCNET			18	    // Source Network Address
#define IPXH_SRCNODE	    22	    // Source Node Address
#define IPXH_SRCSOCK	    28	    // Source Socket Number

//*** Packet Types we care about
#define IPX_NETBIOS_TYPE    20	   // Netbios propagated packet

//*** Socket Numbers we care about
#define IPX_NETBIOS_SOCKET  ((USHORT)0x0455)
#define IPX_SAP_SOCKET		((USHORT)0x0452)
#define IPX_SMB_NAME_SOCKET	((USHORT)0x0551)

//*** maximum nr of hops for a normal packet ***
#define IPX_MAX_HOPS	    16

//*** offsets into the netbios name frames ***
#define NB_NAME_TYPE_FLAG				62
#define NB_DATA_STREAM_TYPE2			63
#define NB_NAME							64
#define NB_TOTAL_DATA_LENGTH			80
// *** offsets into smb name claim/query frames
#define SMB_OPERATION					62
#define SMB_NAME_TYPE					63
#define SMB_MESSAGE_IF					64
#define SMB_NAME						66


// Some commonly used macros
#define IPX_NODE_CPY(dst,src) memcpy(dst,src,6)
#define IPX_NODE_CMP(node1,node2) memcmp(node1,node2,6)

#define IPX_NET_CPY(dst,src) memcpy(dst,src,4)
#define IPX_NET_CMP(net1,net2) memcmp(net1,net2,4)

#define NB_NAME_CPY(dst,src) strncpy((char *)dst,(char *)src,16)
#define NB_NAME_CMP(name1,name2) strncmp((char *)name1,(char *)name2,16)

// Make sure the structure is copied with DWORD granularity
#define IF_STATS_CPY(dst,src) \
		(dst)->OperationalState	= (src)->OperationalState;	\
		(dst)->MaxPacketSize	= (src)->MaxPacketSize;		\
		(dst)->InHdrErrors		= (src)->InHdrErrors;		\
		(dst)->InFiltered		= (src)->InFiltered;		\
		(dst)->InNoRoutes		= (src)->InNoRoutes;		\
		(dst)->InDiscards		= (src)->InDiscards;		\
		(dst)->InDelivers		= (src)->InDelivers;		\
		(dst)->OutFiltered		= (src)->OutFiltered;		\
		(dst)->OutDiscards		= (src)->OutDiscards;		\
		(dst)->OutDelivers		= (src)->OutDelivers;		\
		(dst)->NetbiosReceived	= (src)->NetbiosReceived;	\
		(dst)->NetbiosSent		= (src)->NetbiosSent;

// Extensions to list macros
#define InitializeListEntry(entry) InitializeListHead(entry)
#define IsListEntry(entry) IsListEmpty(entry)
#define IsSingleEntry(head) ((head)->Flink==(head)->Blink)

// Conversions from/to on-the-wire format
#define GETUSHORT(src) (			\
	(USHORT)(						\
		(((UCHAR *)src)[0]<<8)		\
		+ (((UCHAR *)src)[1])		\
	)								\
)

#define GETULONG(src) (				\
	(ULONG)(						\
		(((UCHAR *)src)[0]<<24)		\
		+ (((UCHAR *)src)[1]<<16)	\
		+ (((UCHAR *)src)[2]<<8)	\
		+ (((UCHAR *)src)[3])		\
	)								\
)

#define PUTUSHORT(src,dst) {				\
	((UCHAR *)dst)[0] = ((UCHAR)(src>>8));	\
	((UCHAR *)dst)[1] = ((UCHAR)src);		\
}

#define PUTULONG(src,dst) {					\
	((UCHAR *)dst)[0] = ((UCHAR)(src>>24));	\
	((UCHAR *)dst)[1] = ((UCHAR)(src>>16));	\
	((UCHAR *)dst)[2] = ((UCHAR)(src>>8));	\
	((UCHAR *)dst)[3] = ((UCHAR)src);		\
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\lineind.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\lineind.h

Abstract:
	Processing line indication (bind/unbind)


Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFWD_LINEIND_
#define _IPXFWD_LINEIND_

/*++
*******************************************************************
    B i n d I n t e r f a c e

Routine Description:
	Binds interface to physical adapter and exchanges contexts
	with IPX stack
Arguments:
	ifCB			- interface to bind
	NicId			- id of an adapter
	MaxPacketSize	- max size of packet allowed
	Network			- adapter network address
	LocalNode		- adapter local node address
	RemoteNode		- peer node address (for clients on global
						net)
Return Value:
	STATUS_SUCCESS - interface was bound OK
	error status returned by IPX stack driver

*******************************************************************
--*/
NTSTATUS
BindInterface (
	IN PINTERFACE_CB	ifCB,
	IN USHORT			NicId,
	IN ULONG			MaxPacketSize,
	IN ULONG			Network,
	IN PUCHAR			LocalNode,
	IN PUCHAR			RemoteNode
	);

/*++
*******************************************************************
    U n b i n d I n t e r f a c e

Routine Description:
	Unbinds interface from physical adapter and breaks connection
	with IPX stack
Arguments:
	ifCB			- interface to unbind
Return Value:
	None
*******************************************************************
--*/
VOID
UnbindInterface (
	PINTERFACE_CB	ifCB
	);

/*++
*******************************************************************
    F w L i n e U p

Routine Description:
	Process line up indication delivered by IPX stack
Arguments:
	NicId		- adapter ID on which connection was established
	LineInfo	- NDIS/IPX line information
	DeviceType	- medium specs
	ConfigurationData - IPX CP configuration data
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdLineUp (
	IN USHORT			NicId,
	IN PIPX_LINE_INFO	LineInfo,
	IN NDIS_MEDIUM		DeviceType,
	IN PVOID			ConfigurationData
	);

/*++
*******************************************************************
    F w L i n e D o w n

Routine Description:
	Process line down indication delivered by IPX stack
Arguments:
	NicId		- disconnected adapter ID 
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdLineDown (
	IN USHORT	NicId,
	IN ULONG_PTR Context
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\netbios.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\netbios.c

Abstract:
	Netbios packet processing

Author:

    Vadim Eydelman

Revision History:

--*/
#include    "precomp.h"

LIST_ENTRY	NetbiosQueue;
KSPIN_LOCK	NetbiosQueueLock;
WORK_QUEUE_ITEM		NetbiosWorker;
BOOLEAN				NetbiosWorkerScheduled=FALSE;
ULONG				NetbiosPacketsQuota;
ULONG				MaxNetbiosPacketsQueued = DEF_MAX_NETBIOS_PACKETS_QUEUED;


/*++
*******************************************************************
    P r o c e s s N e t b i o s Q u e u e

Routine Description:
	Process packets in the netbios broadcast queue (sends them on
	all interfaces in sequence)
Arguments:
	Context - unused
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessNetbiosQueue (
	PVOID		Context
	) {
	KIRQL			oldIRQL;
	LIST_ENTRY		tempQueue;

	KeAcquireSpinLock (&NetbiosQueueLock, &oldIRQL);
		// Check if there is something in the queue
	if (!IsListEmpty (&NetbiosQueue)) {
			// Move the queue to local variable
		InsertHeadList (&NetbiosQueue, &tempQueue);
		RemoveEntryList (&NetbiosQueue);
		InitializeListHead (&NetbiosQueue);

		KeReleaseSpinLock (&NetbiosQueueLock, oldIRQL);
		do {
			PLIST_ENTRY		cur;
			PPACKET_TAG		pktTag;

			cur = RemoveHeadList (&tempQueue);
			pktTag = CONTAINING_RECORD (cur, PACKET_TAG, PT_QueueLink);
				// Check if this packet has to be sent on other
				// interfaces
			if (!(pktTag->PT_Flags&PT_NB_DESTROY)) {
				PINTERFACE_CB	dstIf = pktTag->PT_InterfaceReference;
				PUCHAR			dataPtr = pktTag->PT_Data;
				UINT			rtCount = *(dataPtr+IPXH_XPORTCTL);
				PUCHAR			netListPtr;
				UINT			i;
					
				if (dstIf==NULL) {
						// This is a brand new packet: not sent on any
						// interface yet
					USHORT dstSock = GETUSHORT (dataPtr+IPXH_DESTSOCK);
						// Check if we have a static route for this name
						// (offset to name depends on packet dest socket)
					if (dstSock==IPX_NETBIOS_SOCKET)
						dstIf = FindNBDestination (dataPtr+NB_NAME);
					else if (dstSock==IPX_SMB_NAME_SOCKET)
						dstIf = FindNBDestination (dataPtr+SMB_NAME);
					else
						dstIf = NULL;

					if (dstIf!=NULL) {
							// Static route found, make sure this packet
							// won't be sent on any other interface
						pktTag->PT_Flags |= PT_NB_DESTROY;
						InterlockedIncrement (&NetbiosPacketsQuota);
							// Make sure the packet has not traversed
							// this network already
						for (i=0, netListPtr=dataPtr+IPXH_HDRSIZE; i<rtCount; i++,netListPtr+=4) {
							if (GETULONG (netListPtr)==dstIf->ICB_Network)
								break;
						}
							// Make sure we are allowed to send on this
							// interface
						if ((dstIf!=InternalInterface)
							&& (i==rtCount)	// Has not already traversed
											// this network
							&& IS_IF_ENABLED (dstIf)
							&& ((dstIf->ICB_NetbiosDeliver==FWD_NB_DELIVER_ALL)
								|| (dstIf->ICB_NetbiosDeliver
										==FWD_NB_DELIVER_STATIC)
								|| ((dstIf->ICB_NetbiosDeliver
										==FWD_NB_DELIVER_IF_UP)
									&& (dstIf->ICB_Stats.OperationalState
											==FWD_OPER_STATE_UP)))) {
							NOTHING;
						}
						else {
							// We have static route, but can't send it,
							// no point to propagate in on other interfaces
							// as well
							ReleaseInterfaceReference (dstIf);
							dstIf = NULL;
							goto FreePacket;
						}
					}
					else { // no static route
						goto FindNextInterface;
					}
				}
				else {	// not a brand new packet (already sent on some 
						// interfaces)

				FindNextInterface:

						// Loop through the interface list till we find
						// the one on which we can send
					while ((dstIf=GetNextInterfaceReference (dstIf))!=NULL) {
							// Check if we allowed to send on this interface
						if (IS_IF_ENABLED (dstIf)
							&& ((dstIf->ICB_NetbiosDeliver==FWD_NB_DELIVER_ALL)
								|| ((dstIf->ICB_NetbiosDeliver
											==FWD_NB_DELIVER_IF_UP)
									&& (dstIf->ICB_Stats.OperationalState
											==FWD_OPER_STATE_UP)))) {
								// Make sure the packet has not traversed
								// this network already
							for (i=0, netListPtr=dataPtr+IPXH_HDRSIZE; i<rtCount; i++,netListPtr+=4) {
								if (GETULONG (netListPtr)==dstIf->ICB_Network)
									break;
							}
								// Network was not in the list
							if (i==rtCount)
								break;
						}
					}
				}
					// Save the destination interface in the packet
				pktTag->PT_InterfaceReference = dstIf;
					// Go ahead and send if we have a valid destination
				if (dstIf!=NULL) {
					SendPacket (dstIf, pktTag);
						// The rest does not apply: if the packet was sent or
						// failed, it will be queued back to NetbiosQueue;
						// if it was queued to interface to be connected,
						// a copy of it will be queued to NetbiosQueue
					continue;
				}
				// else no more destinations to send this packet on
			}
			else { // Packet has to be destroyed
				if (pktTag->PT_InterfaceReference!=NULL)
					ReleaseInterfaceReference (pktTag->PT_InterfaceReference);
			}

		FreePacket:
			IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
				("IpxFwd: No more interfaces for nb packet %08lx.\n",
				pktTag));
			if (MeasuringPerformance
					&& (pktTag->PT_PerfCounter!=0)) {
				LARGE_INTEGER	PerfCounter = KeQueryPerformanceCounter (NULL);
				PerfCounter.QuadPart -= pktTag->PT_PerfCounter;
				KeAcquireSpinLock (&PerfCounterLock, &oldIRQL);
				PerfBlock.TotalNbPacketProcessingTime += PerfCounter.QuadPart;
				PerfBlock.NbPacketCounter += 1;
				if (PerfBlock.MaxNbPacketProcessingTime < PerfCounter.QuadPart)
					PerfBlock.MaxNbPacketProcessingTime = PerfCounter.QuadPart;
				KeReleaseSpinLock (&PerfCounterLock, oldIRQL);
				}
			if (!(pktTag->PT_Flags&PT_NB_DESTROY))
				InterlockedIncrement (&NetbiosPacketsQuota);
			FreePacket (pktTag);
		} while (!IsListEmpty (&tempQueue));

		KeAcquireSpinLock (&NetbiosQueueLock, &oldIRQL);
		if (IsListEmpty (&NetbiosQueue)
				|| !EnterForwarder ()) {
			NetbiosWorkerScheduled = FALSE;
		}
		else {
			ExQueueWorkItem (&NetbiosWorker, DelayedWorkQueue);
		}
	}
	KeReleaseSpinLock (&NetbiosQueueLock, oldIRQL);
	LeaveForwarder ();
}		

/*++
*******************************************************************
    P r o c e s s N e t b i o s P a c k e t

Routine Description:
	Processes received netbios broadcast packet (checks network list
	and source filter, updates input statistics)
Arguments:
	srcIf - interfae on which packet was received
	pktTag - netbios packet
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessNetbiosPacket (
	PINTERFACE_CB	srcIf,
	PPACKET_TAG		pktTag
	) {
	PUCHAR			dataPtr, dataPtr2;
	UINT			rtCount;
	UINT			i, j;
	KIRQL			oldIRQL;
	ULONG           ulNetwork;


	dataPtr = pktTag->PT_Data;
	rtCount = *(dataPtr+IPXH_XPORTCTL);

    //
	// pmay: 264339: Make sure valid networks are listed
	// 
	// We used to only verify that the source network was not 
	// contained in the list.  Now, we verify that 0 and 0xfffffff
	// are also absent.
    // 
	for (i = 0, dataPtr += IPXH_HDRSIZE; i < rtCount; i++, dataPtr += 4) 
	{
	    ulNetwork = GETULONG (dataPtr);
	    
		if ((srcIf->ICB_Network == ulNetwork) ||
	        (ulNetwork == 0xffffffff)         ||
	        (ulNetwork == 0x0))
	    {
	        break;
	    }
	}

    // 
    // pmay: 272193
    //
    // nwlnknb on nt4 puts status bits into the first router slot in 
    // the type 20 payload.  As a consequence, the router has to 
    // ignore the first slot when validating the router table so that nt4 
    // client bcasts aren't dropped at the router.
    //
    if (rtCount == 0)
    {
        j = 1;
        dataPtr2 = dataPtr + 4;
    }
    else
    {
        j = i;
        dataPtr2 = dataPtr;
    }

    //
    // pmay: 264331
    //
    // Make sure the rest of the networks listed are zero
    //
	for (; j < 8; j++, dataPtr2 += 4)
	{
	    ulNetwork = GETULONG (dataPtr2);
	    
	    if (ulNetwork != 0x0)
	    {
	        break;
	    }
	}

	// We scaned the whole list and we haven't found it
	if ((i == rtCount) && (j == 8)) { 
        FILTER_ACTION   action;
        action = FltFilter (pktTag->PT_Data,
				            GETUSHORT (pktTag->PT_Data+IPXH_LENGTH),
				            srcIf->ICB_FilterInContext, NULL);
			// Apply the input filter
		if (action==FILTER_PERMIT) {
			InterlockedIncrement (&srcIf->ICB_Stats.NetbiosReceived);
			InterlockedIncrement (&srcIf->ICB_Stats.InDelivers);
			PUTULONG (srcIf->ICB_Network, dataPtr);
    		*(pktTag->PT_Data+IPXH_XPORTCTL) += 1;
			IPX_NODE_CPY (pktTag->PT_Target.MacAddress, BROADCAST_NODE);
				// Initialize the packet
			pktTag->PT_InterfaceReference = NULL;	// not yet sent on any
													// interfaces
			pktTag->PT_Flags = 0;					// No flags
			QueueNetbiosPacket (pktTag);
			IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
				("IpxFwd: Queued nb packet %08lx from if %ld.\n",
								pktTag, srcIf->ICB_Index));
		}
		else {
            ASSERT (action==FILTER_DENY_IN);
			IpxFwdDbgPrint (DBG_NETBIOS, DBG_WARNING,
				("IpxFwd: Filtered out nb packet %08lx"
				" from if %ld.\n", pktTag, srcIf->ICB_Index));
			InterlockedIncrement (&NetbiosPacketsQuota);
			InterlockedIncrement (&srcIf->ICB_Stats.InFiltered);
			FreePacket (pktTag);
		}
	}
	else {
		IpxFwdDbgPrint (DBG_NETBIOS, DBG_WARNING,
			("IpxFwd: Source net is already in nb packet %08lx"
			" from if %ld.\n", pktTag, srcIf->ICB_Index));
		InterlockedIncrement (&NetbiosPacketsQuota);
		InterlockedIncrement (&srcIf->ICB_Stats.InDiscards);
		FreePacket (pktTag);
	}
	ReleaseInterfaceReference (srcIf);

}


/*++
*******************************************************************
    D e l e t e N e t b i o s Q u e u e

Routine Description:
	Deletes the netbios bradcast queue
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteNetbiosQueue (
	void
	) {
	while (!IsListEmpty (&NetbiosQueue)) {
		PPACKET_TAG pktTag = CONTAINING_RECORD (NetbiosQueue.Flink,
											PACKET_TAG,
											PT_QueueLink);
		RemoveEntryList (&pktTag->PT_QueueLink);
		if (pktTag->PT_InterfaceReference!=NULL) {
			ReleaseInterfaceReference (pktTag->PT_InterfaceReference);
		}
		FreePacket (pktTag);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\ipxbind.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\ipxbind.c

Abstract:
    IPX Forwarder Driver interface with IPX stack driver


Author:

    Vadim Eydelman

Revision History:

--*/

#include    "precomp.h"


// global handle of the IPX driver
HANDLE					HdlIpxFile;


// Buffer for IPX binding output structure
PIPX_INTERNAL_BIND_RIP_OUTPUT	IPXBindOutput=NULL;

NTSTATUS
IpxFwdFindRoute (
	IN  PUCHAR					Network,
	IN  PUCHAR					Node,
	OUT PIPX_FIND_ROUTE_REQUEST	RouteEntry
	);

/*++
*******************************************************************
    B i n d T o I p x D r i v e r

Routine Description:
	Exchanges binding information with IPX stack driver
Arguments:
	None
Return Value:
	STATUS_SUCCESS - exchange was done OK
	STATUS_INSUFFICIENT_RESOURCES - could not allocate buffers for
									info exchange
	error status returned by IPX stack driver

*******************************************************************
--*/
NTSTATUS
BindToIpxDriver (
	KPROCESSOR_MODE requestorMode
	) {
    NTSTATUS					status;
    IO_STATUS_BLOCK				IoStatusBlock;
    OBJECT_ATTRIBUTES			ObjectAttributes;
    PIPX_INTERNAL_BIND_INPUT	bip;
	UNICODE_STRING				UstrIpxFileName;
	PWSTR						WstrIpxFileName;

	ASSERT (IPXBindOutput==NULL);

    // Read Ipx exported device name from the registry
    status = ReadIpxDeviceName (&WstrIpxFileName);
	if (!NT_SUCCESS (status))
		return status;

	RtlInitUnicodeString (&UstrIpxFileName, WstrIpxFileName);
	InitializeObjectAttributes(
				&ObjectAttributes,
				&UstrIpxFileName,
				OBJ_CASE_INSENSITIVE,
				NULL,
				NULL
				);

	if (requestorMode==UserMode)
		status = ZwCreateFile(&HdlIpxFile,
							SYNCHRONIZE | GENERIC_READ,
							&ObjectAttributes,
							&IoStatusBlock,
							NULL,
							FILE_ATTRIBUTE_NORMAL,
							FILE_SHARE_READ | FILE_SHARE_WRITE,
							FILE_OPEN,
							FILE_SYNCHRONOUS_IO_NONALERT,
							NULL,
							0L);
	else
		status = NtCreateFile(&HdlIpxFile,
							SYNCHRONIZE | GENERIC_READ,
							&ObjectAttributes,
							&IoStatusBlock,
							NULL,
							FILE_ATTRIBUTE_NORMAL,
							FILE_SHARE_READ | FILE_SHARE_WRITE,
							FILE_OPEN,
							FILE_SYNCHRONOUS_IO_NONALERT,
							NULL,
							0L);

	if (!NT_SUCCESS(status)) {
		IpxFwdDbgPrint (DBG_IPXBIND, DBG_ERROR,
			("IpxFwd: Open of the IPX driver failed with %lx\n", status));
		return status;
		}

	IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION,
			 ("IpxFwd: Open of the IPX driver was successful.\n"));

	// First, send a IOCTL to find out how much data we need to allocate
	if ((bip = ExAllocatePoolWithTag (
					PagedPool,
					sizeof(IPX_INTERNAL_BIND_INPUT),
					FWD_POOL_TAG)) == NULL) {

		if (ExGetPreviousMode()!=KernelMode)
			ZwClose (HdlIpxFile);
		else
			NtClose (HdlIpxFile);
		IpxFwdDbgPrint (DBG_IPXBIND, DBG_ERROR,
			 ("IpxFwd: Could not allocate input binding buffer!\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}

    //
    // Zero out the memory so that there are no garbage pointers.
    // - ShreeM
    //
    RtlZeroMemory(bip, sizeof(IPX_INTERNAL_BIND_INPUT));

	// fill in our bind data
	// bip->Version = 1;
	bip->Version = ISN_VERSION;
	bip->Identifier = IDENTIFIER_RIP;
	bip->BroadcastEnable = TRUE;
	bip->LookaheadRequired = IPXH_HDRSIZE;
	bip->ProtocolOptions = 0;
	bip->ReceiveHandler = IpxFwdReceive;
	bip->ReceiveCompleteHandler = IpxFwdReceiveComplete;
	bip->SendCompleteHandler = IpxFwdSendComplete;
	bip->TransferDataCompleteHandler = IpxFwdTransferDataComplete;
	bip->FindRouteCompleteHandler = NULL;
	bip->LineUpHandler = IpxFwdLineUp;
	bip->LineDownHandler = IpxFwdLineDown;
	bip->InternalSendHandler = IpxFwdInternalSend;
	bip->FindRouteHandler = IpxFwdFindRoute;
	bip->InternalReceiveHandler = IpxFwdInternalReceive;
//	bip->RipParameters = GlobalWanNetwork ? IPX_RIP_PARAM_GLOBAL_NETWORK : 0;


	if (requestorMode==UserMode)
		status = ZwDeviceIoControlFile(
						HdlIpxFile,		    // HANDLE to File
						NULL,			    // HANDLE to Event
						NULL,			    // ApcRoutine
						NULL,			    // ApcContext
						&IoStatusBlock,	    // IO_STATUS_BLOCK
						IOCTL_IPX_INTERNAL_BIND,	 // IoControlCode
						bip,			    // Input Buffer
						sizeof(IPX_INTERNAL_BIND_INPUT),// Input Buffer Length
						NULL,			    // Output Buffer
						0);			    // Output Buffer Length
	else
		status = NtDeviceIoControlFile(
						HdlIpxFile,		    // HANDLE to File
						NULL,			    // HANDLE to Event
						NULL,			    // ApcRoutine
						NULL,			    // ApcContext
						&IoStatusBlock,	    // IO_STATUS_BLOCK
						IOCTL_IPX_INTERNAL_BIND,	 // IoControlCode
						bip,			    // Input Buffer
						sizeof(IPX_INTERNAL_BIND_INPUT),// Input Buffer Length
						NULL,			    // Output Buffer
						0);			    // Output Buffer Length


	if (status == STATUS_PENDING) {
		if (requestorMode==UserMode)
			status = ZwWaitForSingleObject(
						HdlIpxFile,
						FALSE,
						NULL);
		else
			status = NtWaitForSingleObject(
						HdlIpxFile,
						FALSE,
						NULL);
		if (NT_SUCCESS(status))
			status = IoStatusBlock.Status;
	}

	if (status != STATUS_BUFFER_TOO_SMALL) {
		IpxFwdDbgPrint (DBG_IPXBIND, DBG_ERROR,
			  ("IpxFwd: Ioctl to the IPX driver failed with %lx\n", status));

		ExFreePool(bip);
		if (requestorMode==UserMode)
			ZwClose (HdlIpxFile);
		else
			NtClose (HdlIpxFile);
		return STATUS_INVALID_PARAMETER;
	}

	if ((IPXBindOutput = (PIPX_INTERNAL_BIND_RIP_OUTPUT)
				ExAllocatePoolWithTag(NonPagedPool,
					(ULONG)IoStatusBlock.Information,
					FWD_POOL_TAG)) == NULL) {

		ExFreePool(bip);
		if (requestorMode==UserMode)
			ZwClose (HdlIpxFile);
		else
			NtClose (HdlIpxFile);
		IpxFwdDbgPrint (DBG_IPXBIND, DBG_ERROR,
			 ("IpxFwd: Could not allocate output binding buffer!\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}


	if (requestorMode==UserMode)
		status = ZwDeviceIoControlFile(
					 HdlIpxFile,		    // HANDLE to File
					 NULL,			    // HANDLE to Event
					 NULL,			    // ApcRoutine
					 NULL,			    // ApcContext
					 &IoStatusBlock,	    // IO_STATUS_BLOCK
					 IOCTL_IPX_INTERNAL_BIND,   // IoControlCode
					 bip,			    // Input Buffer
					 sizeof(IPX_INTERNAL_BIND_INPUT),// Input Buffer Length
					 IPXBindOutput,		    // Output Buffer
					 (ULONG)IoStatusBlock.Information);  // Output Buffer Length
	else
		status = NtDeviceIoControlFile(
					 HdlIpxFile,		    // HANDLE to File
					 NULL,			    // HANDLE to Event
					 NULL,			    // ApcRoutine
					 NULL,			    // ApcContext
					 &IoStatusBlock,	    // IO_STATUS_BLOCK
					 IOCTL_IPX_INTERNAL_BIND,   // IoControlCode
					 bip,			    // Input Buffer
					 sizeof(IPX_INTERNAL_BIND_INPUT),// Input Buffer Length
					 IPXBindOutput,		    // Output Buffer
					 (ULONG)IoStatusBlock.Information);  // Output Buffer Length


	if (status == STATUS_PENDING) {
		if (requestorMode==UserMode)
			status = ZwWaitForSingleObject(
							HdlIpxFile,
							(BOOLEAN)FALSE,
							NULL);
		else
			status = NtWaitForSingleObject(
							HdlIpxFile,
							(BOOLEAN)FALSE,
							NULL);
		if (NT_SUCCESS(status))
			status = IoStatusBlock.Status;
		}

    if (!NT_SUCCESS (status)) {
		IpxFwdDbgPrint (DBG_IPXBIND, DBG_ERROR,
			  ("IpxFwd: Ioctl to the IPX driver failed with %lx\n", IoStatusBlock.Status));

		ExFreePool(bip);
		ExFreePool(IPXBindOutput);
		IPXBindOutput = NULL;
		if (requestorMode==UserMode)
			ZwClose (HdlIpxFile);
		else
			NtClose (HdlIpxFile);
		return status;
		}

    IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION,
			 ("IpxFwd: Succesfuly bound to the IPX driver\n"));

    ExFreePool (bip);
	ExFreePool (WstrIpxFileName);

    return status;
}


/*++
*******************************************************************
    U n b i n d F r o m I p x D r i v e r

Routine Description:
	Closes connection to IPX stack driver
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
UnbindFromIpxDriver (
	KPROCESSOR_MODE requestorMode
	) {
		// Free binding output buffer and close driver handle
	ASSERT (IPXBindOutput!=NULL);
	ExFreePool (IPXBindOutput);
	IPXBindOutput = NULL;
    IpxFwdDbgPrint (DBG_IPXBIND, DBG_WARNING,
			 ("IpxFwd: Closing IPX driver handle\n"));
	if (requestorMode==UserMode)
		ZwClose (HdlIpxFile);
	else
		NtClose (HdlIpxFile);
}


/*++
*******************************************************************
	F w  F i n d R o u t e

Routine Description:
	This routine is provided by the Kernel Forwarder to find the route
	to a given node and network
Arguments:
	Network - the destination network
	Node - destination node
	RouteEntry - filled in by the Forwarder if a route exists
Return Value:
	STATUS_SUCCESS
	STATUS_NETWORK_UNREACHABLE - if the findroute failed
*******************************************************************
--*/
NTSTATUS
IpxFwdFindRoute (
	IN  PUCHAR					Network,
	IN  PUCHAR					Node,
	OUT PIPX_FIND_ROUTE_REQUEST	RouteEntry
	) {
	PINTERFACE_CB	ifCB;
	ULONG			net;
	KIRQL			oldIRQL;
	NTSTATUS		status = STATUS_NETWORK_UNREACHABLE;
	PFWD_ROUTE		fwRoute;

	if (!EnterForwarder ())
		return STATUS_UNSUCCESSFUL;

	net = GETULONG (Network);

	ifCB = FindDestination (net, Node, &fwRoute);
	if (ifCB!=NULL) {
		if (IS_IF_ENABLED(ifCB)) {
			KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
			switch (ifCB->ICB_Stats.OperationalState) {
			case FWD_OPER_STATE_UP:
				IPX_NET_CPY (&RouteEntry->Network, Network);
				if (fwRoute->FR_Network==ifCB->ICB_Network) {
					if (Node!=NULL) {
						IPX_NODE_CPY (RouteEntry->LocalTarget.MacAddress, Node);
					}
					else {
						IPX_NODE_CPY (RouteEntry->LocalTarget.MacAddress,
												BROADCAST_NODE);
					}
				}
				else {
					IPX_NODE_CPY (RouteEntry->LocalTarget.MacAddress,
											fwRoute->FR_NextHopAddress);
				}
                if (ifCB!=InternalInterface) {
				    ADAPTER_CONTEXT_TO_LOCAL_TARGET (
                                    ifCB->ICB_AdapterContext,
									&RouteEntry->LocalTarget);
                }
                else {
				    CONSTANT_ADAPTER_CONTEXT_TO_LOCAL_TARGET (
                                    VIRTUAL_NET_ADAPTER_CONTEXT,
									&RouteEntry->LocalTarget);
                }

                //
                // Fill in the hop count and tick count
                //
                RouteEntry->TickCount = fwRoute->FR_TickCount;
                RouteEntry->HopCount  = fwRoute->FR_HopCount;
                
				status = STATUS_SUCCESS;
				break;
			case FWD_OPER_STATE_SLEEPING:
				IPX_NODE_CPY (&RouteEntry->LocalTarget.MacAddress,
												fwRoute->FR_NextHopAddress);
				CONSTANT_ADAPTER_CONTEXT_TO_LOCAL_TARGET (DEMAND_DIAL_ADAPTER_CONTEXT,
												&RouteEntry->LocalTarget);
				status = STATUS_SUCCESS;

                //
                // Fill in the hop count and tick count
                //
                RouteEntry->TickCount = fwRoute->FR_TickCount;
                RouteEntry->HopCount  = fwRoute->FR_HopCount;
                
				
				break;
			case FWD_OPER_STATE_DOWN:
				status = STATUS_NETWORK_UNREACHABLE;
				break;
			default:
				ASSERTMSG ("Inavalid operational state", FALSE);
			}
			KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
	#if DBG
			if (Node!=NULL) {
				if (NT_SUCCESS (status)) {
					IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION,
						("IpxFwd: Found route for IPX driver:"
							" %08lX:%02X%02X%02X%02X%02X%02X"
							" -> %ld(%ld):%02X%02X%02X%02X%02X%02X\n",
							net, Node[0],Node[1],Node[2],Node[3],Node[4],Node[5],
							ifCB->ICB_Index, RouteEntry->LocalTarget.NicId,
								RouteEntry->LocalTarget.MacAddress[0],
								RouteEntry->LocalTarget.MacAddress[1],
								RouteEntry->LocalTarget.MacAddress[2],
								RouteEntry->LocalTarget.MacAddress[3],
								RouteEntry->LocalTarget.MacAddress[4],
								RouteEntry->LocalTarget.MacAddress[5]));
				}
				else {
					IpxFwdDbgPrint (DBG_IPXROUTE, DBG_WARNING,
						("IpxFwd: Network unreachable for:"
							" %08lX:%02X%02X%02X%02X%02X%02X -> %ld.\n",
							net, Node[0],Node[1],Node[2],Node[3],Node[4],Node[5],
							ifCB->ICB_Index));
				}
			}
			else {
				if (NT_SUCCESS (status)) {
					IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION,
						("IpxFwd: Found route for IPX driver:"
							" %08lX"
							" -> %ld(%ld):%02X%02X%02X%02X%02X%02X\n",
							net, ifCB->ICB_Index, RouteEntry->LocalTarget.NicId,
								RouteEntry->LocalTarget.MacAddress[0],
								RouteEntry->LocalTarget.MacAddress[1],
								RouteEntry->LocalTarget.MacAddress[2],
								RouteEntry->LocalTarget.MacAddress[3],
								RouteEntry->LocalTarget.MacAddress[4],
								RouteEntry->LocalTarget.MacAddress[5]));
				}
				else {
					IpxFwdDbgPrint (DBG_IPXROUTE, DBG_WARNING,
						("IpxFwd: Network unreachable for:"
							" %08lX -> %ld.\n", net));
				}
			}
	#endif
			ReleaseInterfaceReference (ifCB);
			ReleaseRouteReference (fwRoute);

		}
	}
	else {
#if DBG
		if (Node!=NULL) {
			IpxFwdDbgPrint (DBG_IPXROUTE, DBG_WARNING,
				("IpxFwd: No route for:"
					" %08lX:%02X%02X%02X%02X%02X%02X.\n",
					net, Node[0],Node[1],Node[2],Node[3],Node[4],Node[5]));
		}
		else {
			IpxFwdDbgPrint (DBG_IPXROUTE, DBG_WARNING,
				("IpxFwd: No route for: %08lX.\n", net));
		}
#endif
		status = STATUS_NETWORK_UNREACHABLE;
	}
	LeaveForwarder ();
	return status;
}
			


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\netbios.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\netbios.h

Abstract:
	Netbios packet processing

Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef IPXFWD_NETBIOS
#define IPXFWD_NETBIOS

extern LIST_ENTRY		NetbiosQueue;
extern KSPIN_LOCK		NetbiosQueueLock;
extern WORK_QUEUE_ITEM	NetbiosWorker;
extern BOOLEAN			NetbiosWorkerScheduled;
extern ULONG			NetbiosPacketsQuota;
extern ULONG			MaxNetbiosPacketsQueued;
#define DEF_MAX_NETBIOS_PACKETS_QUEUED	256


/*++
*******************************************************************
    I n i t i a l i z e N e t b i o s Q u e u e

Routine Description:
	Initializes the netbios bradcast queue
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
//VOID
//InitializeNetbiosQueue (
//	void
//	)
#define InitializeNetbiosQueue()	{							\
	InitializeListHead (&NetbiosQueue);							\
	KeInitializeSpinLock (&NetbiosQueueLock);					\
	ExInitializeWorkItem (&NetbiosWorker, &ProcessNetbiosQueue, NULL);\
	NetbiosWorkerScheduled = FALSE;								\
	NetbiosPacketsQuota = MaxNetbiosPacketsQueued;				\
}

/*++
*******************************************************************
    D e l e t e N e t b i o s Q u e u e

Routine Description:
	Deletes the netbios bradcast queue
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteNetbiosQueue (
	void
	);


/*++
*******************************************************************
    P r o c e s s N e t b i o s Q u e u e

Routine Description:
	Process packets in the netbios bradcast queue
Arguments:
	Context - unused
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessNetbiosQueue (
	PVOID		Context
	);

/*++
*******************************************************************
    P r o c e s s N e t b i o s P a c k e t

Routine Description:
	Processes received netbios broadcast packet
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessNetbiosPacket (
	PINTERFACE_CB	srcIf,
	PPACKET_TAG		pktTag
	);


#define QueueNetbiosPacket(pktTag) {						\
	KIRQL		oldIRQL;									\
	KeAcquireSpinLock (&NetbiosQueueLock, &oldIRQL);		\
	InsertTailList (&NetbiosQueue, &pktTag->PT_QueueLink);	\
	KeReleaseSpinLock (&NetbiosQueueLock, oldIRQL);			\
}

#define ScheduleNetbiosWorker() {							\
	KIRQL		oldIRQL;									\
	KeAcquireSpinLock (&NetbiosQueueLock, &oldIRQL);		\
	if (!NetbiosWorkerScheduled								\
			&& !IsListEmpty (&NetbiosQueue)					\
			&& EnterForwarder ()) {							\
		NetbiosWorkerScheduled	= TRUE;						\
		ExQueueWorkItem (&NetbiosWorker, DelayedWorkQueue);	\
	}														\
	KeReleaseSpinLock (&NetbiosQueueLock, oldIRQL);			\
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\lineind.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\lineind.c

Abstract:
	Processing line indication (bind/unbind)


Author:

    Vadim Eydelman

Revision History:

--*/

#include    "precomp.h"


/*++
*******************************************************************
    B i n d I n t e r f a c e

Routine Description:
	Binds interface to physical adapter and exchanges contexts
	with IPX stack
Arguments:
	ifCB			- interface to bind
	NicId			- id of an adapter
	MaxPacketSize	- max size of packet allowed
	Network			- adapter network address
	LocalNode		- adapter local node address
	RemoteNode		- peer node address (for clients on global
						net)
Return Value:
	STATUS_SUCCESS - interface was bound OK
	error status returned by IPX stack driver

*******************************************************************
--*/
NTSTATUS
BindInterface (
	IN PINTERFACE_CB	ifCB,
	IN USHORT			NicId,
	IN ULONG			MaxPacketSize,
	IN ULONG			Network,
	IN PUCHAR			LocalNode,
	IN PUCHAR			RemoteNode
	) {
	KIRQL				oldIRQL;
	NTSTATUS			status;
    NIC_HANDLE          NicHandle={0};
	
	KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
	if (ifCB->ICB_Stats.OperationalState!=FWD_OPER_STATE_UP) {
		switch (ifCB->ICB_InterfaceType) {
		case FWD_IF_PERMANENT:
			if (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX)
				status = RegisterPacketConsumer (MaxPacketSize,
											&ifCB->ICB_PacketListId);
			else
				status = STATUS_SUCCESS;
			break;
		case FWD_IF_DEMAND_DIAL:
		case FWD_IF_LOCAL_WORKSTATION:
		case FWD_IF_REMOTE_WORKSTATION:
			if (IS_IF_CONNECTING (ifCB)) {
				SET_IF_NOT_CONNECTING (ifCB);
				DequeueConnectionRequest (ifCB);
			}
			status = STATUS_SUCCESS;
			break;
		default:
		    status = STATUS_INVALID_PARAMETER;
			ASSERTMSG ("Invalid interface type ", FALSE);
			break;
		}
		if (NT_SUCCESS (status)) {
			if (Network==GlobalNetwork) {
				ASSERT (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);
				IPX_NODE_CPY (ifCB->ICB_RemoteNode, RemoteNode);
				status = AddGlobalNetClient (ifCB);
				ASSERT (status==STATUS_SUCCESS);
			}
			KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
			
			if (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX) {
                NIC_HANDLE_FROM_NIC(NicHandle, NicId);
				status = IPXOpenAdapterProc (NicHandle, (ULONG_PTR)ifCB,
										&ifCB->ICB_AdapterContext);
            }

			if (NT_SUCCESS (status)) {
				ifCB->ICB_Network = Network;
				IPX_NODE_CPY (ifCB->ICB_RemoteNode, RemoteNode);
				IPX_NODE_CPY (ifCB->ICB_LocalNode, LocalNode);
				if (ifCB->ICB_InterfaceType==FWD_IF_PERMANENT)
					ifCB->ICB_Stats.MaxPacketSize = MaxPacketSize;
				else
					ifCB->ICB_Stats.MaxPacketSize = WAN_PACKET_SIZE;
				ifCB->ICB_NicId = NicId;
				ifCB->ICB_Stats.OperationalState = FWD_OPER_STATE_UP;

				AcquireInterfaceReference (ifCB);
				IpxFwdDbgPrint (DBG_LINEIND, DBG_INFORMATION,
					("IpxFwd: Bound interface %ld (icb: %08lx):"
					" Nic-%d, Net-%08lx,"
					" LocalNode-%02x%02x%02x%02x%02x%02x,"
					" RemoteNode-%02x%02x%02x%02x%02x%02x.\n",
					ifCB->ICB_Index, ifCB, NicId, Network,
					LocalNode[0], LocalNode[1], LocalNode[2],
						LocalNode[3], LocalNode[4], LocalNode[5],
					RemoteNode[0], RemoteNode[1], RemoteNode[2],
						RemoteNode[3], RemoteNode[4], RemoteNode[5]));

				if (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX) {
					ProcessInternalQueue (ifCB);
					ProcessExternalQueue (ifCB);
				}
				return STATUS_SUCCESS;
			}

			IpxFwdDbgPrint (DBG_LINEIND, DBG_ERROR,
					("IpxFwd: Could not open adapter %d to bind"
					" interface %ld (icb: %08lx)!\n",
					NicId, ifCB->ICB_Index, ifCB));

			KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
			if (Network==GlobalNetwork) {
				DeleteGlobalNetClient (ifCB);
			}

			switch (ifCB->ICB_InterfaceType) {
			case FWD_IF_PERMANENT:
				DeregisterPacketConsumer (ifCB->ICB_PacketListId);
				break;
			case FWD_IF_DEMAND_DIAL:
			case FWD_IF_LOCAL_WORKSTATION:
			case FWD_IF_REMOTE_WORKSTATION:
				break;
			}
		}
		ifCB->ICB_Stats.OperationalState = FWD_OPER_STATE_DOWN;
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
	
		ProcessInternalQueue (ifCB);
		ProcessExternalQueue (ifCB);
	}
	else {
		ASSERT (Network==ifCB->ICB_Network);
		ASSERT (NicId==(USHORT)ifCB->ICB_AdapterContext.NicId);
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
		status = STATUS_SUCCESS; // Report success if already
								// connected
		IpxFwdDbgPrint (DBG_LINEIND, DBG_WARNING,
			("IpxFwd: Interface %ld (icb: %08lx) is already bound to Nic %d.\n",
			ifCB->ICB_Index, ifCB, NicId));
	}
	return status;
}


/*++
*******************************************************************
    U n b i n d I n t e r f a c e

Routine Description:
	Unbinds interface from physical adapter and breaks connection
	with IPX stack
Arguments:
	ifCB			- interface to unbind
Return Value:
	None
*******************************************************************
--*/
VOID
UnbindInterface (
	PINTERFACE_CB	ifCB
	) {
	KIRQL		oldIRQL;
	KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
	if (ifCB->ICB_Stats.OperationalState==FWD_OPER_STATE_UP) {
		switch (ifCB->ICB_InterfaceType) {
		case FWD_IF_PERMANENT:
			ifCB->ICB_Stats.OperationalState = FWD_OPER_STATE_DOWN;
			if (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX)
				DeregisterPacketConsumer (ifCB->ICB_PacketListId);
			break;
		case FWD_IF_DEMAND_DIAL:
		case FWD_IF_LOCAL_WORKSTATION:
		case FWD_IF_REMOTE_WORKSTATION:
			ifCB->ICB_Stats.OperationalState = FWD_OPER_STATE_SLEEPING;
			KeQuerySystemTime ((PLARGE_INTEGER)&ifCB->ICB_DisconnectTime);
			break;
		default:
			ASSERTMSG ("Invalid interface type ", FALSE);
			break;
		}
		if (ifCB->ICB_CashedInterface!=NULL)
			ReleaseInterfaceReference (ifCB->ICB_CashedInterface);
		ifCB->ICB_CashedInterface = NULL;
		if (ifCB->ICB_CashedRoute!=NULL)
			ReleaseRouteReference (ifCB->ICB_CashedRoute);
		ifCB->ICB_CashedRoute = NULL;
		if (ifCB->ICB_Network==GlobalNetwork)
			DeleteGlobalNetClient (ifCB);
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);

		IpxFwdDbgPrint (DBG_LINEIND, DBG_INFORMATION,
			("IpxFwd: Unbinding interface %ld (icb: %08lx) from Nic %ld.\n",
			ifCB->ICB_Index, ifCB, ifCB->ICB_AdapterContext));
		if (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX) {
		    // [pmay].  Because of pnp, this interface may not need to have an
		    // adapter closed any more.  This is because nic id's get renumbered.
		    if (ifCB->ICB_NicId != INVALID_NIC_ID)
    			IPXCloseAdapterProc (ifCB->ICB_AdapterContext);
			ProcessInternalQueue (ifCB);
			ProcessExternalQueue (ifCB);
		}
		ReleaseInterfaceReference (ifCB);
	}
	else {
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
		IpxFwdDbgPrint (DBG_LINEIND, DBG_WARNING,
			("IpxFwd: Interface %ld (icb: %08lx) is already unbound.\n",
			ifCB->ICB_Index, ifCB));
	}
}



/*++
*******************************************************************
    F w L i n e U p

Routine Description:
	Process line up indication delivered by IPX stack
Arguments:
	NicId		- adapter ID on which connection was established
	LineInfo	- NDIS/IPX line information
	DeviceType	- medium specs
	ConfigurationData - IPX CP configuration data
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdLineUp (
	IN USHORT			NicId,
	IN PIPX_LINE_INFO	LineInfo,
	IN NDIS_MEDIUM		DeviceType,
	IN PVOID			ConfigurationData
	) {
	PINTERFACE_CB		ifCB;
	if (ConfigurationData==NULL)	// This is just an update for multilink
									// connections
		return;

    if (!EnterForwarder()) {
		return;
    }
	IpxFwdDbgPrint (DBG_LINEIND, DBG_INFORMATION, ("IpxFwd: FwdLineUp.\n"));

	ifCB = GetInterfaceReference (
		((PIPXCP_CONFIGURATION)ConfigurationData)->InterfaceIndex);
	if (ifCB!=NULL) {
		LONG	Net = GETULONG (((PIPXCP_CONFIGURATION)ConfigurationData)->Network);
		
		ASSERT (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);
		ASSERT (ifCB->ICB_InterfaceType!=FWD_IF_PERMANENT);
		
		BindInterface (ifCB,
			NicId,
			LineInfo->MaximumPacketSize,
			Net,
			((PIPXCP_CONFIGURATION)ConfigurationData)->LocalNode,
			((PIPXCP_CONFIGURATION)ConfigurationData)->RemoteNode
			);
		ReleaseInterfaceReference (ifCB);
	}
	LeaveForwarder ();
}




/*++
*******************************************************************
    F w L i n e D o w n

Routine Description:
	Process line down indication delivered by IPX stack
Arguments:
	NicId		- disconnected adapter ID
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdLineDown (
	IN USHORT NicId,
	IN ULONG_PTR Context
	) {
	PINTERFACE_CB	ifCB;

    if (!EnterForwarder()) {
		return;
    }
	IpxFwdDbgPrint (DBG_LINEIND, DBG_INFORMATION, ("IpxFwd: FwdLineDown.\n"));


	ifCB = InterfaceContextToReference ((PVOID)Context, NicId);
	if (ifCB!=NULL) {
		ASSERT (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);
		ASSERT (ifCB->ICB_InterfaceType!=FWD_IF_PERMANENT);
		UnbindInterface (ifCB);
		ReleaseInterfaceReference (ifCB);
	}
	LeaveForwarder ();
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\ipxbind.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\ipxbind.h

Abstract:
    IPX Forwarder Driver interface with IPX stack driver


Author:

    Vadim Eydelman

Revision History:

--*/


#ifndef _IPXFWD_IPXBIND_
#define _IPXFWD_IPXBIND_

extern PIPX_INTERNAL_BIND_RIP_OUTPUT	IPXBindOutput;
#define IPXMacHeaderSize (IPXBindOutput->MacHeaderNeeded)
#define IPXOpenAdapterProc (IPXBindOutput->OpenAdapterHandler)
#define IPXCloseAdapterProc (IPXBindOutput->CloseAdapterHandler)
#define IPXInternalSendCompletProc (IPXBindOutput->InternalSendCompleteHandler)
#define IPXSendProc (IPXBindOutput->SendHandler)
#define IPXTransferData (IPXBindOutput->TransferDataHandler)


/*++
*******************************************************************
    B i n d T o I p x D r i v e r

Routine Description:
	Exchanges binding information with IPX stack driver
Arguments:
Return Value:
	STATUS_SUCCESS - exchange was done OK
	STATUS_INSUFFICIENT_RESOURCES - could not allocate buffers for
									info exchange
	error status returned by IPX stack driver

*******************************************************************
--*/
NTSTATUS
BindToIpxDriver (
	KPROCESSOR_MODE requestorMode
	);


/*++
*******************************************************************
    U n b i n d T o I p x D r i v e r

Routine Description:
	Closes connection to IPX stack driver
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
UnbindFromIpxDriver (
	KPROCESSOR_MODE requestorMode
	);


#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\packets.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\packets.h

Abstract:
    IPX Forwarder Driver packet allocator


Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFWD_PACKETS_
#define _IPXFWD_PACKETS_

// Forward structure prototypes
struct _SEGMENT_LIST;
typedef struct _SEGMENT_LIST SEGMENT_LIST, *PSEGMENT_LIST;
struct _PACKET_SEGMENT;
typedef struct _PACKET_SEGMENT PACKET_SEGMENT, *PPACKET_SEGMENT;
struct _PACKET_TAG;
typedef struct _PACKET_TAG PACKET_TAG, *PPACKET_TAG;

// Forwarder data associated with each packet it allocates
struct _PACKET_TAG {
	union {
		UCHAR			PT_Identifier;	// this should be IDENTIFIER_RIP
		PPACKET_TAG		PT_Next;		// link in packet segment
	};
	union {
		PVOID			SEND_RESERVED[SEND_RESERVED_COMMON_SIZE];	// needed by ipx
										// for padding on ethernet
		PINTERFACE_CB	PT_SourceIf;	// Source interface reference needed
										// for spoofing keep-alives and
                                        // queuing connection requests
	};
	PPACKET_SEGMENT		PT_Segment;		// segment where it belongs
	LONGLONG			PT_PerfCounter;
	ULONG				PT_Flags;
#define	PT_NB_DESTROY	0x1				// NB packet to be not requeued
#define PT_SOURCE_IF	0x2				// Spoofing packet with src if reference
	PUCHAR				PT_Data;		// Data buffer
	PNDIS_BUFFER		PT_MacHdrBufDscr; // buffer descriptor for
										// mac header buffer required
										// by IPX
	PINTERFACE_CB		PT_InterfaceReference;	// points to the interface CB where
										// it is queued
	LIST_ENTRY			PT_QueueLink;	// links this packet in send queue
	IPX_LOCAL_TARGET	PT_Target;		// destination target for ipx
										// stack
	UCHAR				PT_MacHeader[1];// Mac header buffer reserved for IPX
};

// Segment of preallocated packets complete with buffers
struct _PACKET_SEGMENT {
	LIST_ENTRY				PS_Link;		// Link in segment list
	PSEGMENT_LIST			PS_SegmentList;	// Segment list we belong to
	PPACKET_TAG				PS_FreeHead;	// List of free packets in
											// this segment
	ULONG					PS_BusyCount;	// Count of packets allocated
											// from this segment
	NDIS_HANDLE				PS_PacketPool;	// Pool of NDIS packet
											// descriptors used by the
											// packets in this segment
	NDIS_HANDLE				PS_BufferPool;	// Pool of NDIS buffer
											// descriptors used by the
											// packets in this segment
	LONGLONG				PS_FreeStamp;	// Time when last packet was freed
	union {
		UCHAR					PS_Buffers[1];	// Memory used by buffers
		LONGLONG				PS_BuffersAlign;
	};
};


// List of segment with preallocated packets
struct _SEGMENT_LIST {
	const ULONG				SL_BlockSize;	// Size of packet's buffer
	LIST_ENTRY				SL_Head;		// Head of the segment list
	ULONG					SL_FreeCount;	// Total number of free packets
											// in all segment in the list
	ULONG					SL_BlockCount;	// Number of packets per segment
	ULONG					SL_LowCount;	// Free count at which we
											// will preallocate new segment
	LONG					SL_RefCount;	// Number of consumers that are
											// using packets in this list
	BOOLEAN					SL_TimerDpcPending;
	BOOLEAN					SL_AllocatorPending;
	WORK_QUEUE_ITEM			SL_Allocator;	// Allocation work item
	KTIMER					SL_Timer;		// Timer to free unused segments
	KDPC					SL_TimerDpc;	// DPC of the timer of unused segments
	KSPIN_LOCK				SL_Lock;		// Access control
};


// The number of rcv packets per segment (config parameter)
#define     MIN_RCV_PKTS_PER_SEGMENT	    8
#define     DEF_RCV_PKTS_PER_SEGMENT	    64
#define     MAX_RCV_PKTS_PER_SEGMENT	    256
extern ULONG RcvPktsPerSegment;

// Maximum size of memory that can be used to allocate packets (config
// param). 0 means no limit
extern ULONG MaxRcvPktsPoolSize;

// There are currently three known frame sizes: ethernet-1500,
//		token ring 4k - 4500, token ring 16k - 17986
#define FRAME_SIZE_VARIATIONS	3

// List of packet segments for Ethernet packets
extern SEGMENT_LIST	ListEther;	
// List of packet segments for Token Ring 4K packets
extern SEGMENT_LIST	ListTR4;
// List of packet segments for Token Ring 16K packets
extern SEGMENT_LIST	ListTR16;
// Mapping from src and destination packet size requirments
// to the appropriate segment list
extern PSEGMENT_LIST SegmentMap[FRAME_SIZE_VARIATIONS][FRAME_SIZE_VARIATIONS];
// Timeout for unused segment
extern const LONGLONG SegmentTimeout;
extern KSPIN_LOCK	AllocatorLock;

/*++
*******************************************************************
    I n i t i a l i z e P a c k e t A l l o c a t o r

Routine Description:
	Initializes packet allocator
Arguments:
    None
Return Value:
	None

*******************************************************************
--*/
//	VOID
//	InitializePacketAllocator (
//		void
//	);
#define InitializePacketAllocator() {			\
	KeInitializeSpinLock(&AllocatorLock);		\
	InitializeSegmentList(&ListEther);			\
	InitializeSegmentList(&ListTR4);			\
	InitializeSegmentList(&ListTR16);			\
}

/*++
*******************************************************************
    D e l e t e P a c k e t A l l o c a t o r

Routine Description:
	Disposes of all resources in packet allocator
Arguments:
    None
Return Value:
	None

*******************************************************************
--*/
//	VOID
//	DeletePacketAllocator (
//		void
//	);
#define DeletePacketAllocator() {			\
	DeleteSegmentList(&ListEther);			\
	DeleteSegmentList(&ListTR4);			\
	DeleteSegmentList(&ListTR16);			\
}


/*++
*******************************************************************
    A l l o c a t e P a c k e t

Routine Description:
	Allocate packet for source - destination combination
Arguments:
    srcListId - identifies max frame size for source interface
	dstListId - identifies max frame size for destination
	packet - receives pointer to allocated packet or NULL if allocation
			fails
Return Value:
	None

*******************************************************************
--*/
//	VOID
//	AllocatePacket (
//		IN INT		srcListId,
//		IN INT		dstListId,
//		OUT PPACKET_TAG	packet
//		);
#define AllocatePacket(srcListId,dstListId,packet) {					\
	PSEGMENT_LIST		list;											\
	ASSERT ((srcListId>=0) && (srcListId<FRAME_SIZE_VARIATIONS));		\
	ASSERT ((dstListId>=0) && (dstListId<FRAME_SIZE_VARIATIONS));		\
	list = SegmentMap[srcListId][dstListId];							\
	AllocatePacketFromList(list,packet);								\
}

/*++
*******************************************************************
    D u p l i c a t e P a c k e t

Routine Description:
	Duplicates packet
Arguments:
	src	- source packet
	dst - receives pointer to duplicated packet or NUUL if operation
	failed
Return Value:
	None

*******************************************************************
--*/
//	VOID
//	DuplicatePacket (
//		IN PPACKET_TAG	src
//		OUT PPACKET_TAG	dst
//		);
#define DuplicatePacket(src,dst) {										\
	PSEGMENT_LIST		list;											\
	list = src->PT_Segment->PS_SegmentList;								\
	AllocatePacketFromList(list,dst);									\
}


/*++
*******************************************************************
    A l l o c a t e P a c k e t F r o m L i s t

Routine Description:
	Allocate packet from specified packet segment list
Arguments:
	list	- list from which to allocate
	packet	- receives pointer to allocated packet or NULL if allocation
			fails
Return Value:
	None

*******************************************************************
--*/
//	VOID
//	AllocatePacketFromList (
//		IN PSEGMENT_LIST	list
//		OUT PPACKET_TAG		packet
//		);
#define AllocatePacketFromList(list,packet) {							\
	PPACKET_SEGMENT		segment;										\
	KIRQL				oldIRQL;										\
	KeAcquireSpinLock (&list->SL_Lock, &oldIRQL);						\
	do {																\
		if (list->SL_FreeCount>0) {										\
			segment = CONTAINING_RECORD (list->SL_Head.Flink,			\
											 PACKET_SEGMENT, PS_Link);	\
			while (segment->PS_FreeHead==NULL) {						\
				segment = CONTAINING_RECORD (segment->PS_Link.Flink,	\
											PACKET_SEGMENT, PS_Link);	\
				ASSERT (&segment->PS_Link!=&list->SL_Head);				\
			}															\
			list->SL_FreeCount -= 1;									\
			if ((list->SL_FreeCount<list->SL_LowCount)					\
					&& !list->SL_AllocatorPending						\
					&& EnterForwarder ()) {								\
				list->SL_AllocatorPending = TRUE;						\
				ExQueueWorkItem (&list->SL_Allocator, DelayedWorkQueue);\
			}															\
		}																\
		else {															\
			segment = CreateSegment (list);								\
			if (segment!=NULL) {										\
				InsertTailList (&list->SL_Head, &segment->PS_Link);		\
				segment->PS_SegmentList = list;							\
				list->SL_FreeCount = list->SL_BlockCount-1;				\
			}															\
			else {														\
				packet = NULL;											\
				break;													\
			}															\
		}																\
		packet = segment->PS_FreeHead;									\
		segment->PS_FreeHead = packet->PT_Next;							\
		segment->PS_BusyCount += 1;										\
		packet->PT_Identifier = IDENTIFIER_RIP;							\
		packet->PT_Flags = 0;											\
	}																	\
	while (FALSE);														\
	KeReleaseSpinLock (&list->SL_Lock, oldIRQL);						\
}

/*++
*******************************************************************
    F r e e P a c k e t

Routine Description:
	Free allocated packet
Arguments:
	packet - packet to free
Return Value:
	None

*******************************************************************
--*/
//	VOID
//	FreePacket (
//		IN PPACKET_TAG	packet
//		);
#define FreePacket(packet) {							\
	PPACKET_SEGMENT		segment=packet->PT_Segment;		\
	PSEGMENT_LIST		list;							\
	KIRQL				oldIRQL;						\
	list = segment->PS_SegmentList;						\
	KeAcquireSpinLock (&list->SL_Lock, &oldIRQL);		\
	packet->PT_Next = segment->PS_FreeHead;				\
	segment->PS_FreeHead = packet;						\
	list->SL_FreeCount += 1;							\
	segment->PS_BusyCount -= 1;							\
	if (segment->PS_BusyCount==0) {						\
		if (list->SL_TimerDpcPending) {					\
			KeQuerySystemTime ((PLARGE_INTEGER)&segment->PS_FreeStamp);	\
			KeReleaseSpinLock (&list->SL_Lock, oldIRQL);\
		}												\
		else if (EnterForwarder ()) {					\
			list->SL_TimerDpcPending = TRUE;			\
			KeReleaseSpinLock (&list->SL_Lock, oldIRQL);\
			KeSetTimer (&list->SL_Timer,				\
					*((PLARGE_INTEGER)&SegmentTimeout),	\
					&list->SL_TimerDpc);				\
		}												\
		else {											\
			KeReleaseSpinLock (&list->SL_Lock, oldIRQL);\
		}												\
	}													\
	else {												\
		KeReleaseSpinLock (&list->SL_Lock, oldIRQL);	\
	}													\
}
	

/*++
*******************************************************************
    C r e a t e S e g m e n t

Routine Description:
	Allocates and initializes packet segment
Arguments:
	list - segment list to which new segment will be added
Return Value:
	Pointer to allocated segment, NULL if fails

*******************************************************************
--*/
PPACKET_SEGMENT
CreateSegment (
	PSEGMENT_LIST	list
	);

/*++
*******************************************************************
    D e l e t e S e g m e n t

Routine Description:
	Frees packet segment
Arguments:
	segment - segment to free
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteSegment (
	PPACKET_SEGMENT	segment
	);

/*++
*******************************************************************
    R e g i s t e r P a c k e t C o n s u m e r

Routine Description:
	Registers a consumer (bound interface) of packets of the
	given size
Arguments:
	pktsize - maximum size of packets needed
	listId - buffer to return packet list id where packets
			of required size are located
Return Value:
	STATUS_SUCCESS - registration succeded
	STATUS_INSUFFICIENT_RESOURCES - not enogh resources to register

*******************************************************************
--*/
NTSTATUS
RegisterPacketConsumer (
	IN ULONG	pktsize,
	OUT INT		*listID
	);

/*++
*******************************************************************
    D e r e g i s t e r P a c k e t C o n s u m e r

Routine Description:
	Deregisters a consumer (bound interface) of packets of the
	given size
Arguments:
	listId - packet list id used by the consumer
Return Value:
	None

*******************************************************************
--*/
VOID
DeregisterPacketConsumer (
	IN INT		listID
	);

/*++
*******************************************************************
    I n i t i a l i z e S e g m e n t L i s t

Routine Description:
	Initializes list of packet segments
Arguments:
	list - list to initalize
Return Value:
	None

*******************************************************************
--*/
VOID
InitializeSegmentList(
	PSEGMENT_LIST	list
	);


/*++
*******************************************************************
    D e l e t e S e g m e n t L i s t

Routine Description:
	Deletes list of packet segments
Arguments:
	list - list to delete
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteSegmentList (
	PSEGMENT_LIST	list
	);

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\packets.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\packets.c

Abstract:
    IPX Forwarder Driver packet allocator


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

ULONG	RcvPktsPerSegment = DEF_RCV_PKTS_PER_SEGMENT;
ULONG	MaxRcvPktsPoolSize =0;
ULONG	RcvPktsPoolSize = 0;
KSPIN_LOCK	AllocatorLock;
const LONGLONG SegmentTimeout = -10i64*10000000i64;

SEGMENT_LIST ListEther={1500};
SEGMENT_LIST ListTR4={4500};
SEGMENT_LIST ListTR16={17986};

PSEGMENT_LIST	SegmentMap[FRAME_SIZE_VARIATIONS][FRAME_SIZE_VARIATIONS] = {
	{&ListEther, &ListEther, &ListEther},
	{&ListEther, &ListTR4, &ListTR4},
	{&ListEther, &ListTR4, &ListTR16}
};

VOID
AllocationWorker (
	PVOID		Context
	);
	
VOID
SegmentTimeoutDpc (
	PKDPC		dpc,
	PVOID		Context,
	PVOID		SystemArgument1,
	PVOID		SystemArgument2
	);
	
/*++
*******************************************************************
    C r e a t e S e g m e n t

Routine Description:
	Allocates and initializes packet segment
Arguments:
	list - segment list to which new segment will be added
Return Value:
	Pointer to allocated segment, NULL if fails

*******************************************************************
--*/
PPACKET_SEGMENT
CreateSegment (
	PSEGMENT_LIST	list
	) {
	KIRQL				oldIRQL;
	NDIS_STATUS			status;
	PPACKET_SEGMENT		segment;
	ULONG				segmentsize = list->SL_BlockCount*list->SL_BlockSize
								+FIELD_OFFSET(PACKET_SEGMENT,PS_Buffers);
	if (MaxRcvPktsPoolSize!=0) {
			// Check if this allocation would exceed the limit
		KeAcquireSpinLock (&AllocatorLock, &oldIRQL);
		if (RcvPktsPoolSize+segmentsize<MaxRcvPktsPoolSize) {
			RcvPktsPoolSize += segmentsize;
			KeReleaseSpinLock (&AllocatorLock, oldIRQL);
		}
		else {
			KeReleaseSpinLock (&AllocatorLock, oldIRQL);
			return NULL;
		}
	}

		// Allocate chunk of memory to hold segment header and buffers
	segment = ExAllocatePoolWithTag (
					NonPagedPool,
					segmentsize,
					FWD_POOL_TAG);
	if (segment!=NULL) {
		segment->PS_SegmentList = list;
		segment->PS_FreeHead = NULL;
		segment->PS_BusyCount = 0;
		segment->PS_PacketPool = (NDIS_HANDLE)FWD_POOL_TAG;
		KeQuerySystemTime ((PLARGE_INTEGER)&segment->PS_FreeStamp);
		NdisAllocatePacketPoolEx (
				&status,
				&segment->PS_PacketPool,
				list->SL_BlockCount,
				0,
				IPXMacHeaderSize
						+FIELD_OFFSET (PACKET_TAG, PT_MacHeader));
		if (status==NDIS_STATUS_SUCCESS) {
        	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING, 
                ("IpxFwd: CreateSegent pool: %x\n", segment->PS_PacketPool));
	
			NdisAllocateBufferPool (
				&status,
				&segment->PS_BufferPool,
				list->SL_BlockCount*2);
			if (status==NDIS_STATUS_SUCCESS) {
				PUCHAR			bufferptr = segment->PS_Buffers;
				PNDIS_PACKET	packetDscr;
				PNDIS_BUFFER	bufferDscr;
				PPACKET_TAG		packetTag;
				ULONG			i;

				for (i=0; i<list->SL_BlockCount; i++,
										bufferptr+=list->SL_BlockSize) {
					NdisAllocatePacket (
						&status,
						&packetDscr,
						segment->PS_PacketPool);
					ASSERT (status==NDIS_STATUS_SUCCESS);

					packetTag = (PPACKET_TAG)packetDscr->ProtocolReserved;
					packetTag->PT_Segment = segment;
					packetTag->PT_Data = bufferptr;
					packetTag->PT_InterfaceReference = NULL;
					
					NdisAllocateBuffer (
						&status,
						&packetTag->PT_MacHdrBufDscr,
						segment->PS_BufferPool,
						packetTag->PT_MacHeader,
						IPXMacHeaderSize);
					ASSERT (status==NDIS_STATUS_SUCCESS);

					NdisAllocateBuffer (
						&status,
						&bufferDscr,
						segment->PS_BufferPool,
						bufferptr,
						list->SL_BlockSize);
					ASSERT (status==NDIS_STATUS_SUCCESS);
					if (bufferDscr)
					{
    					NdisChainBufferAtFront (packetDscr, bufferDscr);
					}

					packetTag->PT_Next = segment->PS_FreeHead;
					segment->PS_FreeHead = packetTag;
				}
				IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING,
					("IpxFwd: Allocated packet segment %08lx for list %ld.\n",
					segment, list->SL_BlockSize));
				return segment;
			}
			else {
				IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_ERROR,
					("IpxFwd: Failed to allocate buffer pool"
					" for new segment in list %ld.\n",
					list->SL_BlockSize));
			}
			NdisFreePacketPool (segment->PS_PacketPool);
		}
		else {
			IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_ERROR,
				("IpxFwd: Failed to allocate packet pool"
				" for new segment in list %ld.\n",
				list->SL_BlockSize));
		}
		ExFreePool (segment);
	}
	else {
		IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_ERROR,
			("IpxFwd: Failed to allocate new segment for list %ld.\n",
			list->SL_BlockSize));
	}

	return NULL;
}


/*++
*******************************************************************
    D e l e t e S e g m e n t

Routine Description:
	Frees packet segment
Arguments:
	segment - segment to free
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteSegment (
	PPACKET_SEGMENT	segment
	) {
	PSEGMENT_LIST	list = segment->PS_SegmentList;

	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING, 
	                ("IpxFwd: DeleteSegment entered. %d %x\n",segment->PS_BusyCount, segment->PS_PacketPool));
	
	ASSERT (segment->PS_BusyCount == 0);
	
	// Free all NDIS packet and buffer descriptors first
	while (segment->PS_FreeHead!=NULL) {
		PNDIS_BUFFER	bufferDscr;
		PPACKET_TAG		packetTag = segment->PS_FreeHead;
		PNDIS_PACKET	packetDscr = CONTAINING_RECORD (packetTag,
									NDIS_PACKET, ProtocolReserved);

		segment->PS_FreeHead = packetTag->PT_Next;

		ASSERT (packetTag->PT_MacHdrBufDscr!=NULL);
		NdisFreeBuffer (packetTag->PT_MacHdrBufDscr);

		NdisUnchainBufferAtFront (packetDscr, &bufferDscr);
		ASSERT (bufferDscr!=NULL);
		NdisFreeBuffer (bufferDscr);
		
		NdisFreePacket (packetDscr);
	}
	NdisFreeBufferPool (segment->PS_BufferPool);

	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING, 
	                ("IpxFwd: DeleteSegment pool:      %x\n", segment->PS_PacketPool));
	                
	NdisFreePacketPool (segment->PS_PacketPool);

	// [pmay] Remove this -- for debugging only
	segment->PS_PacketPool = NULL;

		// Decrement memory used if we have a quota
	if (MaxRcvPktsPoolSize!=0) {
		KIRQL			oldIRQL;
		ULONG			segmentsize = list->SL_BlockCount*list->SL_BlockSize
								+FIELD_OFFSET(PACKET_SEGMENT,PS_Buffers);
		KeAcquireSpinLock (&AllocatorLock, &oldIRQL);
		RcvPktsPoolSize -= segmentsize;
		KeReleaseSpinLock (&AllocatorLock, oldIRQL);
	}
	ExFreePool (segment);
	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING,
		("IpxFwd: Deleting segment %08lx in list %ld.\n",
		segment, list->SL_BlockSize));
}


/*++
*******************************************************************
    R e g i s t e r P a c k e t C o n s u m e r

Routine Description:
	Registers a consumer (bound interface) of packets of the
	given size
Arguments:
	pktsize - maximum size of packets needed
	listId - buffer to return packet list id where packets
			of required size are located
Return Value:
	STATUS_SUCCESS - registration succeded
	STATUS_INSUFFICIENT_RESOURCES - not enogh resources to register

*******************************************************************
--*/
NTSTATUS
RegisterPacketConsumer (
	IN ULONG	pktsize,
	OUT INT		*listID
	) {
	NTSTATUS		status=STATUS_SUCCESS;
	KIRQL			oldIRQL;
	PSEGMENT_LIST	list;
	INT				i;
	LONG			addRefCount = 1;

	KeAcquireSpinLock (&AllocatorLock, &oldIRQL);
	ASSERT (pktsize<=SegmentMap[FRAME_SIZE_VARIATIONS-1]
								[FRAME_SIZE_VARIATIONS-1]->SL_BlockSize);

	for (i=0; i<FRAME_SIZE_VARIATIONS; i++) {
		list = SegmentMap[i][i];
		if (pktsize<=list->SL_BlockSize) {
			list->SL_RefCount += 1;
			*listID = i;
			break;
		}
	}
	KeReleaseSpinLock (&AllocatorLock, oldIRQL);
	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING,
		("IpxFwd: Registered packet consumer, pktsz: %ld, list: %ld.\n",
		pktsize, list->SL_BlockSize));
	return status;
}

/*++
*******************************************************************
    D e r e g i s t e r P a c k e t C o n s u m e r

Routine Description:
	Deregisters a consumer (bound interface) of packets of the
	given size
Arguments:
	listId - packet list id used by the consumer
Return Value:
	None

*******************************************************************
--*/
VOID
DeregisterPacketConsumer (
	IN INT		listID
	) {
	KIRQL		oldIRQL;
	PSEGMENT_LIST	list;

	ASSERT ((listID>=0) && (listID<FRAME_SIZE_VARIATIONS));

	KeAcquireSpinLock (&AllocatorLock, &oldIRQL);
	list = SegmentMap[listID][listID];
	
	ASSERT (list->SL_RefCount>0);
	
	list->SL_RefCount -= 1;
	
	KeReleaseSpinLock (&AllocatorLock, oldIRQL);
	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING,
		("IpxFwd: Deregistered packet consumer, list: %ld.\n",
		list->SL_BlockSize));
	
	}
	
/*++
*******************************************************************
    I n i t i a l i z e S e g m e n t L i s t

Routine Description:
	Initializes list of packet segments
Arguments:
	list - list to initalize
Return Value:
	None

*******************************************************************
--*/
VOID
InitializeSegmentList(
	PSEGMENT_LIST	list
	) {
	InitializeListHead (&list->SL_Head);
	list->SL_FreeCount = 0;
		// Make sure we don't have any leftover larger than
		// the buffer size (kernel memory allocator
		// allocates full pages)
	list->SL_BlockCount = (ULONG)
				(ROUND_TO_PAGES (
						list->SL_BlockSize*RcvPktsPerSegment
						+FIELD_OFFSET(PACKET_SEGMENT,PS_Buffers))
					-FIELD_OFFSET(PACKET_SEGMENT,PS_Buffers))
				/list->SL_BlockSize;
	list->SL_LowCount = list->SL_BlockCount/2;
	list->SL_RefCount = 0;
	list->SL_AllocatorPending = FALSE;
	list->SL_TimerDpcPending = FALSE;
	KeInitializeSpinLock (&list->SL_Lock);
	KeInitializeTimer (&list->SL_Timer);
	KeInitializeDpc (&list->SL_TimerDpc, SegmentTimeoutDpc, list);
	ExInitializeWorkItem (&list->SL_Allocator, AllocationWorker, list);
}

/*++
*******************************************************************
    D e l e t e S e g m e n t L i s t

Routine Description:
	Deletes list of packet segments
Arguments:
	list - list to delete
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteSegmentList (
	PSEGMENT_LIST	list
	) {
	KeCancelTimer (&list->SL_Timer);
	while (!IsListEmpty (&list->SL_Head)) {
		PPACKET_SEGMENT segment;
		segment = CONTAINING_RECORD (list->SL_Head.Blink,
										PACKET_SEGMENT, PS_Link);

		RemoveEntryList (&segment->PS_Link);
		DeleteSegment (segment);
	}
}


/*++
*******************************************************************
    S e g m e n t T i m e o u t D p c

Routine Description:
	Timer DPC that launches allocator worker to get rid of unused
	segments
Arguments:
	Context - segment list to check for unused segments
Return Value:
	None

*******************************************************************
--*/
VOID
SegmentTimeoutDpc (
	PKDPC		dpc,
	PVOID		Context,
	PVOID		SystemArgument1,
	PVOID		SystemArgument2
	) {
#define list ((PSEGMENT_LIST)Context)
	KIRQL			oldIRQL;
	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_INFORMATION,
		("IpxFwd: Segment timed out in list: %ld.\n",
		list->SL_BlockSize));
	KeAcquireSpinLock (&list->SL_Lock, &oldIRQL);
	list->SL_TimerDpcPending = FALSE;
	if (!list->SL_AllocatorPending
			&& (list->SL_FreeCount>=list->SL_BlockCount)
			&& EnterForwarder ()) {
		list->SL_AllocatorPending = TRUE;
		KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
		ExQueueWorkItem (&list->SL_Allocator, DelayedWorkQueue);
	}
	else {
		KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
	}
	LeaveForwarder ();
#undef list
}


/*++
*******************************************************************
    A l l o c a t i o n W o r k e r

Routine Description:
	Adds new segment or releases unused segments from the list
	depending on the free packet count and time that segments
	are not used
Arguments:
	Context - packet list to process
Return Value:
	None

*******************************************************************
--*/
VOID
AllocationWorker (
	PVOID	Context
	) {
#define list ((PSEGMENT_LIST)Context)
	KIRQL			oldIRQL;
	PPACKET_SEGMENT segment = NULL;
	LONGLONG		curTime;

	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_INFORMATION,
		("IpxFwd: Allocating/scavenging segment(s) in list: %ld.\n",
		list->SL_BlockSize));
	KeQuerySystemTime ((PLARGE_INTEGER)&curTime);
	KeAcquireSpinLock (&list->SL_Lock, &oldIRQL);
	list->SL_AllocatorPending = FALSE;
	if (list->SL_FreeCount<list->SL_BlockCount) {
		KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
			// First allocate a segment
		segment = CreateSegment (list);
		if (segment!=NULL) {
			KeAcquireSpinLock (&list->SL_Lock, &oldIRQL);
			InsertTailList (&list->SL_Head, &segment->PS_Link);		
			list->SL_FreeCount += list->SL_BlockCount;
			if (!list->SL_TimerDpcPending
					&& EnterForwarder ()) {
				list->SL_TimerDpcPending = TRUE;
				KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
				KeSetTimer (&list->SL_Timer, *((PLARGE_INTEGER)&SegmentTimeout), &list->SL_TimerDpc);
			}
			else {
				KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
			}
		}
	}
	else {
			// Make sure that there is either more than segment in the list
			// or there is one and no registered users
		if (!IsListEmpty (&list->SL_Head)) {

		    // [pmay] Remove this -- for debugging purposes only.
		    //
            //{
            //    LIST_ENTRY * pEntry = &list->SL_Head;
            //    
            // 	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING,
            //		("IpxFwd: Scanning %x for possible segment deletion.\n",list));
            //
            //    while (pEntry->Flink != list->SL_Head.Flink) {
            //        segment = CONTAINING_RECORD (pEntry->Flink, PACKET_SEGMENT, PS_Link);
            //    	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING,
            //    		("IpxFwd: Segment:  %x\n",segment));
            //        pEntry = pEntry->Flink;
            //    }
            //}
            
			segment = CONTAINING_RECORD (list->SL_Head.Blink,
											PACKET_SEGMENT, PS_Link);
				// Check for all segments with no used blocks
				// except for the last one (delete event the last
				// one if there are no clients)
			while ((segment->PS_BusyCount==0)
					&& ((list->SL_Head.Flink!=&segment->PS_Link)
						|| (list->SL_RefCount<=0))) {
				LONGLONG	timeDiff;
					// Check if it has not been used for long enough
				timeDiff = SegmentTimeout - (segment->PS_FreeStamp-curTime);
				if (timeDiff>=0) {
						// Delete the segment
					RemoveEntryList (&segment->PS_Link);
					list->SL_FreeCount -= list->SL_BlockCount;
					KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
					DeleteSegment (segment);
					KeAcquireSpinLock (&list->SL_Lock, &oldIRQL);
					if (!IsListEmpty (&list->SL_Head)) {
						segment = CONTAINING_RECORD (list->SL_Head.Blink,
												PACKET_SEGMENT, PS_Link);
						continue;
					}
				}
				else { // Reschedule the timer otherwise
					if (!list->SL_TimerDpcPending
							&& EnterForwarder ()) {
						list->SL_TimerDpcPending = TRUE;
						KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
						KeSetTimer (&list->SL_Timer,
										*((PLARGE_INTEGER)&timeDiff),
										&list->SL_TimerDpc);
						goto ExitAllocator; // Spinlock is already released
					}
				}
			break;
			} // while
		} // if (IsListEmpty)
		KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
	}
ExitAllocator:
	LeaveForwarder ();
#undef list
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\precomp.h

Abstract:
    IPX Forwarder driver precompiled header file

Author:

    Vadim Eydelman

Revision History:

--*/

#define ISN_NT 1
#define NT 1

#if DBG
#define DEBUG 1
#endif

// System includes
#include <ntosp.h>
#include <tdikrnl.h>
#include <ndis.h>
#include <zwapi.h>
#include <limits.h>

// IPX shared includes
#include "bind.h"
#include "ipxfwd.h"
#include "ipxfltif.h"
#include "ipxfwtbl.h"

// Constants and macros
#include "fwddefs.h"
#include "rwlock.h"

// Internal module prototypes
#include "registry.h"
#include "packets.h"
#include "ipxbind.h"
#include "rcvind.h"
#include "send.h"
#include "netbios.h"
#include "lineind.h"
#include "ddreqs.h"
#include "driver.h"
#include "filterif.h"
#include "debug.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\registry.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\registry.h

Abstract:
    IPX Forwarder Driver registry interface


Author:

    Vadim Eydelman

Revision History:

--*/
#ifndef _IPXFWD_REGISTRY_
#define _IPXFWD_REGISTRY_

/*++
*******************************************************************
    R e a d I p x D e v i c e N a m e

Routine Description:
	Allocates buffer and reads device name exported by the IPX stack
	into it
Arguments:
	FileName - pointer to variable to hold the name buffer
Return Value:
	STATUS_SUCCESS - tables were created ok
	STATUS_INSUFFICIENT_RESOURCES - resource allocation failed
	STATUS_OBJECT_NAME_NOT_FOUND - if name value is not found
*******************************************************************
--*/
NTSTATUS
ReadIpxDeviceName (
	PWSTR		*FileName
	);

/*++
*******************************************************************
	G e t R o u t e r P a r a m e t e r s

Routine Description:
	Reads the parameters from the registry or sets the defaults
Arguments:
	RegistryPath - where to read from.
Return Value:
    STATUS_SUCCESS
*******************************************************************
--*/
NTSTATUS
GetForwarderParameters (
	IN PUNICODE_STRING RegistryPath
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\rcvind.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\rcvind.c

Abstract:
	Receive indication processing

Author:

    Vadim Eydelman

Revision History:

--*/
#include    "precomp.h"

#if DBG
VOID
DbgFilterReceivedPacket(PUCHAR	    hdrp);
#endif

// Doesn't allow accepting packets (for routing) from dial-in clients
BOOLEAN	ThisMachineOnly = FALSE;

/*++
*******************************************************************
    F w R e c e i v e

Routine Description:
	Called by the IPX stack to indicate that the IPX packet was
	received by the NIC dirver.  Only external destined packets are
	indicated by this routine (with the exception of Netbios boradcasts
	that indicated both for internal and external handlers)
Arguments:
	MacBindingHandle	- handle of NIC driver
	MaxReceiveContext	- NIC driver context
	RemoteAddress		- sender's address
	MacOptions			-
	LookaheadBuffer		- packet lookahead buffer that contains complete
							IPX header
	LookaheadBufferSize	- its size (at least 30 bytes)
	LookaheadBufferOffset - offset of lookahead buffer in the physical
							packet
Return Value:
    TRUE if we take the MDL chain to return later with NdisReturnPacket

*******************************************************************
--*/
BOOLEAN
IpxFwdReceive (
    NDIS_HANDLE			MacBindingHandle,
    NDIS_HANDLE			MacReceiveContext,
    ULONG_PTR			Context,
    PIPX_LOCAL_TARGET	RemoteAddress,
    ULONG				MacOptions,
    PUCHAR				LookaheadBuffer,
    UINT				LookaheadBufferSize,
    UINT				LookaheadBufferOffset,
    UINT				PacketSize,
    PMDL                pMdl) 
{
  PINTERFACE_CB	srcIf, dstIf;
  PPACKET_TAG	    pktTag;
  PNDIS_PACKET	pktDscr;
  NDIS_STATUS     status;
  UINT			BytesTransferred;
  LARGE_INTEGER	PerfCounter;

  // check that our configuration process has terminated OK
  if (!EnterForwarder ()) {
    return FALSE;
  }

  if (!MeasuringPerformance) {
    PerfCounter.QuadPart = 0;
  }
  else {
#if DBG
    static LONGLONG LastCall = 0;
    KIRQL	oldIRQL;
#endif
    PerfCounter = KeQueryPerformanceCounter (NULL);
#if DBG
    KeAcquireSpinLock (&PerfCounterLock, &oldIRQL);
    ASSERT (PerfCounter.QuadPart-LastCall<ActivityTreshhold);
    LastCall = PerfCounter.QuadPart;
    KeReleaseSpinLock (&PerfCounterLock, oldIRQL);
#endif
  }

  IpxFwdDbgPrint (DBG_RECV, DBG_INFORMATION,
		  ("IpxFwd: FwdReceive on %0lx,"
		   " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
		   Context, GETULONG (LookaheadBuffer+IPXH_DESTNET),
		   LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
		   LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
		   LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
		   LookaheadBuffer[IPXH_PKTTYPE]));

#if DBG
  DbgFilterReceivedPacket (LookaheadBuffer);
#endif
  srcIf = InterfaceContextToReference ((PVOID)Context, RemoteAddress->NicId);
  // Check if interface is valid
  if (srcIf!=NULL) {	
    USHORT			pktlen;
    ULONG			dstNet;
    KIRQL			oldIRQL;

    dstNet = GETULONG (LookaheadBuffer + IPXH_DESTNET);
    pktlen = GETUSHORT(LookaheadBuffer + IPXH_LENGTH);

    // check if we got the whole IPX header in the lookahead buffer
    if ((LookaheadBufferSize >= IPXH_HDRSIZE)
	&& (*(LookaheadBuffer + IPXH_XPORTCTL) < 16)
	&& (pktlen<=PacketSize)) {
      // Lock interface CB to ensure coherency of information in it
      KeAcquireSpinLock(&srcIf->ICB_Lock, &oldIRQL);
      // Check if shoud accept packets on this interface
      if (IS_IF_ENABLED(srcIf)
	  && (srcIf->ICB_Stats.OperationalState!=FWD_OPER_STATE_DOWN)
	  && (!ThisMachineOnly
	      || (srcIf->ICB_InterfaceType
		  !=FWD_IF_REMOTE_WORKSTATION))) {
	// Check for looped back packets
	if (IPX_NODE_CMP (RemoteAddress->MacAddress,
			  srcIf->ICB_LocalNode)!=0) {

	  // Separate processing of netbios broadcast packets (20)
	  if (*(LookaheadBuffer + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE) {
	    PFWD_ROUTE		dstRoute;
	    INT				srcListId, dstListId;
	    // Temp IPX bug fix, they shou;d ensure that
	    // we only get packets that can be routed
	    if ((dstNet==srcIf->ICB_Network)
		|| (dstNet==InternalInterface->ICB_Network)) {
	      InterlockedIncrement (&srcIf->ICB_Stats.InDiscards);
	      KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);
	      ReleaseInterfaceReference (srcIf);
	      LeaveForwarder ();
	      return FALSE;
	    }
	    //						ASSERT (dstNet!=srcIf->ICB_Network);
	    //						ASSERT ((InternalInterface==NULL)
	    //									|| (InternalInterface->ICB_Network==0)
	    //									|| (dstNet!=InternalInterface->ICB_Network));
	    // Check if needed route is in cash
	    if ((srcIf->ICB_CashedRoute!=NULL)
		&& (dstNet==srcIf->ICB_CashedRoute->FR_Network)
		// If route was changed or deleted, this will fail
		&& (srcIf->ICB_CashedRoute->FR_InterfaceReference
		    ==srcIf->ICB_CashedInterface)) {
	      dstIf = srcIf->ICB_CashedInterface;
	      dstRoute = srcIf->ICB_CashedRoute;
	      AcquireInterfaceReference (dstIf);
	      AcquireRouteReference (dstRoute);
	      IpxFwdDbgPrint (DBG_RECV, DBG_INFORMATION,
			      ("IpxFwd: Destination in cash.\n"));
	    }
	    else {	// Find and cash the route
	      dstIf = FindDestination (dstNet,
				       LookaheadBuffer+IPXH_DESTNODE,
				       &dstRoute
				       );

	      if (dstIf!=NULL) { // If route is found
		IpxFwdDbgPrint (DBG_RECV, DBG_INFORMATION,
				("IpxFwd: Found destination %0lx.\n", dstIf));
		// Don't cash global wan clients and
		// routes to the same net
		if ((dstNet!=GlobalNetwork)
		    && (dstIf!=srcIf)) {
		  if (srcIf->ICB_CashedInterface!=NULL)
		    ReleaseInterfaceReference (srcIf->ICB_CashedInterface);
		  if (srcIf->ICB_CashedRoute!=NULL)
		    ReleaseRouteReference (srcIf->ICB_CashedRoute);
		  srcIf->ICB_CashedInterface = dstIf;
		  srcIf->ICB_CashedRoute = dstRoute;
		  AcquireInterfaceReference (dstIf);
		  AcquireRouteReference (dstRoute);
		}
	      }
	      else { // No route
		InterlockedIncrement (&srcIf->ICB_Stats.InNoRoutes);
		KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);
		IpxFwdDbgPrint (DBG_RECV, DBG_WARNING,
				("IpxFwd: No route for packet on interface %ld (icb:%0lx),"
				 " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
				 srcIf->ICB_Index, srcIf, dstNet,
				 LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
				 LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
				 LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
				 LookaheadBuffer[IPXH_PKTTYPE]));
		ReleaseInterfaceReference (srcIf);
		LeaveForwarder ();
		return FALSE;
	      }
	    }
	    srcListId = srcIf->ICB_PacketListId;
	    KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);

	    // Check if destination if can take the packet
	    if (IS_IF_ENABLED (dstIf)
		// If interface is UP check packet againts actual size limit
		&& (((dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_UP)
		     && (PacketSize<=dstIf->ICB_Stats.MaxPacketSize))
		    // if sleeping (WAN), check we can allocate it from WAN list
		    || ((dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_SLEEPING)
			&& (PacketSize<=WAN_PACKET_SIZE))
		    // otherwise, interface is down and we can't take the packet
		    ) ){
	      FILTER_ACTION   action;
	      action = FltFilter (LookaheadBuffer, LookaheadBufferSize,
				  srcIf->ICB_FilterInContext,
				  dstIf->ICB_FilterOutContext);
	      if (action==FILTER_PERMIT) {
		InterlockedIncrement (&srcIf->ICB_Stats.InDelivers);
		dstListId = dstIf->ICB_PacketListId;
		// try to get a packet from the rcv pkt pool
		AllocatePacket (srcListId, dstListId, pktTag);
		if (pktTag!=NULL) {
		  // Set destination mac in local target if
		  // possible
		  KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
		  if (dstIf->ICB_InterfaceType==FWD_IF_PERMANENT) {
		    // Permanent interface: send to the next
		    // hop router if net is not directly connected
		    // or to the dest node otherwise
		    if (dstNet!=dstIf->ICB_Network) {
		      IPX_NODE_CPY (pktTag->PT_Target.MacAddress,
				    dstRoute->FR_NextHopAddress);
		    }
		    else {
		      IPX_NODE_CPY (pktTag->PT_Target.MacAddress,
				    LookaheadBuffer+IPXH_DESTNODE);
		    }
		  }
		  else {	// Demand dial interface: assumed to be
		    // point to point connection -> send to
		    // the other party if connection has already
		    // been made, otherwise wait till connected
		    if (dstIf->ICB_Stats.OperationalState
			== FWD_OPER_STATE_UP) {
		      IPX_NODE_CPY (pktTag->PT_Target.MacAddress,
				    dstIf->ICB_RemoteNode);
		    }	// Copy source mac address and nic id in case
		    // we need to spoof this packet
		    else if ((*(LookaheadBuffer+IPXH_PKTTYPE)==0)
			     && (pktlen==IPXH_HDRSIZE+2)
			     && ((LookaheadBufferSize<IPXH_HDRSIZE+2)
				 ||(*(LookaheadBuffer+IPXH_HDRSIZE+1)=='?'))) {
		      IPX_NODE_CPY (pktTag->PT_Target.MacAddress,
				    RemoteAddress->MacAddress);
		      pktTag->PT_SourceIf = srcIf;
		      AcquireInterfaceReference (srcIf);
		      pktTag->PT_Flags |= PT_SOURCE_IF;
		    }

		  }
		  KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
		  ReleaseRouteReference (dstRoute);
		  goto GetPacket;
		}
		else { // Allocation failure
		  InterlockedIncrement (&dstIf->ICB_Stats.OutDiscards);
		}
	      }
	      else {// Filtered out
		if (action==FILTER_DENY_OUT)
		  InterlockedIncrement (&dstIf->ICB_Stats.OutFiltered);
		else {
		  ASSERT (action==FILTER_DENY_IN);
		  InterlockedIncrement (&srcIf->ICB_Stats.InFiltered);
		}
		IpxFwdDbgPrint (DBG_RECV, DBG_WARNING,
				("IpxFwd: Filtered out"
				 " packet on interface %ld (icb:%0lx),"
				 " dst-%ld (icb %08lx) %08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
				 srcIf->ICB_Index, srcIf, dstIf->ICB_Index, dstIf, dstNet,
				 LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
				 LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
				 LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
				 LookaheadBuffer[IPXH_PKTTYPE]));
	      }
	    }
	    else {	// Destination interface is down
	      InterlockedIncrement (&srcIf->ICB_Stats.InDelivers);
	      InterlockedIncrement (&dstIf->ICB_Stats.OutDiscards);
	      IpxFwdDbgPrint (DBG_RECV, DBG_WARNING,
			      ("IpxFwd: Dest interface %ld (icb %08lx) down"
			       " for packet on interface %ld (icb:%0lx),"
			       " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
			       dstIf->ICB_Index, dstIf, srcIf->ICB_Index, srcIf, dstNet,
			       LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
			       LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
			       LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
			       LookaheadBuffer[IPXH_PKTTYPE]));
	    }
	    ReleaseInterfaceReference (dstIf);
	    ReleaseRouteReference (dstRoute);
	  }
	  else {	// if netbios
	    // check that this is a netbios bcast packet and
	    // didnt exceed the limit of routers to traverse
	    // and we can accept it on this interface
	    if (srcIf->ICB_NetbiosAccept
		&& (*(LookaheadBuffer + IPXH_XPORTCTL) < 8)) {
	      INT				srcListId;
	      srcListId = srcIf->ICB_PacketListId;
	      KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);
	      // Check if packet is valid
	      if (IPX_NODE_CMP (LookaheadBuffer + IPXH_DESTNODE,
				BROADCAST_NODE)==0) {
		// Check if we haven't exceeded the quota
		if (InterlockedDecrement (&NetbiosPacketsQuota)>=0) {
		  // try to get a packet from the rcv pkt pool
		  AllocatePacket (srcListId, srcListId, pktTag);
		  if (pktTag!=NULL) {
		    dstIf = srcIf;
		    AcquireInterfaceReference (dstIf);
		    goto GetPacket;
		  }
		}
		else {// Netbios quota exceded
		  IpxFwdDbgPrint (DBG_NETBIOS, DBG_WARNING,
				  ("IpxFwd: Netbios quota exceded"
				   " for packet on interface %ld (icb:%0lx),"
				   " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
				   srcIf->ICB_Index, srcIf, dstNet,
				   LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
				   LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
				   LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
				   LookaheadBuffer[IPXH_PKTTYPE]));
		  InterlockedIncrement (&srcIf->ICB_Stats.InDiscards);
		}
		InterlockedIncrement (&NetbiosPacketsQuota);
	      }
	      else {	// Bad netbios packet
		IpxFwdDbgPrint (DBG_NETBIOS, DBG_WARNING,
				("IpxFwd: Bad nb packet on interface %ld (icb:%0lx),"
				 " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
				 srcIf->ICB_Index, srcIf, dstNet,
				 LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
				 LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
				 LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
				 LookaheadBuffer[IPXH_PKTTYPE]));
		InterlockedIncrement (&srcIf->ICB_Stats.InHdrErrors);
	      }
	    }
	    else { // Netbios accept disabled or to many routers crossed
	      KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);
	      InterlockedIncrement (&srcIf->ICB_Stats.InDiscards);
	      IpxFwdDbgPrint (DBG_NETBIOS, DBG_WARNING,
			      ("IpxFwd: NB packet dropped on disabled interface %ld (icb:%0lx),"
			       " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
			       srcIf->ICB_Index, srcIf, dstNet,
			       LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
			       LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
			       LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
			       LookaheadBuffer[IPXH_PKTTYPE]));
	    }
	  }	// End netbios specific processing (else if netbios)
	}
	else {	// Looped back packets discarded without counting
	  // (We shouldn't get them in IPX stack does the right job)
	  KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);
	}
      }
      else {	// Interface is down or disabled
	KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);
	InterlockedIncrement (&srcIf->ICB_Stats.InDiscards);
	IpxFwdDbgPrint (DBG_RECV, DBG_WARNING,
			("IpxFwd: Packet dropped on disabled interface %ld (icb:%0lx),"
			 " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
			 srcIf->ICB_Index, srcIf, dstNet,
			 LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
			 LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
			 LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
			 LookaheadBuffer[IPXH_PKTTYPE]));
      }
    }
    else {	// Obvious header errors (shouldn't IPX do this for us ?
      InterlockedIncrement (&srcIf->ICB_Stats.InHdrErrors);
      IpxFwdDbgPrint (DBG_RECV, DBG_ERROR,
		      ("IpxFwd: Header errors in packet on interface %ld (icb:%0lx),"
		       " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
		       srcIf->ICB_Index, srcIf, dstNet,
		       LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
		       LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
		       LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
		       LookaheadBuffer[IPXH_PKTTYPE]));
    }
    ReleaseInterfaceReference (srcIf);
  }	// We could not locate the interface from IPX supplied context: there
  // is just a little time window when interface is deleted
  // but IPX had already pushed the context on the stack
  else {
    IpxFwdDbgPrint (DBG_RECV, DBG_ERROR,
		    ("IpxFwd: Receive, type-%02x"
		     " - src interface context is invalid.\n",
		     LookaheadBuffer[IPXH_PKTTYPE]));
  }
  LeaveForwarder ();
  return FALSE ;

	       GetPacket:
	
  InterlockedIncrement (&srcIf->ICB_Stats.InDelivers);
  ReleaseInterfaceReference (srcIf);

  pktDscr = CONTAINING_RECORD (pktTag, NDIS_PACKET, ProtocolReserved);
  pktTag->PT_InterfaceReference = dstIf;
  pktTag->PT_PerfCounter = PerfCounter.QuadPart;

  // try to get the packet data
  IPXTransferData(&status,
		  MacBindingHandle,
		  MacReceiveContext,
		  LookaheadBufferOffset,   // start of IPX header
		  PacketSize, 	     // packet size starting at IPX header
		  pktDscr,
		  &BytesTransferred);

  if (status != NDIS_STATUS_PENDING) {
    // complete the frame processing (LeaveForwarder will be called there)
    IpxFwdTransferDataComplete(pktDscr, status, BytesTransferred);
  }
  return FALSE;
}


/*++
*******************************************************************
    F w T r a n s f e r D a t a C o m p l e t e

Routine Description:
	Called by the IPX stack when NIC driver completes data transger.
Arguments:
	pktDscr				- handle of NIC driver
	status				- result of the transfer
	bytesTransferred	- number of bytest trasferred
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdTransferDataComplete (
    PNDIS_PACKET	pktDscr,
	NDIS_STATUS		status,
	UINT			bytesTransferred) 
{
    PPACKET_TAG		pktTag;

    pktTag = (PPACKET_TAG)(&pktDscr->ProtocolReserved);

    // If transfer failed, release the packet and interface
    //
    if (status==NDIS_STATUS_SUCCESS) 
    {
        if (*(pktTag->PT_Data + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE)
        {
            // pmay: 260480
            // 
            // Increment the transport control field so that
            // the number of routers that this packet has
            // traversed is increased.  IpxFwdReceive will drop
            // all packets that have traversed more that 15 routers.
            //
            // Netbios packets will have their transport control
            // fields incremented by ProcessNetbiosPacket
            //
            *(pktTag->PT_Data + IPXH_XPORTCTL) += 1;
            
            SendPacket (pktTag->PT_InterfaceReference, pktTag);
        }
        else
        {
            ProcessNetbiosPacket (pktTag->PT_InterfaceReference, pktTag);
        }
    }
    else 
    {
        IpxFwdDbgPrint (DBG_RECV, DBG_ERROR,
            ("IpxFwd: Trans data failed: packet %08lx on if %08lx!\n",
            pktTag, pktTag->PT_InterfaceReference));

        // Record the fact that we're discarding
        //
        if (*(pktTag->PT_Data + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE) 
        {
            InterlockedIncrement (
            &pktTag->PT_InterfaceReference->ICB_Stats.OutDiscards);
        }

        // For netbios packets interface reference is
        // actually a source interface
        else 
        {	
            InterlockedIncrement (&NetbiosPacketsQuota);
            InterlockedIncrement (
                &pktTag->PT_InterfaceReference->ICB_Stats.InDiscards);
        }

        ReleaseInterfaceReference (pktTag->PT_InterfaceReference);
        FreePacket (pktTag);
    }

    LeaveForwarder ();
    return;
}


/*++
*******************************************************************
    F w R e c e i v e C o m p l e t e

Routine Description:

		This routine receives control from the IPX driver after one or
		more receive operations have completed and no receive is in progress.
		It is called under less severe time constraints than IpxFwdReceive.
		It is used to process netbios queue

Arguments:
	None
Return Value:
	None
*******************************************************************
--*/
VOID
IpxFwdReceiveComplete (
		       USHORT NicId
		       ) {

  // check that our configuration process has terminated OK
  if(!EnterForwarder ()) {
    return;
  }
  IpxFwdDbgPrint (DBG_RECV, DBG_INFORMATION, ("IpxFwd: FwdReceiveComplete.\n"));
  ScheduleNetbiosWorker ();
  LeaveForwarder ();
}

/*++
*******************************************************************
    I p x F w d I n t e r n a l R e c e i v e

Routine Description:
	Called by the IPX stack to indicate that the IPX packet destined
	to local client was received by the NIC dirver.
Arguments:
	Context				- forwarder context associated with
							the NIC (interface block pointer)
	RemoteAddress		- sender's address
	LookaheadBuffer		- packet lookahead buffer that contains complete
							IPX header
	LookaheadBufferSize	- its size (at least 30 bytes)
Return Value:
	STATUS_SUCCESS - the packet will be delivered to local destination
	STATUS_UNSUCCESSFUL - the packet will be dropped

*******************************************************************
--*/
NTSTATUS
IpxFwdInternalReceive (
		       IN ULONG_PTR				Context,
		       IN PIPX_LOCAL_TARGET	RemoteAddress,
		       IN PUCHAR				LookAheadBuffer,
		       IN UINT					LookAheadBufferSize
		       ) {
  NTSTATUS	status = STATUS_SUCCESS;
  PINTERFACE_CB	srcIf;

  if (!EnterForwarder ()) {
    return STATUS_UNSUCCESSFUL;
  }
  if (Context!=VIRTUAL_NET_FORWARDER_CONTEXT)	 {
    // Check if interface context supplied by IPX driver is valid
    srcIf = InterfaceContextToReference ((PVOID)Context, RemoteAddress->NicId);
  }
  else {
    srcIf = InternalInterface;
    AcquireInterfaceReference (srcIf);
  }

  if (srcIf!=NULL) {
    // Check if we can accept on this interface
    if (IS_IF_ENABLED (srcIf)
	&& (srcIf->ICB_Stats.OperationalState!=FWD_OPER_STATE_DOWN)
	&& ((*(LookAheadBuffer + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE)
	    || srcIf->ICB_NetbiosAccept)) {
      // Check if we can accept on internal interface
      if (IS_IF_ENABLED(InternalInterface)) {
	FILTER_ACTION   action;
	action = FltFilter (LookAheadBuffer, LookAheadBufferSize,
			    srcIf->ICB_FilterInContext,
			    InternalInterface->ICB_FilterOutContext);
	// Check the filter
	if (action==FILTER_PERMIT) {
	  // Update source interface statistics
	  InterlockedIncrement (&srcIf->ICB_Stats.InDelivers);
	  // Handle NB packets separatedly
	  if (*(LookAheadBuffer + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE) {
	    InterlockedIncrement (
				  &InternalInterface->ICB_Stats.OutDelivers);
	    IpxFwdDbgPrint (DBG_INT_RECV, DBG_INFORMATION,
			    ("IpxFwd: FwdInternalReceive,"
			     " from %d(%lx)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x,"
			     " type-%02x.\n",
			     srcIf->ICB_Index, srcIf,
			     LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
			     LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
			     LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
			     LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
			     LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5],
			     LookAheadBuffer[IPXH_PKTTYPE]));
	  }
	  else {
	    // Check if destination netbios name is staticly assigned to
	    // an external interface or netbios delivery options do not
	    // allow us to deliver this packet
	    PINTERFACE_CB	dstIf;
	    USHORT			dstSock = GETUSHORT (LookAheadBuffer+IPXH_DESTSOCK);

	    InterlockedIncrement (&srcIf->ICB_Stats.NetbiosReceived);
	    // First try to find a static name if we have enough data
	    // in the lookahead buffer
	    if ((dstSock==IPX_NETBIOS_SOCKET)
		&& (LookAheadBufferSize>(NB_NAME+16)))
	      dstIf = FindNBDestination (LookAheadBuffer+(NB_NAME-IPXH_HDRSIZE));
	    else if ((dstSock==IPX_SMB_NAME_SOCKET)
		     && (LookAheadBufferSize>(SMB_NAME+16)))
	      dstIf = FindNBDestination (LookAheadBuffer+(SMB_NAME-IPXH_HDRSIZE));
	    else
	      dstIf = NULL;
	    // Now see, if we can deliver the packet
	    if ((((dstIf==NULL) || (dstIf==InternalInterface))
		 && (InternalInterface->ICB_NetbiosDeliver==FWD_NB_DELIVER_ALL))
		|| ((dstIf==InternalInterface)
		    && (InternalInterface->ICB_NetbiosDeliver==FWD_NB_DELIVER_STATIC))) {
	      InterlockedIncrement (
				    &InternalInterface->ICB_Stats.NetbiosSent);
	      InterlockedIncrement (
				    &InternalInterface->ICB_Stats.OutDelivers);
	      IpxFwdDbgPrint (DBG_INT_RECV, DBG_INFORMATION,
			      ("IpxFwd: FwdInternalReceive, NB"
			       " from %d(%lx)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x\n",
			       srcIf->ICB_Index, srcIf,
			       LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
			       LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
			       LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
			       LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
			       LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5]));
	    }
	    else {
	      InterlockedIncrement (
				    &InternalInterface->ICB_Stats.OutDiscards);
	      IpxFwdDbgPrint (DBG_INT_RECV, DBG_WARNING,
			      ("IpxFwd: FwdInternalReceive, NB dropped because delivery disabled"
			       " from %d(%lx)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x\n",
			       srcIf->ICB_Index, srcIf,
			       LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
			       LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
			       LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
			       LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
			       LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5]));
	      status = STATUS_UNSUCCESSFUL;
	    }
	    if (dstIf!=NULL)
	      ReleaseInterfaceReference (dstIf);
	  }
	}
	else {// Filtered Out
	  if (action==FILTER_DENY_OUT) {
	    InterlockedIncrement (
				  &InternalInterface->ICB_Stats.OutFiltered);
	    status=STATUS_UNSUCCESSFUL;
	  }
	  else {
	    ASSERT (action==FILTER_DENY_IN);
	    InterlockedIncrement (&srcIf->ICB_Stats.InFiltered);
	    status=STATUS_UNSUCCESSFUL;
	  }
	  IpxFwdDbgPrint (DBG_INT_RECV, DBG_WARNING,
			  ("IpxFwd: FwdInternalReceive, filtered out"
			   " from %d(%lx)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x,"
			   " type-%02x.\n",
			   srcIf->ICB_Index, srcIf,
			   LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
			   LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
			   LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
			   LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
			   LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5],
			   LookAheadBuffer[IPXH_PKTTYPE]));
	}
      }
      else {// Internal interface is disabled
	InterlockedIncrement (
			      &InternalInterface->ICB_Stats.OutDiscards);
	status = STATUS_UNSUCCESSFUL;
	IpxFwdDbgPrint (DBG_INT_RECV, DBG_WARNING,
			("IpxFwd: FwdInternalReceive, internal if disabled"
			 " from %d(%lx)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x,"
			 " type-%02x.\n",
			 srcIf->ICB_Index, srcIf,
			 LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
			 LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
			 LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
			 LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
			 LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5],
			 LookAheadBuffer[IPXH_PKTTYPE]));
      }
    }
    else {	// Disabled source interface
      InterlockedIncrement (&srcIf->ICB_Stats.InDiscards);
      IpxFwdDbgPrint (DBG_INT_RECV, DBG_ERROR,
		      ("IpxFwd: FwdInternalReceive, source if disabled"
		       " from %d(%lx)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x,"
		       " type-%02x.\n",
		       srcIf->ICB_Index, srcIf,
		       LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
		       LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
		       LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
		       LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
		       LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5],
		       LookAheadBuffer[IPXH_PKTTYPE]));
      status = STATUS_UNSUCCESSFUL;
    }
    ReleaseInterfaceReference (srcIf);
  }
  else {	// Invalid source interface context
    IpxFwdDbgPrint (DBG_INT_RECV, DBG_ERROR,
		    ("IpxFwd: FwdInternalReceive, source if context is invalid"
		     " from (%lx:%d)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x,"
		     " type-%02x.\n",
		     Context, RemoteAddress->NicId,
		     LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
		     LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
		     LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
		     LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
		     LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5],
		     LookAheadBuffer[IPXH_PKTTYPE]));
    status = STATUS_UNSUCCESSFUL;
  }
  LeaveForwarder ();
  return status;
}

/*++
*******************************************************************
    D e l e t e R e c v Q u e u e

Routine Description:
	Initializes the netbios bradcast queue
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteRecvQueue (
		 void
		 ) {
  //	while (!IsListEmpty (&RecvQueue)) {
  //		PPACKET_TAG pktTag = CONTAINING_RECORD (RecvQueue.Flink,
  //											PACKET_TAG,
  //											PT_QueueLink);
  //		RemoveEntryList (&pktTag->PT_QueueLink);
  //		if (pktTag->PT_InterfaceReference!=NULL) {
  //			ReleaseInterfaceReference (pktTag->PT_InterfaceReference);
  //		}
  //		FreePacket (pktTag);
  //	}
}
#if DBG

ULONG	  DbgFilterTrap = 0;  // 1 - on dst and src (net + node),
// 2 - on dst (net + node),
// 3 - on src (net + node),
// 4 - on dst (net + node + socket)

UCHAR	  DbgFilterDstNet[4];
UCHAR	  DbgFilterDstNode[6];
UCHAR	  DbgFilterDstSocket[2];
UCHAR	  DbgFilterSrcNet[4];
UCHAR	  DbgFilterSrcNode[6];
UCHAR	  DbgFilterSrcSocket[2];
PUCHAR	  DbgFilterFrame;

VOID
DbgFilterReceivedPacket(PUCHAR	    hdrp)
{
  switch(DbgFilterTrap) {

  case 1:

    if(!memcmp(hdrp + IPXH_DESTNET, DbgFilterDstNet, 4) &&
       !memcmp(hdrp + IPXH_DESTNODE, DbgFilterDstNode, 6) &&
       !memcmp(hdrp + IPXH_SRCNET, DbgFilterSrcNet, 4) &&
       !memcmp(hdrp + IPXH_SRCNODE, DbgFilterSrcNode, 6)) {

      DbgBreakPoint();
    }

    break;

  case 2:

    if(!memcmp(hdrp + IPXH_DESTNET, DbgFilterDstNet, 4) &&
       !memcmp(hdrp + IPXH_DESTNODE, DbgFilterDstNode, 6)) {

      DbgBreakPoint();
    }

    break;

  case 3:

    if(!memcmp(hdrp + IPXH_SRCNET, DbgFilterSrcNet, 4) &&
       !memcmp(hdrp + IPXH_SRCNODE, DbgFilterSrcNode, 6)) {

      DbgBreakPoint();
    }

    break;

  case 4:

    if(!memcmp(hdrp + IPXH_DESTNET, DbgFilterDstNet, 4) &&
       !memcmp(hdrp + IPXH_DESTNODE, DbgFilterDstNode, 6) &&
       !memcmp(hdrp + IPXH_DESTSOCK, DbgFilterDstSocket, 2)) {

      DbgBreakPoint();
    }

    break;

  default:

    break;
  }

  DbgFilterFrame = hdrp;
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\registry.c ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	registry.c
//
// Description: routines for reading the registry configuration
//
// Author:	Stefan Solomon (stefans)    November 9, 1993.
//
// Revision History:
//		Updated to read parameters of new forwarder driver (11/95)
//
//***

#include    "precomp.h"

NTSTATUS
SetIpxDeviceName(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

/*++
*******************************************************************
    R e a d I p x D e v i c e N a m e

Routine Description:
	Allocates buffer and reads device name exported by the IPX stack
	into it
Arguments:
	FileName - pointer to buffer to hold the name
Return Value:
	STATUS_SUCCESS - tables were created ok
	STATUS_INSUFFICIENT_RESOURCES - resource allocation failed
	STATUS_OBJECT_NAME_NOT_FOUND - if name value is not found
*******************************************************************
--*/
NTSTATUS
ReadIpxDeviceName (
	PWSTR		*FileName
	) {
    NTSTATUS Status;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWSTR Export = L"Export";
    PWSTR IpxRegistryPath = L"NwLnkIpx\\Linkage";

    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Call SetIpxDeviceName for the string in "Export"
    //

    QueryTable[0].QueryRoutine = SetIpxDeviceName;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = Export;
    QueryTable[0].EntryContext = FileName;
    QueryTable[0].DefaultType = 0;

    //
    // 2) Stop
    //

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    Status = RtlQueryRegistryValues(
		 RTL_REGISTRY_SERVICES,
		 IpxRegistryPath,
         QueryTable,
		 NULL,
         NULL);

    return Status;
}


/*++
*******************************************************************
	S e t I p x D e v i c e N a m e

Routine Description:
    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each piece of the "Export" multi-string and
    saves the information in a ConfigurationInfo structure.
Arguments:
    ValueName - The name of the value ("Export" -- ignored).
    ValueType - The type of the value (REG_SZ -- ignored).
    ValueData - The null-terminated data for the value.
    ValueLength - The length of ValueData.
    Context - NULL.
    EntryContext - file name pointer.
Return Value:
    STATUS_SUCCESS - name was allocated and copied OK
	STATUS_INSUFFICIENT_RESOURCES - name allocation failed
*******************************************************************
--*/
NTSTATUS
SetIpxDeviceName(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    ) {
	PWSTR	*FileName = (PWSTR *)EntryContext;

	ASSERT (ValueType==REG_SZ);
    *FileName = (PWSTR)ExAllocatePoolWithTag(NonPagedPool,
								ValueLength, FWD_POOL_TAG);
    if (*FileName != NULL) {
		RtlCopyMemory (*FileName, ValueData, ValueLength);
	    return STATUS_SUCCESS;
	}
	else
		return STATUS_INSUFFICIENT_RESOURCES;

}

/*++
*******************************************************************
	G e t R o u t e r P a r a m e t e r s

Routine Description:
	Reads the parameters from the registry or sets the defaults
Arguments:
	RegistryPath - where to read from.
Return Value:
    STATUS_SUCCESS
*******************************************************************
--*/
NTSTATUS
GetForwarderParameters (
	IN PUNICODE_STRING RegistryPath
	) {
    NTSTATUS Status;
    PWSTR RegistryPathBuffer;
    PWSTR Parameters = L"Parameters";
    RTL_QUERY_REGISTRY_TABLE	paramTable[11]; // table size = nr of params + 1

    RegistryPathBuffer = (PWSTR)ExAllocatePoolWithTag(NonPagedPool, RegistryPath->Length + sizeof(WCHAR), 'gRwN');

    if (RegistryPathBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory (RegistryPathBuffer, RegistryPath->Buffer, RegistryPath->Length);
    *(PWCHAR)(((PUCHAR)RegistryPathBuffer)+RegistryPath->Length) = (WCHAR)'\0';

    RtlZeroMemory(&paramTable[0], sizeof(paramTable));

    paramTable[0].QueryRoutine = NULL;
    paramTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    paramTable[0].Name = Parameters;

    paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name = L"MaxRcvPktPoolSize";
    paramTable[1].EntryContext = &MaxRcvPktsPoolSize;
    paramTable[1].DefaultType = REG_DWORD;
    paramTable[1].DefaultData = &MaxRcvPktsPoolSize;
    paramTable[1].DefaultLength = sizeof(ULONG);
        
    paramTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[2].Name = L"RcvPktsPerSegment";
    paramTable[2].EntryContext = &RcvPktsPerSegment;
    paramTable[2].DefaultType = REG_DWORD;
    paramTable[2].DefaultData = &RcvPktsPerSegment;
    paramTable[2].DefaultLength = sizeof(ULONG);

    paramTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[3].Name = L"RouteTableSegmentSize";
    paramTable[3].EntryContext = &RouteSegmentSize;
    paramTable[3].DefaultType = REG_DWORD;
    paramTable[3].DefaultData = &RouteSegmentSize;
    paramTable[3].DefaultLength = sizeof(ULONG);

    paramTable[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[4].Name = L"MaxSendPktsQueued";
    paramTable[4].EntryContext = &MaxSendPktsQueued;
    paramTable[4].DefaultType = REG_DWORD;
    paramTable[4].DefaultData = &MaxSendPktsQueued;
    paramTable[4].DefaultLength = sizeof(ULONG);

    paramTable[5].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[5].Name = L"ClientHashSize";
    paramTable[5].EntryContext = &ClientHashSize;
    paramTable[5].DefaultType = REG_DWORD;
    paramTable[5].DefaultData = &ClientHashSize;
    paramTable[5].DefaultLength = sizeof(ULONG);

    paramTable[6].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[6].Name = L"InterfaceHashSize";
    paramTable[6].EntryContext = &InterfaceHashSize;
    paramTable[6].DefaultType = REG_DWORD;
    paramTable[6].DefaultData = &InterfaceHashSize;
    paramTable[6].DefaultLength = sizeof(ULONG);

    paramTable[7].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[7].Name = L"MaxNetbiosPacketsQueued";
    paramTable[7].EntryContext = &MaxNetbiosPacketsQueued;
    paramTable[7].DefaultType = REG_DWORD;
    paramTable[7].DefaultData = &MaxNetbiosPacketsQueued;
    paramTable[7].DefaultLength = sizeof(ULONG);

    paramTable[8].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[8].Name = L"SpoofingTimeout";
    paramTable[8].EntryContext = &SpoofingTimeout;
    paramTable[8].DefaultType = REG_DWORD;
    paramTable[8].DefaultData = &SpoofingTimeout;
    paramTable[8].DefaultLength = sizeof(ULONG);

    paramTable[9].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[9].Name = L"DontSuppressNonAgentSapAdvertisements";
    paramTable[9].EntryContext = &DontSuppressNonAgentSapAdvertisements;
    paramTable[9].DefaultType = REG_DWORD;
    paramTable[9].DefaultData = &DontSuppressNonAgentSapAdvertisements;
    paramTable[9].DefaultLength = sizeof(ULONG);

    Status = RtlQueryRegistryValues(
		 RTL_REGISTRY_ABSOLUTE,
		 RegistryPathBuffer,
		 paramTable,
		 NULL,
		 NULL);

    if(!NT_SUCCESS(Status)) {

	IpxFwdDbgPrint (DBG_REGISTRY, DBG_WARNING,
		("IpxFwd: Missing Parameters key in the registry\n"));
    }

    ExFreePool(RegistryPathBuffer);

    if ((RcvPktsPerSegment > MAX_RCV_PKTS_PER_SEGMENT) ||
			(RcvPktsPerSegment < MIN_RCV_PKTS_PER_SEGMENT)) {

       RcvPktsPerSegment = DEF_RCV_PKTS_PER_SEGMENT;
    }

    if ((RouteSegmentSize > MAX_ROUTE_SEGMENT_SIZE) ||
			(RouteSegmentSize < MIN_ROUTE_SEGMENT_SIZE)) {

       RouteSegmentSize = DEF_ROUTE_SEGMENT_SIZE;
    }
	else
		RouteSegmentSize = (ULONG) ROUND_TO_PAGES(RouteSegmentSize);

    if ((InterfaceHashSize > MAX_INTERFACE_HASH_SIZE) ||
			(InterfaceHashSize < MIN_INTERFACE_HASH_SIZE)) {

       InterfaceHashSize = DEF_INTERFACE_HASH_SIZE;
    }

    if ((ClientHashSize > MAX_CLIENT_HASH_SIZE) ||
			(ClientHashSize < MIN_CLIENT_HASH_SIZE)) {

       ClientHashSize = DEF_CLIENT_HASH_SIZE;
    }
    // even if the RtlQueryRegistryValues has failed, we return success and will
    // use the defaults.
    return STATUS_SUCCESS;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\rcvind.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\rcvind.h

Abstract:
	Receive indication processing

Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFWD_RCVIND
#define _IPXFWD_RCVIND

// Doesn't allow accepting packets (for routing) from dial-in clients
extern BOOLEAN	ThisMachineOnly;

/*++
*******************************************************************
    I n i t i a l i z e R e c v Q u e u e

Routine Description:
	Initializes recv queue
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
//VOID
//DeleteRecvQueue (
//	void
//	)
#define InitializeRecvQueue()	{				\
}

/*++
*******************************************************************
    D e l e t e R e c v Q u e u e

Routine Description:
	Deletes recv queue
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteRecvQueue (
	void
	);
	
/*++
*******************************************************************
    F w R e c e i v e

Routine Description:
	Called by the IPX stack to indicate that the IPX packet was
	received by the NIC dirver.  Only external destined packets are
	indicated by this routine (with the exception of Netbios boradcasts
	that indicated both for internal and external handlers)
Arguments:
	MacBindingHandle	- handle of NIC driver
	MaxReceiveContext	- NIC driver context
	Context				- forwarder context associated with
							the NIC (interface block pointer)
	RemoteAddress		- sender's address
	MacOptions			-
	LookaheadBuffer		- packet lookahead buffer that contains complete
							IPX header
	LookaheadBufferSize	- its size (at least 30 bytes)
	LookaheadBufferOffset - offset of lookahead buffer in the physical
							packet
Return Value:
	None

*******************************************************************
--*/
BOOLEAN
IpxFwdReceive (
	NDIS_HANDLE			MacBindingHandle,
	NDIS_HANDLE			MacReceiveContext,
	ULONG_PTR			Context,
	PIPX_LOCAL_TARGET	RemoteAddress,
	ULONG				MacOptions,
	PUCHAR				LookaheadBuffer,
	UINT				LookaheadBufferSize,
	UINT				LookaheadBufferOffset,
	UINT				PacketSize,
    PMDL                pMdl

	);


/*++
*******************************************************************
    F w T r a n s f e r D a t a C o m p l e t e

Routine Description:
	Called by the IPX stack when NIC driver completes data transger.
Arguments:
	pktDscr				- handle of NIC driver
	status				- result of the transfer
	bytesTransferred	- number of bytest trasferred
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdTransferDataComplete (
	PNDIS_PACKET	pktDscr,
	NDIS_STATUS		status,
	UINT			bytesTransferred
	);


/*++
*******************************************************************
    F w T r a n s f e r D a t a C o m p l e t e

Routine Description:

		This routine receives control from the IPX driver after one or
		more receive operations have completed and no receive is in progress.
		It is called under less severe time constraints than IpxFwdReceive.
		It is used to process netbios queue

Arguments:
	None
Return Value:
	None
*******************************************************************
--*/
VOID
IpxFwdReceiveComplete (
	USHORT	NicId
	);

/*++
*******************************************************************
    F w R e c e i v e

Routine Description:
	Called by the IPX stack to indicate that the IPX packet destined
	to local client was received by the NIC dirver.
Arguments:
	Context				- forwarder context associated with
							the NIC (interface block pointer)
	RemoteAddress		- sender's address
	LookaheadBuffer		- packet lookahead buffer that contains complete
							IPX header
	LookaheadBufferSize	- its size (at least 30 bytes)
Return Value:
	STATUS_SUCCESS - the packet will be delivered to local destination
	STATUS_UNSUCCESSFUL - the packet will be dropped

*******************************************************************
--*/
NTSTATUS
IpxFwdInternalReceive (
	IN ULONG_PTR			FwdAdapterContext,
	IN PIPX_LOCAL_TARGET	RemoteAddress,
	IN PUCHAR				LookAheadBuffer,
	IN UINT					LookAheadBufferSize
	);

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\rwlock.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\rwlock.h

Abstract:
    Reader-Writer lock macros


Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFWD_RWLOCK_
#define _IPXFWD_RWLOCK_

typedef volatile LONG VOLCTR, *PVOLCTR;
typedef PVOLCTR RWCOOKIE, *PRWCOOKIE;

// Reader- writer lock.
// Allows no-lock access to the tables for readers - they merely
// increment the counter to record their presence upon entrance
// and decrement the same counter as they leave.
// Writers are supposed to be serialized (externally) and their
// actions are limited to ATOMIC insertions of new elements and
// ATOMIC removals/replacements. The removals/replacements MUST
// be followed by a wait for all potential readers who might still
// be using the element that was removed/replaced

typedef struct _RW_LOCK {
        KEVENT                          Event;                  // Event to release waiting writer
        VOLCTR                          Ctr1;                   // Two alternating
        VOLCTR                          Ctr2;                   // reader counters
        volatile PVOLCTR        CurCtr;                 // Counter currently in use
} RW_LOCK, *PRW_LOCK;


/*++
*******************************************************************
    I n i t i a l i z e R W L o c k

Routine Description:
        Initializes RW lock
Arguments:
        lock - pointer to lock to initialize
Return Value:
        None
*******************************************************************
--*/
//VOID
//InitializeRWLock (
//      PRW_LOCK        lock
//      );
#define InitializeRWLock(lock)  {                       \
        KeInitializeEvent (&(lock)->Event,              \
                                SynchronizationEvent,           \
                                FALSE);                                         \
        (lock)->Ctr1 = (lock)->Ctr2 = 0;                \
        (lock)->CurCtr = &(lock)->Ctr1;                 \
}

/*++
*******************************************************************
    A c q u i r e R e a d e r A c c e s s

Routine Description:
        Acquires reader access to resource protected by the lock
Arguments:
        lock - pointer to lock
        cookie - pointer to buffer to store lock state for subsequent
                        release operation
Return Value:
        None
*******************************************************************
--*/
//VOID
//AcquireReaderAccess (
//      IN      PRW_LOCK        lock,
//      OUT     RWCOOKIE        cookie
//      );
#define AcquireReaderAccess(lock,cookie)                                                        \
    do {                                                                                                                        \
                register LONG   local,local1;                                                           \
            cookie = (lock)->CurCtr;    /*Get current counter pointer*/ \
                local = *(cookie);                      /*Copy counter value*/                  \
        local1 = local + 1;                                         \
                if ((local>=0)                          /*If counter is valid*/                 \
                                                                        /*and it hasn't changed while*/ \
                                                                        /*we were checking and trying*/ \
                                                                        /*to increment it,*/                    \
                                && (InterlockedCompareExchange (                                        \
                                                (PLONG)(cookie),                                                      \
                                                local1,                                                        \
                                                local)                                                           \
                                        ==local))                                                                \
                        break;                                  /*then we obtained the access*/ \
        } while (1)     /*otherwise, we have to do it again (possibly with*/\
                                /*the other counter if writer switched it on us)*/


/*++
*******************************************************************
    R e l e a s e R e a d e r A c c e s s

Routine Description:
        Releases reader access to resource protected by the lock
Arguments:
        lock - pointer to lock
        cookie - lock state for subsequent stored during acquire operation
Return Value:
        None
*******************************************************************
--*/
//VOID
//ReleaseReaderAccess (
//      IN      PRW_LOCK        lock,
//      IN      RWCOOKIE        cookie
//      );
#define ReleaseReaderAccess(lock,cookie) {                                              \
        /*If counter drops below 0, we have to signal the writer*/      \
        if (InterlockedDecrement((PLONG)cookie)<0) {                            \
                LONG    res;                                                                                    \
                ASSERT (*(cookie)==-1);                                                                 \
                res = KeSetEvent (&(lock)->Event, 0, FALSE);                    \
                ASSERT (res==0);                                                                                \
        }                                                                                                                       \
}

/*++
*******************************************************************
    W a i t F o r A l l R e a d e r s

Routine Description:
        Waits for all readers that were accessing the resource prior
        to the call to exit (New readers are not included)
Arguments:
        lock - pointer to lock
Return Value:
        None
*******************************************************************
--*/
//VOID
//WaitForAllReaders (
//      PRW_LOCK                lock
//      );
#define WaitForAllReaders(lock)                 {       \
        RWCOOKIE        prevCtr = (lock)->CurCtr;       \
                /*Switch the counter first*/            \
        if (prevCtr==&(lock)->Ctr1) {                   \
                (lock)->Ctr2 = 0;                                       \
                (lock)->CurCtr = &(lock)->Ctr2;         \
        }                                                                               \
        else {                                                                  \
                ASSERT (prevCtr==&(lock)->Ctr2);        \
                (lock)->Ctr1 = 0;                                       \
                (lock)->CurCtr = &(lock)->Ctr1;         \
        }                                                                               \
                /* If not all readers are gone, we'll have to wait for them*/   \
        if (InterlockedDecrement((PLONG)prevCtr)>=0) {  \
                NTSTATUS status                                         \
                         = KeWaitForSingleObject (              \
                                                &(lock)->Event,         \
                                                Executive,                      \
                                                ExGetPreviousMode(),\
                                                FALSE,                          \
                                                0);                                     \
                ASSERT (NT_SUCCESS(status));            \
                ASSERT (*prevCtr==-1);                          \
        }                                                                               \
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\send.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\send.c

Abstract:
	Send routines

Author:

    Vadim Eydelman

Revision History:

--*/

#include    "precomp.h"


ULONG			SpoofingTimeout=DEF_SPOOFING_TIMEOUT;
LIST_ENTRY		SpoofingQueue;
KSPIN_LOCK		SpoofingQueueLock;
WORK_QUEUE_ITEM	SpoofingWorker;
BOOLEAN			SpoofingWorkerActive = FALSE;
ULONG			DontSuppressNonAgentSapAdvertisements = 0;

#define IsLocalSapNonAgentAdvertisement(hdr,data,ln,ifCB) (		\
	(DontSuppressNonAgentSapAdvertisements==0)					\
	&& (GETUSHORT(hdr+IPXH_DESTSOCK)==IPX_SAP_SOCKET)			\
	&& (GETUSHORT(hdr+IPXH_SRCSOCK)!=IPX_SAP_SOCKET)			\
	&& (ln>=IPXH_HDRSIZE+2)										\
	&& (GETUSHORT(data)==2)										\
	&& ((IPX_NODE_CMP(hdr+IPXH_DESTNODE,BROADCAST_NODE)==0)		\
        || (IPX_NODE_CMP(hdr+IPXH_DESTNODE,ifCB->ICB_RemoteNode)==0)) \
)

/*++
*******************************************************************
    D o S e n d

Routine Description:
	Prepares and sends packet.  Interface lock must be help while
	callin this routine
Arguments:
	dstIf	- over which interface to send
	pktTag	- packet to send
Return Value:
	result returned by IPX

*******************************************************************
--*/
NDIS_STATUS
DoSend (
	PINTERFACE_CB	dstIf,
	PPACKET_TAG		pktTag,
	KIRQL			oldIRQL
	) {
	NDIS_STATUS			status;
	PNDIS_PACKET		pktDscr;
	PNDIS_BUFFER		bufDscr, aDscr;
	UINT				dataLen;
	ULONG				dstNet = GETULONG (pktTag->PT_Data+IPXH_DESTNET);

	if (dstIf!=InternalInterface) {
        ADAPTER_CONTEXT_TO_LOCAL_TARGET (dstIf->ICB_AdapterContext,
										&pktTag->PT_Target);
    }
    else {
		CONSTANT_ADAPTER_CONTEXT_TO_LOCAL_TARGET (
                        VIRTUAL_NET_ADAPTER_CONTEXT,
										&pktTag->PT_Target);
    }

#if DBG
		// Keep track of packets being processed by IPX stack
	InsertTailList (&dstIf->ICB_InSendQueue, &pktTag->PT_QueueLink);
#endif
	KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
	
	if (pktTag->PT_Flags&PT_SOURCE_IF)
		ReleaseInterfaceReference (pktTag->PT_SourceIf);
	pktTag->SEND_RESERVED[0] = pktTag->SEND_RESERVED[1] = 0;
	pktDscr = CONTAINING_RECORD(pktTag, NDIS_PACKET, ProtocolReserved);
    NdisQueryPacket(pktDscr, NULL, NULL, &bufDscr, NULL);
#if DBG
	{		// Verify packet integrity
		PUCHAR	dataPtr;
		UINT	bufLen;
		ASSERT (NDIS_BUFFER_LINKAGE (bufDscr)==NULL);
		NdisQueryBuffer (bufDscr, &dataPtr, &bufLen);
		ASSERT (dataPtr==pktTag->PT_Data);
		ASSERT (bufLen==pktTag->PT_Segment->PS_SegmentList->SL_BlockSize);
	}
#endif
			// Prepare packet for IPX stack (mac header buffer goes in
			// front and packet length adjusted to reflect the size of the data
	dataLen = GETUSHORT(pktTag->PT_Data+IPXH_LENGTH);
    NdisAdjustBufferLength(bufDscr, dataLen);
	NdisChainBufferAtFront(pktDscr, pktTag->PT_MacHdrBufDscr);


	if (EnterForwarder ()) {// To make sure that we won't unload
							// until IPX driver has a chance to call us back
		status = IPXSendProc (&pktTag->PT_Target, pktDscr, dataLen, 0);

		if (status!=NDIS_STATUS_PENDING) {
			LeaveForwarder ();	// No callback

				// Restore original packet structure
			NdisUnchainBufferAtFront (pktDscr, &aDscr);
#if DBG
				// Make sure IPX stack did not mess our packet
			ASSERT (aDscr==pktTag->PT_MacHdrBufDscr);
		    NdisQueryPacket(pktDscr, NULL, NULL, &aDscr, NULL);
			ASSERT (aDscr==bufDscr);
			ASSERT (NDIS_BUFFER_LINKAGE (aDscr)==NULL);
#endif
				// Restore original packet size
			NdisAdjustBufferLength(bufDscr,
						pktTag->PT_Segment->PS_SegmentList->SL_BlockSize);
#if DBG
				// Remove packet from temp queue
			KeAcquireSpinLock (&pktTag->PT_InterfaceReference->ICB_Lock, &oldIRQL);
			RemoveEntryList (&pktTag->PT_QueueLink);
			KeReleaseSpinLock (&pktTag->PT_InterfaceReference->ICB_Lock, oldIRQL);
#endif
		}
	}
	else {
			// We are going down, restore the packet
		NdisUnchainBufferAtFront (pktDscr, &aDscr);
		NdisAdjustBufferLength(bufDscr,
						pktTag->PT_Segment->PS_SegmentList->SL_BlockSize);
		NdisRecalculatePacketCounts (pktDscr);
		status = STATUS_UNSUCCESSFUL;
#if DBG
		KeAcquireSpinLock (&pktTag->PT_InterfaceReference->ICB_Lock, &oldIRQL);
		RemoveEntryList (&pktTag->PT_QueueLink);
		KeReleaseSpinLock (&pktTag->PT_InterfaceReference->ICB_Lock, oldIRQL);
#endif
	}
	return status;
}


/*++
*******************************************************************
    P r o c e s s S e n t P a c k e t

Routine Description:
	Process completed sent packets
Arguments:
	dstIf	- interface over which packet was sent
	pktTag	- completed packet
	status	- result of send operation
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessSentPacket (
	PINTERFACE_CB	dstIf,
	PPACKET_TAG		pktTag,
	NDIS_STATUS		status
	) {
	KIRQL			oldIRQL;

		// Packet processing is completed -> can take more packets
	InterlockedIncrement (&dstIf->ICB_PendingQuota);

	if (*(pktTag->PT_Data+IPXH_PKTTYPE) == IPX_NETBIOS_TYPE) {
            // Continue processing netbios packets
		if (status==NDIS_STATUS_SUCCESS) {
		    IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
			    ("IpxFwd: NB Packet %08lx sent.", pktTag));
    		InterlockedIncrement (&dstIf->ICB_Stats.OutDelivers);
			InterlockedIncrement (&dstIf->ICB_Stats.NetbiosSent);
        }
        else {
		    IpxFwdDbgPrint (DBG_NETBIOS, DBG_ERROR,
			    ("IpxFwd: NB Packet %08lx send failed with error: %08lx.\n",
			    pktTag, status));
        }
			// Queue nb packet for further processing (broadcast on all interfaces)
		QueueNetbiosPacket (pktTag);
	}
	else {
			// Destroy completed packet
	    if (status==NDIS_STATUS_SUCCESS) {
    		InterlockedIncrement (&dstIf->ICB_Stats.OutDelivers);
		    IpxFwdDbgPrint (DBG_SEND, DBG_INFORMATION,
			    ("IpxFwd: Packet %08lx sent.", pktTag));
	    }
	    else {
		    InterlockedIncrement (&dstIf->ICB_Stats.OutDiscards);
		    IpxFwdDbgPrint (DBG_SEND, DBG_ERROR,
			    ("IpxFwd: Packet %08lx send failed with error: %08lx.\n",
			    pktTag, status));
	    }
		ReleaseInterfaceReference (dstIf);
		if (MeasuringPerformance
			&& (pktTag->PT_PerfCounter!=0)) {
			LARGE_INTEGER	PerfCounter = KeQueryPerformanceCounter (NULL);
			PerfCounter.QuadPart -= pktTag->PT_PerfCounter;
			KeAcquireSpinLock (&PerfCounterLock, &oldIRQL);
			ASSERT (PerfCounter.QuadPart<ActivityTreshhold);
			PerfBlock.TotalPacketProcessingTime += PerfCounter.QuadPart;
			PerfBlock.PacketCounter += 1;
			if (PerfBlock.MaxPacketProcessingTime < PerfCounter.QuadPart)
				PerfBlock.MaxPacketProcessingTime = PerfCounter.QuadPart;
			KeReleaseSpinLock (&PerfCounterLock, oldIRQL);
		}
		FreePacket (pktTag);
	}
}

/*++
*******************************************************************
    S e n d P a c k e t

Routine Description:
	Enqueues packets to be sent by IPX stack
Arguments:
	dstIf	- over which interface to send
	pktTag	- packet to send
Return Value:
	None

*******************************************************************
--*/
VOID
SendPacket (
	PINTERFACE_CB		dstIf,
	PPACKET_TAG		    pktTag
	) {
    NDIS_STATUS			status;
	KIRQL				oldIRQL;


	ASSERT (dstIf->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);
		// Make sure we have not exceded the quota of pending packets on the interface
	if (InterlockedDecrement (&dstIf->ICB_PendingQuota)>=0) {
		KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
			// Decide what to do with the packet based on the interface state
		switch (dstIf->ICB_Stats.OperationalState) {
		case FWD_OPER_STATE_UP:
			if (*(pktTag->PT_Data + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE)
				NOTHING;
			else {
				PUTULONG (dstIf->ICB_Network, pktTag->PT_Data+IPXH_DESTNET);
			}
			status = DoSend (dstIf, pktTag, oldIRQL);
			IpxFwdDbgPrint (DBG_SEND, DBG_INFORMATION,
				("IpxFwd: Sent external packet %08lx on if %ld.\n",
				pktTag, dstIf->ICB_Index));
			break;
		case FWD_OPER_STATE_SLEEPING:
			if ((*(pktTag->PT_Data+IPXH_PKTTYPE)!=0)
					|| (GETUSHORT(pktTag->PT_Data+IPXH_LENGTH)!=IPXH_HDRSIZE+2)
					|| (*(pktTag->PT_Data+IPXH_HDRSIZE+1)!='?')) {
					// Queue this packet on the interface until it is connected
					// by Router Manager (DIM) if this is not a NCP keepalive
					// (watchdog)
				InsertTailList (&dstIf->ICB_ExternalQueue, &pktTag->PT_QueueLink);
				if (!IS_IF_CONNECTING (dstIf)) {
						// Ask for connection if interface is not in the connection
						// queue yet
					QueueConnectionRequest (dstIf,
                        CONTAINING_RECORD (pktTag,
                                            NDIS_PACKET,
                                            ProtocolReserved),
                        pktTag->PT_Data,
                        oldIRQL);
					IpxFwdDbgPrint (DBG_DIALREQS, DBG_WARNING,
						("IpxFwd: Queued dd request on if %ld (ifCB:%08lx)"
						" for packet to %02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%02x%02x"
						" from %02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%02x%02x\n",
						dstIf->ICB_Index, dstIf,
						*(pktTag->PT_Data+6),*(pktTag->PT_Data+7),
								*(pktTag->PT_Data+8),*(pktTag->PT_Data+9),
							*(pktTag->PT_Data+10),*(pktTag->PT_Data+11),
								*(pktTag->PT_Data+12),*(pktTag->PT_Data+13),
								*(pktTag->PT_Data+14),*(pktTag->PT_Data+15),
							*(pktTag->PT_Data+16),*(pktTag->PT_Data+17),
						*(pktTag->PT_Data+18),*(pktTag->PT_Data+19),
								*(pktTag->PT_Data+20),*(pktTag->PT_Data+21),
							*(pktTag->PT_Data+22),*(pktTag->PT_Data+23),
								*(pktTag->PT_Data+24),*(pktTag->PT_Data+25),
								*(pktTag->PT_Data+26),*(pktTag->PT_Data+27),
							*(pktTag->PT_Data+28),*(pktTag->PT_Data+29)));
				}
				else
					KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
				IpxFwdDbgPrint (DBG_SEND, DBG_INFORMATION,
					("IpxFwd: Queued external packet %08lx on if %ld.\n",
					pktTag, dstIf->ICB_Index));
				if (*(pktTag->PT_Data + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE)
					NOTHING;
				else if (!(pktTag->PT_Flags&PT_NB_DESTROY)) {
						// If this nb packet is not to be destroyed after this
						// send, we have to make a copy of it to send on
						// other interfaces while the original is waiting
						// for connection
					PPACKET_TAG	newPktTag;
					DuplicatePacket (pktTag, newPktTag);
					if (newPktTag!=NULL) {
						UINT			bytesCopied;
						PNDIS_PACKET	packet = CONTAINING_RECORD (pktTag,
														NDIS_PACKET,
														ProtocolReserved);
						PNDIS_PACKET	newPacket = CONTAINING_RECORD (newPktTag,
														NDIS_PACKET,
														ProtocolReserved);
						NdisCopyFromPacketToPacket (newPacket, 0,
									GETUSHORT(pktTag->PT_Data+IPXH_LENGTH),
									packet, 0, &bytesCopied);

						ASSERT (bytesCopied==GETUSHORT(pktTag->PT_Data+IPXH_LENGTH));
						IpxFwdDbgPrint (DBG_NETBIOS,
							DBG_INFORMATION,
							("IpxFwd: Duplicated queued nb packet"
							" %08lx -> %08lx on if %ld.\n",
							pktTag, newPktTag, dstIf->ICB_Index));
						AcquireInterfaceReference (dstIf);
						newPktTag->PT_InterfaceReference = dstIf;
						newPktTag->PT_PerfCounter = pktTag->PT_PerfCounter;
						QueueNetbiosPacket (newPktTag);
							// The original copy will have to be
							// destroyed after it is sent on the
							// connected interface
						pktTag->PT_Flags |= PT_NB_DESTROY;
					}
				}
				status = NDIS_STATUS_PENDING;
				break;
			}
			else {	// Process keepalives
				LONGLONG	curTime;
				KeQuerySystemTime ((PLARGE_INTEGER)&curTime);
				if (((curTime-dstIf->ICB_DisconnectTime)/10000000) < SpoofingTimeout) {
					KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
					IpxFwdDbgPrint (DBG_SPOOFING, DBG_INFORMATION,
						("IpxFwd: Queueing reply to keepalive from server"
						" on if %ld (ifCB %lx)"
						" at %02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%02x%02x.\n",
						dstIf->ICB_Index, dstIf,
						*(pktTag->PT_Data+IPXH_SRCNET),*(pktTag->PT_Data+IPXH_SRCNET+1),
							*(pktTag->PT_Data+IPXH_SRCNET+2),*(pktTag->PT_Data+IPXH_SRCNET+3),
						*(pktTag->PT_Data+IPXH_SRCNODE),*(pktTag->PT_Data+IPXH_SRCNODE+1),
							*(pktTag->PT_Data+IPXH_SRCNODE+2),*(pktTag->PT_Data+IPXH_SRCNODE+3),
							*(pktTag->PT_Data+IPXH_SRCNODE+4),*(pktTag->PT_Data+IPXH_SRCNODE+5),
						*(pktTag->PT_Data+IPXH_SRCSOCK),*(pktTag->PT_Data+IPXH_SRCNODE+1)));
						// Spoof the packet if timeout has not been exceeded
					KeAcquireSpinLock (&SpoofingQueueLock, &oldIRQL);
					InsertTailList (&SpoofingQueue, &pktTag->PT_QueueLink);
					if (!SpoofingWorkerActive
							&& EnterForwarder()) {
						SpoofingWorkerActive = TRUE;
						ExQueueWorkItem (&SpoofingWorker, DelayedWorkQueue);
					}
					KeReleaseSpinLock (&SpoofingQueueLock, oldIRQL);
						// We will actually send this packet though
						// in other direction, so mark it as pending
						// to prevent ProcessSentPacket to be called
					status = NDIS_STATUS_PENDING;
					break;
				}
				// else don't spoof (fall through and fail the packet)
			}
		case FWD_OPER_STATE_DOWN:
			KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
			status = NDIS_STATUS_ADAPTER_NOT_READY;
			IpxFwdDbgPrint (DBG_SEND, DBG_WARNING,
				("IpxFwd: Failed external packet %08lx on if %ld(down?).\n",
				pktTag, dstIf->ICB_Index));
			break;
		default:
		    status = STATUS_UNSUCCESSFUL;
			ASSERTMSG ("Invalid operational state ", FALSE);
		}
	}
	else {
		IpxFwdDbgPrint (DBG_SEND, DBG_WARNING,
			("IpxFwd: Could not send packet %08lx on if %ld (quota exceeded).\n",
			pktTag, dstIf->ICB_Index));
		status = NDIS_STATUS_RESOURCES;
	}

	if (status!=NDIS_STATUS_PENDING)
		ProcessSentPacket (dstIf, pktTag, status);
}

/*++
*******************************************************************
    F w S e n d C o m p l e t e

Routine Description:
	Called by IPX stack when send completes asynchronously
Arguments:
	pktDscr	- descriptor of the completed packet
	status	- result of send operation
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdSendComplete (
	PNDIS_PACKET	pktDscr,
	NDIS_STATUS		status
	) {
	PPACKET_TAG     pktTag;
	PNDIS_BUFFER	bufDscr;

	pktTag = (PPACKET_TAG)pktDscr->ProtocolReserved;

	NdisUnchainBufferAtFront (pktDscr, &bufDscr);
	ASSERT (bufDscr==pktTag->PT_MacHdrBufDscr);

	NdisQueryPacket(pktDscr,
            NULL,
            NULL,
            &bufDscr,
            NULL);
    NdisAdjustBufferLength(bufDscr,
		pktTag->PT_Segment->PS_SegmentList->SL_BlockSize);
	NdisRecalculatePacketCounts (pktDscr);
#if DBG
	{
	KIRQL			oldIRQL;
	KeAcquireSpinLock (&pktTag->PT_InterfaceReference->ICB_Lock, &oldIRQL);
	RemoveEntryList (&pktTag->PT_QueueLink);
	KeReleaseSpinLock (&pktTag->PT_InterfaceReference->ICB_Lock, oldIRQL);
	}
#endif
	ProcessSentPacket (pktTag->PT_InterfaceReference, pktTag, status);
	LeaveForwarder (); // Entered before calling IpxSendPacket
}


/*++
*******************************************************************
	
	F w I n t e r n a l S e n d

Routine Description:
	Filter and routes packets sent by IPX stack
Arguments:
   LocalTarget		- the NicId and next hop router MAC address
   Context			- preferred interface on which to send
   Packet			- packet to be sent
   ipxHdr			- pointer to ipx header inside the packet
   PacketLength		- length of the packet
   fIterate         - a flag to indicate if this is a packet for the
                        iteration of which the Fwd takes responsibility
                        - typically type 20 NetBIOS frames
Return Value:

   STATUS_SUCCESS - if the preferred NIC was OK and packet passed filtering
   STATUS_NETWORK_UNREACHABLE - if the preferred was not OK or packet failed filtering
   STATUS_PENDING - packet was queued until connection is established
*******************************************************************
--*/
NTSTATUS
IpxFwdInternalSend (
	IN OUT PIPX_LOCAL_TARGET	LocalTarget,
	IN ULONG_PTR				Context,
	IN PNDIS_PACKET				pktDscr,
	IN PUCHAR					ipxHdr,
	IN PUCHAR					data,
	IN ULONG					PacketLength,
    IN BOOLEAN                  fIterate
	) {
	PINTERFACE_CB				dstIf = NULL, // Initialized to indicate
                                // first path through the iteration
                                // as well as the fact the we do not
                                // know it initially
                                stDstIf = NULL;    // Static destination for
                                // NetBIOS names
	PFWD_ROUTE					fwRoute = NULL;
	ULONG						dstNet;
    USHORT                      dstSock;
	NTSTATUS					status;

	if (!EnterForwarder())
		return STATUS_NETWORK_UNREACHABLE;

	if (IS_IF_ENABLED(InternalInterface)
            && ((*(ipxHdr+IPXH_PKTTYPE) != IPX_NETBIOS_TYPE)
                || InternalInterface->ICB_NetbiosAccept)) {

        // Print out the fact that we're going to send and display the nic id's
	    IpxFwdDbgPrint (DBG_INT_SEND, DBG_INFORMATION,
		    ("IpxFwd: InternalSend entered: nicid= %d  if= %d  ifnic= %d  fIterate: %d",
		      LocalTarget->NicId,
		      ((Context!=INVALID_CONTEXT_VALUE) & (Context!=VIRTUAL_NET_FORWARDER_CONTEXT)) ? ((PINTERFACE_CB)Context)->ICB_Index : -1,
		      ((Context!=INVALID_CONTEXT_VALUE) & (Context!=VIRTUAL_NET_FORWARDER_CONTEXT)) ? ((PINTERFACE_CB)Context)->ICB_NicId : -1,
		      fIterate
		      ));

        do { // Big loop used to iterate over interfaces
            status = STATUS_SUCCESS;    // Assume success

            // fIterate is normally set to false and so the following codepath
            // is the most common.  The only time fIterate is set to true is when
            // this is a type 20 broadcast that needs to be sent over each interface.
		    if (!fIterate) {
    		    dstNet = GETULONG (ipxHdr+IPXH_DESTNET);

			    if (Context!=INVALID_CONTEXT_VALUE) {
                    if (Context!=VIRTUAL_NET_FORWARDER_CONTEXT) {
					    // IPX driver supplied interface context, just verify that it
					    // exists and can be used to reach the destination network
				        dstIf = InterfaceContextToReference ((PVOID)Context,
												    LocalTarget->NicId);
                    }
                    else {
                        dstIf = InternalInterface;
                        AcquireInterfaceReference (dstIf);
                    }
				    if (dstIf!=NULL) {
						    // It does exist
						    // First process direct connections
					    if ((dstNet==0)
							    || (dstNet==dstIf->ICB_Network)) {
						    NOTHING;
					    }
					    else { // Network is not connected directly
						    PINTERFACE_CB	dstIf2;
							    // Verify the route
						    dstIf2 = FindDestination (dstNet,
											    ipxHdr+IPXH_DESTNODE,
												    &fwRoute);
						    if (dstIf==dstIf2) {
								    // Route OK, release the extra interface reference
							    ReleaseInterfaceReference (dstIf2);
						    }
						    else {
								    // Route not OK, release interface/route references
							    InterlockedIncrement (&InternalInterface->ICB_Stats.InNoRoutes);
							    IpxFwdDbgPrint (DBG_INT_SEND, DBG_WARNING,
								    ("IpxFwd: Failed direct internal send on"
								    " if %ld to %08lx:%02x%02x%02x%02x%02x%02x"
								    " (no route).\n",
								    dstIf->ICB_Index, dstNet,
								    LocalTarget->MacAddress[0],
									    LocalTarget->MacAddress[1],
									    LocalTarget->MacAddress[2],
									    LocalTarget->MacAddress[3],
									    LocalTarget->MacAddress[4],
									    LocalTarget->MacAddress[5]));
							    if (dstIf2!=NULL) {
								    ReleaseInterfaceReference (dstIf2);
							    }
							    status = STATUS_NETWORK_UNREACHABLE;
                                break;
						    }
					    }
				    }
				    else {
					    InterlockedIncrement (&InternalInterface->ICB_Stats.InDiscards);
					    IpxFwdDbgPrint (DBG_INT_SEND, DBG_WARNING,
						    ("IpxFwd: Invalid interface context (%08lx)"
						    " from IPX driver on internal send to"
						    " %08lx:%02x%02x%02x%02x%02x%02x.\n",
						    Context,  dstNet,
						    LocalTarget->MacAddress[0],
							    LocalTarget->MacAddress[1],
							    LocalTarget->MacAddress[2],
							    LocalTarget->MacAddress[3],
							    LocalTarget->MacAddress[4],
							    LocalTarget->MacAddress[5]));
                        status = STATUS_NO_SUCH_DEVICE;
                        break;
				    }
			    }
			    else {// No interface context supplied by IPX driver, have to find the route
				    dstIf = FindDestination (dstNet, ipxHdr+IPXH_DESTNODE,
										    &fwRoute);
				    if (dstIf!=NULL)
					    NOTHING;
				    else {
					    InterlockedIncrement (&InternalInterface->ICB_Stats.InNoRoutes);
					    IpxFwdDbgPrint (DBG_INT_SEND, DBG_WARNING,
						    ("IpxFwd: Failed internal send because no route to"
						    " %08lx:%02x%02x%02x%02x%02x%02x exists.\n",
						    LocalTarget->MacAddress[0],
							    LocalTarget->MacAddress[1],
							    LocalTarget->MacAddress[2],
							    LocalTarget->MacAddress[3],
							    LocalTarget->MacAddress[4],
							    LocalTarget->MacAddress[5]));
					    status = STATUS_NETWORK_UNREACHABLE;
                        break;
				    }
			    }
    		    InterlockedIncrement (&InternalInterface->ICB_Stats.InDelivers);
		    }

            // fIterate was set to true.
		    // In this case, the stack is calling the forwarder with fIterate set
            // to true until the fwd returns STATUS_NETWORK_UNREACHABLE.  It is
            // the fwd's job to return the NEXT nicid over which to send each time
            // it is called.  This allows the fwd to not enumerate interfaces which
            // have been disabled for netbios delivery.
		    else {
		        dstNet = 0;	// Don't care, it must be a local send

		        // See if it's a type 20 broadcast
			    if (*(ipxHdr+IPXH_PKTTYPE) == IPX_NETBIOS_TYPE) {
			
			        // dstIf is initialized to null.  The only way it
			        // would be non-null is if this is not our first time through
			        // the big do-while loop in this function and if on the last
			        // time through this big loop, we found an interface that we
			        // can't send the packet over so we're looking for the next
			        // one now.
                    if (dstIf==NULL) { // First time through internal loop
   			            dstSock = GETUSHORT (ipxHdr+IPXH_DESTSOCK);

					        // See if we can get a static route for this packet
				        if (dstSock==IPX_NETBIOS_SOCKET)
					        stDstIf = FindNBDestination (data+(NB_NAME-IPXH_HDRSIZE));
				        else if (dstSock==IPX_SMB_NAME_SOCKET)
					        stDstIf = FindNBDestination (data+(SMB_NAME-IPXH_HDRSIZE));
                        else
                            stDstIf = NULL;
                    }

                    // The first time the stack calls us with fIterate==TRUE, it will
                    // give us an INVALID_CONTEXT_VALUE so we can tell it which is the
                    // first nic id in the iteration as per our interface table.
                    if ((Context==INVALID_CONTEXT_VALUE) && (dstIf==NULL)) {
                        // First time through the loop, increment counters
                    	InterlockedIncrement (&InternalInterface->ICB_Stats.InDelivers);
                    	InterlockedIncrement (&InternalInterface->ICB_Stats.NetbiosSent);

                        // stDstIf is the interface to use if there is a static route
                        // to the given network.
                        if (stDstIf!=NULL) {
                            dstIf = stDstIf;
				            IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					            ("IpxFwd: Allowed internal NB broadcast (1st iteration) on if %d (%lx)"
					            " to static name %.16s.\n",
                                dstIf->ICB_Index, dstIf,
					            (dstSock==IPX_NETBIOS_SOCKET)
						            ? data+(NB_NAME-IPXH_HDRSIZE)
						            : ((dstSock==IPX_SMB_NAME_SOCKET)
							            ? data+(SMB_NAME-IPXH_HDRSIZE)
							            : "Not a name frame")
					            ));
                        }

                        // There is no static route.  Tell the stack to use the
                        // next interface in this enumeration.
                        else {
                            dstIf = GetNextInterfaceReference (NULL);
                            if (dstIf!=NULL)
				                IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					                ("IpxFwd: Allowed internal nb broadcast (1st iteration) on if %d (%lx),"
					                " to name %.16s.\n",
                                    dstIf->ICB_Index, dstIf,
					                (dstSock==IPX_NETBIOS_SOCKET)
						                ? data+(NB_NAME-IPXH_HDRSIZE)
						                : ((dstSock==IPX_SMB_NAME_SOCKET)
							                ? data+(SMB_NAME-IPXH_HDRSIZE)
							                : "Not a name frame")
					                ));
                            else {
				                IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					                ("IpxFwd: Nb broadcast no destinations"
                                    " to name %.16s.\n",
					                (dstSock==IPX_NETBIOS_SOCKET)
						                ? data+(NB_NAME-IPXH_HDRSIZE)
						                : ((dstSock==IPX_SMB_NAME_SOCKET)
							                ? data+(SMB_NAME-IPXH_HDRSIZE)
							                : "Not a name frame")
					                ));
                                status = STATUS_NETWORK_UNREACHABLE;
                                break;
                            }
                        }
                    }

                    // The following path is taken if the stack provided a
                    // valid context and set fIterate to true.  Our job here
                    // is to return the next nic id according to our interface
                    // table over which to send the pack.
                    else {

                        // This path is taken if there is no static netbios route
                        if (stDstIf==NULL) {
                            // dstIf will be null if this is the first time through the
                            // big do-while loop in this function.
                            if (dstIf==NULL)
                                dstIf = InterfaceContextToReference ((PVOID)Context,
												            LocalTarget->NicId);
                            dstIf = GetNextInterfaceReference (dstIf);

                            // If we find a next interface over which to send we'll
                            // put the nic id of that interface into the local target
                            // after exiting the big do-while loop.
                            if (dstIf!=NULL) {
				                IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					                ("IpxFwd: Allowed internal NB broadcast (1+ iteration)"
                                    " on if %d (%lx, ctx: %08lx, nic: %d)"
                                    " to name %.16s.\n",
                                    dstIf->ICB_Index, dstIf,
                                    Context, LocalTarget->NicId,
					                (dstSock==IPX_NETBIOS_SOCKET)
						                ? data+(NB_NAME-IPXH_HDRSIZE)
						                : ((dstSock==IPX_SMB_NAME_SOCKET)
							                ? data+(SMB_NAME-IPXH_HDRSIZE)
							                : "Not a name frame")
					                ));
                            }

                            // Otherwise, we'll break out here and return
                            // STATUS_NETWORK_UNREACHABLE which will signal to the
                            // stack that we have finished the iteration.
                            else {
				                IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					                ("IpxFwd: NB broadcast no more iterations"
                                    " for ctx: %08lx, nic: %d"
                                    " to name %.16s.\n",
                                    Context, LocalTarget->NicId,
					                (dstSock==IPX_NETBIOS_SOCKET)
						                ? data+(NB_NAME-IPXH_HDRSIZE)
						                : ((dstSock==IPX_SMB_NAME_SOCKET)
							                ? data+(SMB_NAME-IPXH_HDRSIZE)
							                : "Not a name frame")
					                ));
                                status = STATUS_NETWORK_UNREACHABLE;
                                break;
                            }
                        }

                        // This path is taken if there is a static netbios route.  In this
                        // case, we don't need to iterate over all interfaces so we break
                        // and tell the stack that we finished our iteration.
                        else {
				            IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					            ("IpxFwd: Static NB broadcast (1+ iteration)"
                                " on if %d (%lx, ctx: %08lx, nic: %d)"
                                " to name %.16s.\n",
                                stDstIf->ICB_Index, stDstIf,
                                Context, LocalTarget->NicId,
					            (dstSock==IPX_NETBIOS_SOCKET)
						            ? data+(NB_NAME-IPXH_HDRSIZE)
						            : ((dstSock==IPX_SMB_NAME_SOCKET)
							            ? data+(SMB_NAME-IPXH_HDRSIZE)
							            : "Not a name frame")
					            ));
                            ReleaseInterfaceReference (stDstIf);
                            status = STATUS_NETWORK_UNREACHABLE;
                            break;
                        }
                    }
                }

                // This path is taken if fIterate was set to true but this
                // is not a type 20 broadcast.  I doubt that this path is
                // ever even taken since for general broadcasts, the stack
                // handles the iteration.
                else {
                    if ((dstIf==NULL)
                            && (Context!=INVALID_CONTEXT_VALUE))
                        dstIf = InterfaceContextToReference ((PVOID)Context,
												        LocalTarget->NicId);
                    dstIf = GetNextInterfaceReference (dstIf);
                    if (dstIf!=NULL) {
				        IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					        ("IpxFwd: Allowed internal iterative send"
                            " on if %d (%lx, ctx: %08lx, nic: %d)"
						    " to %02x%02x%02x%02x%02x%02x.\n",
                            dstIf->ICB_Index, dstIf,
                            Context, LocalTarget->NicId,
						    LocalTarget->MacAddress[0],
							    LocalTarget->MacAddress[1],
							    LocalTarget->MacAddress[2],
							    LocalTarget->MacAddress[3],
							    LocalTarget->MacAddress[4],
							    LocalTarget->MacAddress[5]));

                    }
                    else {
				        IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					        ("IpxFwd: No destinations to internal iterative send"
                            " for ctx: %08lx, nic: %d"
						    " to %02x%02x%02x%02x%02x%02x.\n",
                            Context, LocalTarget->NicId,
						    LocalTarget->MacAddress[0],
							    LocalTarget->MacAddress[1],
							    LocalTarget->MacAddress[2],
							    LocalTarget->MacAddress[3],
							    LocalTarget->MacAddress[4],
							    LocalTarget->MacAddress[5]));
                        status = STATUS_NETWORK_UNREACHABLE;
                        break;
                    }
                }

	        }	// End iterative send processing

		    // We were able to find a destination interface
		    if (IS_IF_ENABLED (dstIf)
                    && ((*(ipxHdr+IPXH_PKTTYPE) != IPX_NETBIOS_TYPE)
                        || (dstIf->ICB_NetbiosDeliver==FWD_NB_DELIVER_ALL)
                        || ((dstIf->ICB_NetbiosDeliver==FWD_NB_DELIVER_IF_UP)
				            && (dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_UP))
                        || ((stDstIf!=NULL)
                            && (dstIf->ICB_NetbiosDeliver==FWD_NB_DELIVER_STATIC)))) {
            	KIRQL			oldIRQL;
                FILTER_ACTION   action;

                // In/Out filter check and statistics update

                action = FltFilter (ipxHdr, IPXH_HDRSIZE,
						    InternalInterface->ICB_FilterInContext,
						    dstIf->ICB_FilterOutContext);
			    if (action==FILTER_PERMIT) {
                    NOTHING;
			    }
			    else {
                    InterlockedIncrement (&dstIf->ICB_Stats.OutFiltered);
				    status = STATUS_NETWORK_UNREACHABLE;
                    break;
			    }

        		KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
				// All set, try to send now
	    		switch (dstIf->ICB_Stats.OperationalState) {
		    	case FWD_OPER_STATE_UP:
					    // Interface is up, let it go right away
					    // Set NIC ID
                    if (dstIf!=InternalInterface) {
				        ADAPTER_CONTEXT_TO_LOCAL_TARGET (
								        dstIf->ICB_AdapterContext,
								        LocalTarget);
                    }
                    else {
				        CONSTANT_ADAPTER_CONTEXT_TO_LOCAL_TARGET (
								        VIRTUAL_NET_ADAPTER_CONTEXT,
								        LocalTarget);
                    }
					    // Set destination node
				    if (IsLocalSapNonAgentAdvertisement (ipxHdr,data,PacketLength,dstIf)) {
						    // Loop back sap ads from non-sap socket
					    IPX_NODE_CPY (&LocalTarget->MacAddress,
                                        dstIf->ICB_LocalNode);
                    }
				    else if ((dstNet==0) || (dstNet==dstIf->ICB_Network)) {
						    // Direct connection: send to destination specified
						    // in the header
					    IPX_NODE_CPY (LocalTarget->MacAddress,
									    ipxHdr+IPXH_DESTNODE);
				    }
				    else {	// Indirect connection: send to next hop router
					    if (dstIf->ICB_InterfaceType==FWD_IF_PERMANENT) {
						    ASSERT (fwRoute!=NULL);
						    IPX_NODE_CPY (LocalTarget->MacAddress,
									    fwRoute->FR_NextHopAddress);
					    }
					    else {
							    // Only one peer on the other side
						    IPX_NODE_CPY (LocalTarget->MacAddress,
									    dstIf->ICB_RemoteNode);
					    }
				    }
				    KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
					    // Update statistics
				    InterlockedIncrement (
					    &dstIf->ICB_Stats.OutDelivers);
				    if (*(ipxHdr+IPXH_PKTTYPE)==IPX_NETBIOS_TYPE)
					    InterlockedIncrement (
						    &dstIf->ICB_Stats.NetbiosSent);

				    IpxFwdDbgPrint (DBG_INT_SEND, DBG_INFORMATION,
					    ("IpxFwd: Allowed internal send:"
					    " %ld-%08lx:%02x%02x%02x%02x%02x%02x.\n",
					    dstIf->ICB_Index, dstNet,
					    LocalTarget->MacAddress[0],
						    LocalTarget->MacAddress[1],
						    LocalTarget->MacAddress[2],
						    LocalTarget->MacAddress[3],
						    LocalTarget->MacAddress[4],
						    LocalTarget->MacAddress[5]));
				    // status = STATUS_SUCCESS;	// Let it go
				    break;
			    case FWD_OPER_STATE_SLEEPING:
					    // Interface is disconnected, queue the packet and try to connecte
				    if ((*(ipxHdr+IPXH_PKTTYPE)!=0)
						    || (*(ipxHdr+IPXH_LENGTH)!=IPXH_HDRSIZE+2)
						    || (*(data+1)!='?')) {
						    // Not a keep-alive packet,
					    if (((*(ipxHdr+IPXH_PKTTYPE)!=IPX_NETBIOS_TYPE))
							    || (dstIf->ICB_NetbiosDeliver!=FWD_NB_DELIVER_IF_UP)) {
							    // Not a netbios broadcast or we are allowed to connect
							    // the interface to deliver netbios broadcasts
						    if (InterlockedDecrement (&dstIf->ICB_PendingQuota)>=0) {
							    PINTERNAL_PACKET_TAG	pktTag;
								    // Create a queue element to enqueue the packet
							    pktTag = (PINTERNAL_PACKET_TAG)ExAllocatePoolWithTag (
														    NonPagedPool,
														    sizeof (INTERNAL_PACKET_TAG),
														    FWD_POOL_TAG);
							    if (pktTag!=NULL) {
								    pktTag->IPT_Packet = pktDscr;
								    pktTag->IPT_Length = PacketLength;
								    pktTag->IPT_DataPtr = ipxHdr;
									    // Save next hop address if after connection is
									    // established we determine that destination net
									    // is not connected directly
								    if (fwRoute!=NULL)
									    IPX_NODE_CPY (pktTag->IPT_Target.MacAddress,
													    fwRoute->FR_NextHopAddress);
								    AcquireInterfaceReference (dstIf);	// To make sure interface
												    // block won't go away until we are done with
												    // the packet
								    pktTag->IPT_InterfaceReference = dstIf;
								    InsertTailList (&dstIf->ICB_InternalQueue,
														    &pktTag->IPT_QueueLink);
								    if (!IS_IF_CONNECTING (dstIf)) {
									    QueueConnectionRequest (dstIf, pktDscr, ipxHdr, oldIRQL);
									    IpxFwdDbgPrint (DBG_DIALREQS, DBG_WARNING,
										    ("IpxFwd: Queued dd request on if %ld (ifCB:%08lx)"
										    " for internal packet"
										    " to %02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%02x%02x"
										    " from socket:%02x%02x\n",
										    dstIf->ICB_Index, dstIf,
										    *(ipxHdr+6),*(ipxHdr+7),
												    *(ipxHdr+8),*(ipxHdr+9),
											    *(ipxHdr+10),*(ipxHdr+11),
												    *(ipxHdr+12),*(ipxHdr+13),
												    *(ipxHdr+14),*(ipxHdr+15),
											    *(ipxHdr+16),*(ipxHdr+17),
										    *(ipxHdr+28),*(ipxHdr+29)));
								    }
								    else
									    KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
								    IpxFwdDbgPrint (DBG_INT_SEND, DBG_INFORMATION,
									    ("IpxFwd: Queueing internal send packet %08lx on if %ld.\n",
									    pktTag, dstIf->ICB_Index));
								    status = STATUS_PENDING;
								    break;
							    }
							    else {
								    IpxFwdDbgPrint (DBG_INT_SEND, DBG_ERROR,
									    ("IpxFwd: Could not allocate"
									    " internal packet tag.\n"));
							    }
						    }
						    InterlockedIncrement (&dstIf->ICB_PendingQuota);
					    }
					    else {
						    IpxFwdDbgPrint (DBG_NETBIOS, DBG_WARNING,
							    ("IpxFwd: Droped internal NB packet"
							    " because FWD_NB_DELIVER_IF_UP.\n"));
					    }
				    }
				    else { // Process keep-alives
					    LONGLONG	curTime;
					    KeQuerySystemTime ((PLARGE_INTEGER)&curTime);
					    if (((curTime-dstIf->ICB_DisconnectTime)/10000000) < SpoofingTimeout) {
						    PPACKET_TAG pktTag;
							    // Spoofing timeout has not been exceeded,
							    // Create a reply packet
						    AllocatePacket (WanPacketListId,
								    WanPacketListId,
								    pktTag);
						    if (pktTag!=NULL) {
							    KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
							    PUTUSHORT (0xFFFF, pktTag->PT_Data+IPXH_CHECKSUM);
							    PUTUSHORT ((IPXH_HDRSIZE+2), pktTag->PT_Data+IPXH_LENGTH);
							    *(pktTag->PT_Data+IPXH_XPORTCTL) = 0;
							    *(pktTag->PT_Data+IPXH_PKTTYPE) = 0;
							    memcpy (pktTag->PT_Data+IPXH_DESTADDR,
									    ipxHdr+IPXH_SRCADDR,
									    12);
							    memcpy (pktTag->PT_Data+IPXH_SRCADDR,
									    ipxHdr+IPXH_DESTADDR,
									    12);
							    *(pktTag->PT_Data+IPXH_HDRSIZE) = *data;
							    *(pktTag->PT_Data+IPXH_HDRSIZE+1) = 'Y';
								    // Destination for this packet will have to
								    // be the first active LAN adapter in the system
								    // SHOULD BE REMOVED WHEN LOOPBACK SUPPORT US ADDED BY IPX

							    pktTag->PT_InterfaceReference = NULL;
							    IpxFwdDbgPrint (DBG_SPOOFING, DBG_INFORMATION,
								    ("IpxFwd: Queueing reply to keepalive from internal server"
								    " at %02x%02x.\n",*(ipxHdr+IPXH_DESTSOCK),*(ipxHdr+IPXH_DESTSOCK+1)));
								    // Enqueue to spoofing queue to be sent back
								    // to the server
							    KeAcquireSpinLock (&SpoofingQueueLock, &oldIRQL);
							    InsertTailList (&SpoofingQueue, &pktTag->PT_QueueLink);
								    // Start worker if not running already
							    if (!SpoofingWorkerActive
									    && EnterForwarder()) {
								    SpoofingWorkerActive = TRUE;
								    ExQueueWorkItem (&SpoofingWorker, DelayedWorkQueue);
							    }
							    KeReleaseSpinLock (&SpoofingQueueLock, oldIRQL);
							    status = STATUS_DROP_SILENTLY;
							    break;
						    }
						    else {
							    IpxFwdDbgPrint (DBG_SPOOFING, DBG_ERROR,
								    ("IpxFwd: Could not allocate"
								    " packet tag for spoofing.\n"));
						    }
					    }
					    else {
						    IpxFwdDbgPrint (DBG_SPOOFING, DBG_WARNING,
							    ("IpxFwd: Internal spoofing"
							    " timeout exceded.\n"));
					    }
				    }
			    case FWD_OPER_STATE_DOWN:
					    // Interface down or send failed
				    KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
				    if (*(ipxHdr+IPXH_PKTTYPE)!=IPX_NETBIOS_TYPE)
    				    InterlockedIncrement (
						    &dstIf->ICB_Stats.OutDiscards);
				    IpxFwdDbgPrint (DBG_INT_SEND, DBG_WARNING,
					    ("IpxFwd: Internal send not allowed"
					    " on if %ld (down?).\n", dstIf->ICB_Index));
				    status = STATUS_NETWORK_UNREACHABLE;
				    break;
			    default:
				    ASSERTMSG ("Invalid operational state ", FALSE);
			    }
		    }
		    else {// Interface is disabled
    		    if (*(ipxHdr+IPXH_PKTTYPE)!=IPX_NETBIOS_TYPE)
	    		    InterlockedIncrement (&dstIf->ICB_Stats.OutDiscards);
			    IpxFwdDbgPrint (DBG_INT_SEND, DBG_WARNING,
				    ("IpxFwd: Internal send not allowed"
				    " on because dst if (or Netbios deliver on it) %ld (ifCB: %08lx) is disabled.\n",
				    dstIf->ICB_Index, dstIf));
                status = STATUS_NETWORK_UNREACHABLE;
		    }

		
	    }
        while (fIterate && (status!=STATUS_SUCCESS) && (status!=STATUS_PENDING));

        if (dstIf!=NULL)
		    ReleaseInterfaceReference (dstIf);
		if (fwRoute!=NULL)
			ReleaseRouteReference (fwRoute);
    }
	else {	// Internal interface is disabled
		IpxFwdDbgPrint (DBG_INT_SEND, DBG_WARNING,
			("IpxFwd: Internal send not allowed"
			" because internal if (or Netbios accept on it) is disabled.\n"));
		InterlockedIncrement (
				&InternalInterface->ICB_Stats.InDiscards);
		status = STATUS_NETWORK_UNREACHABLE;
	}

	LeaveForwarder ();
	return status;
}


/*++
*******************************************************************

	P r o c e s s I n t e r n a l Q u e u e

Routine Description:
	Processes packets in the interface internal queue.
	Called when connection request completes
Arguments:
	dstIf - interface to process
Return Value:
	None
*******************************************************************
--*/
VOID
ProcessInternalQueue (
	PINTERFACE_CB	dstIf
	) {
	KIRQL						oldIRQL;
	LIST_ENTRY					tempQueue;

	KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
	InsertHeadList (&dstIf->ICB_InternalQueue, &tempQueue);
	RemoveEntryList (&dstIf->ICB_InternalQueue);
	InitializeListHead (&dstIf->ICB_InternalQueue);
	KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);

	while (!IsListEmpty (&tempQueue)) {
		PINTERNAL_PACKET_TAG		pktTag;
		PLIST_ENTRY					cur;
		NTSTATUS					status;

		cur = RemoveHeadList (&tempQueue);
		pktTag = CONTAINING_RECORD (cur, INTERNAL_PACKET_TAG, IPT_QueueLink);
		InterlockedIncrement (&dstIf->ICB_PendingQuota);

		KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
		if (IS_IF_ENABLED(dstIf)
				&& (dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_UP)) {
			IPX_NODE_CPY (pktTag->IPT_Target.MacAddress,
								dstIf->ICB_RemoteNode);
			ADAPTER_CONTEXT_TO_LOCAL_TARGET (
									dstIf->ICB_AdapterContext,
									&pktTag->IPT_Target);
			KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
			InterlockedIncrement (&dstIf->ICB_Stats.OutDelivers);
			if (*(pktTag->IPT_DataPtr + IPXH_PKTTYPE) == IPX_NETBIOS_TYPE) {
				InterlockedIncrement (&dstIf->ICB_Stats.NetbiosSent);
			}
			status = STATUS_SUCCESS;
		}
		else {
			KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
			InterlockedIncrement (&dstIf->ICB_Stats.OutDiscards);
			status = STATUS_NETWORK_UNREACHABLE;
		}

		IPXInternalSendCompletProc (&pktTag->IPT_Target,
							pktTag->IPT_Packet,
							pktTag->IPT_Length,
							status);
		IpxFwdDbgPrint (DBG_INT_SEND,
				NT_SUCCESS (status) ? DBG_INFORMATION : DBG_WARNING,
				("IpxFwd: Returned internal packet %08lx"
				" for send on if %ld with status %08lx.\n",
				pktTag, dstIf->ICB_Index, status));
		ReleaseInterfaceReference (pktTag->IPT_InterfaceReference);
		ExFreePool (pktTag);
	}
}
			
		

/*++
*******************************************************************

	P r o c e s s E x t e r n a l Q u e u e

Routine Description:
	Processes packets in the interface external queue.
	Called when connection request completes
Arguments:
	dstIf - interface to process
Return Value:
	None
*******************************************************************
--*/
VOID
ProcessExternalQueue (
	PINTERFACE_CB	dstIf
	) {
	KIRQL						oldIRQL;
	LIST_ENTRY					tempQueue;

	KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
	InsertHeadList (&dstIf->ICB_ExternalQueue, &tempQueue);
	RemoveEntryList (&dstIf->ICB_ExternalQueue);
	InitializeListHead (&dstIf->ICB_ExternalQueue);
	KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);

	while (!IsListEmpty (&tempQueue)) {
		PPACKET_TAG					pktTag;
		PLIST_ENTRY					cur;
		NDIS_STATUS					status;

		cur = RemoveHeadList (&tempQueue);
		pktTag = CONTAINING_RECORD (cur, PACKET_TAG, PT_QueueLink);

		KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
		if (IS_IF_ENABLED(dstIf)
				&& (dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_UP)) {
			IPX_NODE_CPY (pktTag->PT_Target.MacAddress,
								dstIf->ICB_RemoteNode);
			if (*(pktTag->PT_Data + IPXH_PKTTYPE) == IPX_NETBIOS_TYPE) {
				PUTULONG (dstIf->ICB_Network, pktTag->PT_Data+IPXH_DESTNET);
			}
			status = DoSend (dstIf, pktTag, oldIRQL);
			IpxFwdDbgPrint (DBG_SEND, DBG_INFORMATION,
				("IpxFwd: Sent queued external packet %08lx if %ld.\n",
				pktTag, dstIf->ICB_Index));
		}
		else {
			KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
			IpxFwdDbgPrint (DBG_SEND, DBG_WARNING,
				("IpxFwd: Dropped queued external packet %08lx on dead if %ld.\n",
				pktTag, dstIf->ICB_Index));
			status = STATUS_UNSUCCESSFUL;
		}

		if (status!=STATUS_PENDING)
			ProcessSentPacket (dstIf, pktTag, status);
	}
}
			
		
/*++
*******************************************************************

	S p o o f e r

Routine Description:
	Processes packets in spoofing queue
Arguments:
	None
Return Value:
	None
*******************************************************************
--*/
VOID
Spoofer (
	PVOID	Context
	) {
	KIRQL		oldIRQL;
	NTSTATUS	status;
	UNREFERENCED_PARAMETER (Context);

	KeAcquireSpinLock (&SpoofingQueueLock, &oldIRQL);
		// Keep going till queue is empty
	while (!IsListEmpty (&SpoofingQueue)) {
		PINTERFACE_CB dstIf;
		PPACKET_TAG pktTag = CONTAINING_RECORD (SpoofingQueue.Flink,
										PACKET_TAG,
										PT_QueueLink);
		RemoveEntryList (&pktTag->PT_QueueLink);
		KeReleaseSpinLock (&SpoofingQueueLock, oldIRQL);
		dstIf = pktTag->PT_InterfaceReference;
		if (dstIf==NULL) {
				// Replies for internal server require first active LAN adapter
				// SHOULD BE REMOVED WHEN LOOPBACK SUPPORT US ADDED BY IPX
			while ((dstIf=GetNextInterfaceReference (dstIf))!=NULL) {
				KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
				if (IS_IF_ENABLED (dstIf)
						&& (dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_UP)
						&& (dstIf->ICB_InterfaceType==FWD_IF_PERMANENT)) {
					pktTag->PT_InterfaceReference = dstIf;
					IPX_NODE_CPY (&pktTag->PT_Target.MacAddress, dstIf->ICB_LocalNode);
					status = DoSend (dstIf, pktTag, oldIRQL);	// releases spin lock
					if (status!=STATUS_PENDING)
						ProcessSentPacket (dstIf, pktTag, status);
					break;
				}
				else
					KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
			}
			if (dstIf==NULL) {
				FreePacket (pktTag);
			}

		}
		else {	// Reply for external server, interface is already known
			UCHAR	addr[12];
            FILTER_ACTION   action;
			pktTag->PT_Flags &= (~PT_SOURCE_IF);
			
				// Switch source and destination
			memcpy (addr, pktTag->PT_Data+IPXH_DESTADDR, 12);
			memcpy (pktTag->PT_Data+IPXH_DESTADDR,
				pktTag->PT_Data+IPXH_SRCADDR, 12);
			memcpy (pktTag->PT_Data+IPXH_SRCADDR, addr, 12);
				// Say yes in reply
			*(pktTag->PT_Data+IPXH_HDRSIZE+1) = 'Y';

            action = FltFilter (pktTag->PT_Data,
					GETUSHORT (pktTag->PT_Data+IPXH_LENGTH),
					dstIf->ICB_FilterInContext,
					pktTag->PT_SourceIf->ICB_FilterOutContext);
			if (action==FILTER_PERMIT) {

					// Release destination if and use source as destination
				ReleaseInterfaceReference (dstIf);
				dstIf = pktTag->PT_InterfaceReference = pktTag->PT_SourceIf;
				// Send the packet if we can
				KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
				if (IS_IF_ENABLED (dstIf)
					&& (dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_UP)) {
					status = DoSend (dstIf, pktTag, oldIRQL);
					if (status!=STATUS_PENDING)
						ProcessSentPacket (dstIf, pktTag, status);
				}
				else {
					KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
					InterlockedIncrement (&dstIf->ICB_Stats.OutDiscards);
					ReleaseInterfaceReference (dstIf);
					FreePacket (pktTag);
				}
			}
			else {
                if (action==FILTER_DENY_OUT)
				    InterlockedIncrement (&pktTag->PT_SourceIf->ICB_Stats.OutFiltered);
                else {
                    ASSERT (action==FILTER_DENY_IN);
				    InterlockedIncrement (&dstIf->ICB_Stats.InFiltered);
                }
				ReleaseInterfaceReference (dstIf);
				ReleaseInterfaceReference (pktTag->PT_SourceIf);
				FreePacket (pktTag);
			}
		}
		KeAcquireSpinLock (&SpoofingQueueLock, &oldIRQL);
	} // end while
	SpoofingWorkerActive = FALSE;
	KeReleaseSpinLock (&SpoofingQueueLock, oldIRQL);
	LeaveForwarder ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\send.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\send.c

Abstract:
	Send routines

Author:

    Vadim Eydelman

Revision History:

--*/
#ifndef IPXFWD_SEND
#define IPXFWD_SEND

typedef struct _INTERNAL_PACKET_TAG {
	LIST_ENTRY			IPT_QueueLink;
	PNDIS_PACKET		IPT_Packet;
	PUCHAR				IPT_DataPtr;
	ULONG				IPT_Length;
	PINTERFACE_CB		IPT_InterfaceReference;
	IPX_LOCAL_TARGET	IPT_Target;
} INTERNAL_PACKET_TAG, *PINTERNAL_PACKET_TAG;


#define DEF_SPOOFING_TIMEOUT	(120*60)	// Seconds
extern ULONG			SpoofingTimeout;
extern LIST_ENTRY		SpoofingQueue;
extern KSPIN_LOCK		SpoofingQueueLock;
extern WORK_QUEUE_ITEM	SpoofingWorker;
extern BOOLEAN			SpoofingWorkerActive;
extern ULONG			DontSuppressNonAgentSapAdvertisements;
VOID
Spoofer (
	PVOID	Context
	);
	
#define InitializeSendQueue() {								\
	InitializeListHead (&SpoofingQueue);					\
	KeInitializeSpinLock (&SpoofingQueueLock);				\
	ExInitializeWorkItem (&SpoofingWorker, Spoofer, NULL);	\
	SpoofingWorkerActive = FALSE;							\
}

#define DeleteSendQueue()	{											\
	while (!IsListEmpty (&SpoofingQueue)) {								\
		PPACKET_TAG pktTag = CONTAINING_RECORD (SpoofingQueue.Flink,	\
										PACKET_TAG,						\
										PT_QueueLink);					\
		RemoveEntryList (&pktTag->PT_QueueLink);						\
		if (pktTag->PT_InterfaceReference!=NULL)						\
			ReleaseInterfaceReference (pktTag->PT_InterfaceReference);	\
		FreePacket (pktTag);											\
	}																	\
}
	

/*++
*******************************************************************
    S e n d P a c k e t 

Routine Description:
	Enqueues packets to be sent by IPX stack
Arguments:
	dstIf	- over which interface to send
	pktTag	- packet to send
Return Value:
	None

*******************************************************************
--*/
VOID
SendPacket (
	PINTERFACE_CB		dstIf,
	PPACKET_TAG		    pktTag
	);

/*++
*******************************************************************
    F w S e n d C o m p l e t e

Routine Description:
	Called by IPX stack when send completes asynchronously
Arguments:
	pktDscr	- descriptor of the completed packet
	status	- result of send operation
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdSendComplete (
	PNDIS_PACKET	pktDscr,
	NDIS_STATUS		NdisStatus
	);

/*++
*******************************************************************
	
	F w I n t e r n a l S e n d

Routine Description:
	Filter and routes packets sent by IPX stack
Arguments:
   LocalTarget		- the NicId and next hop router MAC address
   Context			- preferred interface on which to send
   Packet			- packet to be sent
   ipxHdr			- pointer to ipx header inside the packet
   PacketLength		- length of the packet
   fIterate         - a flag to indicate if this is a packet for the 
                        iteration of which the Fwd takes responsibility
                        - typically type 20 NetBIOS frames

Return Value:

   STATUS_SUCCESS - if the preferred NIC was OK and packet passed filtering
   STATUS_NETWORK_UNREACHABLE - if the preferred was not OK or packet failed filtering
   STATUS_PENDING - packet was queued until connection is established
*******************************************************************
--*/
NTSTATUS
IpxFwdInternalSend (
	IN OUT PIPX_LOCAL_TARGET	LocalTarget,
	IN ULONG_PTR				Context,
	IN PNDIS_PACKET				pktDscr,
	IN PUCHAR					ipxHdr,
	IN PUCHAR					data,
	IN ULONG					PacketLength,
    IN BOOLEAN                  fIterate
	);

/*++
*******************************************************************

	P r o c e s s I n t e r n a l Q u e u e

Routine Description:
	Processes packets in the interface internal queue.
	Called when connection request completes
Arguments:
	dstIf - interface to process
Return Value:
	None
*******************************************************************
--*/
VOID
ProcessInternalQueue (
	PINTERFACE_CB	dstIf
	);


/*++
*******************************************************************

	P r o c e s s E x t e r n a l Q u e u e

Routine Description:
	Processes packets in the interface external queue.
	Called when connection request completes
Arguments:
	dstIf - interface to process
Return Value:
	None
*******************************************************************
--*/
VOID
ProcessExternalQueue (
	PINTERFACE_CB	dstIf
	);
/*++
*******************************************************************
    D o S e n d 

Routine Description:
	Prepares and sends packet.  Interface lock must be help while
	callin this routine
Arguments:
	dstIf	- over which interface to send
	pktTag	- packet to send
Return Value:
	result returned by IPX

*******************************************************************
--*/
NDIS_STATUS
DoSend (
	PINTERFACE_CB	dstIf,
	PPACKET_TAG		pktTag,
	KIRQL			oldIRQL
	);

/*++
*******************************************************************
    P r o c e s s S e n t P a c k e t

Routine Description:
	Process completed sent packets
Arguments:
	dstIf	- interface over which packet was sent
	pktTag	- completed packet
	status	- result of send operation
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessSentPacket (
	PINTERFACE_CB	dstIf,
	PPACKET_TAG		pktTag,
	NDIS_STATUS		status
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\inc\isnnb.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    isnnb.h

Abstract:

    This module contains definitions specific to the
    Netbios module of the ISN transport.

Author:

    Adam Barr (adamba) 2-September-1993

Environment:

    Kernel mode

Revision History:


--*/


#define NB_MAXIMUM_MAC   40

#define NB_SOCKET       0x5504

#if     defined(_PNP_POWER)
#define NB_NETBIOS_NAME_SIZE    16

#define LOCK_ACQUIRED      TRUE
#define LOCK_NOT_ACQUIRED  FALSE
#endif  _PNP_POWER

//
// Defined granularity of find name timeouts in milliseconds --
// we make this the same as the spec'ed RIP gap to avoid
// flooding routers.
//

#define FIND_NAME_GRANULARITY  55


//
// Defines the number of milliseconds between expirations of the
// short and long timers.
//

#define MILLISECONDS         10000     // number of NT time units in one

#define SHORT_TIMER_DELTA      100
#define LONG_TIMER_DELTA      2000


//
// Convert a ushort netware order <-> machine order
//

#define REORDER_USHORT(_Ushort) ((((_Ushort) & 0xff00) >> 8) | (((_Ushort) & 0x00ff) << 8))

//
// Convert a ulong netware order <-> machine order
//

#define REORDER_ULONG(_Ulong) \
    ((((_Ulong) & 0xff000000) >> 24) | \
     (((_Ulong) & 0x00ff0000) >> 8) | \
     (((_Ulong) & 0x0000ff00) << 8) | \
     (((_Ulong) & 0x000000ff) << 24))



#include <packon.h>

#ifdef _PNP_POWER_
//
// This is the packaging for the data we send to TDI in TdiRegisterNetAddress
//
typedef struct _NBIPX_PNP_CONTEXT_
{
    TDI_PNP_CONTEXT TDIContext;
    PVOID           ContextData;
} NBIPX_PNP_CONTEXT, *PNBIPX_PNP_CONTEXT;
#endif  // _PNP_POWER_

//
// Definition of the Netbios header for name frames.
//

typedef struct _NB_NAME_FRAME {
    union {
        struct {
            UCHAR ConnectionControlFlag;
            UCHAR DataStreamType;
        };
        UCHAR RoutingInfo[32];
    };
    UCHAR NameTypeFlag;
    UCHAR DataStreamType2;
    UCHAR Name[16];
} NB_NAME_FRAME, *PNB_NAME_FRAME;

//
// Definition of the Netbios header for directed datagrams.
//

typedef struct _NB_DATAGRAM {
    UCHAR ConnectionControlFlag;
    UCHAR DataStreamType;
    UCHAR SourceName[16];
    UCHAR DestinationName[16];
} NB_DATAGRAM, *PNB_DATAGRAM;

//
// Definition of the Netbios header for a status query.
//

typedef struct _NB_STATUS_QUERY {
    UCHAR ConnectionControlFlag;
    UCHAR DataStreamType;
    UCHAR Padding[14];
} NB_STATUS_QUERY, *PNB_STATUS_QUERY;

//
// Definition of the Netbios header for a status response
// (this does not include the status buffer itself).
//

typedef struct _NB_STATUS_RESPONSE {
    UCHAR ConnectionControlFlag;
    UCHAR DataStreamType;
} NB_STATUS_RESPONSE, *PNB_STATUS_RESPONSE;


//
// Definition of the general Netbios connectionless header.
//

typedef struct _NB_CONNECTIONLESS {
    IPX_HEADER IpxHeader;
    union {
        NB_NAME_FRAME NameFrame;
        NB_DATAGRAM Datagram;
        NB_STATUS_QUERY StatusQuery;
        NB_STATUS_RESPONSE StatusResponse;
    };
} NB_CONNECTIONLESS, *PNB_CONNECTIONLESS;


//
// Definition of the Netbios session frame.
//

typedef struct _NB_SESSION {
    UCHAR ConnectionControlFlag;
    UCHAR DataStreamType;
    USHORT SourceConnectionId;
    USHORT DestConnectionId;
    USHORT SendSequence;
    USHORT TotalDataLength;
    USHORT Offset;
    USHORT DataLength;
    USHORT ReceiveSequence;
    union {
        USHORT BytesReceived;
        USHORT ReceiveSequenceMax;
    };
} NB_SESSION, *PNB_SESSION;


//
// Definition of the extra fields in a Netbios
// session frame for session init and session init
// ack.
//

typedef struct _NB_SESSION_INIT {
    UCHAR SourceName[16];
    UCHAR DestinationName[16];
    USHORT MaximumDataSize;
    USHORT MaximumPacketTime;
    USHORT StartTripTime;
} NB_SESSION_INIT, *PNB_SESSION_INIT;


//
// Definition of the general Netbios connection-oriented header.
//

typedef struct _NB_CONNECTION {
    IPX_HEADER IpxHeader;
    NB_SESSION Session;
} NB_CONNECTION, *PNB_CONNECTION;


//
// Definition of a Netbios packet.
//

typedef union _NB_FRAME {
    NB_CONNECTIONLESS Connectionless;
    NB_CONNECTION Connection;
} NB_FRAME, *PNB_FRAME;

#include <packoff.h>


//
// Definitions for the DataStreamType field, with the
// format used shown in the comment afterward.
//

#define NB_CMD_FIND_NAME           0x01   // NAME_FRAME
#define NB_CMD_NAME_RECOGNIZED     0x02   // NAME_FRAME
#define NB_CMD_ADD_NAME            0x03   // NAME_FRAME
#define NB_CMD_NAME_IN_USE         0x04   // NAME_FRAME
#define NB_CMD_DELETE_NAME         0x05   // NAME_FRAME
#define NB_CMD_SESSION_DATA        0x06   // SESSION
#define NB_CMD_SESSION_END         0x07   // SESSION
#define NB_CMD_SESSION_END_ACK     0x08   // SESSION
#define NB_CMD_STATUS_QUERY        0x09   // STATUS_QUERY
#define NB_CMD_STATUS_RESPONSE     0x0a   // STATUS_RESPONSE
#define NB_CMD_DATAGRAM            0x0b   // DATAGRAM
#define NB_CMD_BROADCAST_DATAGRAM  0x0c   // BROADCAST_DATAGRAM

#ifdef RSRC_TIMEOUT_DBG
#define NB_CMD_DEATH_PACKET        0x99   //
#endif // RSRC_TIMEOUT_DBG

//
// Bit values in the NameTypeFlag of NB_NAME_FRAME frames.
//

#define NB_NAME_UNIQUE        0x00
#define NB_NAME_GROUP         0x80
#define NB_NAME_USED          0x40
#define NB_NAME_REGISTERED    0x04
#define NB_NAME_DUPLICATED    0x02
#define NB_NAME_DEREGISTERED  0x01

//
// Bit values in the ConnectionControlFlag.
//

#define NB_CONTROL_SYSTEM     0x80
#define NB_CONTROL_SEND_ACK   0x40
#define NB_CONTROL_ATTENTION  0x20
#define NB_CONTROL_EOM        0x10
#define NB_CONTROL_RESEND     0x08
#define NB_CONTROL_NEW_NB     0x01



#define NB_DEVICE_SIGNATURE             0x1401
#if defined(_PNP_POWER)
#define NB_ADAPTER_ADDRESS_SIGNATURE    0x1403
#endif  _PNP_POWER
#define NB_ADDRESS_SIGNATURE            0x1404
#define NB_ADDRESSFILE_SIGNATURE        0x1405
#define NB_CONNECTION_SIGNATURE         0x1406


//
// Useful in various places.
//
#if     defined(_PNP_POWER)
extern IPX_LOCAL_TARGET BroadcastTarget;
#endif  _PNP_POWER
extern UCHAR BroadcastAddress[6];
extern UCHAR NetbiosBroadcastName[16];


//
// Contains the default handler for each of the TDI event types
// that are supported.
//

extern PVOID TdiDefaultHandlers[6];


//
// Define a structure that can track lock acquire/release.
//

typedef struct _NB_LOCK {
    CTELock Lock;
#if DBG
    ULONG LockAcquired;
    UCHAR LastAcquireFile[8];
    ULONG LastAcquireLine;
    UCHAR LastReleaseFile[8];
    ULONG LastReleaseLine;
#endif
} NB_LOCK, *PNB_LOCK;



#if DBG

extern ULONG NbiDebug;
extern ULONG NbiDebug2;
extern ULONG NbiMemoryDebug;

#define NB_MEMORY_LOG_SIZE 128
#define MAX_ARGLEN      80
#define TEMP_BUF_LEN    150

extern UCHAR NbiDebugMemory[NB_MEMORY_LOG_SIZE][MAX_ARGLEN];
extern PUCHAR NbiDebugMemoryLoc;
extern PUCHAR NbiDebugMemoryEnd;

VOID
NbiDebugMemoryLog(
    IN PUCHAR FormatString,
    ...
);

#define NB_DEBUG(_Flag, _Print) { \
    if (NbiDebug & (NB_DEBUG_ ## _Flag)) { \
        DbgPrint ("NBI: "); \
        DbgPrint _Print; \
    } \
    if (NbiMemoryDebug & (NB_DEBUG_ ## _Flag)) { \
        NbiDebugMemoryLog _Print; \
    } \
}

#define NB_DEBUG2(_Flag, _Print) { \
    if (NbiDebug2 & (NB_DEBUG_ ## _Flag)) { \
        DbgPrint ("NBI: "); \
        DbgPrint _Print; \
    } \
    if (NbiMemoryDebug & (NB_DEBUG_ ## _Flag)) { \
        NbiDebugMemoryLog _Print; \
    } \
}

#else

#define NB_DEBUG(_Flag, _Print)
#define NB_DEBUG2(_Flag, _Print)

#endif


//
// These definitions are for abstracting IRPs from the
// transport for portability.
//

#if ISN_NT

typedef IRP REQUEST, *PREQUEST;
typedef struct _REQUEST_LIST_HEAD {
    PREQUEST Head;   // list is empty if this is NULL
    PREQUEST Tail;   // undefined if the list is empty.
} REQUEST_LIST_HEAD, *PREQUEST_LIST_HEAD;


//
// PREQUEST
// NbiAllocateRequest(
//     IN PDEVICE Device,
//     IN PIRP Irp
// );
//
// Allocates a request for the system-specific request structure.
//

#define NbiAllocateRequest(_Device,_Irp) \
    (_Irp)


//
// BOOLEAN
// IF_NOT_ALLOCATED(
//     IN PREQUEST Request
// );
//
// Checks if a request was not successfully allocated.
//

#define IF_NOT_ALLOCATED(_Request) \
    if (0)


//
// VOID
// NbiFreeRequest(
//     IN PDEVICE Device,
//     IN PREQUEST Request
// );
//
// Frees a previously allocated request.
//

#define NbiFreeRequest(_Device,_Request) \
    ;


//
// VOID
// MARK_REQUEST_PENDING(
//     IN PREQUEST Request
// );
//
// Marks that a request will pend.
//

#define MARK_REQUEST_PENDING(_Request) \
    IoMarkIrpPending(_Request)


//
// VOID
// UNMARK_REQUEST_PENDING(
//     IN PREQUEST Request
// );
//
// Marks that a request will not pend.
//

#define UNMARK_REQUEST_PENDING(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->Control) &= ~SL_PENDING_RETURNED)


//
// UCHAR
// REQUEST_MAJOR_FUNCTION
//     IN PREQUEST Request
// );
//
// Returns the major function code of a request.
//

#define REQUEST_MAJOR_FUNCTION(_Request) \
    ((IoGetCurrentIrpStackLocation(_Request))->MajorFunction)


//
// UCHAR
// REQUEST_MINOR_FUNCTION
//     IN PREQUEST Request
// );
//
// Returns the minor function code of a request.
//

#define REQUEST_MINOR_FUNCTION(_Request) \
    ((IoGetCurrentIrpStackLocation(_Request))->MinorFunction)


//
// PNDIS_BUFFER
// REQUEST_NDIS_BUFFER
//     IN PREQUEST Request
// );
//
// Returns the NDIS buffer chain associated with a request.
//

#define REQUEST_NDIS_BUFFER(_Request) \
    ((PNDIS_BUFFER)((_Request)->MdlAddress))


//
// PVOID
// REQUEST_OPEN_CONTEXT(
//     IN PREQUEST Request
// );
//
// Gets the context associated with an opened address/connection/control channel.
//

#define REQUEST_OPEN_CONTEXT(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->FileObject)->FsContext)


//
// PVOID
// REQUEST_OPEN_TYPE(
//     IN PREQUEST Request
// );
//
// Gets the type associated with an opened address/connection/control channel.
//

#define REQUEST_OPEN_TYPE(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->FileObject)->FsContext2)


//
// PFILE_FULL_EA_INFORMATION
// OPEN_REQUEST_EA_INFORMATION(
//     IN PREQUEST Request
// );
//
// Returns the EA information associated with an open/close request.
//

#define OPEN_REQUEST_EA_INFORMATION(_Request) \
    ((PFILE_FULL_EA_INFORMATION)((_Request)->AssociatedIrp.SystemBuffer))


//
// PTDI_REQUEST_KERNEL
// REQUEST_PARAMETERS(
//     IN PREQUEST Request
// );
//
// Obtains a pointer to the parameters of a request.
//

#define REQUEST_PARAMETERS(_Request) \
    (&((IoGetCurrentIrpStackLocation(_Request))->Parameters))


//
// PLIST_ENTRY
// REQUEST_LINKAGE(
//     IN PREQUEST Request
// );
//
// Returns a pointer to a linkage field in the request.
//

#define REQUEST_LINKAGE(_Request) \
    (&((_Request)->Tail.Overlay.ListEntry))


//
// PREQUEST
// REQUEST_SINGLE_LINKAGE(
//     IN PREQUEST Request
// );
//
// Used to access a single list linkage field in the request.
//

#define REQUEST_SINGLE_LINKAGE(_Request) \
    (*((PREQUEST *)&((_Request)->Tail.Overlay.ListEntry.Flink)))


//
// ULONG
// REQUEST_REFCOUNT(
//     IN PREQUEST Request
// );
//
// Used to access a field in the request which can be used for
// the reference count, as long as it is on a REQUEST_LIST.
//

#define REQUEST_REFCOUNT(_Request) \
    (*((PULONG)&((_Request)->Tail.Overlay.ListEntry.Blink)))


//
// VOID
// REQUEST_LIST_INSERT_TAIL(
//     IN PREQUEST_LIST_HEAD Head,
//     IN PREQUEST Entry
// );
//
// Inserts a request into a single list linkage queue.
//

#define REQUEST_LIST_INSERT_TAIL(_Head,_Entry) { \
    if ((_Head)->Head == NULL) { \
        (_Head)->Head = (_Entry); \
        (_Head)->Tail = (_Entry); \
    } else { \
        REQUEST_SINGLE_LINKAGE((_Head)->Tail) = (_Entry); \
        (_Head)->Tail = (_Entry); \
    } \
}


//
// PREQUEST
// LIST_ENTRY_TO_REQUEST(
//     IN PLIST_ENTRY ListEntry
// );
//
// Returns a request given a linkage field in it.
//

#define LIST_ENTRY_TO_REQUEST(_ListEntry) \
    ((PREQUEST)(CONTAINING_RECORD(_ListEntry, REQUEST, Tail.Overlay.ListEntry)))


//
// NTSTATUS
// REQUEST_STATUS(
//     IN PREQUEST Request
// );
//
// Used to access the status field of a request.
//

#define REQUEST_STATUS(_Request) \
    (_Request)->IoStatus.Status

//
// NTSTATUS
// REQUEST_STATUSPTR(
//     IN PREQUEST Request
// );
//
// Used to access the status field of a request.
//

#define REQUEST_STATUSPTR(_Request) \
    (_Request)->IoStatus.Pointer


//
// ULONG
// REQUEST_INFORMATION(
//     IN PREQUEST Request)
// );
//
// Used to access the information field of a request.
//

#define REQUEST_INFORMATION(_Request) \
    (_Request)->IoStatus.Information


//
// VOID
// NbiCompleteRequest(
//     IN PREQUEST Request
// );
//
// Completes a request whose status and information fields have
// been filled in.
//

#define NbiCompleteRequest(_Request) \
    IoCompleteRequest (_Request, IO_NETWORK_INCREMENT)

#else

//
// These routines must be defined for portability to a VxD.
//

#endif

//
// some utility macros.

// Minimum of two
//
#define NB_MIN( _a , _b )    ( ( (_a) < (_b) ) ? (_a) : (_b) )

//
// Swap the _s1 and _s2 of Type _T
//

#define NB_SWAP(_s1, _s2, _T) {                         \
    _T  _temp;                                          \
    _temp   = (_s1);                                    \
    (_s1)   = (_s2);                                    \
    (_s2)   = _temp;                                    \
}

#define NB_SWAP_IRQL( _s1, _s2 )   NB_SWAP( _s1, _s2, CTELockHandle )

//
// Define our own spinlock routines.
//

#if DBG

#define NB_GET_LOCK(_Lock, _LockHandle) { \
    CTEGetLock(&(_Lock)->Lock, _LockHandle); \
    (_Lock)->LockAcquired = TRUE; \
    strncpy((_Lock)->LastAcquireFile, strrchr(__FILE__,'\\')+1, 7); \
    (_Lock)->LastAcquireLine = __LINE__; \
}

#define NB_FREE_LOCK(_Lock, _LockHandle) { \
    (_Lock)->LockAcquired = FALSE; \
    strncpy((_Lock)->LastReleaseFile, strrchr(__FILE__,'\\')+1, 7); \
    (_Lock)->LastReleaseLine = __LINE__; \
    CTEFreeLock(&(_Lock)->Lock, _LockHandle); \
}

#define NB_GET_LOCK_DPC(_Lock) { \
    ExAcquireSpinLockAtDpcLevel(&(_Lock)->Lock); \
    (_Lock)->LockAcquired = TRUE; \
    strncpy((_Lock)->LastAcquireFile, strrchr(__FILE__,'\\')+1, 7); \
    (_Lock)->LastAcquireLine = __LINE__; \
}

#define NB_FREE_LOCK_DPC(_Lock) { \
    (_Lock)->LockAcquired = FALSE; \
    strncpy((_Lock)->LastReleaseFile, strrchr(__FILE__,'\\')+1, 7); \
    (_Lock)->LastReleaseLine = __LINE__; \
    ExReleaseSpinLockFromDpcLevel(&(_Lock)->Lock); \
}

#else

#define NB_GET_LOCK(_Lock, _LockHandle) CTEGetLock(&(_Lock)->Lock, _LockHandle)
#define NB_FREE_LOCK(_Lock, _LockHandle) CTEFreeLock(&(_Lock)->Lock, _LockHandle)
#define NB_GET_LOCK_DPC(_Lock) ExAcquireSpinLockAtDpcLevel(&(_Lock)->Lock)
#define NB_FREE_LOCK_DPC(_Lock) ExReleaseSpinLockFromDpcLevel(&(_Lock)->Lock)

#endif


#define NB_GET_CANCEL_LOCK( _LockHandle ) IoAcquireCancelSpinLock( _LockHandle )

#define NB_FREE_CANCEL_LOCK( _LockHandle ) IoReleaseCancelSpinLock( _LockHandle )


//
// Routines to optimize for a uni-processor environment.
//


#define NB_INCREMENT(_Long, _Lock)  InterlockedIncrement(_Long)
#define NB_DECREMENT(_Long, _Lock)  InterlockedDecrement(_Long)

#define NB_ADD_ULONG(_Pulong, _Ulong, _Lock)  ExInterlockedAddUlong(_Pulong, _Ulong, &(_Lock)->Lock)

#define NB_DEFINE_SYNC_CONTEXT(_SyncContext)
#define NB_BEGIN_SYNC(_SyncContext)
#define NB_END_SYNC(_SyncContext)

#define NB_DEFINE_LOCK_HANDLE(_LockHandle) CTELockHandle _LockHandle;

//
// Make these be NB_XXX_LOCK_DPC calls -- then the definitions
// of the NB_SYNC_XXX_LOCK calls can be changed to not need _LockHandle
// and many of the functions won't need that as a parameter.
//

#define NB_SYNC_GET_LOCK(_Lock, _LockHandle) NB_GET_LOCK(_Lock, _LockHandle)
#define NB_SYNC_FREE_LOCK(_Lock, _LockHandle) NB_FREE_LOCK(_Lock, _LockHandle)

#define NB_REMOVE_HEAD_LIST(_Queue, _Lock)   ExInterlockedRemoveHeadList(_Queue, &(_Lock)->Lock)
#define NB_LIST_WAS_EMPTY(_Queue, _OldHead)  ((_OldHead) == NULL)
#define NB_INSERT_HEAD_LIST(_Queue, _Entry, _Lock)   ExInterlockedInsertHeadList(_Queue, _Entry, &(_Lock)->Lock)
#define NB_INSERT_TAIL_LIST(_Queue, _Entry, _Lock)   ExInterlockedInsertTailList(_Queue, _Entry, &(_Lock)->Lock)

#define NB_POP_ENTRY_LIST(_Queue, _Lock)           ExInterlockedPopEntryList(_Queue, &(_Lock)->Lock)
#define NB_PUSH_ENTRY_LIST(_Queue, _Entry, _Lock)  ExInterlockedPushEntryList(_Queue, _Entry, &(_Lock)->Lock)

#define NB_LOCK_HANDLE_PARAM(_LockHandle)   , IN CTELockHandle _LockHandle
#define NB_LOCK_HANDLE_ARG(_LockHandle)     , (_LockHandle)

#define NB_SYNC_SWAP_IRQL( _s1, _s2 )   NB_SWAP( _s1, _s2, CTELockHandle )


//
// This macro adds a ULONG to a LARGE_INTEGER (should be
// called with a spinlock held).
//

#define ADD_TO_LARGE_INTEGER(_LargeInteger,_Ulong) \
    ExInterlockedAddLargeStatistic((_LargeInteger),(ULONG)(_Ulong))

#define NB_DEBUG_DEVICE              0x00000001
#define NB_DEBUG_ADDRESS             0x00000004
#define NB_DEBUG_SEND                0x00000008
#define NB_DEBUG_RECEIVE             0x00000020
#define NB_DEBUG_CONFIG              0x00000040
#define NB_DEBUG_PACKET              0x00000080
#define NB_DEBUG_BIND                0x00000200
#define NB_DEBUG_ADDRESS_FRAME       0x00000400
#define NB_DEBUG_CONNECTION          0x00000800
#define NB_DEBUG_QUERY               0x00001000
#define NB_DEBUG_DRIVER              0x00002000
#define NB_DEBUG_CACHE               0x00004000
#define NB_DEBUG_DATAGRAM            0x00008000
#define NB_DEBUG_TIMER               0x00010000
#define NB_DEBUG_SEND_WINDOW         0x00020000



//
// NB_GET_NBHDR_BUFF - gets the nb header in the packet.  It is always the
// second buffer.
//
#define  NB_GET_NBHDR_BUFF(Packet)  (NDIS_BUFFER_LINKAGE((Packet)->Private.Head))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\inc\isn.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    isn.h

Abstract:

    Private include file for the ISN transport.

Author:

    Adam Barr (adamba) 08-Sep-1993

Revision History:

--*/


#define ISN_NT 1


//
// These are needed for CTE
//

#if DBG
#define DEBUG 1
#endif

#define NT 1


#include <ntddk.h>
#include <tdikrnl.h>
#include <ndis.h>
#include <cxport.h>
#include <bind.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\action.c ===
/*++
Copyright (c) 1989-1993 Microsoft Corporation

Module Name:

    action.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiAction

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <packon.h>

//
// Line ups when indicated up should have this length subtracted from the
// max. send size that ndis indicated to us for the line
//
#define HDR_LEN_802_3                14
#define ASYNC_MEDIUM_HDR_LEN         HDR_LEN_802_3

typedef struct _GET_PKT_SIZE {
    ULONG Unknown;
    ULONG MaxDatagramSize;
} GET_PKT_SIZE, *PGET_PKT_SIZE;


//
// These structures are used to set and query information
// about our source routing table.
//

typedef struct _SR_GET_PARAMETERS {
    ULONG BoardNumber;    // 0-based
    ULONG SrDefault;      // 0 = single route, 1 = all routes
    ULONG SrBroadcast;
    ULONG SrMulticast;
} SR_GET_PARAMETERS, *PSR_GET_PARAMETERS;

typedef struct _SR_SET_PARAMETER {
    ULONG BoardNumber;    // 0-based
    ULONG Parameter;      // 0 = single route, 1 = all routes
} SR_SET_PARAMETER, *PSR_SET_PARAMETER;

typedef struct _SR_SET_REMOVE {
    ULONG BoardNumber;    // 0-based
    UCHAR MacAddress[6];  // remote to drop routing for
} SR_SET_REMOVE, *PSR_SET_REMOVE;

typedef struct _SR_SET_CLEAR {
    ULONG BoardNumber;    // 0-based
} SR_SET_CLEAR, *PSR_SET_CLEAR;

#include <packoff.h>

NTSTATUS
IpxTdiAction(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiAction request for the transport
    provider.

Arguments:

    Device - The device for the operation.

    Request - Describes the action request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status;
    PADDRESS_FILE AddressFile;
    UINT BufferLength;
    UINT DataLength;
    PNDIS_BUFFER NdisBuffer;
    CTELockHandle LockHandle;
    PBINDING Binding, MasterBinding;
    PADAPTER Adapter;
    union {
        PISN_ACTION_GET_LOCAL_TARGET GetLocalTarget;
        PISN_ACTION_GET_NETWORK_INFO GetNetworkInfo;
        PISN_ACTION_GET_DETAILS GetDetails;
        PSR_GET_PARAMETERS GetSrParameters;
        PSR_SET_PARAMETER SetSrParameter;
        PSR_SET_REMOVE SetSrRemove;
        PSR_SET_CLEAR SetSrClear;
        PIPX_ADDRESS_DATA IpxAddressData;
        PGET_PKT_SIZE GetPktSize;
        PIPX_NETNUM_DATA IpxNetnumData;
        PIPX_QUERY_WAN_INACTIVITY   QueryWanInactivity;
        PIPXWAN_CONFIG_DONE IpxwanConfigDone;
    } u;    // Make these unaligned??
    PIPX_ROUTE_ENTRY RouteEntry;
    PNWLINK_ACTION NwlinkAction;
    ULONG Segment;
    ULONG AdapterNum;
    static UCHAR BogusId[4] = { 0x01, 0x00, 0x00, 0x00 };   // old nwrdr uses this
    IPX_FIND_ROUTE_REQUEST routeEntry;

	IPX_DEFINE_LOCK_HANDLE(LockHandle1)

    //
    // To maintain some compatibility with the NWLINK streams-
    // based transport, we use the streams header format for
    // our actions. The old transport expected the action header
    // to be in InputBuffer and the output to go in OutputBuffer.
    // We follow the TDI spec, which states that OutputBuffer
    // is used for both input and output. Since IOCTL_TDI_ACTION
    // is method out direct, this means that the output buffer
    // is mapped by the MDL chain; for action the chain will
    // only have one piece so we use it for input and output.
    //

    NdisBuffer = REQUEST_NDIS_BUFFER(Request);
    if (NdisBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    NdisQueryBufferSafe (REQUEST_NDIS_BUFFER(Request), (PVOID *)&NwlinkAction, &BufferLength, NormalPagePriority);

    if (NwlinkAction == NULL) {
       return STATUS_INSUFFICIENT_RESOURCES; 
    } 

    //
    // Make sure we have enough room for just the header not
    // including the data.
    //

    if (BufferLength < (UINT)(FIELD_OFFSET(NWLINK_ACTION, Data[0]))) {
        IPX_DEBUG (ACTION, ("Nwlink action failed, buffer too small\n"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    if ((!RtlEqualMemory ((PVOID) (UNALIGNED ULONG *) (&NwlinkAction->Header.TransportId), "MISN", 4)) &&
        (!RtlEqualMemory ((PVOID) (UNALIGNED ULONG *) (&NwlinkAction->Header.TransportId), "MIPX", 4)) &&
        (!RtlEqualMemory ((PVOID) (UNALIGNED ULONG *) (&NwlinkAction->Header.TransportId), "XPIM", 4)) &&
        (!RtlEqualMemory ((PVOID) (UNALIGNED ULONG *) (&NwlinkAction->Header.TransportId), BogusId, 4))) {

        return STATUS_NOT_SUPPORTED;
    }

    DataLength = BufferLength - FIELD_OFFSET(NWLINK_ACTION, Data[0]);


    //
    // Make sure that the correct file object is being used.
    //

    if (NwlinkAction->OptionType == NWLINK_OPTION_ADDRESS) {

        if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_TRANSPORT_ADDRESS_FILE) {
            IPX_DEBUG (ACTION, ("Nwlink action failed, not address file\n"));
            return STATUS_INVALID_HANDLE;
        }

        AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);

        if ((AddressFile->Size != sizeof (ADDRESS_FILE)) ||
            (AddressFile->Type != IPX_ADDRESSFILE_SIGNATURE)) {

            IPX_DEBUG (ACTION, ("Nwlink action failed, bad address file\n"));
            return STATUS_INVALID_HANDLE;
        }

    } else if (NwlinkAction->OptionType != NWLINK_OPTION_CONTROL) {

        IPX_DEBUG (ACTION, ("Nwlink action failed, option type %d\n", NwlinkAction->OptionType));
        return STATUS_NOT_SUPPORTED;
    }


    //
    // Handle the requests based on the action code. For these
    // requests ActionHeader->ActionCode is 0, we use the
    // Option field in the streams header instead.
    //


    Status = STATUS_SUCCESS;

    switch (NwlinkAction->Option) {

       IPX_DEBUG (ACTION, ("NwlinkAction->Option is (%x)\n", NwlinkAction->Option));
    //DbgPrint("NwlinkAction->Option is (%x)\n", NwlinkAction->Option);
    //
    // This first group support the winsock helper dll.
    // In most cases the corresponding sockopt is shown in
    // the comment, as well as the contents of the Data
    // part of the action buffer.
    //

    case MIPX_SETSENDPTYPE:

        //
        // IPX_PTYPE: Data is a single byte packet type.
        //

        if (DataLength >= 1) {
            IPX_DEBUG (ACTION, ("%lx: MIPX_SETSENDPTYPE %x\n", AddressFile, NwlinkAction->Data[0]));
            AddressFile->DefaultPacketType = NwlinkAction->Data[0];
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    case MIPX_FILTERPTYPE:

        //
        // IPX_FILTERPTYPE: Data is a single byte to filter on.
        //

        if (DataLength >= 1) {
            IPX_DEBUG (ACTION, ("%lx: MIPX_FILTERPTYPE %x\n", AddressFile, NwlinkAction->Data[0]));
            AddressFile->FilteredType = NwlinkAction->Data[0];
            AddressFile->FilterOnPacketType = TRUE;
            AddressFile->SpecialReceiveProcessing = TRUE;
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    case MIPX_NOFILTERPTYPE:

        //
        // IPX_STOPFILTERPTYPE.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NOFILTERPTYPE\n", AddressFile));
        AddressFile->FilterOnPacketType = FALSE;
        AddressFile->SpecialReceiveProcessing = (BOOLEAN)
            (AddressFile->ExtendedAddressing || AddressFile->ReceiveFlagsAddressing ||
            AddressFile->ReceiveIpxHeader || AddressFile->IsSapSocket);
        break;

    case MIPX_SENDADDROPT:

        //
        // IPX_EXTENDED_ADDRESS (TRUE).
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_SENDADDROPT\n", AddressFile));
        AddressFile->ExtendedAddressing = TRUE;
        AddressFile->SpecialReceiveProcessing = TRUE;
        break;

    case MIPX_NOSENDADDROPT:

        //
        // IPX_EXTENDED_ADDRESS (FALSE).
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NOSENDADDROPT\n", AddressFile));
        AddressFile->ExtendedAddressing = FALSE;
        AddressFile->SpecialReceiveProcessing = (BOOLEAN)
            (AddressFile->ReceiveFlagsAddressing || AddressFile->ReceiveIpxHeader ||
            AddressFile->FilterOnPacketType || AddressFile->IsSapSocket);
        break;

#if 0
    case MIPX_SETNIC:

        //
        // IPX_NIC_ADDRESS TRUE
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_SETNIC\n", AddressFile));
        AddressFile->NicAddressing            = TRUE;
        AddressFile->SpecialReceiveProcessing = TRUE;
        break;

    case MIPX_NOSETNIC:

        //
        // IPX_NIC_ADDRESS (FALSE).
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NOSETNIC\n", AddressFile));
        AddressFile->NicAddressing = FALSE;
        AddressFile->SpecialReceiveProcessing = (BOOLEAN)
            (AddressFile->ReceiveFlagsAddressing ||
                    AddressFile->ReceiveIpxHeader ||
            AddressFile->FilterOnPacketType || AddressFile->IsSapSocket ||
             AddressFile->NicAddressing);
        break;
#endif

    case MIPX_SETRCVFLAGS:

        //
        // No sockopt yet.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_SETRCVFLAGS\n", AddressFile));
        AddressFile->ReceiveFlagsAddressing = TRUE;
        AddressFile->SpecialReceiveProcessing = TRUE;
        break;

    case MIPX_NORCVFLAGS:

        //
        // No sockopt yet.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NORCVFLAGS\n", AddressFile));
        AddressFile->ReceiveFlagsAddressing = FALSE;
        AddressFile->SpecialReceiveProcessing = (BOOLEAN)
            (AddressFile->ExtendedAddressing || AddressFile->ReceiveIpxHeader ||
            AddressFile->FilterOnPacketType || AddressFile->IsSapSocket);
        break;

    case MIPX_SENDHEADER:

        //
        // IPX_RECVHDR (TRUE);
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_SENDHEADER\n", AddressFile));
        AddressFile->ReceiveIpxHeader = TRUE;
        AddressFile->SpecialReceiveProcessing = TRUE;
        break;

    case MIPX_NOSENDHEADER:

        //
        // IPX_RECVHDR (FALSE);
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NOSENDHEADER\n", AddressFile));
        AddressFile->ReceiveIpxHeader = FALSE;
        AddressFile->SpecialReceiveProcessing = (BOOLEAN)
            (AddressFile->ExtendedAddressing || AddressFile->ReceiveFlagsAddressing ||
            AddressFile->FilterOnPacketType || AddressFile->IsSapSocket);
        break;

    case MIPX_RCVBCAST:

        //
        // Broadcast reception enabled.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_RCVBCAST\n", AddressFile));
        
        //
        // It's enabled by default now
        // 
        /*

        CTEGetLock (&Device->Lock, &LockHandle);

        if (!AddressFile->EnableBroadcast) {

            AddressFile->EnableBroadcast = TRUE;
            IpxAddBroadcast (Device);
        }

        CTEFreeLock (&Device->Lock, LockHandle);
        */
        break;

    case MIPX_NORCVBCAST:

        //
        // Broadcast reception disabled.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NORCVBCAST\n", AddressFile));
        //
        // It's enabled by default now
        // 
        /*

        CTEGetLock (&Device->Lock, &LockHandle);

        if (AddressFile->EnableBroadcast) {

            AddressFile->EnableBroadcast = FALSE;
            IpxRemoveBroadcast (Device);
        }

        CTEFreeLock (&Device->Lock, LockHandle);
        */
        break;

    case MIPX_GETPKTSIZE:

        //
        // IPX_MAXSIZE.
        //
        // Figure out what the first length is for.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_GETPKTSIZE\n", AddressFile));
        if (DataLength >= sizeof(GET_PKT_SIZE)) {
            u.GetPktSize = (PGET_PKT_SIZE)(NwlinkAction->Data);
            u.GetPktSize->Unknown = 0;
            u.GetPktSize->MaxDatagramSize = Device->Information.MaxDatagramSize;
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    case MIPX_ADAPTERNUM:

        //
        // IPX_MAX_ADAPTER_NUM.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_ADAPTERNUM\n", AddressFile));
        if (DataLength >= sizeof(ULONG)) {
            *(UNALIGNED ULONG *)(NwlinkAction->Data) = Device->SapNicCount;
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    case MIPX_ADAPTERNUM2:

        //
        // IPX_MAX_ADAPTER_NUM.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_ADAPTERNUM2\n", AddressFile));
        if (DataLength >= sizeof(ULONG)) {
            *(UNALIGNED ULONG *)(NwlinkAction->Data) = MIN (Device->MaxBindings, Device->ValidBindings);
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    case MIPX_GETCARDINFO:
    case MIPX_GETCARDINFO2:

        //
        // GETCARDINFO is IPX_ADDRESS.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_GETCARDINFO (%d)\n",
                    AddressFile, *(UNALIGNED UINT *)NwlinkAction->Data));
        if (DataLength >= sizeof(IPX_ADDRESS_DATA)) {
            u.IpxAddressData = (PIPX_ADDRESS_DATA)(NwlinkAction->Data);
            AdapterNum = u.IpxAddressData->adapternum+1;

            if (((AdapterNum >= 1) && (AdapterNum <= Device->SapNicCount)) ||
                ((NwlinkAction->Option == MIPX_GETCARDINFO2) && (AdapterNum <= (ULONG) MIN (Device->MaxBindings, Device->ValidBindings)))) {

// Get lock
				IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

                Binding = NIC_ID_TO_BINDING(Device, AdapterNum);
                if (Binding == NULL) {

                    //
                    // This should be a binding in the WAN range
                    // of an adapter which is currently not
                    // allocated. We scan back to the previous
                    // non-NULL binding, which should be on the
                    // same adapter, and return a down line with
                    // the same characteristics as that binding.
                    //

                    UINT i = AdapterNum;

                    do {
                        --i;
                        Binding = NIC_ID_TO_BINDING(Device, i);
                    } while (Binding == NULL);

                    //CTEAssert (Binding->Adapter->MacInfo.MediumAsync);
                    //CTEAssert (i >= Binding->Adapter->FirstWanNicId);
                    //CTEAssert (AdapterNum <= Binding->Adapter->LastWanNicId);
                    // take out assertion because srv might have gotten the number
                    // of adapters before we finished bindadapters.

                    u.IpxAddressData->status = FALSE;
                    *(UNALIGNED ULONG *)u.IpxAddressData->netnum = Binding->LocalAddress.NetworkAddress;

                } else {

                    if ((Binding->Adapter->MacInfo.MediumAsync) &&
                        (Device->WanGlobalNetworkNumber)) {

                        //
                        // In this case we make it look like one big wan
                        // net, so the line is "up" or "down" depending
                        // on whether we have given him the first indication
                        // or not.
                        //

                        u.IpxAddressData->status = Device->GlobalNetworkIndicated;
                        *(UNALIGNED ULONG *)u.IpxAddressData->netnum = Device->GlobalWanNetwork;

                    } else {
#ifdef SUNDOWN
			      u.IpxAddressData->status = (unsigned char) Binding->LineUp;
#else
			      u.IpxAddressData->status = Binding->LineUp;
#endif

                       
                        *(UNALIGNED ULONG *)u.IpxAddressData->netnum = Binding->LocalAddress.NetworkAddress;
                    }

                }

                RtlCopyMemory(u.IpxAddressData->nodenum, Binding->LocalAddress.NodeAddress, 6);

                Adapter = Binding->Adapter;
                u.IpxAddressData->wan = Adapter->MacInfo.MediumAsync;
                u.IpxAddressData->maxpkt =
                    (NwlinkAction->Option == MIPX_GETCARDINFO) ?
                        Binding->AnnouncedMaxDatagramSize :
                        Binding->RealMaxDatagramSize;
                u.IpxAddressData->linkspeed = Binding->MediumSpeed;
			   IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            } else {

                Status = STATUS_INVALID_PARAMETER;
            }

        } else {
#if 1
            //
            // Support the old format query for now.
            //

            typedef struct _IPX_OLD_ADDRESS_DATA {
                UINT adapternum;
                UCHAR netnum[4];
                UCHAR nodenum[6];
            } IPX_OLD_ADDRESS_DATA, *PIPX_OLD_ADDRESS_DATA;

            if (DataLength >= sizeof(IPX_OLD_ADDRESS_DATA)) {
                u.IpxAddressData = (PIPX_ADDRESS_DATA)(NwlinkAction->Data);
                AdapterNum = u.IpxAddressData->adapternum+1;

                if ((AdapterNum >= 1) && (AdapterNum <= Device->SapNicCount)) {
					IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
					if (Binding = NIC_ID_TO_BINDING(Device, AdapterNum)) {
						*(UNALIGNED ULONG *)u.IpxAddressData->netnum = Binding->LocalAddress.NetworkAddress;
						RtlCopyMemory(u.IpxAddressData->nodenum, Binding->LocalAddress.NodeAddress, 6);
					} else {
						Status = STATUS_INVALID_PARAMETER;
					}
					IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
               } else {
                    Status = STATUS_INVALID_PARAMETER;
               }
            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
#else
            Status = STATUS_BUFFER_TOO_SMALL;
#endif
        }
        break;

    case MIPX_NOTIFYCARDINFO:

        //
        // IPX_ADDRESS_NOTIFY.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NOTIFYCARDINFO (%lx)\n", AddressFile, Request));

        CTEGetLock (&Device->Lock, &LockHandle);

        //
        // If the device is open and there is room in the
        // buffer for the data, insert it in our queue.
        // It will be completed when a change happens or
        // the driver is unloaded.
        //

        if (Device->State == DEVICE_STATE_OPEN) {
            if (DataLength >= sizeof(IPX_ADDRESS_DATA)) {
                InsertTailList(
                    &Device->AddressNotifyQueue,
                    REQUEST_LINKAGE(Request)
                );
                IoSetCancelRoutine (Request, IpxCancelAction);

		// If IO Manager calls the cancel routine, then it will
		// set the cancel routine to be NULL. 
		// IoSetCancelRoutine returns the previous cancel 
		// routine, if the return value is null, then IO Manager
		// has called the cancel routine. If not null, then 
		// the cancel routine has not been called and the irp 
		// was canceled before we set the cancel routine. 

                if (Request->Cancel && 
		    IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL) != NULL) {

                    (VOID)RemoveTailList (&Device->AddressNotifyQueue);
                    Status = STATUS_CANCELLED;
                
		} else {
                    IpxReferenceDevice (Device, DREF_ADDRESS_NOTIFY);
                    Status = STATUS_PENDING;
                }
            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        } else {
            Status = STATUS_DEVICE_NOT_READY;
        }

        CTEFreeLock (&Device->Lock, LockHandle);

        break;

    case MIPX_LINECHANGE:

        //
        // IPX_ADDRESS_NOTIFY.
        //

        IPX_DEBUG (ACTION, ("MIPX_LINECHANGE (%lx)\n", Request));

        CTEGetLock (&Device->Lock, &LockHandle);

        //
        // If the device is open and there is room in the
        // buffer for the data, insert it in our queue.
        // It will be completed when a change happens or
        // the driver is unloaded.
        //

        if (Device->State == DEVICE_STATE_OPEN) {

            InsertTailList(
                &Device->LineChangeQueue,
                REQUEST_LINKAGE(Request)
            );

            IoSetCancelRoutine (Request, IpxCancelAction);
            if (Request->Cancel && 
		IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL) != NULL) {

                (VOID)RemoveTailList (&Device->LineChangeQueue);
                Status = STATUS_CANCELLED;
            
	    } else {
                IpxReferenceDevice (Device, DREF_LINE_CHANGE);
                Status = STATUS_PENDING;
            }
        } else {
            Status = STATUS_DEVICE_NOT_READY;
        }

        CTEFreeLock (&Device->Lock, LockHandle);

        break;

    case MIPX_GETNETINFO_NR:

        //
        // A request for network information about the immediate
        // route to a network (this is called by sockets apps).
        //

        if (DataLength < sizeof(IPX_NETNUM_DATA)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        u.IpxNetnumData = (PIPX_NETNUM_DATA)(NwlinkAction->Data);

        //
        // A query on network 0 means that the caller wants
        // information about our directly attached net.
        //

        if (*(UNALIGNED ULONG *)u.IpxNetnumData->netnum == 0) {

            //
            // The tick count is the number of 1/18.21 second ticks
            // it takes to deliver a 576-byte packet. Our link speed
            // is in 100 bit-per-second units. We calculate it as
            // follows (LS is the LinkSpeed):
            //
            // 576 bytes   8 bits       1 second     1821 ticks
            //           * ------  * ------------- * ----------
            //             1 byte    LS * 100 bits   100 seconds
            //
            // which becomes 839 / LinkSpeed -- we add LinkSpeed
            // to the top to round up.
            //

            if (Device->LinkSpeed == 0) {
                u.IpxNetnumData->netdelay = 16;
            } else {
                u.IpxNetnumData->netdelay = (USHORT)((839 + Device->LinkSpeed) /
                                                         (Device->LinkSpeed));
            }
            u.IpxNetnumData->hopcount = 0;
            u.IpxNetnumData->cardnum = 0;
            RtlMoveMemory (u.IpxNetnumData->router, Device->SourceAddress.NodeAddress, 6);

        } else {


            if (Device->ForwarderBound) {
                //
                // [FW] Call the Forwarder's FindRoute if installed
                //

                //
                // What about the node number here?
                //
                Status = (*Device->UpperDrivers[IDENTIFIER_RIP].FindRouteHandler) (
                                 u.IpxNetnumData->netnum,
                                 NULL,  // FindRouteRequest->Node,
                                 &routeEntry);

                if (Status != STATUS_SUCCESS) {
                   IPX_DEBUG (ACTION, (" MIPX_GETNETINFO_NR failed net %lx",
                              REORDER_ULONG(*(UNALIGNED ULONG *)(u.IpxNetnumData->netnum))));
                   Status = STATUS_BAD_NETWORK_PATH;
                } else {
                   //
                   // Fill in the information
                   //
                   IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

                   if (Binding = NIC_ID_TO_BINDING(Device, routeEntry.LocalTarget.NicId)) {
                      u.IpxNetnumData->hopcount = routeEntry.HopCount;
                      u.IpxNetnumData->netdelay = routeEntry.TickCount;
                      if (Binding->BindingSetMember) {
                         u.IpxNetnumData->cardnum = (INT)(Binding->MasterBinding->NicId - 1);
                      } else {
                         u.IpxNetnumData->cardnum = (INT)(routeEntry.LocalTarget.NicId - 1);
                      }

                      // RtlMoveMemory (u.IpxNetnumData->router, routeEntry.LocalTarget.MacAddress, 6);

                      *((UNALIGNED ULONG *)u.IpxNetnumData->router) =
                            *((UNALIGNED ULONG *)routeEntry.LocalTarget.MacAddress);
                      *((UNALIGNED ULONG *)(u.IpxNetnumData->router+4)) =
                            *((UNALIGNED ULONG *)(routeEntry.LocalTarget.MacAddress+4));
                   }
                   IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                }


            } else {
                Segment = RipGetSegment(u.IpxNetnumData->netnum);

                //
                // To maintain the lock order: BindAccessLock > RIP table
                //
                IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

                CTEGetLock (&Device->SegmentLocks[Segment], &LockHandle);

                //
                // See which net card this is routed on.
                //

                RouteEntry = RipGetRoute (Segment, u.IpxNetnumData->netnum);
                if ((RouteEntry != NULL) &&
                    (Binding = NIC_ID_TO_BINDING(Device, RouteEntry->NicId))) {

                    u.IpxNetnumData->hopcount = RouteEntry->HopCount;
                    u.IpxNetnumData->netdelay = RouteEntry->TickCount;
                    if (Binding->BindingSetMember) {
                        u.IpxNetnumData->cardnum = (INT)(MIN (Device->MaxBindings, Binding->MasterBinding->NicId) - 1);
                    } else {
                        u.IpxNetnumData->cardnum = (INT)(RouteEntry->NicId - 1);
                    }
                    RtlMoveMemory (u.IpxNetnumData->router, RouteEntry->NextRouter, 6);

                } else {

                    //
                    // Fail the call, we don't have a route yet.
                    //

                    IPX_DEBUG (ACTION, ("MIPX_GETNETINFO_NR failed net %lx\n",
                        REORDER_ULONG(*(UNALIGNED ULONG *)(u.IpxNetnumData->netnum))));
                    Status = STATUS_BAD_NETWORK_PATH;

                }
                CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);
                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
             }

        }

        break;

    case MIPX_RERIPNETNUM:

        //
        // We dont really support Re-RIP in the case of Forwarder above us
        //

        //
        // A request for network information about the immediate
        // route to a network (this is called by sockets apps).
        //

        if (DataLength < sizeof(IPX_NETNUM_DATA)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        u.IpxNetnumData = (PIPX_NETNUM_DATA)(NwlinkAction->Data);

        //
        // Allow net 0 queries??
        //

        if (*(UNALIGNED ULONG *)u.IpxNetnumData->netnum == 0) {

            if (Device->LinkSpeed == 0) {
                u.IpxNetnumData->netdelay = 16;
            } else {
                u.IpxNetnumData->netdelay = (USHORT)((839 + Device->LinkSpeed) /
                                                         (Device->LinkSpeed));
            }
            u.IpxNetnumData->hopcount = 0;
            u.IpxNetnumData->cardnum = 0;
            RtlMoveMemory (u.IpxNetnumData->router, Device->SourceAddress.NodeAddress, 6);

        } else {


             if (Device->ForwarderBound) {

                //
                // [FW] Call the Forwarder's FindRoute if installed
                //

                //
                // What about the node number here?
                //
                Status = (*Device->UpperDrivers[IDENTIFIER_RIP].FindRouteHandler) (
                                 u.IpxNetnumData->netnum,
                                 NULL,  // FindRouteRequest->Node,
                                 &routeEntry);

                if (Status != STATUS_SUCCESS) {
                   IPX_DEBUG (ACTION, (" MIPX_RERIPNETNUM failed net %lx",
                              REORDER_ULONG(*(UNALIGNED ULONG *)(u.IpxNetnumData->netnum))));
                   Status = STATUS_BAD_NETWORK_PATH;
                } else {
                   //
                   // Fill in the information
                   //
    			   IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                   if (Binding = NIC_ID_TO_BINDING(Device, routeEntry.LocalTarget.NicId)) {
                      u.IpxNetnumData->hopcount = routeEntry.HopCount;
                      u.IpxNetnumData->netdelay = routeEntry.TickCount;
                      if (Binding->BindingSetMember) {
                         u.IpxNetnumData->cardnum = (INT)(Binding->MasterBinding->NicId - 1);
                      } else {
                         u.IpxNetnumData->cardnum = (INT)(routeEntry.LocalTarget.NicId - 1);
                      }

                      // RtlMoveMemory (u.IpxNetnumData->router, routeEntry.LocalTarget.MacAddress, 6);

                      *((UNALIGNED ULONG *)u.IpxNetnumData->router) =
                            *((UNALIGNED ULONG *)routeEntry.LocalTarget.MacAddress);
                      *((UNALIGNED ULONG *)(u.IpxNetnumData->router+4)) =
                            *((UNALIGNED ULONG *)(routeEntry.LocalTarget.MacAddress+4));
                   }
    			    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                }

             } else {
                Segment = RipGetSegment(u.IpxNetnumData->netnum);
    			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                CTEGetLock (&Device->SegmentLocks[Segment], &LockHandle);

                //
                // See which net card this is routed on.
                //

                RouteEntry = RipGetRoute (Segment, u.IpxNetnumData->netnum);

                if ((RouteEntry != NULL) &&
                    (Binding = NIC_ID_TO_BINDING(Device, RouteEntry->NicId)) &&
                    (RouteEntry->Flags & IPX_ROUTER_PERMANENT_ENTRY)) {

                    u.IpxNetnumData->hopcount = RouteEntry->HopCount;
                    u.IpxNetnumData->netdelay = RouteEntry->TickCount;

                    if (Binding->BindingSetMember) {
                        u.IpxNetnumData->cardnum = (INT)(MIN (Device->MaxBindings, Binding->MasterBinding->NicId) - 1);
                    } else {
                        u.IpxNetnumData->cardnum = (INT)(RouteEntry->NicId - 1);
                    }
                    RtlMoveMemory (u.IpxNetnumData->router, RouteEntry->NextRouter, 6);

                } else {

                    //
                    // This call will return STATUS_PENDING if we successfully
                    // queue a RIP request for the packet.
                    //

                    Status = RipQueueRequest (*(UNALIGNED ULONG *)u.IpxNetnumData->netnum, RIP_REQUEST);
                    CTEAssert (Status != STATUS_SUCCESS);

                    if (Status == STATUS_PENDING) {

                        //
                        // A RIP request went out on the network; we queue
                        // this request for completion when the RIP response
                        // arrives. We save the network in the information
                        // field for easier retrieval later.
                        //
#ifdef SUNDOWN
						REQUEST_INFORMATION(Request) = (ULONG_PTR)u.IpxNetnumData;
#else
						REQUEST_INFORMATION(Request) = (ULONG)u.IpxNetnumData;
#endif

                        
                        InsertTailList(
                            &Device->Segments[Segment].WaitingReripNetnum,
                            REQUEST_LINKAGE(Request));

                        IPX_DEBUG (ACTION, ("MIPX_RERIPNETNUM queued net %lx\n",
                            REORDER_ULONG(*(UNALIGNED ULONG *)(u.IpxNetnumData->netnum))));

                    }

                }

                CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);
    			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            }
        }

        break;

    case MIPX_GETNETINFO:

        //
        // A request for network information about the immediate
        // route to a network (this is called by sockets apps).
        //

        if (DataLength < sizeof(IPX_NETNUM_DATA)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        u.IpxNetnumData = (PIPX_NETNUM_DATA)(NwlinkAction->Data);

        //
        // Allow net 0 queries??
        //

        if (*(UNALIGNED ULONG *)u.IpxNetnumData->netnum == 0) {

            if (Device->LinkSpeed == 0) {
                u.IpxNetnumData->netdelay = 16;
            } else {
                u.IpxNetnumData->netdelay = (USHORT)((839 + Device->LinkSpeed) /
                                                         (Device->LinkSpeed));
            }
            u.IpxNetnumData->hopcount = 0;
            u.IpxNetnumData->cardnum = 0;
            RtlMoveMemory (u.IpxNetnumData->router, Device->SourceAddress.NodeAddress, 6);

        } else {


            if (Device->ForwarderBound) {

               //
               // [FW] Call the Forwarder's FindRoute if installed
               //

               //
               // What about the node number here?
               //
               Status = (*Device->UpperDrivers[IDENTIFIER_RIP].FindRouteHandler) (
                                u.IpxNetnumData->netnum,
                                NULL,  // FindRouteRequest->Node,
                                &routeEntry);

               if (Status != STATUS_SUCCESS) {
                  IPX_DEBUG (ACTION, (" MIPX_GETNETINFO failed net %lx",
                             REORDER_ULONG(*(UNALIGNED ULONG *)(u.IpxNetnumData->netnum))));
                  Status = STATUS_BAD_NETWORK_PATH;
               } else {
                  //
                  // Fill in the information
                  //
    			  IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

                  if (Binding = NIC_ID_TO_BINDING(Device, routeEntry.LocalTarget.NicId)) {
                     u.IpxNetnumData->hopcount = routeEntry.HopCount;
                     u.IpxNetnumData->netdelay = routeEntry.TickCount;
                     if (Binding->BindingSetMember) {
                        u.IpxNetnumData->cardnum = (INT)(Binding->MasterBinding->NicId - 1);
                     } else {
                        u.IpxNetnumData->cardnum = (INT)(routeEntry.LocalTarget.NicId - 1);
                     }

                     // RtlMoveMemory (u.IpxNetnumData->router, routeEntry.LocalTarget.MacAddress, 6);

                     *((UNALIGNED ULONG *)u.IpxNetnumData->router) =
                           *((UNALIGNED ULONG *)routeEntry.LocalTarget.MacAddress);
                     *((UNALIGNED ULONG *)(u.IpxNetnumData->router+4)) =
                           *((UNALIGNED ULONG *)(routeEntry.LocalTarget.MacAddress+4));
                  }

    			  IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
               }
            } else {
                Segment = RipGetSegment(u.IpxNetnumData->netnum);
    			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                CTEGetLock (&Device->SegmentLocks[Segment], &LockHandle);

                //
                // See which net card this is routed on.
                //

                RouteEntry = RipGetRoute (Segment, u.IpxNetnumData->netnum);

                if ((RouteEntry != NULL) &&
                    (Binding = NIC_ID_TO_BINDING(Device, RouteEntry->NicId))) {

                    u.IpxNetnumData->hopcount = RouteEntry->HopCount;
                    u.IpxNetnumData->netdelay = RouteEntry->TickCount;

                    if (Binding->BindingSetMember) {
                        u.IpxNetnumData->cardnum = (INT)(MIN (Device->MaxBindings, Binding->MasterBinding->NicId) - 1);
                    } else {
                        u.IpxNetnumData->cardnum = (INT)(RouteEntry->NicId - 1);
                    }
                    RtlMoveMemory (u.IpxNetnumData->router, RouteEntry->NextRouter, 6);

                } else {

                    //
                    // This call will return STATUS_PENDING if we successfully
                    // queue a RIP request for the packet.
                    //

                    Status = RipQueueRequest (*(UNALIGNED ULONG *)u.IpxNetnumData->netnum, RIP_REQUEST);
                    CTEAssert (Status != STATUS_SUCCESS);

                    if (Status == STATUS_PENDING) {

                        //
                        // A RIP request went out on the network; we queue
                        // this request for completion when the RIP response
                        // arrives. We save the network in the information
                        // field for easier retrieval later.
                        //
#ifdef SUNDOWN
						REQUEST_INFORMATION(Request) = (ULONG_PTR)u.IpxNetnumData;
#else
						REQUEST_INFORMATION(Request) = (ULONG)u.IpxNetnumData;
#endif

                        
                        InsertTailList(
                            &Device->Segments[Segment].WaitingReripNetnum,
                            REQUEST_LINKAGE(Request));

                        IPX_DEBUG (ACTION, ("MIPX_GETNETINFO queued net %lx\n",
                            REORDER_ULONG(*(UNALIGNED ULONG *)(u.IpxNetnumData->netnum))));

                    }

                }

                CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);
    			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            }
        }

        break;

    case MIPX_SENDPTYPE:
    case MIPX_NOSENDPTYPE:

        //
        // For the moment just use OptionsLength >= 1 to indicate
        // that the send options include the packet type.
        //
        // Do we need to worry about card num being there?
        //

#if 0
        IPX_DEBUG (ACTION, ("%lx: MIPS_%sSENDPTYPE\n", AddressFile,
                        NwlinkAction->Option == MIPX_SENDPTYPE ? "" : "NO"));
#endif
        break;

    case MIPX_ZEROSOCKET:

        //
        // Sends from this address should be from socket 0;
        // This is done the simple way by just putting the
        // information in the address itself, instead of
        // making it per address file (this is OK since
        // this call is not exposed through winsock).
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_ZEROSOCKET\n", AddressFile));
        AddressFile->Address->SendSourceSocket = 0;
        AddressFile->Address->LocalAddress.Socket = 0;
        break;


    //
    // This next batch are the source routing options. They
    // are submitted by the IPXROUTE program.
    //
    // Do we expose all binding set members to this?

    case MIPX_SRGETPARMS:

        if (DataLength >= sizeof(SR_GET_PARAMETERS)) {
            u.GetSrParameters = (PSR_GET_PARAMETERS)(NwlinkAction->Data);
			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
            if (Binding = NIC_ID_TO_BINDING(Device, u.GetSrParameters->BoardNumber+1)) {

                IPX_DEBUG (ACTION, ("MIPX_SRGETPARMS (%d)\n", u.GetSrParameters->BoardNumber+1));
                u.GetSrParameters->SrDefault = (Binding->AllRouteDirected) ? 1 : 0;
                u.GetSrParameters->SrBroadcast = (Binding->AllRouteBroadcast) ? 1 : 0;
                u.GetSrParameters->SrMulticast = (Binding->AllRouteMulticast) ? 1 : 0;

            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }

        break;

    case MIPX_SRDEF:
    case MIPX_SRBCAST:
    case MIPX_SRMULTI:

        if (DataLength >= sizeof(SR_SET_PARAMETER)) {
            u.SetSrParameter = (PSR_SET_PARAMETER)(NwlinkAction->Data);
			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

            if (Binding = NIC_ID_TO_BINDING(Device, u.SetSrParameter->BoardNumber+1)) {
                if (NwlinkAction->Option == MIPX_SRDEF) {

                    //
                    // The compiler generates strange
                    // code which always makes this path be
                    // taken????
                    //

                    IPX_DEBUG (ACTION, ("MIPX_SRDEF %d (%d)\n",
                        u.SetSrParameter->Parameter, u.SetSrParameter->BoardNumber+1));
                    Binding->AllRouteDirected = (BOOLEAN)u.SetSrParameter->Parameter;

                } else if (NwlinkAction->Option == MIPX_SRBCAST) {

                    IPX_DEBUG (ACTION, ("MIPX_SRBCAST %d (%d)\n",
                        u.SetSrParameter->Parameter, u.SetSrParameter->BoardNumber+1));
                    Binding->AllRouteBroadcast = (BOOLEAN)u.SetSrParameter->Parameter;

                } else {

                    IPX_DEBUG (ACTION, ("MIPX_SRMCAST %d (%d)\n",
                        u.SetSrParameter->Parameter, u.SetSrParameter->BoardNumber+1));
                    Binding->AllRouteMulticast = (BOOLEAN)u.SetSrParameter->Parameter;

                }

            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }

        break;

    case MIPX_SRREMOVE:

        if (DataLength >= sizeof(SR_SET_REMOVE)) {
            u.SetSrRemove = (PSR_SET_REMOVE)(NwlinkAction->Data);
			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
            if (Binding = NIC_ID_TO_BINDING(Device, u.SetSrRemove->BoardNumber+1)) {

                IPX_DEBUG (ACTION, ("MIPX_SRREMOVE %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x (%d)\n",
                    u.SetSrRemove->MacAddress[0],
                    u.SetSrRemove->MacAddress[1],
                    u.SetSrRemove->MacAddress[2],
                    u.SetSrRemove->MacAddress[3],
                    u.SetSrRemove->MacAddress[4],
                    u.SetSrRemove->MacAddress[5],
                    u.SetSrRemove->BoardNumber+1));
                MacSourceRoutingRemove (Binding, u.SetSrRemove->MacAddress);

            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }

        break;

    case MIPX_SRCLEAR:

        if (DataLength >= sizeof(SR_SET_CLEAR)) {
            u.SetSrClear = (PSR_SET_CLEAR)(NwlinkAction->Data);
			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);	
            if (Binding = NIC_ID_TO_BINDING(Device, u.SetSrClear->BoardNumber+1)) {

                IPX_DEBUG (ACTION, ("MIPX_SRCLEAR (%d)\n", u.SetSrClear->BoardNumber+1));
                MacSourceRoutingClear (Binding);

            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
		} else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }

        break;


    //
    // These are new for ISN (not supported in NWLINK).
    //

    case MIPX_LOCALTARGET:

        //
        // A request for the local target for an IPX address.
        //

        if (DataLength < sizeof(ISN_ACTION_GET_LOCAL_TARGET)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        u.GetLocalTarget = (PISN_ACTION_GET_LOCAL_TARGET)(NwlinkAction->Data);

        if (Device->ForwarderBound) {

            //
            // [FW] Call the Forwarder's FindRoute if installed
            //

            //
            // What about the node number here?
            //
            Status = (*Device->UpperDrivers[IDENTIFIER_RIP].FindRouteHandler) (
                        (PUCHAR)&u.GetLocalTarget->IpxAddress.NetworkAddress,
                        NULL,  // FindRouteRequest->Node,
                        &routeEntry);

            if (Status != STATUS_SUCCESS) {
               IPX_DEBUG (ACTION, (" MIPX_LOCALTARGET failed net %lx",
                  REORDER_ULONG(u.GetLocalTarget->IpxAddress.NetworkAddress)));
               Status = STATUS_BAD_NETWORK_PATH;
            } else {
               //
               // Fill in the information
               //

               IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
               //
               // What about check for IPX_ROUTER_LOCAL_NET
               //
               if (Binding = NIC_ID_TO_BINDING(Device, routeEntry.LocalTarget.NicId)) {
                  if (Binding->BindingSetMember) {

                       //
                       // It's a binding set member, we round-robin the
                       // responses across all the cards to distribute
                       // the traffic.
                       //

                       MasterBinding = Binding->MasterBinding;
                       Binding = MasterBinding->CurrentSendBinding;
                       MasterBinding->CurrentSendBinding = Binding->NextBinding;

                       u.GetLocalTarget->LocalTarget.NicId = Binding->NicId;

                   } else {

                       u.GetLocalTarget->LocalTarget.NicId = routeEntry.LocalTarget.NicId;
                   }

                  *((UNALIGNED ULONG *)u.GetLocalTarget->LocalTarget.MacAddress) =
                     *((UNALIGNED ULONG *)routeEntry.LocalTarget.MacAddress);
                  *((UNALIGNED ULONG *)(u.GetLocalTarget->LocalTarget.MacAddress+4)) =
                     *((UNALIGNED ULONG *)(routeEntry.LocalTarget.MacAddress+4));
               }

               IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            }
        } else {
            Segment = RipGetSegment((PUCHAR)&u.GetLocalTarget->IpxAddress.NetworkAddress);

            CTEGetLock (&Device->SegmentLocks[Segment], &LockHandle);

            //
            // See if this route is local.
            //

            RouteEntry = RipGetRoute (Segment, (PUCHAR)&u.GetLocalTarget->IpxAddress.NetworkAddress);

            if ((RouteEntry != NULL) &&
                (RouteEntry->Flags & IPX_ROUTER_PERMANENT_ENTRY)) {

                //
                // This is a local net, to send to it you just use
                // the appropriate NIC ID and the real MAC address.
                //

                if ((RouteEntry->Flags & IPX_ROUTER_LOCAL_NET) == 0) {

                    //
                    // It's the virtual net, send via the first card.
                    //
                    FILL_LOCAL_TARGET(&u.GetLocalTarget->LocalTarget, 1);
    				CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);

                } else {


    				CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);
    				IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
    				Binding = NIC_ID_TO_BINDING(Device, RouteEntry->NicId);

                    if (Binding->BindingSetMember) {

                        //
                        // It's a binding set member, we round-robin the
                        // responses across all the cards to distribute
                        // the traffic.
                        //

                        MasterBinding = Binding->MasterBinding;
                        Binding = MasterBinding->CurrentSendBinding;
                        MasterBinding->CurrentSendBinding = Binding->NextBinding;

                        FILL_LOCAL_TARGET(&u.GetLocalTarget->LocalTarget, MIN( Device->MaxBindings, Binding->NicId));

                    } else {

                        FILL_LOCAL_TARGET(&u.GetLocalTarget->LocalTarget, RouteEntry->NicId);

                    }
    				IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                }

                RtlCopyMemory(
                    u.GetLocalTarget->LocalTarget.MacAddress,
                    u.GetLocalTarget->IpxAddress.NodeAddress,
                    6);

            } else {

                //
                // This call will return STATUS_PENDING if we successfully
                // queue a RIP request for the packet.
                //

                Status = RipQueueRequest (u.GetLocalTarget->IpxAddress.NetworkAddress, RIP_REQUEST);
                CTEAssert (Status != STATUS_SUCCESS);

                if (Status == STATUS_PENDING) {

                    //
                    // A RIP request went out on the network; we queue
                    // this request for completion when the RIP response
                    // arrives. We save the network in the information
                    // field for easier retrieval later.
                    //
#ifdef SUNDOWN
					REQUEST_INFORMATION(Request) = (ULONG_PTR)u.GetLocalTarget;
#else
					REQUEST_INFORMATION(Request) = (ULONG)u.GetLocalTarget;
#endif

                    
                    InsertTailList(
                        &Device->Segments[Segment].WaitingLocalTarget,
                        REQUEST_LINKAGE(Request));

                }

    			CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);
            }

        }

        break;

    case MIPX_NETWORKINFO:

        //
        // A request for network information about the immediate
        // route to a network.
        //

        if (DataLength < sizeof(ISN_ACTION_GET_NETWORK_INFO)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        u.GetNetworkInfo = (PISN_ACTION_GET_NETWORK_INFO)(NwlinkAction->Data);

        if (u.GetNetworkInfo->Network == 0) {

            //
            // This is information about the local card.
            //

            u.GetNetworkInfo->LinkSpeed = Device->LinkSpeed * 12;
            u.GetNetworkInfo->MaximumPacketSize = Device->Information.MaxDatagramSize;

        } else {

            if (Device->ForwarderBound) {

                //
                // [FW] Call the Forwarder's FindRoute if installed
                //

                //
                // What about the node number here?
                //
                Status = (*Device->UpperDrivers[IDENTIFIER_RIP].FindRouteHandler) (
                                 (PUCHAR)&u.GetNetworkInfo->Network,
                                 NULL,  // FindRouteRequest->Node,
                                 &routeEntry);

                if (Status != STATUS_SUCCESS) {
                   IPX_DEBUG (ACTION, (" MIPX_GETNETINFO_NR failed net %lx",
                              REORDER_ULONG(u.GetNetworkInfo->Network)));
                   Status = STATUS_BAD_NETWORK_PATH;
                } else {
                   //
                   // Fill in the information
                   //

    			   IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                   if (Binding = NIC_ID_TO_BINDING(Device, routeEntry.LocalTarget.NicId)) {
                      //
                      // Our medium speed is stored in 100 bps, we
                      // convert to bytes/sec by multiplying by 12
                      // (should really be 100/8 = 12.5).
                      //

                      u.GetNetworkInfo->LinkSpeed = Binding->MediumSpeed * 12;
                      u.GetNetworkInfo->MaximumPacketSize = Binding->AnnouncedMaxDatagramSize;
                   }
    			   IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                }
            } else {
                Segment = RipGetSegment((PUCHAR)&u.GetNetworkInfo->Network);

    			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                CTEGetLock (&Device->SegmentLocks[Segment], &LockHandle);

                //
                // See which net card this is routed on.
                //

                RouteEntry = RipGetRoute (Segment, (PUCHAR)&u.GetNetworkInfo->Network);

                if ((RouteEntry != NULL) &&
    				(Binding = NIC_ID_TO_BINDING(Device, RouteEntry->NicId))) {

                    //
                    // Our medium speed is stored in 100 bps, we
                    // convert to bytes/sec by multiplying by 12
                    // (should really be 100/8 = 12.5).
                    //

                    u.GetNetworkInfo->LinkSpeed = Binding->MediumSpeed * 12;
                    u.GetNetworkInfo->MaximumPacketSize = Binding->AnnouncedMaxDatagramSize;

                } else {

                    //
                    // Fail the call, we don't have a route yet.
                    // This requires that a packet has been
                    // sent to this net already; nwrdr says this is
                    // OK, they will send their connect request
                    // before they query. On the server it should
                    // have RIP running so all nets should be in
                    // the database.
                    //

                    Status = STATUS_BAD_NETWORK_PATH;

                }

                CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);
    			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            }
        }

        break;

    case MIPX_CONFIG:

        //
        // A request for details on every binding.
        //

        if (DataLength < sizeof(ISN_ACTION_GET_DETAILS)) {
	   IPX_DEBUG(ACTION, ("Not enought buffer %d < %d\n", DataLength,sizeof(ISN_ACTION_GET_DETAILS) )); 
	   return STATUS_BUFFER_TOO_SMALL;
        }

        u.GetDetails = (PISN_ACTION_GET_DETAILS)(NwlinkAction->Data);

        if (u.GetDetails->NicId == 0) {

            //
            // This is information about the local card. We also
            // tell him the total number of bindings in NicId.
            //

            u.GetDetails->NetworkNumber = Device->VirtualNetworkNumber;
            u.GetDetails->NicId = (USHORT)MIN (Device->MaxBindings, Device->ValidBindings);

        } else {
			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
	        Binding = NIC_ID_TO_BINDING(Device, u.GetDetails->NicId);

            if ((Binding != NULL) &&
                (u.GetDetails->NicId <= MIN (Device->MaxBindings, Device->ValidBindings))) {

                ULONG StringLoc;
    			IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
    			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                u.GetDetails->NetworkNumber = Binding->LocalAddress.NetworkAddress;
                if (Binding->Adapter->MacInfo.MediumType == NdisMediumArcnet878_2) {
                    u.GetDetails->FrameType = ISN_FRAME_TYPE_ARCNET;
                } else {
                    u.GetDetails->FrameType = Binding->FrameType;
                }
                u.GetDetails->BindingSet = Binding->BindingSetMember;
                if (Binding->Adapter->MacInfo.MediumAsync) {
                    if (Binding->LineUp) {
                        u.GetDetails->Type = 2;
                    } else {
                        u.GetDetails->Type = 3;
                    }
                } else {
                    u.GetDetails->Type = 1;
                }

                RtlCopyMemory (u.GetDetails->Node, Binding->LocalMacAddress.Address, 6);

                //
                // Copy the adapter name, including the final NULL.
                //

                StringLoc = (Binding->Adapter->AdapterNameLength / sizeof(WCHAR)) - 2;
                while (Binding->Adapter->AdapterName[StringLoc] != L'\\') {
                    --StringLoc;
                }
                RtlCopyMemory(
                    u.GetDetails->AdapterName,
                    &Binding->Adapter->AdapterName[StringLoc+1],
                    Binding->Adapter->AdapterNameLength - ((StringLoc+1) * sizeof(WCHAR)));

    			IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
            } else {
	       IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
	       IPX_DEBUG(ACTION, ("Bad nic id %d\n",u.GetDetails->NicId)); 
	       Status = STATUS_INVALID_PARAMETER;
            }
        }

        break;


        //
        // Return new nic info to the requestor. Currently, no check for
        // who retrieved the info earlier.
        //
        case MIPX_GETNEWNICINFO:

            IPX_DEBUG (ACTION, ("%lx: MIPX_GETNEWNICINFO (%lx)\n", AddressFile,
                                Request));
            //
            // a request for details on new bindings.
            //
            Status = GetNewNics(Device, Request, TRUE, NwlinkAction, BufferLength, FALSE);
            break;

        //
        // In case a LineUp occurs with the IpxwanConfigRequired, this is used
        // to indicate to IPX that the config is done and that the LineUp
        // can be indicated to the other clients.
        //
        case MIPX_IPXWAN_CONFIG_DONE:

            IPX_DEBUG (ACTION, ("MIPX_IPXWAN_CONFIG_DONE (%lx)\n", Request));

            if (DataLength < sizeof(IPXWAN_CONFIG_DONE)) {
                return STATUS_BUFFER_TOO_SMALL;
            }

            u.IpxwanConfigDone = (PIPXWAN_CONFIG_DONE)(NwlinkAction->Data);
            Status = IpxIndicateLineUp( IpxDevice,
                                        u.IpxwanConfigDone->NicId,
                                        u.IpxwanConfigDone->Network,
                                        u.IpxwanConfigDone->LocalNode,
                                        u.IpxwanConfigDone->RemoteNode);
            break;

        //
        // Used to query the WAN inactivity counter for a given NicId
        //
        case MIPX_QUERY_WAN_INACTIVITY: {

            USHORT   NicId;

            IPX_DEBUG (ACTION, ("MIPX_QUERY_WAN_INACTIVITY (%lx)\n", Request));

            if (DataLength < sizeof(IPX_QUERY_WAN_INACTIVITY)) {
                return STATUS_BUFFER_TOO_SMALL;
            }

            u.QueryWanInactivity = (PIPX_QUERY_WAN_INACTIVITY)(NwlinkAction->Data);

            //
            // If this is an invalid Nic, then we need to associate a Nic with the ConnectionId that
            // was passed in.
            // This should happen only once per line up.
            //
            if (u.QueryWanInactivity->NicId == INVALID_NICID) {
                PBINDING    Binding;
                {
                ULONG   Index = MIN (Device->MaxBindings, Device->HighestExternalNicId);

                IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                for ( NicId = Device->HighestLanNicId+1;NicId < Index;NicId++ ) {
                    Binding = NIC_ID_TO_BINDING(Device, NicId);
                    if (Binding && (Binding->ConnectionId == u.QueryWanInactivity->ConnectionId)) {
                        CTEAssert(Binding->Adapter->MacInfo.MediumAsync);
                        if (Binding->LineUp != LINE_CONFIG) {
                            IPX_DEBUG (WAN, ("Binding is not in config state yet got QUERY_WAN_INACTIVITY %lx %lx", Binding, Request));
                            NicId = 0;
                        }
                        u.QueryWanInactivity->NicId = NicId;
                        break;
                    }
                }
			    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                }
            }

            if (NicId) {
                u.QueryWanInactivity->WanInactivityCounter = IpxInternalQueryWanInactivity(NicId);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }

            break;
        }

    //
    // The Option was not supported, so fail.
    //

    default:

        Status = STATUS_NOT_SUPPORTED;
        break;


    }   // end of the long switch on NwlinkAction->Option


#if DBG
    if (!NT_SUCCESS(Status)) {
        IPX_DEBUG (ACTION, ("Nwlink action %lx failed, status %lx\n", NwlinkAction->Option, Status));
    }
#endif

    return Status;

}   /* IpxTdiAction */


VOID
IpxCancelAction(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel an Action.
    What is done to cancel it is specific to each action.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{
    PDEVICE Device = IpxDevice;
    PREQUEST Request = (PREQUEST)Irp;
    CTELockHandle LockHandle;
    PLIST_ENTRY p;
    BOOLEAN Found;
    UINT IOCTLType;

    ASSERT( DeviceObject->DeviceExtension == IpxDevice );

    //
    // Find the request on the address notify queue.
    //

    Found = FALSE;

    CTEGetLock (&Device->Lock, &LockHandle);

    for (p = Device->AddressNotifyQueue.Flink;
         p != &Device->AddressNotifyQueue;
         p = p->Flink) {

         if (LIST_ENTRY_TO_REQUEST(p) == Request) {

             RemoveEntryList (p);
             Found = TRUE;
             IOCTLType = MIPX_NOTIFYCARDINFO;
             break;
         }
    }

    if (!Found) {
        for (p = Device->LineChangeQueue.Flink;
             p != &Device->LineChangeQueue;
             p = p->Flink) {

             if (LIST_ENTRY_TO_REQUEST(p) == Request) {

                 RemoveEntryList (p);
                 Found = TRUE;
                 IOCTLType = MIPX_LINECHANGE;
                 break;
             }
        }
    }

    if (!Found) {
        for (p = Device->NicNtfQueue.Flink;
             p != &Device->NicNtfQueue;
             p = p->Flink) {

             if (LIST_ENTRY_TO_REQUEST(p) == Request) {

                 RemoveEntryList (p);
                 Found = TRUE;
                 IOCTLType = MIPX_GETNEWNICINFO;
                 break;
             }
        }
    }

    CTEFreeLock (&Device->Lock, LockHandle);
    IoReleaseCancelSpinLock (Irp->CancelIrql);

    if (Found) {


        REQUEST_INFORMATION(Request) = 0;
        REQUEST_STATUS(Request) = STATUS_CANCELLED;

        IpxCompleteRequest (Request);
        IpxFreeRequest(Device, Request);
        if (IOCTLType == MIPX_NOTIFYCARDINFO) {
            IPX_DEBUG(ACTION, ("Cancelled action NOTIFYCARDINFO %lx\n", Request));
            IpxDereferenceDevice (Device, DREF_ADDRESS_NOTIFY);
        } else {
            if (IOCTLType == MIPX_LINECHANGE) {
                IPX_DEBUG(ACTION, ("Cancelled action LINECHANGE %lx\n", Request));
                IpxDereferenceDevice (Device, DREF_LINE_CHANGE);
            } else {
                IPX_DEBUG(ACTION, ("Cancelled action LINECHANGE %lx\n", Request));
                IpxDereferenceDevice (Device, DREF_NIC_NOTIFY);
            }
        }

    }
#if DBG
       else {
        IPX_DEBUG(ACTION, ("Cancelled action orphan %lx\n", Request));
    }
#endif

}   /* IpxCancelAction */


VOID
IpxAbortLineChanges(
    IN PVOID ControlChannelContext
    )

/*++

Routine Description:

    This routine aborts any line change IRPs posted by the
    control channel with the specified open context. It is
    called when a control channel is being shut down.

Arguments:

    ControlChannelContext - The context assigned to the control
        channel when it was opened.

Return Value:

    none.

--*/

{
    PDEVICE Device = IpxDevice;
    CTELockHandle LockHandle;
    LIST_ENTRY AbortList;
    PLIST_ENTRY p;
    PREQUEST Request;
    KIRQL irql;


    InitializeListHead (&AbortList);

    IoAcquireCancelSpinLock( &irql );
    CTEGetLock (&Device->Lock, &LockHandle);

    p = Device->LineChangeQueue.Flink;

    while (p != &Device->LineChangeQueue) {
        LARGE_INTEGER   ControlChId;

        Request = LIST_ENTRY_TO_REQUEST(p);

        CCID_FROM_REQUEST(ControlChId, Request);

        p = p->Flink;

        if (ControlChId.QuadPart == ((PLARGE_INTEGER)ControlChannelContext)->QuadPart) {
            RemoveEntryList (REQUEST_LINKAGE(Request));
            InsertTailList (&AbortList, REQUEST_LINKAGE(Request));
        }
    }

    while (!IsListEmpty (&AbortList)) {

        p = RemoveHeadList (&AbortList);
        Request = LIST_ENTRY_TO_REQUEST(p);

        IPX_DEBUG(ACTION, ("Aborting line change %lx\n", Request));

        IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);

        REQUEST_INFORMATION(Request) = 0;
        REQUEST_STATUS(Request) = STATUS_CANCELLED;

        CTEFreeLock(&Device->Lock, LockHandle);
        IoReleaseCancelSpinLock( irql );

        IpxCompleteRequest (Request);
        IpxFreeRequest(Device, Request);

        IpxDereferenceDevice (Device, DREF_LINE_CHANGE);

        IoAcquireCancelSpinLock( &irql );
        CTEGetLock(&Device->Lock, &LockHandle);
    }

    CTEFreeLock(&Device->Lock, LockHandle);
    IoReleaseCancelSpinLock( irql );
}   /* IpxAbortLineChanges */

#define ROUTER_INFORMED_OF_NIC_CREATION 2


NTSTATUS
GetNewNics(
    PDEVICE  Device,
    IN PREQUEST Request,
    BOOLEAN fCheck,
    PNWLINK_ACTION NwlinkAction,
    UINT BufferLength,
    BOOLEAN OldIrp
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    UINT DataLength;
    PNDIS_BUFFER NdisBuffer;
    CTELockHandle LockHandle;
    CTELockHandle LockHandle1;
    PBINDING Binding;
    ULONG NoOfNullNics = 0;
    PIPX_NICS   pNics;
    PIPX_NIC_INFO pNicInfo;
    PIPX_NIC_INFO pLastNicInfo;
    UINT          LengthOfHeader;
    ULONG n, i;
    KIRQL OldIrql;
    BOOLEAN     fIncDec = FALSE;
    ULONG StringLoc = 0;

    LengthOfHeader =  (UINT)(FIELD_OFFSET(NWLINK_ACTION, Data[0]));
    if (fCheck)
    {
       if (BufferLength < (LengthOfHeader + FIELD_OFFSET(IPX_NICS, Data[0]) + sizeof(IPX_NIC_INFO)))
      {
          IPX_DEBUG (ACTION, ("Nwlink action failed, buffer too small for even one NICs info\n"));
          return STATUS_BUFFER_TOO_SMALL;
      }
    }
    else
    {
        NdisQueryBufferSafe (REQUEST_NDIS_BUFFER(Request), (PVOID *)&NwlinkAction, &BufferLength, NormalPagePriority);
	if (NwlinkAction == NULL) {
	   return STATUS_INSUFFICIENT_RESOURCES; 
	}

    }
    pNics = (PIPX_NICS)(NwlinkAction->Data);
    pNicInfo = (PIPX_NIC_INFO)(pNics->Data);
    pLastNicInfo = pNicInfo  + ((BufferLength - LengthOfHeader - FIELD_OFFSET(IPX_NICS, Data[0]))/sizeof(IPX_NIC_INFO)) - 1;

    IPX_DEBUG(BIND, ("GetNewNicInfo: pNicInfo=(%x), pLastNicInfo=(%x),LengthOfHeader=(%x), BindingCount=(%x)\n", pNicInfo, pLastNicInfo, LengthOfHeader, Device->ValidBindings));
    IPX_DEBUG(BIND, ("BufferLength is (%d). Length for storing NICS is (%d)\n", BufferLength, (BufferLength - LengthOfHeader - FIELD_OFFSET(IPX_NICS, Data[0]))));
    

    if (pNics->fAllNicsDesired) {
        IPX_DEBUG(BIND, ("Yes, All NICs desired\n"));    
    } else {
        IPX_DEBUG(BIND, ("No, All NICs NOT desired\n"));    

    }

    //
    // Optimize since we don't want to go over the array all the time.
    //

    CTEGetLock (&Device->Lock, &LockHandle);

    {
    ULONG   Index = MIN (Device->MaxBindings, Device->ValidBindings);


    //
    // If all nics are desired, then mark them ALL as dirty,
    // for the subsequent IRPs that do not have this flag.
    //

    if (pNics->fAllNicsDesired) {
        
        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
        
        for (n=0, i=LOOPBACK_NIC_ID; i<=Index; i++) {

            Binding =  NIC_ID_TO_BINDING(Device, i);
    
            if (Binding) {

                Binding->fInfoIndicated = FALSE;

            }
        }
        
        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

    }

    IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
    for (n=0, i=LOOPBACK_NIC_ID; i<=Index; i++)
    {
       Binding =  NIC_ID_TO_BINDING(Device, i);

       if (!Binding)
       {
             NoOfNullNics++;
             continue;
       }

       //
       // If the binding is of type autodetect *and* we haven't gotten a response on the adapter, 
       // that means IPX is still Autodetecting for this card. Do NOT tell FWD about it [shreem]
       //
       if (!Binding->PastAutoDetection) {
           
           IPX_DEBUG(BIND, ("Binding[%d] Dont Tell FWD!\n", i));
           NoOfNullNics++;
           continue;

       } else {
           
           IPX_DEBUG(BIND, ("Binding[%d] Tell FWD about it (past auto detect)!\n", i));

       }

       //
       // If we have already indicated info about this NIC, go on to the
       // next nic.
       //
       if ((Binding->fInfoIndicated && !pNics->fAllNicsDesired)
                     || (pNicInfo > pLastNicInfo))
       {
           if (Binding->fInfoIndicated) {
               IPX_DEBUG(BIND, ("-------------------------> %d already indicated\n", i));
           } else {
               IPX_DEBUG(BIND, ("*********** Continue for another reason! (%d) \n", i));
           }

           if (pNicInfo > pLastNicInfo) {
               IPX_DEBUG(BIND, ("pNicInfo: %x  pLastNicInfo %x\n", pNicInfo, pLastNicInfo));
           }           
           
           continue;
       }

       //
       // If we have a WAN nic, indicate the line up/down status.  Also,
       // copy the remote address into the app. field
       //
       if (Binding->Adapter->MacInfo.MediumAsync)
       {
            RtlCopyMemory(pNicInfo->RemoteNodeAddress, Binding->WanRemoteNode, HARDWARE_ADDRESS_LENGTH);
            if (Binding->LineUp)
            {
                 // pNicInfo->Status = NIC_LINE_UP;

                    pNicInfo->Status = NIC_CREATED;
                    //fIncDec          = NIC_OPCODE_INCREMENT_NICIDS;
            }
            else
            {
                 // pNicInfo->Status = NIC_LINE_DOWN;

                    pNicInfo->Status = NIC_DELETED;
                    //fIncDec          = NIC_OPCODE_DECREMENT_NICIDS;
            }

            pNicInfo->InterfaceIndex = Binding->InterfaceIndex;
            pNicInfo->MaxPacketSize =
                    Binding->MaxSendPacketSize - ASYNC_MEDIUM_HDR_LEN;
       }
       else
       {
                 if (Binding->LocalAddress.NetworkAddress == 0)
                 {

                    pNicInfo->Status = NIC_CREATED;

		     if (ROUTER_INFORMED_OF_NIC_CREATION != Binding->PastAutoDetection) {
		       IPX_DEBUG(BIND, ("!!!!!!!---- Increment on Binding %x, index (%d)\n", Binding,i));
		       fIncDec          = NIC_OPCODE_INCREMENT_NICIDS;                        
                    
                     } else {
		       IPX_DEBUG(BIND, ("Already informed. No increment on Binding %x, index (%d)\n", Binding,i));
		     }
                 }
                 else
                 {
                    pNicInfo->Status = NIC_CONFIGURED;

                    //
                    // IPX might have already informed the Router of the
                    // creation of this NicId, in which case, we dont ask
                    // it to increment the NicIds [ShreeM]
                    //
                    if (ROUTER_INFORMED_OF_NIC_CREATION != Binding->PastAutoDetection) {
		       IPX_DEBUG(BIND, ("!!!!!!!!! --------Increment on Binding %x, index (%d)\n", Binding,i));
		       fIncDec          = NIC_OPCODE_INCREMENT_NICIDS;                        
                    
                    }

                 }

                 //
                 // Router pnp changes [ShreeM]
                 // 
                 if (FALSE == Binding->LineUp) {

                     pNicInfo->Status = NIC_DELETED;
                     fIncDec          = NIC_OPCODE_DECREMENT_NICIDS;
                 
                 }
                 
                 //
                 // Loopback Adapter
                 //
                 if (LOOPBACK_NIC_ID == Binding->NicId) {

                     pNicInfo->Status = NIC_CONFIGURED;
                     fIncDec          = NIC_OPCODE_INCREMENT_NICIDS;

                 }

                 //
                 // RealMaxDatagramSize does not include space for ipx
                 // header. The forwarder needs to have it included since
                 // we give the entire packet (mimus the mac header) to
                 // the forwarder
                 //
                 pNicInfo->MaxPacketSize =
                    Binding->RealMaxDatagramSize + sizeof(IPX_HEADER);
       }

       pNicInfo->NdisMediumType= Binding->Adapter->MacInfo.RealMediumType;
       pNicInfo->LinkSpeed     = Binding->MediumSpeed;
       pNicInfo->PacketType    = Binding->FrameType;
       
       //
       // Zero the stuff out and then set fields that make sense.
       //
       RtlZeroMemory(&pNicInfo->Details, sizeof(ISN_ACTION_GET_DETAILS));

       pNicInfo->Details.NetworkNumber = Binding->LocalAddress.NetworkAddress;
       RtlCopyMemory(pNicInfo->Details.Node, Binding->LocalAddress.NodeAddress, HARDWARE_ADDRESS_LENGTH);
       pNicInfo->Details.NicId         = Binding->NicId;
       pNicInfo->Details.BindingSet    = Binding->BindingSetMember;
       pNicInfo->Details.FrameType     = Binding->FrameType;

       if (Binding->Adapter->MacInfo.MediumAsync) {
           if (Binding->LineUp) {
               pNicInfo->Details.Type = 2;
           } else {
               pNicInfo->Details.Type = 3;
           }
       } else {
           pNicInfo->Details.Type = 1;
       }

       //
       // Copy the adapter name, including the final NULL.
       //

       StringLoc = (Binding->Adapter->AdapterNameLength / sizeof(WCHAR)) - 2;
       while (Binding->Adapter->AdapterName[StringLoc] != L'\\') {
           --StringLoc;
       }

       RtlCopyMemory(
           pNicInfo->Details.AdapterName,
           &Binding->Adapter->AdapterName[StringLoc+1],
           Binding->Adapter->AdapterNameLength - ((StringLoc+1) * sizeof(WCHAR)));
       
       // 
       // Tell the forwarder that the rest of the NICIDs are to be moved up/down
       // only if it is not asking for ALL of them
       //
       if (!pNics->fAllNicsDesired) { 
           pNicInfo->Status |= fIncDec;
       }

       pNicInfo->ConnectionId  = Binding->ConnectionId;
       pNicInfo->IpxwanConfigRequired = Binding->IpxwanConfigRequired;

#if DBG
       //
       // Dump the IPX_NIC_INFO Structure.
       //

       IPX_DEBUG(BIND, ("%d.\nNICID= %d, Interface Index  = %d\n", i, pNicInfo->Details.NicId, pNicInfo->InterfaceIndex));

       IPX_DEBUG(BIND, ("Interface Index  = %d\n", pNicInfo->InterfaceIndex));
       IPX_DEBUG(BIND, ("LinkSpeed             = %d\n", pNicInfo->LinkSpeed));
       IPX_DEBUG(BIND, ("PacketType            = %d\n", pNicInfo->PacketType));
       IPX_DEBUG(BIND, ("MaxPacketSize         = %d\n", pNicInfo->MaxPacketSize));
       IPX_DEBUG(BIND, ("NdisMediumType        = %d\n", pNicInfo->NdisMediumType));
       IPX_DEBUG(BIND, ("NdisMediumSubtype     = %d\n", pNicInfo->NdisMediumSubtype));
       IPX_DEBUG(BIND, ("Status                = %d\n", (ULONG) pNicInfo->Status));
       IPX_DEBUG(BIND, ("ConnectionID          = %d\n", pNicInfo->ConnectionId));
       IPX_DEBUG(BIND, ("IpxwanConfigRequired  = %d\n", pNicInfo->IpxwanConfigRequired));
       
       IPX_DEBUG(BIND, ("FrameType             = %d\n", pNicInfo->Details.FrameType));
       IPX_DEBUG(BIND, ("Type                  = %d\n", pNicInfo->Details.Type));
       IPX_DEBUG(BIND, ("NetworkNumber         = %d\n", pNicInfo->Details.NetworkNumber));
       IPX_DEBUG(BIND, ("BindingSet            = %d\n", pNicInfo->Details.BindingSet));
       IPX_DEBUG(BIND, ("LocalNode = %x-%x-%x-%x-%x-%x\n",  pNicInfo->Details.Node[0], 
                                                            pNicInfo->Details.Node[1],
                                                            pNicInfo->Details.Node[2],
                                                            pNicInfo->Details.Node[3],
                                                            pNicInfo->Details.Node[4],
                                                            pNicInfo->Details.Node[5]));

       IPX_DEBUG(BIND, ("RemoteNode = %x-%x-%x-%x-%x-%x\n",  pNicInfo->RemoteNodeAddress[0], 
                                                            pNicInfo->RemoteNodeAddress[1],
                                                            pNicInfo->RemoteNodeAddress[2],
                                                            pNicInfo->RemoteNodeAddress[3],
                                                            pNicInfo->RemoteNodeAddress[4],
                                                            pNicInfo->RemoteNodeAddress[5]));
       
       //IPX_DEBUG(BIND, ("AdadpterName = %ws\n", pNicInfo->Details.AdapterName));

#endif

       pNicInfo++;  //increment to store next nic info
       n++;         //indicates the # of nics processed so far.
       Binding->fInfoIndicated = TRUE;
       Binding->PastAutoDetection = ROUTER_INFORMED_OF_NIC_CREATION;
       IPX_DEBUG(BIND, ("Iteration no = (%d) complete : reporting NicId:(%lx)\n", n, Binding->NicId));


    }
    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
    }
    CTEFreeLock (&Device->Lock, LockHandle);

    pNics->NoOfNics = n;
    pNics->TotalNoOfNics = Device->ValidBindings - NoOfNullNics;

    //
    // If no nics. to report, queue the request
    //
    if (!n) {

      IPX_DEBUG(BIND, ("GetNewNicInfo: Inserting Irp\n"));
      CTEGetLock (&Device->Lock, &LockHandle);

      InsertTailList( &Device->NicNtfQueue, REQUEST_LINKAGE(Request) );

      if (!OldIrp)
      {
        IoSetCancelRoutine (Request, IpxCancelAction);
      }
      if (Request->Cancel && 
	  IoSetCancelRoutine(Request, (PDRIVER_CANCEL)NULL)) {
	 
	 IPX_DEBUG(BIND, ("GetNewNicInfo:Cancelling Irp\n"));
	 (VOID)RemoveTailList (&Device->NicNtfQueue);
	 CTEFreeLock (&Device->Lock, LockHandle);
	 Status = STATUS_CANCELLED;
      
      } else {
	 if (!OldIrp)
	 {
	    IpxReferenceDevice (Device, DREF_NIC_NOTIFY);
	 }
	 Status = STATUS_PENDING;
	 CTEFreeLock (&Device->Lock, LockHandle);
      }
    }
    else
    {
       IPX_DEBUG(BIND, ("Reporting (%d) nics\n", n));
    }

    return(Status);
}


VOID
IpxAbortNtfChanges(
    IN PVOID ControlChannelContext
    )

/*++

Routine Description:

    This routine aborts any line change IRPs posted by the
    control channel with the specified open context. It is
    called when a control channel is being shut down.

Arguments:

    ControlChannelContext - The context assigned to the control
        channel when it was opened.

Return Value:

    none.

--*/

{
    PDEVICE Device = IpxDevice;
    CTELockHandle LockHandle;
    LIST_ENTRY AbortList;
    PLIST_ENTRY p;
    PREQUEST Request;
    KIRQL irql;


    InitializeListHead (&AbortList);

    IoAcquireCancelSpinLock( &irql );
    CTEGetLock (&Device->Lock, &LockHandle);

    p = Device->NicNtfQueue.Flink;

    while (p != &Device->NicNtfQueue) {
        LARGE_INTEGER   ControlChId;

        Request = LIST_ENTRY_TO_REQUEST(p);

        CCID_FROM_REQUEST(ControlChId, Request);

        IPX_DEBUG(BIND, ("IpxAbortNtfChange: There is at least one IRP in the queue\n"));
        p = p->Flink;

        if (ControlChId.QuadPart == ((PLARGE_INTEGER)ControlChannelContext)->QuadPart) {
            IPX_DEBUG(BIND, ("IpxAbortNtfChanges: Dequeing an Irp\n"));
            RemoveEntryList (REQUEST_LINKAGE(Request));
            InsertTailList (&AbortList, REQUEST_LINKAGE(Request));
        }
    }

    while (!IsListEmpty (&AbortList)) {

        p = RemoveHeadList (&AbortList);
        Request = LIST_ENTRY_TO_REQUEST(p);

        IPX_DEBUG(ACTION, ("Aborting line change %lx\n", Request));

        IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);

        REQUEST_INFORMATION(Request) = 0;
        REQUEST_STATUS(Request) = STATUS_CANCELLED;

        CTEFreeLock(&Device->Lock, LockHandle);
        IoReleaseCancelSpinLock( irql );

        IPX_DEBUG(BIND, ("IpxAbortNtfChanges: Cancelling the dequeued Irp\n"));
        IpxCompleteRequest (Request);
        IpxFreeRequest(Device, Request);

        IpxDereferenceDevice (Device, DREF_NIC_NOTIFY);

        IoAcquireCancelSpinLock( &irql );
        CTEGetLock(&Device->Lock, &LockHandle);
    }

    CTEFreeLock(&Device->Lock, LockHandle);
    IoReleaseCancelSpinLock( irql );
}   /* IpxAbortNtfChanges */

NTSTATUS
IpxIndicateLineUp(
    IN  PDEVICE Device,
    IN  USHORT  NicId,
    IN  ULONG   Network,
    IN  UCHAR   LocalNode[6],
    IN  UCHAR   RemoteNode[6]
    )
/*++

Routine Description:

    This routine indicates a line-up to all the concerned clients once
    the line is up.
    For now, called only if the MIPX_IPXWAN_CONFIG_DONE IOCTL is received.


Arguments:

    Device - The device for the operation.

    NicId  - The NicId corresponding to the binding that is up.

    Network, LocalNode, RemoteNode - addresses corresponding to this lineup.

Return Value:

    NTSTATUS - status of operation.

--*/
{
    PBINDING    Binding = NIC_ID_TO_BINDING(Device, NicId);
    IPX_LINE_INFO LineInfo;
    USHORT  i;
    PLIST_ENTRY p;
    PREQUEST Request;
    PNDIS_BUFFER NdisBuffer;
    PNWLINK_ACTION NwlinkAction;
    UINT BufferLength;
    PIPX_ADDRESS_DATA IpxAddressData;
    IPXCP_CONFIGURATION Configuration;
    KIRQL irql, OldIrq;
    NTSTATUS    Status;
    NTSTATUS    ntStatus;
    KIRQL   OldIrql;

    IPX_DEFINE_LOCK_HANDLE (LockHandle)

    if (!(Binding &&
          Binding->Adapter->MacInfo.MediumAsync &&
          Binding->LineUp == LINE_CONFIG)) {
        IPX_DEBUG(WAN, ("Indicate line up on invalid line: %lu\n", NicId));
        return STATUS_INVALID_PARAMETER;
    }

    // take bindaccesslock here...
    //

    //
    // If we are here, then this flag was set on a line up.
    // We turn it off now so that the adapter dll above us can decide
    // to indicate this lineup to the router module instead of the IpxWan module
    //

    CTEAssert(Binding->IpxwanConfigRequired);

    Binding->IpxwanConfigRequired = 0;

    Binding->LineUp = LINE_UP;

    //
    // Indicate to the upper drivers.
    //

    LineInfo.LinkSpeed = Binding->MediumSpeed;
    LineInfo.MaximumPacketSize = Binding->MaxSendPacketSize - 14;
    LineInfo.MaximumSendSize = Binding->MaxSendPacketSize - 14;
    LineInfo.MacOptions = Binding->Adapter->MacInfo.MacOptions;

    //
    // Fill-in the addresses into the bindings
    //
    Binding->LocalAddress.NetworkAddress = Network;

    *(UNALIGNED ULONG *)Binding->LocalAddress.NodeAddress = *(UNALIGNED ULONG *)LocalNode;
    *(UNALIGNED ULONG *)(Binding->LocalAddress.NodeAddress+4) = *(UNALIGNED ULONG *)(LocalNode+4);

    *(UNALIGNED ULONG *)Binding->WanRemoteNode = *(UNALIGNED ULONG *)RemoteNode;
    *(UNALIGNED ULONG *)(Binding->WanRemoteNode+4) = *(UNALIGNED ULONG *)(RemoteNode+4);

    //
    // Fill in the IPXCP_CONFIGURATION structure from the binding.
    //
    *(UNALIGNED ULONG *)Configuration.Network = Binding->LocalAddress.NetworkAddress;

    *(UNALIGNED ULONG *)Configuration.LocalNode = *(UNALIGNED ULONG *)Binding->LocalAddress.NodeAddress;
    *(UNALIGNED USHORT *)(Configuration.LocalNode+4) = *(UNALIGNED USHORT *)(Binding->LocalAddress.NodeAddress+4);

    *(UNALIGNED ULONG *)Configuration.RemoteNode = *(UNALIGNED ULONG *)RemoteNode;
    *(UNALIGNED USHORT *)(Configuration.RemoteNode+4) = *(UNALIGNED USHORT *)(RemoteNode+4);

    Configuration.InterfaceIndex = Binding->InterfaceIndex;
    Configuration.ConnectionClient = Binding->DialOutAsync;


        //
        // We dont give lineups; instead indicate only if the PnP reserved address
        // changed to SPX. NB gets all PnP indications with the reserved address case
        // marked out.
        //
        {
            IPX_PNP_INFO    NBPnPInfo;

            if ((!Device->MultiCardZeroVirtual) || (Binding->NicId == 1)) {

                //
                // NB's reserved address changed.
                //
                NBPnPInfo.NewReservedAddress = TRUE;

                if (!Device->VirtualNetwork) {
                    //
                    // Let SPX know because it fills in its own headers.
                    //
                    if (Device->UpperDriverBound[IDENTIFIER_SPX]) {
                        IPX_DEFINE_LOCK_HANDLE(LockHandle1)
                        IPX_PNP_INFO    IpxPnPInfo;

                        IpxPnPInfo.NewReservedAddress = TRUE;
                        IpxPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
                        IpxPnPInfo.FirstORLastDevice = FALSE;

                        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                        RtlCopyMemory(IpxPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                        NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, Binding->NicId);
                        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                        //
                        // give the PnP indication
                        //
                        (*Device->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
                            IPX_PNP_ADDRESS_CHANGE,
                            &IpxPnPInfo);

                        IPX_DEBUG(AUTO_DETECT, ("IPX_PNP_ADDRESS_CHANGED to SPX: net addr: %lx\n", Binding->LocalAddress.NetworkAddress));
                    }
                }
            } else {
                    NBPnPInfo.NewReservedAddress = FALSE;
            }

            if (Device->UpperDriverBound[IDENTIFIER_NB]) {
                IPX_DEFINE_LOCK_HANDLE(LockHandle1)

                Binding->IsnInformed[IDENTIFIER_NB] = TRUE;

            	NBPnPInfo.LineInfo.LinkSpeed = Device->LinkSpeed;
            	NBPnPInfo.LineInfo.MaximumPacketSize =
            		Device->Information.MaximumLookaheadData + sizeof(IPX_HEADER);
            	NBPnPInfo.LineInfo.MaximumSendSize =
            		Device->Information.MaxDatagramSize + sizeof(IPX_HEADER);
            	NBPnPInfo.LineInfo.MacOptions = Device->MacOptions;

                NBPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
                NBPnPInfo.FirstORLastDevice = FALSE;

                IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                RtlCopyMemory(NBPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                NIC_HANDLE_FROM_NIC(NBPnPInfo.NicHandle, Binding->NicId);
                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                //
                // give the PnP indication
                //
                (*Device->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
                    IPX_PNP_ADD_DEVICE,
                    &NBPnPInfo);

                IPX_DEBUG(AUTO_DETECT, ("IPX_PNP_ADD_DEVICE (lineup) to NB: net addr: %lx\n", Binding->LocalAddress.NetworkAddress));
            }

            //
            // Register this address with the TDI clients.
            //
            RtlCopyMemory (Device->TdiRegistrationAddress->Address, &Binding->LocalAddress, sizeof(TDI_ADDRESS_IPX));

            if ((ntStatus = TdiRegisterNetAddress(
                            Device->TdiRegistrationAddress,
#if     defined(_PNP_POWER_)
                            &IpxDeviceName,
                            NULL,
#endif _PNP_POWER_
                            &Binding->TdiRegistrationHandle)) != STATUS_SUCCESS) {

                IPX_DEBUG(PNP, ("TdiRegisterNetAddress failed: %lx", ntStatus));
            }
        }

        //
        // Indicate to the upper drivers.
        //
        //
        // Give line up to RIP as it is not PnP aware.
        //
        if (Device->UpperDriverBound[IDENTIFIER_RIP]) {
                Binding->IsnInformed[IDENTIFIER_RIP] = TRUE;
                (*Device->UpperDrivers[IDENTIFIER_RIP].LineUpHandler)(
                    Binding->NicId,
                    &LineInfo,
                    NdisMediumWan,
                    &Configuration);
        }

    //
    // Add router entry for this net since it was not done on LineUp.
    // Also, update the addresses' pre-constructed local IPX address.
    //
    {
        ULONG CurrentHash;
        PADAPTER    Adapter = Binding->Adapter;
        PADDRESS    Address;

        //
        // Add a router entry for this net if there is no router.
        // We want the number of ticks for a 576-byte frame,
        // given the link speed in 100 bps units, so we calculate
        // as:
        //
        //        seconds          18.21 ticks   4608 bits
        // --------------------- * ----------- * ---------
        // link_speed * 100 bits     second        frame
        //
        // to get the formula
        //
        // ticks/frame = 839 / link_speed.
        //
        // We add link_speed to the numerator also to ensure
        // that the value is at least 1.
        //

        if ((!Device->UpperDriverBound[IDENTIFIER_RIP]) &&
            (*(UNALIGNED ULONG *)Configuration.Network != 0)) {

            if (RipInsertLocalNetwork(
                     *(UNALIGNED ULONG *)Configuration.Network,
                     Binding->NicId,
                     Adapter->NdisBindingHandle,
                     (USHORT)((839 + Binding->MediumSpeed) / Binding->MediumSpeed)) != STATUS_SUCCESS) {

                //
                // This means we couldn't allocate memory, or
                // the entry already existed. If it already
                // exists we can ignore it for the moment.
                //
                // Now it will succeed if the network exists.
                //

                IPX_DEBUG (WAN, ("Line up, could not insert local network\n"));
                // [FW] Binding->LineUp = FALSE;
                Binding->LineUp = LINE_DOWN;
                return STATUS_SUCCESS;
            }
        }

        //
        // Update the device node and all the address
        // nodes if we have only one bound, or this is
        // binding one.
        //

        if (!Device->VirtualNetwork) {

            if ((!Device->MultiCardZeroVirtual) || (Binding->NicId == 1)) {
                Device->SourceAddress.NetworkAddress = *(UNALIGNED ULONG *)(Configuration.Network);
                RtlCopyMemory (Device->SourceAddress.NodeAddress, Configuration.LocalNode, 6);
            }

            //
            // Scan through all the addresses that exist and modify
            // their pre-constructed local IPX address to reflect
            // the new local net and node.
            //

            IPX_GET_LOCK (&Device->Lock, &LockHandle);

            for (CurrentHash = 0; CurrentHash < IPX_ADDRESS_HASH_COUNT; CurrentHash++) {

                for (p = Device->AddressDatabases[CurrentHash].Flink;
                     p != &Device->AddressDatabases[CurrentHash];
                     p = p->Flink) {

                     Address = CONTAINING_RECORD (p, ADDRESS, Linkage);

                     Address->LocalAddress.NetworkAddress = *(UNALIGNED ULONG *)Configuration.Network;
                     RtlCopyMemory (Address->LocalAddress.NodeAddress, Configuration.LocalNode, 6);
                }
            }

            IPX_FREE_LOCK (&Device->Lock, LockHandle);

        }
    }



    //
    // [FW] IpxWan config state will not be entered if only the line params are getting
    // updated.
    //
    // if (!UpdateLineUp) {

        //
        // Instead of the check for ConnectionClient, use the DialOutAsync flag
        //
        if ((Device->SingleNetworkActive) &&
            /*(LineUp->Configuration.ConnectionClient == 1)*/
            Binding->DialOutAsync) {

            //
            // Drop all entries in the database if rip is not bound.
            //

            if (!Device->UpperDriverBound[IDENTIFIER_RIP]) {
                RipDropRemoteEntries();
            }

            Device->ActiveNetworkWan = TRUE;

            //
            // Find a queued line change and complete it.
            //

            if ((p = ExInterlockedRemoveHeadList(
                           &Device->LineChangeQueue,
                           &Device->Lock)) != NULL) {

                Request = LIST_ENTRY_TO_REQUEST(p);

                IoAcquireCancelSpinLock( &irql );
                IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
                IoReleaseCancelSpinLock( irql );

                REQUEST_STATUS(Request) = STATUS_SUCCESS;

                //
                // NwRdr assumes that Line-up completions are at DPC
                //
                KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
                IpxCompleteRequest (Request);
                KeLowerIrql(OldIrql);

                IpxFreeRequest (Device, Request);

                IpxDereferenceDevice (Device, DREF_LINE_CHANGE);

            }

        }

	//
	// If we have a virtual net, do a broadcast now so
	// the router on the other end will know about us.
	//
	// Use RipSendResponse, and do it even
	// if SingleNetworkActive is FALSE??
	//

	if (Device->RipResponder && Binding->DialOutAsync) {
	    (VOID)RipQueueRequest (Device->VirtualNetworkNumber, RIP_RESPONSE);
	}

        //
        // Find a queued address notify and complete it.
        // If WanGlobalNetworkNumber is TRUE, we only do
        // this when the first dialin line comes up.
        //

        if ((!Device->WanGlobalNetworkNumber ||
             (!Device->GlobalNetworkIndicated && !Binding->DialOutAsync))
                            &&
            ((p = ExInterlockedRemoveHeadList(
                       &Device->AddressNotifyQueue,
                       &Device->Lock)) != NULL)) {

            if (Device->WanGlobalNetworkNumber) {
                Device->GlobalWanNetwork = Binding->LocalAddress.NetworkAddress;
                Device->GlobalNetworkIndicated = TRUE;
            }

            Request = LIST_ENTRY_TO_REQUEST(p);
            NdisBuffer = REQUEST_NDIS_BUFFER(Request);
            NdisQueryBufferSafe (REQUEST_NDIS_BUFFER(Request), (PVOID *)&NwlinkAction, &BufferLength, HighPagePriority);

	    if (NwlinkAction == NULL) {
	       return STATUS_INSUFFICIENT_RESOURCES; 
	    }

            IpxAddressData = (PIPX_ADDRESS_DATA)(NwlinkAction->Data);

            if (Device->WanGlobalNetworkNumber) {
                IpxAddressData->adapternum = Device->SapNicCount - 1;
            } else {
                IpxAddressData->adapternum = Binding->NicId - 1;
            }
            *(UNALIGNED ULONG *)IpxAddressData->netnum = Binding->LocalAddress.NetworkAddress;
            RtlCopyMemory(IpxAddressData->nodenum, Binding->LocalAddress.NodeAddress, 6);
            IpxAddressData->wan = TRUE;
            IpxAddressData->status = TRUE;
            IpxAddressData->maxpkt = Binding->AnnouncedMaxDatagramSize; // Use real?
            IpxAddressData->linkspeed = Binding->MediumSpeed;

            IoAcquireCancelSpinLock( &irql );
            IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
            IoReleaseCancelSpinLock( irql );

            REQUEST_STATUS(Request) = STATUS_SUCCESS;
            IpxCompleteRequest (Request);
            IpxFreeRequest (Device, Request);

            IpxDereferenceDevice (Device, DREF_ADDRESS_NOTIFY);
        }

        Binding->fInfoIndicated = FALSE;
        if ((p = ExInterlockedRemoveHeadList(
                &Device->NicNtfQueue,
                &Device->Lock)) != NULL)
        {
            Request = LIST_ENTRY_TO_REQUEST(p);

            IPX_DEBUG(BIND, ("IpxStatus: WAN LINE UP\n"));
            Status = GetNewNics(Device, Request, FALSE, NULL, 0, TRUE);
            if (Status == STATUS_PENDING)
            {
                IPX_DEBUG(BIND, ("WANLineUp may not be responding properly\n"));
            }
            else
            {
                IoAcquireCancelSpinLock(&OldIrq);
                IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
                IoReleaseCancelSpinLock(OldIrq);

                REQUEST_STATUS(Request) = Status;
                IpxCompleteRequest (Request);
                IpxFreeRequest (Device, Request);
                IpxDereferenceDevice (Device, DREF_NIC_NOTIFY);
            }
        }
//  }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\inc\ioctls.h ===
#define VER_IOCH "@(#)MCS ipx/h/ioctls.h     1.00.00 - 08 APR 1993";

/****************************************************************************
* (c) Copyright 1990, 1993 Micro Computer Systems, Inc. All rights reserved.
*****************************************************************************
*
*   Title:    IPX/SPX Driver for Windows NT
*
*   Module:   ipx/h/ioctls.h
*
*   Version:  1.00.00
*
*   Date:     04-08-93
*
*   Author:   Brian Walker
*
*****************************************************************************
*
*   Change Log:
*
*   Date     DevSFC   Comment
*   -------- ------   -------------------------------------------------------
*****************************************************************************
*
*   Functional Description:
*
*   IOCTL defines
*
****************************************************************************/

/** Ioctls for IPX - (X) = User callable **/

/**
    ioctls will values 100 - 150 were added for the NT port.
**/

#define I_MIPX          (('I' << 24) | ('D' << 16) | ('P' << 8))
#define MIPX_SETNODEADDR   I_MIPX | 0   /* Set the node address */
#define MIPX_SETNETNUM     I_MIPX | 1   /* Set the network number */
#define MIPX_SETPTYPE      I_MIPX | 2   /* (X) Set the packet type */
#define MIPX_SENTTYPE      I_MIPX | 3   /* (X) Set the xport type */
#define MIPX_SETPKTSIZE    I_MIPX | 4   /* Set the packet size */
#define MIPX_SETSAP        I_MIPX | 5   /* Set the sap/type field */
#define MIPX_SENDOPTS      I_MIPX | 6   /* (X) Send options on recv */
#define MIPX_NOSENDOPTS    I_MIPX | 7   /* (X) Don't send options on recv */
#define MIPX_SENDSRC       I_MIPX | 8   /* (X) Send source address up */
#define MIPX_NOSENDSRC     I_MIPX | 9   /* (X) Don't Send source address up */
#define MIPX_CONVBCAST     I_MIPX | 10  /* Convert TKR bcast to func addr */
#define MIPX_NOCONVBCAST   I_MIPX | 11  /* Don't cnvrt TKR bcast to funcaddr */
#define MIPX_SETCARDTYPE   I_MIPX | 12  /* Set 802.3 or ETH type */
#define MIPX_STARGROUP     I_MIPX | 13  /* This is stargroup */
#define MIPX_SWAPLENGTH    I_MIPX | 14  /* Set flag for swapping 802.3 length */
#define MIPX_SENDDEST      I_MIPX | 15  /* (X) Send dest. address up */
#define MIPX_NOSENDDEST    I_MIPX | 16  /* (X) Don't send dest. address up */
#define MIPX_SENDFDEST     I_MIPX | 17  /* (X) Send final dest. address up */
#define MIPX_NOSENDFDEST   I_MIPX | 18  /* (X) Don't send final dest. up */

/** Added for NT port **/

#define MIPX_SETVERSION    I_MIPX | 100 /* Set card version */
#define MIPX_GETSTATUS     I_MIPX | 101
#define MIPX_SENDADDROPT   I_MIPX | 102 /* (X) Send ptype w/addr on recv */
#define MIPX_NOSENDADDROPT I_MIPX | 103 /* (X) Stop sending ptype on recv */
#define MIPX_CHECKSUM      I_MIPX | 104 /* Enable/Disable checksum      */
#define MIPX_GETPKTSIZE    I_MIPX | 105 /* Get max packet size          */
#define MIPX_SENDHEADER    I_MIPX | 106 /* Send header with data        */
#define MIPX_NOSENDHEADER  I_MIPX | 107 /* Don't send header with data  */
#define MIPX_SETCURCARD    I_MIPX | 108 /* Set current card for IOCTLs  */
#define MIPX_SETMACTYPE    I_MIPX | 109 /* Set the Cards MAC type       */
#define MIPX_DOSROUTE      I_MIPX | 110 /* Do source routing on this card*/
#define MIPX_NOSROUTE      I_MIPX | 111 /* Don't source routine the card*/
#define MIPX_SETRIPRETRY   I_MIPX | 112 /* Set RIP retry count          */
#define MIPX_SETRIPTO      I_MIPX | 113 /* Set RIP timeout              */
#define MIPX_SETTKRSAP     I_MIPX | 114 /* Set the token ring SAP       */
#define MIPX_SETUSELLC     I_MIPX | 115 /* Put LLC hdr on packets       */
#define MIPX_SETUSESNAP    I_MIPX | 116 /* Put SNAP hdr on packets      */
#define MIPX_8023LEN       I_MIPX | 117 /* 1=make even, 0=dont make even*/
#define MIPX_SENDPTYPE     I_MIPX | 118 /* Send ptype in options on recv*/
#define MIPX_NOSENDPTYPE   I_MIPX | 119 /* Don't send ptype in options  */
#define MIPX_FILTERPTYPE   I_MIPX | 120 /* Filter on recv ptype         */
#define MIPX_NOFILTERPTYPE I_MIPX | 121 /* Don't Filter on recv ptype   */
#define MIPX_SETSENDPTYPE  I_MIPX | 122 /* Set pkt type to send with    */
#define MIPX_GETCARDINFO   I_MIPX | 123 /* Get info on a card           */
#define MIPX_SENDCARDNUM   I_MIPX | 124 /* Send card num up in options  */
#define MIPX_NOSENDCARDNUM I_MIPX | 125 /* Dont send card num in options*/
#define MIPX_SETROUTER     I_MIPX | 126 /* Set router enabled flag      */
#define MIPX_SETRIPAGE     I_MIPX | 127 /* Set RIP age timeout          */
#define MIPX_SETRIPUSAGE   I_MIPX | 128 /* Set RIP usage timeout        */
#define MIPX_SETSROUTEUSAGE I_MIPX| 129 /* Set the SROUTE usage timeout */
#define MIPX_SETINTNET     I_MIPX | 130 /* Set internal network number  */
#define MIPX_NOVIRTADDR    I_MIPX | 131 /* Turn off virtual net num     */
#define MIPX_VIRTADDR      I_MIPX | 132 /* Turn on  virtual net num     */
#define MIPX_SETBCASTFLAG  I_MIPX | 133 /* Turn on bcast flag in addr   */
#define MIPX_NOBCASTFLAG   I_MIPX | 134 /* Turn off bcast flag in addr  */
#define MIPX_GETNETINFO    I_MIPX | 135 /* Get info on a network num    */
#define MIPX_SETDELAYTIME  I_MIPX | 136 /* Set cards delay time         */
#define MIPX_SETROUTEADV   I_MIPX | 137 /* Route advertise timeout      */
#define MIPX_SETSOCKETS    I_MIPX | 138 /* Set default sockets          */
#define MIPX_SETLINKSPEED  I_MIPX | 139 /* Set the link speed for a card*/
#define MIPX_SETWANFLAG    I_MIPX | 140
#define MIPX_GETCARDCHANGES I_MIPX | 141 /* Wait for card changes	*/
#define MIPX_GETMAXADAPTERS I_MIPX | 142
#define MIPX_REUSEADDRESS   I_MIPX | 143
#define MIPX_RERIPNETNUM    I_MIPX | 144 /* ReRip a network         */

/** For Source Routing Support **/

#define MIPX_SRCLEAR       I_MIPX | 200 /* Clear the source routing table*/
#define MIPX_SRDEF         I_MIPX | 201 /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRBCAST       I_MIPX | 202 /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRMULTI       I_MIPX | 203 /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRREMOVE      I_MIPX | 204 /* Remove a node from the table */
#define MIPX_SRLIST        I_MIPX | 205 /* Get the source routing table */
#define MIPX_SRGETPARMS    I_MIPX | 206 /* Get source routing parms     */

#define MIPX_SETSHOULDPUT  I_MIPX | 210 /* Turn on should put call      */
#define MIPX_DELSHOULDPUT  I_MIPX | 211 /* Turn off should put call     */
#define MIPX_GETSHOULDPUT  I_MIPX | 212 /* Get ptr to mipx_shouldput    */

/** Added for ISN **/

#define MIPX_RCVBCAST      I_MIPX | 300 /* (X) Enable broadcast reception */
#define MIPX_NORCVBCAST    I_MIPX | 301 /* (X) Disable broadcast reception */
#define MIPX_ADAPTERNUM    I_MIPX | 302 /* Get maximum adapter number */
#define MIPX_NOTIFYCARDINFO I_MIPX | 303 /* Pend until card info changes */
#define MIPX_LOCALTARGET   I_MIPX | 304 /* Get local target for address */
#define MIPX_NETWORKINFO   I_MIPX | 305 /* Return info about remote net */
#define MIPX_ZEROSOCKET    I_MIPX | 306 /* Use 0 as source socket on sends */

/** Ioctls for SPX **/

#define I_MSPX          (('S' << 24) | ('P' << 16) | ('P' << 8))
#define MSPX_SETADDR       I_MSPX | 0   /* Set the network address      */
#define MSPX_SETPKTSIZE    I_MSPX | 1   /* Set the packet size per card */
#define MSPX_SETDATASTREAM I_MSPX | 2   /* Set datastream type          */

/** Added for NT port **/

#define MSPX_SETASLISTEN   I_MSPX | 100 /* Set as a listen socket       */
#define MSPX_GETSTATUS     I_MSPX | 101 /* Get running status           */
#define MSPX_GETQUEUEPTR   I_MSPX | 102 /* Get ptr to the streams queue */
#define MSPX_SETDATAACK    I_MSPX | 103 /* Set DATA ACK option          */
#define MSPX_NODATAACK     I_MSPX | 104 /* Turn off DATA ACK option     */
#define MSPX_SETMAXPKTSOCK I_MSPX | 105 /* Set the packet size per socket */
#define MSPX_SETWINDOWCARD I_MSPX | 106 /* Set window size for card     */
#define MSPX_SETWINDOWSOCK I_MSPX | 107 /* Set window size for 1 socket */
#define MSPX_SENDHEADER    I_MSPX | 108 /* Send header with data        */
#define MSPX_NOSENDHEADER  I_MSPX | 109 /* Don't send header with data  */
#define MSPX_GETPKTSIZE    I_MSPX | 110 /* Get the packet size per card */
#define MSPX_SETCONNCNT    I_MSPX | 111 /* Set the conn req count       */
#define MSPX_SETCONNTO     I_MSPX | 112 /* Set the conn req timeout     */
#define MSPX_SETALIVECNT   I_MSPX | 113 /* Set the keepalive count      */
#define MSPX_SETALIVETO    I_MSPX | 114 /* Set the keepalive timeout    */
#define MSPX_SETALWAYSEOM  I_MSPX | 115 /* Turn on always EOM flag      */
#define MSPX_NOALWAYSEOM   I_MSPX | 116 /* Turn off always EOM flag     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\inc\bind.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    bind.h

Abstract:

    Private include file for the ISN transport. It defines the
    structures used for binding between IPX and the upper drivers.

Author:

    Adam Barr (adamba) 04-Oct-1993

Revision History:

   Sanjay Anand (SanjayAn) 5-July-1995
   Bug fixes - tagged [SA]

   Ting Cai (TingCai) Sept-18-1998
   Port the to 64-bit environment
   #ifdef SUNDOWN
      ULONG FwdAdapterContext	
   #else
      ULONG_PTR FwdAdapterContext			
   #endif
   
--*/

#ifndef _ISN_BIND_
#define _ISN_BIND_

//
// Retrieve the common definitions.
//

#include <isnkrnl.h>


//
// Define the IOCTL used for binding between the upper
// drivers and IPX.
//

#define _IPX_CONTROL_CODE(request,method) \
            CTL_CODE(FILE_DEVICE_TRANSPORT, request, method, FILE_ANY_ACCESS)

#define IOCTL_IPX_INTERNAL_BIND      _IPX_CONTROL_CODE( 0x1234, METHOD_BUFFERED )


//
// [FW] Error codes - reusing NTSTATUS codes
//

#define  STATUS_ADAPTER_ALREADY_OPENED    STATUS_UNSUCCESSFUL
#define  STATUS_ADAPTER_ALREADY_CLOSED    STATUS_UNSUCCESSFUL
#define  STATUS_FILTER_FAILED             STATUS_UNSUCCESSFUL
#define  STATUS_DROP_SILENTLY             STATUS_UNSUCCESSFUL

//
// Identifier for the drivers in ISN.
//

#define IDENTIFIER_NB  0
#define IDENTIFIER_SPX 1
#define IDENTIFIER_RIP 2
#define IDENTIFIER_IPX 3

#ifdef	_PNP_POWER
//
// This the number of PVOIDs in the beginning of the SEND_RESERVED
// section of a packet header, to be set aside by the ISN clients (NB/SPX)
// for IPX's private use.
//
#define	SEND_RESERVED_COMMON_SIZE	8
#endif

//
// Definition of a RIP router table entry.
//

typedef struct _IPX_ROUTE_ENTRY {
    UCHAR Network[4];
    USHORT NicId;
    UCHAR NextRouter[6];
    NDIS_HANDLE NdisBindingContext;
    USHORT Flags;
    USHORT Timer;
    UINT Segment;
    USHORT TickCount;
    USHORT HopCount;
    LIST_ENTRY AlternateRoute;
    LIST_ENTRY NicLinkage;
    struct {
        LIST_ENTRY Linkage;
        ULONG Reserved[1];
    } PRIVATE;
} IPX_ROUTE_ENTRY, * PIPX_ROUTE_ENTRY;

//
// Definition of the Flags values.
//

#define IPX_ROUTER_PERMANENT_ENTRY    0x0001    // entry should never be deleted
#define IPX_ROUTER_LOCAL_NET          0x0002    // locally attached network
#define IPX_ROUTER_SCHEDULE_ROUTE     0x0004    // call ScheduleRouteHandler after using
#define IPX_ROUTER_GLOBAL_WAN_NET     0x0008    // this is for rip's global network number


//
// Definition of the structure provided on a find
// route/find route completion call.
//

//
// [SA] Bug #15094 added node number to the structure.
//

//
// [FW] Added Hop and Tick counts so this structure can be passed
// as such to the Forwarder - hop and tick counts are queried in actions
//

typedef struct _IPX_FIND_ROUTE_REQUEST {
    UCHAR Network[4];
    UCHAR Node[6] ;
    IPX_LOCAL_TARGET LocalTarget;
    USHORT TickCount;   // [FW]
    USHORT HopCount;    // [FW]
    UCHAR Identifier;
    UCHAR Type;
    UCHAR Reserved1[2];
    PVOID Reserved2;
    LIST_ENTRY Linkage;
} IPX_FIND_ROUTE_REQUEST, *PIPX_FIND_ROUTE_REQUEST;

//
// Definitions for the Type value.
//

#define IPX_FIND_ROUTE_NO_RIP        1  // fail if net is not in database
#define IPX_FIND_ROUTE_RIP_IF_NEEDED 2  // return net if in database, otherwise RIP out
#define IPX_FIND_ROUTE_FORCE_RIP     3  // re-RIP even if net is in database


//
// Structure used when querying the line information
// for a specific NID ID.
//

typedef struct _IPX_LINE_INFO {
    UINT LinkSpeed;
    UINT MaximumPacketSize;
    UINT MaximumSendSize;
    UINT MacOptions;
} IPX_LINE_INFO, *PIPX_LINE_INFO;



//
// Functions provided by the upper driver.
//

//
// [FW] Added the ForwarderAdapterContext to the paramters
// SPX/NB can ignore this for now
//

typedef BOOLEAN
(*IPX_INTERNAL_RECEIVE) (
    IN NDIS_HANDLE MacBindingHandle,
    IN NDIS_HANDLE MacReceiveContext,
    IN ULONG_PTR FwdAdapterContext,  // [FW]
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT LookaheadBufferOffset,
    IN UINT PacketSize,
    IN PMDL pMdl
);

typedef VOID
(*IPX_INTERNAL_RECEIVE_COMPLETE) (
    IN USHORT NicId
);

//
// [FW] Status and ScheduleRoute removed from the bind input
// [ZZZZZZZZZ]

typedef VOID
(*IPX_INTERNAL_STATUS) (
    IN USHORT NicId,
    IN NDIS_STATUS GeneralStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferLength
);

typedef VOID
(*IPX_INTERNAL_SCHEDULE_ROUTE) (
    IN PIPX_ROUTE_ENTRY RouteEntry
);

typedef VOID
(*IPX_INTERNAL_SEND_COMPLETE) (
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
);

typedef VOID
(*IPX_INTERNAL_TRANSFER_DATA_COMPLETE) (
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status,
    IN UINT BytesTransferred
);

typedef VOID
(*IPX_INTERNAL_FIND_ROUTE_COMPLETE) (
    IN PIPX_FIND_ROUTE_REQUEST FindRouteRequest,
    IN BOOLEAN FoundRoute
);

typedef VOID
(*IPX_INTERNAL_LINE_UP) (
    IN USHORT NicId,
    IN PIPX_LINE_INFO LineInfo,
    IN NDIS_MEDIUM DeviceType,
    IN PVOID ConfigurationData
);

typedef VOID
(*IPX_INTERNAL_LINE_DOWN) (
    IN USHORT NicId,
    IN ULONG_PTR  FwdAdapterContext
);

#if defined(_PNP_POWER)

//
// following opcodes are used when calling the
// above handler.
//
typedef enum _IPX_PNP_OPCODE {
    IPX_PNP_ADD_DEVICE,         // 0 - addition of the first adapter
    IPX_PNP_DELETE_DEVICE,      // 1 - deletion of the last adapter
    IPX_PNP_TRANSLATE_DEVICE,   // 2 - translate device resource
    IPX_PNP_TRANSLATE_ADDRESS,  // 3 - translate address resource
    IPX_PNP_ADDRESS_CHANGE,     // 4 - Adapter address or Reserved address changed
    IPX_PNP_QUERY_POWER,        // 5 - NDIS queries if power can go off
    IPX_PNP_SET_POWER,          // 6 - NDIS tells that power is going off
    IPX_PNP_QUERY_REMOVE,       // 7 - NDIS queries if adapter can be removed
    IPX_PNP_CANCEL_REMOVE,       // 8 - NDIS cancels the query_remove
    IPX_PNP_MAX_OPCODES,        // 9
} IPX_PNP_OPCODE, *PIPX_PNP_OPCODE;

//
// PnP event notification handler.
//
typedef NTSTATUS
(*IPX_INTERNAL_PNP_NOTIFICATION) (
    IN      IPX_PNP_OPCODE      PnPOpcode,
    IN OUT  PVOID               PnpData
);

//
// Pointer to this structure is passed in PnPData portion of
// the above handler when the opcode is ADD_DEVICE or DELETE_DEVICE.
//
typedef struct _IPX_PNP_INFO {
    ULONG   NetworkAddress;
    UCHAR   NodeAddress[6];
    BOOLEAN NewReservedAddress;  // where the above is a new reserved
                                // address for the Ipx clients.
    BOOLEAN FirstORLastDevice;  // is this a first card arrival or last card deletion.
    IPX_LINE_INFO   LineInfo;   // New LineInfo.
    NIC_HANDLE NicHandle;
} IPX_PNP_INFO, *PIPX_PNP_INFO;

#endif  _PNP_POWER

//
// [FW] New entry points provided by the Kernel Forwarder.
// These are not filled in by NB and SPX.
//

/*++

Routine Description:

   This routine is provided by the Kernel Forwarder to filter packets being sent out
   by NB/SPX/TDI thru' IPX - does not include those sent out by the Forwarder (external sends)

Arguments:

   LocalTarget - the NicId and next hop router MAC address

   FwdAdapterContext - Forwarder's context - preferred NIC if not INVALID_CONTEXT_VALUE

   Packet - packet to be sent out

   IpxHeader - points to the IPX header

   Data - points to after the IPX header - needed in spoofing of keepalives.

   PacketLength - length of the packet

   fIterate - a flag to indicate if this is a packet for the iteration of which the
                Fwd takes responsibility - typically type 20 NetBIOS frames


Return Value:

   STATUS_SUCCESS - if the preferred NIC was OK and packet passed filtering
   STATUS_NETWORK_UNREACHABLE - if the preferred was not OK or packet failed filtering
   STATUS_PENDING - if preferred NIC was OK but line down

   Forwarder should give us a different status than STATUS_NETWORK_UNREACHABLE for changed NIC
--*/
typedef NTSTATUS
(*IPX_FW_INTERNAL_SEND) (
   IN OUT   PIPX_LOCAL_TARGET LocalTarget,
   IN    ULONG_PTR         FwdAdapterContext,
   IN    PNDIS_PACKET      Packet,
   IN    PUCHAR            IpxHeader,
   IN    PUCHAR            Data,
   IN    ULONG             PacketLength,
   IN    BOOLEAN           fIterate
);

/*++

Routine Description:

   This routine is provided by the Kernel Forwarder to find the route to a given node and network

Arguments:

   Network - the destination network

   Node - destination node

   RouteEntry - filled in by the Forwarder if a route exists

Return Value:

   STATUS_SUCCESS
   STATUS_NETWORK_UNREACHABLE - if the findroute failed

--*/
typedef NTSTATUS
(*IPX_FW_FIND_ROUTE) (
   IN    PUCHAR   Network,
   IN    PUCHAR   Node,
   OUT   PIPX_FIND_ROUTE_REQUEST RouteEntry
);

/*++

Routine Description:

   This routine is provided by the Kernel Forwarder to find the route to a given node and network

Arguments:

   FwdAdapterContext - Forwarder's context

   RemoteAddress - the address the packet came on

   LookAheadBuffer - packet header that came in

   LookAheadBufferSize - size of the lookaheadbuffer

Return Value:

   STATUS_SUCCESS
   STATUS_FILTER_FAILED - if the packet was not allowed by the filter

--*/
typedef NTSTATUS
(*IPX_FW_INTERNAL_RECEIVE) (
   IN ULONG_PTR            FwdAdapterContext,
   IN PIPX_LOCAL_TARGET    RemoteAddress,
   IN PUCHAR               LookAheadBuffer,
   IN UINT                 LookAheadBufferSize
);

//
// Input to the bind IOCTL
//

//
// [FW] Removed the status and schedule route handlers
//
typedef struct _IPX_INTERNAL_BIND_INPUT {
    USHORT Version;
    UCHAR Identifier;
    BOOLEAN BroadcastEnable;
    UINT LookaheadRequired;
    UINT ProtocolOptions;
    IPX_INTERNAL_RECEIVE ReceiveHandler;
    IPX_INTERNAL_RECEIVE_COMPLETE ReceiveCompleteHandler;
    IPX_INTERNAL_STATUS StatusHandler;
    IPX_INTERNAL_SEND_COMPLETE SendCompleteHandler;
    IPX_INTERNAL_TRANSFER_DATA_COMPLETE TransferDataCompleteHandler;
    IPX_INTERNAL_FIND_ROUTE_COMPLETE FindRouteCompleteHandler;
    IPX_INTERNAL_LINE_UP LineUpHandler;
    IPX_INTERNAL_LINE_DOWN LineDownHandler;
    IPX_INTERNAL_SCHEDULE_ROUTE ScheduleRouteHandler;
#if defined(_PNP_POWER)
    IPX_INTERNAL_PNP_NOTIFICATION PnPHandler;
#endif _PNP_POWER
    IPX_FW_INTERNAL_SEND   InternalSendHandler;
    IPX_FW_FIND_ROUTE   FindRouteHandler;
    IPX_FW_INTERNAL_RECEIVE   InternalReceiveHandler;
    ULONG RipParameters;
} IPX_INTERNAL_BIND_INPUT, * PIPX_INTERNAL_BIND_INPUT;

#if     defined(_PNP_POWER)
#define ISN_VERSION 2
#endif  _PNP_POWER


//
// Bit mask values for RipParameters.
//

#define IPX_RIP_PARAM_GLOBAL_NETWORK  0x00000001   // single network for all WANS



//
// Functions provided by the lower driver.
//

typedef NDIS_STATUS
(*IPX_INTERNAL_SEND) (
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
);

typedef VOID
(*IPX_INTERNAL_FIND_ROUTE) (
    IN PIPX_FIND_ROUTE_REQUEST FindRouteRequest
);

typedef NTSTATUS
(*IPX_INTERNAL_QUERY) (
    IN ULONG InternalQueryType,
#if defined(_PNP_POWER)
    IN PNIC_HANDLE NicHandle OPTIONAL,
#else
    IN USHORT   NicId OPTIONAL,
#endif  _PNP_POWER
    IN OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG BufferLengthNeeded OPTIONAL
);

typedef VOID
(*IPX_INTERNAL_TRANSFER_DATA)(
	OUT PNDIS_STATUS Status,
	IN NDIS_HANDLE NdisBindingHandle,
	IN NDIS_HANDLE MacReceiveContext,
	IN UINT ByteOffset,
	IN UINT BytesToTransfer,
	IN OUT PNDIS_PACKET Packet,
	OUT PUINT BytesTransferred
    );

typedef VOID 
(*IPX_INTERNAL_PNP_COMPLETE) (
                              IN PNET_PNP_EVENT NetPnPEvent,
                              IN NTSTATUS       Status
                              );
//
// Definitions of the internal query types. In all cases
// STATUS_SUCCESS is returned if the request succeeds, and
// STATUS_BUFFER_TOO_SMALL is returned, and BufferLengthNeeded
// set if specified, if the buffer is too short. Other
// return codes are defined below. The routine never pends.
//

//
// This is used to query the line info. NicId specifies which one
// to query. Buffer contains an IPX_LINE_INFO structure which is
// used to return the information. Other return values:
//
// STATUS_INVALID_PARAMETER - NicId is invalid.
//

#define IPX_QUERY_LINE_INFO             1

//
// This is used to query the maximum NicId. NicId is unused. The
// Buffer contains a USHORT which is used to return the information.
//

#define IPX_QUERY_MAXIMUM_NIC_ID        2

//
// This is used to determine if the IPX address specified was sent
// by our local machine. If the address is the source address of a
// received frame, NicId should be the ID that was indicated; otherwise
// it should be set to 0. Buffer holds a TDI_ADDRESS_IPX. This
// call returns STATUS_SUCCESS if the address is local, and
// STATUS_NO_SUCH_DEVICE if not.
//

#define IPX_QUERY_IS_ADDRESS_LOCAL      3

//
// This is used to query the receive buffer space of a given NicId.
// Buffer contains a ULONG which is used to return the information.
// It returns STATUS_INVALID_PARAMETER if NicId is invalid.
//

#define IPX_QUERY_RECEIVE_BUFFER_SPACE  4

//
// This is used to query the local IPX address of a given NicId.
// Buffer contains a TDI_ADDRESS_IPX structure (the Socket is
// returned as 0). If it is queried on net 0 it returns the
// virtual network if there is one, otherwise STATUS_INVALID_PARAMETER.
// It returns STATUS_INVALID_PARAMETER if NicId is invalid.
//

#define IPX_QUERY_IPX_ADDRESS           5

//
// This is used to return the source routing information for
// a give remote address. NicId will be the NIC the packet was
// received from. The IPX_SOURCE_ROUTING_QUERY is contained
// in Buffer. Always returns STATUS_SUCCESS, although the
// SourceRoutingLength may be 0 for unknown remotes.
//
// The source routing is return in the direction it was received
// from the remote, not the direction used in replying. The
// MaximumSendSize includes the IPX header (as it does in
// IPX_LINE_INFO).
//

#define IPX_QUERY_SOURCE_ROUTING        6

typedef struct _IPX_SOURCE_ROUTING_INFO {
    USHORT Identifier;            // input: the caller's IDENTIFIER_SPX, _NB, etc.
    UCHAR RemoteAddress[6];       // input: the remote address
    UCHAR SourceRouting[18];      // output: room for the maximum source route
    USHORT SourceRoutingLength;   // output: the valid length of source route
    ULONG MaximumSendSize;        // output: based on nic and source routing
} IPX_SOURCE_ROUTING_INFO, * PIPX_SOURCE_ROUTING_INFO;

//
// This is used to query the maximum NicId over which outgoing type
// 20 packets should be sent. It will be less than or equal to
// the IPX_QUERY_MAXIMUM_NIC_ID value. What's excluded are down wan
// lines and dialin wan lines if DisableDialinNetbios bit 1 is set.
//

#define IPX_QUERY_MAX_TYPE_20_NIC_ID    7

#if defined(_PNP_POWER)

//
// This are used by NB to pass down these TDI queries which cannot
// be completed in NB.
//

#define IPX_QUERY_DATA_LINK_ADDRESS     8
#define IPX_QUERY_NETWORK_ADDRESS       9

#endif  _PNP_POWER

#define IPX_QUERY_MEDIA_TYPE           10

#define IPX_QUERY_DEVICE_RELATION      11 

//
// Output of a non-RIP bind.
//

typedef struct _IPX_INTERNAL_BIND_OUTPUT {
    USHORT Version;
    UCHAR Node[6];
    UCHAR Network[4];
    USHORT MacHeaderNeeded;
    USHORT IncludedHeaderOffset;
    IPX_LINE_INFO LineInfo;
    IPX_INTERNAL_SEND SendHandler;
    IPX_INTERNAL_FIND_ROUTE FindRouteHandler;
    IPX_INTERNAL_QUERY QueryHandler;
    IPX_INTERNAL_TRANSFER_DATA  TransferDataHandler;
    IPX_INTERNAL_PNP_COMPLETE   PnPCompleteHandler;
} IPX_INTERNAL_BIND_OUTPUT, * PIPX_INTERNAL_BIND_OUTPUT;



//
// Lower driver functions provided only for RIP.
//

typedef UINT
(*IPX_INTERNAL_GET_SEGMENT) (
    IN UCHAR Network[4]
);

typedef PIPX_ROUTE_ENTRY
(*IPX_INTERNAL_GET_ROUTE) (
    IN UINT Segment,
    IN UCHAR Network[4]
);

typedef BOOLEAN
(*IPX_INTERNAL_ADD_ROUTE) (
    IN UINT Segment,
    IN PIPX_ROUTE_ENTRY RouteEntry
);

typedef BOOLEAN
(*IPX_INTERNAL_DELETE_ROUTE) (
    IN UINT Segment,
    IN PIPX_ROUTE_ENTRY RouteEntry
);

typedef PIPX_ROUTE_ENTRY
(*IPX_INTERNAL_GET_FIRST_ROUTE) (
    IN UINT Segment
);

typedef PIPX_ROUTE_ENTRY
(*IPX_INTERNAL_GET_NEXT_ROUTE) (
    IN UINT Segment
);

typedef VOID
(*IPX_INTERNAL_INCREMENT_WAN_INACTIVITY) (
#ifdef	_PNP_LATER
	IN	NIC_HANDLE	NicHandle
#else
    IN USHORT NicId
#endif
);

typedef ULONG
(*IPX_INTERNAL_QUERY_WAN_INACTIVITY) (
#ifdef	_PNP_LATER
	IN	NIC_HANDLE	NicHandle
#else
    IN USHORT NicId
#endif

);

/*++

Routine Description:

   This routine is called by the Kernel Forwarder to open an adapter

Arguments:

   AdapterIndex - index of the adapter to open (NICid for now - will change to a struct
                  with a version number, signature and the NicId
   FwdAdapterContext - Forwarder's context
   IpxAdapterContext - our context (for now we use the NICid - for pnp will change
                       this to contain a signature and version #)

Return Value:

   STATUS_INVALID_HANDLE   if the AdapterIndex handle was invalid
   STATUS_ADAPTER_ALREADY_OPENED    if the Adapter is being opened a second time
   STATUS_SUCCESS

--*/
typedef NTSTATUS
(*IPX_FW_OPEN_ADAPTER) (
   IN    NIC_HANDLE     AdapterIndex,
   IN    ULONG_PTR      FwdAdapterContext,
   OUT   PNIC_HANDLE    IpxAdapterContext
);

/*++

Routine Description:

   This routine is called by the Kernel Forwarder to close an adapter

Arguments:

   IpxAdapterContext - our context (for now we use the NICid - for pnp will change
                       this to contain a signature and version#)

Return Value:

   STATUS_ADAPTER_ALREADY_CLOSED - if the adapter is being closed a second time
   STATUS_SUCCESS

--*/
typedef NTSTATUS
(*IPX_FW_CLOSE_ADAPTER) (
   IN NIC_HANDLE  IpxAdapterContext
);

/*++

Routine Description:

   This routine is called by the Kernel Forwarder to indicate that a pending
   internal send to it has completed.

Arguments:

   LocalTarget - if Status is OK, this has the local target for the send.

   Packet - A pointer to the NDIS_PACKET that we sent.

   PacketLength - length of the packet (including the IPX header)

   Status - the completion status of the send - STATUS_SUCCESS or STATUS_NETWORK_UNREACHABLE

Return Value:

   none.

--*/
typedef VOID
(*IPX_FW_INTERNAL_SEND_COMPLETE) (
   IN PIPX_LOCAL_TARGET LocalTarget,
   IN PNDIS_PACKET      Packet,
   IN ULONG             PacketLength,
   IN NTSTATUS          Status
);

//
// Describes a single network.
//

typedef struct _IPX_NIC_DATA {
    USHORT NicId;
    UCHAR Node[6];
    UCHAR Network[4];
    IPX_LINE_INFO LineInfo;
    NDIS_MEDIUM DeviceType;
    ULONG EnableWanRouter;
} IPX_NIC_DATA, * PIPX_NIC_DATA;


//
// Describes all networks.
//

typedef struct _IPX_NIC_INFO_BUFFER {
    USHORT NicCount;
    USHORT VirtualNicId;
    UCHAR VirtualNetwork[4];
    IPX_NIC_DATA NicData[1];
} IPX_NIC_INFO_BUFFER, * PIPX_NIC_INFO_BUFFER;


//
// Output from a RIP bind (the actual structure size is
// based on the number of IPX_NIC_DATA elements in the
// final IPX_NIC_INFO_BUFFER structure).
//

typedef struct _IPX_INTERNAL_BIND_RIP_OUTPUT {
    USHORT Version;
    USHORT MaximumNicCount;
    USHORT MacHeaderNeeded;
    USHORT IncludedHeaderOffset;
    IPX_INTERNAL_SEND SendHandler;
    UINT SegmentCount;
    KSPIN_LOCK * SegmentLocks;
    IPX_INTERNAL_GET_SEGMENT GetSegmentHandler;
    IPX_INTERNAL_GET_ROUTE GetRouteHandler;
    IPX_INTERNAL_ADD_ROUTE AddRouteHandler;
    IPX_INTERNAL_DELETE_ROUTE DeleteRouteHandler;
    IPX_INTERNAL_GET_FIRST_ROUTE GetFirstRouteHandler;
    IPX_INTERNAL_GET_NEXT_ROUTE GetNextRouteHandler;
    IPX_INTERNAL_INCREMENT_WAN_INACTIVITY IncrementWanInactivityHandler;
    IPX_INTERNAL_QUERY_WAN_INACTIVITY QueryWanInactivityHandler;
    IPX_INTERNAL_TRANSFER_DATA  TransferDataHandler;
    IPX_FW_OPEN_ADAPTER OpenAdapterHandler;
    IPX_FW_CLOSE_ADAPTER   CloseAdapterHandler;
    IPX_FW_INTERNAL_SEND_COMPLETE   InternalSendCompleteHandler;
    IPX_NIC_INFO_BUFFER NicInfoBuffer;
} IPX_INTERNAL_BIND_RIP_OUTPUT, * PIPX_INTERNAL_BIND_RIP_OUTPUT;

//
// [FW] Used by the forwarder to fill up the localtarget
//

#ifdef _PNP_LATER
#define NIC_HANDLE_FROM_NIC(_nichandle, _nic) \
	_nichandle.NicId = _nic; \
	_nichandle.Signature = IPX_BINDING_SIGNATURE; \
	if (_nic == 0) { \
		_nichandle.Version = 0; \
	} else { \
		_nichandle.Version = IpxDevice->Bindings[_nic].Version; \
	}

#else

#define NIC_HANDLE_FROM_NIC(_nichandle, _nic) \
	_nichandle.NicId = (USHORT)_nic;

#endif

//
// VOID
// ADAPTER_CONTEXT_TO_LOCAL_TARGET(
//     IN NIC_HANDLE   _context;
//     IN PIPX_LOCAL_TARGET   _localtarget;
// );
//
#define  ADAPTER_CONTEXT_TO_LOCAL_TARGET(_context, _localtarget)  \
    (_localtarget)->NicHandle.NicId = (_context).NicId;

//
// VOID
// CONSTANT_ADAPTER_CONTEXT_TO_LOCAL_TARGET(
//     IN NIC_HANDLE   _context;
//     IN PIPX_LOCAL_TARGET   _localtarget;
// );
//
#define  CONSTANT_ADAPTER_CONTEXT_TO_LOCAL_TARGET(_context, _localtarget)  \
    (_localtarget)->NicHandle.NicId = (USHORT)(_context);


//
// [FW] Used to indicate to the Forwarder that a preferred NIC is not given
// in InternalSend
//
#define  INVALID_CONTEXT_VALUE   0xffffffff

//
// [FW] This is the value returned (in FindRoute) to IPX from the Forwarder in case of a demand dial Nic.
// On an InternalSend, this is passed up to the FWD, which brings up the line and returns the good LocalTarget
//
#define  DEMAND_DIAL_ADAPTER_CONTEXT   0xffffffff

//
// Adapter context used by the FWD to represent a send to the virtual net.
// IPX maps this to the loopback adapter.
//
#define  VIRTUAL_NET_ADAPTER_CONTEXT   0x1 //0xfffffffe   // -2

//
// Context passed up to the FWD on a loopback send.
//
#define  VIRTUAL_NET_FORWARDER_CONTEXT 0x1 //  0xfffffffe   // -2

//
// Special NIC id used by NB/SPX to send packets over all NICs.
//
#define ITERATIVE_NIC_ID    0xfffd  // -3

#endif // _ISN_BIND_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\fwd\tables.c ===
#include "precomp.h"

// Memory zone for interfaces
ZONE_HEADER		InterfaceZone;
// Segment size in interface sone
ULONG			InterfaceSegmentSize=
			sizeof(INTERFACE_CB)*NUM_INTERFACES_PER_SEGMENT
			+sizeof (ZONE_SEGMENT_HEADER);
KSPIN_LOCK		InterfaceZoneLock;

// Interface tables
LIST_ENTRY		*InterfaceIndexHash;	// Hash by interface index
PINTERFACE_CB	*ClientNodeHash;	// Hash by node on qlobal net
INTERFACE_CB	TheInternalInterface; // The internal interface
PINTERFACE_CB	InternalInterface=&TheInternalInterface; 
KSPIN_LOCK	InterfaceTableLock;	// Protection for interface hash tables

// Memory Zone for routes
ZONE_HEADER		RouteZone;
// Segment size in route sone
ULONG			RouteSegmentSize=DEF_ROUTE_SEGMENT_SIZE;
KSPIN_LOCK		RouteZoneLock;

// Route tables
PFWD_ROUTE		*RouteHash;
PFWD_ROUTE	GlobalRoute;
ULONG		GlobalNetwork;


// NB Route table
PNB_ROUTE		*NBRouteHash;


// Reader-writer lock to wait for all readers to drain when
// updating the route tables
RW_LOCK			RWLock;
// Mutex to serialize writers to route tables
FAST_MUTEX		WriterMutex;


// Sizes of the tables
ULONG			RouteHashSize;		// Must be specified
ULONG			InterfaceHashSize=DEF_INTERFACE_HASH_SIZE;
ULONG			ClientHashSize=DEF_CLIENT_HASH_SIZE;
ULONG			NBRouteHashSize=DEF_NB_ROUTE_HASH_SIZE;

//*** max send pkts queued limit: over this limit the send pkts get discarded
ULONG	MaxSendPktsQueued = MAX_SEND_PKTS_QUEUED;
INT		WanPacketListId = -1;

// Initial memory block allocated for the tables
CHAR	*TableBlock = NULL;

ULONG InterfaceAllocCount = 0;
ULONG InterfaceFreeCount = 0;

// Hash functions
#define InterfaceIndexHashFunc(Interface) (Interface%InterfaceHashSize)
#define ClientNodeHashFunc(Node64) ((UINT)(Node64%ClientHashSize))
#define NetworkNumberHashFunc(Network) (Network%RouteHashSize)
#define NetbiosNameHashFunc(Name128) ((UINT)(Name128[0]+Name128[1])%NBRouteHashSize)

/*++
*******************************************************************
    A l l o c a t e R o u t e

Routine Description:
    Allocates memory for route from memory zone reserved
	for route storage.  Extends zone if there are no
	free blocks in currently allocated segements.
Arguments:
    None
Return Value:
	Pointer to allocated route

*******************************************************************
--*/
PFWD_ROUTE
AllocateRoute (
	void
	) {
	PFWD_ROUTE	fwRoute;
	KIRQL		oldIRQL;

	KeAcquireSpinLock (&RouteZoneLock, &oldIRQL);
		// Check if there are free blocks in the zone
	if (ExIsFullZone (&RouteZone)) {
			// Try to allocate new segment if not
		NTSTATUS	status;
		PVOID	segment = ExAllocatePoolWithTag
					(NonPagedPool, RouteSegmentSize, FWD_POOL_TAG);
		if (segment==NULL) {
			KeReleaseSpinLock (&RouteZoneLock, oldIRQL);
			IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_ERROR,
					("IpxFwd: Can't allocate route zone segment.\n"));
			return NULL;
		}
		status = ExExtendZone (&RouteZone, segment, RouteSegmentSize);
		ASSERTMSG ("Could not extend RouteZone ", NT_SUCCESS (status));
	}
	fwRoute = (PFWD_ROUTE)ExAllocateFromZone (&RouteZone);
	KeReleaseSpinLock (&RouteZoneLock, oldIRQL);
	return fwRoute;
}

/*++
*******************************************************************
    F r e e R o u t e

Routine Description:
    Releases memory allocated for route to route memory
	zone.
Arguments:
	fwRoute - route block to release
Return Value:
	None
*******************************************************************
--*/
VOID
FreeRoute (
	PFWD_ROUTE	fwRoute
	) {
	IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_INFORMATION,
		("IpxFwd: Freeing route block %08lx.\n", fwRoute));
	ASSERT (fwRoute->FR_InterfaceReference==NULL);
	ExInterlockedFreeToZone(&RouteZone,fwRoute,&RouteZoneLock);
}


/*++
*******************************************************************
    A l l o c a t e I n t e r f a c e

Routine Description:
    Allocates memory for interface from memory zone reserved
	for interface storage.  Extends zone if there are no
	free blocks in currently allocated segements.
Arguments:
    None
Return Value:
	Pointer to allocated route

*******************************************************************
--*/
PINTERFACE_CB
AllocateInterface (
	void
	) {
	PINTERFACE_CB	ifCB;
	KIRQL		oldIRQL;

	KeAcquireSpinLock (&RouteZoneLock, &oldIRQL);
		// Check if there are free blocks in the zone
	if (ExIsFullZone (&InterfaceZone)) {
			// Try to allocate new segment if not
		NTSTATUS	status;
		PVOID	segment = ExAllocatePoolWithTag
					(NonPagedPool, InterfaceSegmentSize, FWD_POOL_TAG);
		if (segment==NULL) {
			KeReleaseSpinLock (&RouteZoneLock, oldIRQL);
			IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR, 
					("IpxFwd: Can't allocate interface zone segment.\n"));
			return NULL;
		}
		status = ExExtendZone (&InterfaceZone, segment, InterfaceSegmentSize);
		ASSERTMSG ("Could not extend InterfaceZone ", NT_SUCCESS (status));
	}
	ifCB = (PINTERFACE_CB)ExAllocateFromZone (&InterfaceZone);
	KeReleaseSpinLock (&RouteZoneLock, oldIRQL);

    InterlockedIncrement(&InterfaceAllocCount);
	
	return ifCB;
}

/*++
*******************************************************************
    F r e e I n t e r f a c e

Routine Description:
    Releases memory allocated for interface to interface memory
	zone.
Arguments:
	fwRoute - route block to release
Return Value:
	None
*******************************************************************
--*/
VOID
FreeInterface (
	PINTERFACE_CB	ifCB
	) {
	KIRQL		oldIRQL;

	IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING,
		("IpxFwd: Freeing icb %08lx.\n", ifCB));

	ASSERT(ifCB->ICB_Stats.OperationalState==FWD_OPER_STATE_DOWN);
	KeAcquireSpinLock (&InterfaceZoneLock, &oldIRQL);
	ExFreeToZone(&InterfaceZone, ifCB);
	KeReleaseSpinLock (&InterfaceZoneLock, oldIRQL);


	InterlockedIncrement(&InterfaceFreeCount);

}

/*++
*******************************************************************
    C r e a t e T a b l e s

Routine Description:
	Allocates and intializes all hash tables and related structures
Arguments:
	None
Return Value:
	STATUS_SUCCESS - tables were created ok
	STATUS_INSUFFICIENT_RESOURCES - resource allocation failed
*******************************************************************
--*/
NTSTATUS
CreateTables (
	void
	) {
	UINT		i;
	CHAR 		*segment;
	NTSTATUS	status;
	ULONG		blockSize;

	ASSERT (TableBlock==NULL);

	blockSize = (ULONG) ROUND_TO_PAGES (
					InterfaceHashSize*sizeof(*InterfaceIndexHash)
					+ClientHashSize*sizeof(*ClientNodeHash)
					+RouteHashSize*sizeof(*RouteHash)
					+NBRouteHashSize*sizeof(*NBRouteHash)
					+InterfaceSegmentSize
					+RouteSegmentSize
					);

		// Allocate first segment for route zone
	TableBlock = segment = (CHAR *)ExAllocatePoolWithTag (
						NonPagedPool, blockSize, FWD_POOL_TAG);
	if (segment!=NULL) {
		InterfaceIndexHash = (LIST_ENTRY *)segment;
		segment = (CHAR *)ALIGN_UP((ULONG_PTR)(InterfaceIndexHash+InterfaceHashSize),ULONGLONG);

		ClientNodeHash = (PINTERFACE_CB *)segment;
		segment = (CHAR *)ALIGN_UP((ULONG_PTR)(ClientNodeHash+ClientHashSize),ULONGLONG);
		
		RouteHash = (PFWD_ROUTE *)segment;
		segment = (CHAR *)ALIGN_UP((ULONG_PTR)(RouteHash + RouteHashSize),ULONGLONG);

		NBRouteHash = (PNB_ROUTE *)segment;
		segment = (CHAR *)ALIGN_UP((ULONG_PTR)(NBRouteHash + NBRouteHashSize),ULONGLONG);

		status = ExInitializeZone (&InterfaceZone,
								ALIGN_UP(sizeof (INTERFACE_CB),ULONGLONG),
								segment,
								InterfaceSegmentSize);
		ASSERTMSG ("Could not initalize InterfaceZone ",
										NT_SUCCESS (status));
		segment = (CHAR *)ALIGN_UP((ULONG_PTR)(segment+InterfaceSegmentSize),ULONGLONG);

		status = ExInitializeZone (&RouteZone,
									ALIGN_UP(sizeof (FWD_ROUTE), ULONGLONG),
									segment,
									blockSize - (ULONG)(segment - TableBlock));

		ASSERTMSG ("Could not initalize RouteZone ", NT_SUCCESS (status));
			
		
		// No global route yet
		GlobalRoute = NULL;
		GlobalNetwork = 0xFFFFFFFF;

		InternalInterface = &TheInternalInterface;
		InitICB (InternalInterface,
					FWD_INTERNAL_INTERFACE_INDEX,
					FWD_IF_PERMANENT,
					TRUE,
					FWD_NB_DELIVER_ALL);
#if DBG
		InitializeListHead (&InternalInterface->ICB_InSendQueue);
#endif

		KeInitializeSpinLock (&InterfaceTableLock);
		KeInitializeSpinLock (&InterfaceZoneLock);
		KeInitializeSpinLock (&RouteZoneLock);
		InitializeRWLock (&RWLock);
		ExInitializeFastMutex (&WriterMutex);

			// Initialize hash tables buckets
		for (i=0; i<InterfaceHashSize; i++)
			InitializeListHead (&InterfaceIndexHash[i]);

		for (i=0; i<ClientHashSize; i++) {
			ClientNodeHash[i] = NULL;
		}

		for (i=0; i<RouteHashSize; i++) {
			RouteHash[i] = NULL;
		}

		for (i=0; i<NBRouteHashSize; i++) {
			NBRouteHash[i] = NULL;
		}
		return STATUS_SUCCESS;
	}
	else {
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
			("IpxFwd: Could not allocate table block!\n"));
	}

	return STATUS_INSUFFICIENT_RESOURCES;
}

/*++
*******************************************************************
    D e l e t e T a b l e s

Routine Description:
	Releases resources allocated for all hash tables
Arguments:
	None
Return Value:
	STATUS_SUCCESS - tables were freed ok
*******************************************************************
--*/
NTSTATUS
DeleteTables (
	void
	) {
	UINT		i;
	PVOID		segment;


	if (TableBlock==NULL) {
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR, ("Tables already deleted.\n"));
		return STATUS_SUCCESS;
	}
		// First get rid of all routes
		// (that should release all references to interface
		// control blocks
	for (i=0; i<RouteHashSize; i++) {
		while (RouteHash[i]!=NULL) {
			PFWD_ROUTE	fwRoute = RouteHash[i];
			RouteHash[i] = fwRoute->FR_Next;
			if (fwRoute->FR_InterfaceReference!=GLOBAL_INTERFACE_REFERENCE) {
				ReleaseInterfaceReference (fwRoute->FR_InterfaceReference);
			}
			fwRoute->FR_InterfaceReference = NULL;
			ReleaseRouteReference (fwRoute);
		}
	}
		// Don't forget about global route
	if (GlobalRoute!=NULL) {
		GlobalRoute->FR_InterfaceReference = NULL;
		ReleaseRouteReference (GlobalRoute);
		GlobalRoute = NULL;
		GlobalNetwork = 0xFFFFFFFF;
	}

		// Now we should be able to release all interfaces
	for (i=0; i<InterfaceHashSize; i++) {
		while (!IsListEmpty (&InterfaceIndexHash[i])) {
			PINTERFACE_CB ifCB = CONTAINING_RECORD (InterfaceIndexHash[i].Flink,
														INTERFACE_CB,
														ICB_IndexHashLink);
			RemoveEntryList (&ifCB->ICB_IndexHashLink);
			if (ifCB->ICB_Stats.OperationalState==FWD_OPER_STATE_UP) {
				switch (ifCB->ICB_InterfaceType) {
				case FWD_IF_PERMANENT:
					DeregisterPacketConsumer (ifCB->ICB_PacketListId);
					break;
				case FWD_IF_DEMAND_DIAL:
				case FWD_IF_LOCAL_WORKSTATION:
				case FWD_IF_REMOTE_WORKSTATION:
					break;
				default:
					ASSERTMSG ("Invalid interface type ", FALSE);
					break;
				}
				if (ifCB->ICB_CashedInterface!=NULL)
					ReleaseInterfaceReference (ifCB->ICB_CashedInterface);
				ifCB->ICB_CashedInterface = NULL;
				if (ifCB->ICB_CashedRoute!=NULL)
					ReleaseRouteReference (ifCB->ICB_CashedRoute);
				ifCB->ICB_CashedRoute = NULL;
				if (ifCB->ICB_Network==GlobalNetwork)
					DeleteGlobalNetClient (ifCB);
				IPXCloseAdapterProc (ifCB->ICB_AdapterContext);
                ReleaseInterfaceReference (ifCB);   // Binding reference
			}

			if (IS_IF_CONNECTING (ifCB)) {
				SET_IF_NOT_CONNECTING (ifCB);
				DequeueConnectionRequest (ifCB);
			}

			while (!IsListEmpty (&ifCB->ICB_ExternalQueue)) {
				PPACKET_TAG					pktTag;

				pktTag = CONTAINING_RECORD (ifCB->ICB_ExternalQueue.Flink,
											PACKET_TAG, PT_QueueLink);
				RemoveEntryList (&pktTag->PT_QueueLink);
				ReleaseInterfaceReference (pktTag->PT_InterfaceReference);
				FreePacket (pktTag);
			}

			while (!IsListEmpty (&ifCB->ICB_InternalQueue)) {
				PINTERNAL_PACKET_TAG		pktTag;

				pktTag = CONTAINING_RECORD (ifCB->ICB_InternalQueue.Flink,
									INTERNAL_PACKET_TAG, IPT_QueueLink);
				RemoveEntryList (&pktTag->IPT_QueueLink);
				IPXInternalSendCompletProc (&pktTag->IPT_Target,
							pktTag->IPT_Packet,
							pktTag->IPT_Length,
							STATUS_NETWORK_UNREACHABLE);
				ReleaseInterfaceReference (pktTag->IPT_InterfaceReference);
				ExFreePool (pktTag);
			}

			ifCB->ICB_Stats.OperationalState = FWD_OPER_STATE_DOWN;
			if (ifCB->ICB_NBRoutes!=NULL) {
				DeleteNBRoutes (ifCB->ICB_NBRoutes, ifCB->ICB_NBRouteCount);
				ifCB->ICB_NBRoutes = NULL;
			}
			ReleaseInterfaceReference (ifCB);
		}
	}

	if (InternalInterface->ICB_NBRoutes!=NULL) {
		DeleteNBRoutes (InternalInterface->ICB_NBRoutes,
							InternalInterface->ICB_NBRouteCount);
		InternalInterface->ICB_NBRoutes = NULL;
	}
    if (InternalInterface->ICB_Stats.OperationalState==FWD_OPER_STATE_UP) {
        InternalInterface->ICB_Stats.OperationalState = FWD_OPER_STATE_DOWN;
        ReleaseInterfaceReference (InternalInterface);  // Binding reference
    }
	ReleaseInterfaceReference (InternalInterface);



		// Release extra memory segments used for route table entries
	segment = PopEntryList (&RouteZone.SegmentList);
	while (RouteZone.SegmentList.Next!=NULL) {
		ExFreePool (segment);
		segment = PopEntryList (&RouteZone.SegmentList);
	}

		// Release extra memory segments used for interface table entries
	segment = PopEntryList (&InterfaceZone.SegmentList);
	while (InterfaceZone.SegmentList.Next!=NULL) {
		ExFreePool (segment);
		segment = PopEntryList (&InterfaceZone.SegmentList);
	}

	ExFreePool (TableBlock);
	TableBlock = NULL;
	return STATUS_SUCCESS;
}

/*++
*******************************************************************
    L o c a t e I n t e r f a c e

Routine Description:
	Finds interface control block in interface
	index hash table.  Optionally returns the 
	insertion point pointer if interface block
	with given index is not in the table.
Arguments:
	InterfaceIndex - unique id of the interface
	insertBefore - buffer to place the pointer to
					hash table element where interface
					block should be inserted if it is not
					already in the table
Return Value:
	Pointer to interface control block if found
	NULL otherwise
*******************************************************************
--*/
PINTERFACE_CB
LocateInterface (
	ULONG			InterfaceIndex,
	PLIST_ENTRY		*insertBefore OPTIONAL
	) {
	PLIST_ENTRY		cur;
	PINTERFACE_CB	ifCB;
	PLIST_ENTRY		HashList;

	ASSERT (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX);

		// Find hash bucket
	HashList = &InterfaceIndexHash[InterfaceIndexHashFunc(InterfaceIndex)];
	cur = HashList->Flink;
		// Walk the list
	while (cur!=HashList) {
		ifCB = CONTAINING_RECORD(cur, INTERFACE_CB, ICB_IndexHashLink);

		if (ifCB->ICB_Index==InterfaceIndex)
				// Found, return it (insertion point is irrelevant)
			return ifCB;
		else if (ifCB->ICB_Index>InterfaceIndex)
				// No chance to find it
			break;
		cur = cur->Flink;
	}
		// Return insertion point if asked
	if (ARGUMENT_PRESENT(insertBefore))
		*insertBefore = cur;
	return NULL;
}

/*++
*******************************************************************
    L o c a t e C l i e n t I n t e r f a c e

Routine Description:
	Finds interface control block in client
	node hash bucket.  Optionally returns the 
	insertion point pointer if interface block
	with given node is not in the table
Arguments:
	ClientNode - node address of the client on global network
	insertBefore - buffer to place the pointer to
					hash table element where interface
					block should be inserted if it is not
					already in the table
Return Value:
	Pointer to interface control block if found
	NULL otherwise
*******************************************************************
--*/
PINTERFACE_CB
LocateClientInterface (
	ULONGLONG		*NodeAddress64,
	PINTERFACE_CB	**prevLink OPTIONAL
	) {
	PINTERFACE_CB	cur, *prev;

	prev = &ClientNodeHash[ClientNodeHashFunc (*NodeAddress64)];
	cur = *prev;
	while (cur!=NULL) {
		if (*NodeAddress64==cur->ICB_ClientNode64[0])
			break;
		else if (*NodeAddress64>cur->ICB_ClientNode64[0]) {
			// No chance to find it
			cur = NULL;
			break;
		}
		prev = &cur->ICB_NodeHashLink;
		cur = cur->ICB_NodeHashLink;
	}
	if (ARGUMENT_PRESENT(prevLink))
		*prevLink = prev;
	return cur;
}

/*++
*******************************************************************
    L o c a t e R o u t e

Routine Description:
	Finds route block in network number
	hash table.  Optionally returns the 
	insertion point pointer if route
	for given destination netowrk is not in the table
Arguments:
	Network - destination netowork number
	insertBefore - buffer to place the pointer to
					hash table element where route
					block should be inserted if it is not
					already in the table
Return Value:
	Pointer to route block if found
	NULL otherwise
*******************************************************************
--*/
PFWD_ROUTE
LocateRoute (
	ULONG			Network,
	PFWD_ROUTE		**prevLink OPTIONAL
	) {
	PFWD_ROUTE		cur, *prev;

	prev = &RouteHash[NetworkNumberHashFunc(Network)];
	cur = *prev;

	while (cur!=NULL) {
		if (cur->FR_Network==Network)
			break;
		else if (cur->FR_Network>Network) {
			cur = NULL;
				// No chance to find it
			break;
		}
		prev = &cur->FR_Next;
		cur = *prev;
	}
	if (ARGUMENT_PRESENT(prevLink))
		*prevLink = prev;

	return cur;
}

/*++
*******************************************************************
    L o c a t e N B R o u t e

Routine Description:
	Finds nb route block in nb name
	hash table.  Optionally returns the 
	insertion point pointer if nb route
	for given name is not in the table
Arguments:
	Name - netbios name
	insertBefore - buffer to place the pointer to
					hash table element where route
					block should be inserted if it is not
					already in the table
Return Value:
	Pointer to nb route block if found
	NULL otherwise
*******************************************************************
--*/
PNB_ROUTE
LocateNBRoute (
	ULONGLONG		*Name128,
	PNB_ROUTE		**prevLink OPTIONAL
	) {
	PNB_ROUTE		cur, *prev;

	prev = &NBRouteHash[NetbiosNameHashFunc(Name128)];
	cur = *prev;

	while (cur!=NULL) {
		if ((cur->NBR_Name128[0]==Name128[0])
				&& (cur->NBR_Name128[1]==Name128[1]))
			break;
		else if ((cur->NBR_Name128[0]>Name128[0])
				|| ((cur->NBR_Name128[0]==Name128[0])
					&& (cur->NBR_Name128[1]>Name128[1]))) {
			cur = NULL;
				// No chance to find it
			break;
		}
		prev = &cur->NBR_Next;
		cur = *prev;
	}
	if (ARGUMENT_PRESENT(prevLink))
		*prevLink = prev;

	return cur;
}

/*++
*******************************************************************
    G e t I n t e r f a c e R e f e r e n c e

Routine Description:
	Returns reference interface based on its index
Arguments:
	InterfaceIndex - unique id of the interface
Return Value:
	Pointer to interface control block if there is one in the table
	NULL otherwise
*******************************************************************
--*/
PINTERFACE_CB
GetInterfaceReference (
	ULONG			InterfaceIndex
	) {
	KIRQL			oldIRQL;
	PINTERFACE_CB	ifCB;

	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
	if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX)
		ifCB = LocateInterface (InterfaceIndex, NULL);
	else
		ifCB = InternalInterface;

	if (ifCB!=NULL) {
		AcquireInterfaceReference (ifCB);
		//if (ifCB->ICB_Index > 1)
		//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
		//                ("IpxFwd: GetInterfaceReference: Aquired if #%ld (%ld) \n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount));
    }
	else {
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
			("IpxFwd: Could not get interface reference %ld.\n", InterfaceIndex));
	}
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
	return ifCB;
}

//
//  Function    IncrementNicIds
//
//  Increments the nic id of every nic in the interface table
//  whose id is greater than or equal to the given threshold.
//
NTSTATUS IncrementNicids (USHORT usThreshold) {
	KIRQL oldIRQL;
	PINTERFACE_CB ifCB;
	PLIST_ENTRY	cur;
	PLIST_ENTRY	HashList;
	ULONG i;

    IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION, 
                   ("IpxFwd: Incrementing all nic id's >= %d", usThreshold));
                   
	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
    
    // Walk through all of the hash buckets
    for (i = 0; i < InterfaceHashSize; i++) {
    	HashList = &InterfaceIndexHash[i];
    	cur = HashList->Flink;
    	
    	// Walk the list in this bucket updating as needed
    	while (cur!=HashList) {
    		ifCB = CONTAINING_RECORD(cur, INTERFACE_CB, ICB_IndexHashLink);
    		if ((ifCB->ICB_NicId != INVALID_NIC_ID) && (ifCB->ICB_NicId >= usThreshold)) {   
                IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION, 
                               ("IpxFwd: Incrementing nic id %d", ifCB->ICB_NicId));
    		    ifCB->ICB_NicId++;
    		    *((USHORT*)&ifCB->ICB_AdapterContext) = ifCB->ICB_NicId;
    		}
    		cur = cur->Flink;
    	}
    }
	
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);

    return STATUS_SUCCESS;
}

//
//  Function    DecrementNicIds
//
//  Decrements the nic id of every nic in the interface table
//  whose id is greater than the given threshold.
//
NTSTATUS DecrementNicids (USHORT usThreshold) {
	KIRQL oldIRQL;
	PINTERFACE_CB ifCB;
	PLIST_ENTRY	cur;
	PLIST_ENTRY	HashList;
	ULONG i;

    IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION, 
                   ("IpxFwd: Decrementing all nic id's > %d", usThreshold));

	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
    
    // Walk through all of the hash buckets
    for (i = 0; i < InterfaceHashSize; i++) {
    	HashList = &InterfaceIndexHash[i];
    	cur = HashList->Flink;
    	
    	// Walk the list in this bucket updating as needed
    	while (cur!=HashList) {
    		ifCB = CONTAINING_RECORD(cur, INTERFACE_CB, ICB_IndexHashLink);
    		// If this is a bound interface
    		if (ifCB->ICB_NicId != INVALID_NIC_ID) {
    		    // If it's bound to a nic greater than the threshold, update
    		    // the nicid
    		    if (ifCB->ICB_NicId > usThreshold) {
                    IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION, 
                                   ("IpxFwd: Decrementing nic id %d", ifCB->ICB_NicId));
        		    ifCB->ICB_NicId--;
        		}
        		// The if with bound to the threshold is now unbound.
        		else if (ifCB->ICB_NicId == usThreshold) {
                    IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION, 
                                   ("IpxFwd: Marking interface %d as unbound", ifCB->ICB_Index));
        		    ifCB->ICB_NicId = INVALID_NIC_ID;
        		}
    		    *((USHORT*)&ifCB->ICB_AdapterContext) = ifCB->ICB_NicId;
    		}
    		cur = cur->Flink;
    	}
    }
	
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);

    return STATUS_SUCCESS;
}

// 
// Puts as much of the interface table into the buffer pointed to by 
// pRows as there is space.
//
NTSTATUS DoGetIfTable (FWD_INTERFACE_TABLE * pTable, 
                       ULONG dwRowBufferSize)
{
	KIRQL oldIRQL;
	PINTERFACE_CB ifCB;
	PLIST_ENTRY	cur;
	PLIST_ENTRY	HashList;
	ULONG i, j = 0;

	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);

    // Walk through all of the hash buckets
    for (i = 0; i < InterfaceHashSize; i++) {
    	HashList = &InterfaceIndexHash[i];
    	cur = HashList->Flink;
    	
    	// Walk the list in this bucket updating as needed
    	while (cur!=HashList) {
    		ifCB = CONTAINING_RECORD(cur, INTERFACE_CB, ICB_IndexHashLink);

            // Validate the size of the return buffer
            if (dwRowBufferSize < 
                    (sizeof(FWD_INTERFACE_TABLE) + 
                     (sizeof(FWD_INTERFACE_TABLE_ROW) * (j + 1))))
            {
                break;
            }

            // Validate the number of rows
    		if (j >= pTable->dwNumRows)
    		    break;

            // Copy over the interface information
            pTable->pRows[j].dwIndex = ifCB->ICB_Index;
            pTable->pRows[j].dwNetwork = ifCB->ICB_Network;
            memcpy (pTable->pRows[j].uNode, ifCB->ICB_LocalNode, 6);
            memcpy (pTable->pRows[j].uRemoteNode, ifCB->ICB_RemoteNode, 6);
            pTable->pRows[j].usNicId = ifCB->ICB_NicId;
            pTable->pRows[j].ucType = ifCB->ICB_InterfaceType;
            j++;

            // Advance the current row and interface
    		cur = cur->Flink;
    	}
    }
	
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);

	pTable->dwNumRows = j;

    return STATUS_SUCCESS;
}

/*++
*******************************************************************
    G e t N e x t I n t e r f a c e R e f e r e n c e

Routine Description:
	Returns reference to the next interface in the table
	Reference to the provided interface is released
Arguments:
	ifCB - interface to start with or NULL to start from the
			beginning of the interface table
Return Value:
	Pointer to interface control block if thare are any more interfaces
	in the table
	NULL otherwise
*******************************************************************
--*/
PINTERFACE_CB
GetNextInterfaceReference (
	PINTERFACE_CB	ifCB
	) {
	PLIST_ENTRY		cur;
	PLIST_ENTRY		HashList;
	KIRQL			oldIRQL;

	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
	if (ifCB!=NULL) {
		// Find hash bucket
		ASSERT (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);
		HashList = &InterfaceIndexHash[InterfaceIndexHashFunc(ifCB->ICB_Index)];
		if (LocateInterface (ifCB->ICB_Index, &cur)!=NULL)
			cur = ifCB->ICB_IndexHashLink.Flink;
		ReleaseInterfaceReference (ifCB);
		ifCB = NULL;
	}
	else
		cur = HashList = InterfaceIndexHash-1;

	if (cur==HashList) {
		do {
			HashList += 1;
			if (HashList==&InterfaceIndexHash[InterfaceHashSize]) {
				KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
				return NULL;
			}
		} while (IsListEmpty (HashList));
		cur = HashList->Flink;
	}
	ifCB = CONTAINING_RECORD (cur, INTERFACE_CB, ICB_IndexHashLink);
	AcquireInterfaceReference (ifCB);
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);

	return ifCB;
}


/*++
*******************************************************************
        A d d I n t e r f a c e

Routine Description:
	Adds interface control block to the table.
Arguments:
	InterfaceIndex - unique if of the interface
	Info - interface paramters
Return Value:
	STATUS_SUCCESS - interface added ok
	STATUS_UNSUCCESSFUL - interface is already in the table
	STATUS_INSUFFICIENT_RESOURCES - can't allocate memory for
				interface CB
*******************************************************************
--*/
NTSTATUS
AddInterface (
	ULONG		InterfaceIndex,
	UCHAR		InterfaceType,
	BOOLEAN		NetbiosAccept,
	UCHAR		NetbiosDeliver
	) {
	PINTERFACE_CB	ifCB;
	PLIST_ENTRY		cur;
	KIRQL			oldIRQL;
	NTSTATUS		status = STATUS_SUCCESS;

	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
	if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX) {
		ifCB = LocateInterface (InterfaceIndex, &cur);
		if (ifCB==NULL) {
			ifCB = AllocateInterface ();
			if (ifCB!=NULL)
				NOTHING;
			else {
				status = STATUS_INSUFFICIENT_RESOURCES;
				goto AddEnd;
			}
		}
		else {
			IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
				("IpxFwd: Interface %ld is already in the table!\n", InterfaceIndex));
			status = STATUS_UNSUCCESSFUL;
			goto AddEnd;
		}
	}
	else
		ifCB = InternalInterface;

	InitICB (ifCB, InterfaceIndex,InterfaceType,NetbiosAccept,NetbiosDeliver);
#if DBG
	InitializeListHead (&ifCB->ICB_InSendQueue);
#endif

	switch (InterfaceType) {
	case FWD_IF_PERMANENT:
		break;
	case FWD_IF_DEMAND_DIAL:
	case FWD_IF_LOCAL_WORKSTATION:
	case FWD_IF_REMOTE_WORKSTATION:
		ASSERT (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX);
		if (WanPacketListId==-1) {
			status = RegisterPacketConsumer (
							WAN_PACKET_SIZE,
							&WanPacketListId);
			if (!NT_SUCCESS (status)) {
				WanPacketListId = -1;
				break;
			}
		}
		ifCB->ICB_PacketListId = WanPacketListId;
		break;
	}

	if (NT_SUCCESS (status)) {
		if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX) {
			InsertTailList (cur, &ifCB->ICB_IndexHashLink);
		}
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING,
			("IpxFwd: Adding interface %d (icb: %08lx, plid: %d)\n",
			InterfaceIndex, ifCB, ifCB->ICB_PacketListId));
	}
	else 
		FreeInterface (ifCB);

AddEnd:
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
	return status;
}


/*++
*******************************************************************
    A d d G l o b a l N e t C l i e n t

Routine Description:
	Adds interface control block to the table of
	clients on the global network (should be done when
	client connects)
Arguments:
	ifCB - interface control block to add to the table
Return Value:
	STATUS_SUCCESS - interface was added ok
	STATUS_UNSUCCESSFUL - another interface with the same
					node address is already in the table
*******************************************************************
--*/
NTSTATUS
AddGlobalNetClient (
	PINTERFACE_CB	ifCB
	) {
	KIRQL			oldIRQL;
	RWCOOKIE		cookie;
	PINTERFACE_CB	*prev;
	NTSTATUS		status = STATUS_SUCCESS;

	ASSERT (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);

	AcquireReaderAccess (&RWLock, cookie);
	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
	if (LocateClientInterface (ifCB->ICB_ClientNode64, &prev)==NULL) {
		ifCB->ICB_NodeHashLink = *prev;
		*prev = ifCB;
		KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
		ReleaseReaderAccess (&RWLock, cookie);
		AcquireInterfaceReference (ifCB); // To make sure that
							// interface block does not
							// get deleted until it is
							// removed from the node table
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING,
			("IpxFwd: Adding interface %ld (icb: %08lx, ref=%ld)"
			" to global client table.\n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount, ifCB));
	}
	else {
		KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
		ReleaseReaderAccess (&RWLock, cookie);
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
			("IpxFwd: Interface %ld (icb: %08lx)"
			" is already in the global client table.\n",
			ifCB->ICB_Index, ifCB));
		status = STATUS_UNSUCCESSFUL;
	}

	return status;
}

/*++
*******************************************************************
    D e l e t e G l o b a l N e t C l i e n t

Routine Description:
	Removes interface control block from the table of
	clients on the global network (should be done when
	client disconnects)
Arguments:
	ifCB - interface control block to remove from the table
Return Value:
	STATUS_SUCCESS - interface was removed ok
*******************************************************************
--*/
NTSTATUS
DeleteGlobalNetClient (
	PINTERFACE_CB	ifCB
	) {
	KIRQL			oldIRQL;
	RWCOOKIE		cookie;
	PINTERFACE_CB	cur, *prev;

	IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING,
			("IpxFwd: Deleting interface %ld (icb: %08lx)"
			" from global client table.\n", ifCB->ICB_Index, ifCB));

	ASSERT (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);

	AcquireReaderAccess (&RWLock, cookie);
	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
	cur = LocateClientInterface (ifCB->ICB_ClientNode64, &prev);
	ASSERT (cur==ifCB);
	*prev = ifCB->ICB_NodeHashLink;
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
	ReleaseReaderAccess (&RWLock, cookie);

	ReleaseInterfaceReference (ifCB);
	return STATUS_SUCCESS;
}


/*++
*******************************************************************
    D e l e t e I n t e r f a c e

Routine Description:
	Deletes interface control block (the block is not actually 
	disposed of until all references to it are released).
Arguments:
	InterfaceIndex - unique if of the interface
Return Value:
	STATUS_SUCCESS - interface info retreived ok
	STATUS_UNSUCCESSFUL - interface is not in the table
*******************************************************************
--*/
NTSTATUS
DeleteInterface (
	ULONG		InterfaceIndex
	) {
	PINTERFACE_CB	ifCB;
	KIRQL			oldIRQL;
	NTSTATUS		status = STATUS_SUCCESS;

	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);

	if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX)
		ifCB = LocateInterface (InterfaceIndex, NULL);
	else
		ifCB = InternalInterface;
	if (ifCB!=NULL) {
		if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX) {
			RemoveEntryList (&ifCB->ICB_IndexHashLink);
		}
		KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
		if (ifCB->ICB_Stats.OperationalState == FWD_OPER_STATE_UP) {
			IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
				("IpxFwd: Interface %ld (icb: %08lx) was still bound"
				" when asked to delete it.\n",
				ifCB->ICB_Index, ifCB));
			UnbindInterface (ifCB);
		}
		else if (IS_IF_CONNECTING (ifCB)) {
			IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
				("IpxFwd: Interface %ld (icb: %08lx) was still being connected"
				" when asked to delete it.\n",
					ifCB->ICB_Index, ifCB));
			SET_IF_NOT_CONNECTING (ifCB);
			DequeueConnectionRequest (ifCB);
			ProcessInternalQueue (ifCB);
			ProcessExternalQueue (ifCB);
		}

		ifCB->ICB_Stats.OperationalState = FWD_OPER_STATE_DOWN;

		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING,
			("IpxFwd: Deleting interface %ld (icb: %08lx).\n",
			ifCB->ICB_Index, ifCB));

		if (ifCB->ICB_NBRoutes!=NULL) {
			DeleteNBRoutes (ifCB->ICB_NBRoutes, ifCB->ICB_NBRouteCount);
			ifCB->ICB_NBRoutes = NULL;
		}

		FltInterfaceDeleted (ifCB);
		ReleaseInterfaceReference (ifCB);
	}
	else {
		KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
			("IpxFwd: Could not delete interface %ld because it is not found.\n",
			InterfaceIndex));
		status = STATUS_UNSUCCESSFUL;
	}
	return status;

}

/*++
*******************************************************************
    A d d R o u t e

Routine Description:
	Adds route to the hash table and finds and stores the reference
	to the associated interface control block in the route.
Arguments:
	Network - route's destination network
	NextHopAddress - mac address of next hop router if network is not
						directly connected
	TickCount - ticks to reach the destination net
	HopCount - hopss to reach the destination net
	InterfaceIndex - index of the associated interface (through which
						packets destined to the network are to be sent)
Return Value:
	STATUS_SUCCESS - route was added ok
	STATUS_UNSUCCESSFUL - route is already in the table
	STATUS_INSUFFICIENT_RESOURCES - can't allocate memory for
				route block
*******************************************************************
--*/
NTSTATUS
AddRoute (
	ULONG	Network,
	UCHAR	*NextHopAddress,
	USHORT	TickCount,
	USHORT	HopCount,
	ULONG	InterfaceIndex
	) {
	PFWD_ROUTE		fwRoute;
	PFWD_ROUTE		*prev;
	NTSTATUS		status = STATUS_SUCCESS;
	KIRQL			oldIRQL;

		// Assume success, allocate route and intialize it
		// (the goal is to spend as little time as possible
		// inside exclusive usage zone)
	fwRoute = AllocateRoute ();
	if (fwRoute!=NULL) {
		fwRoute->FR_Network = Network;
		IPX_NODE_CPY (fwRoute->FR_NextHopAddress, NextHopAddress);
		fwRoute->FR_TickCount = TickCount;
		fwRoute->FR_HopCount = HopCount;
		fwRoute->FR_ReferenceCount = 0;

		if (InterfaceIndex!=0xFFFFFFFF) {
				// See if interface is there
			KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
			if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX)
				fwRoute->FR_InterfaceReference
					= LocateInterface (InterfaceIndex, NULL);
			else
				fwRoute->FR_InterfaceReference = InternalInterface;
			if (fwRoute->FR_InterfaceReference!=NULL) {
				AcquireInterfaceReference (fwRoute->FR_InterfaceReference);
				//if (fwRoute->FR_InterfaceReference->ICB_Index > 1)
            	//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
            	//                ("IpxFwd: AddRoute: Aquired if #%ld (%ld) \n", 
            	//                fwRoute->FR_InterfaceReference->ICB_Index, 
            	//                fwRoute->FR_InterfaceReference->ICB_ReferenceCount));
				KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
				
				ExAcquireFastMutex (&WriterMutex);
					// Check if route is already there
				if (LocateRoute (Network, &prev)==NULL) {
					fwRoute->FR_Next = *prev;
					*prev = fwRoute;
				}
				else {
					ReleaseInterfaceReference (fwRoute->FR_InterfaceReference);
					fwRoute->FR_InterfaceReference = NULL;
					IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_ERROR,
						("IpxFwd: Route for net %08lx"
						" is already in the table!\n", Network));
					status = STATUS_UNSUCCESSFUL;
				}

				ExReleaseFastMutex (&WriterMutex);
			}
			else {
				KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
				IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_ERROR,
					("IpxFwd: Interface %ld for route for net %08lx"
					" is not in the table!\n", InterfaceIndex, Network));
				status = STATUS_UNSUCCESSFUL;
			}
		}
		else {
			ExAcquireFastMutex (&WriterMutex);
				// Just check if we do not have it already
			if (GlobalRoute==NULL) {
				fwRoute->FR_InterfaceReference = GLOBAL_INTERFACE_REFERENCE;
				GlobalNetwork = Network;
				GlobalRoute = fwRoute;
			}
			else {
				IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_ERROR,
					("IpxFwd: Route for global net %08lx"
					" is already in the table!\n", Network));
				status = STATUS_UNSUCCESSFUL;
			}
			ExReleaseFastMutex (&WriterMutex);
		}

		if (NT_SUCCESS (status)) {
			IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_WARNING,
				("IpxFwd: Adding route for net %08lx"
				" (rb: %08lx, NHA: %02x%02x%02x%02x%02x%02x,"
				" if: %ld, icb: %08lx).\n",
				Network, fwRoute,
				NextHopAddress[0], NextHopAddress[1],
					NextHopAddress[2], NextHopAddress[3],
					NextHopAddress[4],  NextHopAddress[5],
				InterfaceIndex, fwRoute->FR_InterfaceReference));
		}
		else {
			FreeRoute (fwRoute);
		}
	}
	else
		status = STATUS_INSUFFICIENT_RESOURCES;

	return status;
}

/*++
*******************************************************************
    D e l e t e R o u t e

Routine Description:
	Deletes route from the hash table and releases the reference
	to the interface control block associated with the route.
Arguments:
	Network - route's destination network
Return Value:
	STATUS_SUCCESS - route was deleted ok
	STATUS_UNSUCCESSFUL - route is not in the table
*******************************************************************
--*/
NTSTATUS
DeleteRoute (
	ULONG	Network
	) {
	PFWD_ROUTE	fwRoute, *prev;
	NTSTATUS	status = STATUS_SUCCESS;

	ExAcquireFastMutex (&WriterMutex);
	
	if ((GlobalRoute!=NULL)
			&& (GlobalNetwork==Network)) {
		fwRoute = GlobalRoute;
		GlobalNetwork = 0xFFFFFFFF;
		GlobalRoute = NULL;
	}
	else if ((fwRoute=LocateRoute (Network, &prev))!=NULL) {
		*prev = fwRoute->FR_Next;
	}

	if (fwRoute!=NULL) {
		IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_WARNING,
			("IpxFwd: Deleting route for net %08lx (rb: %08lx).\n",
				Network, fwRoute));
		WaitForAllReaders (&RWLock);
		if (fwRoute->FR_InterfaceReference!=GLOBAL_INTERFACE_REFERENCE) {
			ReleaseInterfaceReference (fwRoute->FR_InterfaceReference);
		}
		fwRoute->FR_InterfaceReference = NULL;
		ReleaseRouteReference (fwRoute);
	}
	else {
		IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_ERROR,
			("IpxFwd: Could not delete route for net %08lx because it is not in the table.\n",
				Network));
		status = STATUS_UNSUCCESSFUL;
	}

	ExReleaseFastMutex (&WriterMutex);
	return status;
}

	
/*++
*******************************************************************
    U p d a t e R o u t e

Routine Description:
	Updates route in the hash table
Arguments:
	Network - route's destination network
	NextHopAddress - mac address of next hop router if network is not
						directly connected
	TickCount - ticks to reach the destination net
	HopCount - hopss to reach the destination net
	InterfaceIndex - index of the associated interface (through which
						packets destined to the network are to be sent)
Return Value:
	STATUS_SUCCESS - interface info retreived ok
	STATUS_UNSUCCESSFUL - interface is not in the table
*******************************************************************
--*/
NTSTATUS
UpdateRoute (
	ULONG	Network,
	UCHAR	*NextHopAddress,
	USHORT	TickCount,
	USHORT	HopCount,
	ULONG	InterfaceIndex
	) {
	PFWD_ROUTE		fwRoute = NULL, newRoute, *prev;
	PINTERFACE_CB	ifCB = NULL;
	KIRQL			oldIRQL;
	NTSTATUS		status = STATUS_SUCCESS;


	ExAcquireFastMutex (&WriterMutex);
	
	if ((GlobalRoute!=NULL)
			&& (GlobalNetwork==Network)) {
		InterfaceIndex = 0xFFFFFFFF;
		fwRoute = GlobalRoute;
	}
	else {
		ASSERT (InterfaceIndex!=0xFFFFFFFF);
		fwRoute = LocateRoute (Network, &prev);
	    if ((fwRoute != NULL) && (fwRoute->FR_InterfaceReference == GLOBAL_INTERFACE_REFERENCE))
	    {
    		status = STATUS_UNSUCCESSFUL;
    		goto ExitUpdate;
	    }
	}

	if (fwRoute!=NULL) {
		if (InterfaceIndex!=0xFFFFFFFF) {
			if (fwRoute->FR_InterfaceReference->ICB_Index!=InterfaceIndex) {
				// Get a reference to new interface
				KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
				if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX)
					ifCB = LocateInterface (InterfaceIndex, NULL);
				else
					ifCB = InternalInterface;
				if (ifCB!=NULL) {
					AcquireInterfaceReference (ifCB);
            		//if (ifCB->ICB_Index > 1)
                	//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
                	//                ("IpxFwd: UpdateRoute: Aquired if #%ld (%ld) \n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount));
				}
				else {
					KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
					status = STATUS_UNSUCCESSFUL;
					goto ExitUpdate;
				}
				KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
			}
			else {
				ifCB = fwRoute->FR_InterfaceReference;
				AcquireInterfaceReference (ifCB);
        		//if (ifCB->ICB_Index > 1)
            	//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
            	//                ("IpxFwd: UpdateRoute(2): Aquired if #%ld (%ld) \n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount));
            }
		}
		else
			ifCB = GLOBAL_INTERFACE_REFERENCE;
		newRoute = AllocateRoute ();
		if (newRoute!=NULL) {
			newRoute->FR_Network = Network;
			IPX_NODE_CPY (newRoute->FR_NextHopAddress, NextHopAddress);
			newRoute->FR_TickCount = TickCount;
			newRoute->FR_HopCount = HopCount;
			newRoute->FR_ReferenceCount = 0;
			newRoute->FR_InterfaceReference = ifCB;
				// Lock the table only when updating it
			if (InterfaceIndex!=0xFFFFFFFF) {
				newRoute->FR_Next = fwRoute->FR_Next;
				*prev = newRoute;
			}
			else
				GlobalRoute = newRoute;

			WaitForAllReaders (&RWLock)
			if (fwRoute->FR_InterfaceReference!=GLOBAL_INTERFACE_REFERENCE) {
				ReleaseInterfaceReference (fwRoute->FR_InterfaceReference);
			}
			fwRoute->FR_InterfaceReference = NULL;
			ReleaseRouteReference (fwRoute);

		}
		else
			status = STATUS_INSUFFICIENT_RESOURCES;
	}
	else
		status = STATUS_UNSUCCESSFUL;

ExitUpdate:
	ExReleaseFastMutex (&WriterMutex);
	return status;
}


/*++
*******************************************************************
    F i n d D e s t i n a t i o n

Routine Description:
	Finds destination interface for IPX address and
	returns reference to its control block.
Arguments:
	Network - destination network
	Node	- destination node (needed in case of global client)
	Route	- buffer to hold reference to route block				
Return Value:
	Reference to destination interface CB
	NULL if route it not found
*******************************************************************
--*/
PINTERFACE_CB
FindDestination (
	IN ULONG			Network,
	IN PUCHAR			Node,
	OUT PFWD_ROUTE		*Route
	) {
	PFWD_ROUTE		fwRoute;
	PINTERFACE_CB	ifCB;
	RWCOOKIE		cookie;

	AcquireReaderAccess (&RWLock, cookie);
	if ((GlobalRoute!=NULL)
			&& (GlobalNetwork==Network)) {
		if (Node!=NULL) {	// If caller did not specify node, 
								// we can't find the route
			union {
				ULONGLONG	Node64[1];
				UCHAR		Node[6];
			} u;
			u.Node64[0] = 0;
			IPX_NODE_CPY (u.Node, Node);

			ifCB = LocateClientInterface (u.Node64, NULL);
			if (ifCB!=NULL) {
				AcquireRouteReference (GlobalRoute);
				*Route = GlobalRoute;
				AcquireInterfaceReference (ifCB);
        		//if (ifCB->ICB_Index > 1)
            	//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
            	//                ("IpxFwd: FindDestination: Aquired if #%ld (%ld) \n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount));
			}
			else
				*Route = NULL;
		}
		else {
			ifCB = NULL;
			*Route = NULL;
		}
	}
	else {
		*Route = fwRoute = LocateRoute (Network, NULL);
		if (fwRoute!=NULL) {
			AcquireRouteReference (fwRoute);
			ifCB = fwRoute->FR_InterfaceReference;
			AcquireInterfaceReference (ifCB);
    		//if (ifCB->ICB_Index > 1)
        	//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
        	//                ("IpxFwd: FindDestination(2): Aquired if #%ld (%ld) \n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount));
		}
		else
			ifCB = NULL;
	}	
	ReleaseReaderAccess (&RWLock, cookie);
	return ifCB;
}

/*++
*******************************************************************
    A d d N B R o u t e s

Routine Description:
	Adds netbios names associated with interface to netbios
	route hash table
Arguments:
	ifCB	- interface with which names are associated
	Names	- array of names
	Count	- number of names in the array
	routeArray - buffer to place allocated array of routes
Return Value:
	STATUS_SUCCESS - names were added ok
	STATUS_UNSUCCESSFUL - one of the names is already in the table
	STATUS_INSUFFICIENT_RESOURCES - can't allocate memory for
				route array
*******************************************************************
--*/
NTSTATUS
AddNBRoutes (
	PINTERFACE_CB	ifCB,
	FWD_NB_NAME		Names[],
	ULONG			Count,
	PNB_ROUTE		*routeArray
	) {
	PNB_ROUTE		nbRoutes, *prev;
	NTSTATUS		status = STATUS_SUCCESS;

	nbRoutes = (PNB_ROUTE)ExAllocatePoolWithTag  (
					NonPagedPool, sizeof (NB_ROUTE)*Count, FWD_POOL_TAG);
	if (nbRoutes!=NULL) {
		ULONG	i;

		ExAcquireFastMutex (&WriterMutex);

		for (i=0; i<Count; i++) {
			nbRoutes[i].NBR_Name128[0] = nbRoutes[i].NBR_Name128[1] = 0;
			NB_NAME_CPY (nbRoutes[i].NBR_Name, &Names[i]);
				// Check if route is already there
			if (LocateNBRoute (nbRoutes[i].NBR_Name128, &prev)==NULL) {
				nbRoutes[i].NBR_Destination = ifCB;
				nbRoutes[i].NBR_Next = *prev;
				*prev = &nbRoutes[i];
				IpxFwdDbgPrint (DBG_NBROUTE_TABLE, DBG_WARNING,
					("IpxFwd: Adding nb route for name %16s.\n",Names[i]));
			}
			else {
				IpxFwdDbgPrint (DBG_NBROUTE_TABLE, DBG_ERROR,
					("IpxFwd: Route for nb name %16s"
					" is already in the table!\n", Names[i]));
				break;
			}
		}
		ExReleaseFastMutex (&WriterMutex);
		if (i==Count) {
			*routeArray = nbRoutes;
			status = STATUS_SUCCESS;

		}
		else {
			status = STATUS_UNSUCCESSFUL;
			DeleteNBRoutes (nbRoutes, i);
		}
	}
	else {
		IpxFwdDbgPrint (DBG_NBROUTE_TABLE, DBG_ERROR,
					("IpxFwd: Could allocate nb route array for if: %ld"
						" (icb: %08lx).\n", ifCB->ICB_Index, ifCB));
		status = STATUS_INSUFFICIENT_RESOURCES;
	}
	return status;
}

/*++
*******************************************************************
    D e l e t e N B R o u t e s

Routine Description:
	Deletes nb routes in the array from the route table and frees
	the array
Arguments:
	nbRoutes - array of routes
	Count	- number of routes in the array
Return Value:
	STATUS_SUCCESS - route was deleted ok
	STATUS_UNSUCCESSFUL - route is not in the table
*******************************************************************
--*/
NTSTATUS
DeleteNBRoutes (
	PNB_ROUTE		nbRoutes,
	ULONG			Count
	) {
	PNB_ROUTE	*prev;
	NTSTATUS	status = STATUS_SUCCESS;
	ULONG		i;

	ExAcquireFastMutex (&WriterMutex);
	for (i=0; i<Count; i++) {
		PNB_ROUTE	cur = LocateNBRoute (nbRoutes[i].NBR_Name128, &prev);
		ASSERT (cur==&nbRoutes[i]);
		*prev = nbRoutes[i].NBR_Next;
		IpxFwdDbgPrint (DBG_NBROUTE_TABLE, DBG_WARNING,
					("IpxFwd: Deleting nb route for name %16s.\n",
							nbRoutes[i].NBR_Name));
	}

	WaitForAllReaders (&RWLock);
	ExReleaseFastMutex (&WriterMutex);

	ExFreePool (nbRoutes);

	return STATUS_SUCCESS;
}

	
/*++
*******************************************************************
    F i n d N B D e s t i n a t i o n

Routine Description:
	Finds destination interface for nb name and
	returns reference to its control block.
Arguments:
	Name	- name to look for
Return Value:
	Reference to destination interface CB
	NULL if route it not found
*******************************************************************
--*/
PINTERFACE_CB
FindNBDestination (
	IN PUCHAR		Name
	) {
	PNB_ROUTE		nbRoute;
	PINTERFACE_CB	ifCB;
	RWCOOKIE		cookie;
	union {
		ULONGLONG	Name128[2];
		UCHAR		Name[16];
	} u;
	u.Name128[0] = u.Name128[1] = 0;
	NB_NAME_CPY (u.Name, Name);

	AcquireReaderAccess (&RWLock, cookie);
	nbRoute = LocateNBRoute (u.Name128, NULL);
	if (nbRoute!=NULL) {
		ifCB = nbRoute->NBR_Destination;
		AcquireInterfaceReference (ifCB);
		//if (ifCB->ICB_Index > 1)
    	//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
    	//                ("IpxFwd: FindNBDestination: Aquired if #%ld (%ld) \n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount));
	}
	else
		ifCB = NULL;
	ReleaseReaderAccess (&RWLock, cookie);
	return ifCB;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\inc\ipxfltif.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    private\inc\ipxfltif.h

Abstract:
    IPX Filter driver interface with forwarder


Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFLTIF_
#define _IPXFLTIF_

	// No filter context means that packets should not
	// be passed for filtering
#define NO_FILTER_CONTEXT ((PVOID)0)


	// Forwarder Driver Entry Points:
	// ==============================
/*++
	S E T _ I F _ I N _ C O N T E X T _ H A N D L E R

Routine Description:
	Associates filter driver context with
	the packets received on the interface
Arguments:
	InterfaceIndex	- index of the interface
	ifInContext		- filter driver context
Return Value:
	STATUS_SUCCESS	- context associated ok
	STATUS_UNSUCCESSFUL - interface does not exist
--*/
typedef
NTSTATUS
(*PSET_IF_IN_CONTEXT_HANDLER) (
	IN ULONG	InterfaceIndex,
	IN PVOID	ifInContext
	);

/*++
	S E T _ I F _ O U T _ C O N T E X T _ H A N D L E R

Routine Description:
	Associates filter driver context with
	the packets sent on the interface
Arguments:
	InterfaceIndex	- index of the interface
	ifOutContext	- filter driver context
Return Value:
	STATUS_SUCCESS	- context associated ok
	STATUS_UNSUCCESSFUL - interface does not exist
--*/
typedef
NTSTATUS
(*PSET_IF_OUT_CONTEXT_HANDLER) (
	IN ULONG	InterfaceIndex,
	IN PVOID	ifOutContext
	);

typedef enum {
	FILTER_DENY_IN = -2,
    FILTER_DENY_OUT = -1,
    FILTER_DENY = 1,
	FILTER_PERMIT = 0
} FILTER_ACTION;
#define NOT_FILTER_ACTION(action) (!action)
#define IS_FILTERED(action) (action!=FILTER_PERMIT)


	// Forwarder Driver Entry Points:
	// ==============================
/*++
	F i l t e r H a n d l e r

Routine Description:
	
	Filters the packet supplied by the forwarder

Arguments:
	ipxHdr			- pointer to packet header
	ipxHdrLength	- size of the header buffer (must be at least 30)
	ifInContext		- context associated with interface on which packet
						was received
	ifOutContext	- context associated with interface on which packet
						will be sent
Return Value:
	FILTER_PERMIT		- packet should be passed on by the forwarder
	FILTER_DENY_IN		- packet should be dropped because of input filter
	FILTER_DENY_OUT		- packet should be dropped because of output filter

--*/
typedef
FILTER_ACTION
(*PFILTER_HANDLER) (
	IN PUCHAR	ipxHdr,
	IN ULONG	ipxHdrLength,
	IN PVOID	ifInContext,
	IN PVOID	ifOutContex
	);

/*++
	I n t e r f a c e D e l e t e d H a n d l e r

Routine Description:
	
	Frees interface filters blocks when forwarder indicates that
	interface is deleted
Arguments:
	ifInContext		- context associated with input filters block	
	ifOutContext	- context associated with output filters block
Return Value:
	None

--*/
typedef
VOID
(*PINTERFACE_DELETED_HANDLER) (
	IN PVOID	ifInContext,
	IN PVOID	ifOutContext
	);

// Binds filter driver to forwarder
// IPX_FLT_BIND_INPUT should be passed in the input buffer and
// IPX_FLT_BINF_OUTPUT will be returned in the output buffer
#define IOCTL_FWD_INTERNAL_BIND_FILTER	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+16,METHOD_BUFFERED,FILE_ANY_ACCESS)

typedef struct _IPX_FLT_BIND_INPUT {
	PFILTER_HANDLER				FilterHandler;
	PINTERFACE_DELETED_HANDLER	InterfaceDeletedHandler;
} IPX_FLT_BIND_INPUT, *PIPX_FLT_BIND_INPUT;

typedef struct _IPX_FLT_BIND_OUTPUT {
	ULONG						Size;
	PSET_IF_IN_CONTEXT_HANDLER	SetIfInContextHandler;
	PSET_IF_OUT_CONTEXT_HANDLER	SetIfOutContextHandler;
} IPX_FLT_BIND_OUTPUT, *PIPX_FLT_BIND_OUTPUT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\adapter.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    adapter.c

Abstract:

    This module contains code which implements the ADAPTER object.
    Routines are provided to reference, and dereference transport
    adapter objects.

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// local function prototypes
//
VOID
IpxDelayedFreeAdapter(
    IN PVOID	Param
);

//********** Pageable Routine Declarations  *****
//************************* PAGEIPX **********************************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEIPX, IpxDelayedFreeAdapter)
#endif
//********** Pageable Routine Declarations *****



//
// These are init only until binding is really dynamic.
//

//
// [FW] So, later we can change this to pnp-compatible value
//

//
// ULONG
// ADAPTER_INDEX_TO_FWCONTEXT(
//    IN ULONG _adapterindex;
// );
//

#define ADAPTER_INDEX_TO_FWCONTEXT(_adapterindex) _adapterindex


VOID
IpxRefBinding(
    IN PBINDING Binding
    )

/*++

Routine Description:

    This routine increments the reference count on a device context.

Arguments:

    Binding - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    CTEAssert (Binding->ReferenceCount > 0);    // not perfect, but...

    (VOID)InterlockedIncrement (&Binding->ReferenceCount);

}   /* IpxRefBinding */


VOID
IpxDerefBinding(
    IN PBINDING Binding
    )

/*++

Routine Description:

    This routine dereferences a device context by decrementing the
    reference count contained in the structure.  Currently, we don't
    do anything special when the reference count drops to zero, but
    we could dynamically unload stuff then.

Arguments:

    Binding - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    LONG result;

    result = InterlockedDecrement (&Binding->ReferenceCount);

    CTEAssert (result >= 0);

    if (result == 0) {
        IpxDestroyBinding (Binding);
    }

}   /* IpxDerefBinding */


NTSTATUS
IpxCreateAdapter(
    IN PDEVICE Device,
    IN PUNICODE_STRING AdapterName,
    IN OUT PADAPTER *AdapterPtr
    )

/*++

Routine Description:

    This routine creates and initializes a device context structure.

Arguments:


    DriverObject - pointer to the IO subsystem supplied driver object.

    Adapter - Pointer to a pointer to a transport device context object.

    AdapterName - pointer to the name of the device this device object points to.

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    PADAPTER Adapter;
#if 0
    UINT i, j;
#endif

    Adapter = (PADAPTER)IpxAllocateMemory (sizeof(ADAPTER) + AdapterName->Length + sizeof(WCHAR), MEMORY_ADAPTER, "Adapter");

    if (Adapter == NULL) {
		if (KeGetCurrentIrql() == 0) {
			IPX_DEBUG (ADAPTER, ("Create adapter %ws failed\n", AdapterName));
		} else {
			IPX_DEBUG (ADAPTER, ("Create adapter %lx failed\n", AdapterName));
		}
		return STATUS_INSUFFICIENT_RESOURCES;
	}

    IPX_DEBUG (ADAPTER, ("Create adapter %lx %lx succeeded\n", Adapter, AdapterName));

    RtlZeroMemory(Adapter, sizeof(ADAPTER));

    //
    // Copy over the adapter name.
    //

    Adapter->AdapterNameLength = AdapterName->Length + sizeof(WCHAR);
    Adapter->AdapterName = (PWCHAR)(Adapter+1);
    RtlCopyMemory(
        Adapter->AdapterName,
        AdapterName->Buffer,
        AdapterName->Length);
    Adapter->AdapterName[AdapterName->Length/sizeof(WCHAR)] = UNICODE_NULL;


#if DBG
    RtlCopyMemory(Adapter->Signature1, "IAD1", 4);
#endif

    Adapter->Type = IPX_ADAPTER_SIGNATURE;
    Adapter->Size = sizeof(ADAPTER);

    CTEInitLock (&Adapter->Lock);

    InitializeListHead (&Adapter->RequestCompletionQueue);

    InitializeListHead (&Adapter->ReceiveBufferPoolList);

    ExInitializeSListHead (&Adapter->ReceiveBufferList);

    Adapter->Device = Device;
    Adapter->DeviceLock = &Device->Lock;
    IpxReferenceDevice (Device, DREF_ADAPTER);

    Adapter->Disabled = ENABLED;                // used iu NDIS_MEDIA_SENSE ...

#if 0
    Adapter->ReceiveBufferPool.Next = NULL;
    for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {
        Adapter->Bindings[i] = NULL;
    }
    Adapter->BindingCount = 0;

    for (i = 0; i < IDENTIFIER_TOTAL; i++) {
        for (j = 0; j < SOURCE_ROUTE_HASH_SIZE; j++) {
            Adapter->SourceRoutingHeads[i][j] = (PSOURCE_ROUTE)NULL;
        }
    }
#endif

    //
    // For the moment, we have to do the source
    // routing operation on any type where broadcast
    // may not be used for discovery -- improve this
    // hopefully.
    //

    Adapter->SourceRoutingEmpty[IDENTIFIER_RIP] = FALSE;
    Adapter->SourceRoutingEmpty[IDENTIFIER_IPX] = FALSE;
    Adapter->SourceRoutingEmpty[IDENTIFIER_SPX] = FALSE;
    Adapter->SourceRoutingEmpty[IDENTIFIER_NB] = TRUE;

	//
	// Lock here? Added lock. [TC]
	//

    KeInitializeEvent(
        &Adapter->NdisEvent,
        NotificationEvent,
        FALSE
    );

    InterlockedExchange(&(Adapter->ReferenceCount),1);
#if DBG
    InterlockedExchange(&(Adapter->RefTypes[ADAP_REF_CREATE]),1);
#endif
    *AdapterPtr = Adapter;

    return STATUS_SUCCESS;

}   /* IpxCreateAdapter */


VOID
IpxDestroyAdapter(
    IN PADAPTER Adapter
    )

/*++

Routine Description:

    This routine destroys a device context structure.

Arguments:

    Adapter - Pointer to a pointer to a transport device context object.

Return Value:

    None.

--*/

{
    ULONG Database, Hash;
    PSOURCE_ROUTE Current;
    ULONG ReceiveBufferPoolSize;
    PIPX_RECEIVE_BUFFER ReceiveBuffer;
    PIPX_RECEIVE_BUFFER_POOL ReceiveBufferPool;
    PDEVICE Device = Adapter->Device;
    PLIST_ENTRY p;
    UINT i;
    PIPX_DELAYED_FREE_ITEM  DelayedFreeItem;

    IPX_DEBUG (ADAPTER, ("Destroy adapter %lx\n", Adapter));

    //
    // Free any receive buffer pools this adapter has.
    //

    ReceiveBufferPoolSize = FIELD_OFFSET (IPX_RECEIVE_BUFFER_POOL, Buffers[0]) +
                       (sizeof(IPX_RECEIVE_BUFFER) * Device->InitReceiveBuffers) +
                       (Adapter->MaxReceivePacketSize * Device->InitReceiveBuffers);

    while (!IsListEmpty (&Adapter->ReceiveBufferPoolList)) {

        p = RemoveHeadList (&Adapter->ReceiveBufferPoolList);
        ReceiveBufferPool = CONTAINING_RECORD (p, IPX_RECEIVE_BUFFER_POOL, Linkage);

        for (i = 0; i < ReceiveBufferPool->BufferCount; i++) {

            ReceiveBuffer = &ReceiveBufferPool->Buffers[i];
            IpxDeinitializeReceiveBuffer (Adapter, ReceiveBuffer, Adapter->MaxReceivePacketSize);

        }

        IPX_DEBUG (PACKET, ("Free buffer pool %lx\n", ReceiveBufferPool));
        IpxFreeMemory (ReceiveBufferPool, ReceiveBufferPoolSize, MEMORY_PACKET, "ReceiveBufferPool");
    }

    //
    // Free all the source routing information for this adapter.
    //

    for (Database = 0; Database < IDENTIFIER_TOTAL; Database++) {

        for (Hash = 0; Hash < SOURCE_ROUTE_HASH_SIZE; Hash++) {

            while (Adapter->SourceRoutingHeads[Database][Hash]) {

                Current = Adapter->SourceRoutingHeads[Database][Hash];
                Adapter->SourceRoutingHeads[Database][Hash] = Current->Next;

                IpxFreeMemory (Current, SOURCE_ROUTE_SIZE (Current->SourceRoutingLength), MEMORY_SOURCE_ROUTE, "SourceRouting");
            }
        }
    }

    //
    // I am moving the following line to the workerthread, so that 
    // the device can go away only after the worker thread completes. [MS]
    //
    // IpxDereferenceDevice (Adapter->Device, DREF_ADAPTER);

    //
    // Free the adapter on a delayed queue so that all
    // the threads inside this would have come out of it.
    // allocate a work item and queue it on a delayed queue.
    //
    DelayedFreeItem = (PIPX_DELAYED_FREE_ITEM)IpxAllocateMemory (
                                        sizeof(IPX_DELAYED_FREE_ITEM),
                                        MEMORY_WORK_ITEM,
                                        "Work Item");
    if ( DelayedFreeItem ) {
        DelayedFreeItem->Context = (PVOID)Adapter;
        DelayedFreeItem->ContextSize = sizeof(ADAPTER) + Adapter->AdapterNameLength;
        ExInitializeWorkItem(
            &DelayedFreeItem->WorkItem,
            IpxDelayedFreeAdapter,
            (PVOID)DelayedFreeItem);

        ExQueueWorkItem(
            &DelayedFreeItem->WorkItem,
            DelayedWorkQueue);

    } else {
        //
        // oh well, tough luck. Just delay this thread and then
        // destroy the adapter.
        //
        LARGE_INTEGER   Delay;
	PDEVICE 	Device; 

        Delay.QuadPart = -10*10000;  // Ten second.
	Device = Adapter->Device; 

        KeDelayExecutionThread(
            KernelMode,
            FALSE,
            &Delay);

        IpxFreeMemory (Adapter, sizeof(ADAPTER) + Adapter->AdapterNameLength, MEMORY_ADAPTER, "Adapter");

	// We need to dereference the adapter in the failure case as well. [TingCai]
	IpxDereferenceDevice (Device, DREF_ADAPTER);
    }

}   /* IpxDestroyAdapter */


VOID
IpxDelayedFreeAdapter(
    IN PVOID	Param
)

/*++

Routine Description:

	This routine frees an adapter on the delayed queue.  We wait long enough
    before freeing an adapter to make sure that no threads are accessing it
    This allows us to access the Adapter without the use of spinlocks.

Arguments:

    Param - pointer to the work item.

Return Value:

    None.

--*/
{
    LARGE_INTEGER   Delay;
    PIPX_DELAYED_FREE_ITEM DelayedFreeItem = (PIPX_DELAYED_FREE_ITEM) Param;
    PADAPTER      Adapter;
    PDEVICE	  Device; 

    Adapter = (PADAPTER) DelayedFreeItem->Context;

    // Keep a pointer, as we need it in IpxDereferenceDevice after we free the memory.[TC]
    Device = Adapter->Device;  


    Delay.QuadPart = -10*10000;  // Ten second.

    KeDelayExecutionThread(
        KernelMode,
        FALSE,
        &Delay);
    
    // IpxFreeMemory needs to access Device structure, so delay the following line
    // to the end of this function. 
    // IpxDereferenceDevice (Adapter->Device, DREF_ADAPTER);

    IpxFreeMemory (
        DelayedFreeItem->Context,
        DelayedFreeItem->ContextSize,
        MEMORY_ADAPTER,
        "Adapter");

    IpxFreeMemory (
        DelayedFreeItem,
        sizeof (IPX_DELAYED_FREE_ITEM),
        MEMORY_WORK_ITEM,
        "Work Item");

    IpxDereferenceDevice (Device, DREF_ADAPTER);

} /* IpxDelayedFreeAdapter */



NTSTATUS
IpxCreateBinding(
    IN PDEVICE Device,
    IN PBINDING_CONFIG ConfigBinding OPTIONAL,
    IN ULONG NetworkNumberIndex,
    IN PWCHAR AdapterName,
    IN OUT PBINDING *BindingPtr
    )

/*++

Routine Description:

    This routine creates and initializes a binding structure.

Arguments:

    Device - The device.

    ConfigBinding - Information about this binding. If this is
        NULL then this is a WAN binding and all the relevant
        information will be filled in by the caller.

    NetworkNumberIndex - The index in the frame type array for
        ConfigBinding indicating which frame type this binding is for.
        Not used if ConfigBinding is not provided.

    AdapterName - Used for error logging.

    BindingPtr - Returns the allocated binding structure.

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    PBINDING Binding;
    PSLIST_ENTRY s;

    s = IPX_POP_ENTRY_LIST(
            &Device->BindingList,
            &Device->SListsLock);

    if (s != NULL) {
         goto GotBinding;
    }

    //
    // This function tries to allocate another packet pool.
    //

    s = IpxPopBinding(Device);

    //
    // Possibly we should queue the packet up to wait
    // for one to become free.
    //

    if (s == NULL) {

#if DBG
        if (KeGetCurrentIrql() == 0) {
            IPX_DEBUG (ADAPTER, ("Create binding %ws failed\n", AdapterName));
        } else {
            IPX_DEBUG (ADAPTER, ("Create binding WAN failed\n"));
        }
#endif
        return STATUS_INSUFFICIENT_RESOURCES;
    }

GotBinding:

    Binding = CONTAINING_RECORD (s, BINDING, PoolLinkage);


#if DBG
    if (KeGetCurrentIrql() == 0) {
        IPX_DEBUG (ADAPTER, ("Create binding %ws succeeded, %lx\n", AdapterName, Binding));
    } else {
        IPX_DEBUG (ADAPTER, ("Create binding WAN succeeded\n"));
    }
#endif

    RtlZeroMemory(Binding, sizeof(BINDING));

    //
    // Initialize the reference count.
    //

    Binding->ReferenceCount = 1;
#if DBG
    Binding->RefTypes[BREF_BOUND] = 1;
#endif

#if DBG
    RtlCopyMemory(Binding->Signature1, "IBI1", 4);
#endif

    Binding->Type = IPX_BINDING_SIGNATURE;
    Binding->Size = sizeof(BINDING);

    Binding->Device = Device;
    Binding->DeviceLock = &Device->Lock;

    if (ConfigBinding != NULL) {

        ULONG Temp = ConfigBinding->NetworkNumber[NetworkNumberIndex];
        Binding->ConfiguredNetworkNumber = REORDER_ULONG (Temp);

        Binding->AutoDetect = ConfigBinding->AutoDetect[NetworkNumberIndex];
        Binding->DefaultAutoDetect = ConfigBinding->DefaultAutoDetect[NetworkNumberIndex];

        Binding->AllRouteDirected = (BOOLEAN)ConfigBinding->Parameters[BINDING_ALL_ROUTE_DEF];
        Binding->AllRouteBroadcast = (BOOLEAN)ConfigBinding->Parameters[BINDING_ALL_ROUTE_BC];
        Binding->AllRouteMulticast = (BOOLEAN)ConfigBinding->Parameters[BINDING_ALL_ROUTE_MC];

    }

    Binding->ReceiveBroadcast = TRUE;
    IPX_DEBUG(ADAPTER, (" %x set to TRUE\n", Binding));

#if 0
    Binding->BindingSetMember = FALSE;
    Binding->NextBinding = (PBINDING)NULL;
    Binding->DialOutAsync = FALSE;
#endif

    Binding->TdiRegistrationHandle = NULL;
    Binding->fInfoIndicated = FALSE;
    Binding->PastAutoDetection = FALSE;
    //
    // We set Binding->FrameType later, after we can map it based on the
    // media type of the adapter we bind to.
    //

    *BindingPtr = Binding;

    return STATUS_SUCCESS;

}   /* IpxCreateBinding */


VOID
IpxDestroyBinding(
    IN PBINDING Binding
    )

/*++

Routine Description:

    This routine destroys a binding structure.

Arguments:

    Binding - Pointer to a transport binding structure.

Return Value:

    None.

--*/

{
    IPX_DEBUG (ADAPTER, ("Destroy binding %lx\n", Binding));


    IPX_PUSH_ENTRY_LIST(
        &IpxDevice->BindingList,
        &Binding->PoolLinkage,
        &IpxDevice->SListsLock);

}   /* IpxDestroyBinding */


VOID
IpxAllocateBindingPool(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine adds 10 bindings to the pool for this device.

Arguments:

    Device - The device.

Return Value:

    None.

--*/

{
    PIPX_BINDING_POOL BindingPool;
    UINT BindingPoolSize;
    UINT BindingNum;
    PBINDING Binding;
    CTELockHandle LockHandle;

    BindingPoolSize = FIELD_OFFSET (IPX_BINDING_POOL, Bindings[0]) +
                       (sizeof(BINDING) * Device->InitBindings);

    BindingPool = (PIPX_BINDING_POOL)IpxAllocateMemory (BindingPoolSize, MEMORY_PACKET, "BindingPool");

    if (BindingPool == NULL) {
        IPX_DEBUG (PNP, ("Could not allocate binding pool memory\n"));
        return;
    }


    IPX_DEBUG (PNP, ("Initializing Binding pool %lx, %d bindings\n",
                             BindingPool, Device->InitBindings));

    BindingPool->BindingCount = Device->InitBindings;

    CTEGetLock (&Device->Lock, &LockHandle);

    for (BindingNum = 0; BindingNum < BindingPool->BindingCount; BindingNum++) {

        Binding = &BindingPool->Bindings[BindingNum];
        IPX_PUSH_ENTRY_LIST (&Device->BindingList, &Binding->PoolLinkage, &Device->SListsLock);

#ifdef IPX_TRACK_POOL
        Binding->Pool = BindingPool;
#endif
    }

    InsertTailList (&Device->BindingPoolList, &BindingPool->Linkage);

    Device->AllocatedBindings += BindingPool->BindingCount;

    CTEFreeLock (&Device->Lock, LockHandle);

}   /* IpxAllocateBindingPool */


PSLIST_ENTRY
IpxPopBinding(
    PDEVICE Device
    )

/*++

Routine Description:

    This routine allocates a binding from the device context's pool.
    If there are no bindings in the pool, it allocates one up to
    the configured limit.

Arguments:

    Device - Pointer to our device to charge the packet to.

Return Value:

    The pointer to the Linkage field in the allocated binding.

--*/

{
    PSLIST_ENTRY s;

    s = IPX_POP_ENTRY_LIST(
            &Device->BindingList,
            &Device->SListsLock);

    if (s != NULL) {
        return s;
    }

    //
    // No packets in the pool, see if we can allocate more.
    //

    if (Device->AllocatedBindings < Device->MaxPoolBindings) {

        //
        // Allocate a pool and try again.
        //

        IpxAllocateBindingPool (Device);
        s = IPX_POP_ENTRY_LIST(
                &Device->BindingList,
                &Device->SListsLock);

        return s;

    } else {

        return NULL;

    }

}   /* IpxPopBinding */

//
// [FW]
//
#ifdef SUNDOWN
NTSTATUS
IpxOpenAdapter(
   IN    NIC_HANDLE  AdapterIndex1,
   IN    ULONG_PTR   FwdAdapterContext,
   OUT   PNIC_HANDLE IpxAdapterContext
   )
#else
NTSTATUS
IpxOpenAdapter(
   IN    NIC_HANDLE  AdapterIndex1,
   IN    ULONG       FwdAdapterContext,
   OUT   PNIC_HANDLE IpxAdapterContext
   )
#endif



/*++

Routine Description:

   This routine is called by the Kernel Forwarder to open an adapter

Arguments:

   AdapterIndex - index of the adapter to open (NICid for now - will change to a struct
                  with a version number, signature and the NicId
   FwdAdapterContext - Forwarder's context
   IpxAdapterContext - our context (for now we use the NICid - for pnp will change
                       this to contain a signature and version #)

Return Value:

   STATUS_INVALID_HANDLE   if the AdapterIndex handle was invalid
   STATUS_ADAPTER_ALREADY_OPENED    if the Adapter is being opened a second time
   STATUS_SUCCESS

--*/

{
   PBINDING Binding;
   PDEVICE  Device = IpxDevice;
   USHORT   AdapterIndex = AdapterIndex1.NicId;

   IPX_DEBUG(ADAPTER, ("IPX: Entered IpxOpenAdapter\n"));

   //
   // Return error if the AdapterIndex is out of range.
   // We do indicate the slave bindings to NB/SPX (but not to RIP)
   // Hence, the index should be less than  HighestExternalNicId (not ValidBindings)
   //

   if (AdapterIndex > Device->HighestExternalNicId) {
      return STATUS_INVALID_HANDLE;
   }


   //
   // Fill up our context to be returned to the Forwarder
   //
   NIC_HANDLE_FROM_NIC((*IpxAdapterContext), AdapterIndex);

   //
   // If AdapterIndex is 0, it is for the virtual net
   // Will the forwarder open this at all?
   //

   if (AdapterIndex == 0) {
      return STATUS_SUCCESS;
   }

   //
   // Get the binding pointer
   //

   Binding = NIC_ID_TO_BINDING(IpxDevice, AdapterIndex);

   if (Binding == NULL) {
      return STATUS_INVALID_HANDLE; 
   }

   //
   // Return error if adapter is being opened a second time (or more times)
   //

   if (GET_LONG_VALUE(Binding->ReferenceCount) >= 2) {
      return STATUS_ADAPTER_ALREADY_OPENED;
   }

   //
   // Store the Forwarder's Adapter Context in the binding
   //

   Binding->FwdAdapterContext = FwdAdapterContext;

   //
   // Reference the Binding
   //

   IpxReferenceBinding(Binding, BREF_FWDOPEN);

   return STATUS_SUCCESS;

}

NTSTATUS
IpxCloseAdapter(
   IN NIC_HANDLE  IpxAdapterContext
   )

/*++

Routine Description:

   This routine is called by the Kernel Forwarder to close an adapter

Arguments:

   IpxAdapterContext - our context (for now we use the NICid - for pnp will change
                       this to contain a signature and version#)

Return Value:

   STATUS_ADAPTER_ALREADY_CLOSED - if the adapter is being closed a second time
   STATUS_SUCCESS

--*/

{

   PBINDING Binding;

   IPX_DEBUG(ADAPTER, ("IPX: Entered IpxCloseAdapter\n"));

   Binding = NIC_ID_TO_BINDING(IpxDevice, IpxAdapterContext.NicId);

   if (Binding == NULL) {
      ASSERT(FALSE); 
      return  STATUS_UNSUCCESSFUL; 
   }
   //
   // Either the adapter is around (count = 2)
   // or it went away (count = 1). The latter cannot happen now.
   //

   if (GET_LONG_VALUE(Binding->ReferenceCount) <= 1) {
      return STATUS_ADAPTER_ALREADY_CLOSED;
   }

   //
   // Dereference the Binding so it can be deleted
   //

   IpxDereferenceBinding(Binding, BREF_FWDOPEN);


   //
   // Clear the Forwarder's Adapter Context in the binding
   //

   Binding->FwdAdapterContext = 0;

   return STATUS_SUCCESS;
}


VOID
IpxRefAdapter(
    IN PADAPTER Adapter
    )

/*++

Routine Description:

    This routine increments the reference count on a adapter context.

Arguments:

    Adapter - Pointer to a transport adapter context object.

Return Value:

    none.

--*/

{
    CTEAssert (Adapter->ReferenceCount > 0);    // not perfect, but...

    (VOID)InterlockedIncrement(&Adapter->ReferenceCount);

}   /* IpxRefAdapter */


VOID
IpxDerefAdapter(
    IN PADAPTER Adapter
    )

/*++

Routine Description:

    This routine dereferences a adapter context by decrementing the
    reference count contained in the structure.  

Arguments:

    Adapter - Pointer to a transport adapter context object.

Return Value:

    none.

--*/

{
    LONG result;


    result = InterlockedDecrement (&Adapter->ReferenceCount);

    CTEAssert (result >= 0);

    if (result == 0) {
       KeSetEvent(&Adapter->NdisEvent, 0L, FALSE); 
    }

}   /* IpxDerefAdapter */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\driver.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module contains the DriverEntry and other initialization
    code for the IPX module of the ISN transport.

Author:

    Adam Barr (adamba) 2-September-1993

Environment:

    Kernel mode

Revision History:

	Sanjay Anand (SanjayAn) - 22-Sept-1995
	BackFill optimization changes added under #if BACK_FILL

	Sanjay Anand (SanjayAn) 18-Sept-1995
	Changes to support Plug and Play

--*/

#include "precomp.h"
#pragma hdrstop
#define	MODULE	0x60000

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

extern NDIS_HANDLE IpxNdisProtocolHandle; 

#ifdef _PNP_POWER_
#include "ipxpnp.h"
void
IpxDoPnPEvent(
    IN CTEEvent *WorkerThreadEvent,
    IN PVOID Context);

#endif //_PNP_POWER_
//
// Local Function prototypes
//

PWSTR IpxDeviceNameString = L"\\Device\\Nwlnkipx";

VOID
IpxDelayedFreeBindingsArray(
    IN PVOID	Param
);

VOID
IpxPnPCompletionHandler(
                        IN PNET_PNP_EVENT   pnp,
                        IN NTSTATUS         status
                        );

//********** Pageable Routine Declarations  *****
//************************* PAGEIPX **********************************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEIPX, IpxDelayedFreeBindingsArray )
#endif
//********** Pageable Routine Declarations *****


PDEVICE IpxDevice = NULL;
PIPX_PADDING_BUFFER IpxPaddingBuffer = NULL;

#if DBG

UCHAR  IpxTempDebugBuffer[300];
ULONG IpxDebug = 0x0;
ULONG IpxMemoryDebug = 0xffffffd3;
UCHAR IpxDebugMemory[IPX_MEMORY_LOG_SIZE][192];
PUCHAR IpxDebugMemoryLoc = IpxDebugMemory[0];
PUCHAR IpxDebugMemoryEnd = IpxDebugMemory[IPX_MEMORY_LOG_SIZE];

VOID
IpxDebugMemoryLog(
    IN PUCHAR FormatString,
    ...
)

{
    INT ArgLen;
    va_list ArgumentPointer;

    va_start(ArgumentPointer, FormatString);

    //
    // To avoid any overflows, copy this in a temp buffer first.
    RtlZeroMemory (IpxTempDebugBuffer, 300);
    ArgLen = vsprintf(IpxTempDebugBuffer, FormatString, ArgumentPointer);
    va_end(ArgumentPointer);

    if ( ArgLen > 192 ) {
        CTEAssert( FALSE );
    } else {
        RtlZeroMemory (IpxDebugMemoryLoc, 192);
        RtlCopyMemory( IpxDebugMemoryLoc, IpxTempDebugBuffer, ArgLen );

        IpxDebugMemoryLoc += 192;
        if (IpxDebugMemoryLoc >= IpxDebugMemoryEnd) {
            IpxDebugMemoryLoc = IpxDebugMemory[0];
        }
    }
}


DEFINE_LOCK_STRUCTURE(IpxMemoryInterlock);
MEMORY_TAG IpxMemoryTag[MEMORY_MAX];

#endif

DEFINE_LOCK_STRUCTURE(IpxGlobalInterlock);

#if DBG

//
// Use for debug printouts
//

PUCHAR FrameTypeNames[5] = { "Ethernet II", "802.3", "802.2", "SNAP", "Arcnet" };
#define OutputFrameType(_Binding) \
    (((_Binding)->Adapter->MacInfo.MediumType == NdisMediumArcnet878_2) ? \
         FrameTypeNames[4] : \
         FrameTypeNames[(_Binding)->FrameType])
#endif


#ifdef IPX_PACKET_LOG

ULONG IpxPacketLogDebug = IPX_PACKET_LOG_RCV_OTHER | IPX_PACKET_LOG_SEND_OTHER;
USHORT IpxPacketLogSocket = 0;
DEFINE_LOCK_STRUCTURE(IpxPacketLogLock);
IPX_PACKET_LOG_ENTRY IpxPacketLog[IPX_PACKET_LOG_LENGTH];
PIPX_PACKET_LOG_ENTRY IpxPacketLogLoc = IpxPacketLog;
PIPX_PACKET_LOG_ENTRY IpxPacketLogEnd = &IpxPacketLog[IPX_PACKET_LOG_LENGTH];

VOID
IpxLogPacket(
    IN BOOLEAN Send,
    IN PUCHAR DestMac,
    IN PUCHAR SrcMac,
    IN USHORT Length,
    IN PVOID IpxHeader,
    IN PVOID Data
    )

{

    CTELockHandle LockHandle;
    PIPX_PACKET_LOG_ENTRY PacketLog;
    LARGE_INTEGER TickCount;
    ULONG DataLength;

    CTEGetLock (&IpxPacketLogLock, &LockHandle);

    PacketLog = IpxPacketLogLoc;

    ++IpxPacketLogLoc;
    if (IpxPacketLogLoc >= IpxPacketLogEnd) {
        IpxPacketLogLoc = IpxPacketLog;
    }
    *(UNALIGNED ULONG *)IpxPacketLogLoc->TimeStamp = 0x3e3d3d3d;    // "===>"

    CTEFreeLock (&IpxPacketLogLock, LockHandle);

    RtlZeroMemory (PacketLog, sizeof(IPX_PACKET_LOG_ENTRY));

    PacketLog->SendReceive = Send ? '>' : '<';

    KeQueryTickCount(&TickCount);
    _itoa (TickCount.LowPart % 100000, PacketLog->TimeStamp, 10);

    RtlCopyMemory(PacketLog->DestMac, DestMac, 6);
    RtlCopyMemory(PacketLog->SrcMac, SrcMac, 6);
    PacketLog->Length[0] = Length / 256;
    PacketLog->Length[1] = Length % 256;

    if (Length < sizeof(IPX_HEADER)) {
        RtlCopyMemory(&PacketLog->IpxHeader, IpxHeader, Length);
    } else {
        RtlCopyMemory(&PacketLog->IpxHeader, IpxHeader, sizeof(IPX_HEADER));
    }

    DataLength = Length - sizeof(IPX_HEADER);
    if (DataLength < 14) {
        RtlCopyMemory(PacketLog->Data, Data, DataLength);
    } else {
        RtlCopyMemory(PacketLog->Data, Data, 14);
    }

}   /* IpxLogPacket */

#endif // IPX_PACKET_LOG


//
// Forward declaration of various routines used in this module.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

//
// This is now shared with other modules
//

VOID
IpxUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
IpxDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IpxDispatchOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IpxDispatchInternal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)

//
// These routines can be called at any time in case of PnP.
//

#endif

UCHAR VirtualNode[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };

//
// This prevents us from having a bss section.
//

ULONG _setjmpexused = 0;

ULONG IpxFailLoad = FALSE;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine performs initialization of the IPX ISN module.
    It creates the device objects for the transport
    provider and performs other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

    RegistryPath - The name of IPX's node in the registry.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status;
    UINT SuccessfulOpens, ValidBindings;
    static const NDIS_STRING ProtocolName = NDIS_STRING_CONST("NWLNKIPX");
    PDEVICE Device;
    PBINDING Binding;
    PADAPTER Adapter;
    ULONG BindingCount, BindingIndex;
    PLIST_ENTRY p;
    ULONG AnnouncedMaxDatagram, RealMaxDatagram, MaxLookahead;
    ULONG LinkSpeed, MacOptions;
    ULONG Temp;
    UINT i;
    BOOLEAN CountedWan;

    PCONFIG Config = NULL;
    PBINDING_CONFIG ConfigBinding;

#if 0
    DbgPrint ("IPX: FailLoad at %lx\n", &IpxFailLoad);

    if (IpxFailLoad) {
        return STATUS_UNSUCCESSFUL;
    }
#endif

    // DbgBreakPoint();
    //
    // This ordering matters because we use it to quickly
    // determine if packets are internally generated or not.
    //

    CTEAssert (IDENTIFIER_NB < IDENTIFIER_IPX);
    CTEAssert (IDENTIFIER_SPX < IDENTIFIER_IPX);
    CTEAssert (IDENTIFIER_RIP < IDENTIFIER_IPX);
    CTEAssert (IDENTIFIER_RIP_INTERNAL > IDENTIFIER_IPX);

    //
    // We assume that this structure is not packet in between
    // the fields.
    //

    CTEAssert (FIELD_OFFSET (TDI_ADDRESS_IPX, Socket) + sizeof(USHORT) == 12);


    //
    // Initialize the Common Transport Environment.
    //

    if (CTEInitialize() == 0) {

        IPX_DEBUG (DEVICE, ("CTEInitialize() failed\n"));
        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_REGISTER_FAILED,
            101,
            STATUS_UNSUCCESSFUL,
            NULL,
            0,
            NULL);
        return STATUS_UNSUCCESSFUL;
    }

#if DBG
    CTEInitLock (&IpxGlobalInterlock);
    CTEInitLock (&IpxMemoryInterlock);
    for (i = 0; i < MEMORY_MAX; i++) {
        IpxMemoryTag[i].Tag = i;
        IpxMemoryTag[i].BytesAllocated = 0;
    }
#endif
#ifdef IPX_PACKET_LOG
    CTEInitLock (&IpxPacketLogLock);
#endif

#ifdef  IPX_OWN_PACKETS
    CTEAssert (NDIS_PACKET_SIZE == FIELD_OFFSET(NDIS_PACKET, ProtocolReserved[0]));
#endif

    IPX_DEBUG (DEVICE, ("IPX loaded\n"));

    //
    // This allocates the CONFIG structure and returns
    // it in Config.
    //

    status = IpxGetConfiguration(DriverObject, RegistryPath, &Config);

    if (!NT_SUCCESS (status)) {

        //
        // If it failed, it logged an error.
        //

        PANIC (" Failed to initialize transport, IPX initialization failed.\n");
        return status;

    }

    //
    // Initialize the TDI layer.
    //
    
    TdiInitialize();

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction [IRP_MJ_CREATE] = IpxDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_CLOSE] = IpxDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_CLEANUP] = IpxDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_PNP] = IpxDispatchOpenClose; 
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] = IpxDispatchInternal;
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = IpxDispatchDeviceControl;

    DriverObject->DriverUnload = IpxUnload;

    SuccessfulOpens = 0;

    status = IpxCreateDevice(
                 DriverObject,
                 &Config->DeviceName,
                 Config->Parameters[CONFIG_RIP_TABLE_SIZE],
                 &Device);

    if (!NT_SUCCESS (status)) {

        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_IPX_CREATE_DEVICE,
            801,
            status,
            NULL,
            0,
            NULL);

        IpxFreeConfiguration(Config);
        IpxDeregisterProtocol();
        return status;
    }

    IpxDevice = Device;

    RtlInitUnicodeString(&IpxDeviceName, IpxDeviceNameString);

    //
    // Initialize and keep track of the Init Time Adapters and such.
    //
    IpxDevice->InitTimeAdapters = 1;
    IpxDevice->NoMoreInitAdapters = FALSE;


    status = TdiRegisterProvider(&IpxDeviceName, &IpxDevice->TdiProviderReadyHandle);
	if (!NT_SUCCESS(status))
	{
        IpxFreeConfiguration(Config);
        IpxDeregisterProtocol();
        return status;
	}

    //
    // Save the relevant configuration parameters.
    //

    Device->DedicatedRouter = (BOOLEAN)(Config->Parameters[CONFIG_DEDICATED_ROUTER] != 0);
    Device->InitDatagrams = Config->Parameters[CONFIG_INIT_DATAGRAMS];
    Device->MaxDatagrams = Config->Parameters[CONFIG_MAX_DATAGRAMS];
    Device->RipAgeTime = Config->Parameters[CONFIG_RIP_AGE_TIME];
    Device->RipCount = Config->Parameters[CONFIG_RIP_COUNT];
    Device->RipTimeout =
        ((Config->Parameters[CONFIG_RIP_TIMEOUT] * 500) + (RIP_GRANULARITY/2)) /
            RIP_GRANULARITY;
    Device->RipUsageTime = Config->Parameters[CONFIG_RIP_USAGE_TIME];
    Device->SourceRouteUsageTime = Config->Parameters[CONFIG_ROUTE_USAGE_TIME];
    Device->SocketUniqueness = Config->Parameters[CONFIG_SOCKET_UNIQUENESS];
    Device->SocketStart = (USHORT)Config->Parameters[CONFIG_SOCKET_START];
    Device->SocketEnd = (USHORT)Config->Parameters[CONFIG_SOCKET_END];
    Device->MemoryLimit = Config->Parameters[CONFIG_MAX_MEMORY_USAGE];
    Device->VerifySourceAddress = (BOOLEAN)(Config->Parameters[CONFIG_VERIFY_SOURCE_ADDRESS] != 0);

    Device->InitReceivePackets = (Device->InitDatagrams + 1) / 2;
    Device->InitReceiveBuffers = (Device->InitDatagrams + 1) / 2;

    Device->MaxReceivePackets = 10;
    Device->MaxReceiveBuffers = 10;

    InitializeListHead(&Device->NicNtfQueue);
    InitializeListHead(&Device->NicNtfComplQueue);

    Device->InitBindings = 5;

    //
    // RAS max is 240 (?) + 10 max LAN
    //
    Device->MaxPoolBindings = 250;

#ifdef  SNMP
    IPX_MIB_ENTRY(Device, SysConfigSockets) = (Device->SocketEnd - Device->SocketStart)
                / ((Device->SocketUniqueness > 1) ? Device->SocketUniqueness : 1);
             ;
#endif  SNMP

    //
    // Have to reverse this.
    //

    Device->VirtualNetworkOptional = (BOOLEAN)(Config->Parameters[CONFIG_VIRTUAL_OPTIONAL] != 0);

    Device->CurrentSocket = Device->SocketStart;

    Device->EthernetPadToEven = (BOOLEAN)(Config->Parameters[CONFIG_ETHERNET_PAD] != 0);
    Device->EthernetExtraPadding = (Config->Parameters[CONFIG_ETHERNET_LENGTH] & 0xfffffffe) + 1;

    Device->SingleNetworkActive = (BOOLEAN)(Config->Parameters[CONFIG_SINGLE_NETWORK] != 0);
    Device->DisableDialoutSap = (BOOLEAN)(Config->Parameters[CONFIG_DISABLE_DIALOUT_SAP] != 0);
    Device->DisableDialinNetbios = (UCHAR)(Config->Parameters[CONFIG_DISABLE_DIALIN_NB]);

    //
    // Used later to access the registry.
    //
    Device->RegistryPathBuffer = Config->RegistryPathBuffer;
	Device->RegistryPath.Length = RegistryPath->Length;
	Device->RegistryPath.MaximumLength = RegistryPath->MaximumLength;
	Device->RegistryPath.Buffer = Device->RegistryPathBuffer;

    //
    // Initialize the BroadcastCount now and so, we dont have to
    // init this field per adapter [MS]
    //
    Device->EnableBroadcastCount = 0;

    //
    // ActiveNetworkWan will start as FALSE, which is correct.
    //

    //
    // Allocate our initial packet pool. We do not allocate
    // receive and receive buffer pools until we need them,
    // because in many cases we never do.
    //

#if BACK_FILL
    IpxAllocateBackFillPool (Device);
#endif

    IpxAllocateSendPool (Device);

    IpxAllocateBindingPool (Device);

    //
    // Allocate one 1-byte buffer for odd length packets.
    //

    IpxPaddingBuffer = IpxAllocatePaddingBuffer(Device);

    if ( IpxPaddingBuffer == (PIPX_PADDING_BUFFER)NULL ) {
        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_RESOURCE_POOL,
            801,
            STATUS_INSUFFICIENT_RESOURCES,
            NULL,
            0,
            NULL);

        TdiDeregisterProvider(IpxDevice->TdiProviderReadyHandle);
        IpxFreeConfiguration(Config);
        IpxDeregisterProtocol();
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the loopback structures
    //
    IpxInitLoopback();

// NIC_HANDLE
// All this will be done on appearance of adapters.
//

{
	PBIND_ARRAY_ELEM	BindingArray;
    PTA_ADDRESS         TdiRegistrationAddress;

	//
	// Pre-allocate the binding array
	// Later, we will allocate the LAN/WAN and SLAVE bindings separately
	// Read the array size from registry?
	//
	BindingArray = (PBIND_ARRAY_ELEM)IpxAllocateMemory (
										MAX_BINDINGS * sizeof(BIND_ARRAY_ELEM),
										MEMORY_BINDING,
										"Binding array");

	if (BindingArray == NULL) {
        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_IPX_NO_ADAPTERS,
            802,
            STATUS_DEVICE_DOES_NOT_EXIST,
            NULL,
            0,
            NULL);
        TdiDeregisterProvider(IpxDevice->TdiProviderReadyHandle);
		IpxDereferenceDevice (Device, DREF_CREATE);
		return STATUS_DEVICE_DOES_NOT_EXIST;
	}

    Device->MaxBindings = MAX_BINDINGS - EXTRA_BINDINGS;

    //
    // Allocate the TA_ADDRESS structure - this will be used in all TdiRegisterNetAddress
    // notifications.
    //
	TdiRegistrationAddress = (PTA_ADDRESS)IpxAllocateMemory (
										    (2 * sizeof(USHORT) + sizeof(TDI_ADDRESS_IPX)),
										    MEMORY_ADDRESS,
										    "Tdi Address");

	if (TdiRegistrationAddress == NULL) {
        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_IPX_NO_ADAPTERS,
            802,
            STATUS_DEVICE_DOES_NOT_EXIST,
            NULL,
            0,
            NULL);
        TdiDeregisterProvider(IpxDevice->TdiProviderReadyHandle);
        IpxFreeMemory(BindingArray, sizeof(BindingArray), MEMORY_BINDING, "Binding Array");
		IpxDereferenceDevice (Device, DREF_CREATE);
		return STATUS_DEVICE_DOES_NOT_EXIST;
	}

	RtlZeroMemory (BindingArray, MAX_BINDINGS * sizeof(BIND_ARRAY_ELEM));
	RtlZeroMemory (TdiRegistrationAddress, 2 * sizeof(USHORT) + sizeof(TDI_ADDRESS_IPX));

    //
    // We keep BindingArray[-1] as a placeholder for demand dial bindings.
    // This NicId is returned by the Fwd when a FindRoute is done on a demand
    // dial Nic. At the time of the InternalSend, the true Nic is returned.
    // We create a placeholder here to avoid special checks in the critical send path.
    //
    // NOTE: we need to free this demand dial binding as well as ensure that the
    // true binding array pointer is freed at Device Destroy time.
    //
    //
    // Increment beyond the first pointer - we will refer to the just incremented
    // one as Device->Bindings[-1].
    //
    BindingArray += EXTRA_BINDINGS;

	Device->Bindings = BindingArray;

    TdiRegistrationAddress->AddressLength = sizeof(TDI_ADDRESS_IPX);
    TdiRegistrationAddress->AddressType = TDI_ADDRESS_TYPE_IPX;

    //
    // Store the pointer in the Device.
    //
    Device->TdiRegistrationAddress = TdiRegistrationAddress;

	//
	// Device state is loaded, but not opened. It is opened when at least
	// one adapter has appeared.
	//
	Device->State = DEVICE_STATE_LOADED;

    Device->FirstLanNicId = Device->FirstWanNicId = (USHORT)1; // will be changed later

	IpxFreeConfiguration(Config);

    //
    // We use this event when unloading to signal that we
    // can proceed...initialize it here so we know it is
    // ready to go when unload is called.
    //

    KeInitializeEvent(
        &IpxDevice->UnloadEvent,
        NotificationEvent,
        FALSE
    );

    KeInitializeEvent(
        &IpxDevice->NbEvent,
        NotificationEvent,
        FALSE
    );

    //
    // Create a loopback adapter right here. [NtBug - 110010]
    //
    status = IpxBindLoopbackAdapter();

    if (status != STATUS_SUCCESS) {

        PANIC ("IpxCreateLoopback adapter failed!\n");
        
        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_REGISTER_FAILED,
            607,
            status,
            NULL,
            0,
            NULL);
        
        TdiDeregisterProvider(IpxDevice->TdiProviderReadyHandle);
        return status;

    } else {

        IPX_DEBUG(DEVICE, ("Created LOOPBACK ADAPTER!\n"));

    }

    //
    // make ourselves known to the NDIS wrapper.
    //

    status = IpxRegisterProtocol ((PNDIS_STRING)&ProtocolName);

    if (!NT_SUCCESS (status)) {

        IpxFreeConfiguration(Config);
        DbgPrint ("IpxInitialize: RegisterProtocol failed with status %x!\n", status);

        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_REGISTER_FAILED,
            607,
            status,
            NULL,
            0,
            NULL);

       return status;
    }
	return STATUS_SUCCESS;
}
}   /* DriverEntry */


ULONG
IpxResolveAutoDetect(
    IN PDEVICE Device,
    IN ULONG ValidBindings,
	IN CTELockHandle	*LockHandle1,
    IN PUNICODE_STRING RegistryPath,
    IN PADAPTER Adapter
    )

/*++

Routine Description:

    This routine is called for auto-detect bindings to
    remove any bindings that were not successfully found.
    It also updates "DefaultAutoDetectType" in the registry
    if needed.

Arguments:

    Device - The IPX device object.

    ValidBindings - The total number of bindings present.

    RegistryPath - The path to the ipx registry, used if we have
        to write a value back.

Return Value:

    The updated number of bindings.

--*/

{
    PBINDING Binding, TmpBinding;
    UINT i, j;

    //
    // Get rid of any auto-detect devices which we
    // could not find nets for. We also remove any
    // devices which are not the first ones
    // auto-detected on a particular adapter.
    //

    for (i = FIRST_REAL_BINDING; i <= ValidBindings; i++) {
        Binding = NIC_ID_TO_BINDING(Device, i);

        if (!Binding) {
            continue;
        }

        //
        // If this was auto-detected and was not the default,
        // or it was the default, but nothing was detected for
        // it *and* something else *was* detected (which means
        // we will use that frame type when we get to it),
        // we may need to remove this binding.
        //
		  // TINGCAI: If users do not set DefaultAutoDetectType in the
		  // registry, the default is 802.2. For 802.3, 
		  

        if (Binding->AutoDetect &&
            (!Binding->DefaultAutoDetect ||
             (Binding->DefaultAutoDetect &&
              (Binding->LocalAddress.NetworkAddress == 0) &&
              Binding->Adapter->AutoDetectResponse))) {

            if ((Binding->LocalAddress.NetworkAddress == 0) ||
                (Binding->Adapter->AutoDetectFoundOnBinding && 
					 Binding->Adapter->AutoDetectFoundOnBinding != Binding)) {

                //
                // Remove this binding.
                //

                if (Binding->LocalAddress.NetworkAddress == 0) {
                    IPX_DEBUG (AUTO_DETECT, ("Binding %d (%d) no net found\n",
                                                i, Binding->FrameType));
                } else {
                    IPX_DEBUG (AUTO_DETECT, ("Binding %d (%d) adapter already auto-detected\n",
                                                i, Binding->FrameType));
                }

                CTEAssert (Binding->NicId == i);
                CTEAssert (!Binding->Adapter->MacInfo.MediumAsync);

                //
                // Remove any routes through this NIC, and
                // adjust any NIC ID's above this one in the
                // database down by one.
                //

                RipAdjustForBindingChange (Binding->NicId, 0, IpxBindingDeleted);

                Binding->Adapter->Bindings[Binding->FrameType] = NULL;
                for (j = i+1; j <= ValidBindings; j++) {
					TmpBinding = NIC_ID_TO_BINDING(Device, j);
					INSERT_BINDING(Device, j-1, TmpBinding);
                    if (TmpBinding) {
                        if ((TmpBinding->Adapter->MacInfo.MediumAsync) &&
                            (TmpBinding->Adapter->FirstWanNicId == TmpBinding->NicId)) {
                            --TmpBinding->Adapter->FirstWanNicId;
                            --TmpBinding->Adapter->LastWanNicId;
                        }
                        --TmpBinding->NicId;
                    }
                }
                INSERT_BINDING(Device, ValidBindings, NULL);
                --Binding->Adapter->BindingCount;
                --ValidBindings;

                --i;   // so we check the binding that was just moved.

                //
                // Wait 100 ms before freeing the binding,
                // in case an indication is using it.
                //

                KeStallExecutionProcessor(100000);

                IpxDestroyBinding (Binding);

            } else {

                IPX_DEBUG (AUTO_DETECT, ("Binding %d (%d) auto-detected OK\n",
                                                i, Binding->FrameType));

#if DBG
                DbgPrint ("IPX: Auto-detected non-default frame type %s, net %lx\n",
                    OutputFrameType(Binding),
                    REORDER_ULONG (Binding->LocalAddress.NetworkAddress));
#endif

                //
                // Save it in the registry for the next boot.
                //
//
// This cannot be done at DPC, so, drop the IRQL
//
				IPX_FREE_LOCK1(&Device->BindAccessLock, *LockHandle1);
				IpxWriteDefaultAutoDetectType(
					RegistryPath,
					Binding->Adapter,
					Binding->FrameType);
				IPX_GET_LOCK1(&Device->BindAccessLock, LockHandle1);

                //
                // Now, we know for sure that NB needs to be told of this.
                // Set to TRUE in IpxBindToAdapter line 1491
 
                if (Binding->Adapter == Adapter) {
                    Binding->IsnInformed[IDENTIFIER_NB] = FALSE;
                    Binding->IsnInformed[IDENTIFIER_SPX] = FALSE;
                }

                Binding->Adapter->AutoDetectFoundOnBinding = Binding;
            }

        } else {

            if (Binding->AutoDetect) {

                IPX_DEBUG (AUTO_DETECT, ("Binding %d (%d) auto-detect default\n",
                                               i, Binding->FrameType));

#if DBG
                if (Binding->LocalAddress.NetworkAddress != 0) {
                    IPX_DEBUG (AUTO_DETECT, ("IPX: Auto-detected default frame type %s, net %lx\n",
                        OutputFrameType(Binding),
                        REORDER_ULONG (Binding->LocalAddress.NetworkAddress)));
                } else {
                    IPX_DEBUG (AUTO_DETECT, ("IPX: Using default auto-detect frame type %s\n",
                        OutputFrameType(Binding)));
                }
#endif

                Binding->Adapter->AutoDetectFoundOnBinding = Binding;

            } else {

                IPX_DEBUG (AUTO_DETECT, ("Binding %d (%d) not auto-detected\n",
                                               i, Binding->FrameType));
            }
            
            //
            // Now, we know for sure that NB needs to be told of this.
            //
            
            if (Binding->Adapter == Adapter) {
                Binding->IsnInformed[IDENTIFIER_NB] = FALSE;
                Binding->IsnInformed[IDENTIFIER_SPX] = FALSE;
            }
        }

    }


    for (i = 1; i <= ValidBindings; i++) {
        if (Binding = NIC_ID_TO_BINDING(Device, i)) {
            CTEAssert (Binding->NicId == i);
            IPX_DEBUG (AUTO_DETECT, ("Binding %lx, type %d, auto %d\n",
                            Binding, Binding->FrameType, Binding->AutoDetect));
        }

    }

    return ValidBindings;

}   /* IpxResolveAutoDetect */


VOID
IpxResolveBindingSets(
    IN PDEVICE Device,
    IN ULONG ValidBindings
    )

/*++

Routine Description:

    This routine is called to determine if we have any
    binding sets and rearrange the bindings the way we
    like. The order is as follows:

    - First comes the first binding to each LAN network
    - Following that are all WAN bindings
    - Following that are any duplicate bindings to LAN networks
        (the others in the "binding set").

    If "global wan net" is true we will advertise up to
    and including the first wan binding as the highest nic
    id; otherwise we advertise up to and including the last
    wan binding. In all cases the duplicate bindings are
    hidden.

Arguments:

    Device - The IPX device object.

    ValidBindings - The total number of bindings present.

Return Value:

    None.

--*/

{
    PBINDING Binding, MasterBinding, TmpBinding;
    UINT i, j;
    ULONG WanCount, DuplicateCount;

    //
    // First loop through and push all the wan bindings
    // to the end.
    //

    WanCount = Device->HighestExternalNicId - Device->HighestLanNicId;

    //
    // Now go through and find the LAN duplicates and
    // create binding sets from them.
    //

    DuplicateCount = 0;

    for (i = FIRST_REAL_BINDING; i <= (ValidBindings-(WanCount+DuplicateCount)); ) {

		Binding = NIC_ID_TO_BINDING(Device, i);
        CTEAssert (Binding != NULL);    // because we are only looking at LAN bindings

        CTEAssert (!Binding->Adapter->MacInfo.MediumAsync);

        if (Binding->LocalAddress.NetworkAddress == 0) {
            i++;
            continue;
        }

        //
        // See if any previous bindings match the
        // frame type, medium type, and number of
        // this network (for the moment we match on
        // frame type and medium type too so that we
        // don't have to worry about different frame
        // formats and header offsets within a set).
        //

        for (j = FIRST_REAL_BINDING; j < i; j++) {
          	MasterBinding = NIC_ID_TO_BINDING(Device, j);
            if ((MasterBinding->LocalAddress.NetworkAddress == Binding->LocalAddress.NetworkAddress) &&
                (MasterBinding->FrameType == Binding->FrameType) &&
                (MasterBinding->Adapter->MacInfo.MediumType == Binding->Adapter->MacInfo.MediumType)) {
                break;
            }

        }

        if (j == i) {
            i++;
            continue;
        }

        //
        // We have a duplicate. First slide it down to the
        // end. Note that we change any router entries that
        // use our real NicId to use the real NicId of the
        // master (there should be no entries in the rip
        // database that have the NicId of a binding slave).
        //

        RipAdjustForBindingChange (Binding->NicId, MasterBinding->NicId, IpxBindingMoved);

        for (j = i+1; j <= ValidBindings; j++) {
			TmpBinding = NIC_ID_TO_BINDING(Device, j);
            INSERT_BINDING(Device, j-1, TmpBinding);
            if (TmpBinding) {
                if ((TmpBinding->Adapter->MacInfo.MediumAsync) &&
                    (TmpBinding->Adapter->FirstWanNicId == TmpBinding->NicId)) {
                    --TmpBinding->Adapter->FirstWanNicId;
                    --TmpBinding->Adapter->LastWanNicId;
                }
                --TmpBinding->NicId;
            }
        }
        INSERT_BINDING(Device, ValidBindings, Binding);

        Binding->NicId = (USHORT)ValidBindings;
        ++DuplicateCount;

	if (Binding->TdiRegistrationHandle != NULL) {
	   NTSTATUS    ntStatus;
	   ntStatus = TdiDeregisterNetAddress(Binding->TdiRegistrationHandle);
           if (ntStatus != STATUS_SUCCESS) {
              IPX_DEBUG(PNP, ("TdiDeRegisterNetAddress failed: %lx", ntStatus));
           } else {
	      Binding->TdiRegistrationHandle = NULL; 
	   }
	}

        //
        // Now make MasterBinding the head of a binding set.
        //

        if (MasterBinding->BindingSetMember) {

            //
            // Just insert ourselves in the chain.
            //

#if DBG
            DbgPrint ("IPX: %lx is also on network %lx\n",
                Binding->Adapter->AdapterName,
                REORDER_ULONG (Binding->LocalAddress.NetworkAddress));
#endif
            IPX_DEBUG (AUTO_DETECT, ("Add %lx to binding set of %lx\n", Binding, MasterBinding));

            CTEAssert (MasterBinding->CurrentSendBinding);
            Binding->NextBinding = MasterBinding->NextBinding;

        } else {

            //
            // Start the chain with the two bindings in it.
            //

#if DBG
            DbgPrint ("IPX: %lx and %lx are on the same network %lx, will load balance\n",
                MasterBinding->Adapter->AdapterName, Binding->Adapter->AdapterName,
                REORDER_ULONG (Binding->LocalAddress.NetworkAddress));
#endif
            IPX_DEBUG (AUTO_DETECT, ("Create new %lx in binding set of %lx\n", Binding, MasterBinding));

            MasterBinding->BindingSetMember = TRUE;
            MasterBinding->CurrentSendBinding = MasterBinding;
            MasterBinding->MasterBinding = MasterBinding;
            Binding->NextBinding = MasterBinding;

        }

        MasterBinding->NextBinding = Binding;
        Binding->BindingSetMember = TRUE;
        Binding->ReceiveBroadcast = FALSE;
        Binding->CurrentSendBinding = NULL;
        Binding->MasterBinding = MasterBinding;

        //
        // Since the master binding looks like all members of
        // the binding set to people querying from above, we have
        // to make it the worst-case of all the elements. Generally
        // these will be equal since the frame type and media is
        // the same.
        //

        if (Binding->MaxLookaheadData > MasterBinding->MaxLookaheadData) {
            MasterBinding->MaxLookaheadData = Binding->MaxLookaheadData;
        }
        if (Binding->AnnouncedMaxDatagramSize < MasterBinding->AnnouncedMaxDatagramSize) {
            MasterBinding->AnnouncedMaxDatagramSize = Binding->AnnouncedMaxDatagramSize;
        }
        if (Binding->RealMaxDatagramSize < MasterBinding->RealMaxDatagramSize) {
            MasterBinding->RealMaxDatagramSize = Binding->RealMaxDatagramSize;
        }
        if (Binding->MediumSpeed < MasterBinding->MediumSpeed) {
            MasterBinding->MediumSpeed = Binding->MediumSpeed;
        }

        //
        // Keep i the same, to check the new binding at
        // this position.
        //

    }
	Device->HighestLanNicId -= (USHORT)DuplicateCount;

	if (Device->HighestLanNicId == 0) {
        CTEAssert(FALSE);
	}

	Device->HighestExternalNicId -= (USHORT)DuplicateCount;
	Device->HighestType20NicId -= (USHORT)DuplicateCount;
	Device->SapNicCount -= (USHORT)DuplicateCount;
}   /* IpxResolveBindingSets */


NTSTATUS
IpxBindToAdapter(
    IN PDEVICE Device,
    IN PBINDING_CONFIG ConfigBinding,
	IN PADAPTER	*AdapterPtr,
    IN ULONG FrameTypeIndex
    )

/*++

Routine Description:

    This routine handles binding the transport to a new
    adapter. It can be called at any point during the life
    of the transport.

Arguments:

    Device - The IPX device object.

    ConfigBinding - The configuration info for this binding.

	AdapterPtr - pointer to the adapter to bind to in case of PnP.

	FrameTypeIndex - The index into ConfigBinding's array of frame
        types for this adapter. The routine is called once for
        every valid frame type.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status;

	PADAPTER Adapter = *AdapterPtr;

    PBINDING Binding, OldBinding;
    ULONG FrameType, MappedFrameType;
    PLIST_ENTRY p;

    //
    // We can't bind more than one adapter unless we have a
    // virtual network configured or we are allowed to run
    // with a virtual network of 0.
    //

    if (Device->BindingCount == 1) {
        if ((Device->VirtualNetworkNumber == 0) &&
            (!Device->VirtualNetworkOptional)) {

            IPX_DEBUG (ADAPTER, ("Cannot bind to more than one adapter\n"));
            DbgPrint ("IPX: Disallowing multiple bind ==> VirtualNetwork is 0\n");
            IpxWriteGeneralErrorLog(
                Device->DeviceObject,
                EVENT_TRANSPORT_BINDING_FAILED,
                666,
                STATUS_NOT_SUPPORTED,
                ConfigBinding->AdapterName.Buffer,
                0,
                NULL);

            return STATUS_NOT_SUPPORTED;
        }
    }


    //
    // First allocate the memory for the binding.
    //

    status = IpxCreateBinding(
                 Device,
                 ConfigBinding,
                 FrameTypeIndex,
                 ConfigBinding->AdapterName.Buffer,
                 &Binding);

    if (status != STATUS_SUCCESS) {
       IpxWriteGeneralErrorLog(
	  (PVOID)IpxDevice->DeviceObject,
	  EVENT_TRANSPORT_RESOURCE_POOL,
	  812,
	  status,
	  L"IpxBindToAdapter: failed to create binding",
	  0,
	  NULL);
       DbgPrint("IPX: IpxCreateBinding failed with status %x\n.",status);  
       return status;
    }

    FrameType = ConfigBinding->FrameType[FrameTypeIndex];

//
// In PnP case, we dont need to check for existing adapters since
// we supply a NULL adapter in the parameters if it needs to be created
//

    if (Adapter == NULL) {

        //
        // No binding to this adapter exists, so create a
        // new one.
        //

        status = IpxCreateAdapter(
                     Device,
                     &ConfigBinding->AdapterName,
                     &Adapter);

        if (status != STATUS_SUCCESS) {
            IpxDestroyBinding(Binding);
            return status;
        }

        //
        // Save these now (they will be the same for all bindings
        // on this adapter).
        //

        Adapter->ConfigMaxPacketSize = ConfigBinding->Parameters[BINDING_MAX_PKT_SIZE];
        Adapter->SourceRouting = (BOOLEAN)ConfigBinding->Parameters[BINDING_SOURCE_ROUTE];
        Adapter->EnableFunctionalAddress = (BOOLEAN)ConfigBinding->Parameters[BINDING_ENABLE_FUNC_ADDR];
        Adapter->EnableWanRouter = (BOOLEAN)ConfigBinding->Parameters[BINDING_ENABLE_WAN];

        Adapter->BindSap = (USHORT)ConfigBinding->Parameters[BINDING_BIND_SAP];
        Adapter->BindSapNetworkOrder = REORDER_USHORT(Adapter->BindSap);
        CTEAssert (Adapter->BindSap == 0x8137);
        CTEAssert (Adapter->BindSapNetworkOrder == 0x3781);

        //
        // Now fire up NDIS so this adapter talks
        //

        status = IpxInitializeNdis(
                    Adapter,
                    ConfigBinding);

        if (!NT_SUCCESS (status)) {

            //
            // Log an error.
            //

            IpxWriteGeneralErrorLog(
                Device->DeviceObject,
                EVENT_TRANSPORT_BINDING_FAILED,
                601,
                status,
                ConfigBinding->AdapterName.Buffer,
                0,
                NULL);


	    IpxDereferenceAdapter1(Adapter,ADAP_REF_CREATE); 
	    IpxDestroyAdapter (Adapter);
	    IpxDestroyBinding (Binding);

            //
            // Returning this status informs the caller to not
            // try any more frame types on this adapter.
            //

            return STATUS_DEVICE_DOES_NOT_EXIST;

        }

        //
        // For 802.5 bindings we need to start the source routing
        // timer to time out old entries.
        //

        if ((Adapter->MacInfo.MediumType == NdisMedium802_5) &&
            (Adapter->SourceRouting)) {

            if (!Device->SourceRoutingUsed) {

                Device->SourceRoutingUsed = TRUE;
                IpxReferenceDevice (Device, DREF_SR_TIMER);

                CTEStartTimer(
                    &Device->SourceRoutingTimer,
                    60000,                     // one minute timeout
                    MacSourceRoutingTimeout,
                    (PVOID)Device);
            }
        }

        MacMapFrameType(
            Adapter->MacInfo.RealMediumType,
            FrameType,
            &MappedFrameType);

        IPX_DEBUG (ADAPTER, ("Create new bind to adapter %ws, type %d\n",
                              ConfigBinding->AdapterName.Buffer,
                              MappedFrameType));

        IpxAllocateReceiveBufferPool (Adapter);

		*AdapterPtr = Adapter;
    }
	else {
		//
		// get the mapped frame type
		//
        MacMapFrameType(
            Adapter->MacInfo.RealMediumType,
            FrameType,
            &MappedFrameType);

        if (Adapter->Bindings[MappedFrameType] != NULL) {

            IPX_DEBUG (ADAPTER, ("Bind to adapter %ws, type %d exists\n",
                                  Adapter->AdapterName,
                                  MappedFrameType));

            //
            // If this was the auto-detect default for this
            // adapter and it failed, we need to make the
            // previous one the default, so that at least
            // one binding will stick around.
            //

            if (ConfigBinding->DefaultAutoDetect[FrameTypeIndex]) {
                IPX_DEBUG (ADAPTER, ("Default auto-detect changed from %d to %d\n",
                                          FrameType, MappedFrameType));
                Adapter->Bindings[MappedFrameType]->DefaultAutoDetect = TRUE;
            }

            IpxDestroyBinding (Binding);

            return STATUS_NOT_SUPPORTED;
        }

        IPX_DEBUG (ADAPTER, ("Using existing bind to adapter %ws, type %d\n",
                              Adapter->AdapterName,
                              MappedFrameType));
	}

    //
    // The local node address starts out the same as the
    // MAC address of the adapter (on WAN this will change).
    // The local MAC address can also change for WAN.
    //

    RtlCopyMemory (Binding->LocalAddress.NodeAddress, Adapter->LocalMacAddress.Address, 6);
    RtlCopyMemory (Binding->LocalMacAddress.Address, Adapter->LocalMacAddress.Address, 6);


    //
    // Save the send handler.
    //

    Binding->SendFrameHandler = NULL;
    Binding->FrameType = MappedFrameType;

    //
    // Put this in InitializeBindingInfo.
    //

    switch (Adapter->MacInfo.RealMediumType) {
    case NdisMedium802_3:
        switch (MappedFrameType) {
        case ISN_FRAME_TYPE_802_3: Binding->SendFrameHandler = IpxSendFrame802_3802_3; break;
        case ISN_FRAME_TYPE_802_2: Binding->SendFrameHandler = IpxSendFrame802_3802_2; break;
        case ISN_FRAME_TYPE_ETHERNET_II: Binding->SendFrameHandler = IpxSendFrame802_3EthernetII; break;
        case ISN_FRAME_TYPE_SNAP: Binding->SendFrameHandler = IpxSendFrame802_3Snap; break;
        }
        break;
    case NdisMedium802_5:
        switch (MappedFrameType) {
        case ISN_FRAME_TYPE_802_2: Binding->SendFrameHandler = IpxSendFrame802_5802_2; break;
        case ISN_FRAME_TYPE_SNAP: Binding->SendFrameHandler = IpxSendFrame802_5Snap; break;
        }
        break;
    case NdisMediumFddi:
        switch (MappedFrameType) {
        case ISN_FRAME_TYPE_802_3: Binding->SendFrameHandler = IpxSendFrameFddi802_3; break;
        case ISN_FRAME_TYPE_802_2: Binding->SendFrameHandler = IpxSendFrameFddi802_2; break;
        case ISN_FRAME_TYPE_SNAP: Binding->SendFrameHandler = IpxSendFrameFddiSnap; break;
        }
        break;
    case NdisMediumArcnet878_2:
        switch (MappedFrameType) {
        case ISN_FRAME_TYPE_802_3: Binding->SendFrameHandler = IpxSendFrameArcnet878_2; break;
        }
        break;
    case NdisMediumWan:
        switch (MappedFrameType) {
        case ISN_FRAME_TYPE_ETHERNET_II: Binding->SendFrameHandler = IpxSendFrameWanEthernetII; break;
        }
        break;
    }

    if (Binding->SendFrameHandler == NULL) {
        DbgPrint ("SendFrameHandler is NULL\n");
    }

    Adapter->Bindings[MappedFrameType] = Binding;
    ++Adapter->BindingCount;

    Binding->Adapter = Adapter;


    //
    // NicId and ExternalNicId will be filled in later when the binding
    // is assigned a spot in the Device->Bindings array.
    //

    //
    // Initialize the per-binding MAC information
    //

    if ((Adapter->ConfigMaxPacketSize == 0) ||
        (Adapter->MaxSendPacketSize < Adapter->ConfigMaxPacketSize)) {
        Binding->MaxSendPacketSize = Adapter->MaxSendPacketSize;
    } else {
        Binding->MaxSendPacketSize = Adapter->ConfigMaxPacketSize;
    }
    Binding->MediumSpeed = Adapter->MediumSpeed;
    if (Adapter->MacInfo.MediumAsync) {
        Binding->LineUp = FALSE;
    } else {
        //
        // Lets do this until we know for sure that we are done with autodetect.
        // [ShreeM]
        //
        // Only for LAN as we don't do auto detect for WAN lines. 276128
        Binding->IsnInformed[IDENTIFIER_NB] = TRUE;
        Binding->IsnInformed[IDENTIFIER_SPX] = TRUE;
        Binding->LineUp = TRUE;
    }

    MacInitializeBindingInfo(
        Binding,
        Adapter);

    return STATUS_SUCCESS;

}   /* IpxBindToAdapter */


BOOLEAN
IpxIsAddressLocal(
    IN TDI_ADDRESS_IPX UNALIGNED * SourceAddress
    )

/*++

Routine Description:

    This routine returns TRUE if the specified SourceAddress indicates
    the packet was sent by us, and FALSE otherwise.

Arguments:

    SourceAddress - The source IPX address.

Return Value:

    TRUE if the address is local.

--*/

{
    PBINDING Binding;
    UINT i;

    PDEVICE Device = IpxDevice; 

    CTELockHandle LockHandle;
    
    CTEGetLock (&Device->Lock, &LockHandle);
    //
    // First see if it is a virtual network address or not.
    //

    if (RtlEqualMemory (VirtualNode, SourceAddress->NodeAddress, 6)) {

        //
        // This is us if we have a virtual network configured.
        // If we don't have a virtual node, we fall through to the
        // other check -- an arcnet card configured as node 1 will
        // have what we think of as the "virtual node" as its
        // real node address.
        //

        if ((IpxDevice->VirtualNetwork) &&
            (IpxDevice->VirtualNetworkNumber == SourceAddress->NetworkAddress)) {
	    CTEFreeLock (&Device->Lock, LockHandle);
            return TRUE;
        }

    }

    //
    // Check through our list of adapters to see if one of
    // them is the source node.
    //
    {
    ULONG   Index = MIN (IpxDevice->MaxBindings, IpxDevice->ValidBindings);

    for (i = FIRST_REAL_BINDING; i <= Index; i++) {
        if (((Binding = NIC_ID_TO_BINDING(IpxDevice, i)) != NULL) &&
            (RtlEqualMemory (Binding->LocalAddress.NodeAddress, SourceAddress->NodeAddress, 6))) {
	    CTEFreeLock (&Device->Lock, LockHandle);
	    return TRUE;
        }
    }
    }

    CTEFreeLock (&Device->Lock, LockHandle);
    
    return FALSE;

}   /* IpxIsAddressLocal */


NTSTATUS
IpxUnBindFromAdapter(
    IN PBINDING Binding
    )

/*++

Routine Description:

    This routine handles unbinding the transport from an
    adapter. It can be called at any point during the life
    of the transport.

Arguments:

    Binding - The adapter to unbind.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    PADAPTER Adapter = Binding->Adapter;

    
    IpxDereferenceBinding (Binding, BREF_BOUND);

    if (NIC_ID_TO_BINDING(IpxDevice, LOOPBACK_NIC_ID) != Binding) {
       
       Adapter->Bindings[Binding->FrameType] = NULL;
       --Adapter->BindingCount;
    
    } else {

       IPX_DEBUG(PNP, ("Loopback Binding : dont decrement adapter's bindingcount, just return\n"));
       return STATUS_SUCCESS;

    }

    if (Adapter->BindingCount == 0) {

        //
        // DereferenceAdapter is a NULL macro for load-only.
        //
#ifdef _PNP_LATER
        //
        // Take away the creation reference. When the in-use ref is taken off,
        // we destroy this adapter.
        //
        IpxDereferenceAdapter(Adapter);
#else
        IpxDestroyAdapter (Adapter);

#endif
    }

    return STATUS_SUCCESS;

}   /* IpxUnBindFromAdapter */

VOID
IpxNdisUnload() {
   
   PBINDING Loopback=NULL;
   NTSTATUS ntStatus = STATUS_SUCCESS;
   NDIS_STATUS ndisStatus;
   IPX_PNP_INFO IpxPnPInfo;
   PREQUEST Request;
   PLIST_ENTRY p;
   KIRQL irql;

   NDIS_HANDLE LocalNdisProtocolHandle; 

   IPX_DEBUG(PNP, ("IpxNdisUnload is being called\n")); 

   IpxDevice->State = DEVICE_STATE_STOPPING;

   
   LocalNdisProtocolHandle = InterlockedExchangePointer(&IpxNdisProtocolHandle, NULL); 
 
   if (LocalNdisProtocolHandle != (NDIS_HANDLE)NULL) {
       NdisDeregisterProtocol (&ndisStatus, LocalNdisProtocolHandle);
       ASSERT(ndisStatus == NDIS_STATUS_SUCCESS);  
   }
   
   //
   // Complete any pending address notify requests.
   //

   while ((p = ExInterlockedRemoveHeadList(
					   &IpxDevice->AddressNotifyQueue,
					   &IpxDevice->Lock)) != NULL) {

      Request = LIST_ENTRY_TO_REQUEST(p);	
      REQUEST_STATUS(Request) = STATUS_DEVICE_NOT_READY;
      
      // AcquireCancelSpinLock to force the cancel routine to release the lock if it was
      // fired after we remove it from the queue
      IoAcquireCancelSpinLock( &irql );
      IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
      IoReleaseCancelSpinLock( irql );
      IpxCompleteRequest (Request);
      IpxFreeRequest (IpxDevice, Request);
      
      IpxDereferenceDevice (IpxDevice, DREF_ADDRESS_NOTIFY);
   }


   Loopback = NIC_ID_TO_BINDING(IpxDevice, LOOPBACK_NIC_ID);

   if (Loopback != NULL) {

      if (Loopback->TdiRegistrationHandle) {
      
	 if ((ntStatus = TdiDeregisterNetAddress(Loopback->TdiRegistrationHandle)) != STATUS_SUCCESS) {
            DbgPrint("IPX: IpxNdisUnload: TdiDeRegisterNetAddress failed: %lx\n", ntStatus);
	 } else {
	    IPX_DEBUG(PNP, ("TdiDeRegisterNetAddress Loopback Address: %lx\n", Loopback->LocalAddress.NetworkAddress));
	    Loopback->TdiRegistrationHandle = NULL; 
	 }	
      }	
   }

   //
   // Inform TDI clients about the close of our device object.
   //

   // If TdiRegisterDeviceObject failed, the handle would be null. 
   if (IpxDevice->TdiRegistrationHandle != NULL) {
      if (IpxDevice->TdiRegistrationHandle == (PVOID) TDI_DEREGISTERED_COOKIE) {
	 DbgPrint("IPX: IpxNdisUnload: NDIS is calling us AGAIN (%p) !!!!\n, IpxDevice->TdiRegistrationHandle");  
	 DbgBreakPoint(); 
      } else {
	 ntStatus = TdiDeregisterDeviceObject(IpxDevice->TdiRegistrationHandle); 
	 if (ntStatus != STATUS_SUCCESS) {
	    DbgPrint("IPX: TdiDeRegisterDeviceObject failed: %lx\n", ntStatus);
	 } else {
	    IpxDevice->TdiRegistrationHandle = (HANDLE) TDI_DEREGISTERED_COOKIE; 
	 }
      }
   }
   

   IpxPnPInfo.LineInfo.LinkSpeed = IpxDevice->LinkSpeed;
   IpxPnPInfo.LineInfo.MaximumPacketSize =
      IpxDevice->Information.MaximumLookaheadData + sizeof(IPX_HEADER);
   IpxPnPInfo.LineInfo.MaximumSendSize =
      IpxDevice->Information.MaxDatagramSize + sizeof(IPX_HEADER);
   IpxPnPInfo.LineInfo.MacOptions = IpxDevice->MacOptions;
   
   IpxPnPInfo.FirstORLastDevice = TRUE;
   
   if (Loopback != NULL) {
      if (IpxDevice->UpperDriverBound[IDENTIFIER_SPX] && (*IpxDevice->UpperDrivers[IDENTIFIER_SPX].PnPHandler)) {
	 if (Loopback->IsnInformed[IDENTIFIER_SPX]) {

      
	    (*IpxDevice->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
								   IPX_PNP_DELETE_DEVICE,
								   &IpxPnPInfo);

	    Loopback->IsnInformed[IDENTIFIER_SPX] = FALSE; 
	 }
      }        
       
      if (IpxDevice->UpperDriverBound[IDENTIFIER_NB] && (*IpxDevice->UpperDrivers[IDENTIFIER_NB].PnPHandler)) {
	 if (Loopback->IsnInformed[IDENTIFIER_NB]) {

	    (*IpxDevice->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
								  IPX_PNP_DELETE_DEVICE,
								  &IpxPnPInfo);

	    Loopback->IsnInformed[IDENTIFIER_NB] = FALSE; 
	    IPX_DEBUG(PNP,("Indicate to NB IPX_PNP_DELETE_DEVICE with FirstORLastDevice = (%d)",IpxPnPInfo.FirstORLastDevice));  
	 }
      }
   }
}


VOID
IpxUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine unloads the sample transport driver.
    It unbinds from any NDIS drivers that are open and frees all resources
    associated with the transport. The I/O system will not call us until
    nobody above has IPX open.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None. When the function returns, the driver is unloaded.

--*/

{

    PBINDING Binding, Loopback=NULL;
 
    UINT i;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    LARGE_INTEGER   Delay;

    CTELockHandle LockHandle;

    UNREFERENCED_PARAMETER (DriverObject);
    
    //
    // Cancel the source routing timer if used.
    //
    if (IpxDevice->SourceRoutingUsed) {

        IpxDevice->SourceRoutingUsed = FALSE;
        if (CTEStopTimer (&IpxDevice->SourceRoutingTimer)) {
            IpxDereferenceDevice (IpxDevice, DREF_SR_TIMER);
        }
    }

    //
    // Cancel the RIP long timer, and if we do that then
    // send a RIP DOWN message if needed.
    //
    if (CTEStopTimer (&IpxDevice->RipLongTimer)) {

        if (IpxDevice->RipResponder) {

            if (RipQueueRequest (IpxDevice->VirtualNetworkNumber, RIP_DOWN) == STATUS_PENDING) {

                //
                // If we queue a request, it will stop the timer.
                //

                KeWaitForSingleObject(
                    &IpxDevice->UnloadEvent,
                    Executive,
                    KernelMode,
                    TRUE,
                    (PLARGE_INTEGER)NULL
                    );
            }
        }

        IpxDereferenceDevice (IpxDevice, DREF_LONG_TIMER);

    } else {

        //
        // We couldn't stop the timer, which means it is running,
        // so we need to wait for the event that is kicked when
        // the RIP DOWN messages are done.
        //

        if (IpxDevice->RipResponder) {
	    
	   KeWaitForSingleObject(
                &IpxDevice->UnloadEvent,
                Executive,
                KernelMode,
                TRUE,
                (PLARGE_INTEGER)NULL
                );
        }
    }

    IPX_DEBUG(PNP, ("Going back to loaded state\n"));

    // Free loopback binding and adapter
    IpxDereferenceAdapter1(NIC_ID_TO_BINDING(IpxDevice, LOOPBACK_NIC_ID)->Adapter,ADAP_REF_CREATE);
    IpxDestroyAdapter(NIC_ID_TO_BINDING(IpxDevice, LOOPBACK_NIC_ID)->Adapter);
    IpxDestroyBinding(NIC_ID_TO_BINDING(IpxDevice, LOOPBACK_NIC_ID));

    //
    // Walk the list of device contexts.
    //
    for (i = FIRST_REAL_BINDING; i <= IpxDevice->ValidBindings; i++) {
        if ((Binding = NIC_ID_TO_BINDING(IpxDevice, i)) != NULL) {

	   // This function will skip NdisCloseAdapter if it has already done so.
	   IpxCloseNdis(Binding->Adapter);

	   INSERT_BINDING(IpxDevice, i, NULL);

	   // Deref the binding and free its adapter if the binding count goes to 0.
	   IpxUnBindFromAdapter (Binding);

        }
    }

    //
    // Backup the pointer to free the demand dial location.
    //
    IpxDevice->Bindings -= EXTRA_BINDINGS;

    IpxFreeMemory ( IpxDevice->Bindings,
                    IpxDevice->MaxBindings * sizeof(BIND_ARRAY_ELEM),
                    MEMORY_BINDING,
                    "Binding array");

    //
    // Deallocate the TdiRegistrationAddress and RegistryPathBuffer.
    //
    IpxFreeMemory ( IpxDevice->TdiRegistrationAddress,
                    (2 * sizeof(USHORT) + sizeof(TDI_ADDRESS_IPX)),
                    MEMORY_ADDRESS,
                    "Tdi Address");

    IpxFreeMemory ( IpxDevice->RegistryPathBuffer,
                    IpxDevice->RegistryPath.Length + sizeof(WCHAR),
                    MEMORY_CONFIG,
                    "RegistryPathBuffer");


    KeResetEvent(&IpxDevice->UnloadEvent);

    CTEGetLock (&IpxDevice->Lock, &LockHandle);
    IpxDevice->UnloadWaiting = TRUE;
    CTEFreeLock (&IpxDevice->Lock, LockHandle);

    //
    // Remove the reference for us being loaded.
    //
    IpxDereferenceDevice (IpxDevice, DREF_CREATE);

    //
    // Wait for our count to drop to zero.
    //
    // If KeWaitForSingleObject returns STATUS_ALERTED, we should keep waiting. [TC]
    //
    while (KeWaitForSingleObject(
				 &IpxDevice->UnloadEvent,
				 Executive,
				 KernelMode,
				 TRUE,
				 (PLARGE_INTEGER)NULL
				 ) 
	   == STATUS_ALERTED) {
       IPX_DEBUG(DEVICE, ("KeWaitForSingleObject returned STATUS_ALERTED")); 
    };


    // Let the thread that set the UnloadEvent exit. 269061
    Delay.QuadPart = -10*1000;  // One second.

    KeDelayExecutionThread(
        KernelMode,
        FALSE,
        &Delay);

    //
    // Now free the padding buffer.
    //
    IpxFreePaddingBuffer (IpxDevice);

    //
    // Now do the cleanup that has to happen at IRQL 0.
    //
    ExDeleteResourceLite (&IpxDevice->AddressResource);
    IoDeleteDevice (IpxDevice->DeviceObject);

    //
    // Finally, remove ourselves as an NDIS protocol.
    //
    IpxDeregisterProtocol();

}   /* IpxUnload */

NTSTATUS
IpxDispatchPnP(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PREQUEST         Request
    )
{
    PIO_STACK_LOCATION  pIrpSp;
    PDEVICE_RELATIONS   pDeviceRelations = NULL;
    PVOID               pnpDeviceContext = NULL;
    NTSTATUS 		Status = STATUS_INVALID_DEVICE_REQUEST;
    PADDRESS_FILE	AddressFile; 
    PDEVICE		Device = IpxDevice; 

    pIrpSp = IoGetCurrentIrpStackLocation(Request);

    //
    // Allocate a request to track this IRP.
    //

    switch(pIrpSp->MinorFunction) {  
       
       case IRP_MN_QUERY_DEVICE_RELATIONS:                                        
       if (pIrpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation) {
/*
	 354517 nwrdr passes neither a connection nor an address file object.
	 If nwrdr gives an address object, 
	 IPX should look up which nic this address is bound to and 
	 gives the PDO of that NIC.  
*/
/*
	    if (PtrToUlong(pIrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE) {
	       DbgPrint("IPX: Received IRP_MJ_PNP, Connectoin File\n");
	       Status = STATUS_INVALID_HANDLE; 
	       break;  
	    } else if ( PtrToUlong(pIrpSp->FileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE) {
	       DbgPrint("IPX: Received IRP_MJ_PNP, Address File\n"); 
	       AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);
	    } else {
	       Status = STATUS_INVALID_HANDLE; 
	       break; 
	    }

	    //
	    // This creates a reference to AddressFile->Address
	    // which is removed by IpxCloseAddressFile.
	    //

	    Status = IpxVerifyAddressFile(AddressFile);


	    if (!NT_SUCCESS (Status)) {
               DbgPrint("IPX: Received IRP_MJ_PNP, Invalid Address File\n"); 
	       Status = STATUS_INVALID_HANDLE;
	    } else {
*/	       
	       PBINDING Binding = NIC_ID_TO_BINDING(Device, FIRST_REAL_BINDING); 

	       if (Binding == NULL) {
		  Status = STATUS_INVALID_HANDLE; 
	       } else {
		  pnpDeviceContext = Binding->Adapter->PNPContext;
		  pDeviceRelations = (PDEVICE_RELATIONS) IpxAllocateMemory (sizeof (DEVICE_RELATIONS),
									 MEMORY_ADAPTER,
									 "Query Device Relation"); 
									 
		  if (pDeviceRelations != NULL) {

		     ObReferenceObject (pnpDeviceContext);
		     
		     //
		     // TargetDeviceRelation allows exactly one PDO. fill it up.
		     //
		     pDeviceRelations->Count  =   1;
		     pDeviceRelations->Objects[0] = pnpDeviceContext;

		     //
		     // invoker of this irp will free the information buffer.
		     //

		     REQUEST_INFORMATION(Request) = (ULONG_PTR) pDeviceRelations;

		     Status = STATUS_SUCCESS;

		  } else {
		     Status = STATUS_INSUFFICIENT_RESOURCES;
		  } 
/*
	       }
 	       IpxDereferenceAddressFile (AddressFile, AFREF_VERIFY); 
*/
	       } 
       }
       break; 

    default:
       break; 
    }

    return Status; 
}


NTSTATUS
IpxDispatchOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the IPX device driver.
    It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    CTELockHandle LockHandle;
    PDEVICE Device = IpxDevice;
    NTSTATUS Status;
    PFILE_FULL_EA_INFORMATION openType;
    BOOLEAN found;
    PADDRESS_FILE AddressFile;
    PREQUEST Request;
    UINT i;
#ifdef SUNDOWN
    ULONG_PTR Type;
#else
    ULONG Type;
#endif



    ASSERT( DeviceObject->DeviceExtension == IpxDevice );

    
    // We should allow clients such as NB to CLOSE and CLEANUP even when we are stopping. 
    // Only disable CREATE when stopping. [TC]

    if (Device->State == DEVICE_STATE_CLOSED) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }

    #ifdef DBG
    if (Device->State == DEVICE_STATE_STOPPING) {
       IPX_DEBUG(DEVICE, ("Got IRP in STOPPING state. IRP(%p)", Irp)); 
    }
    #endif
    //
    // Allocate a request to track this IRP.
    //

    Request = IpxAllocateRequest (Device, Irp);
    IF_NOT_ALLOCATED(Request) {
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Make sure status information is consistent every time.
    //

    MARK_REQUEST_PENDING(Request);
    REQUEST_STATUS(Request) = STATUS_PENDING;
    REQUEST_INFORMATION(Request) = 0;

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //


    switch (REQUEST_MAJOR_FUNCTION(Request)) {


    case IRP_MJ_PNP:

       Status = IpxDispatchPnP(DeviceObject, Request);                                    
       break;                                                                 

    //
    // The Create function opens a transport object (either address or
    // connection).  Access checking is performed on the specified
    // address to ensure security of transport-layer addresses.
    //

    case IRP_MJ_CREATE:

       // We should reject CREATE when we are stopping

       if (Device->State == DEVICE_STATE_STOPPING) {
	  Status = STATUS_INVALID_DEVICE_STATE;
	  break; 
       }

        openType = OPEN_REQUEST_EA_INFORMATION(Request);

        if (openType != NULL) {

            found = FALSE;

	    if (strncmp(openType->EaName, TdiTransportAddress,
                            openType->EaNameLength) == 0)
            {
               found = TRUE;
            }

            if (found) {
                Status = IpxOpenAddress (Device, Request);
                break;
            }

            //
            // Router
            //
            if (strncmp(openType->EaName, ROUTER_INTERFACE,
                            openType->EaNameLength) == 0)
            {
               found = TRUE;
            }

            if (found) {
                Status = OpenRtAddress (Device, Request);
                break;
            }
            //
            // Connection?
            //

	    if (strncmp(openType->EaName, TdiConnectionContext,
                            openType->EaNameLength) == 0)
            {
               found = TRUE;
            }

            if (found) {
                Status = STATUS_NOT_SUPPORTED;
                break;
            }
            else
            {
               Status = STATUS_NONEXISTENT_EA_ENTRY;

            }

        } else {

            CTEGetLock (&Device->Lock, &LockHandle);

            //
            // LowPart is in the OPEN_CONTEXT directly.
            // HighPart goes into the upper 2 bytes of the OPEN_TYPE.
            //
#ifdef _WIN64             
	    REQUEST_OPEN_CONTEXT(Request) = (PVOID)(Device->ControlChannelIdentifier.QuadPart);
	    (ULONG_PTR)(REQUEST_OPEN_TYPE(Request)) = IPX_FILE_TYPE_CONTROL;
#else
	    REQUEST_OPEN_CONTEXT(Request) = (PVOID)(Device->ControlChannelIdentifier.LowPart);
            (ULONG)(REQUEST_OPEN_TYPE(Request)) = (Device->ControlChannelIdentifier.HighPart << 16);
            (ULONG)(REQUEST_OPEN_TYPE(Request)) |= IPX_FILE_TYPE_CONTROL;
#endif

            ++(Device->ControlChannelIdentifier.QuadPart);

            if (Device->ControlChannelIdentifier.QuadPart > MAX_CCID) {
                Device->ControlChannelIdentifier.QuadPart = 1;
            }

            CTEFreeLock (&Device->Lock, LockHandle);

            Status = STATUS_SUCCESS;
        }

        break;

    case IRP_MJ_CLOSE:

        //
        // The Close function closes a transport endpoint, terminates
        // all outstanding transport activity on the endpoint, and unbinds
        // the endpoint from its transport address, if any.  If this
        // is the last transport endpoint bound to the address, then
        // the address is removed from the provider.
        //
#ifdef _WIN64
        switch (Type = ((ULONG_PTR)(REQUEST_OPEN_TYPE(Request)))) {
#else
        switch (Type = ((ULONG)(REQUEST_OPEN_TYPE(Request)) & IPX_CC_MASK)) {
#endif
        default:
             if ((Type >= ROUTER_ADDRESS_FILE) &&
                    (Type <= (ROUTER_ADDRESS_FILE + IPX_RT_MAX_ADDRESSES)))
             {
                CloseRtAddress(Device, Request);
             }
             else
             {
                 Status = STATUS_INVALID_HANDLE;
                 break;
             }

             // fall through
        case TDI_TRANSPORT_ADDRESS_FILE:

            AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);

            //
            // This creates a reference to AddressFile->Address
            // which is removed by IpxCloseAddressFile.
            //

            Status = IpxVerifyAddressFile(AddressFile);

            if (!NT_SUCCESS (Status)) {
                Status = STATUS_INVALID_HANDLE;
            } else {
                Status = IpxCloseAddressFile (Device, Request);
                IpxDereferenceAddressFile (AddressFile, AFREF_VERIFY);

            }

            break;

        case IPX_FILE_TYPE_CONTROL:
            {
                LARGE_INTEGER   ControlChannelId;

                CCID_FROM_REQUEST(ControlChannelId, Request);

                //
                // See if it is one of the upper driver's control channels.
                //

                Status = STATUS_SUCCESS;

                IPX_DEBUG (DEVICE, ("CCID: (%d, %d)\n", ControlChannelId.HighPart, ControlChannelId.LowPart));

		/*
		
		// Move to IRP_MJ_CLEANUP 360966
                for (i = 0; i < UPPER_DRIVER_COUNT; i++) {
                    if (Device->UpperDriverControlChannel[i].QuadPart ==
                            ControlChannelId.QuadPart) {
                        Status = IpxInternalUnbind (Device, i);
                        break;
                    }
                }
		*/

                break;
            }
        }

        break;

    case IRP_MJ_CLEANUP:

        //
        // Handle the two stage IRP for a file close operation. When the first
        // stage hits, run down all activity on the object of interest. This
        // do everything to it but remove the creation hold. Then, when the
        // CLOSE irp hits, actually close the object.
        //
#ifdef _WIN64
        switch (Type = ((ULONG_PTR)REQUEST_OPEN_TYPE(Request))) {
#else
        switch (Type = ((ULONG)(REQUEST_OPEN_TYPE(Request)) & IPX_CC_MASK)) {
#endif


        default:

             if ((Type >= ROUTER_ADDRESS_FILE) &&
                         (Type <= (ROUTER_ADDRESS_FILE + IPX_RT_MAX_ADDRESSES)))
             {
                CleanupRtAddress(Device, Request);
             }
             else
             {
                 Status = STATUS_INVALID_HANDLE;
                 break;
             }


            //
            // fall through
            //
        case TDI_TRANSPORT_ADDRESS_FILE:
            AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);
            Status = IpxVerifyAddressFile(AddressFile);
            if (!NT_SUCCESS (Status)) {

                Status = STATUS_INVALID_HANDLE;

            } else {

                IpxStopAddressFile (AddressFile);
                IpxDereferenceAddressFile (AddressFile, AFREF_VERIFY);
                Status = STATUS_SUCCESS;
            }

            break;

        case IPX_FILE_TYPE_CONTROL:
            {
                LARGE_INTEGER   ControlChannelId;

                CCID_FROM_REQUEST(ControlChannelId, Request);

		IPX_DEBUG (DEVICE, ("CCID: (%d, %d)\n", ControlChannelId.HighPart, ControlChannelId.LowPart));
                //
                // Check for any line change IRPs submitted by this
                // address.
                //

                IpxAbortLineChanges ((PVOID)&ControlChannelId);
                IpxAbortNtfChanges ((PVOID)&ControlChannelId);

		Status = STATUS_SUCCESS;
		
		for (i = 0; i < UPPER_DRIVER_COUNT; i++) {
		   if (Device->UpperDriverControlChannel[i].QuadPart ==
		       ControlChannelId.QuadPart) {
			if (Irp->RequestorMode == KernelMode) {
			   Status = IpxInternalUnbind (Device, i);
			} else {
			   DbgPrint("!!!! IPX:Rejected non-kernel-mode component's attemp to close handles. !!!!\n"); 
			   Status = STATUS_UNSUCCESSFUL; 
			}
			break;
                    }
                }


                break;
            }
        }

        break;


    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;

    } /* major function switch */

    if (Status != STATUS_PENDING) {
        UNMARK_REQUEST_PENDING(Request);
        REQUEST_STATUS(Request) = Status;
        IpxCompleteRequest (Request);
        IpxFreeRequest (Device, Request);
    }

    //
    // Return the immediate status code to the caller.
    //

    return Status;

}   /* IpxDispatchOpenClose */

#define IOCTL_IPX_LOAD_SPX      _IPX_CONTROL_CODE( 0x5678, METHOD_BUFFERED )

NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );


NTSTATUS
IpxDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches TDI request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various TDI request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status;
    PDEVICE Device = IpxDevice;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);
    static NDIS_STRING SpxServiceName = NDIS_STRING_CONST ("\\Registry\\Machine\\System\\CurrentControlSet\\Services\\NwlnkSpx");
    KPROCESSOR_MODE PreviousMode;

    ASSERT( DeviceObject->DeviceExtension == IpxDevice );

    //
    // Branch to the appropriate request handler.  Preliminary checking of
    // the size of the request block is performed here so that it is known
    // in the handlers that the minimum input parameters are readable.  It
    // is *not* determined here whether variable length input fields are
    // passed correctly; this is a check which must be made within each routine.
    //

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER: {


#ifdef SUNDOWN
           PULONG_PTR EntryPoint; 
#else
	   PULONG EntryPoint;
#endif



            //
            // This is the LanmanServer trying to get the send
            // entry point.
            //

            IPX_DEBUG (BIND, ("Direct send entry point being returned\n"));

            EntryPoint = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            
            //
            //  96390: SEC PROBES [ShreeM]
            //

            //
            // Get previous processor mode
            //
        
            PreviousMode = ExGetPreviousMode();
            
            if (PreviousMode != KernelMode) {
                
                try {

                 
#ifdef SUNDOWN
		   ProbeForWrite( EntryPoint,
                                  sizeof( ULONG_PTR ),
                                  TYPE_ALIGNMENT( ULONG_PTR )
                                 );
                    *EntryPoint = (ULONG_PTR)IpxTdiSendDatagram;
#else
		    ProbeForWrite( EntryPoint,
                                   sizeof( ULONG ),
                                   sizeof( ULONG )
                                 );
                    *EntryPoint = (ULONG)IpxTdiSendDatagram;
#endif



                } except( EXCEPTION_EXECUTE_HANDLER ) {
                      
                      Status = GetExceptionCode();
                      Irp->IoStatus.Status = Status;
                      IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

                      return( Status );

                }
            } else {
#ifdef SUNDOWN
                *EntryPoint = (ULONG_PTR)IpxTdiSendDatagram;
#else
                *EntryPoint = (ULONG)IpxTdiSendDatagram;
#endif



            }

                    
            Status = STATUS_SUCCESS;
            Irp->IoStatus.Status = Status;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
            break;
        }

        case IOCTL_IPX_INTERNAL_BIND:

            //
            // This is a client trying to bind.
            //

            CTEAssert ((IOCTL_IPX_INTERNAL_BIND & 0x3) == METHOD_BUFFERED);
            CTEAssert (IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);

            
            if ((Device->State == DEVICE_STATE_CLOSED) ||
				(Device->State == DEVICE_STATE_STOPPING)) {
	        DbgPrint("IPX:IpxDispatchDeviceControl:Invalid Device state, skip internal bind\n"); 
                Status = STATUS_INVALID_DEVICE_STATE;

            } else {
	       PreviousMode = ExGetPreviousMode();	       
	       if (PreviousMode == KernelMode) {
		  Status = IpxInternalBind (Device, Irp);
	       } else {
		  DbgPrint("IPX:Caller is not in kernel mode.\n"); 
		  Status = STATUS_UNSUCCESSFUL; 
	       }

            }

            CTEAssert (Status != STATUS_PENDING);

            Irp->IoStatus.Status = Status;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

            break;

        case IOCTL_IPX_LOAD_SPX:

            //
            // The SPX helper dll is asking us to load SPX.
            //

            Status = ZwLoadDriver (&SpxServiceName);

            Irp->IoStatus.Status = Status;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

            break;

#ifdef  SNMP
        case    IOCTL_IPX_MIB_GET: {

            //
            // Get the Base MIB entries out of the device. All Host-side
            // entries, appearing in the MS and Novell MIBs are returned.
            //
            PNOVIPXMIB_BASE    UserBuffer;

            UserBuffer = (PNOVIPXMIB_BASE)Irp->AssociatedIrp.SystemBuffer;

            Irp->IoStatus.Information = sizeof(NOVIPXMIB_BASE);

            RtlCopyMemory(  UserBuffer,
                            &Device->MibBase,
                            sizeof(NOVIPXMIB_BASE));

            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

            Status = STATUS_SUCCESS;

            break;
        }
#endif SNMP

        case MIPX_SEND_DATAGRAM:
            MARK_REQUEST_PENDING(Irp);
            Status = SendIrpFromRt (Device, Irp);
            if (Status == STATUS_PENDING) {
                return STATUS_PENDING;
            } else {
                UNMARK_REQUEST_PENDING(Irp);
                REQUEST_STATUS(Irp) = Status;
                IpxCompleteRequest (Irp);
                IpxFreeRequest (Device, Irp);
                return Status;
            }

            break;

        case MIPX_RCV_DATAGRAM:
            MARK_REQUEST_PENDING(Irp);
            Status =  RcvIrpFromRt (Device, Irp);
            if (Status == STATUS_PENDING) {
                return STATUS_PENDING;
            } else {
                UNMARK_REQUEST_PENDING(Irp);
                REQUEST_STATUS(Irp) = Status;
                IpxCompleteRequest (Irp);
                IpxFreeRequest (Device, Irp);
                return Status;
            }

            break;


        default:

            //
            // Convert the user call to the proper internal device call.
            //

            Status = TdiMapUserRequest (DeviceObject, Irp, IrpSp);

            if (Status == STATUS_SUCCESS) {

                //
                // If TdiMapUserRequest returns SUCCESS then the IRP
                // has been converted into an IRP_MJ_INTERNAL_DEVICE_CONTROL
                // IRP, so we dispatch it as usual. The IRP will
                // be completed by this call.
                //

                Status = IpxDispatchInternal (DeviceObject, Irp);

            } else {

                Irp->IoStatus.Status = Status;
                IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

            }

            break;
    }
    return Status;

}   /* IpxDispatchDeviceControl */


NTSTATUS
IpxDispatchInternal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches TDI request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various TDI request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status;
    PDEVICE Device = IpxDevice;
    PREQUEST Request;

    ASSERT( DeviceObject->DeviceExtension == IpxDevice );

    if (Device->State == DEVICE_STATE_OPEN) {

        //
        // Allocate a request to track this IRP.
        //

        Request = IpxAllocateRequest (Device, Irp);

        IF_NOT_ALLOCATED(Request) {
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        //
        // Make sure status information is consistent every time.
        //

        MARK_REQUEST_PENDING(Request);
#if DBG
        REQUEST_STATUS(Request) = STATUS_PENDING;
        REQUEST_INFORMATION(Request) = 0;
#endif

        //
        // Branch to the appropriate request handler.  Preliminary checking of
        // the size of the request block is performed here so that it is known
        // in the handlers that the minimum input parameters are readable.  It
        // is *not* determined here whether variable length input fields are
        // passed correctly; this is a check which must be made within each routine.
        //

        switch (REQUEST_MINOR_FUNCTION(Request)) {

            case TDI_SEND_DATAGRAM:
                Status = IpxTdiSendDatagram (DeviceObject, Request);
                break;

            case TDI_ACTION:
                Status = IpxTdiAction (Device, Request);
                break;

            case TDI_QUERY_INFORMATION:
                Status = IpxTdiQueryInformation (Device, Request);
                break;

            case TDI_RECEIVE_DATAGRAM:
                Status =  IpxTdiReceiveDatagram (Request);
                break;

            case TDI_SET_EVENT_HANDLER:
                Status = IpxTdiSetEventHandler (Request);
                break;

            case TDI_SET_INFORMATION:
                Status = IpxTdiSetInformation (Device, Request);
                break;


            //
            // Something we don't know about was submitted.
            //

            default:
                Status = STATUS_INVALID_DEVICE_REQUEST;
        }

        //
        // Return the immediate status code to the caller.
        //

        if (Status == STATUS_PENDING) {

            return STATUS_PENDING;

        } else {

            UNMARK_REQUEST_PENDING(Request);
            REQUEST_STATUS(Request) = Status;
            IpxCompleteRequest (Request);
            IpxFreeRequest (Device, Request);
            return Status;
        }


    } else {

        //
        // The device was not open.
        //

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }



}   /* IpxDispatchInternal */


PVOID
IpxpAllocateMemory(
    IN ULONG BytesNeeded,
    IN ULONG Tag,
    IN BOOLEAN ChargeDevice
    )

/*++

Routine Description:

    This routine allocates memory, making sure it is within
    the limit allowed by the device.

Arguments:

    BytesNeeded - The number of bytes to allocated.

    ChargeDevice - TRUE if the device should be charged.

Return Value:

    None.

--*/

{
    PVOID Memory;
    PDEVICE Device = IpxDevice;

    if (ChargeDevice) {
        if ((Device->MemoryLimit != 0) &&
                (((LONG)(Device->MemoryUsage + BytesNeeded) >
                    Device->MemoryLimit))) {

            IpxPrint1 ("IPX: Could not allocate %d: limit\n", BytesNeeded);
            IpxWriteResourceErrorLog(
                Device->DeviceObject,
                EVENT_TRANSPORT_RESOURCE_POOL,
                BytesNeeded,
                Tag);

            return NULL;
        }
    }

#if ISN_NT
    Memory = ExAllocatePoolWithTag (NonPagedPool, BytesNeeded, ' XPI');
#else
    Memory = CTEAllocMem (BytesNeeded);
#endif

    if (Memory == NULL) {

        IpxPrint1("IPX: Could not allocate %d: no pool\n", BytesNeeded);
        if (ChargeDevice) {
            IpxWriteResourceErrorLog(
                Device->DeviceObject,
                EVENT_TRANSPORT_RESOURCE_POOL,
                BytesNeeded,
                Tag);
        }

        return NULL;
    }

    if (ChargeDevice) {
        Device->MemoryUsage += BytesNeeded;
    }

    return Memory;
}   /* IpxpAllocateMemory */


VOID
IpxpFreeMemory(
    IN PVOID Memory,
    IN ULONG BytesAllocated,
    IN BOOLEAN ChargeDevice
    )

/*++

Routine Description:

    This routine frees memory allocated with IpxpAllocateMemory.

Arguments:

    Memory - The memory allocated.

    BytesAllocated - The number of bytes to freed.

    ChargeDevice - TRUE if the device should be charged.

Return Value:

    None.

--*/

{
    PDEVICE Device = IpxDevice;

#if ISN_NT
    ExFreePool (Memory);
#else
    CTEFreeMem (Memory);
#endif
    if (ChargeDevice) {
        Device->MemoryUsage -= BytesAllocated;
    }

}   /* IpxpFreeMemory */

#if DBG


PVOID
IpxpAllocateTaggedMemory(
    IN ULONG BytesNeeded,
    IN ULONG Tag,
    IN PUCHAR Description
    )

/*++

Routine Description:

    This routine allocates memory, charging it to the device.
    If it cannot allocate memory it uses the Tag and Descriptor
    to log an error.

Arguments:

    BytesNeeded - The number of bytes to allocated.

    Tag - A unique ID used in the error log.

    Description - A text description of the allocation.

Return Value:

    None.

--*/

{
    PVOID Memory;

    UNREFERENCED_PARAMETER(Description);

    Memory = IpxpAllocateMemory(BytesNeeded, Tag, (BOOLEAN)(Tag != MEMORY_CONFIG));

    if (Memory) {
        (VOID)IPX_ADD_ULONG(
            &IpxMemoryTag[Tag].BytesAllocated,
            BytesNeeded,
            &IpxMemoryInterlock);
    }

    return Memory;

}   /* IpxpAllocateTaggedMemory */


VOID
IpxpFreeTaggedMemory(
    IN PVOID Memory,
    IN ULONG BytesAllocated,
    IN ULONG Tag,
    IN PUCHAR Description
    )

/*++

Routine Description:

    This routine frees memory allocated with IpxpAllocateTaggedMemory.

Arguments:

    Memory - The memory allocated.

    BytesAllocated - The number of bytes to freed.

    Tag - A unique ID used in the error log.

    Description - A text description of the allocation.

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER(Description);

    (VOID)IPX_ADD_ULONG(
        &IpxMemoryTag[Tag].BytesAllocated,
        (ULONG)(-(LONG)BytesAllocated),
        &IpxMemoryInterlock);

    IpxpFreeMemory (Memory, BytesAllocated, (BOOLEAN)(Tag != MEMORY_CONFIG));

}   /* IpxpFreeTaggedMemory */

#endif


VOID
IpxWriteResourceErrorLog(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS ErrorCode,
    IN ULONG BytesNeeded,
    IN ULONG UniqueErrorValue
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry which has
    a %3 value that needs to be converted to a string. It is currently
    used for EVENT_TRANSPORT_RESOURCE_POOL and EVENT_IPX_INTERNAL_NET_
    INVALID.

Arguments:

    DeviceObject - Pointer to the system device object.

    ErrorCode - The transport event code.

    BytesNeeded - If applicable, the number of bytes that could not
        be allocated -- will be put in the dump data.

    UniqueErrorValue - Used as the UniqueErrorValue in the error log
        packet and converted for use as the %3 string.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    PUCHAR StringLoc;
    ULONG TempUniqueError;
    PDEVICE Device = IpxDevice;
    static WCHAR UniqueErrorBuffer[9] = L"00000000";
    UINT CurrentDigit;
    INT i;


    //
    // Convert the error value into a buffer.
    //

    TempUniqueError = UniqueErrorValue;
    i = 8;
    do {
        CurrentDigit = TempUniqueError & 0xf;
        TempUniqueError >>= 4;
        i--;
        if (CurrentDigit >= 0xa) {
            UniqueErrorBuffer[i] = (WCHAR)(CurrentDigit - 0xa + L'A');
        } else {
            UniqueErrorBuffer[i] = (WCHAR)(CurrentDigit + L'0');
        }
    } while (TempUniqueError);

	// cast to UCHAR to avoid 64-bit warning. 
    EntrySize = (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) +
						 Device->DeviceNameLength +
						 sizeof(UniqueErrorBuffer) - (i * sizeof(WCHAR)));

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        DeviceObject,
        EntrySize
    );

    if (errorLogEntry != NULL) {

        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = sizeof(ULONG);
        errorLogEntry->NumberOfStrings = 2;
        errorLogEntry->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->DumpData[0] = BytesNeeded;

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;

        // This routine may be called before IpxDevice is created. 
        if (Device != NULL) {
           RtlCopyMemory (StringLoc, Device->DeviceName, Device->DeviceNameLength);

           StringLoc += Device->DeviceNameLength;
        } 

        RtlCopyMemory (StringLoc, UniqueErrorBuffer + i, sizeof(UniqueErrorBuffer) - (i * sizeof(WCHAR)));

        IoWriteErrorLogEntry(errorLogEntry);

    }

}   /* IpxWriteResourceErrorLog */


VOID
IpxWriteGeneralErrorLog(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PWSTR SecondString,
    IN ULONG DumpDataCount,
    IN ULONG DumpData[]
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    a general problem as indicated by the parameters. It handles
    event codes REGISTER_FAILED, BINDING_FAILED, ADAPTER_NOT_FOUND,
    TRANSFER_DATA, TOO_MANY_LINKS, and BAD_PROTOCOL. All these
    events have messages with one or two strings in them.

Arguments:

    DeviceObject - Pointer to the system device object, or this may be
        a driver object instead.

    ErrorCode - The transport event code.

    UniqueErrorValue - Used as the UniqueErrorValue in the error log
        packet.

    FinalStatus - Used as the FinalStatus in the error log packet.

    SecondString - If not NULL, the string to use as the %3
        value in the error log packet.

    DumpDataCount - The number of ULONGs of dump data.

    DumpData - Dump data for the packet.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    ULONG SecondStringSize;
    PUCHAR StringLoc;
    PDEVICE Device = IpxDevice;
    static WCHAR DriverName[9] = L"NwlnkIpx";

#if DBG
	if ((sizeof(IO_ERROR_LOG_PACKET) + (DumpDataCount * sizeof(ULONG))) > 255) {
		DbgPrint("IPX: Data size is greater than the maximum size allowed by UCHAR\n"); 
	} 
#endif

    EntrySize = (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) +
                (DumpDataCount * sizeof(ULONG)));

    if (DeviceObject->Type == IO_TYPE_DEVICE) {
        EntrySize += (UCHAR)Device->DeviceNameLength;
    } else {
        EntrySize += sizeof(DriverName);
    }

    if (SecondString) {
        SecondStringSize = (wcslen(SecondString)*sizeof(WCHAR)) + sizeof(UNICODE_NULL);
        EntrySize += (UCHAR)SecondStringSize;
    }

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        DeviceObject,
        EntrySize
    );

    if (errorLogEntry != NULL) {

        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = (USHORT)(DumpDataCount * sizeof(ULONG));
        errorLogEntry->NumberOfStrings = (SecondString == NULL) ? 1 : 2;
        errorLogEntry->StringOffset = (USHORT) 
            (sizeof(IO_ERROR_LOG_PACKET) + ((DumpDataCount-1) * sizeof(ULONG)));
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;

        if (DumpDataCount) {
            RtlCopyMemory(errorLogEntry->DumpData, DumpData, DumpDataCount * sizeof(ULONG));
        }

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        if (DeviceObject->Type == IO_TYPE_DEVICE) {
            RtlCopyMemory (StringLoc, Device->DeviceName, Device->DeviceNameLength);
            StringLoc += Device->DeviceNameLength;
        } else {
            RtlCopyMemory (StringLoc, DriverName, sizeof(DriverName));
            StringLoc += sizeof(DriverName);
        }
        if (SecondString) {
            RtlCopyMemory (StringLoc, SecondString, SecondStringSize);
        }

        IoWriteErrorLogEntry(errorLogEntry);

    } else {
       DbgPrint("IPX: Failed to allocate %d bytes for IO error log entry.\n", EntrySize); 
    }

}   /* IpxWriteGeneralErrorLog */


VOID
IpxWriteOidErrorLog(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS ErrorCode,
    IN NTSTATUS FinalStatus,
    IN PWSTR AdapterString,
    IN ULONG OidValue
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    a problem querying or setting an OID on an adapter. It handles
    event codes SET_OID_FAILED and QUERY_OID_FAILED.

Arguments:

    DeviceObject - Pointer to the system device object.

    ErrorCode - Used as the ErrorCode in the error log packet.

    FinalStatus - Used as the FinalStatus in the error log packet.

    AdapterString - The name of the adapter we were bound to.

    OidValue - The OID which could not be set or queried.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    ULONG AdapterStringSize;
    PUCHAR StringLoc;
    PDEVICE Device = IpxDevice;
    static WCHAR OidBuffer[9] = L"00000000";
    INT i;
    UINT CurrentDigit;

    AdapterStringSize = (wcslen(AdapterString)*sizeof(WCHAR)) + sizeof(UNICODE_NULL);
    EntrySize = (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) -
						 sizeof(ULONG) +
						 Device->DeviceNameLength +
						 AdapterStringSize +
						 sizeof(OidBuffer));

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        DeviceObject,
        EntrySize
    );

    //
    // Convert the OID into a buffer.
    //

    for (i=7; i>=0; i--) {
        CurrentDigit = OidValue & 0xf;
        OidValue >>= 4;
        if (CurrentDigit >= 0xa) {
            OidBuffer[i] = (WCHAR)(CurrentDigit - 0xa + L'A');
        } else {
            OidBuffer[i] = (WCHAR)(CurrentDigit + L'0');
        }
    }

    if (errorLogEntry != NULL) {

        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = 0;
        errorLogEntry->NumberOfStrings = 3;
        errorLogEntry->StringOffset = sizeof(IO_ERROR_LOG_PACKET) - sizeof(ULONG);
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = FinalStatus;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        RtlCopyMemory (StringLoc, Device->DeviceName, Device->DeviceNameLength);
        StringLoc += Device->DeviceNameLength;

        RtlCopyMemory (StringLoc, OidBuffer, sizeof(OidBuffer));
        StringLoc += sizeof(OidBuffer);

        RtlCopyMemory (StringLoc, AdapterString, AdapterStringSize);

        IoWriteErrorLogEntry(errorLogEntry);

    }

}   /* IpxWriteOidErrorLog */


VOID
IpxPnPUpdateDevice(
    IN  PDEVICE Device
    )

/*++

Routine Description:

	Updates datagram sizes, lookahead sizes, etc. in the Device as a result
    of a new binding coming in.

Arguments:

    Device - The IPX device object.

Return Value:

    None.

--*/
{
    ULONG AnnouncedMaxDatagram = 0, RealMaxDatagram = 0, MaxLookahead = 0;
    ULONG LinkSpeed = 0, MacOptions = 0;
    ULONG i;
    PBINDING    Binding;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)

    IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle);

    if (Device->ValidBindings) {

       //
       // Calculate some values based on all the bindings.
       //
       
       MaxLookahead = NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->MaxLookaheadData; // largest binding value
       AnnouncedMaxDatagram = NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->AnnouncedMaxDatagramSize;   // smallest binding value
       RealMaxDatagram = NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->RealMaxDatagramSize;   // smallest binding value
   
       if (NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->LineUp) {
           LinkSpeed = NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->MediumSpeed;  // smallest binding value
       } else {
           LinkSpeed = 0xffffffff;
       }
       MacOptions = NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->Adapter->MacInfo.MacOptions; // AND of binding values
   
       for (i = FIRST_REAL_BINDING; i <= Device->ValidBindings; i++) {
   
           Binding = NIC_ID_TO_BINDING_NO_ILOCK(Device, i);
   
           if (!Binding) {
               continue;
           }
   
           if (Binding->MaxLookaheadData > MaxLookahead) {
               MaxLookahead = Binding->MaxLookaheadData;
           }
           if (Binding->AnnouncedMaxDatagramSize < AnnouncedMaxDatagram) {
               AnnouncedMaxDatagram = Binding->AnnouncedMaxDatagramSize;
           }
           if (Binding->RealMaxDatagramSize < RealMaxDatagram) {
               RealMaxDatagram = Binding->RealMaxDatagramSize;
           }
   
           if (Binding->LineUp && (Binding->MediumSpeed < LinkSpeed)) {
               LinkSpeed = Binding->MediumSpeed;
           }
           MacOptions &= Binding->Adapter->MacInfo.MacOptions;
   
       }
       
       //
       // If we couldn't find anything better, use the speed from
       // the first binding.
       //
   
       if (LinkSpeed == 0xffffffff) {
           Device->LinkSpeed = NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->MediumSpeed;
       } else {
           Device->LinkSpeed = LinkSpeed;
       }
       
       Device->MacOptions = MacOptions;
       
    } else {
       
       //
       // zero bindings means LinkSpeed = 0;
       //
       Device->LinkSpeed = 0;
    }
    
    Device->Information.MaxDatagramSize = AnnouncedMaxDatagram;
    Device->RealMaxDatagramSize = RealMaxDatagram;
    Device->Information.MaximumLookaheadData = MaxLookahead;
   

    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle);
}

VOID
IpxPnPUpdateBindingArray(
    IN PDEVICE Device,
    IN PADAPTER	Adapter,
    IN PBINDING_CONFIG  ConfigBinding
    )

/*++

Routine Description:

    This routine is called to update the binding array to
	add the new bindings that appeared in this PnP event.
    The order of bindings in the array is as follows:

    - First comes the first binding to each LAN network
    - Following that are all WAN bindings
    - Following that are any duplicate bindings to LAN networks
        (the others in the "binding set").

	This routine inserts the bindings while maintaining this
	order by resolving binding sets.

	The bindings are also inserted into the RIP database.

    If "global wan net" is true we will advertise up to
    and including the first wan binding as the highest nic
    id; otherwise we advertise up to and including the last
    wan binding. In all cases the duplicate bindings are
    hidden.

	Updates the SapNicCount, Device->FirstLanNicId and Device->FirstWanNicId

Arguments:

    Device - The IPX device object.

    Adapter -  The adapter added in this PnP event

	ValidBindings - the number of bindings valid for this adapter (if LAN)

Return Value:

    None.

--*/
{
	ULONG	i, j;
	PBINDING Binding, MasterBinding;
	NTSTATUS	status;

	//
	// Insert in proper place; if WAN, after all the WAN bindings
	// If LAN, check for binding sets and insert in proper place
	// Also, insert into the Rip Tables.
	//

	//
	// Go thru' the bindings for this adapter, inserting into the
	// binding array in place
	//
	for (i = 0; i < ConfigBinding->FrameTypeCount; i++) {
        ULONG MappedFrameType = ISN_FRAME_TYPE_802_3;

        //
        // Store in the preference order.
        // Map the frame types since we could have a case where the user selects a FrameType (say, EthernetII on FDDI)
        // which maps to a different FrameType (802.2). Then we would fail to find the binding in the adapter array;
        // we could potentialy add a binding twice (if two frame types map to the same Frame, then we would go to the
        // mapped one twice). This is taken care of by purging dups from the ConfigBinding->FrameType array when we
        // create the bindings off of the Adapter (see call to IpxBindToAdapter).
        //

        MacMapFrameType(
            Adapter->MacInfo.RealMediumType,
            ConfigBinding->FrameType[i],
            &MappedFrameType);

		Binding = Adapter->Bindings[MappedFrameType];


		if (!Binding){
			continue;
		}

        CTEAssert(Binding->FrameType == MappedFrameType);

        Binding->fInfoIndicated = FALSE;

		if (Adapter->MacInfo.MediumAsync) {
            PBINDING    DemandDialBinding;

			//
			// WAN: Place after the HighestExternalNicId, with space for WanLine # of bindings.
			// Update the First/LastWanNicId.
			//
			Adapter->FirstWanNicId = (USHORT)Device->HighestExternalNicId+1;
			Adapter->LastWanNicId = (USHORT)(Device->HighestExternalNicId + Adapter->WanNicIdCount);

            //
			// Make sure we dont overflow the array
			// Re-alloc the array to fit the new bindings
			//
            if (Device->ValidBindings+Adapter->WanNicIdCount >= Device->MaxBindings) {
                status = IpxPnPReallocateBindingArray(Device, Adapter->WanNicIdCount);
                if (status != STATUS_SUCCESS) {
                    DbgPrint("!!!!! IpxPnPReallocateBindingArray failed with status %x !!!!!\n", status); 
                    ASSERT(FALSE); 
                    return; 
                }
            }

			//
			// Move Slaves down by WanNicIdCount# of entries
			//
			for (j = Device->ValidBindings; j > Device->HighestExternalNicId; j--) {
				INSERT_BINDING(Device, j+Adapter->WanNicIdCount, NIC_ID_TO_BINDING_NO_ILOCK(Device, j));
                INSERT_BINDING(Device, j, NULL);
                if (NIC_ID_TO_BINDING_NO_ILOCK(Device, j+Adapter->WanNicIdCount)) {
                    NIC_ID_TO_BINDING_NO_ILOCK(Device, j+Adapter->WanNicIdCount)->NicId += (USHORT)Adapter->WanNicIdCount;
                }
			}

			//
			// Insert the WAN binding in the place just allocated
			//
			INSERT_BINDING(Device, Device->HighestExternalNicId+1, Binding);
			SET_VERSION(Device, Device->HighestExternalNicId+1);

			Binding->NicId = (USHORT)Device->HighestExternalNicId+1;

			//
			// Update the indices
			//
            //
            // We do not create WanNicIdCount number of bindings, just one!
            // NDISWAN tells us that there are 1000 WAN lines by default.
            // The rest will be created on WAN_LINE_UP in ndis.c [ShreeM]
            //

			Device->HighestExternalNicId += (USHORT)Adapter->WanNicIdCount;
			Device->ValidBindings += (USHORT)Adapter->WanNicIdCount;
			Device->BindingCount += (USHORT)Adapter->WanNicIdCount;
			Device->SapNicCount++;

            //
            // Since we initialize FirstWanNicId to 1, we need to compare against that.
            // In case of no LAN bindings, we are fine since we have only one WAN binding initally
            // (all the other WAN lines have place holders).
            //
			if (Device->FirstWanNicId == (USHORT)1) {
				Device->FirstWanNicId = Binding->NicId;
			}

            //
            // Prime the DemandDial binding too.
            //

            //
            // First allocate the memory for the binding.
            //
            status = IpxCreateBinding(
                         Device,
                         NULL,
                         0,
                         Adapter->AdapterName,
                         &DemandDialBinding);

            if (status != STATUS_SUCCESS) {
	       IpxWriteGeneralErrorLog(
		   (PVOID)IpxDevice->DeviceObject,
		   EVENT_TRANSPORT_RESOURCE_POOL,
		   810,
		   status,
		   L"IpxPnPUpdateBindingArray: failed to create demand dial binding",
		   0,
		   NULL);
	       DbgPrint("IPX: IpxCreateBinding on demand dial failed with status %x\n.",status);  
            } else {
	       //
	       // Copy over all the values from the first WAN binding created above.
	       //
	       RtlCopyMemory(DemandDialBinding, Binding, sizeof(BINDING));
	       INSERT_BINDING(Device, (SHORT)DEMAND_DIAL_ADAPTER_CONTEXT, DemandDialBinding);
	       DemandDialBinding->NicId = (USHORT)DEMAND_DIAL_ADAPTER_CONTEXT;
	       DemandDialBinding->FwdAdapterContext = INVALID_CONTEXT_VALUE;
	       IpxReferenceBinding(DemandDialBinding, BREF_FWDOPEN); // so it appears the FWD opened it.

	    }
            //
            // This should be done after all the auto-detect bindings have been thrown away.
            //
            // IpxPnPUpdateDevice(Device, Binding);

            //
            // Since WAN can have only one frame type, break
            //
            break;

		} else {

			Device->BindingCount++;

            //
            // Make sure we dont overflow the array
            // Re-alloc the array to fit the new bindings
            //
            if (Device->ValidBindings+1 >= Device->MaxBindings) {
                status = IpxPnPReallocateBindingArray(Device, 1);
                CTEAssert(status == STATUS_SUCCESS);
            }

			//
			// LAN: Figure out if it is a slave binding only for non-auto-detect bindings.
			//
            {
            ULONG   Index = MIN (Device->MaxBindings, Device->HighestExternalNicId);

			for (j = FIRST_REAL_BINDING; j < Index; j++) {
				MasterBinding = NIC_ID_TO_BINDING_NO_ILOCK(Device, j);
				if (MasterBinding &&
                    (MasterBinding->ConfiguredNetworkNumber) &&
                    (MasterBinding->ConfiguredNetworkNumber == Binding->ConfiguredNetworkNumber) &&
					(MasterBinding->FrameType == Binding->FrameType) &&
					(MasterBinding->Adapter->MacInfo.MediumType == Binding->Adapter->MacInfo.MediumType)) {

                    CTEAssert(Binding->ConfiguredNetworkNumber);
					break;
				}			
            }
            }

			if (j < Device->HighestExternalNicId) {
				//
				// Slave binding
				//

				//
				// Now make MasterBinding the head of a binding set.
				//
		
				if (MasterBinding->BindingSetMember) {
		
					//
					// Just insert ourselves in the chain.
					//
		
#if DBG
					DbgPrint ("IPX: %ws is also on network %lx\n",
						Binding->Adapter->AdapterName,
						REORDER_ULONG (Binding->LocalAddress.NetworkAddress));
#endif
					IPX_DEBUG (AUTO_DETECT, ("Add %lx to binding set of %lx\n", Binding, MasterBinding));
		
					CTEAssert (MasterBinding->CurrentSendBinding);
					Binding->NextBinding = MasterBinding->NextBinding;
		
				} else {
		
					//
					// Start the chain with the two bindings in it.
					//
		
#if DBG
					DbgPrint ("IPX: %lx and %lx are on the same network %lx, will load balance\n",
						MasterBinding->Adapter->AdapterName, Binding->Adapter->AdapterName,
						REORDER_ULONG (Binding->LocalAddress.NetworkAddress));
#endif
					IPX_DEBUG (AUTO_DETECT, ("Create new %lx in binding set of %lx\n", Binding, MasterBinding));
		
					MasterBinding->BindingSetMember = TRUE;
					MasterBinding->CurrentSendBinding = MasterBinding;
					MasterBinding->MasterBinding = MasterBinding;
					Binding->NextBinding = MasterBinding;
		
				}
		
				MasterBinding->NextBinding = Binding;
				Binding->BindingSetMember = TRUE;
				Binding->ReceiveBroadcast = FALSE;
				Binding->CurrentSendBinding = NULL;
				Binding->MasterBinding = MasterBinding;
                KdPrint((" %x set to FALSE\n", Binding));
		
				//
				// Since the master binding looks like all members of
				// the binding set to people querying from above, we have
				// to make it the worst-case of all the elements. Generally
				// these will be equal since the frame type and media is
				// the same.
				//
		
				if (Binding->MaxLookaheadData > MasterBinding->MaxLookaheadData) {
					MasterBinding->MaxLookaheadData = Binding->MaxLookaheadData;
				}
				if (Binding->AnnouncedMaxDatagramSize < MasterBinding->AnnouncedMaxDatagramSize) {
					MasterBinding->AnnouncedMaxDatagramSize = Binding->AnnouncedMaxDatagramSize;
				}
				if (Binding->RealMaxDatagramSize < MasterBinding->RealMaxDatagramSize) {
					MasterBinding->RealMaxDatagramSize = Binding->RealMaxDatagramSize;
				}
				if (Binding->MediumSpeed < MasterBinding->MediumSpeed) {
					MasterBinding->MediumSpeed = Binding->MediumSpeed;
				}

				//
				// Place the binding after the last slave binding
				//
				INSERT_BINDING(Device, Device->ValidBindings+1, Binding);
				SET_VERSION(Device, Device->ValidBindings+1);

				Binding->NicId = (USHORT)Device->ValidBindings+1;

				//
				// Update the indices
				//
				Device->ValidBindings++;

			} else {

                PBINDING    WanBinding=NIC_ID_TO_BINDING_NO_ILOCK(Device, Device->HighestLanNicId+1);

                if (WanBinding) {
                    WanBinding->Adapter->LastWanNicId++;
                    WanBinding->Adapter->FirstWanNicId++;
                }

				//
				// Not a binding set slave binding - just add it after the last LAN binding
				//

                //
				// Move WAN and Slaves down by 1 entry
				//
				for (j = Device->ValidBindings; j > Device->HighestLanNicId; j--) {
					INSERT_BINDING(Device, j+1, NIC_ID_TO_BINDING_NO_ILOCK(Device, j));
                    if (NIC_ID_TO_BINDING_NO_ILOCK(Device, j+1)) {
                        NIC_ID_TO_BINDING_NO_ILOCK(Device, j+1)->NicId++;
                    }
				}

                //
                // Increment the WAN counters in the adapter.
                //


				//
				// Insert the LAN binding in the place just allocated
				//
				INSERT_BINDING(Device, Device->HighestLanNicId+1, Binding);
				SET_VERSION(Device, Device->HighestLanNicId+1);
				Binding->NicId = (USHORT)Device->HighestLanNicId+1;

				//
				// Update the indices
				//
				Device->HighestLanNicId++;
				Device->HighestExternalNicId++;
				Device->ValidBindings++;
				Device->HighestType20NicId++;
				Device->SapNicCount++;

				if (Device->FirstLanNicId == (USHORT)-1) {
					Device->FirstLanNicId = Binding->NicId;
				}

			}
				
		}
	
		//
		// Insert this binding in the RIP Tables
		//
		if (Binding->ConfiguredNetworkNumber != 0) {
			status = RipInsertLocalNetwork(
						 Binding->ConfiguredNetworkNumber,
						 Binding->NicId,
						 Binding->Adapter->NdisBindingHandle,
						 (USHORT)((839 + Binding->Adapter->MediumSpeed) / Binding->Adapter->MediumSpeed));
		
			if ((status == STATUS_SUCCESS) ||
				(status == STATUS_DUPLICATE_NAME)) {
		
				Binding->LocalAddress.NetworkAddress = Binding->ConfiguredNetworkNumber;
			}
		}
	
        //
        // This should be done after all the auto-detect bindings have been thrown away.
        //
        // IpxPnPUpdateDevice(Device, Binding);
	}

} /* IpxPnPUpdateBindingArray */


VOID
IpxPnPToLoad()
/*++

Routine Description:

    This routine takes the driver to LOADED state (from OPEN) when all
    PnP adapters have been removed from the machine.

Arguments:

    None.

Return Value:

    None. When the function returns, the driver is in LOADED state.

--*/

{
    PBINDING Binding;
    PREQUEST Request;
    PLIST_ENTRY p;
    UINT i;
    NTSTATUS    ntStatus;
    KIRQL irql;

    //
    // Complete any pending address notify requests.
    //

    while ((p = ExInterlockedRemoveHeadList(
                   &IpxDevice->AddressNotifyQueue,
                   &IpxDevice->Lock)) != NULL) {

        Request = LIST_ENTRY_TO_REQUEST(p);
        REQUEST_STATUS(Request) = STATUS_DEVICE_NOT_READY;
	IoAcquireCancelSpinLock( &irql );
	IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
	IoReleaseCancelSpinLock( irql );
	IpxCompleteRequest (Request);
        IpxFreeRequest (IpxDevice, Request);

        IpxDereferenceDevice (IpxDevice, DREF_ADDRESS_NOTIFY);
    }

    //
    // Cancel the source routing timer if used.
    //

    if (IpxDevice->SourceRoutingUsed) {

        IpxDevice->SourceRoutingUsed = FALSE;
        if (CTEStopTimer (&IpxDevice->SourceRoutingTimer)) {
            IpxDereferenceDevice (IpxDevice, DREF_SR_TIMER);
        }
    }


    //
    // Cancel the RIP long timer, and if we do that then
    // send a RIP DOWN message if needed.
    //

    if (CTEStopTimer (&IpxDevice->RipLongTimer)) {

        if (IpxDevice->RipResponder) {

            if (RipQueueRequest (IpxDevice->VirtualNetworkNumber, RIP_DOWN) == STATUS_PENDING) {

                //
                // If we queue a request, it will stop the timer.
                //

                KeWaitForSingleObject(
                    &IpxDevice->UnloadEvent,
                    Executive,
                    KernelMode,
                    TRUE,
                    (PLARGE_INTEGER)NULL
                    );
            }
        }

        IpxDereferenceDevice (IpxDevice, DREF_LONG_TIMER);

    } else {

        //
        // We couldn't stop the timer, which means it is running,
        // so we need to wait for the event that is kicked when
        // the RIP DOWN messages are done.
        //

        if (IpxDevice->RipResponder) {

            KeWaitForSingleObject(
                &IpxDevice->UnloadEvent,
                Executive,
                KernelMode,
                TRUE,
                (PLARGE_INTEGER)NULL
                );
        }
    }
}   /* IpxPnPToLoad */


NTSTATUS
IpxPnPReallocateBindingArray(
    IN  PDEVICE    Device,
    IN  ULONG      Size
    )
/*++

Routine Description:

    This routine reallocates the binding array when the number of bindings go above
    Device->MaxBindings.

Arguments:

    Device - pointer to the device.
    Size - the number of new entries required.

Return Value:

    None.

--*/
{
    PBIND_ARRAY_ELEM	BindingArray;
    PBIND_ARRAY_ELEM	OldBindingArray;
    ULONG               Pad=2;         // extra bindings we keep around
    ULONG               NewSize = Size + Pad + Device->MaxBindings;
    PIPX_DELAYED_FREE_ITEM  DelayedFreeItem;
    CTELockHandle LockHandle;

    //
    // The absolute max WAN bindings.
    //
    CTEAssert(Size < 2048);

    //
    // Re-allocate the new array
    //
    BindingArray = (PBIND_ARRAY_ELEM)IpxAllocateMemory (
                                        NewSize * sizeof(BIND_ARRAY_ELEM),
                                        MEMORY_BINDING,
                                        "Binding array");

    if (BindingArray == NULL) {
        IpxWriteGeneralErrorLog(
            (PVOID)Device->DeviceObject,
            EVENT_IPX_NO_ADAPTERS,
            802,
            STATUS_DEVICE_DOES_NOT_EXIST,
            NULL,
            0,
            NULL);
        IpxDereferenceDevice (Device, DREF_CREATE);

        DbgPrint ("Failed to allocate memory in binding array expansion\n");

        //
        // Unload the driver here? In case of WAN, we can tolerate this failure. What about LAN?
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory (BindingArray, NewSize * sizeof(BIND_ARRAY_ELEM));

    //
    // Backup the pointer to free the demand dial location.
    //   

    
    CTEGetLock (&Device->Lock, &LockHandle);

    OldBindingArray = Device->Bindings - EXTRA_BINDINGS;

    //
    // Copy the old array into the new one.
    //
    RtlCopyMemory (BindingArray, OldBindingArray, (Device->ValidBindings+1+EXTRA_BINDINGS) * sizeof(BIND_ARRAY_ELEM));

    //
    // Free the old one. Free it on a delayed queue so that all
    // the threads inside this array would come out of it.
    // allocate a work item and queue it on a delayed queue.
    //
    DelayedFreeItem = (PIPX_DELAYED_FREE_ITEM)IpxAllocateMemory (
                                        sizeof(IPX_DELAYED_FREE_ITEM),
                                        MEMORY_WORK_ITEM,
                                        "Work Item");
    if ( DelayedFreeItem ) {
        DelayedFreeItem->Context = (PVOID)OldBindingArray;
        DelayedFreeItem->ContextSize = (Device->MaxBindings+EXTRA_BINDINGS) * sizeof(BIND_ARRAY_ELEM);
        ExInitializeWorkItem(
            &DelayedFreeItem->WorkItem,
            IpxDelayedFreeBindingsArray,
            (PVOID)DelayedFreeItem);

	IpxReferenceDevice(Device,DREF_BINDING); 
        ExQueueWorkItem(
            &DelayedFreeItem->WorkItem,
            DelayedWorkQueue);

	// DbgPrint("---------- 3. Queued with IpxDelayedFreeAdapter ----------\n"); 

    } else {
        //
        // oh well, tough luck. Just delay this thread and then
        // destroy the binding array.
        //
        LARGE_INTEGER   Delay;

        Delay.QuadPart = -10*1000;  // One second.

        KeDelayExecutionThread(
            KernelMode,
            FALSE,
            &Delay);

        IpxFreeMemory ( OldBindingArray,
                        (Device->MaxBindings+EXTRA_BINDINGS) * sizeof(BIND_ARRAY_ELEM),
                        MEMORY_BINDING,
                        "Binding array");

    }

    IPX_DEBUG(PNP, ("Expand bindarr old: %lx, new: %lx, oldsize: %lx\n",
                        Device->Bindings, BindingArray, Device->MaxBindings));

    //
    // We keep BindingArray[-1] as a placeholder for demand dial bindings.
    // This NicId is returned by the Fwd when a FindRoute is done on a demand
    // dial Nic. At the time of the InternalSend, the true Nic is returned.
    // We create a placeholder here to avoid special checks in the critical send path.
    //
    // NOTE: we need to free this demand dial binding as well as ensure that the
    // true binding array pointer is freed at Device Destroy time.
    //
    //
    // Increment beyond the first pointer - we will refer to the just incremented
    // one as Device->Bindings[-1].
    //
    BindingArray += EXTRA_BINDINGS;

    //
    // Use interlocked exchange to assign this since we dont take the BindAccessLock anymore.
    //
    // Device->Bindings = BindingArray;
    SET_VALUE(Device->Bindings, BindingArray);

    Device->MaxBindings = (USHORT)NewSize - EXTRA_BINDINGS;

    CTEFreeLock (&Device->Lock, LockHandle);

    return STATUS_SUCCESS;

}


VOID
IpxDelayedFreeBindingsArray(
    IN PVOID	Param
)

/*++

Routine Description:

	This routine frees a binding array on the delayed queue.  We wait long enough
    before freeing the binding array to make sure that no threads are accessing the
    binding array.  This allows us to access the binding array without the use of
    spinlocks.

Arguments:

    Param - pointer to the work item.

Return Value:

    None.

--*/
{
    LARGE_INTEGER   Delay;
    PIPX_DELAYED_FREE_ITEM DelayedFreeItem = (PIPX_DELAYED_FREE_ITEM) Param;
    PDEVICE Device = IpxDevice;

    Delay.QuadPart = -10*1000;  // One second.

    KeDelayExecutionThread(
        KernelMode,
        FALSE,
        &Delay);

    IpxFreeMemory (
        DelayedFreeItem->Context,
        DelayedFreeItem->ContextSize,
        MEMORY_BINDING,
        "Binding array");

    IpxFreeMemory (
        DelayedFreeItem,
        sizeof (IPX_DELAYED_FREE_ITEM),
        MEMORY_WORK_ITEM,
        "Work Item");

    IpxDereferenceDevice(Device, DREF_BINDING); 

    // DbgPrint("!!!!!!! 3. Done with IpxDelayedFreeBindingsArray ----------\n"); 

} /* IpxDelayedFreeBindingsArray */

#ifdef _PNP_POWER_

//++
//  IpxPnPEventHandler
//  * called from NDIS.
//  * We return STATUS_PENDING and perform the work on a WorkerThread
//
//  IN: ProtocolBindingContext and NetPnpEvent.
//  OUT: NTSTATUS
//--

NDIS_STATUS

IpxPnPEventHandler(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNET_PNP_EVENT NetPnPEvent
    )
{

    PNetPnPEventReserved    Reserved;
    CTEEvent                *Event;
    int                     i;
    PVOID                   Temp;

    Reserved = CTEAllocMem (sizeof(NetPnPEventReserved));

    if (NULL == Reserved) {
        
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    
    RtlZeroMemory(Reserved, sizeof(NetPnPEventReserved));

    *((PNetPnPEventReserved *)NetPnPEvent->TransportReserved) = Reserved;


    Event = CTEAllocMem( sizeof(CTEEvent) );

    if ( Event ) {

        CTEInitEvent(Event, IpxDoPnPEvent);
        Reserved->ProtocolBindingContext = ProtocolBindingContext;
        Reserved->Context1 = NULL;
        Reserved->Context2 = NULL;
        Reserved->State = NONE_DONE;

        for(i = 0; i < 3; i++) {

            Reserved->Status[i] = STATUS_SUCCESS;

        }

        CTEScheduleEvent(Event, NetPnPEvent);
        return STATUS_PENDING;
    } else {

        CTEFreeMem(Reserved);
        return STATUS_INSUFFICIENT_RESOURCES;
    
    }

}

//** IpxDoPnPEvent - Handles PNP/PM events.
//
//  Called from the worker thread event scheduled by IPPnPEvent
//  bWe take action depending on the type of the event.
//
//  Entry:
//      Context - This is a pointer to a NET_PNP_EVENT that describes
//                the PnP indication.
//
//  Exit:
//      None.
//
void
IpxDoPnPEvent(
    IN CTEEvent *WorkerThreadEvent,
    IN PVOID Context)
{

    PNET_PNP_EVENT  NetPnPEvent = (PNET_PNP_EVENT) Context;
    UNICODE_STRING  DeviceName;
    UNICODE_STRING  PDO_Name, *TempStr;
    NDIS_HANDLE     ProtocolBindingContext;
    PNetPnPEventReserved    Reserved;
    PDEVICE         Device = IpxDevice;
    INT             i;
    PTDI_PNP_CONTEXT Context1, Context2;
    PADAPTER        Adapter;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)

    CTEFreeMem(WorkerThreadEvent);

    //
    // Get the ProtocolBindingContext out
    //
    Reserved = *((PNetPnPEventReserved *) NetPnPEvent->TransportReserved);
    ProtocolBindingContext = Reserved->ProtocolBindingContext;
    
    Adapter = (PADAPTER)ProtocolBindingContext;


    //
    // Map protocol binding context to devicename
    //
    DeviceName.Buffer = Device->DeviceName;
    DeviceName.Length = (USHORT) Device->DeviceNameLength - sizeof(WCHAR);
    DeviceName.MaximumLength = (USHORT) Device->DeviceNameLength;


#ifdef _AUTO_RECONFIG_
    
    // 
    // If the Event is NetEventAutoReconfig, then we call IpxNcpaChanges that 
    // does all the dirty work.
    //

    if (NetPnPEvent->NetEvent == NetEventReconfigure) {

        //
        // If it is Reconfigure event, just ask ndis to
        // unbind/bind the the protocol
        // 
       NDIS_STATUS ReconfigStatus = NDIS_STATUS_NOT_ACCEPTED ;
       
       if ((ProtocolBindingContext == NULL)) {
            if (TRUE == IpxNcpaChanges(NetPnPEvent)) {
                IPX_DEBUG(PNP, ("IpxNcpaChanges : SUCCESS. \n"));
                ReconfigStatus = STATUS_SUCCESS;
             } else {
                IPX_DEBUG(PNP, ("IpxNcpaChanges : FAILED!! \n"));
                ReconfigStatus = STATUS_UNSUCCESSFUL;
            }
       }
       //
       // Need to unbind and bind the adapte.
       // 
       NdisCompletePnPEvent(
                    ReconfigStatus,
                    (Adapter != NULL) ? Adapter->NdisBindingHandle : NULL,
                    NetPnPEvent
                    );
       
       CTEFreeMem(Reserved);
       return;
    }

#endif _AUTO_RECONFIG_

    //
    // Map NDIS opcode to IPX's private OpCode for its clients.
    //

    IPX_DEBUG(PNP,("IPX: PNP_EVENT: %x\n", NetPnPEvent->NetEvent));

    switch (NetPnPEvent->NetEvent) {
    case NetEventQueryRemoveDevice:
        Reserved->OpCode = IPX_PNP_QUERY_REMOVE;
        break;
    case NetEventCancelRemoveDevice:
        Reserved->OpCode = IPX_PNP_CANCEL_REMOVE;
        break;
    case NetEventQueryPower:
        Reserved->OpCode = IPX_PNP_QUERY_POWER;
        break;
    case NetEventSetPower:
        Reserved->OpCode = IPX_PNP_SET_POWER;
        break;
    case NetEventBindsComplete:
        
        {
            BOOLEAN Ready = FALSE;

            //
            // That's it - no more Init time adapters are
            // going to get bound to IPX.
            //
            IPX_GET_LOCK(&Device->Lock, &LockHandle);
            
            Device->NoMoreInitAdapters = TRUE;
            
            if (0 == --Device->InitTimeAdapters) {
                Ready = TRUE;
            }

            IPX_FREE_LOCK(&Device->Lock, LockHandle);

            if (Ready) {

                NTSTATUS ntstatus;

                IPX_DEBUG(PNP, ("IPX : Calling Provider Ready\n"));

                ntstatus = TdiProviderReady(Device->TdiProviderReadyHandle);

                //
                // TdiProviderReady is guaranteed to be synch with nothing apart from success.
                //
                NdisCompletePnPEvent(
                                     ntstatus,
                                     (Adapter != NULL) ? Adapter->NdisBindingHandle : NULL,
                                     NetPnPEvent
                                     );

                IPX_DEBUG(PNP, ("NdisComplete called with %x\n", ntstatus));
                
                CTEFreeMem(Reserved);

                return;

            } else {

                CTEAssert(NULL == Device->NetPnPEvent);
                
                Device->NetPnPEvent = NetPnPEvent;

                IPX_DEBUG(PNP, ("The count is %d - someone else is going to call Ndis' completion \n", Device->InitTimeAdapters));

            }

            return;
        }        
        
        break;

    default:
        IPX_DEBUG(PNP,("IPX: IpxDoPnPEvent: Unhandled NETPNP_CODE!! - %x\n", NetPnPEvent->NetEvent));
        
        NdisCompletePnPEvent(
                    STATUS_SUCCESS,
                    (Adapter != NULL) ? Adapter->NdisBindingHandle : NULL,
                    NetPnPEvent
                    );

        CTEFreeMem(Reserved);

        return;

    }

    
    CTEAssert(ProtocolBindingContext != NULL);
    
    //
    // We are passing in the PDO's name too
    //
    RtlInitUnicodeString(&PDO_Name, ((PADAPTER)ProtocolBindingContext)->AdapterName);

    //
    // IPX exports one device, so this is all we have to do.
    //
    Context1 = IpxAllocateMemory(
                                 sizeof(TDI_PNP_CONTEXT) + sizeof (UNICODE_STRING) + PDO_Name.MaximumLength,
                                 MEMORY_ADAPTER,
                                 "Adapter Name"
                                 );
    
    if (NULL != Context1) {
        
        Context2 = IpxAllocateMemory(
                                     sizeof(TDI_PNP_CONTEXT),
                                     MEMORY_ADAPTER,
                                     "Last Adapter"
                                     );

        if (NULL != Context2) {

            //
            // We've gotten the resources and are now making the call
            // to tdi for sure.
            //
            Context1->ContextType = TDI_PNP_CONTEXT_TYPE_IF_NAME;
            Context1->ContextSize = sizeof(UNICODE_STRING) + PDO_Name.MaximumLength;
            TempStr = (PUNICODE_STRING) Context1->ContextData;
            TempStr->Length = 0;
            TempStr->MaximumLength = PDO_Name.MaximumLength;
            TempStr->Buffer = (PWCHAR) ((PUCHAR) Context1->ContextData) + 2 * sizeof(USHORT);
            RtlCopyUnicodeString(TempStr, &PDO_Name);
            
            Context2->ContextType = TDI_PNP_CONTEXT_TYPE_FIRST_OR_LAST_IF;
            Context2->ContextSize = sizeof(UCHAR);
            // Check if first or last device
            if (Device->ValidBindings == 1) {
                Context2->ContextData[1] = TRUE;
            } else {
                Context2->ContextData[1] = FALSE;
            }
            
            Reserved->Context1 = Context1;
            Reserved->Context2 = Context2;

            IPX_DEBUG(PNP, ("Calling Tdipnppowerrequest: Context1:%lx, Context2:%lx, Adapter:%lx\n",
                     Context1,
                     Context2,
                     Reserved->ProtocolBindingContext));
        } else {

            IpxFreeMemory (
               Context1,
               sizeof(TDI_PNP_CONTEXT) + sizeof (UNICODE_STRING) + PDO_Name.MaximumLength,
               MEMORY_ADAPTER,
               "Adapter Name"
               );
    


            NdisCompletePnPEvent(
                                 STATUS_INSUFFICIENT_RESOURCES,
                                 (Adapter != NULL) ? Adapter->NdisBindingHandle : NULL,
                                 NetPnPEvent
                                 );

	    CTEFreeMem(Reserved);
	    
	    return ;


        }

    } else {

        NdisCompletePnPEvent(
                     STATUS_INSUFFICIENT_RESOURCES,
                     (Adapter != NULL) ? Adapter->NdisBindingHandle : NULL,
                     NetPnPEvent
                     );

	CTEFreeMem(Reserved);

	return;

    }

    //
    // First we call the three Upper Drivers bound to IPX: RIP, SPX and NB.
    // The private interface with SPX, RIP and NB is synchronous.
    // Then we call TDI.
    //

    // Nota Bene: RIP doesnt have a PNP Handler

    if ((Device->UpperDriverBound[IDENTIFIER_SPX]) && (*Device->UpperDrivers[IDENTIFIER_SPX].PnPHandler)) {
        
        IPX_DEBUG(PNP,("Calling PnPEventHandler of SPX\n"));
        
        Reserved->Status[0] = (*Device->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
                                                    Reserved->OpCode,
                                                    NetPnPEvent
                                                    );

    } else {

        Reserved->Status[0] = STATUS_SUCCESS;

    }

    if (STATUS_PENDING != Reserved->Status[0]) {
        
        IpxPnPCompletionHandler(NetPnPEvent,
                               Reserved->Status[0]
                               );

    } else {
       IPX_DEBUG(PNP,("SPX PnPHandler returned STATUS_PENDING on event %p.\n", NetPnPEvent)); 
    }
    
}

VOID
IpxPnPCompletionHandler(
                       IN PNET_PNP_EVENT NetPnPEvent,
                       IN NTSTATUS       Status
                       )
{
    
    PNetPnPEventReserved    Reserved;
    PDEVICE         Device = IpxDevice;
    INT i;
    PADAPTER       Adapter;

    //
    // Get the ProtocolBindingContext out
    //
    ASSERT(Status != STATUS_PENDING); 

    Reserved = *((PNetPnPEventReserved *) NetPnPEvent->TransportReserved);

    IPX_DEBUG(PNP, ("PNP Completion Handler: State: %d  Context1:%lx, Context2:%lx, Adapter:%lx\n",
         Reserved->State,
         Reserved->Context1,
         Reserved->Context2,
         Reserved->ProtocolBindingContext));

    Adapter = (PADAPTER)Reserved->ProtocolBindingContext;

    switch (Reserved->State) {
    
    case NONE_DONE:
        
        IPX_DEBUG(PNP, ("SPX is Complete\n"));

	Reserved->Status[0] = Status; 

        Reserved->State = SPX_DONE;
        
        IPX_DEBUG(PNP, ("PNP Completion Handler: State: %d  Context1:%lx, Context2:%lx, Adapter:%lx\n",
                 Reserved->State,
                 Reserved->Context1,
                 Reserved->Context2,
                 Reserved->ProtocolBindingContext));


        if ((Device->UpperDriverBound[IDENTIFIER_NB]) && (*Device->UpperDrivers[IDENTIFIER_NB].PnPHandler)) {
            IPX_DEBUG(PNP,("Calling PnPEventHandler of NB\n"));
            Reserved->Status[1] = (*Device->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
                                                                                     Reserved->OpCode,
                                                                                     NetPnPEvent
                                                                                     );
            if (Reserved->Status[1] == STATUS_PENDING) {
                
                break;

            } else {

	       Reserved->State = NB_DONE; 

	    }


        } else {
	   
            IPX_DEBUG(PNP, ("NB's handlers arent around, we jump to the next call \n"));

	    Reserved->Status[1] = STATUS_SUCCESS; 

	    Reserved->State = NB_DONE;

        }
        
	// fall through

    case SPX_DONE:
        
        IPX_DEBUG(PNP,("NB is Complete\n"));

	if (Reserved->State == SPX_DONE) {
             
	   // Previous NbiPnPNotification returned pending, we are here because
	   // Tdi is calling this completion routine. 

	   Reserved->Status[1] = Status; 
	   Reserved->State = NB_DONE;
	
	}

	ASSERT(Reserved->State == NB_DONE); 


        IPX_DEBUG(PNP,("Calling Tdipnppowerrequest: Context1:%lx, Context2:%lx, Adapter:%lx\n",
                 Reserved->Context1,
                 Reserved->Context2,
                 Reserved->ProtocolBindingContext));

#ifdef DBG
        if (Reserved->Status[0] == STATUS_PENDING) {
            DbgPrint("!!!!! Before calling TdiPnPPowerRequest: Reserved->Status[0] = STATUS_PENDING\n"); 
        } 
#endif 

        Reserved->Status[2] = TdiPnPPowerRequest(
                                       &IpxDeviceName,
                                       NetPnPEvent,
                                       Reserved->Context1,
                                       Reserved->Context2,
                                       IpxPnPCompletionHandler
                                       );


        IPX_DEBUG(PNP,("Status[2] = %lx\n", Reserved->Status[2])); 

        if (STATUS_PENDING == Reserved->Status[2]) {

            break;

        } else {

            IPX_DEBUG(PNP,("TDI did not return pending, so we are done\n"));

	    Reserved->State = ALL_DONE;

        }

	// fall through

    case NB_DONE:

        IPX_DEBUG(PNP,("NB is Done\n"));

	if (Reserved->State == NB_DONE) {

	   Reserved->Status[2] = Status; 
	   Reserved->State = ALL_DONE;

	}

	ASSERT(Reserved->State == ALL_DONE); 

        IPX_DEBUG(PNP,("PNP Completion Handler: State: %d  Context1:%lx, Context2:%lx, Adapter:%lx\n",
             Reserved->State,
             Reserved->Context1,
             Reserved->Context2,
             Reserved->ProtocolBindingContext));
    
        IpxFreeMemory (
                   Reserved->Context1,
                   sizeof(TDI_PNP_CONTEXT) + Reserved->Context1->ContextSize,
                   MEMORY_ADAPTER,
                   "Adapter Name"
                   );
    
        IpxFreeMemory (
                   Reserved->Context2,
                   sizeof(TDI_PNP_CONTEXT),
                   MEMORY_ADAPTER,
                   "Last Adapter"
                   );
    
        for (i = 0; i < 3; i++) {
            if (STATUS_SUCCESS != Reserved->Status[i]) {
	       
	       ASSERT(Reserved->Status[i] != STATUS_PENDING); 

	       NdisCompletePnPEvent(
		  Reserved->Status[i],
          (Adapter != NULL) ? Adapter->NdisBindingHandle : NULL,
		  NetPnPEvent
		  );
	       CTEFreeMem(Reserved);
    
	       return;
	    }
        }
    
        NdisCompletePnPEvent(
                             STATUS_SUCCESS,
                             (Adapter != NULL) ? Adapter->NdisBindingHandle : NULL,
                             NetPnPEvent
                             );
        CTEFreeMem(Reserved);
    
        return;

    default:
        
        //CTEAssert(FALSE);
        break;
    
    }

}

#ifdef _AUTO_RECONFIG_

//
// When IPX gets a AUTO_RECONFIG structure from NCPA (via NDIS), it
// checks if there are any changes. If there are changes, it does the
// BindAdapter shenanigan.
// 
// Input: the PVOID in the NET_PNP structure
//        if the protocolbindingcontext is NULL, it is global reconfig.
// Output: BOOLEAN; if the auto_reconfig was a success/failure
// 

BOOLEAN 
IpxNcpaChanges(
               PNET_PNP_EVENT NetPnPEvent
               )
{
   PDEVICE        Device = IpxDevice;
   PRECONFIG      ReconfigBuffer;
   UINT           ReConfigBufferLength;
   BOOLEAN        ReBindAdapter;
   NDIS_HANDLE    ProtocolBindingContext;
   PNetPnPEventReserved    Reserved;
   PADAPTER       Adapter;
   NTSTATUS       NtStatus;
   CONFIG         Config;
   PBINDING	      Binding;
   BINDING_CONFIG	ConfigBinding;
   INT              i;
   PLIST_ENTRY      p = NULL;
   PREQUEST         Request = NULL;
   void * PNPContext; 
   IPX_DEFINE_LOCK_HANDLE (OldIrq)

   CTEAssert(NetPnPEvent != NULL);
   
   //
   // Get the ProtocolBindingContext out
   //
   
   Reserved = *((PNetPnPEventReserved *) NetPnPEvent->TransportReserved);
   ProtocolBindingContext = Reserved->ProtocolBindingContext;
   Adapter = (PADAPTER) ProtocolBindingContext;
   
   //
   // Get the Buffer out
   //
   Device               =  IpxDevice;
   ReconfigBuffer       =  (RECONFIG *) NetPnPEvent->Buffer;
   ReConfigBufferLength =  NetPnPEvent->BufferLength;

   //
   // Bug 96509, NCPA might give us NULL reconfig buffers (NOPs)
   //
   if ((ReConfigBufferLength == 0) || (NULL == ReconfigBuffer)) {
       IPX_DEBUG(PNP, ("The Reconfig Buffer is NULL!\n"));
       return TRUE;
   }
   //
   // We know where to lookup the parameters.
   //
   Config.DriverObject = (PDRIVER_OBJECT)Device->DeviceObject;
   Config.RegistryPathBuffer = Device->RegistryPathBuffer;

   // 
   // Could be global reconfig.
   // For IPX, this means that our Internal Network Number has changed.
   //
      if (NULL == ProtocolBindingContext) {
         
         if (ReconfigBuffer->VirtualNetworkNumber) {
   
          //
          // Read the registry to see if a virtual network number ap
          //
          NtStatus = IpxPnPGetVirtualNetworkNumber(&Config);
         
          if (Config.Parameters[CONFIG_VIRTUAL_NETWORK] == REORDER_ULONG(Device->VirtualNetworkNumber)) {
             
             IPX_DEBUG(PNP, ("The Net Number is the same!!\n"));
          
          } else { // The net number has changed. do something special if it is zero ?
             
             IPX_DEBUG(PNP, ("The Net Numbers are different: %x <-> %x\n", Config.Parameters[CONFIG_VIRTUAL_NETWORK], REORDER_ULONG(Device->VirtualNetworkNumber) ));
   
             Device->VirtualNetworkNumber = REORDER_ULONG(Config.Parameters[CONFIG_VIRTUAL_NETWORK]);
             
             if (IpxNewVirtualNetwork(Device, TRUE)) {
                

                IPX_DEBUG(PNP, ("SPX has been informed about the change in Network Number\n"));
             
             } else {
                
                IPX_DEBUG(PNP, ("SPX has NOT been informed about the change in Network Number\n"));
             }

             IPX_DEBUG(PNP, ("Telling RTR Manager that the internal net number has changed.\n"));

             if (Device->ForwarderBound && ((p = ExInterlockedRemoveHeadList(
                                                                            &Device->NicNtfQueue,
                                                                            &Device->Lock)) != NULL))
             {
                 PNWLINK_ACTION     NwlinkAction = NULL;
                 PIPX_NICS          pNics = NULL;
                 ULONG              BufferLength = 0;
                 
                 Request = LIST_ENTRY_TO_REQUEST(p);

                 IPX_DEBUG(PNP,("Ipxpnphandler: Netnum has changed\n"));

                 //
                 // Get the Buffer out. 
                 // 
                 NdisQueryBufferSafe (REQUEST_NDIS_BUFFER(Request), (PVOID *)&NwlinkAction, &BufferLength, HighPagePriority);
                     
                 if (NULL == NwlinkAction) {
                     DbgPrint("The IRP has a NULL buffer\n");
		     return FALSE; 
                 }

                 pNics = (PIPX_NICS)(NwlinkAction->Data);

                 //
                 // 0, 0 means that Internal network number has changed.
                 //

                 pNics->NoOfNics = 0;
                 pNics->TotalNoOfNics = 0;

                 IoAcquireCancelSpinLock(&OldIrq);
                 IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
                 IoReleaseCancelSpinLock(OldIrq);

                 REQUEST_STATUS(Request) = STATUS_SUCCESS;
                 IpxCompleteRequest (Request);
                 IpxFreeRequest (Device, Request);
                 IpxDereferenceDevice (Device, DREF_NIC_NOTIFY);
                 IPX_DEBUG(PNP,("GetNewNics returned SUCCESS (RTR Manager has been informed\n"));
          
             } else {
                 IPX_DEBUG(PNP,("No IRPs pending - couldnt tell the forwarder about the change in NetNum\n"));
                 //DbgBreakPoint();
             }
          }
          
          return TRUE;
         
         } else {
             
             KdPrint(("NULL ADAPTER context AND Not a Virtual Network number!!\n"));
             return FALSE;
         
         }
      }
   //
   // Otherwise, It is for an adapter.
   //
   ASSERT(Adapter != NULL);
   
   //
   // Used for error logging
   //
   
   ConfigBinding.AdapterName.Buffer = IpxAllocateMemory(
                                                        Adapter->AdapterNameLength+1,
                                                        MEMORY_ADAPTER,
                                                        "Adapter Name"
							);
                                                           
   ConfigBinding.AdapterName.Length = 0; 

   if (ConfigBinding.AdapterName.Buffer == NULL) {
      
      DbgPrint("IPX:IpxNcpaChanges:Failed to allocate buffer for adapter name.\n"); 
      ConfigBinding.AdapterName.MaximumLength = 0; 
      return FALSE; 

   } else {
      
      ConfigBinding.AdapterName.MaximumLength = (USHORT) Adapter->AdapterNameLength+1;
      RtlAppendUnicodeToString(&ConfigBinding.AdapterName, Adapter->AdapterName);
   
   }
   
   // NetCfg should not trigger a reconfigure event if no properties have changed. 

   // Do we really need to do a Bindadapter again?
   // Maybe we can get away with something smaller/
   //

   PNPContext = Adapter->PNPContext; 

   IpxUnbindAdapter(&NtStatus,
		    Adapter,
		    NULL
		    );
   if (NtStatus != STATUS_SUCCESS) {
      
      IPX_DEBUG(PNP, ("IpxUnbindAdapter return error!! %x\n", NtStatus));
      IpxFreeMemory (
	 ConfigBinding.AdapterName.Buffer,
	 ConfigBinding.AdapterName.MaximumLength,
	 MEMORY_ADAPTER,
	 "Adapter Name"
	 );
               
      return FALSE;

   } else {

      IpxBindAdapter(
	 &NtStatus,
	 NULL,
	 &ConfigBinding.AdapterName,
	 NULL,
	 PNPContext
	 );

      IpxFreeMemory (
	 ConfigBinding.AdapterName.Buffer,
	 ConfigBinding.AdapterName.MaximumLength,
	 MEMORY_ADAPTER,
	 "Adapter Name"
	 );
		  
      if (NtStatus != STATUS_SUCCESS) {
                  
	 IPX_DEBUG(PNP, ("IpxBindAdapter return error!! %x\n", NtStatus));
		 
	 return FALSE;
		  
      } else {
	 
	 IPX_DEBUG(PNP, ("Unbind/Bind SUCCESS. NCPA changes made!!\n"));
	 
	 return TRUE;
      
      }
   }
}



#endif // _AUTO_RECONFIG_


#endif // _PNP_POWER_


#if	TRACK

KSPIN_LOCK  ALock = 0;
#define MAX_PTR_COUNT   2048

struct _MemPtr
{
    PVOID   Ptr;
    ULONG   Size;
    ULONG   ModLine;
    ULONG   Tag;
} IpxMemPtrs[MAX_PTR_COUNT] = { 0 };

PVOID
IpxAllocateMemoryTrack(
    IN ULONG Size,
    IN ULONG Tag,
    IN ULONG ModLine
    )
{
    PVOID   p;

    p = ExAllocatePoolWithTag(NonPagedPool, Size, Tag);

    if (p != NULL)
    {
        KIRQL   OldIrql;
        UINT    i;

		KeAcquireSpinLock(&ALock, &OldIrql);

        for (i = 0; i < MAX_PTR_COUNT; i++)
        {
            if (IpxMemPtrs[i].Ptr == NULL)
            {
                IpxMemPtrs[i].Ptr = p;
                IpxMemPtrs[i].Size = Size;
                IpxMemPtrs[i].ModLine = ModLine;
                IpxMemPtrs[i].Tag = Tag;
                break;
            }
        }

        KeReleaseSpinLock(&ALock, OldIrql);
    }

    return(p);
}


VOID
IpxFreeMemoryTrack(
    IN PVOID Memory
    )

{
    KIRQL   OldIrql;
    UINT    i;

    KeAcquireSpinLock(&ALock, &OldIrql);

    for (i = 0; i < MAX_PTR_COUNT; i++)
    {
        if (IpxMemPtrs[i].Ptr == Memory)
        {
            IpxMemPtrs[i].Ptr = NULL;
            IpxMemPtrs[i].Size = 0;
            IpxMemPtrs[i].ModLine = 0;
            IpxMemPtrs[i].Tag = 0;
        }
    }

    KeReleaseSpinLock(&ALock, OldIrql);

    ExFreePool(Memory);
}

#endif	TRACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\config.c ===
/*++


Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    config.c

Abstract:

    This contains all routines necessary for the support of the dynamic
    configuration of the ISN IPX module.

Revision History:

   Sanjay Anand (SanjayAn) 19-Sept-1995
   Changes to support Plug and Play

--*/

#include "precomp.h"
#pragma hdrstop


//
// Local functions used to access the registry.
//

NTSTATUS
IpxGetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
IpxGetBindingValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
IpxGetFrameType(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
IpxAddBind(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
IpxAddExport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
IpxReadLinkageInformation(
    IN PCONFIG Config
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,IpxGetConfiguration)
#pragma alloc_text(INIT,IpxFreeConfiguration)

#pragma alloc_text(INIT,IpxAddBind)
#pragma alloc_text(INIT,IpxAddExport)
#pragma alloc_text(INIT,IpxReadLinkageInformation)
#endif
#define MAX_PATH 260


NTSTATUS
IpxGetConfiguration (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PCONFIG * ConfigPtr
    )

/*++

Routine Description:

    This routine is called by IPX to get information from the configuration
    management routines. We read the registry, starting at RegistryPath,
    to get the parameters. If they don't exist, we use the defaults
    set in ipxcnfg.h file. A list of adapters to bind to is chained
    on to the config information.

Arguments:

    DriverObject - Used for logging errors.

    RegistryPath - The name of IPX's node in the registry.

    ConfigPtr - Returns the configuration information.

Return Value:

    Status - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/

{
    PWSTR RegistryPathBuffer;
    PCONFIG Config;
    RTL_QUERY_REGISTRY_TABLE QueryTable[CONFIG_PARAMETERS+2];
    NTSTATUS Status;
    ULONG Zero = 0;
    ULONG One = 1;
    ULONG Five = 5;
    ULONG Eight = 8;
    ULONG Ten = 10;
    ULONG Fifteen = 15;
    ULONG Fifty = 50;
    ULONG DefaultSocketStart = 0x4000;
    ULONG DefaultSocketEnd = 0x8000;
    ULONG RipSegments = RIP_SEGMENTS;
    PWSTR Parameters = L"Parameters";
    struct {
        PWSTR KeyName;
        PULONG DefaultValue;
    } ParameterValues[CONFIG_PARAMETERS] = {
        { L"DedicatedRouter",      &Zero } ,
        { L"InitDatagrams",        &Ten } ,
        { L"MaxDatagrams",         &Fifty } ,
        { L"RipAgeTime",           &Five } ,    //  minutes
        { L"RipCount",             &Five } ,
        { L"RipTimeout",           &One } ,     //  half-second
        { L"RipUsageTime",         &Fifteen } , //  minutes
        { L"SourceRouteUsageTime", &Ten } ,     //  minutes
        { L"SocketUniqueness",     &Eight } ,
        { L"SocketStart",          &DefaultSocketStart } ,
        { L"SocketEnd",            &DefaultSocketEnd } ,
        { L"VirtualNetworkNumber", &Zero } ,
        { L"MaxMemoryUsage",       &Zero } ,
        { L"RipTableSize",         &RipSegments } ,
        { L"VirtualNetworkOptional", &One } ,
        { L"EthernetPadToEven",    &One } ,
        { L"EthernetExtraPadding", &Zero } ,
        { L"SingleNetworkActive",  &Zero } ,
        { L"DisableDialoutSap",    &Zero } ,
        { L"DisableDialinNetbios", &One } ,
        { L"VerifySourceAddress",  &One } };

    UINT i;


    //
    // Allocate memory for the main config structure.
    //

    Config = IpxAllocateMemory (sizeof(CONFIG), MEMORY_CONFIG, "Config");
    if (Config == NULL) {
        IpxWriteResourceErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_RESOURCE_POOL,
            sizeof(CONFIG),
            MEMORY_CONFIG);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Config->DeviceName.Buffer = NULL;
    InitializeListHead (&Config->BindingList);
    Config->DriverObject = DriverObject;

    //
    // Read in the NDIS binding information.
    //
    // IpxReadLinkageInformation expects a null-terminated path,
    // so we have to create one from the UNICODE_STRING.
    //

    RegistryPathBuffer = (PWSTR)IpxAllocateMemory(RegistryPath->Length + sizeof(WCHAR),
                                                      MEMORY_CONFIG, "RegistryPathBuffer");
    if (RegistryPathBuffer == NULL) {
        IpxFreeConfiguration(Config);
        IpxWriteResourceErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_RESOURCE_POOL,
            RegistryPath->Length + sizeof(WCHAR),
            MEMORY_CONFIG);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlCopyMemory (RegistryPathBuffer, RegistryPath->Buffer, RegistryPath->Length);
    *(PWCHAR)(((PUCHAR)RegistryPathBuffer)+RegistryPath->Length) = (WCHAR)'\0';

    Config->RegistryPathBuffer = RegistryPathBuffer;

    //
    // Determine what name to export and who to bind to.
    //

    Status = IpxReadLinkageInformation (Config);
    if (Status != STATUS_SUCCESS) {

        //
        // It logged an error if it failed.
        //
        IpxFreeMemory (Config->RegistryPathBuffer,
                       RegistryPath->Length + sizeof(WCHAR),
                       MEMORY_CONFIG,
                       "RegistryPathBuffer");
        IpxFreeConfiguration(Config);
        return Status;
    }

    //
    // Read the per-transport (as opposed to per-binding)
    // parameters.
    //

    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Switch to the Parameters key below IPX
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Parameters;

    //
    // 2-14) Call IpxGetConfigValue for each of the keys we
    // care about.
    //

    for (i = 0; i < CONFIG_PARAMETERS; i++) {

        QueryTable[i+1].QueryRoutine = IpxGetConfigValue;
        QueryTable[i+1].Flags = 0;
        QueryTable[i+1].Name = ParameterValues[i].KeyName;
        QueryTable[i+1].EntryContext = UlongToPtr(i);
        QueryTable[i+1].DefaultType = REG_DWORD;
        QueryTable[i+1].DefaultData = (PVOID)(ParameterValues[i].DefaultValue);
        QueryTable[i+1].DefaultLength = sizeof(ULONG);

    }

    //
    // 15) Stop
    //

    QueryTable[CONFIG_PARAMETERS+1].QueryRoutine = NULL;
    QueryTable[CONFIG_PARAMETERS+1].Flags = 0;
    QueryTable[CONFIG_PARAMETERS+1].Name = NULL;


    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->RegistryPathBuffer,
                 QueryTable,
                 (PVOID)Config,
                 NULL);

    if (Status != STATUS_SUCCESS) {

        IpxFreeMemory (Config->RegistryPathBuffer,
                       RegistryPath->Length + sizeof(WCHAR),
                       MEMORY_CONFIG,
                       "RegistryPathBuffer");
        IpxFreeConfiguration(Config);

        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            905,
            Status,
            Parameters,
            0,
            NULL);
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

	//
    // For PnP, we need to keep this path around
    //

    *ConfigPtr = Config;

    return STATUS_SUCCESS;

}   /* IpxGetConfiguration */


VOID
IpxFreeConfiguration (
    IN PCONFIG Config
    )

/*++

Routine Description:

    This routine is called by IPX to get free any storage that was allocated
    by IpxGetConfiguration in producing the specified CONFIG structure.

Arguments:

    Config - A pointer to the configuration information structure.

Return Value:

    None.

--*/

{
    PLIST_ENTRY p;
    PBINDING_CONFIG Binding;

    while (!IsListEmpty (&Config->BindingList)) {
        p = RemoveHeadList (&Config->BindingList);
        Binding = CONTAINING_RECORD (p, BINDING_CONFIG, Linkage);
        IpxFreeMemory (Binding->AdapterName.Buffer, Binding->AdapterName.MaximumLength, MEMORY_CONFIG, "NameBuffer");
        IpxFreeMemory (Binding, sizeof(BINDING_CONFIG), MEMORY_CONFIG, "Binding");
    }

    if (Config->DeviceName.Buffer) {
        IpxFreeMemory (Config->DeviceName.Buffer, Config->DeviceName.MaximumLength, MEMORY_CONFIG, "DeviceName");
    }

    IpxFreeMemory (Config, sizeof(CONFIG), MEMORY_CONFIG, "Config");

}   /* IpxFreeConfiguration */


NTSTATUS
IpxGetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).

    ValueType - The type of the value (REG_DWORD -- ignored).

    ValueData - The data for the value.

    ValueLength - The length of ValueData (ignored).

    Context - A pointer to the CONFIG structure.

    EntryContext - The index in Config->Parameters to save the value.

Return Value:

    STATUS_SUCCESS

--*/

{
    PCONFIG Config = (PCONFIG)Context;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);
    UNREFERENCED_PARAMETER(ValueLength);

    if ((ValueType != REG_DWORD) || (ValueLength != sizeof(ULONG))) {

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            904,
            STATUS_INVALID_PARAMETER,
            ValueName,
            0,
            NULL);
        return STATUS_INVALID_PARAMETER;
    }
#ifdef SUNDOWN
     IPX_DEBUG (CONFIG, ("Config parameter %d, value %lx\n",
                            (ULONG_PTR)EntryContext, *(UNALIGNED ULONG *)ValueData));
     Config->Parameters[(ULONG_PTR)EntryContext] = *(UNALIGNED ULONG *)ValueData;
#else
     IPX_DEBUG (CONFIG, ("Config parameter %d, value %lx\n",
                            (ULONG)EntryContext, *(UNALIGNED ULONG *)ValueData));
     Config->Parameters[(ULONG)EntryContext] = *(UNALIGNED ULONG *)ValueData;
#endif

   
    

    return STATUS_SUCCESS;

}   /* IpxGetConfigValue */


NTSTATUS
IpxGetBindingValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the NetConfig\DriverNN
    node to set the per-binding values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).

    ValueType - The type of the value (REG_DWORD -- ignored).

    ValueData - The data for the value.

    ValueLength - The length of ValueData (ignored).

    Context - A pointer to the BINDING_CONFIG structure.

    EntryContext - The index in Binding->Parameters to save the value.

Return Value:

    STATUS_SUCCESS

--*/

{
    PBINDING_CONFIG Binding = (PBINDING_CONFIG)Context;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);
    UNREFERENCED_PARAMETER(ValueLength);

    if ((ValueType != REG_DWORD) || (ValueLength != sizeof(ULONG))) {

        IpxWriteGeneralErrorLog(
            (PVOID)Binding->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            903,
            STATUS_INVALID_PARAMETER,
            ValueName,
            0,
            NULL);
        return STATUS_INVALID_PARAMETER;
    }
#ifdef SUNDOWN
    IPX_DEBUG (CONFIG, ("Binding parameter %d, value %lx\n",
                            (ULONG_PTR)EntryContext, *(UNALIGNED ULONG *)ValueData));
    Binding->Parameters[(ULONG_PTR)EntryContext] = *(UNALIGNED ULONG *)ValueData;	
#else
    IPX_DEBUG (CONFIG, ("Binding parameter %d, value %lx\n",
                            (ULONG)EntryContext, *(UNALIGNED ULONG *)ValueData));
    Binding->Parameters[(ULONG)EntryContext] = *(UNALIGNED ULONG *)ValueData;
#endif

    
    

    return STATUS_SUCCESS;

}   /* IpxGetBindingValue */


NTSTATUS
IpxGetFrameType(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues.
    It is called for each of the entry in the "PktType" and
    "NetworkNumber" multi-strings for a given binding.

Arguments:

    ValueName - The name of the value ("PktType" or "NetworkNumber" -- ignored).

    ValueType - The type of the value (REG_MULTI_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - A pointer to the BINDING_CONFIG structure.

    EntryContext - A pointer to a count of multi-string entries.

Return Value:

    STATUS_SUCCESS

--*/

{
    PBINDING_CONFIG Binding = (PBINDING_CONFIG)Context;
    ULONG IntegerValue;
    PWCHAR Cur;
    PULONG Count = (PULONG)EntryContext;

    ASSERT(Binding->DriverObject != NULL); 

    if ((ValueType != REG_SZ) ||
        (*Count >= 4)) {

        IpxWriteGeneralErrorLog(
            (PVOID)Binding->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            903,
            STATUS_INVALID_PARAMETER,
            ValueName,
            0,
            NULL);
        return STATUS_INVALID_PARAMETER;
    }

    IntegerValue = 0;
    for (Cur = (PWCHAR)(ValueData); ; Cur++) {
        if (*Cur >= L'0' && *Cur <= L'9') {
            IntegerValue = (IntegerValue * 16) + (*Cur - L'0');
        } else if (*Cur >= L'A' && *Cur <= L'F') {
            IntegerValue = (IntegerValue * 16) + (*Cur - L'A' + 10);
        } else if (*Cur >= L'a' && *Cur <= L'f') {
            IntegerValue = (IntegerValue * 16) + (*Cur - L'a' + 10);
        } else {
            break;
        }
    }

    if (((PWCHAR)ValueName)[0] == L'P') {

        //
        // PktType. We map arcnet to 802_3 so the code around
        // here can assume there are only four packets type --
        // the frame type is ignored later for arcnet.
        //

        if ((IntegerValue > ISN_FRAME_TYPE_ARCNET) &&
            (IntegerValue != ISN_FRAME_TYPE_AUTO)) {

            IpxWriteGeneralErrorLog(
                (PVOID)Binding->DriverObject,
                EVENT_IPX_ILLEGAL_CONFIG,
                903,
                STATUS_INVALID_PARAMETER,
                ValueName,
                0,
                NULL);
            return STATUS_INVALID_PARAMETER;
        }

        IPX_DEBUG (CONFIG, ("PktType(%d) is %lx\n", *Count, IntegerValue));
        if (IntegerValue == ISN_FRAME_TYPE_ARCNET) {
            Binding->FrameType[*Count] = ISN_FRAME_TYPE_802_3;
        } else {
            Binding->FrameType[*Count] = IntegerValue;
        }

    } else {

        //
        // NetworkNumber
        //

        IPX_DEBUG (CONFIG, ("NetworkNumber(%d) is %d\n", *Count, IntegerValue));
        Binding->NetworkNumber[*Count] = IntegerValue;

    }

    ++(*Count);

    return STATUS_SUCCESS;

}   /* IpxGetFrameType */


NTSTATUS
IpxAddBind(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each piece of the "Bind" multi-string and
    saves the information in a Config structure. It
    also queries the per-binding information and stores it.

Arguments:

    ValueName - The name of the value ("Bind" -- ignored).

    ValueType - The type of the value (REG_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - A pointer to the Config structure.

    EntryContext - A pointer to a count of binds that is incremented.

Return Value:

    STATUS_SUCCESS

--*/

{
    PCONFIG Config = (PCONFIG)Context;
    PBINDING_CONFIG Binding;
    PULONG CurBindNum = ((PULONG)EntryContext);
    RTL_QUERY_REGISTRY_TABLE QueryTable[BINDING_PARAMETERS+4];
    ULONG FrameTypeCount, NetworkNumberCount;
    ULONG StringLoc;
    BOOLEAN AutoDetect;
    ULONG AutoDetectLoc;
    ULONG SlideCount;
    PWCHAR NameBuffer;
    NTSTATUS Status;
    BOOLEAN FrameTypeUsed[ISN_FRAME_TYPE_MAX];
    ULONG Zero = 0;
    ULONG One = 1;
    ULONG DefaultBindSap = 0x8137;
    ULONG DefaultAutoDetectType = ISN_FRAME_TYPE_802_2;
    WCHAR Subkey[MAX_PATH];// = L"Parameters\\Adapters\\12345678901234567890";
    PWSTR ValueDataWstr = (PWSTR)ValueData;
    struct {
        PWSTR KeyName;
        PULONG DefaultValue;
    } ParameterValues[BINDING_PARAMETERS] = {
        { L"MaxPktSize",       &Zero } ,
        { L"BindSap",          &DefaultBindSap } ,
        { L"DefaultAutoDetectType", &DefaultAutoDetectType } ,
        { L"SourceRouting",    &One } ,
        { L"SourceRouteDef",   &Zero } ,
        { L"SourceRouteBcast", &Zero } ,
        { L"SourceRouteMcast", &Zero } ,
        { L"EnableFuncaddr",   &One } ,
        { L"EnableWanRouter",  &One } };
    ULONG BindingPreference[ISN_FRAME_TYPE_MAX] = {
        ISN_FRAME_TYPE_802_2,
        ISN_FRAME_TYPE_802_3,
        ISN_FRAME_TYPE_ETHERNET_II,
        ISN_FRAME_TYPE_SNAP };

    UINT i, j, k;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);


    Binding = (PBINDING_CONFIG)IpxAllocateMemory (sizeof(BINDING_CONFIG), MEMORY_CONFIG, "Binding");
    if (Binding == NULL) {
        IpxWriteResourceErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_TRANSPORT_RESOURCE_POOL,
            sizeof(BINDING_CONFIG),
            MEMORY_CONFIG);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NameBuffer = (PWCHAR)IpxAllocateMemory (ValueLength, MEMORY_CONFIG, "NameBuffer");
    if (NameBuffer == NULL) {
        IpxFreeMemory (Binding, sizeof(BINDING_CONFIG), MEMORY_CONFIG, "Binding");
        IpxWriteResourceErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_TRANSPORT_RESOURCE_POOL,
            ValueLength,
            MEMORY_CONFIG);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory (NameBuffer, ValueData, ValueLength);
    Binding->AdapterName.Buffer = NameBuffer;
    Binding->AdapterName.Length = (USHORT)(ValueLength - sizeof(WCHAR));
    Binding->AdapterName.MaximumLength = (USHORT)ValueLength;

    Binding->DriverObject = Config->DriverObject;

    FrameTypeCount = 0;
    NetworkNumberCount = 0;

    //
    // The structure is allocated OK, insert it into the list.
    //

    InsertTailList (&Config->BindingList, &Binding->Linkage);
    ++(*CurBindNum);


    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Switch to the NetConfig\XXXX key below IPX
    //    (we construct the right name in Subkey,
    //    first scan back to find the \, then copy
    //    the rest over, including the final '\0').
    //

    StringLoc = (ValueLength / sizeof(WCHAR)) - 2;
    while (ValueDataWstr[StringLoc] != L'\\') {
        --StringLoc;
    }

    RtlCopyMemory(&Subkey, L"Parameters\\Adapters\\12345678901234567890", 40);
    RtlCopyMemory(&Subkey[20], &ValueDataWstr[StringLoc+1], ValueLength - ((StringLoc+1) * sizeof(WCHAR)));
    KdPrint(("Subkey:%ws\n", Subkey));

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Subkey;

    //
    // 2) Call IpxGetFrameType for each part of the
    // "PktType" multi-string.
    //

    QueryTable[1].QueryRoutine = IpxGetFrameType;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[1].Name = L"PktType";
    QueryTable[1].EntryContext = &FrameTypeCount;
    QueryTable[1].DefaultType = REG_NONE;

    //
    // 3) Call IpxGetFrameType for each part of the
    // "NetworkNumber" multi-string.
    //

    QueryTable[2].QueryRoutine = IpxGetFrameType;
    QueryTable[2].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[2].Name = L"NetworkNumber";
    QueryTable[2].EntryContext = &NetworkNumberCount;
    QueryTable[2].DefaultType = REG_NONE;

    //
    // 4-11) Call IpxGetBindingValue for each of the keys we
    // care about.
    //

    for (i = 0; i < BINDING_PARAMETERS; i++) {

        QueryTable[i+3].QueryRoutine = IpxGetBindingValue;
        QueryTable[i+3].Flags = 0;
        QueryTable[i+3].Name = ParameterValues[i].KeyName;
        QueryTable[i+3].EntryContext = UlongToPtr(i);
        QueryTable[i+3].DefaultType = REG_DWORD;
        QueryTable[i+3].DefaultData = (PVOID)(ParameterValues[i].DefaultValue);
        QueryTable[i+3].DefaultLength = sizeof(ULONG);

    }

    //
    // 12) Stop
    //

    QueryTable[BINDING_PARAMETERS+3].QueryRoutine = NULL;
    QueryTable[BINDING_PARAMETERS+3].Flags = 0;
    QueryTable[BINDING_PARAMETERS+3].Name = NULL;


    IPX_DEBUG (CONFIG, ("Read bind key for %ws (%ws)\n", ValueData, Subkey));

    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->RegistryPathBuffer,
                 QueryTable,
                 (PVOID)Binding,
                 NULL);

    if (Status != STATUS_SUCCESS) {

        //
        // The binding will get freed during cleanup.
        //

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            906,
            Status,
            Subkey,
            0,
            NULL);
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (FrameTypeCount == 0) {

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_NO_FRAME_TYPES,
            907,
            Status,
            Subkey + 10,
            0,
            NULL);
    }

    if (FrameTypeCount > NetworkNumberCount) {
        for (i = NetworkNumberCount; i <FrameTypeCount; i++) {
            Binding->NetworkNumber[i] = 0;
        }
    }
    Binding->FrameTypeCount = FrameTypeCount;

    //
    // Go through and eliminate duplicates from the frame
    // type array.
    //

    for (i = 0; i < Binding->FrameTypeCount; i++) {

        for (j = i+1; j < Binding->FrameTypeCount; j++) {

            if (Binding->FrameType[j] == Binding->FrameType[i]) {

                IPX_DEBUG (CONFIG, ("Frame types %d and %d identical\n", i, j));

                //
                // A duplicate, slide everything else down.
                //

                for (k = j+1; k < Binding->FrameTypeCount; k++) {
                    Binding->FrameType[k-1] = Binding->FrameType[k];
                    Binding->NetworkNumber[k-1] = Binding->NetworkNumber[k];
                }
                --Binding->FrameTypeCount;

                --j;   // so we check whoever just moved into this spot.
            }
        }
    }


    //
    // Mark all the explicitly configured frame types, and
    // see if we have to auto-detect.
    //

    for (i = 0; i < 4; i++) {
        FrameTypeUsed[i] = FALSE;
    }

    AutoDetect = FALSE;
    for (i = 0; i < Binding->FrameTypeCount; i++) {
        if (Binding->FrameType[i] == ISN_FRAME_TYPE_AUTO) {
            AutoDetectLoc = i;
            AutoDetect = TRUE;
        } else {
            Binding->AutoDetect[i] = FALSE;
            Binding->DefaultAutoDetect[i] = FALSE;
            FrameTypeUsed[Binding->FrameType[i]] = TRUE;
        }
    }

    if (!AutoDetect) {
        IPX_DEBUG (AUTO_DETECT, ("No bindings auto-detected\n"));
        return STATUS_SUCCESS;
    }

    //
    // Slide everything that is past the auto-detect point up
    // to the end.
    //

    SlideCount = Binding->FrameTypeCount - AutoDetectLoc - 1;
    for (j = 3; j > 3 - SlideCount; j--) {
        Binding->FrameType[j] = Binding->FrameType[j-(3-Binding->FrameTypeCount)];
        Binding->NetworkNumber[j] = Binding->NetworkNumber[j-(3-Binding->FrameTypeCount)];
        Binding->AutoDetect[j] = Binding->AutoDetect[j-(3-Binding->FrameTypeCount)];
        Binding->DefaultAutoDetect[j] = Binding->DefaultAutoDetect[j-(3-Binding->FrameTypeCount)];
    }

    //
    // Now fill in any frame types that are not hard-coded,
    // this will start at AutoDetectLoc and exactly fill up
    // the gap created when we slid things up above. We
    // first put the default auto-detect at the first spot.
    //

    if (!FrameTypeUsed[Binding->Parameters[BINDING_DEFAULT_AUTO_DETECT]]) {
        Binding->FrameType[AutoDetectLoc] = Binding->Parameters[BINDING_DEFAULT_AUTO_DETECT];
        Binding->NetworkNumber[AutoDetectLoc] = 0;
        Binding->AutoDetect[AutoDetectLoc] = TRUE;
        Binding->DefaultAutoDetect[AutoDetectLoc] = TRUE;
        ++AutoDetectLoc;
        FrameTypeUsed[Binding->Parameters[BINDING_DEFAULT_AUTO_DETECT]] = TRUE;
    }

    //
    // Now fill in the array, using the preference order in
    // the BindingPreference array (this comes into effect
    // because the first frame type in our list that we
    // find is used).
    //

    for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {

        if (!FrameTypeUsed[BindingPreference[i]]) {
            Binding->FrameType[AutoDetectLoc] = BindingPreference[i];
            Binding->NetworkNumber[AutoDetectLoc] = 0;
            Binding->AutoDetect[AutoDetectLoc] = TRUE;
            Binding->DefaultAutoDetect[AutoDetectLoc] = FALSE;
            ++AutoDetectLoc;
        }
    }

    Binding->FrameTypeCount = ISN_FRAME_TYPE_MAX;

#if DBG
    for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {
        IPX_DEBUG (AUTO_DETECT, ("%d: type %d, net %d, auto %d, defaultautodetect %d\n",
            i, Binding->FrameType[i], Binding->NetworkNumber[i], Binding->AutoDetect[i], Binding->DefaultAutoDetect[i]));
    }
#endif

    return STATUS_SUCCESS;

}   /* IpxAddBind */


NTSTATUS
IpxAddExport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each piece of the "Export" multi-string. It
    saves the first callback string in the Config structure.

Arguments:

    ValueName - The name of the value ("Export" -- ignored).

    ValueType - The type of the value (REG_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - A pointer to the Config structure.

    EntryContext - A pointer to a ULONG that goes to 1 after the
       first call to this routine (so we know to ignore other ones).

Return Value:

    STATUS_SUCCESS

--*/

{
    PCONFIG Config = (PCONFIG)Context;
    PULONG ValueReadOk = ((PULONG)EntryContext);
    PWCHAR NameBuffer;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);

    if (*ValueReadOk == 0) {

        IPX_DEBUG (CONFIG, ("Read export value %ws\n", ValueData));

        NameBuffer = (PWCHAR)IpxAllocateMemory (ValueLength, MEMORY_CONFIG, "DeviceName");
        if (NameBuffer == NULL) {
            IpxWriteResourceErrorLog(
                (PVOID)Config->DriverObject,
                EVENT_TRANSPORT_RESOURCE_POOL,
                ValueLength,
                MEMORY_CONFIG);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory (NameBuffer, ValueData, ValueLength);
        Config->DeviceName.Buffer = NameBuffer;
        Config->DeviceName.Length = (USHORT)(ValueLength - sizeof(WCHAR));
        Config->DeviceName.MaximumLength = (USHORT)ValueLength;

        //
        // Set this to ignore any other callbacks and let the
        // caller know we read something.
        //

        *ValueReadOk = 1;

    }

    return STATUS_SUCCESS;

}   /* IpxAddExport */


NTSTATUS
IpxReadLinkageInformation(
    IN PCONFIG Config
    )

/*++

Routine Description:

    This routine is called by IPX to read its linkage information
    from the registry.

Arguments:

    Config - The config structure which will have per-binding information
        linked on to it.

Return Value:

    The status of the operation.

--*/

{

    NTSTATUS Status;
    RTL_QUERY_REGISTRY_TABLE QueryTable[3];
    PWSTR Subkey = L"Linkage";
    PWSTR Bind = L"Bind";
    PWSTR Export = L"Export";
    ULONG ValueReadOk;

    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Switch to the Linkage key below IPX
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Subkey;

    //
    // 1) Call IpxAddExport for each string in "Export"
    //

    QueryTable[1].QueryRoutine = IpxAddExport;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[1].Name = Export;
    QueryTable[1].EntryContext = (PVOID)&ValueReadOk;
    QueryTable[1].DefaultType = REG_NONE;

    //
    // 2) Stop
    //

    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = NULL;


    ValueReadOk = 0;

    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->RegistryPathBuffer,
                 QueryTable,
                 (PVOID)Config,
                 NULL);

    if ((Status != STATUS_SUCCESS) || (ValueReadOk == 0)) {

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            901,
            Status,
            Export,
            0,
            NULL);
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    return STATUS_SUCCESS;

}   /* IpxReadLinkageInformation */


VOID
IpxWriteDefaultAutoDetectType(
    IN PUNICODE_STRING RegistryPath,
    IN struct _ADAPTER * Adapter,
    IN ULONG FrameType
    )

/*++

Routine Description:

    This routine is called when we were unable to detect the default
    auto-detect type and instead found a different one. We update
    the "DefaultAutoDetectType" in the registry.

Arguments:

    RegistryPath - The name of IPX's node in the registry.

    Adapter - The adapter which we auto-detected on.

    FrameType - The new auto-detected value.

Return Value:

    None.

--*/

{
    PWSTR FullRegistryPath;
    PUCHAR CurRegistryPath;
    ULONG FullRegistryPathLength;
    ULONG AdapterNameLength;
    WCHAR Adapters[] = L"\\Parameter\\Adapters\\";
    static PWCHAR FrameTypeNames[4] = { L"Ethernet II", L"802.3", L"802.2", L"SNAP" };
    PWCHAR CurAdapterName;
    NTSTATUS Status;


    //
    // We need to allocate a buffer which contains the registry path,
    // followed by "\Parameters\Adapters\", followed by the adapter name, and
    // then NULL-terminated.
    //

    CurAdapterName = &Adapter->AdapterName[(Adapter->AdapterNameLength/sizeof(WCHAR))-2];
    while (*CurAdapterName != L'\\') {
        --CurAdapterName;
    }

    // AdapterNameLength is unlikely to exceed 32-bit, RtlCopyMemory takes 32-bit only, so we cast it to ULONG
    AdapterNameLength = (ULONG) (Adapter->AdapterNameLength - ((CurAdapterName - Adapter->AdapterName) * sizeof(WCHAR)) - sizeof(WCHAR));

    FullRegistryPathLength = RegistryPath->Length + sizeof(Adapters) + AdapterNameLength;

    FullRegistryPath = (PWSTR)IpxAllocateMemory (FullRegistryPathLength, MEMORY_CONFIG, "FullRegistryPath");
    if (FullRegistryPath == NULL) {
        IpxWriteResourceErrorLog(
            IpxDevice->DeviceObject,
            EVENT_TRANSPORT_RESOURCE_POOL,
            FullRegistryPathLength,
            MEMORY_CONFIG);
        return;
    }

    CurRegistryPath = (PUCHAR)FullRegistryPath;
    RtlCopyMemory (CurRegistryPath, RegistryPath->Buffer, RegistryPath->Length);
    CurRegistryPath += RegistryPath->Length;
    RtlCopyMemory (CurRegistryPath, Adapters, sizeof(Adapters) - sizeof(WCHAR));
    CurRegistryPath += (sizeof(Adapters) - sizeof(WCHAR));
    RtlCopyMemory (CurRegistryPath, CurAdapterName, AdapterNameLength);
    CurRegistryPath += AdapterNameLength;
    *(PWCHAR)CurRegistryPath = L'\0';

    Status = RtlWriteRegistryValue(
                 RTL_REGISTRY_ABSOLUTE,
                 FullRegistryPath,
                 L"DefaultAutoDetectType",
                 REG_DWORD,
                 &FrameType,
                 sizeof(ULONG));

    IpxFreeMemory (FullRegistryPath, FullRegistryPathLength, MEMORY_CONFIG, "FullRegistryPath");

    IpxWriteGeneralErrorLog(
        IpxDevice->DeviceObject,
        EVENT_IPX_NEW_DEFAULT_TYPE,
        888,
        STATUS_SUCCESS,
        FrameTypeNames[FrameType],
        0,
        NULL);

}   /* IpxWriteDefaultAutoDetectType */


//
// Vnet# and VnetOptional
//
#define VIRTUAL_NETWORK_PARAMETERS  2

NTSTATUS
IpxPnPGetVirtualNetworkNumber (
    IN	PCONFIG	Config
    )

/*++

Routine Description:

    This routine is called by IPX to read the virtual network number
    from the registry. This is called on appearance/disappearance of an
    adapter from the system. We read the registry, starting at RegistryPath,
    to get the value of the VirtualNetworkNumber parameter. If it doesn't
    exist, we use the default set in ipxcnfg.h file.
	Adapted from IpxGetConfiguration().

Arguments:

    Config - Contians the configuration information.

Return Value:

    Status - STATUS_SUCCESS if everything OK, STATUS_DEVICE_CONFIGURATION_ERROR
            otherwise.

--*/

{
    RTL_QUERY_REGISTRY_TABLE QueryTable[VIRTUAL_NETWORK_PARAMETERS+2];
    NTSTATUS Status;
    ULONG Zero = 0;
    ULONG One = 1;
    PWSTR Parameters = L"Parameters";
    struct {
        PWSTR KeyName;
        PULONG DefaultValue;
    } ParameterValues[VIRTUAL_NETWORK_PARAMETERS] = {
        { L"VirtualNetworkNumber", &Zero } ,
        { L"VirtualNetworkOptional", &One } };
    UINT i;

    //
    // Read the virtual net number from the parameters.
    //

    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Switch to the Parameters key below IPX
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Parameters;

    //
    // 2) Call IpxGetConfigValue for the virtual net number key
    //

    QueryTable[1].QueryRoutine = IpxGetConfigValue;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = ParameterValues[0].KeyName;
    QueryTable[1].EntryContext = (PVOID)CONFIG_VIRTUAL_NETWORK;
    QueryTable[1].DefaultType = REG_DWORD;
    QueryTable[1].DefaultData = (PVOID)(ParameterValues[0].DefaultValue);
    QueryTable[1].DefaultLength = sizeof(ULONG);

    //
    // 2) Call IpxGetConfigValue for the virtual net optional key
    //

    QueryTable[2].QueryRoutine = IpxGetConfigValue;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = ParameterValues[1].KeyName;
    QueryTable[2].EntryContext = (PVOID)CONFIG_VIRTUAL_OPTIONAL;
    QueryTable[2].DefaultType = REG_DWORD;
    QueryTable[2].DefaultData = (PVOID)(ParameterValues[1].DefaultValue);
    QueryTable[2].DefaultLength = sizeof(ULONG);

    //
    // 15) Stop
    //

    QueryTable[3].QueryRoutine = NULL;
    QueryTable[3].Flags = 0;
    QueryTable[3].Name = NULL;


    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->RegistryPathBuffer,
                 QueryTable,
                 (PVOID)Config,
                 NULL);

    if (Status != STATUS_SUCCESS) {

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            905,
            Status,
            Parameters,
            0,
            NULL);
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    return STATUS_SUCCESS;

}   /* IpxPnPGetNetworkNumber */

#define IPX_REG_KEY_CONFIG_NAME L"Parameters\\Adapters\\12345678901234567890"
#define IPX_REG_KEY_CONFIG_DUMMY_LENGTH 40
#define IPX_REG_KEY_CONFIG_LENGTH 20


NTSTATUS
IpxPnPGetAdapterParameters(
	IN		PCONFIG			Config,
	IN		PNDIS_STRING	DeviceName,
	IN OUT	PBINDING_CONFIG	Binding
	)
/*++

Routine Description:

    This routine is called by IPX to read the adapter-specific parameters
    from the registry on PnP appearance of an adapter in the system.
	We read the registry, starting at RegistryPath\NetConfig\DeviceName.

	Adapted from IpxAddBind().

Arguments:

    Config - Config structure - supplies the DeviceObject and RegistryPathBuffer.

    DeviceName - name of the adapter that was added.

    Binding - Returns the configuration information per adapter.

Return Value:

    Status - STATUS_SUCCESS if everything OK, STATUS_DEVICE_CONFIGURATION_ERROR
            otherwise.

--*/
{
    RTL_QUERY_REGISTRY_TABLE QueryTable[BINDING_PARAMETERS+4];
    ULONG FrameTypeCount, NetworkNumberCount;
    ULONG StringLoc;
    BOOLEAN AutoDetect;
    ULONG AutoDetectLoc;
    ULONG SlideCount;
    PWCHAR NameBuffer;
    NTSTATUS Status;
    BOOLEAN FrameTypeUsed[ISN_FRAME_TYPE_MAX];
    ULONG Zero = 0;
    ULONG One = 1;
    ULONG DefaultBindSap = 0x8137;
    ULONG DefaultAutoDetectType = ISN_FRAME_TYPE_802_2;
    WCHAR Subkey[MAX_PATH];// = L"NetConfig\\12345678901234567890";
    struct {
        PWSTR KeyName;
        PULONG DefaultValue;
    } ParameterValues[BINDING_PARAMETERS] = {
        { L"MaxPktSize",       &Zero } ,
        { L"BindSap",          &DefaultBindSap } ,
        { L"DefaultAutoDetectType", &DefaultAutoDetectType } ,
        { L"SourceRouting",    &One } ,
        { L"SourceRouteDef",   &Zero } ,
        { L"SourceRouteBcast", &Zero } ,
        { L"SourceRouteMcast", &Zero } ,
        { L"EnableFuncaddr",   &One } ,
        { L"EnableWanRouter",  &One } };
    ULONG BindingPreference[ISN_FRAME_TYPE_MAX] = {
        ISN_FRAME_TYPE_802_2,
        ISN_FRAME_TYPE_802_3,
        ISN_FRAME_TYPE_ETHERNET_II,
        ISN_FRAME_TYPE_SNAP };

    UINT i, j, k;

    ASSERT(Binding->DriverObject != NULL); 
    
    FrameTypeCount = 0;
    NetworkNumberCount = 0;

    //
    // The structure is allocated OK, insert it into the list.
    //

//  InsertTailList (&Config->BindingList, &Binding->Linkage);
//  ++(*CurBindNum);


    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Switch to the NetConfig\XXXX key below IPX
    //    (we construct the right name in Subkey,
    //    first scan back to find the \, then copy
    //    the rest over, including the final '\0').
    //
    StringLoc = (DeviceName->Length / sizeof(WCHAR)) - 2;
    while (DeviceName->Buffer[StringLoc] != L'\\') {
        --StringLoc;
    }

    RtlCopyMemory(&Subkey, IPX_REG_KEY_CONFIG_NAME, IPX_REG_KEY_CONFIG_DUMMY_LENGTH);
    RtlCopyMemory(&Subkey[IPX_REG_KEY_CONFIG_LENGTH], &DeviceName->Buffer[StringLoc+1], DeviceName->Length - ((StringLoc+1) * sizeof(WCHAR)));
    
    Subkey[IPX_REG_KEY_CONFIG_LENGTH + (DeviceName->Length / sizeof (WCHAR)) - (StringLoc+1) ] = L'\0';
    
    IPX_DEBUG(CONFIG, ("Subkey:%ws\n", Subkey));
//RtlCopyMemory(&Subkey[10], &DeviceName->Buffer[StringLoc+1], DeviceName->MaximumLength - ((StringLoc+1) * sizeof(WCHAR)));

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Subkey;

    //
    // 2) Call IpxGetFrameType for each part of the
    // "PktType" multi-string.
    //

    QueryTable[1].QueryRoutine = IpxGetFrameType;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[1].Name = L"PktType";
    QueryTable[1].EntryContext = &FrameTypeCount;
    QueryTable[1].DefaultType = REG_NONE;

    //
    // 3) Call IpxGetFrameType for each part of the
    // "NetworkNumber" multi-string.
    //

    QueryTable[2].QueryRoutine = IpxGetFrameType;
    QueryTable[2].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[2].Name = L"NetworkNumber";
    QueryTable[2].EntryContext = &NetworkNumberCount;
    QueryTable[2].DefaultType = REG_NONE;

    //
    // 4-11) Call IpxGetBindingValue for each of the keys we
    // care about.
    //

    for (i = 0; i < BINDING_PARAMETERS; i++) {

        QueryTable[i+3].QueryRoutine = IpxGetBindingValue;
        QueryTable[i+3].Flags = 0;
        QueryTable[i+3].Name = ParameterValues[i].KeyName;
        QueryTable[i+3].EntryContext = UlongToPtr(i);
        QueryTable[i+3].DefaultType = REG_DWORD;
        QueryTable[i+3].DefaultData = (PVOID)(ParameterValues[i].DefaultValue);
        QueryTable[i+3].DefaultLength = sizeof(ULONG);

    }

    //
    // 12) Stop
    //

    QueryTable[BINDING_PARAMETERS+3].QueryRoutine = NULL;
    QueryTable[BINDING_PARAMETERS+3].Flags = 0;
    QueryTable[BINDING_PARAMETERS+3].Name = NULL;


    IPX_DEBUG (CONFIG, ("Read bind key for %ws (%ws)\n", DeviceName->Buffer, Subkey));

    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->RegistryPathBuffer,
                 QueryTable,
                 (PVOID)Binding,
                 NULL);

    if (Status != STATUS_SUCCESS) {

        //
        // The binding will get freed during cleanup.
        //

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            906,
            Status,
            Subkey,
            0,
            NULL);
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (FrameTypeCount == 0) {

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_NO_FRAME_TYPES,
            907,
            Status,
            Subkey + 10,
            0,
            NULL);
    }

    if (FrameTypeCount > NetworkNumberCount) {
        for (i = NetworkNumberCount; i <FrameTypeCount; i++) {
            Binding->NetworkNumber[i] = 0;
        }
    }
    Binding->FrameTypeCount = FrameTypeCount;

    //
    // Go through and eliminate duplicates from the frame
    // type array.
    //

    for (i = 0; i < Binding->FrameTypeCount; i++) {

        for (j = i+1; j < Binding->FrameTypeCount; j++) {

            if (Binding->FrameType[j] == Binding->FrameType[i]) {

                IPX_DEBUG (CONFIG, ("Frame types %d and %d identical\n", i, j));

                //
                // A duplicate, slide everything else down.
                //

                for (k = j+1; k < Binding->FrameTypeCount; k++) {
                    Binding->FrameType[k-1] = Binding->FrameType[k];
                    Binding->NetworkNumber[k-1] = Binding->NetworkNumber[k];
                }
                --Binding->FrameTypeCount;

                --j;   // so we check whoever just moved into this spot.
            }
        }
    }


    //
    // Mark all the explicitly configured frame types, and
    // see if we have to auto-detect.
    //

    for (i = 0; i < 4; i++) {
        FrameTypeUsed[i] = FALSE;
    }

    AutoDetect = FALSE;
    for (i = 0; i < Binding->FrameTypeCount; i++) {
        if ((Binding->FrameType[i] == ISN_FRAME_TYPE_AUTO)) {
            AutoDetectLoc = i;
            AutoDetect = TRUE;
        } else {
            Binding->AutoDetect[i] = FALSE;
            Binding->DefaultAutoDetect[i] = FALSE;
            FrameTypeUsed[Binding->FrameType[i]] = TRUE;
        }
    }

    if (!AutoDetect) {
        IPX_DEBUG (AUTO_DETECT, ("No bindings auto-detected\n"));
#if DBG
	for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {
	   IPX_DEBUG (AUTO_DETECT, ("%d: type %d, net %d, auto %d, default auto detect %d\n",
				    i, Binding->FrameType[i], Binding->NetworkNumber[i], Binding->AutoDetect[i], Binding->DefaultAutoDetect[i]));
	}
#endif
        return STATUS_SUCCESS;
    }

    //
    // Slide everything that is past the auto-detect point up
    // to the end.
    //

    //
    // Fixed this loop which can spill over if the FrameTypeCount is 4 and the SlideCount > 0.
    // Here, the FrameTypeCount is 1-based, whereas the indices are 0-based, we need to make
    // the index 1-based for this to work. So, instead of (3-Binding->FrameTypeCount), we use
    // (4-Binding->FrameTypeCount). This loop copies all the non-auto-detect frametypes down to
    // the bottom of the array to make space after the last auto-detect frame-type for filling
    // in the frametypes in the preference order.
    //
#if 0
    SlideCount = Binding->FrameTypeCount - AutoDetectLoc - 1;
    for (j = 3; j > 3 - SlideCount; j--) {
        Binding->FrameType[j] = Binding->FrameType[j-(3-Binding->FrameTypeCount)];
        Binding->NetworkNumber[j] = Binding->NetworkNumber[j-(3-Binding->FrameTypeCount)];
        Binding->AutoDetect[j] = Binding->AutoDetect[j-(3-Binding->FrameTypeCount)];
        Binding->DefaultAutoDetect[j] = Binding->DefaultAutoDetect[j-(3-Binding->FrameTypeCount)];
    }
#else
    SlideCount = Binding->FrameTypeCount - AutoDetectLoc - 1;
    for (j = 3; j > 3 - SlideCount; j--) {
        Binding->FrameType[j] = Binding->FrameType[j-(4-Binding->FrameTypeCount)];
        Binding->NetworkNumber[j] = Binding->NetworkNumber[j-(4-Binding->FrameTypeCount)];
        Binding->AutoDetect[j] = Binding->AutoDetect[j-(4-Binding->FrameTypeCount)];
        Binding->DefaultAutoDetect[j] = Binding->DefaultAutoDetect[j-(4-Binding->FrameTypeCount)];
    }
#endif

    //
    // Now fill in any frame types that are not hard-coded,
    // this will start at AutoDetectLoc and exactly fill up
    // the gap created when we slid things up above. We
    // first put the default auto-detect at the first spot.
    //

    if (!FrameTypeUsed[Binding->Parameters[BINDING_DEFAULT_AUTO_DETECT]]) {
        Binding->FrameType[AutoDetectLoc] = Binding->Parameters[BINDING_DEFAULT_AUTO_DETECT];
        Binding->NetworkNumber[AutoDetectLoc] = 0;
        Binding->AutoDetect[AutoDetectLoc] = TRUE;
        Binding->DefaultAutoDetect[AutoDetectLoc] = TRUE;
        ++AutoDetectLoc;
        FrameTypeUsed[Binding->Parameters[BINDING_DEFAULT_AUTO_DETECT]] = TRUE;
    }

    //
    // Now fill in the array, using the preference order in
    // the BindingPreference array (this comes into effect
    // because the first frame type in our list that we
    // find is used).
    //

    for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {

        if (!FrameTypeUsed[BindingPreference[i]]) {
            Binding->FrameType[AutoDetectLoc] = BindingPreference[i];
            Binding->NetworkNumber[AutoDetectLoc] = 0;
            Binding->AutoDetect[AutoDetectLoc] = TRUE;
            Binding->DefaultAutoDetect[AutoDetectLoc] = FALSE;
            ++AutoDetectLoc;
        }
    }

    Binding->FrameTypeCount = ISN_FRAME_TYPE_MAX;

#if DBG
    for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {
       IPX_DEBUG (AUTO_DETECT, ("%d: type %d, net %d, auto %d, default auto detect %d\n",
				i, Binding->FrameType[i], Binding->NetworkNumber[i], Binding->AutoDetect[i], Binding->DefaultAutoDetect[i]));
  }
#endif

    return STATUS_SUCCESS;
} /* IpxPnPGetAdapterParameters */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\config.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    config.h

Abstract:

    Private include file for the ISN IPX module.
    file defines all constants and structures necessary for support of
    the dynamic configuration of ST.

Revision History:

--*/


//
// These are used to index into the Parameters array in CONFIG.
//

#define CONFIG_DEDICATED_ROUTER  0
#define CONFIG_INIT_DATAGRAMS    1
#define CONFIG_MAX_DATAGRAMS     2
#define CONFIG_RIP_AGE_TIME      3
#define CONFIG_RIP_COUNT         4
#define CONFIG_RIP_TIMEOUT       5
#define CONFIG_RIP_USAGE_TIME    6
#define CONFIG_ROUTE_USAGE_TIME  7
#define CONFIG_SOCKET_UNIQUENESS 8
#define CONFIG_SOCKET_START      9
#define CONFIG_SOCKET_END       10
#define CONFIG_VIRTUAL_NETWORK  11
#define CONFIG_MAX_MEMORY_USAGE 12
#define CONFIG_RIP_TABLE_SIZE   13
#define CONFIG_VIRTUAL_OPTIONAL 14
#define CONFIG_ETHERNET_PAD     15
#define CONFIG_ETHERNET_LENGTH  16
#define CONFIG_SINGLE_NETWORK   17
#define CONFIG_DISABLE_DIALOUT_SAP 18
#define CONFIG_DISABLE_DIALIN_NB 19
#define CONFIG_VERIFY_SOURCE_ADDRESS 20

#define CONFIG_PARAMETERS       21

//
// Main configuration structure.
//

typedef struct _CONFIG {

    ULONG Parameters[CONFIG_PARAMETERS];  // index defined above
    NDIS_STRING DeviceName;               // device name exported
    PWSTR RegistryPathBuffer;             // path to config info
    ULONG BindCount;                      // entries in BindingList
    LIST_ENTRY BindingList;               // one per binding
    PDRIVER_OBJECT DriverObject;          // used for logging errors

} CONFIG, * PCONFIG;


//
// These are used to index into the Parameters array in BINDING_CONFIG.
//

#define BINDING_MAX_PKT_SIZE        0
#define BINDING_BIND_SAP            1
#define BINDING_DEFAULT_AUTO_DETECT 2
#define BINDING_SOURCE_ROUTE        3
#define BINDING_ALL_ROUTE_DEF       4
#define BINDING_ALL_ROUTE_BC        5
#define BINDING_ALL_ROUTE_MC        6
#define BINDING_ENABLE_FUNC_ADDR    7
#define BINDING_ENABLE_WAN          8

#define BINDING_PARAMETERS          9


//
// One of these is allocated per adapter we are to bind to.
//

typedef struct _BINDING_CONFIG {

    LIST_ENTRY Linkage;                   // for chaining on BindingList
    NDIS_STRING AdapterName;              // NDIS adapter to bind to
    ULONG FrameTypeCount;                 // number of frame types defined (max. 4)
                                          //  == number of valid entries in arrays:
    ULONG FrameType[ISN_FRAME_TYPE_MAX];  // ISN_FRAME_TYPE_XXX
    ULONG NetworkNumber[ISN_FRAME_TYPE_MAX]; // may be 0
    BOOLEAN AutoDetect[ISN_FRAME_TYPE_MAX]; // remove if net number can't be found
    BOOLEAN DefaultAutoDetect[ISN_FRAME_TYPE_MAX]; // use this if multiple or none found
    ULONG Parameters[BINDING_PARAMETERS]; // index defined above
    PDRIVER_OBJECT DriverObject;          // used for logging errors

} BINDING_CONFIG, * PBINDING_CONFIG;


NTSTATUS
IpxGetConfiguration (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PCONFIG * ConfigPtr
    );

VOID
IpxFreeConfiguration (
    IN PCONFIG Config
    );

VOID
IpxWriteDefaultAutoDetectType(
    IN PUNICODE_STRING RegistryPath,
    IN struct _ADAPTER * Adapter,
    IN ULONG FrameType
    );

NTSTATUS
IpxPnPGetVirtualNetworkNumber (
    IN	PCONFIG	Config
    );

NTSTATUS
IpxPnPGetAdapterParameters(
	IN		PCONFIG			Config,
	IN		PNDIS_STRING	DeviceName,
	IN OUT	PBINDING_CONFIG	Binding
	);

//
// Reconfig info from NCPA --> NDIS --> IPXPnPHandler
// We get a pointer to the RECONFIG Structure in the NET_PNP_EVENT Structure
// This structure is defined below - an array of BOOLEANs.
//

#define RECONFIG_AUTO_DETECT        1
#define RECONFIG_MANUAL             2
#define RECONFIG_PREFERENCE_1       3
#define RECONFIG_NETWORK_NUMBER_1   4
#define RECONFIG_PREFERENCE_2       5
#define RECONFIG_NETWORK_NUMBER_2   6
#define RECONFIG_PREFERENCE_3       7
#define RECONFIG_NETWORK_NUMBER_3   8
#define RECONFIG_PREFERENCE_4       9
#define RECONFIG_NETWORK_NUMBER_4   10

#define RECONFIG_PARAMETERS         10

//
// Main configuration structure.
//

typedef struct _RECONFIG {
   ULONG       ulVersion;
   BOOLEAN     VirtualNetworkNumber;
   BOOLEAN     AdapterParameters[RECONFIG_PARAMETERS];
} RECONFIG, *PRECONFIG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\address.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    address.c

Abstract:

    This module contains code which implements the ADDRESS object.
    Routines are provided to create, destroy, reference, and dereference,
    transport address objects.

Environment:

    Kernel mode

Revision History:

	Sanjay Anand (SanjayAn) - 22-Sept-1995
	BackFill optimization changes added under #if BACK_FILL

	Sanjay Anand (SanjayAn) 3-Oct-1995
	Changes to support transfer of buffer ownership to transports - tagged [CH]

--*/

#include "precomp.h"
#pragma hdrstop


//
// Map all generic accesses to the same one.
//

static GENERIC_MAPPING AddressGenericMapping =
       { READ_CONTROL, READ_CONTROL, READ_CONTROL, READ_CONTROL };



TDI_ADDRESS_IPX UNALIGNED *
IpxParseTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress
    )

/*++

Routine Description:

    This routine scans a TRANSPORT_ADDRESS, looking for an address
    of type TDI_ADDRESS_TYPE_IPX.

Arguments:

    Transport - The generic TDI address.

Return Value:

    A pointer to the IPX address, or NULL if none is found.

--*/

{
    TA_ADDRESS * addressName;
    INT i;

    addressName = &TransportAddress->Address[0];

    //
    // The name can be passed with multiple entries; we'll take and use only
    // the IPX one.
    //

    for (i=0;i<TransportAddress->TAAddressCount;i++) {
        if (addressName->AddressType == TDI_ADDRESS_TYPE_IPX) {
            if (addressName->AddressLength >= sizeof(TDI_ADDRESS_IPX)) {
                return ((TDI_ADDRESS_IPX UNALIGNED *)(addressName->Address));
            }
        }
        addressName = (TA_ADDRESS *)(addressName->Address +
                                                addressName->AddressLength);
    }
    return NULL;

}   /* IpxParseTdiAddress */


BOOLEAN
IpxValidateTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress,
    IN ULONG TransportAddressLength
    )

/*++

Routine Description:

    This routine scans a TRANSPORT_ADDRESS, verifying that the
    components of the address do not extend past the specified
    length.

Arguments:

    TransportAddress - The generic TDI address.

    TransportAddressLength - The specific length of TransportAddress.

Return Value:

    TRUE if the address is valid, FALSE otherwise.

--*/

{
    PUCHAR AddressEnd = ((PUCHAR)TransportAddress) + TransportAddressLength;
    TA_ADDRESS * addressName;
    INT i;

    if (TransportAddressLength < sizeof(TransportAddress->TAAddressCount)) {
        IpxPrint0 ("IpxValidateTdiAddress: runt address\n");
        return FALSE;
    }

    addressName = &TransportAddress->Address[0];

    for (i=0;i<TransportAddress->TAAddressCount;i++) {
        if (addressName->Address > AddressEnd) {
            IpxPrint0 ("IpxValidateTdiAddress: address too short\n");
            return FALSE;
        }
        addressName = (TA_ADDRESS *)(addressName->Address +
                                                addressName->AddressLength);
    }

    if ((PUCHAR)addressName > AddressEnd) {
        IpxPrint0 ("IpxValidateTdiAddress: address too short\n");
        return FALSE;
    }
    return TRUE;

}   /* IpxValidateTdiAddress */

#if DBG

VOID
IpxBuildTdiAddress(
    IN PVOID AddressBuffer,
    IN ULONG Network,
    IN UCHAR Node[6],
    IN USHORT Socket
    )

/*++

Routine Description:

    This routine fills in a TRANSPORT_ADDRESS in the specified
    buffer, given the socket, network and node.

Arguments:

    AddressBuffer - The buffer that will hold the address.

    Network - The network number.

    Node - The node address.

    Socket - The socket.

Return Value:

    None.

--*/

{
    TA_IPX_ADDRESS UNALIGNED * IpxAddress;

    IpxAddress = (TA_IPX_ADDRESS UNALIGNED *)AddressBuffer;

    IpxAddress->TAAddressCount = 1;
    IpxAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_IPX);
    IpxAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    IpxAddress->Address[0].Address[0].NetworkAddress = Network;
    IpxAddress->Address[0].Address[0].Socket = Socket;
    RtlCopyMemory(IpxAddress->Address[0].Address[0].NodeAddress, Node, 6);

}   /* IpxBuildTdiAddress */
#endif


NTSTATUS
IpxOpenAddress(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

{
   return(IpxOpenAddressM(Device, Request, 0));
}



NTSTATUS
IpxOpenAddressM(
    IN PDEVICE Device,
    IN PREQUEST Request,
    IN ULONG     Index
    )
/*++

Routine Description:

    This routine opens a file that points to an existing address object, or, if
    the object doesn't exist, creates it (note that creation of the address
    object includes registering the address, and may take many seconds to
    complete, depending upon system configuration).

    If the address already exists, and it has an ACL associated with it, the
    ACL is checked for access rights before allowing creation of the address.

Arguments:

    Device - pointer to the device describing the IPX transport.

    Request - a pointer to the request used for the creation of the address.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PADDRESS Address;
    PADDRESS_FILE AddressFile;
    PFILE_FULL_EA_INFORMATION ea;
    TRANSPORT_ADDRESS UNALIGNED *name;
    TA_ADDRESS *AddressName;
    USHORT Socket;
    ULONG DesiredShareAccess;
    CTELockHandle LockHandle;
    PACCESS_STATE AccessState;
    ACCESS_MASK GrantedAccess;
    BOOLEAN AccessAllowed;
    int i;
    BOOLEAN found = FALSE;
#ifdef ISN_NT
    PIRP Irp = (PIRP)Request;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
#endif
    INT Size = 0;

    //
    // If we are a dedicated router, we cannot let addresses
    // be opened.
    //

    if (Device->DedicatedRouter  && (REQUEST_CODE(Request) != MIPX_RT_CREATE)) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // The network name is in the EA, passed in the request.
    //

    ea = OPEN_REQUEST_EA_INFORMATION(Request);
    if (ea == NULL) {
        IpxPrint1("OpenAddress: REQUEST %lx has no EA\n", Request);
        return STATUS_NONEXISTENT_EA_ENTRY;
    }

    //
    // this may be a valid name; parse the name from the EA and use it if OK.
    //

    name = (PTRANSPORT_ADDRESS)&ea->EaName[ea->EaNameLength+1];

    //
    // 126042
    //
    if (ea->EaValueLength < (sizeof(TRANSPORT_ADDRESS) -1)) {

        IPX_DEBUG(ADDRESS, ("The ea value length does not match the TA address length\n"));
        DbgPrint("IPX: STATUS_INVALID_EA_NAME - 1\n");
        return STATUS_INVALID_EA_NAME;

    }

    AddressName = (PTA_ADDRESS)&name->Address[0];
    Size = FIELD_OFFSET(TRANSPORT_ADDRESS, Address) + FIELD_OFFSET(TA_ADDRESS, Address) + AddressName->AddressLength;

    //
    // The name can be passed with multiple entries; we'll take and use only
    // the first one of type IPX.
    //

    //DbgPrint("Size (%d) & EaValueLength (%d)", Size, ea->EaValueLength);
    if (Size > ea->EaValueLength) {
        DbgPrint("EA:%lx, Name:%lx, AddressName:%lx\n", ea, name, AddressName);
        CTEAssert(FALSE);
    }

    for (i=0;i<name->TAAddressCount;i++) {

        //
        // 126042
        //
        if (Size > ea->EaValueLength) {

            IPX_DEBUG(ADDRESS, ("The EA value length does not match the TA address length (2)\n"));

            DbgPrint("IPX: STATUS_INVALID_EA_NAME - 2\n");

            return STATUS_INVALID_EA_NAME;

        }

        if (AddressName->AddressType == TDI_ADDRESS_TYPE_IPX) {
            if (AddressName->AddressLength >= sizeof(TDI_ADDRESS_IPX)) {
                Socket = ((TDI_ADDRESS_IPX UNALIGNED *)&AddressName->Address[0])->Socket;
                found = TRUE;
            }
            break;

        } else {

            AddressName = (PTA_ADDRESS)(AddressName->Address +
                                        AddressName->AddressLength);

            Size += FIELD_OFFSET(TA_ADDRESS, Address);

            if (Size < ea->EaValueLength) {

                Size += AddressName->AddressLength;

            } else {

                break;

            }

        }


    }

    if (!found) {
        IPX_DEBUG (ADDRESS, ("OpenAddress, request %lx has no IPX Address\n", Request));
        return STATUS_NONEXISTENT_EA_ENTRY;
    }

    if (Socket == 0) {

        Socket = IpxAssignSocket (Device);

        if (Socket == 0) {
            IPX_DEBUG (ADDRESS, ("OpenAddress, no unique socket found\n"));
#ifdef  SNMP
            ++IPX_MIB_ENTRY(Device, SysOpenSocketFails);
#endif  SNMP
            return STATUS_INSUFFICIENT_RESOURCES;
        } else {
            IPX_DEBUG (ADDRESS, ("OpenAddress, assigned socket %lx\n", REORDER_USHORT(Socket)));
        }

    } else {

        IPX_DEBUG (ADDRESS, ("OpenAddress, socket %lx\n", REORDER_USHORT(Socket)));

    }

    //
    // get an address file structure to represent this address.
    //

    AddressFile = IpxCreateAddressFile (Device);

    if (AddressFile == (PADDRESS_FILE)NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // We mark this socket specially.
    //

    if (Socket == SAP_SOCKET) {
        AddressFile->IsSapSocket = TRUE;
        AddressFile->SpecialReceiveProcessing = TRUE;
    }

    //
    // See if this address is already established.  This call automatically
    // increments the reference count on the address so that it won't disappear
    // from underneath us after this call but before we have a chance to use it.
    //
    // To ensure that we don't create two address objects for the
    // same address, we hold the device context addressResource until
    // we have found the address or created a new one.
    //

    KeEnterCriticalRegion(); 

    ExAcquireResourceExclusiveLite (&Device->AddressResource, TRUE);

    CTEGetLock (&Device->Lock, &LockHandle);

    Address = IpxLookupAddress (Device, Socket);

    if (Address == NULL) {

        CTEFreeLock (&Device->Lock, LockHandle);

        //
        // This address doesn't exist. Create it.
        // registering it.
        //

        Address = IpxCreateAddress (
                    Device,
                    Socket);

        if (Address != (PADDRESS)NULL) {

            //
            // Set this now in case we have to deref.
            //

            AddressFile->AddressLock = &Address->Lock;

            if (REQUEST_CODE(Request) == MIPX_RT_CREATE) {
               Address->RtAdd = TRUE;
               Address->Index = Index;
            } else {
               Address->RtAdd = FALSE;
            }

#ifdef ISN_NT

            //
            // Initialize the shared access now. We use read access
            // to control all access.
            //

            DesiredShareAccess = (ULONG)
                (((IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                  (IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) ?
                        FILE_SHARE_READ : 0);

            IoSetShareAccess(
                FILE_READ_DATA,
                DesiredShareAccess,
                IrpSp->FileObject,
                &Address->u.ShareAccess);


            //
            // Assign the security descriptor (need to do this with
            // the spinlock released because the descriptor is not
            // mapped).
            //

            AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

            status = SeAssignSecurity(
                         NULL,                       // parent descriptor
                         AccessState->SecurityDescriptor,
                         &Address->SecurityDescriptor,
                         FALSE,                      // is directory
                         &AccessState->SubjectSecurityContext,
                         &AddressGenericMapping,
                         NonPagedPool);

            if (!NT_SUCCESS(status)) {

                //
                // Error, return status.
                //

                IoRemoveShareAccess (IrpSp->FileObject, &Address->u.ShareAccess);
                ExReleaseResourceLite (&Device->AddressResource);
		KeLeaveCriticalRegion(); 
                IpxDereferenceAddress (Address, AREF_ADDRESS_FILE);
                IpxDereferenceAddressFile (AddressFile, AFREF_CREATE);
                return status;

            }

#endif

            ExReleaseResourceLite (&Device->AddressResource);
            KeLeaveCriticalRegion(); 

            //
            // if the adapter isn't ready, we can't do any of this; get out
            //

            if (Device->State == DEVICE_STATE_STOPPING) {
                IpxDereferenceAddress (Address, AREF_ADDRESS_FILE);
                IpxDereferenceAddressFile (AddressFile, AFREF_CREATE);
                status = STATUS_DEVICE_NOT_READY;

            } else {

                REQUEST_OPEN_CONTEXT(Request) = (PVOID)AddressFile;
                REQUEST_OPEN_TYPE(Request) = (PVOID)TDI_TRANSPORT_ADDRESS_FILE;
#ifdef ISN_NT
                AddressFile->FileObject = IrpSp->FileObject;
#endif
                AddressFile->Request = Request;
                AddressFile->Address = Address;

                CTEGetLock (&Address->Lock, &LockHandle);
                InsertTailList (&Address->AddressFileDatabase, &AddressFile->Linkage);
                CTEFreeLock (&Address->Lock, LockHandle);

                AddressFile->Request = NULL;
                AddressFile->State = ADDRESSFILE_STATE_OPEN;
                status = STATUS_SUCCESS;

            }

        } else {

            ExReleaseResourceLite (&Device->AddressResource);
            KeLeaveCriticalRegion(); 

            //
            // If the address could not be created, and is not in the
            // process of being created, then we can't open up an address.
            // Since we can't use the AddressLock to deref, we just destroy
            // the address file.
            //

            IpxDestroyAddressFile (AddressFile);

	    // 288208
	    status = STATUS_INSUFFICIENT_RESOURCES; 
	    
        }

    } else {

        CTEFreeLock (&Device->Lock, LockHandle);

        IPX_DEBUG (ADDRESS, ("Add to address %lx\n", Address));

        //
        // We never allow shared access to a RT address.  So, check that
        // we don't have a "RT address create" request and also that the
        // address has not only been taken up by a RT Address request. If
        // and only if both the above
        //
        if ((REQUEST_CODE(Request) != MIPX_RT_CREATE) && (!Address->RtAdd))
        {
        //
        // Set this now in case we have to deref.
        //

        AddressFile->AddressLock = &Address->Lock;

        //
        // The address already exists.  Check the ACL and see if we
        // can access it.  If so, simply use this address as our address.
        //

#ifdef ISN_NT

        AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

        AccessAllowed = SeAccessCheck(
                            Address->SecurityDescriptor,
                            &AccessState->SubjectSecurityContext,
                            FALSE,                   // tokens locked
                            IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                            (ACCESS_MASK)0,             // previously granted
                            NULL,                    // privileges
                            &AddressGenericMapping,
                            Irp->RequestorMode,
                            &GrantedAccess,
                            &status);

#else   // ISN_NT

        AccessAllowed = TRUE;

#endif  // ISN_NT

        if (!AccessAllowed) {

            ExReleaseResourceLite (&Device->AddressResource);
            KeLeaveCriticalRegion(); 

            IpxDereferenceAddressFile (AddressFile, AFREF_CREATE);

        } else {

#ifdef ISN_NT

            //
            // NtBug: 132051. Make sure you dont give more access than reqd.
            //
            AccessState->PreviouslyGrantedAccess |= GrantedAccess;
            AccessState->RemainingDesiredAccess &= ~( GrantedAccess | MAXIMUM_ALLOWED );

            //
            // Now check that we can obtain the desired share
            // access. We use read access to control all access.
            //

            DesiredShareAccess = (ULONG)
                (((IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                  (IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) ?
                        FILE_SHARE_READ : 0);

            status = IoCheckShareAccess(
                         FILE_READ_DATA,
                         DesiredShareAccess,
                         IrpSp->FileObject,
                         &Address->u.ShareAccess,
                         TRUE);

#else   // ISN_NT

            status = STATUS_SUCCESS;

#endif  // ISN_NT

            if (!NT_SUCCESS (status)) {

                ExReleaseResourceLite (&Device->AddressResource);
                KeLeaveCriticalRegion(); 

                IpxDereferenceAddressFile (AddressFile, AFREF_CREATE);

            } else {

                ExReleaseResourceLite (&Device->AddressResource);
                KeLeaveCriticalRegion(); 

                CTEGetLock (&Address->Lock, &LockHandle);

                InsertTailList (
                    &Address->AddressFileDatabase,
                    &AddressFile->Linkage);

                AddressFile->Request = NULL;
                AddressFile->Address = Address;
#ifdef ISN_NT
                AddressFile->FileObject = IrpSp->FileObject;
#endif
                AddressFile->State = ADDRESSFILE_STATE_OPEN;

                IpxReferenceAddress (Address, AREF_ADDRESS_FILE);

                REQUEST_OPEN_CONTEXT(Request) = (PVOID)AddressFile;
                REQUEST_OPEN_TYPE(Request) = (PVOID)TDI_TRANSPORT_ADDRESS_FILE;

                CTEFreeLock (&Address->Lock, LockHandle);

                status = STATUS_SUCCESS;

            }
        }
        }
        else
        {
                    DbgPrint("IpxOpenAddress: ACCESS DENIED - duplicate address\n");
                    status = STATUS_ACCESS_DENIED;
                    ExReleaseResourceLite (&Device->AddressResource);
                    KeLeaveCriticalRegion(); 
                    IpxDereferenceAddressFile (AddressFile, AFREF_CREATE);

        }

        //
        // Remove the reference from IpxLookupAddress.
        //

        IpxDereferenceAddress (Address, AREF_LOOKUP);
    }

    return status;

}   /* IpxOpenAddress */



USHORT
IpxAssignSocket(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine assigns a socket that is unique within a range
    of SocketUniqueness.

Arguments:

    Device - Pointer to the device context.

Return Value:

    The assigned socket number, or 0 if a unique one cannot
    be found.

--*/

{
    USHORT InitialSocket, CurrentSocket, AddressSocket;
    ULONG CurrentHash;
    BOOLEAN Conflict;
    PLIST_ENTRY p;
    PADDRESS Address;
    CTELockHandle LockHandle;

    //
    // Loop through all possible sockets, starting at
    // Device->CurrentSocket, looking for a suitable one.
    // Device->CurrentSocket rotates through the possible
    // sockets to improve the chances of finding one
    // quickly.
    //

    CTEGetLock (&Device->Lock, &LockHandle);

    InitialSocket = Device->CurrentSocket;
    Device->CurrentSocket = (USHORT)(Device->CurrentSocket + Device->SocketUniqueness);
    if ((USHORT)(Device->CurrentSocket+Device->SocketUniqueness) > Device->SocketEnd) {
        Device->CurrentSocket = Device->SocketStart;
    }

    CurrentSocket = InitialSocket;

    do {

        //
        // Scan all addresses; if we find one with a socket
        // that conflicts with this one, we can't use it.
        //
        // NOTE: Device->Lock is acquired here.
        //

        Conflict = FALSE;

        for (CurrentHash = 0; CurrentHash < IPX_ADDRESS_HASH_COUNT; CurrentHash++) {

            for (p = Device->AddressDatabases[CurrentHash].Flink;
                 p != &Device->AddressDatabases[CurrentHash];
                 p = p->Flink) {

                 Address = CONTAINING_RECORD (p, ADDRESS, Linkage);
                 AddressSocket = REORDER_USHORT(Address->Socket);

                 if ((AddressSocket + Device->SocketUniqueness > CurrentSocket) &&
                         (AddressSocket < CurrentSocket + Device->SocketUniqueness)) {
                     Conflict = TRUE;
                     break;
                 }
            }

            //
            // If we've found a conflict, no need to check the other
            // queues.
            //

            if (Conflict) {
                break;
            }
        }

        CTEFreeLock (&Device->Lock, LockHandle);

        //
        // We intentionally free the lock here so that we
        // never spend too much time with it held.
        //

        if (!Conflict) {

            //
            // We went through the address list without
            // finding a conflict; use this socket.
            //

            return REORDER_USHORT(CurrentSocket);
        }

        CurrentSocket = (USHORT)(CurrentSocket + Device->SocketUniqueness);
        if ((USHORT)(CurrentSocket+Device->SocketUniqueness) > Device->SocketEnd) {
            CurrentSocket = Device->SocketStart;
        }

        CTEGetLock (&Device->Lock, &LockHandle);

    } while (CurrentSocket != InitialSocket);

    CTEFreeLock (&Device->Lock, LockHandle);

    //
    // Could not find one to assign.
    //

    return (USHORT)0;

}   /* IpxAssignSocket */


PADDRESS
IpxCreateAddress(
    IN PDEVICE Device,
    IN USHORT Socket
    )

/*++

Routine Description:

    This routine creates a transport address and associates it with
    the specified transport device context.  The reference count in the
    address is automatically set to 1, and the reference count of the
    device context is incremented.

    NOTE: This routine must be called with the Device
    spinlock held.

Arguments:

    Device - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

    Socket - The socket to assign to this address.

Return Value:

    The newly created address, or NULL if none can be allocated.

--*/

{
    PADDRESS Address;
    PIPX_SEND_RESERVED SendReserved;
    PIPX_RECEIVE_RESERVED ReceiveReserved;
    NDIS_STATUS Status;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)

    Address = (PADDRESS)IpxAllocateMemory (sizeof(ADDRESS), MEMORY_ADDRESS, "Address");
    if (Address == NULL) {
        IPX_DEBUG (ADDRESS, ("Create address %lx failed\n", REORDER_USHORT(Socket)));
        return NULL;
    }

    IPX_DEBUG (ADDRESS, ("Create address %lx (%lx)\n", Address, REORDER_USHORT(Socket)));
    RtlZeroMemory (Address, sizeof(ADDRESS));

#ifndef IPX_OWN_PACKETS
    IpxAllocateSingleSendPacket(Device, &Address->SendPacket, &Status);
    if (Status != NDIS_STATUS_SUCCESS) {
        goto Fail1;
    }
#endif

    if (IpxInitializeSendPacket (Device, &Address->SendPacket, Address->SendPacketHeader) != STATUS_SUCCESS) {
#ifndef IPX_OWN_PACKETS
Fail1:
#endif
        Address->SendPacketInUse = TRUE;
    } else {
        SendReserved = SEND_RESERVED(&Address->SendPacket);
        SendReserved->Address = Address;
        SendReserved->OwnedByAddress = TRUE;
        Address->SendPacketInUse = FALSE;
#ifdef IPX_TRACK_POOL
        SendReserved->Pool = NULL;
#endif
    }


#if BACK_FILL
    {
       PIPX_SEND_RESERVED BackFillReserved;

#ifndef IPX_OWN_PACKETS
        IpxAllocateSingleSendPacket(Device, &Address->BackFillPacket, &Status);
        if (Status != NDIS_STATUS_SUCCESS) {
            goto Fail2;
        }
#endif
       if (IpxInitializeBackFillPacket (Device, &Address->BackFillPacket, NULL) != STATUS_SUCCESS) {
#ifndef IPX_OWN_PACKETS
Fail2:
#endif
           Address->BackFillPacketInUse = TRUE;
       } else {
        BackFillReserved = SEND_RESERVED(&Address->BackFillPacket);
        BackFillReserved->Address = Address;
        Address->BackFillPacketInUse = FALSE;
        BackFillReserved->OwnedByAddress = TRUE;
#ifdef IPX_TRACK_POOL
        BackFillReserved->Pool = NULL;
#endif
       }
    }
#endif

#ifndef IPX_OWN_PACKETS
    IpxAllocateSingleReceivePacket(Device, &Address->ReceivePacket, &Status);
    if (Status != NDIS_STATUS_SUCCESS) {
        goto Fail3;
    }
#endif
    if (IpxInitializeReceivePacket (Device, &Address->ReceivePacket) != STATUS_SUCCESS) {
#ifndef IPX_OWN_PACKETS
Fail3:
#endif
        Address->ReceivePacketInUse = TRUE;
    } else {
        ReceiveReserved = RECEIVE_RESERVED(&Address->ReceivePacket);
        ReceiveReserved->Address = Address;
        ReceiveReserved->OwnedByAddress = TRUE;
        Address->ReceivePacketInUse = FALSE;
#ifdef IPX_TRACK_POOL
        ReceiveReserved->Pool = NULL;
#endif
    }

    Address->Type = IPX_ADDRESS_SIGNATURE;
    Address->Size = sizeof (ADDRESS);

    Address->Device = Device;
    Address->DeviceLock = &Device->Lock;
    CTEInitLock (&Address->Lock);

    InitializeListHead (&Address->AddressFileDatabase);

    Address->ReferenceCount = 1;
#if DBG
    Address->RefTypes[AREF_ADDRESS_FILE] = 1;
#endif
    Address->Socket = Socket;
    Address->SendSourceSocket = Socket;

    //
    // Save our local address for building datagrams quickly.
    //

    RtlCopyMemory (&Address->LocalAddress, &Device->SourceAddress, FIELD_OFFSET(TDI_ADDRESS_IPX,Socket));
    Address->LocalAddress.Socket = Socket;

    //
    // Now link this address into the specified device context's
    // address database.  To do this, we need to acquire the spin lock
    // on the device context.
    //

    IPX_GET_LOCK (&Device->Lock, &LockHandle);
    InsertTailList (&Device->AddressDatabases[IPX_HASH_SOCKET(Socket)], &Address->Linkage);
    IPX_FREE_LOCK (&Device->Lock, LockHandle);

    IpxReferenceDevice (Device, DREF_ADDRESS);

    return Address;

}   /* IpxCreateAddress */


NTSTATUS
IpxVerifyAddressFile(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine is called to verify that the pointer given us in a file
    object is in fact a valid address file object. We also verify that the
    address object pointed to by it is a valid address object, and reference
    it to keep it from disappearing while we use it.

Arguments:

    AddressFile - potential pointer to a ADDRESS_FILE object

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INVALID_ADDRESS otherwise

--*/

{
    CTELockHandle LockHandle;
    NTSTATUS status = STATUS_SUCCESS;
    PADDRESS Address;

    //
    // try to verify the address file signature. If the signature is valid,
    // verify the address pointed to by it and get the address spinlock.
    // check the address's state, and increment the reference count if it's
    // ok to use it. Note that the only time we return an error for state is
    // if the address is closing.
    //

    try {

        if ((AddressFile->Size == sizeof (ADDRESS_FILE)) &&
            (AddressFile->Type == IPX_ADDRESSFILE_SIGNATURE) ) {
//            (AddressFile->State != ADDRESSFILE_STATE_CLOSING) ) {

            Address = AddressFile->Address;

            if ((Address->Size == sizeof (ADDRESS)) &&
                (Address->Type == IPX_ADDRESS_SIGNATURE)    ) {

                CTEGetLock (&Address->Lock, &LockHandle);

                if (!Address->Stopping) {

                    IpxReferenceAddressFileLock (AddressFile, AFREF_VERIFY);

                } else {

                    IpxPrint1("IpxVerifyAddressFile: A %lx closing\n", Address);
                    status = STATUS_INVALID_ADDRESS;
                }

                CTEFreeLock (&Address->Lock, LockHandle);

            } else {

                IpxPrint1("IpxVerifyAddressFile: A %lx bad signature\n", Address);
                status = STATUS_INVALID_ADDRESS;
            }

        } else {

            IpxPrint1("IpxVerifyAddressFile: AF %lx bad signature\n", AddressFile);
            status = STATUS_INVALID_ADDRESS;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

         IpxPrint1("IpxVerifyAddressFile: AF %lx exception\n", Address);
         return GetExceptionCode();
    }

    return status;

}   /* IpxVerifyAddressFile */


VOID
IpxDestroyAddress(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This routine destroys a transport address and removes all references
    made by it to other objects in the transport.  The address structure
    is returned to nonpaged system pool. It is assumed
    that the caller has already removed all addressfile structures associated
    with this address.

    It is called from a worker thread queue by IpxDerefAddress when
    the reference count goes to 0.

    This thread is only queued by IpxDerefAddress.  The reason for
    this is that there may be multiple streams of execution which are
    simultaneously referencing the same address object, and it should
    not be deleted out from under an interested stream of execution.

Arguments:

    Address - Pointer to a transport address structure to be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PADDRESS Address = (PADDRESS)Parameter;
    PDEVICE Device = Address->Device;
    CTELockHandle LockHandle;

    IPX_DEBUG (ADDRESS, ("Destroy address %lx (%lx)\n", Address, REORDER_USHORT(Address->Socket)));

    SeDeassignSecurity (&Address->SecurityDescriptor);

    //
    // Delink this address from its associated device context's address
    // database.  To do this we must spin lock on the device context object,
    // not on the address.
    //

    CTEGetLock (&Device->Lock, &LockHandle);
    RemoveEntryList (&Address->Linkage);
    CTEFreeLock (&Device->Lock, LockHandle);

    if (!Address->SendPacketInUse) {
        IpxDeinitializeSendPacket (Device, &Address->SendPacket);
#ifndef  IPX_OWN_PACKETS
        IpxFreeSingleSendPacket (Device, Address->SendPacket);
#endif
    }

    if (!Address->ReceivePacketInUse) {
        IpxDeinitializeReceivePacket (Device, &Address->ReceivePacket);
#ifndef  IPX_OWN_PACKETS
        IpxFreeSingleReceivePacket (Device, Address->ReceivePacket);
#endif
    }

#if BACK_FILL
    if (!Address->BackFillPacketInUse) {
        IpxDeinitializeBackFillPacket (Device, &Address->BackFillPacket);
#ifndef  IPX_OWN_PACKETS
        IpxFreeSingleSendPacket (Device, Address->BackFillPacket);
#endif
    }
#endif
    IpxFreeMemory (Address, sizeof(ADDRESS), MEMORY_ADDRESS, "Address");

    IpxDereferenceDevice (Device, DREF_ADDRESS);

}   /* IpxDestroyAddress */


#if DBG
VOID
IpxRefAddress(
    IN PADDRESS Address
    )

/*++

Routine Description:

    This routine increments the reference count on a transport address.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{

    CTEAssert (Address->ReferenceCount > 0);    // not perfect, but...

    (VOID)InterlockedIncrement(&Address->ReferenceCount);

}   /* IpxRefAddress */


VOID
IpxRefAddressLock(
    IN PADDRESS Address
    )

/*++

Routine Description:

    This routine increments the reference count on a transport address
    when the device lock is already held.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{

    CTEAssert (Address->ReferenceCount > 0);    // not perfect, but...

    // ++Address->ReferenceCount;
    (VOID)InterlockedIncrement(&Address->ReferenceCount);

}   /* IpxRefAddressLock */
#endif


VOID
IpxDerefAddress(
    IN PADDRESS Address
    )

/*++

Routine Description:

    This routine dereferences a transport address by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    IpxDestroyAddress to remove it from the system.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{
    ULONG oldvalue;

    oldvalue = IPX_ADD_ULONG (
                &Address->ReferenceCount,
                (ULONG)-1,
                Address->DeviceLock);

    //
    // If we have deleted all references to this address, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    //

    CTEAssert (oldvalue != 0);

    if (oldvalue == 1) {

#if ISN_NT
        ExInitializeWorkItem(
            &Address->u.DestroyAddressQueueItem,
            IpxDestroyAddress,
            (PVOID)Address);
        ExQueueWorkItem(&Address->u.DestroyAddressQueueItem, DelayedWorkQueue);
#else
        IpxDestroyAddress(Address);
#endif

    }

}   /* IpxDerefAddress */


VOID
IpxDerefAddressSync(
    IN PADDRESS Address
    )

/*++

Routine Description:

    This routine dereferences a transport address by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    IpxDestroyAddress to remove it from the system. This routine can
    only be called when we are synchronized (inside an IPX_SYNC_START/
    IPX_SYNC_END pair, with a lock held, or in an indication).

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{
    ULONG oldvalue;

    oldvalue = IPX_ADD_ULONG (
                &Address->ReferenceCount,
                (ULONG)-1,
                Address->DeviceLock);

    //
    // If we have deleted all references to this address, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    //

    CTEAssert (oldvalue != 0);

    if (oldvalue == 1) {

#if ISN_NT
        ExInitializeWorkItem(
            &Address->u.DestroyAddressQueueItem,
            IpxDestroyAddress,
            (PVOID)Address);
        ExQueueWorkItem(&Address->u.DestroyAddressQueueItem, DelayedWorkQueue);
#else
        IpxDestroyAddress(Address);
#endif

    }

}   /* IpxDerefAddressSync */


PADDRESS_FILE
IpxCreateAddressFile(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine creates an address file from the pool of ther
    specified device context. The reference count in the
    address is automatically set to 1.

Arguments:

    Device - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

Return Value:

    The allocate address file or NULL.

--*/

{
    CTELockHandle LockHandle;
    PADDRESS_FILE AddressFile;

    AddressFile = (PADDRESS_FILE)IpxAllocateMemory (sizeof(ADDRESS_FILE), MEMORY_ADDRESS, "AddressFile");
    if (AddressFile == NULL) {
        IPX_DEBUG (ADDRESS, ("Create address file failed\n"));
        return NULL;
    }

    IPX_DEBUG (ADDRESS, ("Create address file %lx\n", AddressFile));

    RtlZeroMemory (AddressFile, sizeof(ADDRESS_FILE));

    AddressFile->Type = IPX_ADDRESSFILE_SIGNATURE;
    AddressFile->Size = sizeof (ADDRESS_FILE);

    CTEGetLock (&Device->Lock, &LockHandle);

    InitializeListHead (&AddressFile->ReceiveDatagramQueue);

    CTEFreeLock (&Device->Lock, LockHandle);

#if 0
    AddressFile->SpecialReceiveProcessing = FALSE;
    AddressFile->ExtendedAddressing = FALSE;
    AddressFile->ReceiveIpxHeader = FALSE;
    AddressFile->FilterOnPacketType = FALSE;
    AddressFile->DefaultPacketType = 0;
    AddressFile->Address = NULL;
#ifdef ISN_NT
    AddressFile->FileObject = NULL;
#endif
#endif

    AddressFile->Device = Device;
    AddressFile->State = ADDRESSFILE_STATE_OPENING;
    AddressFile->ReferenceCount = 1;
#if DBG
    AddressFile->RefTypes[AFREF_CREATE] = 1;
#endif
    AddressFile->CloseRequest = (PREQUEST)NULL;

    //
    // Initialize the request handlers.
    //

    AddressFile->RegisteredReceiveDatagramHandler = FALSE;
    AddressFile->ReceiveDatagramHandler = TdiDefaultRcvDatagramHandler;
    AddressFile->ReceiveDatagramHandlerContext = NULL;

	//
	// [CH] Added these handlers for chained buffer receives
	//
	AddressFile->RegisteredChainedReceiveDatagramHandler = FALSE;
    AddressFile->ChainedReceiveDatagramHandler = TdiDefaultChainedRcvDatagramHandler;
    AddressFile->ChainedReceiveDatagramHandlerContext = NULL;

    AddressFile->RegisteredErrorHandler = FALSE;
    AddressFile->ErrorHandler = TdiDefaultErrorHandler;
    AddressFile->ErrorHandlerContext = NULL;

    return AddressFile;

}   /* IpxCreateAddressFile */


NTSTATUS
IpxDestroyAddressFile(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine destroys an address file and removes all references
    made by it to other objects in the transport.

    This routine is only called by IpxDereferenceAddressFile. The reason
    for this is that there may be multiple streams of execution which are
    simultaneously referencing the same address file object, and it should
    not be deleted out from under an interested stream of execution.

Arguments:

    AddressFile Pointer to a transport address file structure to be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    CTELockHandle LockHandle, LockHandle1;
    PADDRESS Address;
    PDEVICE Device;
    PREQUEST CloseRequest;

    IPX_DEBUG (ADDRESS, ("Destroy address file %lx\n", AddressFile));

    Address = AddressFile->Address;
    Device = AddressFile->Device;

    if (Address) {

        //
        // This addressfile was associated with an address.
        //

        CTEGetLock (&Address->Lock, &LockHandle);

        //
        // remove this addressfile from the address list and disassociate it from
        // the file handle.
        //

        RemoveEntryList (&AddressFile->Linkage);
        InitializeListHead (&AddressFile->Linkage);

        if (Address->AddressFileDatabase.Flink == &Address->AddressFileDatabase) {

            //
            // This is the last open of this address, it will close
            // due to normal dereferencing but we have to set the
            // CLOSING flag too to stop further references.
            //

            CTEGetLock (&Device->Lock, &LockHandle1);
            Address->Stopping = TRUE;
            if (Device->LastAddress == Address) {
                Device->LastAddress = NULL;
            }
            CTEFreeLock (&Device->Lock, LockHandle1);

        }

        AddressFile->Address = NULL;

#ifdef ISN_NT
        AddressFile->FileObject->FsContext = NULL;
        AddressFile->FileObject->FsContext2 = NULL;
#endif

        CTEFreeLock (&Address->Lock, LockHandle);

        //
        // We will already have been removed from the ShareAccess
        // of the owning address.
        //

        //
        // Now dereference the owning address.
        //

        IpxDereferenceAddress (Address, AREF_ADDRESS_FILE);

    }

    //
    // Save this for later completion.
    //

    CloseRequest = AddressFile->CloseRequest;

    //
    // return the addressFile to the pool of address files
    //

    IpxFreeMemory (AddressFile, sizeof(ADDRESS_FILE), MEMORY_ADDRESS, "AddressFile");

    if (CloseRequest != (PREQUEST)NULL) {
        REQUEST_INFORMATION(CloseRequest) = 0;
        REQUEST_STATUS(CloseRequest) = STATUS_SUCCESS;
        IpxCompleteRequest (CloseRequest);
        IpxFreeRequest (Device, CloseRequest);
    }

    return STATUS_SUCCESS;

}   /* IpxDestroyAddressFile */


#if DBG
VOID
IpxRefAddressFile(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert (AddressFile->ReferenceCount > 0);   // not perfect, but...

    (VOID)IPX_ADD_ULONG (
            &AddressFile->ReferenceCount,
            1,
            AddressFile->AddressLock);

}   /* IpxRefAddressFile */


VOID
IpxRefAddressFileLock(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.
    IT IS CALLED WITH THE ADDRESS LOCK HELD.

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert (AddressFile->ReferenceCount > 0);   // not perfect, but...

    //++AddressFile->ReferenceCount;
    (VOID)InterlockedIncrement(&AddressFile->ReferenceCount);

}   /* IpxRefAddressFileLock */


VOID
IpxRefAddressFileSync(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert (AddressFile->ReferenceCount > 0);   // not perfect, but...

    (VOID)IPX_ADD_ULONG (
            &AddressFile->ReferenceCount,
            1,
            AddressFile->AddressLock);

}   /* IpxRefAddressFileSync */


VOID
IpxDerefAddressFile(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine dereferences an address file by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    IpxDestroyAddressFile to remove it from the system.

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{
    ULONG oldvalue;

    oldvalue = IPX_ADD_ULONG (
                &AddressFile->ReferenceCount,
                (ULONG)-1,
                AddressFile->AddressLock);

    //
    // If we have deleted all references to this address file, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    //

    CTEAssert (oldvalue > 0);

    if (oldvalue == 1) {
        IpxDestroyAddressFile (AddressFile);
    }

}   /* IpxDerefAddressFile */


VOID
IpxDerefAddressFileSync(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine dereferences an address file by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    IpxDestroyAddressFile to remove it from the system. This routine
    can only be called when we are synchronized (inside an IPX_SYNC_START/
    IPX_SYNC_END pair, with a lock held, or in an indication).

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{
    ULONG oldvalue;

    oldvalue = IPX_ADD_ULONG (
                &AddressFile->ReferenceCount,
                (ULONG)-1,
                AddressFile->AddressLock);

    //
    // If we have deleted all references to this address file, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    //

    CTEAssert (oldvalue > 0);

    if (oldvalue == 1) {
        IpxDestroyAddressFile (AddressFile);
    }

}   /* IpxDerefAddressFileSync */
#endif


PADDRESS
IpxLookupAddress(
    IN PDEVICE Device,
    IN USHORT Socket
    )

/*++

Routine Description:

    This routine scans the transport addresses defined for the given
    device context and compares them with the specified NETWORK
    NAME values.  If an exact match is found, then a pointer to the
    ADDRESS object is returned, and as a side effect, the reference
    count to the address object is incremented.  If the address is not
    found, then NULL is returned.

    NOTE: This routine must be called with the Device
    spinlock held.

Arguments:

    Device - Pointer to the device object and its extension.

    Socket - The socket to look up.

Return Value:

    Pointer to the ADDRESS object found, or NULL if not found.

--*/

{
    PADDRESS Address;
    PLIST_ENTRY p;
    ULONG Hash = IPX_HASH_SOCKET (Socket);

    p = Device->AddressDatabases[Hash].Flink;

    for (p = Device->AddressDatabases[Hash].Flink;
         p != &Device->AddressDatabases[Hash];
         p = p->Flink) {

        Address = CONTAINING_RECORD (p, ADDRESS, Linkage);

        if (Address->Stopping) {
            continue;
        }

        if (Address->Socket == Socket) {

            //
            // We found the match.  Bump the reference count on the address, and
            // return a pointer to the address object for the caller to use.
            //

            IpxReferenceAddressLock (Address, AREF_LOOKUP);
            return Address;

        }

    }

    //
    // The specified address was not found.
    //

    return NULL;

}   /* IpxLookupAddress */


NTSTATUS
IpxStopAddressFile(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine is called to terminate all activity on an AddressFile and
    destroy the object.  We remove every connection and datagram associated
    with this addressfile from the address database and terminate their
    activity. Then, if there are no other outstanding addressfiles open on
    this address, the address will go away.

Arguments:

    AddressFile - pointer to the addressFile to be stopped

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the request
    is not for a real address.

--*/

{
    CTELockHandle LockHandle;
    PREQUEST Request;
    PADDRESS Address = AddressFile->Address;
    PLIST_ENTRY p;
    KIRQL irql;


    IoAcquireCancelSpinLock( &irql );
    CTEGetLock (&Address->Lock, &LockHandle);

    if (AddressFile->State == ADDRESSFILE_STATE_CLOSING) {
        CTEFreeLock (&Address->Lock, LockHandle);
        IoReleaseCancelSpinLock( irql );
        return STATUS_SUCCESS;
    }


    AddressFile->State = ADDRESSFILE_STATE_CLOSING;

    while (!(IsListEmpty(&AddressFile->ReceiveDatagramQueue))) {

        p = RemoveHeadList (&AddressFile->ReceiveDatagramQueue);
        Request = LIST_ENTRY_TO_REQUEST (p);

        REQUEST_INFORMATION(Request) = 0;
        REQUEST_STATUS(Request) = STATUS_NETWORK_NAME_DELETED;
        IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);

        CTEFreeLock(&Address->Lock, LockHandle);
        IoReleaseCancelSpinLock( irql );

        IpxCompleteRequest (Request);
        IpxFreeRequest (Device, Request);

        IpxDereferenceAddressFile (AddressFile, AFREF_RCV_DGRAM);

        IoAcquireCancelSpinLock( &irql );
        CTEGetLock(&Address->Lock, &LockHandle);

    }

    CTEFreeLock(&Address->Lock, LockHandle);
    IoReleaseCancelSpinLock( irql );

    return STATUS_SUCCESS;
}   /* IpxStopAddressFile */


NTSTATUS
IpxCloseAddressFile(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine is called to close the addressfile pointed to by a file
    object. If there is any activity to be run down, we will run it down
    before we terminate the addressfile. We remove every connection and
    datagram associated with this addressfile from the address database
    and terminate their activity. Then, if there are no other outstanding
    addressfiles open on this address, the address will go away.

Arguments:

    Request - the close request.

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the
    request does not point to a real address.

--*/

{
    PADDRESS Address;
    PADDRESS_FILE AddressFile;
    CTELockHandle LockHandle;

    AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);
    AddressFile->CloseRequest = Request;

    //
    // We assume that addressFile has already been verified
    // at this point.
    //

    Address = AddressFile->Address;
    CTEAssert (Address);

    //
    // Remove us from the access info for this address.
    //

    KeEnterCriticalRegion(); 

    ExAcquireResourceExclusiveLite (&Device->AddressResource, TRUE);
#ifdef ISN_NT
    IoRemoveShareAccess (AddressFile->FileObject, &Address->u.ShareAccess);
#endif
    ExReleaseResourceLite (&Device->AddressResource);

    KeLeaveCriticalRegion(); 

    //
    // If this address file had broadcasts enabled, turn it off.
    //

    //
    // Not needed anymore
    //
    /*
    CTEGetLock (&Device->Lock, &LockHandle);
    if (AddressFile->EnableBroadcast) {
        AddressFile->EnableBroadcast = FALSE;
        IpxRemoveBroadcast (Device);
    }
    CTEFreeLock (&Device->Lock, LockHandle);
    */
    IpxStopAddressFile (AddressFile);
    IpxDereferenceAddressFile (AddressFile, AFREF_CREATE);

    return STATUS_PENDING;

}   /* IpxCloseAddressFile */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\device.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    device.c

Abstract:

    This module contains code which implements the DEVICE_CONTEXT object.
    Routines are provided to reference, and dereference transport device
    context objects.

    The transport device context object is a structure which contains a
    system-defined DEVICE_OBJECT followed by information which is maintained
    by the transport provider, called the context.

Environment:

    Kernel mode

Revision History:

	Sanjay Anand (SanjayAn) - 22-Sept-1995
	BackFill optimization changes added under #if BACK_FILL

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,IpxCreateDevice)
#endif



VOID
IpxRefDevice(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine increments the reference count on a device context.

Arguments:

    Device - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    CTEAssert (Device->ReferenceCount > 0);    // not perfect, but...

    (VOID)InterlockedIncrement(&Device->ReferenceCount);

}   /* IpxRefDevice */


VOID
IpxDerefDevice(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine dereferences a device context by decrementing the
    reference count contained in the structure.  Currently, we don't
    do anything special when the reference count drops to zero, but
    we could dynamically unload stuff then.

Arguments:

    Device - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    LONG result;
#if DBG
    int i; 
#endif

    result = InterlockedDecrement (&Device->ReferenceCount);

    CTEAssert (result >= 0);
    
    if (result == 0) {
#if DBG
       for (i = 0; i < DREF_TOTAL; i++) {
	  CTEAssert(Device->RefTypes[i] == 0);
       }
#endif
       IpxDestroyDevice (Device);
    }

}   /* IpxDerefDevice */


NTSTATUS
IpxCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING DeviceName,
    IN ULONG SegmentCount,
    IN OUT PDEVICE *DevicePtr
    )

/*++

Routine Description:

    This routine creates and initializes a device context structure.

Arguments:


    DriverObject - pointer to the IO subsystem supplied driver object.

    Device - Pointer to a pointer to a transport device context object.

    SegmentCount - The number of segments in the RIP router table.

    DeviceName - pointer to the name of the device this device object points to.

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PDEVICE Device;
    ULONG DeviceSize;
    ULONG LocksOffset;
    ULONG SegmentsOffset;
    ULONG DeviceNameOffset;
    UINT i;


    //
    // Create the device object for the sample transport, allowing
    // room at the end for the device name to be stored (for use
    // in logging errors) and the RIP fields.
    //

    DeviceSize = sizeof(DEVICE) +
                 (sizeof(CTELock) * SegmentCount) +
                 (sizeof(ROUTER_SEGMENT) * SegmentCount) +
                 DeviceName->Length + sizeof(UNICODE_NULL);

    status = IoCreateDevice(
                 DriverObject,
                 DeviceSize,
                 DeviceName,
                 FILE_DEVICE_TRANSPORT,
                 FILE_DEVICE_SECURE_OPEN,
                 FALSE,
                 &deviceObject);

    if (!NT_SUCCESS(status)) {
        IPX_DEBUG(DEVICE, ("Create device %ws failed %lx\n", DeviceName->Buffer, status));
        return status;
    }

    deviceObject->Flags |= DO_DIRECT_IO;

    Device = (PDEVICE)deviceObject->DeviceExtension;

    IPX_DEBUG(DEVICE, ("Create device %ws succeeded %lx\n", DeviceName->Buffer,Device));

    //
    // Initialize our part of the device context.
    //

    RtlZeroMemory(
        ((PUCHAR)Device) + sizeof(DEVICE_OBJECT),
        sizeof(DEVICE) - sizeof(DEVICE_OBJECT));

    Device->DeviceObject = deviceObject;

    LocksOffset = sizeof(DEVICE);
    SegmentsOffset = LocksOffset + (sizeof(CTELock) * SegmentCount);
    DeviceNameOffset = SegmentsOffset + (sizeof(ROUTER_SEGMENT) * SegmentCount);

    //
    // Set some internal pointers.
    //

    Device->SegmentLocks = (CTELock *)(((PUCHAR)Device) + LocksOffset);
    Device->Segments = (PROUTER_SEGMENT)(((PUCHAR)Device) + SegmentsOffset);
    Device->SegmentCount = SegmentCount;

    for (i = 0; i < SegmentCount; i++) {

        CTEInitLock (&Device->SegmentLocks[i]);
        InitializeListHead (&Device->Segments[i].WaitingForRoute);
        InitializeListHead (&Device->Segments[i].FindWaitingForRoute);
        InitializeListHead (&Device->Segments[i].WaitingLocalTarget);
        InitializeListHead (&Device->Segments[i].WaitingReripNetnum);
        InitializeListHead (&Device->Segments[i].Entries);
        Device->Segments[i].EnumerateLocation = &Device->Segments[i].Entries;

    }

    //
    // Copy over the device name.
    //

    Device->DeviceNameLength = DeviceName->Length + sizeof(WCHAR);
    Device->DeviceName = (PWCHAR)(((PUCHAR)Device) + DeviceNameOffset);
    RtlCopyMemory(
        Device->DeviceName,
        DeviceName->Buffer,
        DeviceName->Length);
    Device->DeviceName[DeviceName->Length/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Initialize the reference count.
    //

    Device->ReferenceCount = 1;
#if DBG
    Device->RefTypes[DREF_CREATE] = 1;
#endif

#if DBG
    RtlCopyMemory(Device->Signature1, "IDC1", 4);
    RtlCopyMemory(Device->Signature2, "IDC2", 4);
#endif

    Device->Information.Version = 0x0100;
    Device->Information.MaxSendSize = 0;   // no sends allowed
    Device->Information.MaxDatagramSize = 500;   // 500 bytes
    Device->Information.MaxConnectionUserData = 0;
    Device->Information.ServiceFlags =
        TDI_SERVICE_CONNECTIONLESS_MODE | TDI_SERVICE_BROADCAST_SUPPORTED |
        TDI_SERVICE_ROUTE_DIRECTED | TDI_SERVICE_FORCE_ACCESS_CHECK;
    Device->Information.MinimumLookaheadData = 128;
    Device->Information.NumberOfResources = IPX_TDI_RESOURCES;
    KeQuerySystemTime (&Device->Information.StartTime);

    Device->Statistics.Version = 0x0100;

#if 0
    //
    // These will be filled in after all the binding is done.
    //

    Device->Information.MaxDatagramSize = 0;
    Device->Information.MaximumLookaheadData = 0;


    Device->SourceRoutingUsed = FALSE;
    Device->SourceRoutingTime = 0;
    Device->RipPacketCount = 0;

    Device->RipShortTimerActive = FALSE;
    Device->RipSendTime = 0;
#endif


    //
    // Initialize the resource that guards address ACLs.
    //

    ExInitializeResourceLite (&Device->AddressResource);

	//
	// Init the resource that guards the binding array/indices
	//
	// CTEInitLock (&Device->BindAccessLock);

    InitializeListHead (&Device->WaitingRipPackets);
    CTEInitTimer (&Device->RipShortTimer);
    CTEInitTimer (&Device->RipLongTimer);

    CTEInitTimer (&Device->SourceRoutingTimer);

    //
    // [FW] Initialize the timer used to update inactivity counters
    // on WAN lines.
    //
    CTEInitTimer (&Device->WanInactivityTimer);

    //
    // initialize the various fields in the device context
    //

    CTEInitLock (&Device->Interlock);
    CTEInitLock (&Device->Lock);
    CTEInitLock (&Device->SListsLock);

    Device->ControlChannelIdentifier.QuadPart = 1;

    InitializeListHead (&Device->GlobalSendPacketList);
    InitializeListHead (&Device->GlobalReceivePacketList);
    InitializeListHead (&Device->GlobalReceiveBufferList);
#if BACK_FILL
    InitializeListHead (&Device->GlobalBackFillPacketList);
#endif

    InitializeListHead (&Device->AddressNotifyQueue);
    InitializeListHead (&Device->LineChangeQueue);

    for (i = 0; i < IPX_ADDRESS_HASH_COUNT; i++) {
        InitializeListHead (&Device->AddressDatabases[i]);
    }

#if BACK_FILL
    InitializeListHead (&Device->BackFillPoolList);
#endif
    InitializeListHead (&Device->SendPoolList);
    InitializeListHead (&Device->ReceivePoolList);

    InitializeListHead (&Device->BindingPoolList);

    ExInitializeSListHead (&Device->SendPacketList);
    ExInitializeSListHead (&Device->ReceivePacketList);
#if BACK_FILL
    ExInitializeSListHead (&Device->BackFillPacketList);
#endif

    ExInitializeSListHead (&Device->BindingList);

#if 0
    Device->MemoryUsage = 0;
    Device->SendPacketList.Next = NULL;
    Device->ReceivePacketList.Next = NULL;
    Device->Bindings = NULL;
    Device->BindingCount = 0;
#endif

    KeQuerySystemTime (&Device->IpxStartTime);

    Device->State = DEVICE_STATE_CLOSED;
    Device->AutoDetectState = AUTO_DETECT_STATE_INIT;
    Device->NetPnPEvent = NULL;
    Device->Type = IPX_DEVICE_SIGNATURE;
    Device->Size = sizeof (DEVICE);

#ifdef  SNMP
    //
    // what are the values for these?
    //
    IPX_MIB_ENTRY(Device, SysInstance) = 0;
    IPX_MIB_ENTRY(Device, SysExistState) = 0;
#endif SNMP

    *DevicePtr = Device;
    return STATUS_SUCCESS;

}   /* IpxCreateDevice */


VOID
IpxDestroyDevice(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine destroys a device context structure.

Arguments:

    Device - Pointer to a pointer to a transport device context object.

Return Value:

    None.

--*/

{
    PLIST_ENTRY p;
    PSLIST_ENTRY s;
    PIPX_SEND_POOL SendPool;
    PIPX_SEND_PACKET SendPacket;
    PIPX_RECEIVE_POOL ReceivePool;
    PIPX_RECEIVE_PACKET ReceivePacket;
    PIPX_ROUTE_ENTRY RouteEntry;
    UINT SendPoolSize;
    UINT ReceivePoolSize;
    UINT i;
#if BACK_FILL
    PIPX_SEND_POOL BackFillPool;
    UINT BackFillPoolSize;
    PIPX_SEND_PACKET BackFillPacket;
#endif

    PIPX_BINDING_POOL BindingPool;
    UINT BindingPoolSize;
    PBINDING Binding;

    CTELockHandle LockHandle;

    IPX_DEBUG (DEVICE, ("Destroy device %lx\n", Device));

    //
    // Take all the packets out of its pools.
    //

    BindingPoolSize = FIELD_OFFSET (IPX_BINDING_POOL, Bindings[0]) +
                       (sizeof(BINDING) * Device->InitBindings);

    while (!IsListEmpty (&Device->BindingPoolList)) {

        p = RemoveHeadList (&Device->BindingPoolList);
        BindingPool = CONTAINING_RECORD (p, IPX_BINDING_POOL, Linkage);
        IPX_DEBUG (PACKET, ("Free binding pool %lx\n", BindingPool));
        IpxFreeMemory (BindingPool, BindingPoolSize, MEMORY_PACKET, "BindingPool");

    }

#if BACK_FILL

    while (s = IPX_POP_ENTRY_LIST(&Device->BackFillPacketList, &Device->Lock)) {
        PIPX_SEND_RESERVED  Reserved = CONTAINING_RECORD (s, IPX_SEND_RESERVED, PoolLinkage);
        IPX_SEND_PACKET BackFillPacket;

        BackFillPacket.Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

        IpxDeinitializeBackFillPacket (Device, &BackFillPacket);
        Device->MemoryUsage -= sizeof(IPX_SEND_RESERVED);
    }

    while (!IsListEmpty (&Device->BackFillPoolList)) {

        p = RemoveHeadList (&Device->BackFillPoolList);
        BackFillPool = CONTAINING_RECORD (p, IPX_SEND_POOL, Linkage);

        IPX_DEBUG (PACKET, ("Free packet pool %lx\n", BackFillPool));
        NdisFreePacketPool (BackFillPool->PoolHandle);

        IpxFreeMemory (BackFillPool, sizeof(IPX_SEND_POOL), MEMORY_PACKET, "BafiPool");
    }
#endif

    while (s = IPX_POP_ENTRY_LIST(&Device->SendPacketList, &Device->Lock)){
        PIPX_SEND_RESERVED  Reserved = CONTAINING_RECORD (s, IPX_SEND_RESERVED, PoolLinkage);
        IPX_SEND_PACKET SendPacket;
        PUCHAR  Header = Reserved->Header;

        SendPacket.Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

        IpxDeinitializeSendPacket (Device, &SendPacket);
        Device->MemoryUsage -= sizeof(IPX_SEND_RESERVED);
    }

    while (!IsListEmpty (&Device->SendPoolList)) {

        p = RemoveHeadList (&Device->SendPoolList);
        SendPool = CONTAINING_RECORD (p, IPX_SEND_POOL, Linkage);

        IPX_DEBUG (PACKET, ("Free packet pool %lx\n", SendPool));
        NdisFreePacketPool (SendPool->PoolHandle);

        IpxFreeMemory (SendPool->Header, PACKET_HEADER_SIZE * Device->InitDatagrams, MEMORY_PACKET, "SendPool");

        IpxFreeMemory (SendPool, sizeof(IPX_SEND_POOL), MEMORY_PACKET, "SendPool");
    }

    while (s = IPX_POP_ENTRY_LIST(&Device->ReceivePacketList, &Device->Lock)){
        PIPX_RECEIVE_RESERVED Reserved = CONTAINING_RECORD (s, IPX_RECEIVE_RESERVED, PoolLinkage);
        IPX_RECEIVE_PACKET  ReceivePacket;

        ReceivePacket.Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

        IpxDeinitializeReceivePacket (Device, &ReceivePacket);
        Device->MemoryUsage -= sizeof(IPX_RECEIVE_RESERVED);
    }

    while (!IsListEmpty (&Device->ReceivePoolList)) {

        p = RemoveHeadList (&Device->ReceivePoolList);
        ReceivePool = CONTAINING_RECORD (p, IPX_RECEIVE_POOL, Linkage);

        IPX_DEBUG (PACKET, ("Free packet pool %lx\n", ReceivePool));
        NdisFreePacketPool (ReceivePool->PoolHandle);

        IpxFreeMemory (ReceivePool, sizeof(IPX_RECEIVE_POOL), MEMORY_PACKET, "ReceivePool");
    }

    //
    // Destroy all rip table entries.
    //

    for (i = 0; i < Device->SegmentCount; i++) {

        RouteEntry = RipGetFirstRoute(i);
        while (RouteEntry != NULL) {

            (VOID)RipDeleteRoute(i, RouteEntry);
            IpxFreeMemory(RouteEntry, sizeof(IPX_ROUTE_ENTRY), MEMORY_RIP, "RouteEntry");
            RouteEntry = RipGetNextRoute(i);

        }

    }

    IPX_DEBUG (DEVICE, ("Final memory use is %d\n", Device->MemoryUsage));
#if DBG
    for (i = 0; i < MEMORY_MAX; i++) {
        if (IpxMemoryTag[i].BytesAllocated != 0) {
            IPX_DEBUG (DEVICE, ("Tag %d: %d bytes left\n", i, IpxMemoryTag[i].BytesAllocated));
        }
    }
#endif

    //
    // If we are being unloaded then someone is waiting for this
    // event to finish the cleanup, since we may be at DISPATCH_LEVEL;
    // otherwise it is during load and we can just kill ourselves here.
    //


    CTEGetLock (&Device->Lock, &LockHandle);

    
    if (Device->UnloadWaiting) {

       CTEFreeLock (&Device->Lock, LockHandle);
       KeSetEvent(
            &Device->UnloadEvent,
            0L,
            FALSE);

    } else {
       CTEFreeLock (&Device->Lock, LockHandle);
       
       CTEAssert (KeGetCurrentIrql() < DISPATCH_LEVEL);
       ExDeleteResourceLite (&Device->AddressResource);
       IoDeleteDevice (Device->DeviceObject);
    }

}   /* IpxDestroyDevice */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\event.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    event.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiSetEventHandler

Environment:

    Kernel mode

Revision History:

   Sanjay Anand (SanjayAn) 3-Oct-1995
   Changes to support transfer of buffer ownership to transports

   1. Added a new event type - TDI_EVENT_CHAINED_RECEIVE_DATAGRAM
--*/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
IpxTdiSetEventHandler(
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiSetEventHandler request for the
    transport provider.  The caller (request dispatcher) verifies
    that this routine will not be executed on behalf of a user-mode
    client, as this request enables direct callouts at DISPATCH_LEVEL.

Arguments:

    Request - Pointer to the request

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status;
    CTELockHandle LockHandle;
    PTDI_REQUEST_KERNEL_SET_EVENT Parameters;
    PADDRESS_FILE AddressFile;

    //
    // Get the Address this is associated with; if there is none, get out.
    //

    AddressFile  = REQUEST_OPEN_CONTEXT(Request);
    Status = IpxVerifyAddressFile (AddressFile);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    CTEGetLock (&AddressFile->Address->Lock, &LockHandle);

    Parameters = (PTDI_REQUEST_KERNEL_SET_EVENT)REQUEST_PARAMETERS(Request);

    switch (Parameters->EventType) {

    case TDI_EVENT_RECEIVE_DATAGRAM:

        if (Parameters->EventHandler == NULL) {
            AddressFile->ReceiveDatagramHandler =
                (PTDI_IND_RECEIVE_DATAGRAM)TdiDefaultRcvDatagramHandler;
            AddressFile->ReceiveDatagramHandlerContext = NULL;
            AddressFile->RegisteredReceiveDatagramHandler = FALSE;
        } else {
            AddressFile->ReceiveDatagramHandler =
                (PTDI_IND_RECEIVE_DATAGRAM)Parameters->EventHandler;
            AddressFile->ReceiveDatagramHandlerContext = Parameters->EventContext;
            AddressFile->RegisteredReceiveDatagramHandler = TRUE;
        }

        break;
    //
    // [SA] New event handler to receive chained buffers
    //
    case TDI_EVENT_CHAINED_RECEIVE_DATAGRAM:

        if (Parameters->EventHandler == NULL) {
            AddressFile->ChainedReceiveDatagramHandler =
                (PTDI_IND_CHAINED_RECEIVE_DATAGRAM)TdiDefaultChainedRcvDatagramHandler;
            AddressFile->ChainedReceiveDatagramHandlerContext = NULL;
            AddressFile->RegisteredChainedReceiveDatagramHandler = FALSE;
        } else {
            AddressFile->ChainedReceiveDatagramHandler =
                (PTDI_IND_CHAINED_RECEIVE_DATAGRAM)Parameters->EventHandler;
            AddressFile->ChainedReceiveDatagramHandlerContext = Parameters->EventContext;
            AddressFile->RegisteredChainedReceiveDatagramHandler = TRUE;
        }

        break;

    case TDI_EVENT_ERROR:

        if (Parameters->EventHandler == NULL) {
            AddressFile->ErrorHandler =
                (PTDI_IND_ERROR)TdiDefaultErrorHandler;
            AddressFile->ErrorHandlerContext = NULL;
            AddressFile->RegisteredErrorHandler = FALSE;
        } else {
            AddressFile->ErrorHandler =
                (PTDI_IND_ERROR)Parameters->EventHandler;
            AddressFile->ErrorHandlerContext = Parameters->EventContext;
            AddressFile->RegisteredErrorHandler = TRUE;
        }

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;

    } /* switch */

    CTEFreeLock (&AddressFile->Address->Lock, LockHandle);

    IpxDereferenceAddressFile (AddressFile, AFREF_VERIFY);

    REQUEST_INFORMATION(Request) = 0;

    return Status;

}   /* IpxTdiSetEventHandler */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\ind.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ind.c

Abstract:

    This module contains code which implements the indication handler
    for the IPX transport provider.

Environment:

    Kernel mode

Revision History:

   Sanjay Anand (SanjayAn) 3-Oct-1995
   Changes to support transfer of buffer ownership to transports

   1. Added IpxReceivePacket which receives buffers that can be owned
   2. Changed IpxReceiveIndication to call a new function IpxReceiveIndicationCommon
   which takes an extra parameter to indicate whether this is a chained receive or
   not.
   3. Changed IpxProcessDatagram to take the MDL ptr to indicate chained receive,
   a client count and the headerbuffersize as params.

   Sanjay Anand (SanjayAn) 27-Oct-1995
   Changes to support Plug and Play

--*/

#include "precomp.h"
#pragma hdrstop

#include "isnnb.h"

UINT 
IpxGetChainedMDLLength( PNDIS_BUFFER pMDL ) {

   UINT size = 0;
   if (pMDL != NULL) {
     do {
       size += NdisBufferLength(pMDL);
       pMDL = NDIS_BUFFER_LINKAGE(pMDL);
     } while (pMDL != NULL);
   }

   return size; 
}
//
// This is declared here so it will be in the same function
// as IpxReceiveIndication and we can inline it.
//



#if defined(_M_IX86)
_inline
#endif
VOID
IpxProcessDatagram(
    IN PDEVICE Device,
    IN PADAPTER Adapter,
    IN PBINDING Binding,
    IN NDIS_HANDLE MacReceiveContext,
    IN PIPX_DATAGRAM_OPTIONS DatagramOptions,
    IN PUCHAR LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT LookaheadBufferOffset,
    IN UINT PacketSize,
    IN BOOLEAN Broadcast,
    IN PINT pTdiClientCount,
	IN UINT	HeaderBufferSize,
	IN PMDL	pMdl,
    IN NDIS_HANDLE  BindingContext
    )

/*++

Routine Description:

    This routing handles incoming IPX datagrams.

Arguments:

    Device - The IPX device.

    Adapter - The adapter the frame was received on.

    Binding - The binding of the adapter it was received on.

    MacReceiveContext - The context to use when calling
        NdisTransferData.

    DatagramOptions - Contains the datagram options, which
        consists of room for the packet type, padding, and
        the local target of the remote the frame was received from.

    LookaheadBuffer - The lookahead data.

    LookaheadBufferSize - The length of the lookahead data.

    LookaheadBufferOffset - The offset to add when calling
        NdisTransferData.

    PacketSize - The length of the packet, starting at the IPX
        header.

    Broadcast - TRUE if the packet was broadcast.

	pTdiClientCount - to return count of the number of TDI clients above us
		so NDIS can obtain that many ref counts on the buffer.

	HeaderBufferSize - the size of the MAC header buffer - used to determine
		the offsets into the TSDU.

	pMdl -  Mdl chain pointer - non-NULL if chained receive

    BindingContext - In case of loopback, this contains IPX_LOOPBACK_COOKIE

Return Value:

    NTSTATUS - status of operation.

--*/

{

    PIPX_HEADER IpxHeader = (PIPX_HEADER)LookaheadBuffer;
    PADDRESS Address;
    PADDRESS_FILE AddressFile;
    PADDRESS_FILE ReferencedAddressFile;
    PREQUEST Request;
    PIPX_RECEIVE_BUFFER ReceiveBuffer;
    PTDI_CONNECTION_INFORMATION DatagramInformation;
    TDI_ADDRESS_IPX UNALIGNED * DatagramAddress;
    ULONG IndicateBytesCopied;
    IPX_ADDRESS_EXTENDED_FLAGS SourceAddress;
    ULONG SourceAddressLength;
    ULONG RequestCount;
    PNDIS_BUFFER NdisBuffer;
    NDIS_STATUS NdisStatus;
    NTSTATUS Status;
    PIRP Irp;
    UINT ByteOffset, BytesToTransfer;
    ULONG BytesTransferred;
    BOOLEAN LastAddressFile;
    ULONG IndicateOffset;
    PNDIS_PACKET ReceivePacket;
    PIPX_RECEIVE_RESERVED Reserved;
    PLIST_ENTRY p, q;
    PSLIST_ENTRY s;
    USHORT DestinationSocket;
    USHORT SourceSocket;
    ULONG Hash;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)
    PIPX_DATAGRAM_OPTIONS2 Options2;
    BOOLEAN RtProc = FALSE;

    UINT LookaheadBufferOffsetCopy = LookaheadBufferOffset; 

	//
    // First scan the device's address database, looking for
    // the destination socket of this frame.
    //

    DestinationSocket = *(USHORT UNALIGNED *)&IpxHeader->DestinationSocket;

    IPX_GET_LOCK (&Device->Lock, &LockHandle);

    if ((Address = Device->LastAddress) &&
            (Address->Socket == DestinationSocket)) {

        //
        // Device->LastAddress cannot be stopping, so
        // we use it.
        //

        IpxReferenceAddressLock (Address, AREF_RECEIVE);
        IPX_FREE_LOCK (&Device->Lock, LockHandle);
        goto FoundAddress;
    }

    Hash = IPX_DEST_SOCKET_HASH (IpxHeader);

    for (p = Device->AddressDatabases[Hash].Flink;
         p != &Device->AddressDatabases[Hash];
         p = p->Flink) {

         Address = CONTAINING_RECORD (p, ADDRESS, Linkage);

         if ((Address->Socket == DestinationSocket) &&
             (!Address->Stopping)) {
            IpxReferenceAddressLock (Address, AREF_RECEIVE);
            Device->LastAddress = Address;
            IPX_FREE_LOCK (&Device->Lock, LockHandle);
            goto FoundAddress;
         }
    }

    IPX_FREE_LOCK (&Device->Lock, LockHandle);

    //
    // If we had found an address we would have jumped
    // past here.
    //

#ifdef  SNMP
    ++IPX_MIB_ENTRY(Device, SysInUnknownSockets);
#endif  SNMP

    return;

FoundAddress:

    SourceSocket = *(USHORT UNALIGNED *)&IpxHeader->SourceSocket;
    IpxBuildTdiAddress(
        &SourceAddress.IpxAddress,
        (*(ULONG UNALIGNED *)(IpxHeader->SourceNetwork) == 0) ?
            Binding->LocalAddress.NetworkAddress :
            *(UNALIGNED ULONG *)(IpxHeader->SourceNetwork),
        IpxHeader->SourceNode,
        SourceSocket);

    DatagramOptions->PacketType = IpxHeader->PacketType;


    //
    // Now that we have found the address, scan its list of
    // address files for clients that want this datagram.
    //
    // If we have to release the address lock to indicate to
    // a client, we reference the current address file. If
    // we get an IRP we transfer the reference to that;
    // otherwise we store the address file in ReferencedAddressFile
    // and deref it the next time we release the lock.
    //

    ReferencedAddressFile = NULL;
    RequestCount = 0;

    // ++Device->TempDatagramsReceived;
    // Device->TempDatagramBytesReceived += (PacketSize - sizeof(IPX_HEADER));

    Device->Statistics.DatagramsReceived++; 

    ADD_TO_LARGE_INTEGER(
        &Device->Statistics.DatagramBytesReceived,
        PacketSize - sizeof(IPX_HEADER));

    //
    // If LastAddressFile is TRUE, it means we did an indication
    // to the client on the last address file in the address'
    // list, and we did not reacquire the lock when we were
    // done.
    //

    LastAddressFile = FALSE;

    IPX_GET_LOCK (&Address->Lock, &LockHandle);

    //
    // If this is RtAdd, skip the entire body
    //
    if (!Address->RtAdd)
    {
        for (p = Address->AddressFileDatabase.Flink;
             p != &Address->AddressFileDatabase;
             p = p->Flink) {

            AddressFile = CONTAINING_RECORD (p, ADDRESS_FILE, Linkage);

            if (AddressFile->State != ADDRESSFILE_STATE_OPEN) {
                continue;   // next address file
            }

            //
            // Set these to the common values, then change them.
            //

            SourceAddressLength = sizeof(TA_IPX_ADDRESS);
            IndicateOffset = sizeof(IPX_HEADER);

            if (AddressFile->SpecialReceiveProcessing) {

                //
                // On dial out lines, we don't indicate packets to
                // the SAP socket if DisableDialoutSap is set.
                //

                //
                // [FW] no need to check if the FWD is bound
                //
                if (!Device->ForwarderBound &&
                    (AddressFile->IsSapSocket) &&
                    (Binding->DialOutAsync) &&
                    (Device->DisableDialoutSap || Device->SingleNetworkActive)) {

                    //
                    // Go to the next address file (although it will
                    // likely fail this test too).
                    //

                    continue;

                }

                //
                // Set this, since generally we want it.
                //

                SourceAddress.PacketType = IpxHeader->PacketType;

                //
                // See if we fail a packet type filter.
                //

                if (AddressFile->FilterOnPacketType) {
                    if (AddressFile->FilteredType != IpxHeader->PacketType) {
                        continue;
                    }
                }

                //
                // Calculate how long the addresses expected are.
                //

                if (AddressFile->ReceiveFlagsAddressing ||
                    AddressFile->ExtendedAddressing) {

                    SourceAddress.Flags = 0;
                    if (Broadcast) {
                        SourceAddress.Flags = IPX_EXTENDED_FLAG_BROADCAST;
                    }
                    if (IpxIsAddressLocal((TDI_ADDRESS_IPX UNALIGNED *)
                                &SourceAddress.IpxAddress.Address[0].Address[0])) {
                        SourceAddress.Flags |= IPX_EXTENDED_FLAG_LOCAL;
                    }
                    SourceAddressLength = sizeof(IPX_ADDRESS_EXTENDED_FLAGS);
                    SourceAddress.IpxAddress.Address[0].AddressLength +=
                        (sizeof(IPX_ADDRESS_EXTENDED_FLAGS) - sizeof(TA_IPX_ADDRESS));

                }

                //
                // Determine how much of the packet the client wants.
                //

                if (AddressFile->ReceiveIpxHeader) {
                    IndicateOffset = 0;
                }
            }

            //
            // First scan the address' receive datagram queue
            // for datagrams that match. We do a quick check
            // to see if the list is empty.
            //

            q = AddressFile->ReceiveDatagramQueue.Flink;
            if (q != &AddressFile->ReceiveDatagramQueue) {

                do {

                    Request = LIST_ENTRY_TO_REQUEST(q);

                    DatagramInformation =
                        ((PTDI_REQUEST_KERNEL_RECEIVEDG)(REQUEST_PARAMETERS(Request)))->
                            ReceiveDatagramInformation;

                    if ((DatagramInformation != NULL) &&
                        (DatagramInformation->RemoteAddress != NULL) &&
                        (DatagramAddress = IpxParseTdiAddress(DatagramInformation->RemoteAddress)) &&
                        (DatagramAddress->Socket != SourceSocket)) {

                        //
                        // The address that this datagram is looking for is
                        // not satisfied by this frame.
                        //
                        // Speed this up; worry about node and network?
                        //

                        q = q->Flink;
                        continue;    // next receive datagram on this address file

                    } else {

                        //
                        // We found a datagram on the queue.
                        //

                        IPX_DEBUG (RECEIVE, ("Found RDG on %lx\n", AddressFile));
                        RemoveEntryList (q);
                        REQUEST_INFORMATION(Request) = 0;

                        goto HandleDatagram;

                    }

                } while (q != &AddressFile->ReceiveDatagramQueue);

            }

            //
            // If we found a datagram we would have jumped past here,
            // so looking for a datagram failed; see if the
            // client has a receive datagram handler registered.
            //

            //
            // Look for the chained receive handler if the MDL is not NULL
            //
            if (pMdl && AddressFile->RegisteredChainedReceiveDatagramHandler) {

	       // Set to original value when this function was initially called. 
	       LookaheadBufferOffset = LookaheadBufferOffsetCopy; 
    			//
    			// Chained receive both above and below => we indicate the entire MDL up.
    			// Offset the LookaheadBuffer by the size of the MAC header.
    			//
    			LookaheadBufferOffset += HeaderBufferSize;

                IpxReferenceAddressFileLock (AddressFile, AFREF_INDICATION);

                //
                // Set this so we can exit without reacquiring
                // the lock.
                //

                if (p == &Address->AddressFileDatabase) {
                    LastAddressFile = TRUE;
                }

                IndicateBytesCopied = 0;

                IPX_FREE_LOCK (&Address->Lock, LockHandle);

                if (ReferencedAddressFile) {
                    IpxDereferenceAddressFileSync (ReferencedAddressFile, AFREF_INDICATION);
                    ReferencedAddressFile = NULL;
                }

                IPX_DEBUG(RECEIVE, ("AddressFile (%p) ChainedIndicate RecvLen: %d, StartOffset: %d, Tsdu: %lx\n",
                   AddressFile, PacketSize - IndicateOffset, IndicateOffset+LookaheadBufferOffset, pMdl));

                //
                // Will return SUCCESS if the client did not take ownership of the Tsdu
                // PENDING if the client took ownership and will free it later (using TdiFreeReceiveChain).
                // DATA_NOT_ACCEPTED if the client did not take ownership and did not copy the data.
                //

                //
                // Since NDIS needs an array of PNDIS_PACKETs when the TDI client returns this packet,
                // we pass the Packet as the ReceiveContext here. The TDI client will pass in the address
                // of this context on a ReturnPacket.
                // Also, NDIS needs the PacketArray (not to be confused with the array of packetptrs. mentioned
                // above) on an NdisTransferData call. These clients dont do this, but other clients like
                // NB, SPX, RIP or TDI clients that do not have this new interface, can call NdisTransferData
                // so we pass in the PacketArray as a parameter to them.
                //
                Status = (*AddressFile->ChainedReceiveDatagramHandler)(
                             AddressFile->ChainedReceiveDatagramHandlerContext,
                             SourceAddressLength,
                             &SourceAddress,
                             sizeof(IPX_DATAGRAM_OPTIONS),
                             DatagramOptions,
                             Adapter->MacInfo.CopyLookahead,       // TdiRcvFlags|Adapter->MacInfo.CopyLookahead, Receive datagram flags
                             PacketSize - IndicateOffset,          // ReceiveLength
                             IndicateOffset+LookaheadBufferOffset, // StartingOffset
                             pMdl,			                       // Tsdu - MDL chain
                             (PNDIS_PACKET)MacReceiveContext);     // TransportContext - pointer to the packet

                if (Status != STATUS_DATA_NOT_ACCEPTED) {

    				if (Status == STATUS_PENDING) {
    					//
    					// We assume here that the client referenced the packet which will
    					// be removed when the packet is freed.
    					// Increment the Tdi client count
    					//
    					(*pTdiClientCount)++;
    				}

                    //
                    // The handler accepted the data or did not
                    // return an IRP; in either case there is
                    // nothing else to do, so go to the next
                    // address file.
                    //

                    ReferencedAddressFile = AddressFile;
                    if (!LastAddressFile) {

                        IPX_GET_LOCK (&Address->Lock, &LockHandle);
                        continue;

                    } else {

                        //
                        // In this case we have no cleanup, so just leave
                        // if there are no datagrams pending.
                        //
    					// RequestCount should always be 0 here.
    					//


                        //if (RequestCount == 0) {
                        //    return;
                        //}
                        goto BreakWithoutLock;
                    }

                } else {
    				//
    				// Since no IRP can be returned here, we continue to the next addressfile
    				//

                    ReferencedAddressFile = AddressFile;
                    if (!LastAddressFile) {

                        IPX_GET_LOCK (&Address->Lock, &LockHandle);
                        continue;

                    } else {

                        //
                        // In this case we have no cleanup, so just leave
                        // if there are no datagrams pending.
                        //

                        //if (RequestCount == 0) {
                        //    return;
                        //}
                        goto BreakWithoutLock;
    				}
                }

            } else if (AddressFile->RegisteredReceiveDatagramHandler) {

                IpxReferenceAddressFileLock (AddressFile, AFREF_INDICATION);

                //
                // Set this so we can exit without reacquiring
                // the lock.
                //

                if (p == &Address->AddressFileDatabase) {
                    LastAddressFile = TRUE;
                }

                IPX_FREE_LOCK (&Address->Lock, LockHandle);

                if (ReferencedAddressFile) {
                    IpxDereferenceAddressFileSync (ReferencedAddressFile, AFREF_INDICATION);
                    ReferencedAddressFile = NULL;
                }

                IndicateBytesCopied = 0;

                if (PacketSize > LookaheadBufferSize) {
                    IPX_DEBUG(RECEIVE, ("Indicate %d/%d to %lx on %lx\n",
                        LookaheadBufferSize, PacketSize,
                        AddressFile->ReceiveDatagramHandler, AddressFile));
                }

                Status = (*AddressFile->ReceiveDatagramHandler)(
                             AddressFile->ReceiveDatagramHandlerContext,
                             SourceAddressLength,
                             &SourceAddress,
                             sizeof(IPX_DATAGRAM_OPTIONS),
                             DatagramOptions,
                             Adapter->MacInfo.CopyLookahead,
                             LookaheadBufferSize - IndicateOffset, // indicated
                             PacketSize - IndicateOffset,          // available
                             &IndicateBytesCopied,                 // taken
                             LookaheadBuffer + IndicateOffset,     // data
                             &Irp);


                if (Status != STATUS_MORE_PROCESSING_REQUIRED) {

                    //
                    // The handler accepted the data or did not
                    // return an IRP; in either case there is
                    // nothing else to do, so go to the next
                    // address file.
                    //

                    ReferencedAddressFile = AddressFile;
                    if (!LastAddressFile) {

                        IPX_GET_LOCK (&Address->Lock, &LockHandle);
                        continue;

                    } else {

                        //
                        // In this case we have no cleanup, so just leave
                        // if there are no datagrams pending.
                        //

                        if (RequestCount == 0) {
                            return;
                        }
                        goto BreakWithoutLock;
                    }

                } else {

                    //
                    // The client returned an IRP.
                    //

                    IPX_DEBUG (RECEIVE, ("Indicate IRP %lx, taken %d\n", Irp, IndicateBytesCopied));

                    Request = IpxAllocateRequest (Device, Irp);

                    IF_NOT_ALLOCATED(Request) {
                        Irp->IoStatus.Information = 0;
                        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
                        ReferencedAddressFile = AddressFile;
                        IPX_GET_LOCK (&Address->Lock, &LockHandle);
                        continue;
                    }

                    if (!LastAddressFile) {
                        IPX_GET_LOCK (&Address->Lock, &LockHandle);
                    }

    #if DBG
                    //
                    // Make sure the IRP file object is right.
                    //

                    if (IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext != AddressFile) {
                        DbgPrint ("IRP %lx does not match AF %lx, H %lx C %lx\n",
                            Irp, AddressFile,
                            AddressFile->ReceiveDatagramHandler,
                            AddressFile->ReceiveDatagramHandlerContext);
                        DbgBreakPoint();
                    }
    #endif
                    //
                    // Set up the information field so we know
                    // how much to skip in it.
                    //

                    IpxTransferReferenceAddressFile (AddressFile, AFREF_INDICATION, AFREF_RCV_DGRAM);
                    REQUEST_INFORMATION(Request) = IndicateBytesCopied;

                    //
                    // Fall out of the if and continue via
                    // HandleDatagram...
                    //

                }

            } else {

                //
                // No posted datagram, no handler; go to the next
                // address file.
                //

                continue;    // next address file

            }

    HandleDatagram:

            //
            // At this point, Request is set to the request
            // that will hold for this address file, and
            // REQUEST_INFORMATION() is the offset to start
            // the transfer at.
            //

            //
            // First copy over the source address while it is handy.
            //

            DatagramInformation =
                ((PTDI_REQUEST_KERNEL_RECEIVEDG)(REQUEST_PARAMETERS(Request)))->
                    ReturnDatagramInformation;

            if (DatagramInformation != NULL) {

                RtlCopyMemory(
                    DatagramInformation->RemoteAddress,
                    &SourceAddress,
                    (ULONG)DatagramInformation->RemoteAddressLength < SourceAddressLength ?
                        DatagramInformation->RemoteAddressLength : SourceAddressLength);
                RtlCopyMemory(
                    DatagramInformation->Options,
                    &DatagramOptions,
                    (ULONG)DatagramInformation->OptionsLength < sizeof(IPX_DATAGRAM_OPTIONS) ?
                        DatagramInformation->OptionsLength : sizeof(IPX_DATAGRAM_OPTIONS));

            }

            //
            // Now check if this is the first request that will
            // take the data, otherwise queue it up.
            //

            if (RequestCount == 0) {

                //
                // First one; we need to allocate a packet for the transfer.
                //

                //if (Address->ReceivePacketInUse) {
                if (InterlockedExchangeAdd(&Address->ReceivePacketInUse, 0) != 0) {
                    //
                    // Need a packet, check the pool.
                    //

                    s = IpxPopReceivePacket (Device);

                    if (s == NULL) {

                        //
                        // None in pool, fail the request.
                        //

                        REQUEST_INFORMATION(Request) = 0;
                        REQUEST_STATUS(Request) = STATUS_INSUFFICIENT_RESOURCES;
                        IPX_INSERT_TAIL_LIST(
                            &Adapter->RequestCompletionQueue,
                            REQUEST_LINKAGE(Request),
                            Adapter->DeviceLock);

                        if (!LastAddressFile) {
                            continue;
                        } else {
                            goto BreakWithoutLock;
                        }

                    }

                    Reserved = CONTAINING_RECORD (s, IPX_RECEIVE_RESERVED, PoolLinkage);
                    ReceivePacket = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

                } else {

                    // Address->ReceivePacketInUse = TRUE;
                    InterlockedIncrement(&Address->ReceivePacketInUse);

                    ReceivePacket = PACKET(&Address->ReceivePacket);
                    Reserved = RECEIVE_RESERVED(&Address->ReceivePacket);

                }

                CTEAssert (IsListEmpty(&Reserved->Requests));

                Reserved->SingleRequest = Request;
                NdisBuffer = REQUEST_NDIS_BUFFER(Request);
#ifdef SUNDOWN
		// NdisCopyFromPacketToPacket and NdisTransferData only takes UINT
                ByteOffset = (UINT) (REQUEST_INFORMATION(Request)) + LookaheadBufferOffset + IndicateOffset;
#else
                ByteOffset = REQUEST_INFORMATION(Request) + LookaheadBufferOffset + IndicateOffset;
#endif


                BytesToTransfer =
                    ((PTDI_REQUEST_KERNEL_RECEIVEDG)(REQUEST_PARAMETERS(Request)))->ReceiveLength;

		if (BytesToTransfer == 0) {
                   BytesToTransfer = IpxGetChainedMDLLength(NdisBuffer); 
		   IPX_DEBUG(RECEIVE, ("0 length in IRP, Use entire MDL buffer size %d\n", BytesToTransfer)); 
		}

                if (BytesToTransfer > (PacketSize - IndicateOffset)) {
                    BytesToTransfer = PacketSize - IndicateOffset;
                }

            } else {

                if (RequestCount == 1) {

                    //
                    // There is already one request. We need to
                    // allocate a buffer.
                    //

                    s = IpxPopReceiveBuffer (Adapter);

                    if (s == NULL) {

                        //
                        // No buffers, fail the request.
                        //
                        // Should we fail the transfer for the first request too?
                        //

                        REQUEST_INFORMATION(Request) = 0;
                        REQUEST_STATUS(Request) = STATUS_INSUFFICIENT_RESOURCES;
                        IPX_INSERT_TAIL_LIST(
                            &Adapter->RequestCompletionQueue,
                            REQUEST_LINKAGE(Request),
                            Adapter->DeviceLock);

                        if (!LastAddressFile) {
                            continue;
                        } else {
                            goto BreakWithoutLock;
                        }
                    }

                    ReceiveBuffer = CONTAINING_RECORD(s, IPX_RECEIVE_BUFFER, PoolLinkage);
                    NdisBuffer = ReceiveBuffer->NdisBuffer;

                    //
                    // Convert this to a queued multiple piece request.
                    //

                    InsertTailList(&Reserved->Requests, REQUEST_LINKAGE(Reserved->SingleRequest));
                    Reserved->SingleRequest = NULL;
                    Reserved->ReceiveBuffer = ReceiveBuffer;

                    ByteOffset = LookaheadBufferOffset;
                    BytesToTransfer = PacketSize;

                }

                InsertTailList(&Reserved->Requests, REQUEST_LINKAGE(Request));

            }

            //
            // We are done setting up this address file's transfer,
            // proceed to the next one.
            //

            ++RequestCount;

            if (LastAddressFile) {
                goto BreakWithoutLock;
            }

        }
    } else {

            //IpxPrint0("IpxProcessDatagram: Rt packet\n");
            if (Address->ReceivePacketInUse) {
                //
                // Need a packet, check the pool.
                //

                s = IpxPopReceivePacket (Device);

                if (s == NULL) {

                        goto BreakWithLock;
                    }


                Reserved = CONTAINING_RECORD (s, IPX_RECEIVE_RESERVED, PoolLinkage);
                ReceivePacket = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

            } else {

                Address->ReceivePacketInUse = TRUE;
                ReceivePacket = PACKET(&Address->ReceivePacket);
                Reserved = RECEIVE_RESERVED(&Address->ReceivePacket);

            }
            //IpxPrint0("IpxProcessDatagram: Rt packet reserved\n");
            s = IpxPopReceiveBuffer (Adapter);

            if (s == NULL) {

                    //
                    // No buffers, fail the request.
                    //
                    // Should we fail the transfer for the first request too?
                    //
                        goto BreakWithLock;
                    }

            ReceiveBuffer = CONTAINING_RECORD(s, IPX_RECEIVE_BUFFER, PoolLinkage);
            NdisBuffer = ReceiveBuffer->NdisBuffer;
            Reserved->ReceiveBuffer = ReceiveBuffer;
            ByteOffset = LookaheadBufferOffset;
            BytesToTransfer = PacketSize;
            //IpxPrint0("IpxProcessDatagram: Rt packet buffer reserved\n");
            RtProc = TRUE;
            Reserved->Index = Address->Index;

    }

BreakWithLock:

    IPX_FREE_LOCK (&Address->Lock, LockHandle);

BreakWithoutLock:

    if (ReferencedAddressFile) {
        IpxDereferenceAddressFileSync (ReferencedAddressFile, AFREF_INDICATION);
        ReferencedAddressFile = NULL;
    }


    //
    // We can be transferring directly into a request's buffer,
    // transferring into an intermediate buffer, or not
    // receiving the packet at all.
    //

    if (RequestCount > 0 || RtProc) {

        if (RtProc) {
            Reserved->pContext = IpxAllocateMemory(sizeof(IPX_DATAGRAM_OPTIONS2), MEMORY_PACKET, "RT Options");
            if (!Reserved->pContext) {

                  ASSERTMSG("Out of resources\n", 1);
                  goto GetOut;
            } else {
              //IpxPrint1("IpxProcessDatagram: Nic Id is (%d)\n", DatagramOptions->LocalTarget.NicId);
              RtlCopyMemory(
                &((PIPX_DATAGRAM_OPTIONS2)(Reserved->pContext))->DgrmOptions,
                DatagramOptions,
                sizeof(IPX_DATAGRAM_OPTIONS));
             //IpxPrint1("IpxProcessDatagram: Nic Id is (%d)\n",
            //                    ((PIPX_DATAGRAM_OPTIONS2)(Reserved->pContext))->DgrmOptions.LocalTarget.NicId);
            }
        } else {
            Reserved->pContext = NULL;
        }

        //
        // If this is true, then ReceivePacket, Reserved,
        // and NdisBuffer are all set up correctly.
        //

        CTEAssert (ReceivePacket);
        CTEAssert (Reserved == (PIPX_RECEIVE_RESERVED)(ReceivePacket->ProtocolReserved));


        NdisChainBufferAtFront(ReceivePacket, NdisBuffer);

        IPX_DEBUG (RECEIVE, ("Transfer into %lx, offset %d bytes %d\n",
                                  NdisBuffer, ByteOffset, BytesToTransfer));

        if (BindingContext == (PVOID)IPX_LOOPBACK_COOKIE) {

            IPX_DEBUG (LOOPB, ("Loopback Copy from packet: %lx to packet: %lx\n", ReceivePacket, MacReceiveContext));

            NdisCopyFromPacketToPacketSafe(
                ReceivePacket,      // Destination
                0,                  // DestinationOffset
                BytesToTransfer,    // BytesToCopy
                (PNDIS_PACKET)MacReceiveContext,    // Source
                ByteOffset,                 // SourceOffset - loopback packet
                &BytesTransferred,          // BytesCopied
                NormalPagePriority);

            NdisStatus = ((BytesTransferred == BytesToTransfer)? NDIS_STATUS_SUCCESS : NDIS_STATUS_RESOURCES);

        } else {
            NdisTransferData(
                &NdisStatus,
                Adapter->NdisBindingHandle,
                MacReceiveContext,
                ByteOffset,
                BytesToTransfer,
                ReceivePacket,
                &BytesTransferred);
        }

        if (NdisStatus != NDIS_STATUS_PENDING) {

            IpxTransferDataComplete(
                (NDIS_HANDLE)Adapter,
                ReceivePacket,
                NdisStatus,
                BytesTransferred);
        }
    }
#ifdef  SNMP
    else {
        ++IPX_MIB_ENTRY(Device, SysInUnknownSockets);
    }
#endif  SNMP

GetOut:

    // IpxDereferenceAddressSync (Address, AREF_RECEIVE);
    IpxDereferenceAddress (Address, AREF_RECEIVE);

}   /* IpxProcessDatagram */



NDIS_STATUS
IpxReceiveIndication(
    IN NDIS_HANDLE BindingContext,
    IN NDIS_HANDLE ReceiveContext,
    IN PVOID HeaderBuffer,
    IN UINT HeaderBufferSize,
    IN PVOID LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT PacketSize
    )

/*++

Routine Description:

    This routine receives control from the physical provider as an
    indication that a frame has been received on the physical link.
    This routine is time critical, so we only allocate a
    buffer and copy the packet into it. We also perform minimal
    validation on this packet. It gets queued to the device context
    to allow for processing later.

Arguments:

    BindingContext - The Adapter Binding specified at initialization time.

    ReceiveContext - A magic cookie for the MAC.

    HeaderBuffer - pointer to a buffer containing the packet header.

    HeaderBufferSize - the size of the header.

    LookaheadBuffer - pointer to a buffer containing the negotiated minimum
        amount of buffer I get to look at (not including header).

    LookaheadBufferSize - the size of the above. May be less than asked
        for, if that's all there is.

    PacketSize - Overall size of the packet (not including header).

Return Value:

    NDIS_STATUS - status of operation, one of:

                 NDIS_STATUS_SUCCESS if packet accepted,
                 NDIS_STATUS_NOT_RECOGNIZED if not recognized by protocol,
                 NDIS_any_other_thing if I understand, but can't handle.

--*/
{
   //
   // Call the actual receive indication handler and indicate that this is not a
   // chained receive
   //

   return IpxReceiveIndicationCommon (
            BindingContext,
            ReceiveContext,         // ReceiveContext
            HeaderBuffer,
            HeaderBufferSize,
            LookaheadBuffer,
            LookaheadBufferSize,
            PacketSize,    			// PacketSize
			NULL,					// pMdl - non-NULL => chained receive.
			NULL					// pTdiClientCount - used in chained recv case to keep count of TDI clients
            );

}


NDIS_STATUS
IpxReceiveIndicationCommon(
    IN NDIS_HANDLE BindingContext,
    IN NDIS_HANDLE ReceiveContext,
    IN PVOID HeaderBuffer,
    IN UINT HeaderBufferSize,
    IN PVOID LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT PacketSize,
	IN PMDL	pMdl,
	IN PINT pTdiClientCount
    )

/*++

Routine Description:

    This routine receives control from the physical provider as an
    indication that a frame has been received on the physical link.
    This routine is time critical, so we only allocate a
    buffer and copy the packet into it. We also perform minimal
    validation on this packet. It gets queued to the device context
    to allow for processing later.

Arguments:

    BindingContext - The Adapter Binding specified at initialization time.

    ReceiveContext - A magic cookie for the MAC.

    HeaderBuffer - pointer to a buffer containing the packet header.

    HeaderBufferSize - the size of the header.

    LookaheadBuffer - pointer to a buffer containing the negotiated minimum
        amount of buffer I get to look at (not including header).

    LookaheadBufferSize - the size of the above. May be less than asked
        for, if that's all there is.

    PacketSize - Overall size of the packet (not including header).

	pMdl -  pointer to MDL chain if chained, NULL if this came from indication.

Return Value:

    NDIS_STATUS - status of operation, one of:

                 NDIS_STATUS_SUCCESS if packet accepted,
                 NDIS_STATUS_NOT_RECOGNIZED if not recognized by protocol,
                 NDIS_any_other_thing if I understand, but can't handle.

--*/
{

    IPX_DATAGRAM_OPTIONS DatagramOptions;
    PADAPTER Adapter = (PADAPTER)BindingContext;
    PBINDING Binding;
    PDEVICE Device = IpxDevice;
    PUCHAR Header = (PUCHAR)HeaderBuffer;
    PUCHAR Lookahead = (PUCHAR)LookaheadBuffer;
    ULONG PacketLength;
    UINT IpxPacketSize;
    ULONG Length802_3;
    USHORT Saps;
    ULONG DestinationNetwork;
    ULONG SourceNetwork;
    PUCHAR DestinationNode;
    USHORT DestinationSocket;
    ULONG IpxHeaderOffset;
    PIPX_HEADER IpxHeader;
    UINT i;
    BOOLEAN IsBroadcast;
    BOOLEAN IsLoopback = FALSE;
#if DBG
    PUCHAR DestMacAddress;
    ULONG ReceiveFlag;
#endif
    BOOLEAN fCallProcessDatagram = FALSE;

	IPX_DEFINE_LOCK_HANDLE(LockHandle1)

    //
    // Reject packets that are too short to hold even the
    // basic IPX header (this ignores any extra 802.2 etc.
    // headers but is good enough because a runt will fail
    // the IPX header packet length check).
    //

    if (PacketSize < sizeof(IPX_HEADER)) {
#ifdef  SNMP
        ++IPX_MIB_ENTRY(Device, SysInReceives);
        ++IPX_MIB_ENTRY(Device, SysInHdrErrors);
#endif  SNMP
        return STATUS_SUCCESS;
    }

    //
    // If this is a loopback packet, no need to do figure out the
    // MAC header.
    //
    if (BindingContext == (PVOID)IPX_LOOPBACK_COOKIE) {


		IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

         Binding = NIC_ID_TO_BINDING(IpxDevice, 1);

        if (!Binding) {

		    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            goto NotValidLoopback;
        }

        Adapter = Binding->Adapter;

    	//
    	// Bump up the ref count so the adapter doesn't disappear from under
    	// us.
    	//
    	IpxReferenceAdapter(Adapter);

		IpxReferenceBinding1(Binding, BREF_ADAPTER_ACCESS);
		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

	    FILL_LOCAL_TARGET(&DatagramOptions.LocalTarget, LOOPBACK_NIC_ID);

        //
        // Do this copy later, from the IpxHeader.
        //
        // RtlCopyMemory (DatagramOptions.LocalTarget.MacAddress, Binding->LocalAddress.NodeAddress, 6);

        if (Binding->Adapter->MacInfo.MediumType == NdisMedium802_5) {
            DatagramOptions.LocalTarget.MacAddress[0] &= 0x7f;
        }

        //
        // Ipx header starts at the top of the LookAheadBuffer
        //
        IpxHeaderOffset = 0;

        IPX_DEBUG (LOOPB, ("Loopback packet received: %lx\n", ReceiveContext));

#if DBG
        DestMacAddress = DatagramOptions.LocalTarget.MacAddress;
#endif

        IsLoopback = TRUE;
        goto Loopback;
    }

	//
	// Bump up the ref count so the adapter doesn't disappear from under
	// us.
	//
	IpxReferenceAdapter(Adapter);

    //
    // The first step is to construct the 8-byte local
    // target from the packet. We store it in the 9-byte
    // datagram options, leaving one byte at the front
    // for use by IpxProcessDatagram when indicating to
    // its TDI clients.
    //

#if DBG
    Binding = NULL;
#endif

    if (Adapter->MacInfo.MediumType == NdisMedium802_3) {

        //
        // Try to figure out what the packet type is.
        //
		IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

        if (Header[12] < 0x06) {

            //
            // An 802.3 header; check the next bytes. They may
            // be E0/E0 (802.2), FFFF (raw 802.3) or A0/A0 (SNAP).
            //

            Saps = *(UNALIGNED USHORT *)(Lookahead);

            if (Saps == 0xffff) {
                if ((Binding = Adapter->Bindings[ISN_FRAME_TYPE_802_3]) == NULL) {
                    goto NotValid802_3;
                }
                IpxHeaderOffset = 0;
                Length802_3 = ((Header[12] << 8) | Header[13]);
                goto Valid802_3;

            } else if (Saps == 0xe0e0) {
                if (Lookahead[2] == 0x03) {
                    if ((Binding = Adapter->Bindings[ISN_FRAME_TYPE_802_2]) == NULL) {
                        goto NotValid802_3;
                    }
                    IpxHeaderOffset = 3;
                    Length802_3 = ((Header[12] << 8) | Header[13]);
                    goto Valid802_3;
                }

            } else if (Saps == 0xaaaa) {

                if ((Lookahead[2] == 0x03) &&
                        (*(UNALIGNED USHORT *)(Lookahead+6) == Adapter->BindSapNetworkOrder)) {
                    if ((Binding = Adapter->Bindings[ISN_FRAME_TYPE_SNAP]) == NULL) {
                        goto NotValid802_3;
                    }
                    IpxHeaderOffset = 8;
                    Length802_3 = ((Header[12] << 8) | Header[13]);
                    goto Valid802_3;
                }
            }

            goto NotValid802_3;

        } else {

            //
            // It has an ethertype, see if it is ours.
            //

            if (*(UNALIGNED USHORT *)(Header+12) == Adapter->BindSapNetworkOrder) {

                if (Adapter->MacInfo.MediumAsync) {

                    *((ULONG UNALIGNED *)(&Binding)) = *((ULONG UNALIGNED *)(&Header[2]));

					CTEAssert(Binding != NULL);

                    if ((Binding != NULL) &&
                        (Binding->LineUp)) {

                        IpxHeaderOffset = 0;
                        Length802_3 = PacketSize;   // set this so the check succeeds

                        //
                        // Check if this is a type 20 packet and
                        // we are disabling them on dialin lines -- we do
                        // this check here to avoid impacting the main
                        // indication path for LANs.
                        //
                        // The 0x02 bit of DisableDialinNetbios controls
                        // WAN->LAN packets, which we handle here.
                        //

                        //
                        // [FW] If FWD bound, no need to check since the FWD does the checks
                        //
                        if (!Device->ForwarderBound &&
                            (!Binding->DialOutAsync) &&
                            ((Device->DisableDialinNetbios & 0x02) != 0)) {

                            IpxHeader = (PIPX_HEADER)Lookahead;   // IpxHeaderOffset is 0
                            if (IpxHeader->PacketType == 0x14) {
                                IpxDereferenceAdapter(Adapter);
                                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                                return STATUS_SUCCESS;
                            }
                        }

                        goto Valid802_3;
                    }
                    goto NotValid802_3;

                } else if ((Binding = Adapter->Bindings[ISN_FRAME_TYPE_ETHERNET_II]) == NULL) {
                    goto NotValid802_3;
                }

                IpxHeaderOffset = 0;
                Length802_3 = PacketSize;   // set this so the check succeeds
                goto Valid802_3;

	    }
        }

        goto NotValid802_3;

Valid802_3:

        if (Length802_3 > PacketSize) {
            goto NotValid802_3;
        } else if (Length802_3 < PacketSize) {
            PacketSize = Length802_3;
            if (LookaheadBufferSize > Length802_3) {
                LookaheadBufferSize = Length802_3;
            }
        }

		IpxReferenceBinding1(Binding, BREF_ADAPTER_ACCESS);
		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
        RtlCopyMemory (DatagramOptions.LocalTarget.MacAddress, Header+6, 6);
#if DBG
        DestMacAddress = Header;
#endif

    } else if (Adapter->MacInfo.MediumType == NdisMedium802_5) {

		IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

        if ((HeaderBufferSize - 14) > 18) {
            goto NotValid802_5;
        }

        Saps = *(USHORT UNALIGNED *)(Lookahead);

        if (Saps == 0xe0e0) {

            if (Lookahead[2] == 0x03) {
                if ((Binding = Adapter->Bindings[ISN_FRAME_TYPE_802_2]) == NULL) {
                    goto NotValid802_5;
                }

                IpxHeaderOffset = 3;
                goto Valid802_5;
            }

        } else if (Saps == 0xaaaa) {

            if ((Lookahead[2] == 0x03) &&
                    (*(UNALIGNED USHORT *)(Lookahead+6) == Adapter->BindSapNetworkOrder)) {
                if ((Binding = Adapter->Bindings[ISN_FRAME_TYPE_SNAP]) == NULL) {
                    goto NotValid802_5;
                }
                IpxHeaderOffset = 8;
                goto Valid802_5;
            }
        }

        goto NotValid802_5;

Valid802_5:
		IpxReferenceBinding1(Binding, BREF_ADAPTER_ACCESS);
		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

        RtlCopyMemory (DatagramOptions.LocalTarget.MacAddress, Header+8, 6);
        DatagramOptions.LocalTarget.MacAddress[0] &= 0x7f;

#if DBG
        DestMacAddress = Header+2;
#endif

    } else if (Adapter->MacInfo.MediumType == NdisMediumFddi) {

		IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
        Saps = *(USHORT UNALIGNED *)(Lookahead);

        if (Saps == 0xe0e0) {

            if (Lookahead[2] == 0x03) {
                if ((Binding = Adapter->Bindings[ISN_FRAME_TYPE_802_2]) == NULL) {
                    goto NotValidFddi;
                }
                IpxHeaderOffset = 3;
                goto ValidFddi;
            }

        } else if (Saps == 0xffff) {

            if ((Binding = Adapter->Bindings[ISN_FRAME_TYPE_802_3]) == NULL) {
                goto NotValidFddi;
            }
            IpxHeaderOffset = 0;
            goto ValidFddi;

        } else if (Saps == 0xaaaa) {

            if ((Lookahead[2] == 0x03) &&
                    (*(UNALIGNED USHORT *)(Lookahead+6) == Adapter->BindSapNetworkOrder)) {

                if ((Binding = Adapter->Bindings[ISN_FRAME_TYPE_SNAP]) == NULL) {
                    goto NotValidFddi;
                }
                IpxHeaderOffset = 8;
                goto ValidFddi;
            }
        }

        goto NotValidFddi;

ValidFddi:

		IpxReferenceBinding1(Binding, BREF_ADAPTER_ACCESS);
		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

        RtlCopyMemory (DatagramOptions.LocalTarget.MacAddress, Header+7, 6);

#if DBG
		DestMacAddress = Header+1;
#endif


    } else {

        //
        // NdisMediumArcnet878_2
        //

		IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
        if ((Header[2] == ARCNET_PROTOCOL_ID) &&
            ((Binding = Adapter->Bindings[ISN_FRAME_TYPE_802_3]) != NULL)) {

            IpxHeaderOffset = 0;
            RtlZeroMemory (DatagramOptions.LocalTarget.MacAddress, 5);
            DatagramOptions.LocalTarget.MacAddress[5] = Header[0];

        } else {

			IpxDereferenceAdapter(Adapter);
			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

#ifdef IPX_PACKET_LOG
            if (PACKET_LOG(IPX_PACKET_LOG_RCV_ALL)) {
                IpxLogPacket(FALSE, Header+2, Header+1, (USHORT)PacketSize, LookaheadBuffer, (PUCHAR)LookaheadBuffer + sizeof(IPX_HEADER));
            }
#endif
            return NDIS_STATUS_SUCCESS;
        }

#if DBG
        DestMacAddress = Header+2;   // Need to log less than six bytes
#endif

		IpxReferenceBinding1(Binding, BREF_ADAPTER_ACCESS);
		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
    }

    //
    // Make sure this didn't slip through.
    //

    CTEAssert (Binding != NULL);
	FILL_LOCAL_TARGET(&DatagramOptions.LocalTarget, MIN( Device->MaxBindings, Binding->NicId));

Loopback:

    //
    // Now that we have validated the header and constructed
    // the local target, indicate the packet to the correct
    // client.
    //

    IpxHeader = (PIPX_HEADER)(Lookahead + IpxHeaderOffset);

    PacketLength = (IpxHeader->PacketLength[0] << 8) | IpxHeader->PacketLength[1];

    IpxPacketSize = PacketSize - IpxHeaderOffset;
    
    //
    // Take care of bad NICs [109862]
    //

    if (PacketLength < sizeof(IPX_HEADER)) {
        
        IpxDereferenceAdapter(Adapter);
        IpxDereferenceBinding1(Binding, BREF_ADAPTER_ACCESS);

#ifdef IPX_PACKET_LOG
        if (PACKET_LOG(IPX_PACKET_LOG_RCV_ALL)) {
            IpxLogPacket(FALSE, DestMacAddress, DatagramOptions.LocalTarget.MacAddress, (USHORT)PacketSize, IpxHeader, IpxHeader+1);
        }
#endif
        IPX_DEBUG (BAD_PACKET, ("Packet len %d, IPX len %d\n",
                                PacketLength, IpxPacketSize));

        return NDIS_STATUS_SUCCESS;
    
    }

    

    if (PacketLength > IpxPacketSize) {

		IpxDereferenceAdapter(Adapter);
		IpxDereferenceBinding1(Binding, BREF_ADAPTER_ACCESS);

#ifdef IPX_PACKET_LOG
        if (PACKET_LOG(IPX_PACKET_LOG_RCV_ALL)) {
            IpxLogPacket(FALSE, DestMacAddress, DatagramOptions.LocalTarget.MacAddress, (USHORT)PacketSize, IpxHeader, IpxHeader+1);
        }
#endif
        IPX_DEBUG (BAD_PACKET, ("Packet len %d, IPX len %d\n",
                          PacketLength, IpxPacketSize));

#ifdef  SNMP
        ++IPX_MIB_ENTRY(Device, SysInReceives);

#endif  SNMP

        return NDIS_STATUS_SUCCESS;

    } else if (PacketLength < IpxPacketSize) {

        IpxPacketSize = PacketLength;
        if (LookaheadBufferSize > (PacketLength + IpxHeaderOffset)) {
            LookaheadBufferSize = PacketLength + IpxHeaderOffset;
        }

    }

    //
    // Bug #33595 - (hotfixed in 3.51, checked into 4.0 beta2)
    // Customer problem where NT allowed RIP/SAP to reply to an 802.5 functional address in the IPX source node. The source
    // MAC address was proper in this case. We need to check for the case where if the packet's source network is the same
    // as that of the binding it came on (=> did not come thru a router), then the SourceNodeAddress in the IPX header
    // should be equal to the SourceAddress in the MAC header.
    //
    // This check is controlled through a registry value - VerifySourceAddress.
    // In case of Arcnet, this check will not succeed.
    // Also, for WAN, the node addresses will not match, so avoid check for those.

    //
    // If the source network is 0, we drop it. Auto-detect frames should have matching node (MAC) addresses.
    // Loopback packets dont have a valid header, so skip this test for them.
    //
    // For loopback pkts, do all the processing above, so we can avoid all these checks for IsLoopback here.
    // Also, to prevent the RtlCopyMemory into the localtarget above, try to use the MAC header to indicate the
    // correct binding to us so we dont use the first one always.
    //
    // CAVEAT:: when using the MAC header as a binding pointer, ensure that we use the adapter corresp, to that binding
    // to enque all the receive requests. currently we enqueue them onto the first bindings adapter.
    //
    if (((*(UNALIGNED ULONG *)IpxHeader->SourceNetwork == Binding->LocalAddress.NetworkAddress) ||
         (*(UNALIGNED ULONG *)IpxHeader->SourceNetwork == 0)) &&
        (!IPX_NODE_EQUAL (IpxHeader->SourceNode, DatagramOptions.LocalTarget.MacAddress)) &&
        Device->VerifySourceAddress &&
        !IsLoopback &&
        !Adapter->MacInfo.MediumAsync &&
        (Adapter->MacInfo.MediumType != NdisMediumArcnet878_2)) {

        IPX_DEBUG(BAD_PACKET, ("Local packet: Src MAC %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x ",
                        DatagramOptions.LocalTarget.MacAddress[0],
                        DatagramOptions.LocalTarget.MacAddress[1],
                        DatagramOptions.LocalTarget.MacAddress[2],
                        DatagramOptions.LocalTarget.MacAddress[3],
                        DatagramOptions.LocalTarget.MacAddress[4],
                        DatagramOptions.LocalTarget.MacAddress[5]));

        IPX_DEBUG(BAD_PACKET, ("IPX Src Node %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
                        IpxHeader->SourceNode[0],
                        IpxHeader->SourceNode[1],
                        IpxHeader->SourceNode[2],
                        IpxHeader->SourceNode[3],
                        IpxHeader->SourceNode[4],
                        IpxHeader->SourceNode[5]));

#ifdef IPX_PACKET_LOG
        ReceiveFlag = IPX_PACKET_LOG_RCV_ALL;
        if (PACKET_LOG(ReceiveFlag)) {
            IpxLogPacket(
                FALSE,
                DestMacAddress,
                DatagramOptions.LocalTarget.MacAddress,
                (USHORT)IpxPacketSize,
                IpxHeader,
                IpxHeader+1);
        }
#endif

		IpxDereferenceAdapter(Adapter);
		IpxDereferenceBinding1(Binding, BREF_ADAPTER_ACCESS);

#ifdef  SNMP
        ++IPX_MIB_ENTRY(Device, SysInReceives);

#endif  SNMP

        return  NDIS_STATUS_SUCCESS;
    }

    // 235842 To avoid flooding when client blindly respond to source address. [tingcai]

    if (((*(UNALIGNED ULONG *)IpxHeader->SourceNetwork == 0xffffffff) ||
	   (IPX_NODE_BROADCAST (IpxHeader->SourceNode)))) {

       IPX_DEBUG(BAD_PACKET, ("!!! Droping packets with broadcast network or node address. !!!\n")); 
   
       IPX_DEBUG(BAD_PACKET, ("IPX Src Node %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
			      IpxHeader->SourceNode[0],
			      IpxHeader->SourceNode[1],
			      IpxHeader->SourceNode[2],
			      IpxHeader->SourceNode[3],
			      IpxHeader->SourceNode[4],
			      IpxHeader->SourceNode[5]));
#ifdef IPX_PACKET_LOG
       ReceiveFlag = IPX_PACKET_LOG_RCV_ALL;
       if (PACKET_LOG(ReceiveFlag)) {
	  IpxLogPacket(
		       FALSE,
		       DestMacAddress,
		       DatagramOptions.LocalTarget.MacAddress,
		       (USHORT)IpxPacketSize,
		       IpxHeader,
		       IpxHeader+1);
       }
#endif
       
       IpxDereferenceAdapter(Adapter);
       IpxDereferenceBinding1(Binding, BREF_ADAPTER_ACCESS);
   
#ifdef  SNMP
       ++IPX_MIB_ENTRY(Device, SysInReceives);
#endif  SNMP
   
       return  NDIS_STATUS_SUCCESS;
    }

    // 260489 If we receive a packet with source network address equals to 0, 
    // we replace replace the source network address with the network address
    // of the binding where the packet was received. 
    // In this way, clients, such as, forwarder can forward the packet to other
    // networks, and clients in other networks will be able to reply to the 
    // packet with the source network address that we fill below. 

    if (*(UNALIGNED ULONG *)IpxHeader->SourceNetwork == 0) {

       *(UNALIGNED ULONG *) IpxHeader->SourceNetwork = Binding->LocalAddress.NetworkAddress;

       IPX_DEBUG(PACKET, ("!!! Replaced 0 source network address with local network address !!!\n")); 

       IPX_DEBUG (PACKET, ("Source %lx %2.2x-%2.2x-%2.2x-%2.2x %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
                            *(USHORT UNALIGNED *)&IpxHeader->SourceSocket,
                            IpxHeader->SourceNetwork[0],
                            IpxHeader->SourceNetwork[1],
                            IpxHeader->SourceNetwork[2],
                            IpxHeader->SourceNetwork[3],
                            IpxHeader->SourceNode[0],
                            IpxHeader->SourceNode[1],
                            IpxHeader->SourceNode[2],
                            IpxHeader->SourceNode[3],
                            IpxHeader->SourceNode[4],
                            IpxHeader->SourceNode[5]));
#ifdef IPX_PACKET_LOG
       ReceiveFlag = IPX_PACKET_LOG_RCV_ALL;
       if (PACKET_LOG(ReceiveFlag)) {
	  IpxLogPacket(
		       FALSE,
		       DestMacAddress,
		       DatagramOptions.LocalTarget.MacAddress,
		       (USHORT)IpxPacketSize,
		       IpxHeader,
		       IpxHeader+1);
       }
#endif
    }

    DestinationSocket = *(USHORT UNALIGNED *)&IpxHeader->DestinationSocket;

    //
    // In order to have consistent local targets, copy over the target from the IpxHeader.
    //
    if (IsLoopback) {
        IPX_DEBUG (LOOPB, ("Loopback packet copied the localtarget: %lx\n", IpxHeader->DestinationNode));
        // RtlCopyMemory (DatagramOptions.LocalTarget.MacAddress, IpxHeader->DestinationNode, 6);

        *((UNALIGNED ULONG *)DatagramOptions.LocalTarget.MacAddress) =
            *((UNALIGNED ULONG *)IpxHeader->DestinationNode);

        *((UNALIGNED USHORT *)(DatagramOptions.LocalTarget.MacAddress+4)) =
            *((UNALIGNED USHORT *)(IpxHeader->DestinationNode+4));
    }

    ++Device->Statistics.PacketsReceived;

    DestinationNode = IpxHeader->DestinationNode;


    if (DestinationSocket != RIP_SOCKET) {
        
        DestinationNetwork = *(UNALIGNED ULONG *)IpxHeader->DestinationNetwork;

RecheckPacket:

        if (Device->MultiCardZeroVirtual) {

            if ((DestinationNetwork == Binding->LocalAddress.NetworkAddress) ||
                (DestinationNetwork == 0)) {

                if (IPX_NODE_EQUAL (DestinationNode, Binding->LocalAddress.NodeAddress)) {
                    IsBroadcast = FALSE;
                    goto DestinationOk;
                } else {
                    if ((IsBroadcast = IPX_NODE_BROADCAST(DestinationNode)) &&
                        (Binding->ReceiveBroadcast)) {
                        goto DestinationOk;
                    }
                }

                //
                // If this is a binding set slave, check for the master's
                // address.
                //

                if ((Binding->BindingSetMember) &&
                    (IPX_NODE_EQUAL (DestinationNode, Binding->MasterBinding->LocalAddress.NodeAddress))) {
                    goto DestinationOk;
                }

            } else {
                IsBroadcast = IPX_NODE_BROADCAST(DestinationNode);
            }

        } else {

            if ((DestinationNetwork == Device->SourceAddress.NetworkAddress) ||
                (DestinationNetwork == 0)) {

                if (IPX_NODE_EQUAL (DestinationNode, Device->SourceAddress.NodeAddress)) {
                    IsBroadcast = FALSE;
                    goto DestinationOk;
                } else {
                    if ((IsBroadcast = IPX_NODE_BROADCAST(DestinationNode)) &&
                        (Binding->ReceiveBroadcast)) {
                        goto DestinationOk;
                    }
                }
            } else {
                IsBroadcast = IPX_NODE_BROADCAST(DestinationNode);
            }

            //
            // We need to check for frames that are sent to the
            // binding node and net, because if we have a virtual
            // net we won't catch them in the check above. This
            // will include any Netbios frames, since they don't
            // use the virtual net. Doing the check like this will slow
            // down netbios indications just a bit on a machine with
            // a virtual network, but it saves a jump for other traffic
            // vs. adding the check up there (the assumption is if we
            // have a virtual net most traffic is NCP).
            //
            // Note that IsBroadcast is already set, so we don't have
            // to do that.
            //

            if ((Device->VirtualNetwork) &&
                ((DestinationNetwork == Binding->LocalAddress.NetworkAddress) ||
                 (DestinationNetwork == 0))) {

                if (IPX_NODE_EQUAL (DestinationNode, Binding->LocalAddress.NodeAddress)) {
                    goto DestinationOk;
                } else {
                    if (IsBroadcast && (Binding->ReceiveBroadcast)) {
                        goto DestinationOk;
                    }

                }

                //
                // If this is a binding set slave, check for the master's
                // address.
                //

                if ((Binding->BindingSetMember) &&
                    (IPX_NODE_EQUAL (DestinationNode, Binding->MasterBinding->LocalAddress.NodeAddress))) {
                    goto DestinationOk;
                }
            }
        }

        //
        // If this was a loopback packet that was sent on the second binding (but showed back up on the first one),
        // then the networknumbers will not match. Allow the receive on the first binding itself.
        //
        if (IsLoopback) {
            IPX_DEBUG (LOOPB, ("Loopback packet forced on first binding: %lx\n", ReceiveContext));
            goto DestinationOk;
        }

        //
        // If we did not receive this packet, it might be because
        // our network is still 0 and this packet was actually
        // sent to the real network number. If so we try to
        // update our local address, and if successful we
        // re-check the packet. We don't insert if we are
        // not done with auto detection, to avoid colliding
        // with that.
        //
        // To avoid problems if we are a router, we only update
        // on packets that are broadcast or sent to us.
        //

        if ((Binding->LocalAddress.NetworkAddress == 0) &&
            (Device->AutoDetectState == AUTO_DETECT_STATE_DONE) &&
            (DestinationNetwork != 0) &&
            (IsBroadcast ||
             IPX_NODE_EQUAL (DestinationNode, Binding->LocalAddress.NodeAddress))) {

            CTEAssert (Binding->NicId != 0);

            if (IpxUpdateBindingNetwork(
                    Device,
                    Binding,
                    DestinationNetwork) == STATUS_SUCCESS) {

                IPX_DEBUG (RIP, ("Binding %d reconfigured to network %lx\n",
                    Binding->NicId,
                    REORDER_ULONG(Binding->LocalAddress.NetworkAddress)));

                //
                // Jump back and re-process the packet; we know
                // we won't loop through here again because the
                // binding's network is now non-zero.
                //

                goto RecheckPacket;

            }
        }


        //
        // The only frames that will not already have jumped to
        // DestinationOk are those to or from the SAP socket,
        // so we check for those.
        //

        if ((*(USHORT UNALIGNED *)&IpxHeader->SourceSocket == SAP_SOCKET) ||
            (DestinationSocket == SAP_SOCKET)) {

DestinationOk:

            //
            // [FW] For internally destined packets, call the Forwarder's internal
            // receive handler to filter the packets.
            //
            // STEFAN: 3/28/96:
            // Dont filter IPXWAN config packets since the FWD does not have this adapter opened.
            //

            IPX_DEBUG(RECEIVE, ("DestSocket: %lx\n", DestinationSocket));

#ifdef  SNMP
            ++IPX_MIB_ENTRY(Device, SysInDelivers);
#endif  SNMP

            if (DestinationSocket != IPXWAN_SOCKET &&
                Device->ForwarderBound) {

                NDIS_STATUS NdisStatus;

                IPX_DEBUG(RECEIVE, ("Internal packet, sending up to the Forwarder\n"));

                //
                // We should pass up the correct Fwd ctx for loopback ptks
                //

                //
                // Indicate this up only if the adapter the packet came on was opened by the Forwarder
                //
                if (GET_LONG_VALUE(Binding->ReferenceCount) == 2) {

                    NdisStatus = (*Device->UpperDrivers[IDENTIFIER_RIP].InternalReceiveHandler) (
                                    (IsLoopback) ?
                                        VIRTUAL_NET_FORWARDER_CONTEXT :
                                        Binding->FwdAdapterContext,        // ForwarderAdapterContext
                                    &DatagramOptions.LocalTarget,          // Remote Address
                                    (PUCHAR) IpxHeader,                    // Lookahead buffer
                                    LookaheadBufferSize - IpxHeaderOffset  // Lookahead buffer size
                                    );

                    IPX_DEBUG(TEMP, ("Internal packet, Forwarder returned %lx\n", NdisStatus));

                    if (NdisStatus != STATUS_SUCCESS) {
                        //
                        // Log this packet
                        //
                        IPX_DEBUG(TEMP, ("Internal packet, failed the filter: ipxheader: %lx\n", IpxHeader));

                        //
                        // The router needs to see Netbios type 20 broadcasts.
                        //

                        if (IsBroadcast &&
                            (IpxHeader->PacketType == 0x14) &&
                            (Binding->ReceiveBroadcast) &&
                            (!fCallProcessDatagram)) {

                            goto RipIndication;
                        }
                        // else
                        IpxDereferenceAdapter(Adapter);
                        return   NDIS_STATUS_SUCCESS;
                    }

                 } else {
                    IpxDereferenceAdapter(Adapter);
                    IPX_DEBUG(TEMP, ("Internal packet, Forwarder has not opened the adapter yet\n"));
                    return NDIS_STATUS_SUCCESS;
                }
            }

            //
            // An IPX packet sent to us, or a SAP packet (which
            // are not sent to the virtual address but still need
            // to be indicated and not forwarded to RIP).
            //

            if (DestinationSocket == NB_SOCKET) {
#if DBG
                ReceiveFlag = IPX_PACKET_LOG_RCV_NB | IPX_PACKET_LOG_RCV_ALL;
#endif
                if (((!IsBroadcast) || (Device->UpperDrivers[IDENTIFIER_NB].BroadcastEnable)) &&
                    (Device->UpperDriverBound[IDENTIFIER_NB]) && Binding->IsnInformed[IDENTIFIER_NB] == TRUE) {

                    if (!IsLoopback && Adapter->MacInfo.MediumType == NdisMedium802_5) {
                        MacUpdateSourceRouting (IDENTIFIER_NB, Adapter, Header, HeaderBufferSize);
                    }

                    //
                    // We add HeaderBufferSize to the IpxHeaderOffset field since we do an NdisCopyFromPacketToPacket
                    // in IpxTransferData, which needs offset from the beginning of the packet.
                    // NdisTransferData adds the offset passed in to the beginning of the IPX packet.
                    //

                        if ((*Device->UpperDrivers[IDENTIFIER_NB].ReceiveHandler)(
                            (IsLoopback) ? BindingContext : Adapter->NdisBindingHandle,
                            ReceiveContext,
                            Binding->FwdAdapterContext,
                            &DatagramOptions.LocalTarget,
                            Adapter->MacInfo.MacOptions,
                            (PUCHAR)IpxHeader,
                            LookaheadBufferSize - IpxHeaderOffset,
                            (IsLoopback) ? IpxHeaderOffset+HeaderBufferSize : IpxHeaderOffset,
                            IpxPacketSize,
                            pMdl)) {

                        CTEAssert(FALSE);
                        (*pTdiClientCount)++;
                    }

                    Device->ReceiveCompletePending[IDENTIFIER_NB] = TRUE;
                }

                //
                // The router needs to see Netbios type 20 broadcasts.
                //

                if (IsBroadcast &&
                    (IpxHeader->PacketType == 0x14) &&
                    (Binding->ReceiveBroadcast) &&
                    (!fCallProcessDatagram)) {
                    goto RipIndication;
                }

            } else if (IpxHeader->PacketType == SPX_PACKET_TYPE) {

#if DBG
                ReceiveFlag = IPX_PACKET_LOG_RCV_SPX | IPX_PACKET_LOG_RCV_ALL;
#endif

                if (((!IsBroadcast) || (Device->UpperDrivers[IDENTIFIER_SPX].BroadcastEnable)) &&
                    (Device->UpperDriverBound[IDENTIFIER_SPX])) {

                    if (!IsLoopback && Adapter->MacInfo.MediumType == NdisMedium802_5) {
                        MacUpdateSourceRouting (IDENTIFIER_SPX, Adapter, Header, HeaderBufferSize);
                    }

                    if ((*Device->UpperDrivers[IDENTIFIER_SPX].ReceiveHandler)(
                            (IsLoopback) ? BindingContext : Adapter->NdisBindingHandle,
                            ReceiveContext,
                            Binding->FwdAdapterContext,
                            &DatagramOptions.LocalTarget,
                            Adapter->MacInfo.MacOptions,
                            (PUCHAR)IpxHeader,
                            LookaheadBufferSize - IpxHeaderOffset,
                            (IsLoopback) ? IpxHeaderOffset+HeaderBufferSize : IpxHeaderOffset,
                            IpxPacketSize,
                            pMdl)) {

                        CTEAssert(FALSE);
                        (*pTdiClientCount)++;
                    }

                    Device->ReceiveCompletePending[IDENTIFIER_SPX] = TRUE;
                }

            } else {

                IPX_DEBUG (RECEIVE, ("Received packet type %d, length %d\n",
                            Binding->FrameType,
                            IpxPacketSize));
                IPX_DEBUG (RECEIVE, ("Source %lx %2.2x-%2.2x-%2.2x-%2.2x %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
                            *(USHORT UNALIGNED *)&IpxHeader->SourceSocket,
                            IpxHeader->SourceNetwork[0],
                            IpxHeader->SourceNetwork[1],
                            IpxHeader->SourceNetwork[2],
                            IpxHeader->SourceNetwork[3],
                            IpxHeader->SourceNode[0],
                            IpxHeader->SourceNode[1],
                            IpxHeader->SourceNode[2],
                            IpxHeader->SourceNode[3],
                            IpxHeader->SourceNode[4],
                            IpxHeader->SourceNode[5]));
                IPX_DEBUG (RECEIVE, ("Destination %d %2.2x-%2.2x-%2.2x-%2.2x %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
                            DestinationSocket,
                            IpxHeader->DestinationNetwork[0],
                            IpxHeader->DestinationNetwork[1],
                            IpxHeader->DestinationNetwork[2],
                            IpxHeader->DestinationNetwork[3],
                            IpxHeader->DestinationNode[0],
                            IpxHeader->DestinationNode[1],
                            IpxHeader->DestinationNode[2],
                            IpxHeader->DestinationNode[3],
                            IpxHeader->DestinationNode[4],
                            IpxHeader->DestinationNode[5]));

#if DBG
                if (IpxHeader->DestinationSocket == IpxPacketLogSocket) {
                    ReceiveFlag = IPX_PACKET_LOG_RCV_SOCKET | IPX_PACKET_LOG_RCV_OTHER | IPX_PACKET_LOG_RCV_ALL;
                } else {
                    ReceiveFlag = IPX_PACKET_LOG_RCV_OTHER | IPX_PACKET_LOG_RCV_ALL;
                }
#endif

                //
                // Fiddle with this if so in the general case
                // the jump is not made (the compiler
                // still rearranges it).
                //

                if (Adapter->MacInfo.MediumType != NdisMedium802_5) {

CallProcessDatagram:
                    //
                    // [SA] Returns a status now which needs to be returned to NDIS
                    // Also, MDL is passed in.
					// We need to pass in the HeaderBufferSize too....
                    //
					IpxProcessDatagram(
						Device,
						Adapter,
						Binding,
						ReceiveContext,
						&DatagramOptions,
						(PUCHAR)IpxHeader,
						LookaheadBufferSize - IpxHeaderOffset,
                        (IsLoopback) ? IpxHeaderOffset+HeaderBufferSize : IpxHeaderOffset, // lookaheadbufferoffset
						IpxPacketSize,
						IsBroadcast,
						pTdiClientCount,
						HeaderBufferSize,
						pMdl,
                        BindingContext);

                } else {
                    if (!IsLoopback) {
                        MacUpdateSourceRouting (IDENTIFIER_IPX, Adapter, Header, HeaderBufferSize);
                    }
                    goto CallProcessDatagram;
                }

                //
                // The router needs to see type 20 broadcasts.
                //

                if (IsBroadcast &&
                    (IpxHeader->PacketType == 0x14) &&
                    (Binding->ReceiveBroadcast) &&
                    (!fCallProcessDatagram)) {
                    goto RipIndication;
                }
            }

        } else {

#if DBG
            ReceiveFlag = IPX_PACKET_LOG_RCV_ALL;
#endif

            //
            // We need to let non-type 20 broadcast frames go to RIP to allow for lan-specific
            // broadcasts. For logon over IPX, this allows the logon request to get thru the WAN
            // line.
            //
            // if ( !IsBroadcast ) {

RipIndication:;

                if (Device->ForwarderBound) {
                    //
                    // FWD ....
                    //

                    if (DestinationSocket == RIP_SOCKET) {
                        //
                        // [FW] Since RIP is now a user app with the same socket #, we inform thru'
                        // the ProcessDatagram path. And only if the Forwarder is installed.
                        //

                        IsBroadcast = IPX_NODE_BROADCAST(DestinationNode);
                        fCallProcessDatagram = TRUE;
                        goto CallProcessDatagram;
                    } else {
                        if (!IsLoopback && Adapter->MacInfo.MediumType == NdisMedium802_5) {
                            MacUpdateSourceRouting (IDENTIFIER_RIP, Adapter, Header, HeaderBufferSize);
                        }

                        //
                        // We hide binding sets from the router, to avoid
                        // misordering packets which it routes.
                        //

                        if (!IsLoopback && Binding->BindingSetMember) {
    						FILL_LOCAL_TARGET(&DatagramOptions.LocalTarget, MIN (Device->MaxBindings, Binding->MasterBinding->NicId));
                        }

                        if (GET_LONG_VALUE(Binding->ReferenceCount) == 2) {
                            if (IsLoopback) {
                              if ((*Device->UpperDrivers[IDENTIFIER_RIP].InternalReceiveHandler)(
                                VIRTUAL_NET_FORWARDER_CONTEXT,
                                &DatagramOptions.LocalTarget,
                                (PUCHAR)IpxHeader,
                                LookaheadBufferSize - IpxHeaderOffset
                                )) {

                                (*pTdiClientCount)++;
                              }
                            } else {
                               if ((*Device->UpperDrivers[IDENTIFIER_RIP].ReceiveHandler)(
                                (IsLoopback) ? BindingContext : Adapter->NdisBindingHandle,
                                ReceiveContext,
                                Binding->FwdAdapterContext,
                                &DatagramOptions.LocalTarget,
                                Adapter->MacInfo.MacOptions,
                                (PUCHAR)IpxHeader,
                                LookaheadBufferSize - IpxHeaderOffset,
                                (IsLoopback) ? IpxHeaderOffset+HeaderBufferSize : IpxHeaderOffset,
                                IpxPacketSize,
                                pMdl)) {

                                (*pTdiClientCount)++;
                               }
                            }
                            Device->ReceiveCompletePending[IDENTIFIER_RIP] = TRUE;
                        } else {
                            IPX_DEBUG(RECEIVE, ("External packet, Forwarder has not opened the adapter yet\n"));
                        }
                    }
                } else if (Device->UpperDriverBound[IDENTIFIER_RIP]) {
                    //
                    // Old RIP...
                    //
                    if (!IsLoopback && Adapter->MacInfo.MediumType == NdisMedium802_5) {
                        MacUpdateSourceRouting (IDENTIFIER_RIP, Adapter, Header, HeaderBufferSize);
                    }

                    //
                    // We hide binding sets from the router, to avoid
                    // misordering packets which it routes.
                    //

                    if (!IsLoopback && Binding->BindingSetMember) {
                        FILL_LOCAL_TARGET(&DatagramOptions.LocalTarget, MIN (Device->MaxBindings, Binding->MasterBinding->NicId));
                    }

		    if (GET_LONG_VALUE(Binding->ReferenceCount) == 2) {
                if (IsLoopback) {
                    if ((*Device->UpperDrivers[IDENTIFIER_RIP].InternalReceiveHandler)(
                            VIRTUAL_NET_FORWARDER_CONTEXT,
                            &DatagramOptions.LocalTarget,
                            (PUCHAR)IpxHeader,
                            LookaheadBufferSize - IpxHeaderOffset
                            )) {

                        CTEAssert(FALSE);
                        (*pTdiClientCount)++;
                    }
                } else {

                    if ((*Device->UpperDrivers[IDENTIFIER_RIP].ReceiveHandler)(
			                (IsLoopback) ? BindingContext : Adapter->NdisBindingHandle,
                            ReceiveContext,
                            Binding->FwdAdapterContext,
                            &DatagramOptions.LocalTarget,
                            Adapter->MacInfo.MacOptions,
                            (PUCHAR)IpxHeader,
                            LookaheadBufferSize - IpxHeaderOffset,
                            (IsLoopback) ? IpxHeaderOffset+HeaderBufferSize : IpxHeaderOffset,
                            IpxPacketSize,
                            pMdl)) {

                        CTEAssert(FALSE);
                        (*pTdiClientCount)++;
		            }
                }
		    } else {
		       IPX_DEBUG(RECEIVE, ("Old Rip: External packet, Forwarder has not opened the adapter yet\n"));
		    }
                    Device->ReceiveCompletePending[IDENTIFIER_RIP] = TRUE;
                }
            // }
        }

    } else {

        if ((Binding->ReceiveBroadcast) ||
            (!IPX_NODE_BROADCAST(IpxHeader->DestinationNode))) {

            SourceNetwork = *(UNALIGNED LONG *)IpxHeader->SourceNetwork;

            //
            // Sent to the RIP socket; check if this binding needs a
            // network number.
            //

            if ((Binding->LocalAddress.NetworkAddress == 0) &&
                ((SourceNetwork = *(UNALIGNED LONG *)IpxHeader->SourceNetwork) != 0)) {

                switch (Device->AutoDetectState) {

                case AUTO_DETECT_STATE_DONE:

                    //
                    // We are done with auto-detect and running.
                    // Make sure this packet is useful. If the source
                    // MAC address and source IPX node are the same then
                    // it was not routed, and we also check that it is not
                    // an IPX broadcast (otherwise a misconfigured client
                    // might confuse us).
                    //

                    if ((RtlEqualMemory(
                            IpxHeader->SourceNode,
                            DatagramOptions.LocalTarget.MacAddress,
                            6)) &&
                        (*(UNALIGNED ULONG *)(IpxHeader->DestinationNode) != 0xffffffff) &&
                        (*(UNALIGNED USHORT *)(IpxHeader->DestinationNode+4) != 0xffff)) {

                        CTEAssert (Binding->NicId != 0);

                        if (IpxUpdateBindingNetwork(
                                Device,
                                Binding,
                                *(UNALIGNED LONG *)IpxHeader->SourceNetwork) == STATUS_SUCCESS) {

                            IPX_DEBUG (RIP, ("Binding %d is network %lx\n",
                                Binding->NicId,
                                REORDER_ULONG(Binding->LocalAddress.NetworkAddress)));

                        }
                    }

                    break;

                case AUTO_DETECT_STATE_RUNNING:

                    //
                    // We are waiting for rip responses to figure out our
                    // network number. We count the responses that match
                    // and do not match our current value; when the non-
                    // matching number exceeds it we switch (to whatever
                    // this frame happens to have). Note that on the first
                    // non-zero response this will be the case and we will
                    // switch to that network.
                    //
                    // After auto-detect is done we call RipInsertLocalNetwork
                    // for whatever the current network is on each binding.
                    //

                    if (SourceNetwork == Binding->TentativeNetworkAddress) {

                        ++Binding->MatchingResponses;

                    } else {

                        ++Binding->NonMatchingResponses;

                        if (Binding->NonMatchingResponses > Binding->MatchingResponses) {

                            IPX_DEBUG (AUTO_DETECT, ("Switching to net %lx on %lx (%d - %d)\n",
                                REORDER_ULONG(SourceNetwork),
                                Binding,
                                Binding->NonMatchingResponses,
                                Binding->MatchingResponses));

                            Binding->TentativeNetworkAddress = SourceNetwork;
                            Binding->MatchingResponses = 1;
                            Binding->NonMatchingResponses = 0;
                        }

                    }

                    //
                    // If we are auto-detecting and we have just found
                    // a default, set this so that RIP stops trying
                    // to auto-detect on other nets. Unless we
                    // are on a server doing multiple detects.
                    //

                    if (Binding->DefaultAutoDetect) {
                        Adapter->DefaultAutoDetected = TRUE;
                    }
                    Adapter->AutoDetectResponse = TRUE;

                    break;

                default:

                    //
                    // We are still initializing, or are processing auto-detect
                    // responses, not the right time to start updating stuff.
                    //

                    break;

                }

            }


            //
            // See if any packets are waiting for a RIP response.
            //

            if (Device->RipPacketCount > 0) {

                RIP_PACKET UNALIGNED * RipPacket = (RIP_PACKET UNALIGNED *)(IpxHeader+1);
		PBINDING Binding;
		
		Binding = NIC_ID_TO_BINDING(Device, NIC_FROM_LOCAL_TARGET(&DatagramOptions.LocalTarget)); 
  
#ifdef DBG
		// This could be we in the middle of IpxUnbindAdapter and IpxClosNdis.
		if (Binding == NULL) {
		   DbgPrint("The binding %d has disappeared. Skip RipProcessResponse.\n", NIC_FROM_LOCAL_TARGET(&DatagramOptions.LocalTarget)); 
		   DbgPrint("The packet was received on adapter %p.\n",BindingContext); 
		}
#endif
                if ((IpxPacketSize >= sizeof(IPX_HEADER) + sizeof(RIP_PACKET)) &&
                    (RipPacket->Operation == RIP_RESPONSE) &&
                    (RipPacket->NetworkEntry.NetworkNumber != 0xffffffff) &&
		    (Binding != NULL)) {

                    RipProcessResponse(
                        Device,
                        &DatagramOptions.LocalTarget,
                        RipPacket);
                }
            }


            //
            // See if this is a RIP response for our virtual network
            // and we are the only person who could respond to it.
            // We also respond to general queries on WAN lines since
            // we are the only machine on it.
            //

            if (Device->RipResponder) {

                PRIP_PACKET RipPacket =
                    (PRIP_PACKET)(IpxHeader+1);

                if ((IpxPacketSize >= sizeof(IPX_HEADER) + sizeof(RIP_PACKET)) &&
                    (RipPacket->Operation == RIP_REQUEST) &&
                    ((RipPacket->NetworkEntry.NetworkNumber == Device->VirtualNetworkNumber) ||
                     (Adapter->MacInfo.MediumAsync && (RipPacket->NetworkEntry.NetworkNumber == 0xffffffff)))) {

                    //
                    // Update this so our response goes out correctly.
                    //

                    if (!IsLoopback && Adapter->MacInfo.MediumType == NdisMedium802_5) {
                        MacUpdateSourceRouting (IDENTIFIER_IPX, Adapter, Header, HeaderBufferSize);
                    }

                    RipSendResponse(
                        Binding,
                        (TDI_ADDRESS_IPX UNALIGNED *)(IpxHeader->SourceNetwork),
                        &DatagramOptions.LocalTarget);
                }
            }

#if DBG
            ReceiveFlag = IPX_PACKET_LOG_RCV_RIP | IPX_PACKET_LOG_RCV_ALL;
#endif

            //
            // See if the RIP upper driver wants it too.
            //

            goto RipIndication;
        }

    }


	IpxDereferenceAdapter(Adapter);
	IpxDereferenceBinding1(Binding, BREF_ADAPTER_ACCESS);

#ifdef IPX_PACKET_LOG
    if (PACKET_LOG(ReceiveFlag)) {
        IpxLogPacket(
            FALSE,
            DestMacAddress,
            DatagramOptions.LocalTarget.MacAddress,
            (USHORT)IpxPacketSize,
            IpxHeader,
            IpxHeader+1);
    }
#endif
    return NDIS_STATUS_SUCCESS;

	//
    // These are the failure routines for the various media types.
    // They only differ in the debug logging.
    //

NotValid802_3:

#ifdef  SNMP
        ++IPX_MIB_ENTRY(Device, SysInReceives);
        ++IPX_MIB_ENTRY(Device, SysInHdrErrors);
#endif  SNMP

		IpxDereferenceAdapter(Adapter);
		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

#ifdef IPX_PACKET_LOG
    if (PACKET_LOG(IPX_PACKET_LOG_RCV_ALL)) {
        IpxLogPacket(FALSE, Header, Header+6, (USHORT)PacketSize, LookaheadBuffer, (PUCHAR)LookaheadBuffer + sizeof(IPX_HEADER));
    }
#endif
    return NDIS_STATUS_SUCCESS;

NotValid802_5:

#ifdef  SNMP
        ++IPX_MIB_ENTRY(Device, SysInReceives);
        ++IPX_MIB_ENTRY(Device, SysInHdrErrors);
#endif  SNMP

		IpxDereferenceAdapter(Adapter);
		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

#ifdef IPX_PACKET_LOG
    if (PACKET_LOG(IPX_PACKET_LOG_RCV_ALL)) {
        IpxLogPacket(FALSE, Header+2, Header+8, (USHORT)PacketSize, LookaheadBuffer, (PUCHAR)LookaheadBuffer + sizeof(IPX_HEADER));
    }
#endif
    return NDIS_STATUS_SUCCESS;

NotValidFddi:

#ifdef  SNMP
        ++IPX_MIB_ENTRY(Device, SysInReceives);
        ++IPX_MIB_ENTRY(Device, SysInHdrErrors);
#endif  SNMP

		IpxDereferenceAdapter(Adapter);
		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

NotValidLoopback:

#ifdef  SNMP
        ++IPX_MIB_ENTRY(Device, SysInReceives);
        ++IPX_MIB_ENTRY(Device, SysInHdrErrors);
#endif  SNMP

#ifdef IPX_PACKET_LOG
    if (PACKET_LOG(IPX_PACKET_LOG_RCV_ALL)) {
        IpxLogPacket(FALSE, Header+1, Header+7, (USHORT)PacketSize, LookaheadBuffer, (PUCHAR)LookaheadBuffer + sizeof(IPX_HEADER));
    }
#endif

    return NDIS_STATUS_SUCCESS;

}   /* IpxReceiveIndication */


VOID
IpxReceiveComplete(
    IN NDIS_HANDLE BindingContext
    )

/*++

Routine Description:

    This routine receives control from the physical provider as an
    indication that a connection(less) frame has been received on the
    physical link.  We dispatch to the correct packet handler here.

Arguments:

    BindingContext - The Adapter Binding specified at initialization time.

Return Value:

    None

--*/

{

    PADAPTER Adapter = (PADAPTER)BindingContext;
    PREQUEST Request;
    PADDRESS_FILE AddressFile;
    PLIST_ENTRY linkage;
    CTELockHandle OldIrq;
    PDEVICE Device = IpxDevice;
    PIRP pIrp;
    PLIST_ENTRY pLE;


    //
    // Complete all pending receives. Do a quick check
    // without the lock.
    //

    while (!IsListEmpty (&Adapter->RequestCompletionQueue)) {

        linkage = IPX_REMOVE_HEAD_LIST(
                      &Adapter->RequestCompletionQueue,
                      Adapter->DeviceLock);

        if (!IPX_LIST_WAS_EMPTY (&Adapter->RequestCompletionQueue, linkage)) {

            Request = LIST_ENTRY_TO_REQUEST(linkage);
            AddressFile = REQUEST_OPEN_CONTEXT(Request);

            IPX_DEBUG (RECEIVE, ("Completing RDG on %lx\n", AddressFile));

            IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
            IpxCompleteRequest(Request);
            IpxFreeRequest(Adapter->Device, Request);

            IpxDereferenceAddressFileSync (AddressFile, AFREF_RCV_DGRAM);

        } else {

            //
            // IPX_REMOVE_HEAD_LIST returned nothing, so don't
            // bother looping back.
            //

            break;

        }

    }

    //
    // Unwind this loop for speed.
    //

    if (IpxDevice->AnyUpperDriverBound) {

        // PDEVICE Device = IpxDevice;

        if ((Device->UpperDriverBound[0]) &&
                (Device->ReceiveCompletePending[0])) {

            (*Device->UpperDrivers[0].ReceiveCompleteHandler)(
                (USHORT)1);             // Fix NIC ID or remove.
            Device->ReceiveCompletePending[0] = FALSE;

        }

        if ((Device->UpperDriverBound[1]) &&
                (Device->ReceiveCompletePending[1])) {

            (*Device->UpperDrivers[1].ReceiveCompleteHandler)(
                (USHORT)1);             // Fix NIC ID or remove.
            Device->ReceiveCompletePending[1] = FALSE;

        }

        if ((Device->UpperDriverBound[2]) &&
                (Device->ReceiveCompletePending[2])) {

            (*Device->UpperDrivers[2].ReceiveCompleteHandler)(
                (USHORT)1);             // Fix NIC ID or remove.
            Device->ReceiveCompletePending[2] = FALSE;

        }

    }

    CTEGetLock(&Device->Lock, &OldIrq);
    if (pRtInfo)
    {
      CTEFreeLock(&Device->Lock, OldIrq);
      IpxReferenceRt(pRtInfo, RT_EXTRACT);
      while((pLE = ExInterlockedRemoveHeadList(&pRtInfo->CompletedIrps,
                                   &pRtInfo->Lock)) != NULL)
      {
       pIrp = LIST_ENTRY_TO_REQUEST(pLE);
       CTEAssert(pIrp);
       IpxPrint0("IpxReceiveComplete: Completing extracted irp\n");
       NTIoComplete(pIrp, (NTSTATUS)-1,(ULONG)-1);
      }
      IpxDereferenceRt(pRtInfo, RT_EXTRACT);

    } else {
      CTEFreeLock(&Device->Lock, OldIrq);
    }

     //
     // If there are any Ntf completions, do them.  These ntf completions
     // are only if we discovered the address of one of our adapters.
     //

     while((pLE = ExInterlockedRemoveHeadList(&Device->NicNtfComplQueue, &Device ->Lock)) != NULL)
     {
       pIrp = LIST_ENTRY_TO_REQUEST(pLE);
       CTEAssert(pIrp);
       IpxPrint0("IpxReceiveComplete: Completing Nic Ntf irp\n");
       NTIoComplete(pIrp, (NTSTATUS)-1, (ULONG)-1);
       IpxDereferenceDevice (Device, DREF_NIC_NOTIFY);
     }

}   /* IpxReceiveComplete */


NTSTATUS
IpxUpdateBindingNetwork(
    IN PDEVICE Device,
    IN PBINDING Binding,
    IN ULONG Network
    )

/*++

Routine Description:

    This routine is called when we have decided that we now know
    the network number for a binding which we previously thought
    was zero.

Arguments:

    Device - The IPX device.

    Binding - The binding being updated.

    Network - The new network number.

Return Value:

    The status of the operation.

--*/

{
    NTSTATUS Status;
    PADDRESS Address;
    ULONG CurrentHash;
    PLIST_ENTRY p;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)
    PBINDING    Loopback = NULL;
    NDIS_REQUEST            IpxRequest;
    PNETWORK_ADDRESS_LIST   AddrList;
    PNETWORK_ADDRESS        Addr;
    NETWORK_ADDRESS_IPX     *TdiAddress;
    PIPX_DELAYED_NDISREQUEST_ITEM DelayedNdisItem; 

    
    //
    // Only binding set members should have these different,
    // and they will not have a network of 0.
    //

    Status = RipInsertLocalNetwork(
                 Network,
                 Binding->NicId,
                 Binding->Adapter->NdisBindingHandle,
                 (USHORT)((839 + Binding->MediumSpeed) / Binding->MediumSpeed));

    if (Status == STATUS_SUCCESS) {

        Binding->LocalAddress.NetworkAddress = Network;

        //
        //  Loopback Adapter might need to be primed too [shreem]
        //

        if (!Device->VirtualNetwork) {

            Loopback = NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID);

            if (( 0 == Loopback->LocalAddress.NetworkAddress) || 
                (REORDER_ULONG(INITIAL_LOOPBACK_NET_ADDRESS) == Loopback->LocalAddress.NetworkAddress)) {

                Loopback->LocalAddress.NetworkAddress = Network;
                RtlCopyMemory (Loopback->LocalAddress.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                RtlCopyMemory (Loopback->LocalMacAddress.Address, Binding->LocalAddress.NodeAddress, 6);

            }
        }

        //
        // Update the device address if we have no virtual net
        // and there is one binding (!Device->MultiCardZeroVirtual)
        // or this is the first binding, which is the one we
        // appear to be if a) we have no virtual net defined and
        // b) we are bound to multiple cards.
        //

        if ((!Device->MultiCardZeroVirtual) || (Binding->NicId == FIRST_REAL_BINDING)) {

            if (!Device->VirtualNetwork) {

                Device->SourceAddress.NetworkAddress = Network;

                //
                // Scan through all the addresses that exist and modify
                // their pre-constructed local IPX address to reflect
                // the new local net and node.
                //

                IPX_GET_LOCK (&Device->Lock, &LockHandle);

                for (CurrentHash = 0; CurrentHash < IPX_ADDRESS_HASH_COUNT; CurrentHash++) {

                    for (p = Device->AddressDatabases[CurrentHash].Flink;
                         p != &Device->AddressDatabases[CurrentHash];
                         p = p->Flink) {

                         Address = CONTAINING_RECORD (p, ADDRESS, Linkage);

                         Address->LocalAddress.NetworkAddress = Network;
                    }
                }

                IPX_FREE_LOCK (&Device->Lock, LockHandle);

                //
                // Let SPX know because it fills in its own headers.
                //
                if (Device->UpperDriverBound[IDENTIFIER_SPX]) {
                	IPX_DEFINE_LOCK_HANDLE(LockHandle1)
                    IPX_PNP_INFO    IpxPnPInfo;

                    IpxPnPInfo.NewReservedAddress = TRUE;
                    IpxPnPInfo.NetworkAddress = Network;

                    IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                    RtlCopyMemory(IpxPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                    NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, Binding->NicId);
                    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                    //
                    // give the PnP indication
                    //
                    (*Device->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
                        IPX_PNP_ADDRESS_CHANGE,
                        &IpxPnPInfo);

                    IPX_DEBUG(AUTO_DETECT, ("IPX_PNP_ADDRESS_CHANGED to SPX: net addr: %lx\n", Network));
                }

            }
        }
    } else if (Status == STATUS_DUPLICATE_NAME) {

        //
        // If it was a duplicate we still set the binding's local
        // address to the value so we can detect binding sets.
        //

        Binding->LocalAddress.NetworkAddress = Network;

    }

#if 0
	//
    // Set an Ndis OID. This should overwrite any previous setting (they claim).
    //
    if (!Binding->Adapter->MacInfo.MediumAsync) {
        int             count, i;
        int             size;
        NTSTATUS        NdisStatus = STATUS_SUCCESS;
        PADAPTER        Adapter;

        Adapter = Binding->Adapter;

        for (count=0, i=0; i < ISN_FRAME_TYPE_MAX; i++) {
            if (Adapter->Bindings[i]) {
                count++;
            }
        }

        IPX_DEBUG(PNP, ("This adapter has %d valid bindings\n", count));

        size =  FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address) + count * (FIELD_OFFSET(NETWORK_ADDRESS, Address) + sizeof(NETWORK_ADDRESS_IPX));

        AddrList = IpxAllocateMemory(
                                 size,
                                 MEMORY_ADAPTER,
                                 "QoS specific stuff");
	if (AddrList != NULL) {
	   
	   AddrList->AddressCount  = count;
	   AddrList->AddressType    = NDIS_PROTOCOL_ID_IPX;
	   count                   = 0;
	   Addr                    = &AddrList->Address[0];

	   for (i=0; i < ISN_FRAME_TYPE_MAX; i++) {

	      if (Adapter->Bindings[i]) {

		 Addr->AddressLength  = sizeof(NETWORK_ADDRESS_IPX);
		 Addr->AddressType    = NDIS_PROTOCOL_ID_IPX;
		 TdiAddress              = (NETWORK_ADDRESS_IPX *) &Addr->Address[0];

		 TdiAddress->NetworkAddress = Adapter->Bindings[i]->LocalAddress.NetworkAddress;
		 RtlCopyMemory (TdiAddress->NodeAddress, Adapter->Bindings[i]->LocalAddress.NodeAddress, 6);

		 TdiAddress->Socket = 0;

		 IPX_DEBUG(PNP, ("Node is %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x, ",
				 TdiAddress->NodeAddress[0], TdiAddress->NodeAddress[1],
				 TdiAddress->NodeAddress[2], TdiAddress->NodeAddress[3],
				 TdiAddress->NodeAddress[4], TdiAddress->NodeAddress[5]));
		 IPX_DEBUG(PNP, ("Network is %lx\n", REORDER_ULONG (TdiAddress->NetworkAddress)));
		 count++;
		 Addr                 = (PNETWORK_ADDRESS) (((PUCHAR)(&AddrList->Address[0])) + count * (FIELD_OFFSET(NETWORK_ADDRESS, Address) + sizeof(NETWORK_ADDRESS_IPX)));
	      }
	   }

	   IPX_DEBUG(PNP, ("Getting ready to call NDIS\n"));

	   IpxRequest.RequestType = NdisRequestSetInformation;

	   IpxRequest.DATA.SET_INFORMATION.Oid = OID_GEN_NETWORK_LAYER_ADDRESSES;
	   IpxRequest.DATA.SET_INFORMATION.InformationBuffer = AddrList;
	   IpxRequest.DATA.SET_INFORMATION.InformationBufferLength = size;

	   DelayedNdisItem = (PIPX_DELAYED_NDISREQUEST_ITEM)IpxAllocateMemory (
									       sizeof(IPX_DELAYED_NDISREQUEST_ITEM),
									       MEMORY_WORK_ITEM,
									       "Work Item");
	   if ( DelayedNdisItem ) {

	      IPX_DEFINE_LOCK_HANDLE(LockHandle)

	      IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
	      if (Adapter->State != ADAPTER_STATE_STOPPING) {

		 IpxReferenceDevice (Device, DREF_ADAPTER);
		 IpxReferenceAdapter1(Adapter,ADAP_REF_NDISREQ); 
		 DelayedNdisItem->Adapter = (PVOID)Adapter;
		 DelayedNdisItem->IpxRequest = IpxRequest;
		 DelayedNdisItem->AddrListSize = size;
		 ExInitializeWorkItem(
		    &DelayedNdisItem->WorkItem,
		    IpxDelayedSubmitNdisRequest,
		    (PVOID)DelayedNdisItem);

		 ExQueueWorkItem(
		    &DelayedNdisItem->WorkItem,
		    DelayedWorkQueue);

	         IPX_DEBUG(PNP,("Queued the worker thread for IpxDelayedSubmitNdisRequest\n")); 		       	
	      } 
#ifdef DBG
	      else {
		 IPX_DEBUG(PNP,("The adapter %p is stopping, skip IpxDelyedSbmitNdisRequest\n",Adapter)); 
		 IpxFreeMemory (
				DelayedNdisItem,
				sizeof (IPX_DELAYED_NDISREQUEST_ITEM),
				MEMORY_WORK_ITEM,
				"Work Item");
	      }
#endif
              IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
	   } else {
	      IPX_DEBUG(PNP, ("Failed to allocate work-item for NdisRequest.")); 
	   }

	} else {
	   DbgPrint("IPX:IpxAllocateMemory failed, skipped QoS Registration..\n"); 
	}
   } else {
       IPX_DEBUG(PNP, ("Async Medium - skipping QoS OID\n"));
   }
#endif

    Binding->fInfoIndicated = FALSE;
    if ((p = ExInterlockedRemoveHeadList(
               &Device->NicNtfQueue,
               &Device->Lock)) != NULL)
    {
                 PREQUEST Request;

                 Request = LIST_ENTRY_TO_REQUEST(p);

                 IPX_DEBUG(BIND, ("IpxStatus: Got address of binding\n"));
                 Status = GetNewNics(Device, Request, FALSE, NULL, 0, TRUE);

                 //
                 // If not success, we don't queue back the irp. It has
                 // already been queued or completed
                 //
                 if (Status == STATUS_PENDING)
                 {
		            IPX_DEBUG(BIND, ("New address Irp request not responding properly. Status = (%lx)\n", Status));
                 }
                 else
                 {
                     KIRQL OldIrq;
                     //
                     // Status is SUCCESS
                     //
                     IoAcquireCancelSpinLock(&OldIrq);
                     IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
                     IoReleaseCancelSpinLock(OldIrq);
                     REQUEST_STATUS(Request) = Status;
                     ExInterlockedInsertTailList(&Device->NicNtfComplQueue,REQUEST_LINKAGE(Request), &Device->Lock);
                 }

    } else {
        IPX_DEBUG(BIND, ("No IRPs available\n"));
    }

    return Status;

}   /* IpxUpdateBindingNetwork */


INT
IpxReceivePacket (
    IN NDIS_HANDLE ProtocolBindingContext,
	IN PNDIS_PACKET Packet
    )
/*++

Routine Description:

    This routine receives control from the physical provider as an
    indication that a frame has been received on the physical link.
    The packet passed up from NDIS can be held on to by the TDI clients
    that request TDI_EVENT_RECEIVE_EX_DATAGRAM events with us.

Arguments:

    ProtocolBindingContext - The Adapter Binding specified at initialization time.

    Packet - contains the packet received as well as some mediaspecific info.

Return Value:

    return of IpxReceiveIndicationCommon(),

--*/
{
	UINT  HeaderBufferSize = NDIS_GET_PACKET_HEADER_SIZE(Packet);
	UINT  firstbufferLength, bufferLength;
	PNDIS_BUFFER pFirstBuffer;
	PUCHAR   headerBuffer;
	NTSTATUS ntStatus;
	INT	tdiClientCount = 0;
	
	//
	// Query the number of buffers, the first MDL's descriptor and the packet length
	//
	NdisGetFirstBufferFromPacket(Packet,			// packet
								 &pFirstBuffer,		// first buffer descriptor
								 &headerBuffer,	    // ptr to the start of packet
								 &firstbufferLength,// length of the header+lookahead
								 &bufferLength);	// length of the bytes in the buffers

	//
	// ReceiveContext is the packet itself
	//
	
	ntStatus = IpxReceiveIndicationCommon (
					ProtocolBindingContext,
					Packet,                          // ReceiveContext
					headerBuffer,
					HeaderBufferSize,
					headerBuffer + HeaderBufferSize, // LookaheadBuffer
					firstbufferLength - HeaderBufferSize, // LookaheadBufferSize
					bufferLength - HeaderBufferSize, // PacketSize - since the whole packet is indicated
					pFirstBuffer,					 // pMdl
					&tdiClientCount				     // tdi client count
					);

	IPX_DEBUG(RECEIVE, ("IpxReceivePacket: Tdi Client Count is: %lx\n", tdiClientCount));

	return tdiClientCount;
} /* IpxReceivePacket */



BOOLEAN
IpxNewVirtualNetwork(
    IN  PDEVICE Device,
    IN  BOOLEAN NewVirtualNetwork
	)
/*++

Routine Description:

    If the virtualnetwork number changed, this function records this fact
    in the device.

    Called with the BINDACCESSLOCK held.
Arguments:

    Device - Pointer to the Device.

    NewVirtualNetwork - boolean to indicate if the virtual net# changed.

Return Value:

    BOOLEAN -  to indicate whether SPX's reserved address was changed.

--*/
{
    NTSTATUS    ntStatus;
	UCHAR 		VirtualNode[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };
    UCHAR 	InitialLoopbackNodeAddress[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x02};
    BOOLEAN     ReservedAddrChanged = FALSE;
    PBINDING    Loopback = NULL, Binding = NULL;

    if (Device->VirtualNetworkNumber) {
        
       //
       // Added the check for valid bindings so that we dont deref null bindings.
       // Also the net number is useless without adapters. [Shreem]
       // we could probably use a permanent loopback binding in future.
       // 
        if (NewVirtualNetwork && Device->ValidBindings) {
            //
            // If a new one appeared.
            //
            ntStatus = RipInsertLocalNetwork(
                         Device->VirtualNetworkNumber,
                         0,                              // NIC ID
                         NIC_ID_TO_BINDING(Device, 1)->Adapter->NdisBindingHandle,
                         1);

            if (ntStatus != STATUS_SUCCESS) {



                //
                // Log the appropriate error, then ignore the
                // virtual network. If the error was
                // INSUFFICIENT_RESOURCES, the RIP module
                // will have already logged an error.
                //

                if (ntStatus == STATUS_DUPLICATE_NAME) {

                    IPX_DEBUG (AUTO_DETECT, ("Ignoring virtual network %lx, conflict\n", REORDER_ULONG (Device->VirtualNetworkNumber)));

                    IpxWriteResourceErrorLog(
                        Device->DeviceObject,
                        EVENT_IPX_INTERNAL_NET_INVALID,
                        0,
                        REORDER_ULONG (Device->VirtualNetworkNumber));
                }

                Device->VirtualNetworkNumber = 0;
                goto NoVirtualNetwork;

            }

            //
            // If the number is non-zero now, a new one appeared
            //
            Device->VirtualNetwork = TRUE;
            Device->MultiCardZeroVirtual = FALSE;
            RtlCopyMemory(Device->SourceAddress.NodeAddress, VirtualNode, 6);
            Device->SourceAddress.NetworkAddress = Device->VirtualNetworkNumber;
            ReservedAddrChanged = TRUE;
            
            //
            //  Loopback Adapter might need to be primed too [shreem]
            //
    
            if (Device->VirtualNetwork) {
    
                Loopback = NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID);
        
                Loopback->LocalAddress.NetworkAddress = Device->VirtualNetworkNumber;
                RtlCopyMemory (Loopback->LocalAddress.NodeAddress, InitialLoopbackNodeAddress, 6);
                RtlCopyMemory (Loopback->LocalMacAddress.Address, InitialLoopbackNodeAddress, 6);
    
            }

            //
            // If RIP is not bound, then this node is a RipResponder
            //
            if (!Device->UpperDriverBound[IDENTIFIER_RIP]) {
                Device->RipResponder = TRUE;
            }
        }

    } else {
NoVirtualNetwork:
        Device->VirtualNetwork = FALSE;

        //
        // See if we need to be set up for the fake
        // virtual network.
        //

        if (Device->ValidBindings > 1) {

            CTEAssert (Device->VirtualNetworkOptional);

            //
            // In this case we return as our local node the
            // address of the first card. We will also only
            // direct SAP sends to that card.
            //

            Device->MultiCardZeroVirtual = TRUE;

        } else {

            Device->MultiCardZeroVirtual = FALSE;
        }

        if (NewVirtualNetwork) {
            //
            // The virtual network number disappeared this time
            //

            //
            // Remove the prev. net # from the RIP tables here
            //
            RipAdjustForBindingChange (0, 0, IpxBindingDeleted);

            //
            // If we were a RipResponder, we are not anymore
            //
            if (Device->RipResponder) {
                Device->RipResponder = FALSE;
            }
        }

        //
        // Since there is not virtual network number, SPX's reserved address is
        // the address of the first binding. This could have changed because of
        // several reasons: if there was a WAN binding only earlier and this time
        // a LAN binding appeared, or if the first LAN binding disappeared. Instead
        // of checking for all these conditions, check if the Device's sourceaddress
        // and that of the first mis-match.
        // NB uses the address of the first device always and hence does not need
        // this mechanism to determine if this is a reserved address change.
        //

         if (NULL == (Binding = NIC_ID_TO_BINDING(Device, FIRST_REAL_BINDING))) {
             Binding = NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID);
         }

         if (!RtlEqualMemory( &Device->SourceAddress,
                              &Binding->LocalAddress,
                              FIELD_OFFSET(TDI_ADDRESS_IPX,Socket))) {

             RtlCopyMemory(  &Device->SourceAddress,
                             &Binding->LocalAddress,
                             FIELD_OFFSET(TDI_ADDRESS_IPX,Socket));

             ReservedAddrChanged = TRUE;
         }
    }
#ifdef  SNMP
    *(UNALIGNED ULONG *)(IPX_MIB_ENTRY(Device, SysNetNumber)) = Device->SourceAddress.NetworkAddress;

    *(UNALIGNED ULONG *)(IPX_MIB_ENTRY(Device, SysNode)) =
        *(UNALIGNED ULONG *)(Device->SourceAddress.NodeAddress);
    *(UNALIGNED USHORT *)(IPX_MIB_ENTRY(Device, SysNode)+4) =
        *(UNALIGNED USHORT *)(Device->SourceAddress.NodeAddress+4);
#endif
    return ReservedAddrChanged;
}


VOID
IpxBindAdapter(
	OUT	PNDIS_STATUS	Status,
	IN	NDIS_HANDLE		BindContext,
	IN	PNDIS_STRING	DeviceName,
	IN	PVOID			SystemSpecific1,
	IN	PVOID			SystemSpecific2
	)

/*++

Routine Description:

	This routine receives a Plug and Play notification about a new
	adapter in the machine. We are called here only if this adapter
	is to be bound to us, so we don't make any checks for this.

Arguments:

    Status - NDIS_STATUS_SUCCESS, NDIS_STATUS_PENDING

    BindContext - context to represent this bind indication

    DeviceName - Name of the adapter that appeared (e.g. \Device\Lance1)

    SystemSpecific1/2 - Not used here

Return Value:

    Status - NDIS_STATUS_SUCCESS

--*/
{
	NTSTATUS	ntStatus;
	PDEVICE		Device = IpxDevice;
	PADAPTER	Adapter = NULL;
    CONFIG      Config;
    UINT		i;
	ULONG       Temp, SuccessfulOpens=0;
	PBINDING	Binding;
	BINDING_CONFIG	ConfigBinding;
	ULONG		ValidBindings;
	USHORT		AutoDetectReject;
	BOOLEAN		NewVirtualNetwork = FALSE;
    BOOLEAN     FirstDevice = FALSE;
    BOOLEAN     ReservedAddrChanged = FALSE;
	IPX_PNP_INFO	IpxPnPInfo;
    PLIST_ENTRY p = NULL;
    PREQUEST Request = NULL;

    NDIS_REQUEST            IpxRequest;
    PNETWORK_ADDRESS_LIST   AddrList;
    PNETWORK_ADDRESS        Address;
    NETWORK_ADDRESS_IPX UNALIGNED *TdiAddress;	

    IPX_DEFINE_LOCK_HANDLE(LockHandle1)
	IPX_DEFINE_LOCK_HANDLE(LockHandle)
    IPX_DEFINE_LOCK_HANDLE (OldIrq)

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    *Status = NDIS_STATUS_SUCCESS; 

    //
    // This keeps track of the init time adapters
    //
    IPX_GET_LOCK(&Device->Lock, &LockHandle);
    
    if (FALSE == Device->NoMoreInitAdapters) {

        ++Device->InitTimeAdapters;

        IPX_DEBUG(PNP,("BindAdapter: Count %d\n", Device->InitTimeAdapters));
    }

    IPX_FREE_LOCK(&Device->Lock, LockHandle);

	//
    // Used for error logging
    //

    Config.DriverObject = (PDRIVER_OBJECT)Device->DeviceObject;
    Config.RegistryPathBuffer = Device->RegistryPathBuffer;

    ConfigBinding.AdapterName = *DeviceName;
    ConfigBinding.DriverObject = (PDRIVER_OBJECT)Device->DeviceObject;
	//
	// Read the registry to see if a virtual network number appeared/disappeared
	//
    ntStatus = IpxPnPGetVirtualNetworkNumber(&Config);

    if (ntStatus != STATUS_SUCCESS) {
        
        DbgPrint("IPX BindAdapter -> PnPGetVirtualNetworkNumber returned: %lx\n", ntStatus);
		
        IPX_DEBUG(PNP, ("Could not read the vnet#: registrypathbuffer: %lx\n", Device->RegistryPathBuffer));
	*Status = ntStatus;
        goto InitFailed;
		//return;
    }

    Temp = REORDER_ULONG (Config.Parameters[CONFIG_VIRTUAL_NETWORK]);

	//
	// If the virtual network number changed, record this fact.
	//
	if (Device->VirtualNetworkNumber != Temp) {
		NewVirtualNetwork = TRUE;
        Device->VirtualNetworkNumber = Temp;
	}

    Device->VirtualNetworkOptional = (BOOLEAN)(Config.Parameters[CONFIG_VIRTUAL_OPTIONAL] != 0);

	IPX_DEBUG(PNP, ("Virtual net # is: %lx\n", Temp));

	//
	// For each FrameType and Network Number configured, initialize the
	// FrameType array in the CONFIG_BINDING
	//

    IPX_DEBUG(PNP, ("IRQL is %x\n", KeGetCurrentIrql()));
	ntStatus = IpxPnPGetAdapterParameters(
					&Config,
                    DeviceName,
	                &ConfigBinding);

	if (ntStatus != STATUS_SUCCESS) {
	    DbgPrint("IPX BindAdapter -> PnPGetAdapterParameters returned: %lx\n", ntStatus);
	    IPX_DEBUG(PNP, ("Could not read the adapter params: DeviceName: %lx\n", DeviceName->Buffer));
	    *Status = ntStatus;
	    goto InitFailed;

		//return;
	}

    IPX_DEBUG(PNP, ("ConfigBinding.FrameTypeCount: %lx\n", ConfigBinding.FrameTypeCount));

    //
    // Reset the auto-detect state to init so that if a receive occurs on this binding
    // before we can place this binding in the device's binding array, we know of it.
    //
	Device->AutoDetectState = AUTO_DETECT_STATE_INIT;

    //
	// Register adapter with NDIS; query the various parameters; get the WAN line count
	// if this is a WAN adapter.
	// Allocate the bindings corresponding to this adapter
	//
	for (i = 0; i < ConfigBinding.FrameTypeCount; i++) {
	
		//
		// If successful, this queues them on Device->InitialBindingList. not right now
		// Adapter is NULL first time and is allocated then. In subsequent calls,
		// it is not NULL and the bindings are hooked to this adapter.
	
		ntStatus = IpxBindToAdapter (Device, &ConfigBinding, &Adapter, i);
	
		//
		// If this failed because the adapter could not be bound
		// to, then don't try any more frame types on this adapter.
		// For other failures we do try the other frame types.
		//
	
		if (ntStatus == STATUS_DEVICE_DOES_NOT_EXIST) {
			break;
		}

        //
        // If the status is STATUS_NOT_SUPPORTED, then this frametype mapped to a previously
        // initialized one. In this case, remove this index fron the FrameType array so that
        // when we try to update the binding array, we dont have duplicates.
        //
        if (ntStatus == STATUS_NOT_SUPPORTED) {
            ULONG j;

            //
            // Remove this frametype from the FrameType array.
            //
            for (j = i+1; j < ConfigBinding.FrameTypeCount; j++) {
                ConfigBinding.FrameType[j-1] = ConfigBinding.FrameType[j];
            }

            --ConfigBinding.FrameTypeCount;

            //
            // Decrement so we see the one just moved up.
            //
            --i;

#if DBG
            for (j = 0; j < ISN_FRAME_TYPE_MAX; j++) {
                IPX_DEBUG (AUTO_DETECT, ("%d: type %d, net %d, auto %d\n",
                    j, ConfigBinding.FrameType[j], ConfigBinding.NetworkNumber[j], ConfigBinding.AutoDetect[j]));
            }
#endif
            continue;
        }

		if (ntStatus != STATUS_SUCCESS) {
			continue;
		}
	
		if (ConfigBinding.AutoDetect[i]) {
			Device->AutoDetect = TRUE;
		}

		CTEAssert(Adapter);

		++SuccessfulOpens;

		//
		// Even for WAN adapters, the FrameTypeCount is set to 4. We only need to
		// allocate one binding for WAN; the others come later.
		//
		if (Adapter->MacInfo.MediumAsync) {
		   break;
		}
	}

	if (SuccessfulOpens == 0) {
	    *Status = NDIS_STATUS_FAILURE; 
	   goto InitFailed;
	}

    ASSERT(SystemSpecific2 != NULL); 

	Adapter->PNPContext = SystemSpecific2; 
	//
	// Place all the bindings corresponding to this adapter in the binding array
	// Also resolve binding sets for non-autodetect bindings.
	//

	//
	// Obtain lock to the Binding related stuff.
	//
	IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

	IpxPnPUpdateBindingArray (Device, Adapter, &ConfigBinding);

	//
	// Release access to the Binding related stuff.
	//
	IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

	//
	// If at least one card appeared here, set our state
	// to open
	//
	// what if all these bindings are eliminated - then
	// the state is not open...
	//
    if (Device->ValidBindings > 0) {
    	if (Device->State == DEVICE_STATE_LOADED) {
    		FirstDevice = TRUE;
    		Device->State = DEVICE_STATE_OPEN;
    	}
    }

    //
    // We don't do auto-detect/bindingsets for WAN lines: skip over.
    //
	if (Adapter->MacInfo.MediumAsync) {
		goto jump_wan;
	}

    //
    // If this adapter already has a configured network number, and
    // the network number is already plumbed in the binding, we dont need 
    // to Autodetect [MS]. NtBug 101876
    //
    for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {

       Binding = Adapter->Bindings[i];

       //
       // Skip empty binding slots
       if (!Binding) {
          continue;
       }
       
       // Bindings that were configured
       // for a certain network number, we inserted those above.
   
       if (Binding->ConfiguredNetworkNumber != 0) {
          goto AlreadyConfigured;
       }
    
    }
       
	//
	// Auto-detect the network number. Update the results for only the
	// bindings corresponding to this adapter
	//

	//
	// Queue a request to discover our locally attached
	// adapter addresses. This must succeed because we
	// just allocated our send packet pool. We need
	// to wait for this, either because we are
	// auto-detecting or because we need to determine
	// if there are multiple cards on the same network.
	//
	
	KeInitializeEvent(
		&Device->AutoDetectEvent,
		NotificationEvent,
		FALSE
	);
	
	Device->AutoDetectState = AUTO_DETECT_STATE_RUNNING;
	
	//
	// Make this 0; after we are done waiting, which means
	// the packet has been completed, we set it to the
	// correct value.
	//
	
	// Device->IncludedHeaderOffset = 0;

	IPX_BEGIN_SYNC (&SyncContext);
	ntStatus = RipQueueRequest (0xffffffff, RIP_REQUEST);
	IPX_END_SYNC (&SyncContext);
	
	if (ntStatus != STATUS_PENDING) {
	   DbgPrint("IPX: RipQueueRequest returned status %x, skip auto-detect\n", ntStatus); 
	} else {
	   //
	   // This is set when this rip send completes.
	   //
	
	   NTSTATUS status = STATUS_SUCCESS;
	   
	   IPX_DEBUG (AUTO_DETECT, ("Waiting for AutoDetectEvent\n"));


	   status = KeWaitForSingleObject(
					  &Device->AutoDetectEvent,
					  Executive,
					  KernelMode,
					  TRUE,
					  (PLARGE_INTEGER)NULL
					  );

	}

AlreadyConfigured:

	Device->AutoDetectState = AUTO_DETECT_STATE_PROCESSING;
	
	//
	// Now that we are done receiving responses, insert the
	// current network number for every auto-detect binding
	// to the rip database.
	//

	//
	// Obtain exclusive access to the Binding related stuff.
	//
	IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

	//
	// Note, here we go thru' only the bindings corresponding to this adapter
	//
	for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {
	
		Binding = Adapter->Bindings[i];
	
		//
		// Skip empty binding slots or bindings that were configured
		// for a certain network number, we inserted those above.
		// If no network number was detected, also skip it.
		//
	
		if ((!Binding) ||
			(Binding->ConfiguredNetworkNumber != 0) ||
			(Binding->TentativeNetworkAddress == 0)) {
	
			continue;
		}
	
		IPX_DEBUG (AUTO_DETECT, ("Final score for %lx on %lx is %d - %d\n",
			REORDER_ULONG(Binding->TentativeNetworkAddress),
			Binding,
			Binding->MatchingResponses,
			Binding->NonMatchingResponses));
	
		//
		// We don't care about the status.
		//

        ntStatus = RipInsertLocalNetwork(
        			 Binding->TentativeNetworkAddress,
        			 Binding->NicId,
        			 Binding->Adapter->NdisBindingHandle,
        			 (USHORT)((839 + Binding->MediumSpeed) / Binding->MediumSpeed));

        if ((ntStatus != STATUS_SUCCESS) &&
        	(ntStatus != STATUS_DUPLICATE_NAME)) {

        	//
        	// We failed to insert, keep it at zero, hopefully
        	// we will be able to update later.
        	//

#if DBG
        	DbgPrint ("IPX: Could not insert net %lx for binding %lx\n",
        		REORDER_ULONG(Binding->LocalAddress.NetworkAddress),
        		Binding);
#endif
        	CTEAssert (Binding->LocalAddress.NetworkAddress == 0);

        } else {

        	Binding->LocalAddress.NetworkAddress = Binding->TentativeNetworkAddress;
        }

		Binding->LocalAddress.NetworkAddress = Binding->TentativeNetworkAddress;		
	}
	
	// ValidBindings = Device->BindingCount;

	ValidBindings = Device->ValidBindings;

	// if (Device->AutoDetect) {
	
    ValidBindings = IpxResolveAutoDetect (Device, ValidBindings, &LockHandle1, &Device->RegistryPath, Adapter);
	
	//}

	//
	// Adjust all the indices by the number of AutoDetect bindings thrown away
	//
	// AutoDetectReject = (USHORT)(Device->BindingCount - ValidBindings);

	AutoDetectReject = (USHORT)(Device->ValidBindings - ValidBindings);

	Device->HighestLanNicId -= AutoDetectReject;
	Device->HighestExternalNicId -= AutoDetectReject;
	Device->HighestType20NicId -= AutoDetectReject;
	Device->SapNicCount -= AutoDetectReject;

	Device->ValidBindings = (USHORT)ValidBindings;
	
	//
	// Now see if any bindings are actually on the same
	// network. This updates the Device->HighestExternalNicId
	// and Device->HighestType20NicId, SapNicCount, HighestLanNicId
	//

	//
	// Do this only for the auto-detect bindings
	// check this
    //

	//if (Device->AutoDetect) {
		IpxResolveBindingSets (Device, Device->HighestExternalNicId);
	//}

    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

jump_wan:

	IPX_DEBUG(PNP, ("BindingCount: %lu\n", Device->BindingCount));
	IPX_DEBUG(PNP, ("ValidBindings: %lu\n", Device->ValidBindings));
	IPX_DEBUG(PNP, ("HighestLanNicId: %lu\n", Device->HighestLanNicId));
	IPX_DEBUG(PNP, ("HighestExternalNicId: %lu\n", Device->HighestExternalNicId));
	IPX_DEBUG(PNP, ("HighestType20NicId: %lu\n", Device->HighestType20NicId));
	IPX_DEBUG(PNP, ("SapNicCount: %lu\n", Device->SapNicCount));
	IPX_DEBUG(PNP, ("BindingArray: %lx\n", Device->Bindings));

    //
    // Enable this regardless of whether any of our clients enabled b'cast.
    // NB always enables it, so we are fine.
    //
    // Since we dont increment the Broadcast count in the device, we will disable b'casts
    // correctly if the count drops to 0.
    //
    // If the ISN clients appear before the adapters, they increment the BCount, but
    // since the ValidBindings is 0, all works. Then, when the adapters appear, we enable
    // the broadcasts here.
    //
    // If the adapters appear before the ISN clients, then the broadcast is enabled on
    // the adapters here and the adapter's flag is set to indicate this, which will prevent
    // any further calls to NDIS when the ISN clients force an IpxAddBroadcast.
    //
    
    if (!Device->EnableBroadcastPending) {
       
       Device->EnableBroadcastPending = TRUE;
       IpxBroadcastOperation((PVOID)TRUE);
    
    }

	//
	// For multiple adapters, use the offset of the first...why not.
	//
	
#if 0
	Device->IncludedHeaderOffset = Device->Bindings[1]->DefHeaderSize;
#endif
	
	Device->IncludedHeaderOffset = MAC_HEADER_SIZE;


    //
    // If we already registered a virtual network with the loopback adapter, remove it.
    //
    if (NewVirtualNetwork) {

        if (!Device->UpperDriverBound[IDENTIFIER_RIP]) {
        
            PIPX_ROUTE_ENTRY RouteEntry = NULL;
            ULONG   Segment;

            Segment = RipGetSegment ((PUCHAR)&Temp);
        
            IPX_GET_LOCK (&Device->SegmentLocks[Segment], &LockHandle);

            RouteEntry = RipGetRoute (Segment, (PUCHAR)&Temp); 

            if (RouteEntry != (PIPX_ROUTE_ENTRY)NULL) {

                RipDeleteRoute (Segment, RouteEntry);
                IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);
                IpxFreeMemory (RouteEntry, sizeof(IPX_ROUTE_ENTRY), MEMORY_RIP, "RouteEntry");
                IPX_DEBUG(BIND, ("Removed %lx from routing table\n", Temp));

            } else {
            
                IPX_DEBUG(BIND, ("Couldnt find %lx in routing table\n", Temp));
            
                IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);
            }
        
            IPX_DEBUG(PNP, ("Removed the route to LOOPBACK number\n"));
            
        } else {
            //
            // Talk to PMay and figure this out.
            //
            IPX_DEBUG(BIND, ("******** PMAY needs to know about this? \n"));

            //DbgBreakPoint();
        }
    }

    //
    // This function updates flags like RipResponder, MultiCardZeroVirtual, etc.
    // If the VirtualNetwork number changed (NewVirtualNetwork is TRUE), it updates
    // the Device structure and the RIP tables accordingly.
    // It returns a boolean to indicate if SPX's reserved address changed.
    //
    ReservedAddrChanged = IpxNewVirtualNetwork(Device, NewVirtualNetwork);

    //
    // Update the values once the auto-detect bindings have been thrown away...
    //
    IpxPnPUpdateDevice(Device);


	Device->AutoDetectState = AUTO_DETECT_STATE_DONE;
	
	IPX_DEBUG (DEVICE, ("Node is %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x, ",
				Device->SourceAddress.NodeAddress[0], Device->SourceAddress.NodeAddress[1],
				Device->SourceAddress.NodeAddress[2], Device->SourceAddress.NodeAddress[3],
				Device->SourceAddress.NodeAddress[4], Device->SourceAddress.NodeAddress[5]));
	IPX_DEBUG (DEVICE, ("Network is %lx\n",
				REORDER_ULONG (Device->SourceAddress.NetworkAddress)));

    
    //
    // Change the address in the AddressFiles list to the address of this Adapter now.
    //
    IPX_DEBUG(BIND, ("REAL ADAPTERS? : %x\n", Device->RealAdapters));
    
    if (FALSE == Device->RealAdapters || 
        (REORDER_ULONG(INITIAL_LOOPBACK_NET_ADDRESS) == (NIC_ID_TO_BINDING(IpxDevice, LOOPBACK_NIC_ID))->LocalAddress.NetworkAddress)) {
        
        PADDRESS_FILE   AddrFile    = NULL;
        PLIST_ENTRY     Current     = NULL;
        PBINDING        Loopback    = NULL, FirstNonZero = NULL, TempB = NULL;
        PADDRESS        AddrObj     = NULL;
        UINT            k = 0;
        //
        // First change the Loopback Binding's network number to what we discovered.
        //
        Loopback = NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID);

        if (Loopback->LocalAddress.NetworkAddress == REORDER_ULONG(INITIAL_LOOPBACK_NET_ADDRESS)) {

            //
            // ideally we need to find the first non-zero network number
            //

            for (k = FIRST_REAL_BINDING; k <= IpxDevice->ValidBindings; k++) {
                
                TempB = NIC_ID_TO_BINDING(IpxDevice, k);
                
                if (!TempB) {
                    continue;
                }

                if (0 != TempB->LocalAddress.NetworkAddress) {

                    FirstNonZero = TempB;
                    IPX_DEBUG(BIND, ("#%lx Binding had a non zero netnum: %lx\n", k, TempB->LocalAddress.NetworkAddress));
                    
                    Loopback->LocalAddress.NetworkAddress = TempB->LocalAddress.NetworkAddress;
                    Device->SourceAddress.NetworkAddress = TempB->LocalAddress.NetworkAddress;
                    
                    IPX_DEBUG(BIND, ("Changed Loopback address to %lx\n", TempB->LocalAddress.NetworkAddress));
                    
                    RtlCopyMemory (Loopback->LocalAddress.NodeAddress, TempB->LocalAddress.NodeAddress, 6);
                    RtlCopyMemory (Loopback->LocalMacAddress.Address, TempB->LocalAddress.NodeAddress, 6);
                    
                    RtlCopyMemory (Device->SourceAddress.NodeAddress, TempB->LocalAddress.NodeAddress, 6);

                    IPX_DEBUG(BIND, ("Changed Loopback NODE address too\n"));
            
                    if (NULL != Loopback->TdiRegistrationHandle) {
                        
                        if ((ntStatus = TdiDeregisterNetAddress(
                                                                Loopback->TdiRegistrationHandle
                                                                )) != STATUS_SUCCESS) {
                    
                            IPX_DEBUG(PNP, ("TdiDeregisterNetAddress failed: %lx", ntStatus));
                        } else {
			   Loopback->TdiRegistrationHandle = NULL;
			}
                    }
                    

                    break;
                }
                
            }

            if (NULL != FirstNonZero) {
               
                //
                // Then munge the addresses.
                //

                CTEGetLock(&Device->Lock, &LockHandle);

                for (i = 0; i < IPX_ADDRESS_HASH_COUNT; i++) {

                    Current = Device->AddressDatabases[i].Flink;
    
                    while (Current != &Device->AddressDatabases[i]) {
                
                        //CTEGetLock (&AddrFile->Address->Lock, &LockHandle);

                        // do we need the addrfile lock here?
                    
                        AddrObj = CONTAINING_RECORD(Current, 
                                                    ADDRESS,
                                                    Linkage);
    
                        //if (AddrFile->State == ADDRESSFILE_STATE_OPEN) {
                        
                        if (AddrObj->LocalAddress.NetworkAddress == REORDER_ULONG(INITIAL_LOOPBACK_NET_ADDRESS) ||
                            AddrObj->LocalAddress.NetworkAddress == 0) {

                            IPX_DEBUG(BIND, ("Found an Address using the Loopback netnumber: %lx!!\n", AddrObj));
                            //
                            // Change the address now.
                            //
                            RtlCopyMemory(&AddrObj->LocalAddress, 
                                          &FirstNonZero->LocalAddress, 
                                          sizeof(TDI_ADDRESS_IPX));
                            //                 }

                            IPX_DEBUG(BIND, ("Set Address #%d to the %lx\n", i, AddrObj->LocalAddress.NetworkAddress));

                        } else {
                        
                            IPX_DEBUG(BIND, ("AddressObj(%lx): Network Address->%lx\n", AddrObj, AddrObj->LocalAddress.NetworkAddress));

                            //DbgBreakPoint();

                        }
    

                        //              CTEFreeLock (&AddrFile->Address->Lock, LockHandle);
    
                        Current = Current->Flink;
                    }

                    IPX_DEBUG(BIND, ("No more entries in this Hash\n"));
            
                }
            

                CTEFreeLock(&Device->Lock, LockHandle);


                //
                // Remove the loopback network number if it was registered.
                //
        
                if (!Device->UpperDriverBound[IDENTIFIER_RIP]) {
            
                    PIPX_ROUTE_ENTRY RouteEntry = NULL;
                    ULONG   Segment;
                    ULONG   LoopbackNet = REORDER_ULONG(INITIAL_LOOPBACK_NET_ADDRESS);

                    Segment = RipGetSegment ((PUCHAR)&LoopbackNet);
            
                    IPX_GET_LOCK (&Device->SegmentLocks[Segment], &LockHandle);

                    RouteEntry = RipGetRoute (Segment, (PUCHAR)&LoopbackNet); 

                    if (RouteEntry != (PIPX_ROUTE_ENTRY)NULL) {

                        RipDeleteRoute (Segment, RouteEntry);
                        IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);
                        IpxFreeMemory (RouteEntry, sizeof(IPX_ROUTE_ENTRY), MEMORY_RIP, "RouteEntry");
                        IPX_DEBUG(BIND, ("Removed %lx from routing table\n", LoopbackNet));

                    } else {
                
                        IPX_DEBUG(BIND, ("Couldnt find %lx in routing table\n", LoopbackNet));

                        IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);
                    }
            
                    IPX_DEBUG(PNP, ("Removed the route to LOOPBACK number\n"));
                
                } else {
                    //
                    // Talk to PMay and figure this out.
                    //
                    IPX_DEBUG(PNP,("******** PMAY needs to know about this? \n"));

                    //DbgBreakPoint();
                }


            }


        } else {

            IPX_DEBUG(BIND, ("Loopback address to %lx\n", Loopback->LocalAddress.NetworkAddress));

        }
        
        //
        // dont we need to update all the other device sourceaddresses etc. too?
        //
        
    } else {
        
        IPX_DEBUG(BIND, ("---------------> Already have REAL adapters\n"));
    }

    IPX_DEBUG (DEVICE, ("Node is %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x, ",
            Device->SourceAddress.NodeAddress[0], Device->SourceAddress.NodeAddress[1],
            Device->SourceAddress.NodeAddress[2], Device->SourceAddress.NodeAddress[3],
            Device->SourceAddress.NodeAddress[4], Device->SourceAddress.NodeAddress[5]));
    IPX_DEBUG (DEVICE, ("Network is %lx\n",
            REORDER_ULONG (Device->SourceAddress.NetworkAddress)));


    //
    // Start the timer which updates the RIP database
    // periodically. For the first one we do a ten
    // second timeout (hopefully this is enough time
    // for RIP to start if it is going to).
     //
    if (FALSE == Device->RealAdapters) {

        IpxReferenceDevice (Device, DREF_LONG_TIMER);

        CTEStartTimer(
            &Device->RipLongTimer,
            10000,
            RipLongTimeout,
            (PVOID)Device);

    }


    //
    // We have a real adapter now.
    //
    Device->RealAdapters = TRUE;

	//
	// Set up the LineInfo struct.
	//
	IpxPnPInfo.LineInfo.LinkSpeed = Device->LinkSpeed;
	IpxPnPInfo.LineInfo.MaximumPacketSize =
		Device->Information.MaximumLookaheadData + sizeof(IPX_HEADER);
	IpxPnPInfo.LineInfo.MaximumSendSize =
		Device->Information.MaxDatagramSize + sizeof(IPX_HEADER);
	IpxPnPInfo.LineInfo.MacOptions = Device->MacOptions;

    IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

    //
    // Inform NB and TDI of all the bindings corresponding to this adapter
    //
    for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {
        Binding = Adapter->Bindings[i];

        //
        // If a NULL binding or a binding set slave, dont inform NB about it.
        //
        if (!Binding || (Binding->NicId > Device->HighestExternalNicId)) {
#if DBG
            if (Binding) {
                IPX_DEBUG(PNP, ("Binding: %lx, Binding set slave\n", Binding));
            }
#endif
            continue;
        }

        //
        // We dont want to inform AFD of bogus wan addresses, we notify
        // on lineup anyways. [ShreeM]
        //
        if (Adapter->MacInfo.MediumAsync) {
           Binding->TdiRegistrationHandle = NULL;

           IPX_DEBUG(PNP, ("Down WAN Binding - Dont TdiRegisterNetAddress\n"));
           continue;
        }

        Binding->PastAutoDetection = TRUE; // tell only on line up
        //
        // Register this address with the TDI clients.
        //
        RtlCopyMemory (Device->TdiRegistrationAddress->Address, &Binding->LocalAddress, sizeof(TDI_ADDRESS_IPX));
 
        if ((ntStatus = TdiRegisterNetAddress(
                        Device->TdiRegistrationAddress,
#if     defined(_PNP_POWER_)
                        &IpxDeviceName,
                        NULL,
#endif _PNP_POWER_
                        &Binding->TdiRegistrationHandle)) != STATUS_SUCCESS) {

            IPX_DEBUG(PNP, ("TdiRegisterNetAddress failed: %lx", ntStatus));
        }

        //
        // Lock taken to check the UpperDriverBound flag.
        // We already have the BindAccessLock at this point.
        //
        IPX_GET_LOCK(&Device->Lock, &LockHandle);

        if (Device->UpperDriverBound[IDENTIFIER_NB]) {
            IPX_FREE_LOCK(&Device->Lock, LockHandle);

            //
            // We could have informed the upper driver from IpxPnPIsnIndicate
            // Ensure that we dont do it twice.
            //
            if (!Binding->IsnInformed[IDENTIFIER_NB]) {

                //
                // Maybe we didnt indicate the Loopback Binding.
                //  NtBug: 132433
                //

                // Make sure we have informed loopback binding before any other bindings.
                // Moved the fix for 132433 to IpxInformNbLoopback. 

                KeWaitForSingleObject(
                    &IpxDevice->NbEvent,
                    Executive,
                    KernelMode,
                    TRUE,
                    (PLARGE_INTEGER)NULL
                    );

                // IpxInformNbLoopback(); 

                //
    			// Also, to ensure that the indications are done in the right order,
                // check if the first card has been indicated yet.
                //
                if ((Binding->NicId != FIRST_REAL_BINDING) &&
                    !NIC_ID_TO_BINDING_NO_ILOCK(Device, FIRST_REAL_BINDING)->IsnInformed[IDENTIFIER_NB]) {

                    //break;
                   continue;
                }

                Binding->IsnInformed[IDENTIFIER_NB] = TRUE;

                IpxPnPInfo.FirstORLastDevice = FALSE;
                if (Binding->NicId == FIRST_REAL_BINDING) {
                    IpxPnPInfo.NewReservedAddress = TRUE;
                } else {
                    IpxPnPInfo.NewReservedAddress = FALSE;
                }

                IpxPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
                RtlCopyMemory(IpxPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, Binding->NicId);

                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                //
                // give the PnP indication
                //
                ASSERT(Binding->NicId != LOOPBACK_NIC_ID); 
                ASSERT(IpxHasInformedNbLoopback()); 

                (*Device->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
                    IPX_PNP_ADD_DEVICE,
                    &IpxPnPInfo);

	            IPX_DEBUG(PNP, ("PnP to NB add: %lx\n", Binding));

                IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
	    }
    	} else {
    	    IPX_FREE_LOCK(&Device->Lock, LockHandle);
        }
    }

	IPX_GET_LOCK(&Device->Lock, &LockHandle);

	if (Device->UpperDriverBound[IDENTIFIER_SPX]) {
    	IPX_FREE_LOCK(&Device->Lock, LockHandle);

        //
        // Always true for SPX
        //
        IpxPnPInfo.NewReservedAddress = TRUE;
        
    	if (FirstDevice) {

            IpxPnPInfo.FirstORLastDevice = TRUE;

            //
            // We could have informed the upper driver from IpxPnPIsnIndicate
            //
            if (!NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->IsnInformed[IDENTIFIER_SPX]) {

                NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->IsnInformed[IDENTIFIER_SPX] = TRUE;
        		//
        		// Inform SPX - the network/node address is the Virtual one if it exists
        		// else the address of the first binding
        		//
                IpxPnPInfo.NetworkAddress = Device->SourceAddress.NetworkAddress;
                RtlCopyMemory(IpxPnPInfo.NodeAddress, Device->SourceAddress.NodeAddress, 6);

        		if (Device->VirtualNetwork) {
        			NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, 0);
        		} else {
            		NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, 1);
                }

                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

    			(*Device->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
    				IPX_PNP_ADD_DEVICE,
    				&IpxPnPInfo);

	            IPX_DEBUG(PNP, ("PnP to SPX add: %lx\n", Binding));
                IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
            }
        } else {

            //
            // Not the first device - inform if the reserved address changed.
            //
            if (ReservedAddrChanged) {
                if (!NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->IsnInformed[IDENTIFIER_SPX]) {
                    NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->IsnInformed[IDENTIFIER_SPX] = TRUE;
                    IPX_DEBUG(PNP, ("Reserved addr changed; SPX not told of first one yet\n"));
                }

                IpxPnPInfo.NetworkAddress = Device->SourceAddress.NetworkAddress;
                RtlCopyMemory(IpxPnPInfo.NodeAddress, Device->SourceAddress.NodeAddress, 6);

                if (Device->VirtualNetwork) {
                    //
                    // new one appeared
                    //
                    NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, 0);
                } else {
                    //
                    // Old one disappeared
                    //
                    NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, 1);
                }

                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                IpxPnPInfo.FirstORLastDevice = FALSE;

	            IPX_DEBUG(PNP, ("PnP to SPX add (res. addr change): %lx\n", Binding));
                (*Device->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
                    IPX_PNP_ADDRESS_CHANGE,
                    &IpxPnPInfo);

                IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
            }
        }
    } else {
    	IPX_FREE_LOCK(&Device->Lock, LockHandle);
    }

    //
    // 
    //
    IPX_DEBUG(BIND, ("Telling RTR Manager that some bindings have been created\n"));
    
    if ((p = ExInterlockedRemoveHeadList(
        &Device->NicNtfQueue,
        &Device->Lock)) != NULL)
    {
        NTSTATUS Status = STATUS_UNSUCCESSFUL;

        Request = LIST_ENTRY_TO_REQUEST(p);

        IPX_DEBUG(BIND, ("IpxBindAdapter: NICs coming in\n"));
        Status = GetNewNics(Device, Request, FALSE, NULL, 0, TRUE);
        if (Status == STATUS_PENDING)
        {
            IPX_DEBUG(BIND, ("GetNewNics returned %lx\n", Status));
        }
        else
        {
            IoAcquireCancelSpinLock(&OldIrq);
            IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
            IoReleaseCancelSpinLock(OldIrq);

            REQUEST_STATUS(Request) = Status;
            IpxCompleteRequest (Request);
            IpxFreeRequest (Device, Request);
            IpxDereferenceDevice (Device, DREF_NIC_NOTIFY);
            IPX_DEBUG(BIND, ("GetNewNics returned SUCCESS (RTR Manager has been informed)\n"));

        }

    } else {
        IPX_DEBUG(BIND,("No IRPs available\n"));
    }

	//
	// Release access to the Binding related stuff.
	//
	IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

#if 0
	//
    // QoS needs IPX to set the network address as an OID now.
    //
    if (!Adapter->MacInfo.MediumAsync) {
        int             count, i;
        int             size;
        NTSTATUS        NdisStatus = STATUS_SUCCESS;
        UNICODE_STRING  AdapterName;

        for (count=0, i=0; i < ISN_FRAME_TYPE_MAX; i++) {
            if (Adapter->Bindings[i]) {
                count++;
            }
        }

        IPX_DEBUG(PNP,("This adapter has %d valid bindings\n", count));

        size =  FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address) + count * (FIELD_OFFSET(NETWORK_ADDRESS, Address) + sizeof(NETWORK_ADDRESS_IPX));

        AddrList = IpxAllocateMemory(
                                 size,
                                 MEMORY_ADAPTER,
                                 "QoS specific stuff");

	if (AddrList != NULL) {

	   RtlZeroMemory(AddrList, size);

	   AddrList->AddressCount  = count;
	   AddrList->AddressType   = NDIS_PROTOCOL_ID_IPX;
	   count                   = 0;
	   Address                 = &AddrList->Address[0];

	   for (i=0; i < ISN_FRAME_TYPE_MAX; i++) {

	      if (Adapter->Bindings[i]) {

		 Address->AddressLength  = sizeof(NETWORK_ADDRESS_IPX);
		 Address->AddressType    = NDIS_PROTOCOL_ID_IPX;
		 TdiAddress              = (NETWORK_ADDRESS_IPX UNALIGNED *) &Address->Address[0];

		 TdiAddress->NetworkAddress = Adapter->Bindings[i]->LocalAddress.NetworkAddress;
		 RtlCopyMemory (TdiAddress->NodeAddress, Adapter->Bindings[i]->LocalAddress.NodeAddress, 6);

		 TdiAddress->Socket = 0;

		 IPX_DEBUG(PNP,("Node is %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x, ",
				TdiAddress->NodeAddress[0], TdiAddress->NodeAddress[1],
				TdiAddress->NodeAddress[2], TdiAddress->NodeAddress[3],
				TdiAddress->NodeAddress[4], TdiAddress->NodeAddress[5]));
		 IPX_DEBUG(PNP,("Network is %lx\n", REORDER_ULONG (TdiAddress->NetworkAddress)));
		 count++;
                 Address                 = (PNETWORK_ADDRESS) (((PUCHAR)(&AddrList->Address[0])) + count * (FIELD_OFFSET(NETWORK_ADDRESS, Address) + sizeof(NETWORK_ADDRESS_IPX)));
	      }
	   }

	   IpxRequest.RequestType = NdisRequestSetInformation;

	   IpxRequest.DATA.SET_INFORMATION.Oid = OID_GEN_NETWORK_LAYER_ADDRESSES;
	   IpxRequest.DATA.SET_INFORMATION.InformationBuffer = AddrList;
	   IpxRequest.DATA.SET_INFORMATION.InformationBufferLength = size;

	   RtlInitUnicodeString(&AdapterName, Adapter->AdapterName);

	   NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, &AdapterName);

	   if (NdisStatus != NDIS_STATUS_SUCCESS) {

	      IPX_DEBUG(PNP,("Setting the OID Failed!! - Error %lx \n", NdisStatus));

	       //*Status = NdisStatus;

	   } else {

	      IPX_DEBUG(PNP,("Setting the OID was successful\n"));

	   }

	   IpxFreeMemory(AddrList,
			 sizeof(NETWORK_ADDRESS_LIST) + sizeof (NETWORK_ADDRESS) + sizeof(TDI_ADDRESS_IPX),
			 MEMORY_ADAPTER,
			 "QoS specific stuff");

	} else {
	   DbgPrint("IPX:Failed to allocate memory. Skipped QoS registration.\n");
	}
    } else {
        IPX_DEBUG(PNP,("Async Medium - skipping\n"));
    }        
#endif

InitFailed:
    //
    // If there are no more init-time adapters, then indicate to TDI now.
    //
    IPX_GET_LOCK(&Device->Lock, &LockHandle);
    
    if (0 == --Device->InitTimeAdapters) {
        IPX_DEBUG(PNP,("BindAdapter EXIT time: Count %d - CALLING TDI!\n", Device->InitTimeAdapters));
        IPX_FREE_LOCK(&Device->Lock, LockHandle);
        
        CTEAssert(Device->NetPnPEvent);

        NdisCompletePnPEvent(
                             STATUS_SUCCESS,
                             NULL,
                             Device->NetPnPEvent
                             );
        
        Device->NetPnPEvent = NULL;

        TdiProviderReady(Device->TdiProviderReadyHandle);
        
    } else {
                
        IPX_DEBUG(PNP,("BindAdapter EXIT time: Count %d - not calling TDI\n", Device->InitTimeAdapters));
        IPX_FREE_LOCK(&Device->Lock, LockHandle);

    }
       
    IPX_DEBUG(PNP, ("IpxBindAdapter returns status %x\n", *Status));
    return;

} /* IpxBindAdapter */


VOID
IpxUnbindAdapter(
	OUT PNDIS_STATUS Status,
	IN	NDIS_HANDLE ProtocolBindingContext,
	IN	NDIS_HANDLE UnbindContext
	)

/*++

Routine Description:

	This routine receives a Plug and Play notification about the removal
    of an existing adapter from the machine. We are called here only if
    this adapter is to be bound to us, so we don't make any checks for this.

Arguments:

    Status - NDIS_STATUS_SUCCESS, NDIS_STATUS_PENDING.

    ProtocolBindingContext - the adapter that got removed.

    UnbindContext - context to represent this bind indication.

Return Value:

    Void - return thru' Status above.

--*/
{
    UCHAR 	InitialLoopbackNodeAddress[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x02};
    NTSTATUS    ntStatus;
    PADAPTER Adapter=(PADAPTER)ProtocolBindingContext;
    CONFIG Config;
    PBINDING    Binding;
    PDEVICE Device=IpxDevice;
    ULONG   i, Temp;
	BOOLEAN		NewVirtualNetwork = FALSE;
    BOOLEAN     NBReservedAddrChanged = FALSE;
    BOOLEAN     SPXInformed = FALSE;
	IPX_PNP_INFO	IpxPnPInfo;
    PBINDING    newMasterBinding, tBinding = NULL;
    PLIST_ENTRY p = NULL;
    PREQUEST Request = NULL;
	USHORT   NicId = 0;

    // QoS 
    NDIS_REQUEST           IpxRequest;
    PNETWORK_ADDRESS_LIST   AddrList;
    UNICODE_STRING  AdapterName;
    NTSTATUS        NdisStatus = STATUS_SUCCESS;

    IPX_DEFINE_LOCK_HANDLE(LockHandle1)
    IPX_DEFINE_LOCK_HANDLE(LockHandle)
    IPX_DEFINE_LOCK_HANDLE (OldIrq)
    IPX_DEFINE_LOCK_HANDLE (LockHandle2)

    PAGED_CODE();

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle2);

    Adapter->State = ADAPTER_STATE_STOPPING; 

    IpxDereferenceAdapter1(Adapter,ADAP_REF_CREATE);

    IPX_FREE_LOCK (&Adapter->Lock, LockHandle2);

    IPX_DEBUG(PNP,("IpxUnbindAdapter: Waiting for ndis requests to be submitted \n"));

    KeWaitForSingleObject(
	       &Adapter->NdisEvent,
	       Executive,
	       KernelMode,
	       TRUE,
	       (PLARGE_INTEGER)NULL
	       );

    IPX_DEBUG(PNP,("IpxUnbindAdapter: Past NdisEvent\n"));

#if 0
    AddrList = IpxAllocateMemory(sizeof(NETWORK_ADDRESS_LIST),
                                 MEMORY_ADAPTER,
                                 "QoS specific stuff");

    if (AddrList != NULL) {

       RtlZeroMemory(AddrList, sizeof(NETWORK_ADDRESS_LIST));
       AddrList->AddressCount  = 0;
       AddrList->AddressType   = NDIS_PROTOCOL_ID_IPX;

       IpxRequest.RequestType = NdisRequestSetInformation;
       IpxRequest.DATA.SET_INFORMATION.Oid = OID_GEN_NETWORK_LAYER_ADDRESSES;
       IpxRequest.DATA.SET_INFORMATION.InformationBuffer = AddrList;
       IpxRequest.DATA.SET_INFORMATION.InformationBufferLength = sizeof(NETWORK_ADDRESS_LIST);

       RtlInitUnicodeString(&AdapterName, Adapter->AdapterName);

       NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, &AdapterName);

       if (NdisStatus != NDIS_STATUS_SUCCESS) {
       
	  IPX_DEBUG(PNP,("IpxUnbindAdapter: Setting the OID Failed!! - Error %lx \n", NdisStatus));

       } else {

	  IPX_DEBUG(PNP,("Setting the OID was successful\n"));

       }

       IpxFreeMemory(AddrList,
		     sizeof(NETWORK_ADDRESS_LIST),
		     MEMORY_ADAPTER,
		     "QoS specific stuff");
    
    } else {
       DbgPrint("IPX:IpxUnbindAdapter:Memory allocation failed! Skipped QoS registration.\n"); 
    }
#endif
    //
    // Free the packet pools, etc. and close the
    // adapter.
    //

    IpxCloseNdis (Adapter);

    //
    // Used for error logging
    //
    Config.DriverObject = (PDRIVER_OBJECT)Device->DeviceObject;

    Config.RegistryPathBuffer = Device->RegistryPathBuffer;
	
    //
    // Read the registry to see if a virtual network number appeared/disappeared
    //
    ntStatus = IpxPnPGetVirtualNetworkNumber(&Config);

    if (ntStatus != STATUS_SUCCESS) {
		IPX_DEBUG(PNP, ("Could not read the vnet#: registrypathbuffer: %lx\n", Device->RegistryPathBuffer));
		*Status = NDIS_STATUS_SUCCESS;
		return;
    }

    Temp = REORDER_ULONG (Config.Parameters[CONFIG_VIRTUAL_NETWORK]);

    //
    // If the VirtualNetwork number changed, record it.
    //
    if (Device->VirtualNetworkNumber != Temp) {
       NewVirtualNetwork = TRUE;
    }

    PAGED_CODE();

    Device->VirtualNetworkOptional = (BOOLEAN)(Config.Parameters[CONFIG_VIRTUAL_OPTIONAL] != 0);

    IPX_DEBUG(PNP, ("Virtual net # is: %lx\n", Temp));

    //
    // If the WAN adapter disappeared, we can simply remove all the WAN bindings since
    // all of them correspond to this single WAN adapter. Since we tell NB only about
    // the first one of these, we need to indicate removal of only one binding to NB.
    //
    if (Adapter->MacInfo.MediumAsync) {
        USHORT   wanLineCount = (USHORT)Adapter->WanNicIdCount;
	PBINDING bindingDemand = NULL;

        CTEAssert(wanLineCount == (Device->HighestExternalNicId - Device->HighestLanNicId));

        //
        // If no more bindings remain, tell upper driver of the same.
        // We go back to the loaded state.
        //

        if ((Device->ValidBindings - wanLineCount) == 1) {
            
            PBINDING LoopbackBinding = NULL;

            //
            // If we are left with one NIC, then we are on loopback only (and no real adapters).
            // [Shreem]
            //

            Device->RealAdapters = FALSE;
        
            // Dont do these anymore [Shreem]
            //IpxPnPInfo.FirstORLastDevice = TRUE;
            // Device->State = DEVICE_STATE_LOADED;

            //
            // Shut down RIP timers, complete address notify requests, etc.
            //
            IpxPnPToLoad();

            //
            // Put the old Loopback address into the Loopback binding.
            //
            LoopbackBinding = NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID);
            
            if (!Device->VirtualNetwork) {

                LoopbackBinding->LocalAddress.NetworkAddress = REORDER_ULONG(INITIAL_LOOPBACK_NET_ADDRESS);
                Device->SourceAddress.NetworkAddress = REORDER_ULONG(INITIAL_LOOPBACK_NET_ADDRESS);
                
                ntStatus = RipInsertLocalNetwork(
                                                 LoopbackBinding->LocalAddress.NetworkAddress,
                                                 LoopbackBinding->NicId,
                                                 LoopbackBinding->Adapter->NdisBindingHandle,
                                                 (USHORT)((839 + LoopbackBinding->MediumSpeed) / LoopbackBinding->MediumSpeed));
             
                if ((ntStatus != STATUS_SUCCESS) &&
                    (ntStatus != STATUS_DUPLICATE_NAME)) {
             
                    //
                    // We failed to insert, keep it at zero, hopefully
                    // we will be able to update later.
                    //
             
                    IPX_DEBUG(LOOPB, ("IPX: Could not insert net %lx for binding %lx\n",
                                      REORDER_ULONG(LoopbackBinding->LocalAddress.NetworkAddress),
                                      LoopbackBinding));
                 
                } else {
             
                    IPX_DEBUG(LOOPB, ("Inserted the loopback address in the RIP table\n"));
             
                }
            }

            RtlCopyMemory (LoopbackBinding->LocalAddress.NodeAddress, InitialLoopbackNodeAddress, 6);
            RtlCopyMemory (LoopbackBinding->LocalMacAddress.Address, InitialLoopbackNodeAddress, 6);
            RtlCopyMemory (Device->SourceAddress.NodeAddress, LoopbackBinding->LocalAddress.NodeAddress, 6);

            RtlCopyMemory ( Device->TdiRegistrationAddress->Address,
                &LoopbackBinding->LocalAddress,
                sizeof(TDI_ADDRESS_IPX));

            if (STATUS_SUCCESS != (ntStatus = TdiRegisterNetAddress(Device->TdiRegistrationAddress,
                                                 &IpxDeviceName,
                                                 NULL,
                                                 &LoopbackBinding->TdiRegistrationHandle))) {
                IPX_DEBUG(PNP, ("Error registering Loopback IPX address\n"));
            }
            
            IpxPnPInfo.FirstORLastDevice = FALSE;

     
        } else {
            CTEAssert(Device->State == DEVICE_STATE_OPEN);
            IpxPnPInfo.FirstORLastDevice = FALSE;
        }


        //
        // DeRegister this address with the TDI clients.
        //

        //
        // Get to the first WAN binding - this is always the one after the last LAN binding.
        //
        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

        Binding = NIC_ID_TO_BINDING_NO_ILOCK(Device, Device->HighestLanNicId+1);

        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

        // CTEAssert(Binding->TdiRegistrationHandle); // We dont register until lineup these days
         
        PAGED_CODE();

        if (Binding->TdiRegistrationHandle) {
           if ((ntStatus = TdiDeregisterNetAddress(Binding->TdiRegistrationHandle)) != STATUS_SUCCESS) {
              IPX_DEBUG(PNP, ("TdiDeRegisterNetAddress failed: %lx", ntStatus));
           } else {
	      Binding->TdiRegistrationHandle = NULL; 
	   }
        }

        //
    	// Set up the LineInfo struct.
    	//
    	IpxPnPInfo.LineInfo.LinkSpeed = Device->LinkSpeed;
    	IpxPnPInfo.LineInfo.MaximumPacketSize =
    		Device->Information.MaximumLookaheadData + sizeof(IPX_HEADER);
    	IpxPnPInfo.LineInfo.MaximumSendSize =
    		Device->Information.MaxDatagramSize + sizeof(IPX_HEADER);
    	IpxPnPInfo.LineInfo.MacOptions = Device->MacOptions;

       	IPX_GET_LOCK(&Device->Lock, &LockHandle);
	if (Device->UpperDriverBound[IDENTIFIER_NB]) {
    	    PBINDING Loopback = NULL;
            IPX_FREE_LOCK(&Device->Lock, LockHandle);

            IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

            Loopback = NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID);
            //
            // Give the PnP indication to indicate the deletion only if it was
            // added before.
            //
            if (Binding->IsnInformed[IDENTIFIER_NB]) {

                IpxPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
                RtlCopyMemory(IpxPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, Binding->NicId);
                IpxPnPInfo.FirstORLastDevice = FALSE;

                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                IPX_DEBUG(PNP, ("Inform NB: delete WAN device\n"));

				CTEAssert(Binding->NicId != LOOPBACK_NIC_ID); 

                (*Device->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
                    IPX_PNP_DELETE_DEVICE,
                    &IpxPnPInfo);

		        Binding->IsnInformed[IDENTIFIER_NB] = FALSE; 

		        IPX_DEBUG(PNP, ("PnP to NB delete: %lx\n", Binding));
		        IPX_DEBUG(PNP,("Indicate to NB IPX_PNP_DELETE_DEVICE with FirstORLastDevice = (%d)",IpxPnPInfo.FirstORLastDevice));  

            }
#if DBG
            else {
                DbgPrint("WAN adapter id: %lx not indicated to NB\n", Binding->NicId);
                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            }
#endif
        } else {
    	    IPX_FREE_LOCK(&Device->Lock, LockHandle);
        }

        //
        // Inform SPX only if this is the last device.
        //

    	IPX_GET_LOCK(&Device->Lock, &LockHandle);

	    if (Device->UpperDriverBound[IDENTIFIER_SPX]) {
    	    IPX_FREE_LOCK(&Device->Lock, LockHandle);

            if (IpxPnPInfo.FirstORLastDevice && Binding->IsnInformed[IDENTIFIER_SPX]) {
                PBINDING Loopback = NULL;


                IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

                CTEAssert(Device->HighestLanNicId == 0);

                //
                // Get to the first WAN binding - this is always the one after the last LAN binding.
                //
                Binding = NIC_ID_TO_BINDING_NO_ILOCK(Device, Device->HighestLanNicId+1);
                IpxPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
                RtlCopyMemory(IpxPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, Binding->NicId);
                IpxPnPInfo.FirstORLastDevice = FALSE;
                
                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                IPX_DEBUG(PNP, ("Inform SPX: delete WAN device\n"));

                (*Device->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
                    IPX_PNP_DELETE_DEVICE,
                    &IpxPnPInfo);

                Binding->IsnInformed[IDENTIFIER_SPX] = FALSE; 
                //
                // Now add loopback back! [Shreem]
                //

                if (!Device->RealAdapters) {
					
                    Loopback = NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID);
                    IpxPnPInfo.NetworkAddress = Loopback->LocalAddress.NetworkAddress;
                    RtlCopyMemory(IpxPnPInfo.NodeAddress, Loopback->LocalAddress.NodeAddress, 6);
                    NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, Loopback->NicId);
                    IpxPnPInfo.NewReservedAddress = TRUE;
                    IpxPnPInfo.FirstORLastDevice = FALSE;

                    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                    IPX_DEBUG(PNP, ("Inform SPX: ADD Loopback device\n"));

                    (*Device->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
                                                                        IPX_PNP_ADD_DEVICE,
                                                                        &IpxPnPInfo);
		    Loopback->IsnInformed[IDENTIFIER_SPX] = TRUE; 
					
                }

            }

        } else {
    	    IPX_FREE_LOCK(&Device->Lock, LockHandle);
        }



        //
        // IPX needs to tell the forwarder about NIC IDs going away. [109160]
        //
        for (i = Device->HighestLanNicId+1; i <= Device->HighestExternalNicId; i++) {
            PBINDING UnBinding;

            UnBinding = NIC_ID_TO_BINDING_NO_ILOCK(Device, i);
            
            if (UnBinding) {
                if (UnBinding->LineUp) {
                    
                    UnBinding->LineUp = FALSE;
                    UnBinding->fInfoIndicated = FALSE;

                } else {

                    IPX_DEBUG(BIND, ("Line is not up for Binding[%lx]\n", i));
                
                }
            }

        }

        IPX_DEBUG(BIND, ("Telling RTR Manager that some bindings are going away.\n"));
        
        if ((p = ExInterlockedRemoveHeadList(
            &Device->NicNtfQueue,
            &Device->Lock)) != NULL)
        {
            NTSTATUS Status = STATUS_UNSUCCESSFUL;
    
            Request = LIST_ENTRY_TO_REQUEST(p);
    
            IPX_DEBUG(BIND, ("IpxUNbindadapter: NICs gone away\n"));
            Status = GetNewNics(Device, Request, FALSE, NULL, 0, TRUE);
            if (Status == STATUS_PENDING)
            {
                IPX_DEBUG(BIND, ("GetNewNics returned %lx\n", Status));
            }
            else
            {
                IoAcquireCancelSpinLock(&OldIrq);
                IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
                IoReleaseCancelSpinLock(OldIrq);
    
                REQUEST_STATUS(Request) = Status;
                IpxCompleteRequest (Request);
                IpxFreeRequest (Device, Request);
                IpxDereferenceDevice (Device, DREF_NIC_NOTIFY);
                IPX_DEBUG(BIND, ("GetNewNics returned SUCCESS (RTR Manager has been informed\n"));
    
            }
    
        }   else {
            IPX_DEBUG(PNP,("No IRPs available\n"));
        }
    

        //
        // Now remove these WAN bindings from the array. Move all the Slave bindings
        // up to where the WAN bindings were.
        //
        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

        for (i = Device->HighestLanNicId+1; i <= Device->HighestExternalNicId; i++) {
            PBINDING UnBinding;

            //
            // Unbind from the adapter - if it is not referenced by any other thread, it will
            // be deleted at this point.
            //

            IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            UnBinding = NIC_ID_TO_BINDING_NO_ILOCK(Device, i);
            
            if (UnBinding) {
               IpxUnBindFromAdapter(UnBinding);
               INSERT_BINDING(Device, UnBinding->NicId, NULL);
            }

            IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
            //
            // Move the slave binding here. 
            // ONLY if they exist! [ShreeM] 98679
            //
            if ((Device->ValidBindings > Device->HighestExternalNicId) && (i+wanLineCount <= Device->ValidBindings)) {
               PBINDING tmpBinding; 
	       tmpBinding = NIC_ID_TO_BINDING_NO_ILOCK(Device, i+wanLineCount); 
	       INSERT_BINDING(Device, i, tmpBinding);
	       tmpBinding->NicId = (unsigned short) i; 
            }

        }

        //
        // Free the demand dial binding place holder.
        //
	bindingDemand = NIC_ID_TO_BINDING(IpxDevice, DEMAND_DIAL_ADAPTER_CONTEXT); 
	if (bindingDemand != NULL) {
	   IpxUnBindFromAdapter(bindingDemand); 
	   INSERT_BINDING(Device, (SHORT) DEMAND_DIAL_ADAPTER_CONTEXT, NULL);      
	}

        //
        // Update the indices
        //
        Device->HighestExternalNicId -= wanLineCount;
        Device->ValidBindings -= wanLineCount;
        Device->BindingCount -= wanLineCount;
        Device->SapNicCount = Device->HighestType20NicId = Device->HighestLanNicId;

        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

        CTEAssert(Device->HighestLanNicId == Device->HighestExternalNicId);

    } else {
        //
        // LAN adapter disappeared.
        //

    	//
    	// Set up the LineInfo struct.
    	//
    	IpxPnPInfo.LineInfo.LinkSpeed = Device->LinkSpeed;
    	IpxPnPInfo.LineInfo.MaximumPacketSize =
    		Device->Information.MaximumLookaheadData + sizeof(IPX_HEADER);
    	IpxPnPInfo.LineInfo.MaximumSendSize =
    		Device->Information.MaxDatagramSize + sizeof(IPX_HEADER);
    	IpxPnPInfo.LineInfo.MacOptions = Device->MacOptions;


        //
        // IPX needs to tell the forwarder about NIC IDs going away. [109160]
        //
        for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {
            PBINDING UnBinding;
            
            UnBinding = Adapter->Bindings[i];

            if (UnBinding) {
                if (UnBinding->LineUp) {
                    
                    UnBinding->LineUp = FALSE;
                    UnBinding->fInfoIndicated = FALSE;
                    IPX_DEBUG(BIND, ("Line is UP for Binding[%lx]\n", i));
            
                } else {

                    IPX_DEBUG(BIND, ("Line is not up for Binding[%lx]\n", i));
                
                }
            }

        }

        IPX_DEBUG(BIND, ("Telling RTR Manager that some bindings are going away.\n"));
        
        if ((p = ExInterlockedRemoveHeadList(
            &Device->NicNtfQueue,
            &Device->Lock)) != NULL)
        {
            NTSTATUS Status = STATUS_UNSUCCESSFUL;
    
            Request = LIST_ENTRY_TO_REQUEST(p);
    
            IPX_DEBUG(BIND, ("IpxUNbindadapter: NICs gone away\n"));
            Status = GetNewNics(Device, Request, FALSE, NULL, 0, TRUE);
            if (Status == STATUS_PENDING)
            {
                IPX_DEBUG(BIND, ("GetNewNics returned %lx\n", Status));
            }
            else
            {
                IoAcquireCancelSpinLock(&OldIrq);
                IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
                IoReleaseCancelSpinLock(OldIrq);
    
                REQUEST_STATUS(Request) = Status;
                IpxCompleteRequest (Request);
                IpxFreeRequest (Device, Request);
                IpxDereferenceDevice (Device, DREF_NIC_NOTIFY);
                IPX_DEBUG(BIND, ("GetNewNics returned SUCCESS (RTR Manager has been informed\n"));
    
            }
    
        } else {
            IPX_DEBUG(PNP,("No IRPs available\n"));
        }
    



    	//
    	// For each binding corresponding to this adapter, inform NB only
    	// if the binding addition was indicated.
    	//
        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
    	for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {
    		Binding = Adapter->Bindings[i];

    		if (!Binding) {
    			continue;
    		}

            //
            // We cannot receive on this binding anymore
            //
            Adapter->Bindings[i] = NULL;

    		//
    		// If this was a slave binding, dont inform of the deletion.
            // Just remove the binding from the binding array and the bindingset list.
    		//

            if (Binding->NicId > Device->HighestExternalNicId) {
                PBINDING    MasterBinding, tempBinding;
		ULONG j; 

                CTEAssert(Binding->BindingSetMember);
                CTEAssert(Binding->CurrentSendBinding == NULL);

                //
                // Traverse the bindingset list and remove this binding from there.
                //
                tempBinding = MasterBinding = Binding->MasterBinding;

                while (tempBinding->NextBinding != MasterBinding) {
                    if (tempBinding->NextBinding == Binding) {
                        tempBinding->NextBinding = tempBinding->NextBinding->NextBinding;
                        break;
                    }
                    tempBinding = tempBinding->NextBinding;
                }
                
                //
                // If no more slaves, this is no longer a bindingset.
                //
                if (MasterBinding->NextBinding == MasterBinding) {
                    MasterBinding->BindingSetMember = FALSE;
                    MasterBinding->CurrentSendBinding = NULL;
                    MasterBinding->ReceiveBroadcast = TRUE;
         
                    IPX_DEBUG(PNP, ("Slave binding: %lx removed, no master: %lx\n", Binding, MasterBinding));
                } else {
                   
                   //
                   // [MS] if this slave had ReceiveBroadcast on, we need to change that...
                   //

                   MasterBinding->CurrentSendBinding = MasterBinding;
                   MasterBinding->ReceiveBroadcast = TRUE;
                            
                   //
                   // Make sure other bindings are in sync with this change in command
                   //
                   tempBinding = MasterBinding;

                   while (MasterBinding != (tempBinding = tempBinding->NextBinding) ) {
                      
                      tempBinding->ReceiveBroadcast = FALSE;
                      CTEAssert(tempBinding->MasterBinding == MasterBinding);
                   }

                }

                //
                // Change the slave binding entries to have the master's NicId
                //
                RipAdjustForBindingChange (Binding->NicId, MasterBinding->NicId, IpxBindingMoved);
                IPX_DEBUG(PNP, ("RipAdjustForBindingChange (%d, %d, IpxBindingMoved)\n", Binding->NicId, MasterBinding->NicId));

                //
                // Null out the Slave binding.
                //
                INSERT_BINDING(Device, Binding->NicId, NULL);
		
		// 306476
		for (j = Binding->NicId+1; j <= Device->ValidBindings; j++) {
		   PBINDING tmp;

		   tmp = NIC_ID_TO_BINDING_NO_ILOCK(Device, j);
		   INSERT_BINDING(Device, j-1, tmp);

		   if (tmp) {
		      USHORT oldId = tmp->NicId; 
		      --tmp->NicId;
		      RipAdjustForBindingChange (oldId, tmp->NicId, IpxBindingMoved);		   
		   }
                }

                INSERT_BINDING(Device, Device->ValidBindings, NULL);

                --Device->ValidBindings;
                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
		
		if (Adapter->BindingCount == 1) {
		    // The adapter will be destroyed if this is the last binding. 
		    IpxUnBindFromAdapter(Binding);
		    break; 
		} else {
		    IpxUnBindFromAdapter(Binding);
		}

                continue;
            }

            //
            // If this was the last binding, go back to loaded state and shut down the RIP timers.
            //
            if (Device->ValidBindings == LAST_REAL_BINDING) {
                
                PBINDING LoopbackBinding = NULL;
                
                CTEAssert(Device->HighestExternalNicId == LAST_REAL_BINDING);
                CTEAssert(Device->HighestLanNicId == LAST_REAL_BINDING);
                CTEAssert(Device->SapNicCount == LAST_REAL_BINDING);
                CTEAssert(Device->HighestType20NicId == LAST_REAL_BINDING);

                //
                // If we are left with one NIC, then we are on loopback only (and no real adapters).
                // [Shreem]
                //
    
                Device->RealAdapters = FALSE;
                
                //
                // Put the old Loopback address into the Loopback binding.
                //
                LoopbackBinding = NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID);
                
                if (!Device->VirtualNetwork) {

                    LoopbackBinding->LocalAddress.NetworkAddress = REORDER_ULONG(INITIAL_LOOPBACK_NET_ADDRESS);
                    Device->SourceAddress.NetworkAddress = REORDER_ULONG(INITIAL_LOOPBACK_NET_ADDRESS);

                    ntStatus = RipInsertLocalNetwork(
                                                     LoopbackBinding->LocalAddress.NetworkAddress,
                                                     LoopbackBinding->NicId,
                                                     LoopbackBinding->Adapter->NdisBindingHandle,
                                                     (USHORT)((839 + LoopbackBinding->MediumSpeed) / LoopbackBinding->MediumSpeed));
             
                    if ((ntStatus != STATUS_SUCCESS) &&
                        (ntStatus != STATUS_DUPLICATE_NAME)) {
             
                        //
                        // We failed to insert, keep it at zero, hopefully
                        // we will be able to update later.
                        //
             
                        IPX_DEBUG(LOOPB, ("IPX: Could not insert net %lx for binding %lx\n",
                                          REORDER_ULONG(LoopbackBinding->LocalAddress.NetworkAddress),
                                          LoopbackBinding));
                 
                    } else {
             
                        IPX_DEBUG(LOOPB, ("Inserted the loopback address in the RIP table\n"));
             
                    }
                }
                

                RtlCopyMemory (LoopbackBinding->LocalAddress.NodeAddress, InitialLoopbackNodeAddress, 6);
                RtlCopyMemory (LoopbackBinding->LocalMacAddress.Address, InitialLoopbackNodeAddress, 6);
                RtlCopyMemory (Device->SourceAddress.NodeAddress, LoopbackBinding->LocalAddress.NodeAddress, 6);
                
                
                RtlCopyMemory ( Device->TdiRegistrationAddress->Address,
                                &LoopbackBinding->LocalAddress,
                                sizeof(TDI_ADDRESS_IPX));

                if (STATUS_SUCCESS != (ntStatus = TdiRegisterNetAddress(Device->TdiRegistrationAddress,
                                         &IpxDeviceName,
                                         NULL,
                                         &LoopbackBinding->TdiRegistrationHandle))) {
                    IPX_DEBUG(PNP, ("Error registering Loopback IPX address\n"));
                }

                IpxPnPInfo.FirstORLastDevice = FALSE;

                // 
                //
                // Shut down RIP timers, complete address notify requests, etc.
                //
                IpxPnPToLoad();

            } else if (IPX_NODE_EQUAL(
                                      NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID)->LocalAddress.NodeAddress, 
                                      Binding->LocalAddress.NodeAddress)) {

                PBINDING LoopbackBinding = NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID);
                

                //
                // 195358
                // It is likely that the adapter going away was the one that the loopback
                // adapter was using. Fix it by finding the next LAN Adapter.
                //
                for (NicId = FIRST_REAL_BINDING; NicId < Device->HighestExternalNicId; NicId++) {
                    
                    //
                    // Find the next one that is NOT going away.
                    //
                    if (NicId != Binding->NicId) {
                        
                        if ((tBinding = NIC_ID_TO_BINDING(Device, NicId)) == NULL) {
                            
                            CTEAssert(FALSE);

                        }

                        IPX_DEBUG(LOOPB, ("******** Using %d Nicid\n", NicId));
                        LoopbackBinding->LocalAddress.NetworkAddress = tBinding->LocalAddress.NetworkAddress;
                        RtlCopyMemory (LoopbackBinding->LocalAddress.NodeAddress, tBinding->LocalAddress.NodeAddress, 6);
                        RtlCopyMemory (LoopbackBinding->LocalMacAddress.Address, tBinding->LocalMacAddress.Address, 6);
                        RtlCopyMemory (Device->SourceAddress.NodeAddress, LoopbackBinding->LocalAddress.NodeAddress, 6);
                        Device->SourceAddress.NetworkAddress = tBinding->LocalAddress.NetworkAddress;
                        
                        //
                        // We are done for now.
                        // 
                        break;
                    }
                }
                
                IpxPnPInfo.FirstORLastDevice = FALSE;
            
            } else {

                CTEAssert(Device->State == DEVICE_STATE_OPEN);
                IpxPnPInfo.FirstORLastDevice = FALSE;

            }

            //
            // If this was a master binding, promote a slave binding to master.
            //
	    // If binding is a slave binding, this code is skipped by the continue.

            if (Binding->BindingSetMember) {
               PBINDING tmpBinding;
	       int j; 

                CTEAssert(Binding->CurrentSendBinding);
                CTEAssert(Binding->MasterBinding == Binding);

                //
                // Promote the next slave to Master.
                //
                newMasterBinding = Binding->NextBinding;
                INSERT_BINDING(Device, Binding->NicId, newMasterBinding);
                newMasterBinding->CurrentSendBinding = newMasterBinding;
                newMasterBinding->MasterBinding = newMasterBinding;
                
                //
                // If this is the only binding remaining out of its set,
                // it is no longer part of a set.
                //
                if (newMasterBinding->NextBinding == Binding) {
                    newMasterBinding->NextBinding = newMasterBinding->CurrentSendBinding = NULL;
                    newMasterBinding->BindingSetMember = FALSE;
                    newMasterBinding->ReceiveBroadcast = TRUE;

                    IPX_DEBUG(PNP, ("Master binding: %lx removed, no master: %lx\n", Binding, newMasterBinding));
                
                } else {
                   
                   //
                   // RESET: Make the newMasterBinding also the one to receiveBroadcasts [MS]
                   //
                   
                   newMasterBinding->ReceiveBroadcast = TRUE;
   
                   //   
                   // set the newMaster pointers in the other slaves [MS]
                   //
                   
                   tmpBinding = newMasterBinding->NextBinding;
                   
                   // This do-while loop assumes that tmpBinding != Binding before it starts.

		   do {
                      
                      //
                      // make sure all bindings point to the new master [MS]
                      //
		        
                      tmpBinding->MasterBinding = newMasterBinding;
                      tmpBinding->CurrentSendBinding = NULL;
                      tmpBinding->ReceiveBroadcast = FALSE;
                      
                      if (tmpBinding->NextBinding == Binding) {
			 tmpBinding->NextBinding = newMasterBinding;
		      }

		      tmpBinding = tmpBinding->NextBinding;
                   } while (tmpBinding != newMasterBinding);
                   
                }

                //
                // Change the slave binding entries to have the master's NicId
                //
                // RipAdjustForBindingChange (Binding->NicId, newMasterBinding->NicId, IpxBindingMoved); // [MS]
                RipAdjustForBindingChange (newMasterBinding->NicId, Binding->NicId, IpxBindingMoved);
                IPX_DEBUG(PNP, ("RipAdjustForBindingChange (%d, %d, IpxBindingMoved)\n", newMasterBinding->NicId, Binding->NicId));

                //
                // Register slave's address with the TDI clients.
                //
                CTEAssert(!newMasterBinding->TdiRegistrationHandle);

                RtlCopyMemory ( Device->TdiRegistrationAddress->Address,
                                &newMasterBinding->LocalAddress,
                                sizeof(TDI_ADDRESS_IPX));

                if ((ntStatus = TdiRegisterNetAddress(
                                Device->TdiRegistrationAddress,
#if     defined(_PNP_POWER_)
                                &IpxDeviceName,
                                NULL,
#endif _PNP_POWER_
                                &newMasterBinding->TdiRegistrationHandle)) != STATUS_SUCCESS) {

                    IPX_DEBUG(PNP, ("TdiRegisterNetAddress failed: %lx", ntStatus));
                }

                //  
                // Null out the slave binding
                //
                INSERT_BINDING(Device, newMasterBinding->NicId, NULL);

		// Move other slave binding after the promoted binding foward.
		for (j = newMasterBinding->NicId+1; j <= Device->ValidBindings; j++) {
		   PBINDING tmp;

		   tmp = NIC_ID_TO_BINDING_NO_ILOCK(Device, j);
		   ASSERT(tmp->NicId == j); 

		   INSERT_BINDING(Device, j-1, tmp);

		   if (tmp) {
		      USHORT oldId = tmp->NicId; 
		      --tmp->NicId;
		      RipAdjustForBindingChange (oldId, tmp->NicId, IpxBindingMoved);		   
		   }
                }

                INSERT_BINDING(Device, Device->ValidBindings, NULL);

		// Device->ValidBindings-- is done below. 

		newMasterBinding->NicId = Binding->NicId;
	    } else {

                ULONG   j;
                PBINDING    WanBinding=NIC_ID_TO_BINDING_NO_ILOCK(Device, Device->HighestLanNicId+1);

                if (WanBinding) {
                    --WanBinding->Adapter->LastWanNicId;
                    --WanBinding->Adapter->FirstWanNicId;
                }

                //
                // Remove the binding from the array
                //
                RipAdjustForBindingChange (Binding->NicId, 0, IpxBindingDeleted);

                for (j = Binding->NicId+1; j <= Device->ValidBindings; j++) {
                   PBINDING tmp;

					INSERT_BINDING(Device, j-1, NIC_ID_TO_BINDING_NO_ILOCK(Device, j));
                    tmp = NIC_ID_TO_BINDING_NO_ILOCK(Device, j);
                    if (tmp) {
		       USHORT oldId = tmp->NicId; 
                       --tmp->NicId;
		       RipAdjustForBindingChange(oldId, tmp->NicId, IpxBindingMoved); 
		       
                    }
                }

                INSERT_BINDING(Device, Device->ValidBindings, NULL);

                --Device->HighestExternalNicId;
                --Device->HighestLanNicId;
                --Device->HighestType20NicId;
                --Device->SapNicCount;
            }

            --Device->ValidBindings;

            //
            // If this is the first binding, NB's reserved will change.
            // When we inform SPX of an address change later, we dont have
            // this binding to know if this binding was indicated to SPX earlier.
            // So, set SPXInformed, which is used later to determine if an address
            // change is to be indicated to SPX later.
            //
            // Since NB is informed of all adapters, we inform of the reserved address
            // change to NB if the new Binding (now at NicId 1) was indicated earlier.
            //
            if (Binding->NicId == FIRST_REAL_BINDING) {
                NBReservedAddrChanged = TRUE;
                if (Binding->IsnInformed[IDENTIFIER_SPX]) {
                    SPXInformed = TRUE;
                }
            }

            CTEAssert(Binding->TdiRegistrationHandle);

            //
            // DeRegister this address with the TDI clients.
            //
            PAGED_CODE();
            if (Binding->TdiRegistrationHandle) {
               if ((ntStatus = TdiDeregisterNetAddress(Binding->TdiRegistrationHandle)) != STATUS_SUCCESS) {
                IPX_DEBUG(PNP, ("TdiDeRegisterNetAddress failed: %lx", ntStatus));
               } else {
		  Binding->TdiRegistrationHandle = NULL; 
	       }
            }
            PAGED_CODE();
            
            IPX_GET_LOCK(&Device->Lock, &LockHandle);


	        if (Device->UpperDriverBound[IDENTIFIER_NB]) {
    	        IPX_FREE_LOCK(&Device->Lock, LockHandle);
        		//
        		// If this binding's addition was indicated earlier, indicate its deletion to NB.
        		//
                if (Binding->IsnInformed[IDENTIFIER_NB]) {
                    
                    IpxPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
                    RtlCopyMemory(IpxPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                    NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, Binding->NicId);
                    IpxPnPInfo.FirstORLastDevice = FALSE;

                    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                    IPX_DEBUG(PNP, ("Inform NB: delete LAN device: %lx\n", Binding));
					
                    CTEAssert(Binding->NicId != LOOPBACK_NIC_ID); 

                    (*Device->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
                        IPX_PNP_DELETE_DEVICE,
                        &IpxPnPInfo);

                    Binding->IsnInformed[IDENTIFIER_NB] = FALSE; 

		    IPX_DEBUG(PNP,("Indicate to NB IPX_PNP_DELETE_DEVICE with FirstORLastDevice = (%d)",IpxPnPInfo.FirstORLastDevice));  

                    IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

                    //
                    // If this was a Master, indicate the addition of the (promoted) slave
                    //
                    if (Binding->BindingSetMember) {
                        IpxPnPInfo.NetworkAddress = newMasterBinding->LocalAddress.NetworkAddress;
                        RtlCopyMemory(IpxPnPInfo.NodeAddress, newMasterBinding->LocalAddress.NodeAddress, 6);
                        NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, newMasterBinding->NicId);

                        //
                        // In this case, we set the ReservedAddrChanged bit here itself so dont need
                        // to indicate a separate address changed.
                        //
                        IpxPnPInfo.NewReservedAddress = (NBReservedAddrChanged) ? TRUE : FALSE;
                        NBReservedAddrChanged = FALSE;

                        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                        IPX_DEBUG(PNP, ("Inform NB: add slave device: NicId: %lx\n", Binding->NicId));

                        ASSERT(IpxHasInformedNbLoopback()); 
                        ASSERT(Binding->NicId != LOOPBACK_NIC_ID);
                        ASSERT(IpxPnPInfo.FirstORLastDevice == FALSE);

                        (*Device->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
                            IPX_PNP_ADD_DEVICE,
                            &IpxPnPInfo);

                        newMasterBinding->IsnInformed[IDENTIFIER_NB] = TRUE;

                        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

                    }
                }
            } else {
    	        IPX_FREE_LOCK(&Device->Lock, LockHandle);
            }

            //
            // Last device - inform SPX if it is bound and this device was added earlier.
            //
            if (IpxPnPInfo.FirstORLastDevice) {
                IPX_DEBUG(PNP, ("Last device - inform SPX\n"));

       	        IPX_GET_LOCK(&Device->Lock, &LockHandle);
    	        if (Device->UpperDriverBound[IDENTIFIER_SPX]) {
        	        IPX_FREE_LOCK(&Device->Lock, LockHandle);

                    if (Binding->IsnInformed[IDENTIFIER_SPX]) {

                        IpxPnPInfo.NetworkAddress = Device->SourceAddress.NetworkAddress;
                        RtlCopyMemory(IpxPnPInfo.NodeAddress, Device->SourceAddress.NodeAddress, 6);

                        if (Device->VirtualNetwork) {
                            NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, 0);
                        } else {
                            NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, 1);
                        }

                        NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, Binding->NicId);

                        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                        IPX_DEBUG(PNP, ("Inform SPX: last LAN device\n"));

                        (*Device->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
                            IPX_PNP_DELETE_DEVICE,
                            &IpxPnPInfo);

                        Binding->IsnInformed[IDENTIFIER_SPX] = FALSE; 

                        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                    }
                } else {
    	            IPX_FREE_LOCK(&Device->Lock, LockHandle);
                }
            }

            //
            // Unbind from the adapter so it can be deleted
            //

            IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
	    if (Adapter->BindingCount == 1) {
		// The adapter will be destroyed if this is the last binding. 
		IpxUnBindFromAdapter(Binding);
		break; 
	    } else {
		IpxUnBindFromAdapter(Binding);
	    }

            IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
        }

        //
        // Update the Device and RIP tables if this is not the last device.
        // If the reserved address changed, inform NB and SPX of this change.
        //
        if (!IpxPnPInfo.FirstORLastDevice) {

            Binding = NIC_ID_TO_BINDING_NO_ILOCK(Device, 1);

            if (IpxNewVirtualNetwork(Device, NewVirtualNetwork)) {

                IPX_DEBUG(PNP, ("SPX's reserved address changed\n"));

                //
                // SPX's reserved address changed
                //
                IpxPnPInfo.NewReservedAddress = TRUE;

                IPX_GET_LOCK(&Device->Lock, &LockHandle);
    	        if (Device->UpperDriverBound[IDENTIFIER_SPX]) {
        	        IPX_FREE_LOCK(&Device->Lock, LockHandle);

            		//
            		// If this binding's addition was indicated earlier, indicate change of address.
            		//
                    if (SPXInformed) {
                        Binding->IsnInformed[IDENTIFIER_SPX] = TRUE;

                        IPX_DEBUG(PNP, ("Inform SPX: reserved address changed\n"));
                        IpxPnPInfo.NetworkAddress = Device->SourceAddress.NetworkAddress;
                        RtlCopyMemory(IpxPnPInfo.NodeAddress, Device->SourceAddress.NodeAddress, 6);

                        if (Device->VirtualNetwork) {
                            //
                            // new one appeared
                            //
                            NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, 0);
                        } else {
                            //
                            // Old one disappeared
                            //
                            NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, 1);
                        }

                        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                        (*Device->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
                            IPX_PNP_ADDRESS_CHANGE,
                            &IpxPnPInfo);

                        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                    }
                } else {
    	            IPX_FREE_LOCK(&Device->Lock, LockHandle);
                }
            } else {

                //
                // Set the first binding's flag so that when this binding goes away, we remember
                // to inform SPX of this device's removal.
                //

                IPX_DEBUG(PNP, ("Transfer SPX informed flag to NicId: %lx\n", Binding->NicId));
                Binding->IsnInformed[IDENTIFIER_SPX] = TRUE;
            }

            if (NBReservedAddrChanged) {
                //
                // NB's reserved address changed.
                //
                IpxPnPInfo.NewReservedAddress = TRUE;

                IPX_GET_LOCK(&Device->Lock, &LockHandle);
    	        if (Device->UpperDriverBound[IDENTIFIER_NB]) {
        	        IPX_FREE_LOCK(&Device->Lock, LockHandle);
            		//
            		// If this binding's addition was indicated earlier, indicate the change of reserved address.
            		//
                    if (Binding->IsnInformed[IDENTIFIER_NB]) {
                        IpxPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
                        RtlCopyMemory(IpxPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                        NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, Binding->NicId);

                        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                        IPX_DEBUG(PNP, ("Inform NB: reserved address changed\n"));

                        (*Device->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
                            IPX_PNP_ADDRESS_CHANGE,
                            &IpxPnPInfo);

                        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                    }
                } else {
    	            IPX_FREE_LOCK(&Device->Lock, LockHandle);
                }
            }
        }

        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
	}


    //
    // Re-calculate the values of datagram sizes in the Device.
    //
    IpxPnPUpdateDevice(Device);

	IPX_DEBUG(PNP, ("BindingCount: %lu\n", Device->BindingCount));
	IPX_DEBUG(PNP, ("ValidBindings: %lu\n", Device->ValidBindings));
	IPX_DEBUG(PNP, ("HighestLanNicId: %lu\n", Device->HighestLanNicId));
	IPX_DEBUG(PNP, ("HighestExternalNicId: %lu\n", Device->HighestExternalNicId));
	IPX_DEBUG(PNP, ("HighestType20NicId: %lu\n", Device->HighestType20NicId));
	IPX_DEBUG(PNP, ("SapNicCount: %lu\n", Device->SapNicCount));
	IPX_DEBUG(PNP, ("BindingArray: %lx\n", Device->Bindings));

   
    
    *Status = NDIS_STATUS_SUCCESS;

} /* IpxUnbindAdapter */

#if defined TRANSLATE

VOID
IpxTranslate(
	OUT PNDIS_STATUS Status,
	IN NDIS_HANDLE     ProtocolBindingContext,
	OUT	PNET_PNP_ID   IdList,
	IN ULONG           IdListLength,
	OUT PULONG         BytesReturned
	)
/*++

Routine Description:

    This routine receives control from the physical provider as an
    indication that a frame has been received on the physical link.
    The packet passed up from NDIS can be held on to by the TDI clients
    that request TDI_EVENT_RECEIVE_EX_DATAGRAM events with us.

Arguments:

    ProtocolBindingContext - The Adapter Binding specified at initialization time.

    ReceivedPacket - The packet received

    MediaSpecificInformation - Used for media such as Irda, wireless, etc. Not used here.

    HeaderBufferSize - Size of the MAC header

Return Value:


--*/
{
} /* IpxTranslate */
#endif


NTSTATUS
IpxBindLoopbackAdapter(
	)

/*++

Routine Description:

	This routine creates a loopback adapter for IPX.
    This function is internal to IPX and is called during 
    DriverEntry. This adapter will stick around for ever.

Arguments:


Return Value:

    Status - NDIS_STATUS_SUCCESS

--*/
{
   UCHAR 	InitialLoopbackNodeAddress[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x02};
	NTSTATUS	ntStatus;
	PDEVICE		Device = IpxDevice;
    CONFIG      Config;
    UINT		i;
	ULONG       Temp, SuccessfulOpens=0;
    PBINDING    LoopbackBinding;
    BINDING_CONFIG	ConfigBinding;
    BOOLEAN     FirstDevice = FALSE;
    PADAPTER    AdapterPtr;
    UNICODE_STRING AdapterName;
	IPX_DEFINE_LOCK_HANDLE(LockHandle1)
	IPX_DEFINE_LOCK_HANDLE(LockHandle)

	//
    // Used for error logging
    //

    Config.DriverObject = (PDRIVER_OBJECT)Device->DeviceObject;
	Config.RegistryPathBuffer = Device->RegistryPathBuffer;

	
    //
    // Create the loopback binding first.
    //

    if (!NIC_ID_TO_BINDING(Device, (SHORT)LOOPBACK_NIC_ID)) {


        //
        // Prime the Loopback binding too.
        //

        //
        // First allocate the memory for the binding.
        //
        ntStatus = IpxCreateBinding(
                     Device,
                     NULL,
                     0,
                     L"IpxInternalLLoopbackAdapter",
                     &LoopbackBinding);

	// 289740
        if (ntStatus != STATUS_SUCCESS) {
	   IpxWriteGeneralErrorLog(
	      (PVOID)IpxDevice->DeviceObject,
	      EVENT_TRANSPORT_RESOURCE_POOL,
	      814,
	      ntStatus,
	      L"IpxBindLoopbackAdapter: failed to create loopback binding",
	      0,
	      NULL);
	   DbgPrint("IPX: IpxCreateBinding on loopback binding failed with status %x\n.",ntStatus);  
	   return ntStatus; 
        }

        RtlInitUnicodeString(&AdapterName, L"\\Device\\IpxLoopbackAdapter");

        ntStatus = IpxCreateAdapter(
                                    Device,
                                    &AdapterName,
                                    &AdapterPtr
                                    );

	// 289740
	if (ntStatus != STATUS_SUCCESS) {
	   IpxDestroyBinding(LoopbackBinding);
	   return ntStatus; 
	}

        //
        // Initialize the LoopbackBinding details first.
        //

        LoopbackBinding->NicId = (USHORT)LOOPBACK_NIC_ID;
        LoopbackBinding->FwdAdapterContext = VIRTUAL_NET_FORWARDER_CONTEXT;
        LoopbackBinding->Device = Device;
        LoopbackBinding->DeviceLock = &Device->Lock;


        LoopbackBinding->MaxSendPacketSize = 1514;
        LoopbackBinding->AutoDetect = FALSE;
        LoopbackBinding->MediumSpeed = 100000;                    // in units of 100 bytes/sec
        
        //
        // The loopback node address starts out 0x000000000001
        //
    
    
        LoopbackBinding->BindingSetMember = FALSE;
        
        LoopbackBinding->SendFrameHandler = IpxSendFrame802_3802_2; ;
        LoopbackBinding->FrameType = ISN_FRAME_TYPE_802_2;
    
        LoopbackBinding->DefHeaderSize = 17;  //802_3 802_2
        LoopbackBinding->BcMcHeaderSize = 17; //802_3 802_2

        LoopbackBinding->AnnouncedMaxDatagramSize = 1514;  // what we advertise -- assumes worst-case SR
        LoopbackBinding->RealMaxDatagramSize = 1514;       // what will really break the card
        LoopbackBinding->MaxLookaheadData = 200;

        //
        // Indicates whether this binding was indicated to the ISN driver
        //
        for (i = 0; i < UPPER_DRIVER_COUNT; i++) {
            LoopbackBinding->IsnInformed[i] = FALSE;
        }

        LoopbackBinding->MaxLookaheadData =
            LoopbackBinding->MaxSendPacketSize -
            sizeof(IPX_HEADER) -
            (LoopbackBinding->DefHeaderSize - 14);

        LoopbackBinding->AnnouncedMaxDatagramSize =
            LoopbackBinding->MaxSendPacketSize -
            14 -
            sizeof(IPX_HEADER) -
            (LoopbackBinding->DefHeaderSize - 14);

        LoopbackBinding->RealMaxDatagramSize =
            LoopbackBinding->MaxSendPacketSize -
            14 - 
            sizeof(IPX_HEADER) -
            (LoopbackBinding->DefHeaderSize - 14);

        //
        // Copy over all the values from the first WAN binding created above.
        //
        INSERT_BINDING(Device, (SHORT)LOOPBACK_NIC_ID, LoopbackBinding);
        IpxReferenceBinding(LoopbackBinding, BREF_FWDOPEN); // so it appears the FWD opened it.
    
        //
        // Now fill in the Adapter details
        //

        AdapterPtr->ConfigMaxPacketSize = 1514;
        AdapterPtr->SourceRouting = FALSE;
        AdapterPtr->BindSap = 0x8137;
        AdapterPtr->BindSapNetworkOrder = 0x3781;
        
        AdapterPtr->MacInfo.SourceRouting = FALSE;
        AdapterPtr->MacInfo.MediumAsync = FALSE;
        AdapterPtr->MacInfo.BroadcastMask = 0x01;
        AdapterPtr->MacInfo.MaxHeaderLength = 14;
        AdapterPtr->MacInfo.MinHeaderLength = 14;
        AdapterPtr->MacInfo.MacOptions      = 14;
        AdapterPtr->MacInfo.MediumType = NdisMedium802_3;
        AdapterPtr->DefHeaderSizes[ISN_FRAME_TYPE_802_2] = 17;
        AdapterPtr->DefHeaderSizes[ISN_FRAME_TYPE_802_3] = 14;
        AdapterPtr->DefHeaderSizes[ISN_FRAME_TYPE_ETHERNET_II] = 14;
        AdapterPtr->DefHeaderSizes[ISN_FRAME_TYPE_SNAP] = 22;
        AdapterPtr->BcMcHeaderSizes[ISN_FRAME_TYPE_802_2] = 17;
        AdapterPtr->BcMcHeaderSizes[ISN_FRAME_TYPE_802_3] = 14;
        AdapterPtr->BcMcHeaderSizes[ISN_FRAME_TYPE_ETHERNET_II] = 14;
        AdapterPtr->BcMcHeaderSizes[ISN_FRAME_TYPE_SNAP] = 22;
        
        AdapterPtr->Bindings[ISN_FRAME_TYPE_802_2] = LoopbackBinding;
        AdapterPtr->Bindings[ISN_FRAME_TYPE_802_3] = NULL;
        AdapterPtr->Bindings[ISN_FRAME_TYPE_ETHERNET_II] = NULL;
        AdapterPtr->Bindings[ISN_FRAME_TYPE_SNAP] = NULL;
        
        ++AdapterPtr->BindingCount;
        AdapterPtr->NdisBindingHandle = NULL;
        LoopbackBinding->Adapter = AdapterPtr;

        //
        // These were missed [137536].
        //
        AdapterPtr->MediumSpeed             = 100000;
        AdapterPtr->MaxReceivePacketSize    = 1500;
        AdapterPtr->MaxSendPacketSize       = 1514;
        AdapterPtr->ReceiveBufferSpace    = 51264;

    }

    //
    // Update the indices
    //
    Device->HighestLanNicId++;
    Device->HighestExternalNicId++;
    Device->ValidBindings++;
    Device->HighestType20NicId++;
    Device->SapNicCount++;
        
    // These get updated in every BindAdapter.
    Device->Information.MaxDatagramSize         = LoopbackBinding->RealMaxDatagramSize;
    Device->RealMaxDatagramSize                 = LoopbackBinding->RealMaxDatagramSize;
    Device->Information.MaximumLookaheadData    = LoopbackBinding->MaxLookaheadData;
    Device->LinkSpeed                           = LoopbackBinding->MediumSpeed;
    Device->MacOptions                          = AdapterPtr->MacInfo.MacOptions;



    if (Device->FirstLanNicId == (USHORT)-1) {
        Device->FirstLanNicId = LoopbackBinding->NicId;
    }
    
	//
	// If at least one card appeared here, set our state
	// to open
	//
    if (Device->ValidBindings > 0) {
    	if (Device->State == DEVICE_STATE_LOADED) {
    		FirstDevice = TRUE;
    		Device->State = DEVICE_STATE_OPEN;
    	    Device->RealAdapters = FALSE; // no adapters are loaded at this point.

        }
    }

    //
    // Read the registry to see if a virtual network number appeared/disappeared
    //
    ntStatus = IpxPnPGetVirtualNetworkNumber(&Config);
    
    if (ntStatus != STATUS_SUCCESS) {
       IPX_DEBUG(PNP, ("Could not read the vnet#: registrypathbuffer: %lx\n", Device->RegistryPathBuffer));
       return NDIS_STATUS_SUCCESS;
    }
    
    Temp = REORDER_ULONG (Config.Parameters[CONFIG_VIRTUAL_NETWORK]);
	 
    if (0 == Temp) {
        
       Device->VirtualNetworkNumber                    = 0;
       Device->VirtualNetwork                          = FALSE;
       LoopbackBinding->LocalAddress.NetworkAddress    = REORDER_ULONG(INITIAL_LOOPBACK_NET_ADDRESS);
       RtlCopyMemory (LoopbackBinding->LocalAddress.NodeAddress,InitialLoopbackNodeAddress, 6);            
       Device->SourceAddress.NetworkAddress            = REORDER_ULONG(INITIAL_LOOPBACK_NET_ADDRESS);
       RtlCopyMemory (LoopbackBinding->LocalMacAddress.Address, InitialLoopbackNodeAddress, 6);
       RtlCopyMemory (Device->SourceAddress.NodeAddress, LoopbackBinding->LocalAddress.NodeAddress, 6);
	    
       ntStatus = RipInsertLocalNetwork(
                                     LoopbackBinding->LocalAddress.NetworkAddress,
                                     LoopbackBinding->NicId,
                                     LoopbackBinding->Adapter->NdisBindingHandle,
                                     (USHORT)((839 + LoopbackBinding->MediumSpeed) / LoopbackBinding->MediumSpeed));

       if ((ntStatus != STATUS_SUCCESS) &&
	   (ntStatus != STATUS_DUPLICATE_NAME)) {
	  
	  //
	  // We failed to insert, keep it at zero, hopefully
	  // we will be able to update later.
	  //

	  IPX_DEBUG(LOOPB, ("IPX: Could not insert net %lx for binding %lx\n",
			    REORDER_ULONG(LoopbackBinding->LocalAddress.NetworkAddress),
			    LoopbackBinding));
    
       } else {

	  IPX_DEBUG(LOOPB, ("Inserted the loopback address in the RIP table\n"));

       }
    } else {
       
       Device->VirtualNetworkNumber                    = Temp;
       IpxNewVirtualNetwork(Device,TRUE); 
       
    }

    IPX_DEBUG(PNP, ("Virtual net # is: %lx/%lx\n", Temp, REORDER_ULONG(INITIAL_LOOPBACK_NET_ADDRESS)));


 

    if (FirstDevice) {
        UNICODE_STRING  devicename;

        //
        // Inform TDI clients about the open of our device object.
        //
        devicename.MaximumLength = (USHORT)Device->DeviceNameLength;
        devicename.Length = (USHORT)Device->DeviceNameLength - sizeof(WCHAR);
        devicename.Buffer = Device->DeviceName;

        if ((ntStatus = TdiRegisterDeviceObject(
                        &devicename,
                        &Device->TdiRegistrationHandle)) != STATUS_SUCCESS) {

            DbgPrint("IPX:TdiRegisterDeviceObject failed: %lx", ntStatus);
	    Device->TdiRegistrationHandle = NULL; 
        }

    }

    LoopbackBinding->PastAutoDetection = TRUE;

    //
    // Register this address with the TDI clients.
    // 1. dereg later
    // 2. which address is this?
    //
    RtlCopyMemory (Device->TdiRegistrationAddress->Address, &LoopbackBinding->LocalAddress, sizeof(TDI_ADDRESS_IPX));
 
    if ((ntStatus = TdiRegisterNetAddress(
                                          Device->TdiRegistrationAddress,
                                          &IpxDeviceName,
                                          NULL,
                                          &LoopbackBinding->TdiRegistrationHandle)) != STATUS_SUCCESS) {

        IPX_DEBUG(PNP, ("TdiRegisterNetAddress failed: %lx", ntStatus));
    }

    IPX_DEBUG(PNP, ("BindingCount: %lu\n", Device->BindingCount));
    IPX_DEBUG(PNP, ("ValidBindings: %lu\n", Device->ValidBindings));
    IPX_DEBUG(PNP, ("HighestLanNicId: %lu\n", Device->HighestLanNicId));
    IPX_DEBUG(PNP, ("HighestExternalNicId: %lu\n", Device->HighestExternalNicId));
    IPX_DEBUG(PNP, ("HighestType20NicId: %lu\n", Device->HighestType20NicId));
    IPX_DEBUG(PNP, ("SapNicCount: %lu\n", Device->SapNicCount));
    IPX_DEBUG(PNP, ("BindingArray: %lx\n", Device->Bindings));

    return NDIS_STATUS_SUCCESS;

} /* IpxBindLoopbackAdapter */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\internal.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    internal.c

Abstract:

    This module contains the code to handle the internal
    binding of the upper drivers to IPX.

Author:

    Adam Barr (adamba) 2-September-1993

Environment:

    Kernel mode

Revision History:

   Sanjay Anand (SanjayAn) 25-August-1995
   Bug Fixes - tagged [SA]
--*/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
IpxInternalBind(
    IN PDEVICE Device,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used when one of the upper drivers submits
    a request to bind to IPX.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);
    PIPX_INTERNAL_BIND_INPUT BindInput;
    PIPX_INTERNAL_BIND_OUTPUT BindOutput;
    PIPX_INTERNAL_BIND_RIP_OUTPUT BindRipOutput;
    CTELockHandle LockHandle;
    PIPX_NIC_DATA NicData;
    PBINDING Binding, LastRealBinding;
    PADAPTER Adapter;
    ULONG Identifier;
    ULONG BindOutputSize;
    BOOLEAN BroadcastEnable;
    #ifdef SUNDOWN
	// To avoid a warning when    NicData->NicId = i;
	// Assume that USHORT is enough to hold the number of bindings
        USHORT i;
    #else
        UINT i;
    #endif
    

#if DBG
    PUCHAR IdStrings[] = { "NB", "SPX", "RIP" };
#endif
    BOOLEAN     fFwdBindAttempt = FALSE;
    IPX_DEFINE_LOCK_HANDLE(LockHandle1)

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            (sizeof(IPX_INTERNAL_BIND_INPUT) - sizeof(ULONG))) {

        IPX_DEBUG (BIND, ("Bind received, bad input length %d/%d\n",
            IrpSp->Parameters.DeviceIoControl.InputBufferLength,
            sizeof (IPX_INTERNAL_BIND_INPUT)));
        return STATUS_INVALID_PARAMETER;

    }

    BindInput = (PIPX_INTERNAL_BIND_INPUT)(Irp->AssociatedIrp.SystemBuffer);

    if (BindInput->Identifier >= UPPER_DRIVER_COUNT) {
        IPX_DEBUG (BIND, ("Bind received, bad id %d\n", BindInput->Identifier));
        return STATUS_INVALID_PARAMETER;
    }

    IPX_DEBUG (BIND, ("Bind received from id %d (%s)\n",
          BindInput->Identifier,
          IdStrings[BindInput->Identifier]));

//
// RIP gives us version == 1 whereas Forwarder gives us 2 (ISN_VERSION).
//
    if (BindInput->Identifier == IDENTIFIER_RIP) {
        if (BindInput->Version == ISN_VERSION) {
            fFwdBindAttempt = TRUE;
        } else {
            CTEAssert(!Device->ForwarderBound);
	    DbgPrint("IPX:Check out who is requesting bind?.\n"); 
	    CTEAssert(FALSE); 
            if (BindInput->Version != 1) {
                IPX_DEBUG (BIND, ("Bind: bad version %d/%d\n",
                    BindInput->Version, 1));
                return STATUS_INVALID_PARAMETER;
            }
        }
    } else {
        if (BindInput->Version != ISN_VERSION) {
            IPX_DEBUG (BIND, ("Bind: bad version %d/%d\n",
                BindInput->Version, 1));
            return STATUS_INVALID_PARAMETER;
        }
    }


    if (BindInput->Identifier != IDENTIFIER_RIP) {
        BindOutputSize = sizeof(IPX_INTERNAL_BIND_OUTPUT);
    } else {
        BindOutputSize = FIELD_OFFSET (IPX_INTERNAL_BIND_RIP_OUTPUT, NicInfoBuffer.NicData[0]) +
                             (MIN (Device->MaxBindings, Device->HighestExternalNicId) * sizeof(IPX_NIC_DATA));
    }

    Irp->IoStatus.Information = BindOutputSize;

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            BindOutputSize) {

        IPX_DEBUG (BIND, ("Bind: bad output length %d/%d\n",
            IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
            BindOutputSize));

        //
        // Fail this request with BUFFER_TOO_SMALL. Since the
        // I/O system may not copy the status block back to
        // the user's status block, do that here so that
        // he gets IoStatus.Information.
        //

        try {
            *Irp->UserIosb = Irp->IoStatus;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }

        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // We have verified the length, make sure we are not
    // already bound.
    //

    Identifier = BindInput->Identifier;

    CTEGetLock (&Device->Lock, &LockHandle);

    if (Device->UpperDriverBound[Identifier]) {
        IPX_DEBUG (BIND, ("Bind: already bound\n"));
        CTEFreeLock (&Device->Lock, LockHandle);
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    {
        LARGE_INTEGER   ControlChId;

        CCID_FROM_REQUEST(ControlChId, Irp);

        IPX_DEBUG (BIND, ("Control ChId: (%d, %d) for Id: %d\n", ControlChId.HighPart, ControlChId.LowPart, Identifier));
        Device->UpperDriverControlChannel[Identifier].QuadPart = ControlChId.QuadPart;
    }

    RtlCopyMemory(
        &Device->UpperDrivers[Identifier],
        BindInput,
        sizeof (IPX_INTERNAL_BIND_INPUT)
        );

    BroadcastEnable = BindInput->BroadcastEnable;

    //
    // Now construct the output buffer.
    //

    if (Identifier != IDENTIFIER_RIP) {

        BindOutput = (PIPX_INTERNAL_BIND_OUTPUT)Irp->AssociatedIrp.SystemBuffer;

	RtlZeroMemory(BindOutput, sizeof(IPX_INTERNAL_BIND_OUTPUT)); 

        BindOutput->Version = 1;

        //
        // Tell netbios our first binding's net/node instead of the
        // virtual one.
        //
//
// Fill the fields in only if the adapters have already appeared
// Else, set NodeNumber to 0 so NB/SPX know of it.
//
		if ((*(UNALIGNED USHORT *)(Device->SourceAddress.NodeAddress+4) != 0) ||
			(*(UNALIGNED ULONG *)Device->SourceAddress.NodeAddress != 0)) {

			IPX_DEBUG(BIND, ("Device already opened\n"));
			CTEAssert(Device->ValidBindings);

            if (Identifier == IDENTIFIER_SPX) {

                //
                // For SPX, inform directly.
                //
	            IPX_FREE_LOCK(&Device->Lock, LockHandle);
		        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

		        if (!NIC_ID_TO_BINDING(Device, 1)->IsnInformed[Identifier]) {
			        NIC_ID_TO_BINDING(Device, 1)->IsnInformed[Identifier] = TRUE;
		            IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                    ExInitializeWorkItem(
                                         &Device->PnPIndicationsQueueItemSpx,
                                         IpxPnPIsnIndicate,
                                         UlongToPtr(Identifier));

		    IpxReferenceDevice(Device, DREF_PNP); 
                    ExQueueWorkItem(&Device->PnPIndicationsQueueItemSpx, DelayedWorkQueue);


		    // DbgPrint("---------- 5. Queued with IpxPnPIsnIndicate  ----------\n"); 
                    //IpxPnPIsnIndicate((PVOID)Identifier);

                } else {
                    CTEAssert(FALSE);

    	            IPX_FREE_LOCK(&Device->Lock, LockHandle);
		            IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                }

		        IPX_GET_LOCK(&Device->Lock, &LockHandle);
            } else {
    			//
    			// For NB, queue a work item which will go thru' the adapters list and
                // inform the upper drivers about each of them.
    			//

	        KeResetEvent(&Device->NbEvent); 

                ExInitializeWorkItem(
                    &Device->PnPIndicationsQueueItemNb,
                    IpxPnPIsnIndicate,
                    UlongToPtr(Identifier));
		IpxReferenceDevice(Device, DREF_PNP); 
                ExQueueWorkItem(&Device->PnPIndicationsQueueItemNb, DelayedWorkQueue);
		// DbgPrint("---------- 5 (2). Queued with IpxPnPIsnIndicate  ----------\n"); 
            }

		} else {
			// This should not happen as SourceAddress should set in DriverEntry
     			// to initial loopback address or virtual network address. 

			DbgPrint("IPX:IpxInternalBind:Device not open:IpxPnPIsnIndicate thread did not launch.\n");
			*((UNALIGNED ULONG *)BindOutput->Node) = 0;
			*((UNALIGNED USHORT *)(BindOutput->Node+4)) = 0;
			RtlZeroMemory(&BindOutput->LineInfo, sizeof(BindOutput->LineInfo));
		}

        BindOutput->MacHeaderNeeded = MAC_HEADER_SIZE;  //40;
		BindOutput->IncludedHeaderOffset = MAC_HEADER_SIZE; // (USHORT)Device->IncludedHeaderOffset;

        BindOutput->SendHandler = IpxSendFramePreFwd;
        BindOutput->FindRouteHandler = IpxInternalFindRoute;
        BindOutput->QueryHandler = IpxInternalQuery;

        BindOutput->TransferDataHandler = IpxTransferData;
        
        BindOutput->PnPCompleteHandler = IpxPnPCompletionHandler;

    } else {
        //
        // Set this so we stop RIPping for our virtual network (if
        // we have one).
        //

        Device->RipResponder = FALSE;

        //
        // See if he wants a single wan network number.
        //

        if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(IPX_INTERNAL_BIND_INPUT)) ||
            ((BindInput->RipParameters & IPX_RIP_PARAM_GLOBAL_NETWORK) == 0)) {

            Device->WanGlobalNetworkNumber = FALSE;
            Device->SapNicCount = Device->HighestExternalNicId;

        } else {

            Device->WanGlobalNetworkNumber = TRUE;

        }

        BindRipOutput = (PIPX_INTERNAL_BIND_RIP_OUTPUT)Irp->AssociatedIrp.SystemBuffer;

	RtlZeroMemory(BindRipOutput, sizeof(IPX_INTERNAL_BIND_RIP_OUTPUT)); 

        BindRipOutput->Version = 1;
        BindRipOutput->MaximumNicCount = MIN (Device->MaxBindings, Device->HighestExternalNicId) + 1;

        BindRipOutput->MacHeaderNeeded = MAC_HEADER_SIZE;  //40;
        BindRipOutput->IncludedHeaderOffset = (USHORT)Device->IncludedHeaderOffset;

        BindRipOutput->SendHandler = IpxSendFrame;

        if (!fFwdBindAttempt) {
            BindRipOutput->SegmentCount = Device->SegmentCount;
            BindRipOutput->SegmentLocks = Device->SegmentLocks;

            BindRipOutput->GetSegmentHandler = RipGetSegment;
            BindRipOutput->GetRouteHandler = RipGetRoute;
            BindRipOutput->AddRouteHandler = RipAddRoute;
            BindRipOutput->DeleteRouteHandler = RipDeleteRoute;
            BindRipOutput->GetFirstRouteHandler = RipGetFirstRoute;
            BindRipOutput->GetNextRouteHandler = RipGetNextRoute;

            //
            // remove this...
            //
            BindRipOutput->IncrementWanInactivityHandler = IpxInternalIncrementWanInactivity;
            BindRipOutput->QueryWanInactivityHandler = IpxInternalQueryWanInactivity;
        } else {
            //
            // [FW] New routines provided for the Forwarder
            //
            BindRipOutput->OpenAdapterHandler = IpxOpenAdapter;
            BindRipOutput->CloseAdapterHandler = IpxCloseAdapter;
            BindRipOutput->InternalSendCompleteHandler = IpxInternalSendComplete;
        }

        BindRipOutput->TransferDataHandler = IpxTransferData;

        BindRipOutput->NicInfoBuffer.NicCount = (USHORT)MIN (Device->MaxBindings, Device->HighestExternalNicId);
        BindRipOutput->NicInfoBuffer.VirtualNicId = 0;
        if (Device->VirtualNetwork || Device->MultiCardZeroVirtual) {
            *(UNALIGNED ULONG *)(BindRipOutput->NicInfoBuffer.VirtualNetwork) = Device->SourceAddress.NetworkAddress;
        } else if (Device->DedicatedRouter) {
            *(UNALIGNED ULONG *)(BindRipOutput->NicInfoBuffer.VirtualNetwork) = 0x0;
        }

        NicData = &BindRipOutput->NicInfoBuffer.NicData[0];

        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
        {
        ULONG   Index = MIN (Device->MaxBindings, Device->HighestExternalNicId);

        for (i = FIRST_REAL_BINDING; i <= Index; i++) {

            Binding = NIC_ID_TO_BINDING(Device, i);

            //
            // NULL bindings are WAN bindings, so we return the
            // information from the last non-NULL binding found,
            // which will be the first one on this adapter.
            // Otherwise we save this as the last non-NULL one.
            //

            if (Binding == NULL) {
                Binding = LastRealBinding;
            } else {
                LastRealBinding = Binding;
            }

            Adapter = Binding->Adapter;
            NicData->NicId = i;
            RtlCopyMemory (NicData->Node, Binding->LocalAddress.NodeAddress, 6);
            *(UNALIGNED ULONG *)NicData->Network = Binding->LocalAddress.NetworkAddress;
            NicData->LineInfo.LinkSpeed = Binding->MediumSpeed;
            NicData->LineInfo.MaximumPacketSize =
                Binding->MaxLookaheadData + sizeof(IPX_HEADER);
            NicData->LineInfo.MaximumSendSize =
                Binding->AnnouncedMaxDatagramSize + sizeof(IPX_HEADER);
            NicData->LineInfo.MacOptions = Adapter->MacInfo.MacOptions;
            NicData->DeviceType = Adapter->MacInfo.RealMediumType;
            NicData->EnableWanRouter = Adapter->EnableWanRouter;

            ++NicData;
        }
        }
        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
    }
    
    //
    // This is enabled by default these days!
    //
    /*
    if (BroadcastEnable) {
        IpxAddBroadcast (Device);
    }
    */
    Device->UpperDriverBound[Identifier] = TRUE;

    Device->ForwarderBound = fFwdBindAttempt;

    Device->AnyUpperDriverBound = TRUE;
    CTEFreeLock (&Device->Lock, LockHandle);

    return STATUS_SUCCESS;

}   /* IpxInternalBind */


NTSTATUS
IpxInternalUnbind(
    IN PDEVICE Device,
    IN UINT Identifier
    )

/*++

Routine Description:

    This routine is used when one of the upper drivers submits
    a request to unbind from IPX. It does this by closing the
    control channel on which the bind ioctl was submitted.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    CTELockHandle LockHandle;
#if DBG
    PUCHAR IdStrings[] = { "NB", "SPX", "RIP" };
#endif

    IPX_DEBUG (BIND, ("Unbind received from id %d (%s)\n",
          Identifier,
          IdStrings[Identifier]));

    CTEGetLock (&Device->Lock, &LockHandle);
    
    if (!Device->UpperDriverBound[Identifier]) {
        CTEFreeLock (&Device->Lock, LockHandle);
        IPX_DEBUG (BIND, ("No existing binding\n"));
        return STATUS_SUCCESS;
    }

    //
    // [FW] If RIP is unbinding, restart the long timer
    // Also, set the RipResponder flag if virutal net configured

    //
    // Deref all bindings that RIP did not close
    //
    if (Identifier == IDENTIFIER_RIP &&
        Device->ForwarderBound) {
        UINT    i;

        Device->ForwarderBound = FALSE;

        //
        // [FW] Walk the binding list, to deref all bindings not closed by
        // the forwarder before it unbound from us.
        //
        {
        ULONG   Index = MIN (Device->MaxBindings, Device->HighestExternalNicId);

        for (i = FIRST_REAL_BINDING; i <= Index; i++) {
            PBINDING    Binding = NIC_ID_TO_BINDING(Device, i);

            //
            // We need to ensure that they will all be indicated when
            // the Router starts up again.
            //
            if (Binding) {
                Binding->fInfoIndicated = FALSE;
            }

            if (Binding && (Binding->FwdAdapterContext != 0)) {
                IpxDereferenceBinding(Binding, BREF_FWDOPEN);
            }
        }
        }

        if (Device->VirtualNetwork) {
            Device->RipResponder = TRUE;
        }

        //
        // Start the timer which updates the RIP database
        // periodically.
        //

        IpxReferenceDevice (Device, DREF_LONG_TIMER);

        CTEStartTimer(
            &Device->RipLongTimer,
            10000,
            RipLongTimeout,
            (PVOID)Device);

    }

    Device->UpperDriverBound[Identifier] = FALSE;
    Device->AnyUpperDriverBound = (BOOLEAN)
        (Device->UpperDriverBound[IDENTIFIER_RIP] ||
         Device->UpperDriverBound[IDENTIFIER_SPX] ||
         Device->UpperDriverBound[IDENTIFIER_NB]);

    //
    // Lets do it in UnBindadapter anyway - later! [ShreeM]
    //
    /*
    if (Device->UpperDrivers[Identifier].BroadcastEnable) {
        IpxRemoveBroadcast (Device);
    }
    */

    if (Device->ValidBindings > 0) {
        //
        // If SPX went away, reset the IsnIndicate flag in the first binding
        //
        if (Identifier == IDENTIFIER_SPX) {
            CTEAssert(NIC_ID_TO_BINDING(Device, 1));

            if (NIC_ID_TO_BINDING(Device, 1)->IsnInformed[Identifier]) {
                NIC_ID_TO_BINDING(Device, 1)->IsnInformed[Identifier] = FALSE;
                IPX_DEBUG(PNP, ("SPX unbound: IsnInformed turned off\n"));
            }
        }

        //
        // If NB went away, reset all the Binding's flags
        //
        if (Identifier == IDENTIFIER_NB) {

            PBINDING    Binding;
            UINT        i;
            ULONG   Index = MIN (Device->MaxBindings, Device->HighestExternalNicId);

            // DbgBreakPoint(); 

	    for (i = LOOPBACK_NIC_ID; i < Index; i++) {
                Binding = NIC_ID_TO_BINDING(Device, i);
                if (Binding && Binding->IsnInformed[Identifier]) {
                    Binding->IsnInformed[Identifier] = FALSE;
                    IPX_DEBUG(PNP, ("NB unbound: IsnInformed off for NicId: %lx\n", i));
                }
            }
        }
    }

    //
    // Lets NULL out the drivers
    //
    RtlZeroMemory(
        &Device->UpperDrivers[Identifier],
        sizeof (IPX_INTERNAL_BIND_INPUT)
        );
    

    CTEFreeLock (&Device->Lock, LockHandle);

    return STATUS_SUCCESS;

}   /* IpxInternalUnbind */


VOID
IpxInternalFindRoute (
    IN PIPX_FIND_ROUTE_REQUEST FindRouteRequest
    )

/*++

Routine Description:

    This routine is the entry point for upper drivers to submit
    requests to find a remote network, which is contained in
    FindRouteRequest->Network. FindRouteRequest->Identifier must
    contain the identifier of the upper driver.

    This request is always asynchronous and is completed by
    a call to the FindRouteComplete handler of the upper driver.

    NOTE: As a currently unspecified extension to this call,
    we returns the tick and hop counts as two USHORTs in the
    PVOID Reserved2 structure of the request.

Arguments:

    FindRouteRequest - Describes the request and contains
        storage for IPX to use while processing it.

Return Value:

    None.

--*/

{
    PDEVICE Device = IpxDevice;
    ULONG Segment;
    TDI_ADDRESS_IPX TempAddress;
    PBINDING Binding, MasterBinding;
    NTSTATUS Status;
    IPX_DEFINE_SYNC_CONTEXT (SyncContext)
    IPX_DEFINE_LOCK_HANDLE (LockHandle)
    IPX_DEFINE_LOCK_HANDLE(LockHandle1)
	
    //
    // [FW] Call the Forwarder's FindRoute if installed
    //

    if (Device->ForwarderBound) {
        // IPX_ROUTE_ENTRY routeEntry;

        Status = (*Device->UpperDrivers[IDENTIFIER_RIP].FindRouteHandler) (
                     FindRouteRequest->Network,
                     FindRouteRequest->Node,
                     FindRouteRequest);

        if (Status != STATUS_SUCCESS) {
           IPX_DEBUG (RIP, ("RouteHandler returned: %lx\n", Status));
        } else {

#if DBG
            //
            // If a demand-dial NIC was returned, we should have a WAN adapter. In PnP we can check this
            // by making sure that Device->HighestLanNicId < Device->HighestExternalNicId.
            //
            if (FindRouteRequest->LocalTarget.NicId == DEMAND_DIAL_ADAPTER_CONTEXT) {
                CTEAssert(Device->HighestLanNicId < Device->HighestExternalNicId);
            }
#endif

            IPX_DEBUG(RIP, ("FindRoute for %02x-%02x-%02x-%02x-%02x-%02x returned %lx",
                          FindRouteRequest->LocalTarget.MacAddress[0],
                          FindRouteRequest->LocalTarget.MacAddress[1],
                          FindRouteRequest->LocalTarget.MacAddress[2],
                          FindRouteRequest->LocalTarget.MacAddress[3],
                          FindRouteRequest->LocalTarget.MacAddress[4],
                          FindRouteRequest->LocalTarget.MacAddress[5],
                          Status));

        }

    } else {
        //
        // First see if we have a route to this network in our
        // table.
        //

        TempAddress.NetworkAddress = *(UNALIGNED ULONG *)(FindRouteRequest->Network);
        //
        // [SA] Bug #15094 Copy over the Node address so it can be used in WAN cases
        //

        // RtlZeroMemory (TempAddress.NodeAddress, 6);

        *((UNALIGNED ULONG *)TempAddress.NodeAddress) = *((UNALIGNED ULONG *)FindRouteRequest->Node);
        *((UNALIGNED USHORT *)(TempAddress.NodeAddress+4)) = *((UNALIGNED USHORT *)(FindRouteRequest->Node+4));

        Segment = RipGetSegment(FindRouteRequest->Network);
    	//
    	// Since we maintain the order of locks as Bind > Device > RIP table
        // Get the lock up-front.
    	//
    	IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
        IPX_BEGIN_SYNC (&SyncContext);
        IPX_GET_LOCK (&Device->SegmentLocks[Segment], &LockHandle);

        //
        // This call will return STATUS_PENDING if we need to
        // RIP for the packet.
        //

        CTEAssert ((sizeof(USHORT)*2) <= sizeof(PVOID));

        Status = RipGetLocalTarget(
                     Segment,
                     &TempAddress,
                     FindRouteRequest->Type,
                     &FindRouteRequest->LocalTarget,
                     (PUSHORT)&FindRouteRequest->Reserved2);

        if (Status == STATUS_PENDING) {

            //
            // A RIP request went out on the network; we queue
            // this find route request for completion when the
            // RIP response arrives.
            //

            CTEAssert (FindRouteRequest->Type != IPX_FIND_ROUTE_NO_RIP); // should never pend

            InsertTailList(
                &Device->Segments[Segment].FindWaitingForRoute,
                &FindRouteRequest->Linkage);

        } 

        IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);
        IPX_END_SYNC (&SyncContext);
    	IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
    }

    if (Status != STATUS_PENDING) {
  

        if (Status == STATUS_SUCCESS && FindRouteRequest->LocalTarget.NicId) {
	    IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

	    Binding = NIC_HANDLE_TO_BINDING(Device, &FindRouteRequest->LocalTarget.NicHandle);
            
	    if (Binding == NULL) {
	       Status = STATUS_NETWORK_UNREACHABLE; 
	    } else {


	       if (Binding->BindingSetMember) {

		  //
		  // It's a binding set member, we round-robin the
		  // responses across all the cards to distribute
		  // the traffic.
		  //

		  MasterBinding = Binding->MasterBinding;
		  Binding = MasterBinding->CurrentSendBinding;
		  MasterBinding->CurrentSendBinding = Binding->NextBinding;

		  FILL_LOCAL_TARGET(&FindRouteRequest->LocalTarget, Binding->NicId);

	       }
	    }
	    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
	}

        (*Device->UpperDrivers[FindRouteRequest->Identifier].FindRouteCompleteHandler)(
            FindRouteRequest,
            (BOOLEAN)((Status == STATUS_SUCCESS) ? TRUE : FALSE));

    }

}   /* IpxInternalFindRoute */


NTSTATUS
IpxInternalQuery(
    IN ULONG InternalQueryType,
	IN PNIC_HANDLE NicHandle OPTIONAL,
    IN OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG BufferLengthNeeded OPTIONAL
)

/*++

Routine Description:

    This routine is the entry point for upper drivers to query
    information from us.

Arguments:

    InternalQueryType - Identifies the type of the query.

    NicId - The ID to query, if needed

    Buffer - Input or output buffer for the query.

    BufferLength - The length of the buffer.

    BufferLengthNeeded - If the buffer is too short, this returns
        the length needed.

Return Value:

    None.

--*/

{
    PBINDING Binding;
    BOOLEAN BindingNeeded;
    ULONG LengthNeeded;
    PIPX_LINE_INFO LineInfo;
    PUSHORT MaximumNicId;
    PULONG ReceiveBufferSpace;
    TDI_ADDRESS_IPX UNALIGNED * IpxAddress;
    IPX_SOURCE_ROUTING_INFO UNALIGNED * SourceRoutingInfo;
    ULONG SourceRoutingLength;
    UINT MaxUserData;
    PDEVICE Device = IpxDevice;
    USHORT NicId;
    PNDIS_MEDIUM  Medium;
    PVOID *PPDO; 

    IPX_DEFINE_LOCK_HANDLE(LockHandle1)

    //
    // First verify the parameters.
    //

    switch (InternalQueryType) {

    case IPX_QUERY_LINE_INFO:

        BindingNeeded = TRUE;
        LengthNeeded = sizeof(IPX_LINE_INFO);
        break;

    case IPX_QUERY_MAXIMUM_NIC_ID:
    case IPX_QUERY_MAX_TYPE_20_NIC_ID:

        BindingNeeded = FALSE;
        LengthNeeded = sizeof(USHORT);
        break;

    case IPX_QUERY_IS_ADDRESS_LOCAL:

        BindingNeeded = FALSE;   // for now we don't need it
        LengthNeeded = sizeof(TDI_ADDRESS_IPX);
        break;

    case IPX_QUERY_RECEIVE_BUFFER_SPACE:

        BindingNeeded = TRUE;
        LengthNeeded = sizeof(ULONG);
        break;

    case IPX_QUERY_IPX_ADDRESS:

  	if (NicHandle != NULL) {
	   NicId = NicHandle->NicId;
	} else {
	   return STATUS_INVALID_PARAMETER; 
	}

        if ((NicId == 0) &&
            (BufferLength >= sizeof(TDI_ADDRESS_IPX))) {

            RtlCopyMemory (Buffer, &Device->SourceAddress, sizeof(TDI_ADDRESS_IPX));
            return  STATUS_SUCCESS;

        }

        BindingNeeded = TRUE;
        LengthNeeded = sizeof(TDI_ADDRESS_IPX);
        break;

    case IPX_QUERY_SOURCE_ROUTING:

        BindingNeeded = TRUE;
        LengthNeeded = sizeof(IPX_SOURCE_ROUTING_INFO);
        break;

	//
	// These are moved down from NB/SPX to IPX. LengthNeeded is set to 0
	// so we dont return BUFFER_TOO_SMALL here; we assume here that
	// Bufferlength is also 0.
	// Buffer is actually the IRP here.
	//
	case IPX_QUERY_DATA_LINK_ADDRESS:
	case IPX_QUERY_NETWORK_ADDRESS:

        BindingNeeded = FALSE;
        LengthNeeded = 0;
        break;

    //
    //  NBIPX wants to know if it is a WAN link
    //
    case IPX_QUERY_MEDIA_TYPE:
         BindingNeeded = TRUE;
         LengthNeeded = sizeof(NDIS_MEDIUM);
       break;

    case IPX_QUERY_DEVICE_RELATION:
       BindingNeeded = TRUE; 
       LengthNeeded = sizeof(void *); 
       break; 

    default:

        return STATUS_NOT_SUPPORTED;

    }


    if (LengthNeeded > BufferLength) {
        if (BufferLengthNeeded != NULL) {
            *BufferLengthNeeded = LengthNeeded;
        }
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (BindingNeeded) {
       if (NicHandle != NULL) {
	  NicId = NicHandle->NicId;
       } else {
	  return STATUS_INVALID_PARAMETER; 
       }

        if (NicId == 0) {
            NicId = 1;
        }

		IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

        Binding = NIC_ID_TO_BINDING(IpxDevice, NicId);
        if ((Binding == NULL) ||
            (!Binding->LineUp)) {
			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            return STATUS_INVALID_PARAMETER;
        }

        IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
    }


    //
    // Now return the data.
    //

    switch (InternalQueryType) {

    case IPX_QUERY_LINE_INFO:

        LineInfo = (PIPX_LINE_INFO)Buffer;
        LineInfo->LinkSpeed = Binding->MediumSpeed;
        LineInfo->MaximumPacketSize = Binding->MaxLookaheadData + sizeof(IPX_HEADER);
        LineInfo->MaximumSendSize = Binding->AnnouncedMaxDatagramSize + sizeof(IPX_HEADER);
        LineInfo->MacOptions = Binding->Adapter->MacInfo.MacOptions;
        break;

    case IPX_QUERY_MAXIMUM_NIC_ID:

        MaximumNicId = (PUSHORT)Buffer;
        *MaximumNicId = MIN (Device->MaxBindings, IpxDevice->HighestExternalNicId);
        break;

    case IPX_QUERY_IS_ADDRESS_LOCAL:

        IpxAddress = (TDI_ADDRESS_IPX UNALIGNED *)Buffer;
        if (!IpxIsAddressLocal(IpxAddress)) {
            return STATUS_NO_SUCH_DEVICE;
        }
        break;

    case IPX_QUERY_RECEIVE_BUFFER_SPACE:

        ReceiveBufferSpace = (PULONG)Buffer;
        *ReceiveBufferSpace = Binding->Adapter->ReceiveBufferSpace;
        break;

    case IPX_QUERY_IPX_ADDRESS:

        RtlCopyMemory (Buffer, &Binding->LocalAddress, sizeof(TDI_ADDRESS_IPX));
        break;

    case IPX_QUERY_SOURCE_ROUTING:

        SourceRoutingInfo = (IPX_SOURCE_ROUTING_INFO UNALIGNED *)Buffer;

        MacLookupSourceRouting(
            SourceRoutingInfo->Identifier,
            Binding,
            SourceRoutingInfo->RemoteAddress,
            SourceRoutingInfo->SourceRouting,
            &SourceRoutingLength);

        //
        // Reverse the direction of the source routing since it
        // is returned in the outgoing order.
        //

        if (SourceRoutingLength > 0) {
            SourceRoutingInfo->SourceRouting[0] &= 0x7f;
        }
        SourceRoutingInfo->SourceRoutingLength = (USHORT)SourceRoutingLength;

        MacReturnMaxDataSize(
            &Binding->Adapter->MacInfo,
            SourceRoutingInfo->SourceRouting,
            SourceRoutingLength,
            Binding->MaxSendPacketSize,
            &MaxUserData);

        //
        // MaxUserData does not include the MAC header but does include
        // any extra 802.2 etc. headers, so we adjust for that to get the
        // size starting at the IPX header.
        //

        SourceRoutingInfo->MaximumSendSize =
            MaxUserData -
            (Binding->DefHeaderSize - Binding->Adapter->MacInfo.MinHeaderLength);

        break;

    case IPX_QUERY_MAX_TYPE_20_NIC_ID:

        MaximumNicId = (PUSHORT)Buffer;
        *MaximumNicId = MIN (Device->MaxBindings, IpxDevice->HighestType20NicId);
        break;

	case IPX_QUERY_DATA_LINK_ADDRESS:
	case IPX_QUERY_NETWORK_ADDRESS:
		//
		// Call the TDI query equivalent here.
		//
		return IpxTdiQueryInformation(Device, (PREQUEST)Buffer);
    
    case IPX_QUERY_MEDIA_TYPE:
         
       Medium = (PNDIS_MEDIUM) Buffer;
       *Medium = Binding->Adapter->MacInfo.MediumType;
       IPX_DEBUG(CONFIG, ("The medium is %x\n", *Medium));
       break;

    case IPX_QUERY_DEVICE_RELATION:

       PPDO = (PVOID *) Buffer; 
       *PPDO = Binding->Adapter->PNPContext;
       IPX_DEBUG(CONFIG, ("The PDO is %p\n", *PPDO));
       if (*PPDO == NULL) {
           IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
           return STATUS_UNSUCCESSFUL; 
       }
       break; 
    }

    //
    // If Binding was needed earlier, it was referenced, deref it now.
    //
    if (BindingNeeded) {
        IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
    }

    //
    // If we haven't returned failure by now, succeed.
    //

    return STATUS_SUCCESS;

}   /* IpxInternalQuery */


VOID
IpxInternalIncrementWanInactivity(
#ifdef	_PNP_LATER
// RIP not converted yet...
//
	IN	NIC_HANDLE	NicHandle
#else
    IN USHORT NicId
#endif
)

/*++

Routine Description:

    This routine is the entry point where rip calls us to increment
    the inactivity counter on a wan binding. This is done every
    minute.

Arguments:

    NicId - The NIC ID of the wan binding.

Return Value:

    None.

--*/

{
    PBINDING Binding;

    IPX_DEFINE_LOCK_HANDLE(LockHandle1)

	IPX_GET_LOCK1(&IpxDevice->BindAccessLock, &LockHandle1);
    //
    // Change to NIC_HANDLE_TO_BINDING later. Not done yet since RIP not changed to
    // use NICHANDLE instead of NicId
    //
	Binding = NIC_ID_TO_BINDING(IpxDevice, NicId);

    if ((Binding != NULL) &&
        (Binding->Adapter->MacInfo.MediumAsync)) {

        ++Binding->WanInactivityCounter;

    } else {

        CTEAssert (FALSE);

    }
	IPX_FREE_LOCK1(&IpxDevice->BindAccessLock, LockHandle1);

}   /* IpxInternalIncrementWanInactivity */


ULONG
IpxInternalQueryWanInactivity(
#ifdef	_PNP_LATER
    IN NIC_HANDLE	NicHandle
#else
    IN USHORT NicId
#endif
)

/*++

Routine Description:

    This routine is the entry point where rip calls us to query
    the inactivity counter on a wan binding.

Arguments:

    NicId - The NIC ID of the wan binding.

Return Value:

    The inactivity counter for this binding.

--*/

{
    PBINDING Binding;

    IPX_DEFINE_LOCK_HANDLE(LockHandle1)

	IPX_GET_LOCK1(&IpxDevice->BindAccessLock, &LockHandle1);
	// Binding = NIC_HANDLE_TO_BINDING(IpxDevice, &NicHandle);

	Binding = NIC_ID_TO_BINDING(IpxDevice, NicId);
    if ((Binding != NULL) &&
        (Binding->Adapter->MacInfo.MediumAsync)) {
		IPX_FREE_LOCK1(&IpxDevice->BindAccessLock, LockHandle1);
        return Binding->WanInactivityCounter;

    } else {
		IPX_FREE_LOCK1(&IpxDevice->BindAccessLock, LockHandle1);
        CTEAssert (FALSE);
        return 0;

    }

}   /* IpxInternalQueryWanInactivity */

// Pre-condition: Loopback binding has been created. 
//
// This routine is used to essure that we have indicated the loopback
// binding before indicate any other bindings. 
//  
// This routine returns true if we have informed NB about loopback bindings;  
// false if we have not informed NB about loopback and if loopback binding
// does not exist. 

BOOLEAN IpxHasInformedNbLoopback() {

   BOOLEAN RetVal; 
   PBINDING Binding; 
   PDEVICE  Device = IpxDevice; 

   IPX_DEFINE_LOCK_HANDLE(LockHandle1)
   IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
   Binding = NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID);

   if (Binding != NULL) { 

      RetVal = Binding->IsnInformed[IDENTIFIER_NB]; 
      IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
      return RetVal; 

   } else {

      DbgPrint("IPX:IpxHasInformedNbLoopback:Loopback binding is null.\n"); 
      IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
      return FALSE; 

   }	
}

// Pre-condition: Loopback binding has been created. 
// 
// This routine informs NB about IPX loopback binding. 
// 
// This should be the only place that we tell NB about loopback bindings. 
// Loopback bindings must be the first device that we indicate to NB and the
// last device that we delete from NB. Thus, FirstOrLastDevice is only true
// when we inform NB about the loopback binding. It simply returns we already 
// informed NB of loopback bindngs. 

VOID IpxInformNbLoopback() {

    PDEVICE	Device = IpxDevice;
    IPX_PNP_INFO	IpxPnPInfo;
    PBINDING Binding; 
    IPX_DEFINE_LOCK_HANDLE(LockHandle)
    IPX_DEFINE_LOCK_HANDLE(LockHandle1)


    IPX_GET_LOCK(&Device->Lock, &LockHandle);

    // IPX_GET_LOCK1 is no op. 
    IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

    Binding = NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID);

    if (!Binding) {
       DbgPrint("IPX:IpxHasInformedNbLoopback:Loopback binding is null.\n");        
       IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
       IPX_FREE_LOCK(&Device->Lock, LockHandle);
       return; 
    }

    if (Binding->IsnInformed[IDENTIFIER_NB] != TRUE) {
	    
       Binding->IsnInformed[IDENTIFIER_NB] = TRUE;
       
       IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
       
       RtlZeroMemory(&IpxPnPInfo, sizeof(IpxPnPInfo)); 
       
       IpxPnPInfo.LineInfo.LinkSpeed = Device->LinkSpeed;
       IpxPnPInfo.LineInfo.MaximumPacketSize =
	  Device->Information.MaximumLookaheadData + sizeof(IPX_HEADER);
       IpxPnPInfo.LineInfo.MaximumSendSize =
	  Device->Information.MaxDatagramSize + sizeof(IPX_HEADER);
       IpxPnPInfo.LineInfo.MacOptions = Device->MacOptions;
       
       IpxPnPInfo.FirstORLastDevice = TRUE;
       IpxPnPInfo.NewReservedAddress = TRUE;
	    
       IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
       
       IpxPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
       RtlCopyMemory(IpxPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
       NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, (USHORT) LOOPBACK_NIC_ID);

       IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

       IPX_FREE_LOCK(&Device->Lock, LockHandle);

       //
       // give the PnP indication
       //


       (*Device->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
							  IPX_PNP_ADD_DEVICE,
							  &IpxPnPInfo);

       IPX_DEBUG(PNP, ("IpxPnPIsnIndicate: PnP to NB add: %lx\n", Binding));
    } else {
       IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
       IPX_FREE_LOCK(&Device->Lock, LockHandle);
    }
}

VOID
IpxPnPIsnIndicate(
    IN PVOID	Param
)

/*++

Routine Description:

	This routine goes through the list of adapters and informs (thru' PnP indications)
	the ISN drivers bound to IPX about any new adapters that have appeared before the
	bind took place.

	This is queued as a work item in the InternalBind routine.

Arguments:

    Param - the upper driver identifier.

Return Value:

    None.

--*/
{
   #ifdef SUNDOWN
   	ULONG_PTR Identifier = (ULONG_PTR)Param;
   #else
   	ULONG	Identifier = (ULONG)Param;
   #endif
   

	PDEVICE	Device=IpxDevice;
	ULONG	i;
	PBINDING	Binding;
	IPX_PNP_INFO	IpxPnPInfo;
    IPX_DEFINE_LOCK_HANDLE(LockHandle1)

	//
	// Set up the LineInfo struct.
	//

	//
	// Do we give Binding-specific information here?
	//
	IpxPnPInfo.LineInfo.LinkSpeed = Device->LinkSpeed;
	IpxPnPInfo.LineInfo.MaximumPacketSize =
		Device->Information.MaximumLookaheadData + sizeof(IPX_HEADER);
	IpxPnPInfo.LineInfo.MaximumSendSize =
		Device->Information.MaxDatagramSize + sizeof(IPX_HEADER);
	IpxPnPInfo.LineInfo.MacOptions = Device->MacOptions;

	switch(Identifier) {
	case IDENTIFIER_NB:
		IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

		//
		// Inform about all the adapters
        //
		{
        ULONG   Index = MIN (Device->MaxBindings, Device->HighestExternalNicId);

        IpxInformNbLoopback();

	KeSetEvent(
            &Device->NbEvent,
            0L,
            FALSE);

        for (i = LOOPBACK_NIC_ID + 1; i <= Index; i++) {
	    
	    Binding = NIC_ID_TO_BINDING(Device, i);

            if (!Binding) {
                continue;
            }

			//
			// We could have informed the upper driver from IpxBindAdapter
			//
			if (!Binding->IsnInformed[Identifier]) {

				//
				// Inform NB - the reserved network/node address is always that of the first
				// binding
				//

			
				IpxPnPInfo.FirstORLastDevice = FALSE;
				IpxPnPInfo.NewReservedAddress = FALSE;

				IpxPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
				RtlCopyMemory(IpxPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
				NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, (USHORT)i);

				IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

				//
				// give the PnP indication
				//

				ASSERT(IpxPnPInfo.FirstORLastDevice == FALSE);
				ASSERT(IpxHasInformedNbLoopback()); 

				(*Device->UpperDrivers[Identifier].PnPHandler) (
					IPX_PNP_ADD_DEVICE,
					&IpxPnPInfo);
				
				Binding->IsnInformed[Identifier] = TRUE;

				IPX_DEBUG(PNP, ("IpxPnPIsnIndicate: PnP to NB add: %lx\n", Binding));
				IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
			}
		}
        }
		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
		break;

    case IDENTIFIER_SPX:
        //
        // For SPX this is called directly, with the IsnInformed flag appropriately set.
        // This is done so that the IsnInformed flag cannot be changed under
        // us by the BindAdapter routine.
        //
#if 0
		IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

		if (!NIC_ID_TO_BINDING(Device, 1)->IsnInformed[Identifier]) {
			NIC_ID_TO_BINDING(Device, 1)->IsnInformed[Identifier] = TRUE;
#endif
			IpxPnPInfo.FirstORLastDevice = TRUE;
			//
			// Inform of the reserved address only
			//
			if (Device->VirtualNetwork) {
				IpxPnPInfo.NetworkAddress = Device->SourceAddress.NetworkAddress;
				RtlCopyMemory(IpxPnPInfo.NodeAddress, Device->SourceAddress.NodeAddress, 6);
				NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, 0);
			} else {
				IpxPnPInfo.NetworkAddress = NIC_ID_TO_BINDING(Device, 1)->LocalAddress.NetworkAddress;
				RtlCopyMemory(IpxPnPInfo.NodeAddress, NIC_ID_TO_BINDING(Device, 1)->LocalAddress.NodeAddress, 6);
				NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, 1);	
			}

			IpxPnPInfo.NewReservedAddress = TRUE;

			// IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

			(*Device->UpperDrivers[Identifier].PnPHandler) (
				IPX_PNP_ADD_DEVICE,
				&IpxPnPInfo);

            IPX_DEBUG(PNP, ("IpxPnPIsnIndicate: PnP to SPX add: %lx\n", NIC_ID_TO_BINDING(Device, 1)));
#if 0
		} else {
            CTEAssert(FALSE);

			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
        }
#endif

	}

	// DbgPrint("---------- 5. Done with IpxPnPIsnIndicate  ----------\n"); 
	IpxDereferenceDevice(Device, DREF_PNP); 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\mac.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    mac.c

Abstract:

    This module contains code which implements Mac type dependent code for
    the IPX transport.

Environment:

    Kernel mode (Actually, unimportant)

Revision History:

	Sanjay Anand (SanjayAn) - 22-Sept-1995
	BackFill optimization changes added under #if BACK_FILL

--*/

#include "precomp.h"
#pragma hdrstop

#define TR_LENGTH_MASK             0x1F    // low 5 bits in byte
#define TR_DIRECTION_MASK          0x80    // returns direction bit
#define TR_DEFAULT_LENGTH          0x70    // default for outgoing
#define TR_MAX_SIZE_MASK           0x70

#define TR_PREAMBLE_AC             0x10
#define TR_PREAMBLE_FC             0x40

#define FDDI_HEADER_BYTE           0x57


static UCHAR AllRouteSourceRouting[2] = { 0x82, TR_DEFAULT_LENGTH };
static UCHAR SingleRouteSourceRouting[2] = { 0xc2, TR_DEFAULT_LENGTH };

#define ROUTE_EQUAL(_A,_B) { \
    (*(UNALIGNED USHORT *)(_A) == *(UNALIGNED USHORT *)(_B)) \
}


//
// For back-fillable packets, chains the back-fill space as a MAC header
// to the packet and sets the header pointer.
//

//
// We dont need to test for IDENTIFIER_IPX since it will always be
// true for the mediumframe specific send handlers.
//
#define	BACK_FILL_HEADER(_header, _reserved, _headerlength, _packet) \
	if ((_reserved)->Identifier == IDENTIFIER_IPX) { \
		if((_reserved)->BackFill) {		\
			CTEAssert ((_reserved)->HeaderBuffer); \
			CTEAssert ((_reserved)->HeaderBuffer->MdlFlags & MDL_NETWORK_HEADER); \
			_header = (PCHAR)(_reserved)->HeaderBuffer->MappedSystemVa - (_headerlength); \
			(_reserved)->HeaderBuffer->MappedSystemVa = (PCHAR)(_reserved)->HeaderBuffer->MappedSystemVa - (_headerlength); \
			(_reserved)->HeaderBuffer->ByteOffset -= (_headerlength); \
            ASSERT((LONG)(_reserved)->HeaderBuffer->ByteOffset >= 0); \
			NdisChainBufferAtFront(_packet,(PNDIS_BUFFER)(_reserved)->HeaderBuffer); \
		} \
	}

//
// In case of back-fillable packets, the adjusted length should include
// the prev. bytecount of the headerbuffer.
//
#define BACK_FILL_ADJUST_BUFFER_LENGTH(_reserved, _headerlength) \
    if((_reserved)->BackFill){ \
		NdisAdjustBufferLength ((_reserved)->HeaderBuffer, _headerlength+(_reserved)->HeaderBuffer->ByteCount); \
		IPX_DEBUG(SEND,("mac user mdl %x\n", (_reserved)->HeaderBuffer)); \
    } else { \
		NdisAdjustBufferLength ((_reserved)->HeaderBuffer, _headerlength); \
	}

//
// This is the interpretation of the length bits in
// the 802.5 source-routing information.
//

ULONG SR802_5Lengths[8] = {  516,  1500,  2052,  4472,
                            8144, 11407, 17800, 17800 };



VOID
MacInitializeBindingInfo(
    IN struct _BINDING * Binding,
    IN struct _ADAPTER * Adapter
    )

/*++

Routine Description:

    Fills in the binding info based on the adapter's MacInfo
    and the frame type of the binding.

Arguments:

    Binding - The newly created binding.

    Adapter - The adapter.

Return Value:

    None.

--*/

{
    ULONG MaxUserData;

    Binding->DefHeaderSize = Adapter->DefHeaderSizes[Binding->FrameType];
    Binding->BcMcHeaderSize = Adapter->BcMcHeaderSizes[Binding->FrameType];

    MacReturnMaxDataSize(
        &Adapter->MacInfo,
        NULL,
        0,
        Binding->MaxSendPacketSize,
        &MaxUserData);

    Binding->MaxLookaheadData =
        Adapter->MaxReceivePacketSize -
        sizeof(IPX_HEADER) -
        (Binding->DefHeaderSize - Adapter->MacInfo.MinHeaderLength);

    Binding->AnnouncedMaxDatagramSize =
        MaxUserData -
        sizeof(IPX_HEADER) -
        (Binding->DefHeaderSize - Adapter->MacInfo.MinHeaderLength);

    Binding->RealMaxDatagramSize =
        Binding->MaxSendPacketSize -
        Adapter->MacInfo.MaxHeaderLength -
        sizeof(IPX_HEADER) -
        (Binding->DefHeaderSize - Adapter->MacInfo.MinHeaderLength);

}   /* MacInitializeBindingInfo */


VOID
MacInitializeMacInfo(
    IN NDIS_MEDIUM MacType,
    OUT PNDIS_INFORMATION MacInfo
    )

/*++

Routine Description:

    Fills in the MacInfo table based on MacType.

Arguments:

    MacType - The MAC type we wish to decode.

    MacInfo - The MacInfo structure to fill in.

Return Value:

    None.

--*/

{
    switch (MacType) {
    case NdisMedium802_3:
        MacInfo->SourceRouting = FALSE;
        MacInfo->MediumAsync = FALSE;
        MacInfo->BroadcastMask = 0x01;
        MacInfo->MaxHeaderLength = 14;
        MacInfo->MinHeaderLength = 14;
        MacInfo->MediumType = NdisMedium802_3;
        break;
    case NdisMedium802_5:
        MacInfo->SourceRouting = TRUE;
        MacInfo->MediumAsync = FALSE;
        MacInfo->BroadcastMask = 0x80;
        MacInfo->MaxHeaderLength = 32;
        MacInfo->MinHeaderLength = 14;
        MacInfo->MediumType = NdisMedium802_5;
        break;
    case NdisMediumFddi:
        MacInfo->SourceRouting = FALSE;
        MacInfo->MediumAsync = FALSE;
        MacInfo->BroadcastMask = 0x01;
        MacInfo->MaxHeaderLength = 13;
        MacInfo->MinHeaderLength = 13;
        MacInfo->MediumType = NdisMediumFddi;
        break;
    case NdisMediumArcnet878_2:
        MacInfo->SourceRouting = FALSE;
        MacInfo->MediumAsync = FALSE;
        MacInfo->BroadcastMask = 0x00;
        MacInfo->MaxHeaderLength = 3;
        MacInfo->MinHeaderLength = 3;
        MacInfo->MediumType = NdisMediumArcnet878_2;
        break;
    case NdisMediumWan:
        MacInfo->SourceRouting = FALSE;
        MacInfo->MediumAsync = TRUE;
        MacInfo->BroadcastMask = 0x01;
        MacInfo->MaxHeaderLength = 14;
        MacInfo->MinHeaderLength = 14;
        MacInfo->MediumType = NdisMedium802_3;
        break;
    default:
        CTEAssert(FALSE);
    }
    MacInfo->RealMediumType = MacType;

}   /* MacInitializeMacInfo */


VOID
MacMapFrameType(
    IN NDIS_MEDIUM MacType,
    IN ULONG FrameType,
    OUT ULONG * MappedFrameType
    )

/*++

Routine Description:

    Maps the specified frame type to a value which is
    valid for the medium.

Arguments:

    MacType - The MAC type we wish to map for.

    FrameType - The frame type in question.

    MappedFrameType - Returns the mapped frame type.

Return Value:

--*/

{
    switch (MacType) {

    //
    // Ethernet accepts all values, the default is 802.2.
    //

    case NdisMedium802_3:
        if (FrameType >= ISN_FRAME_TYPE_MAX) {
            *MappedFrameType = ISN_FRAME_TYPE_802_2;
        } else {
            *MappedFrameType = FrameType;
        }
        break;

    //
    // Token-ring supports SNAP and 802.2 only.
    //

    case NdisMedium802_5:
        if (FrameType == ISN_FRAME_TYPE_SNAP) {
            *MappedFrameType = ISN_FRAME_TYPE_SNAP;
        } else {
            *MappedFrameType = ISN_FRAME_TYPE_802_2;
        }
        break;

    //
    // FDDI supports SNAP, 802.2, and 802.3 only.
    //

    case NdisMediumFddi:
        if ((FrameType == ISN_FRAME_TYPE_SNAP) || (FrameType == ISN_FRAME_TYPE_802_3)) {
            *MappedFrameType = FrameType;
        } else {
            *MappedFrameType = ISN_FRAME_TYPE_802_2;
        }
        break;

    //
    // On arcnet there is only one frame type, use 802.3
    // (it doesn't matter what we use).
    //

    case NdisMediumArcnet878_2:
        *MappedFrameType = ISN_FRAME_TYPE_802_3;
        break;

    //
    // WAN uses ethernet II because it includes the ethertype.
    //

    case NdisMediumWan:
        *MappedFrameType = ISN_FRAME_TYPE_ETHERNET_II;
        break;

    default:
        CTEAssert(FALSE);
    }

}   /* MacMapFrameType */

//
// use symbols instead of hardcoded values for mac header lengths
//                                                        --pradeepb
//

VOID
MacReturnMaxDataSize(
    IN PNDIS_INFORMATION MacInfo,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength,
    IN UINT DeviceMaxFrameSize,
    OUT PUINT MaxFrameSize
    )

/*++

Routine Description:

    This routine returns the space available for user data in a MAC packet.
    This will be the available space after the MAC header; all headers
    headers will be included in this space.

Arguments:

    MacInfo - Describes the MAC we wish to decode.

    SourceRouting - If we are concerned about a reply to a specific
        frame, then this information is used.

    SourceRouting - The length of SourceRouting.

    MaxFrameSize - The maximum frame size as returned by the adapter.

    MaxDataSize - The maximum data size computed.

Return Value:

    None.

--*/

{
    switch (MacInfo->MediumType) {

    case NdisMedium802_3:

        //
        // For 802.3, we always have a 14-byte MAC header.
        //

        *MaxFrameSize = DeviceMaxFrameSize - 14;
        break;

    case NdisMedium802_5:

        //
        // For 802.5, if we have source routing information then
        // use that, otherwise assume the worst.
        //

        if (SourceRouting && SourceRoutingLength >= 2) {

            UINT SRLength;

            SRLength = SR802_5Lengths[(SourceRouting[1] & TR_MAX_SIZE_MASK) >> 4];
            DeviceMaxFrameSize -= (SourceRoutingLength + 14);

            if (DeviceMaxFrameSize < SRLength) {
                *MaxFrameSize = DeviceMaxFrameSize;
            } else {
                *MaxFrameSize = SRLength;
            }

        } else {

#if 0
            if (DeviceMaxFrameSize < 608) {
                *MaxFrameSize = DeviceMaxFrameSize - 32;
            } else {
                *MaxFrameSize = 576;
            }
#endif
            //
            // bug # 6192.  There is no point in assuming the worst.  It only
            // leads to lower throughput.  Packets can get dropped by an
            // an intermediate router for both cases (this one and the one
            // above where 576 is chosen).  In the above case, they will
            // get dropped if two ethernet machines are communicating via
            // a token ring. In this case, they will if two token ring
            // machines with a frame size > max ethernet frame size are
            // going over an ethernet.  To fix the packet drop case, one
            // should adjust the MaxPktSize Parameter of the card.
            //
            *MaxFrameSize = DeviceMaxFrameSize - 32;
        }

        break;

    case NdisMediumFddi:

        //
        // For FDDI, we always have a 13-byte MAC header.
        //

        *MaxFrameSize = DeviceMaxFrameSize - 13;
        break;

    case NdisMediumArcnet878_2:

        //
        // For Arcnet, we always have a 3-byte MAC header.
        //

        *MaxFrameSize = DeviceMaxFrameSize - 3;
        break;

    }

}   /* MacReturnMaxDataSize */


VOID
IpxUpdateWanInactivityCounter(
    IN PBINDING Binding,
    IN IPX_HEADER UNALIGNED * IpxHeader,
    IN ULONG IncludedHeaderLength,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength
    )

/*++

Routine Description:

    This routine is called when a frame is being sent on a WAN
    line. It updates the inactivity counter for this binding
    unless:

    - The frame is from the RIP socket
    - The frame is from the SAP socket
    - The frame is a netbios keep alive
    - The frame is an NCP keep alive

    Take the identifier as a parameter to optimize.

Arguments:

    Binding - The binding the frame is sent on.

    IpxHeader - May contain the first bytes of the packet.

    IncludedHeaderLength - The number of packet bytes at IpxHeader.

    Packet - The full NDIS packet.

    PacketLength - The length of the packet.

Return Value:

    None, but in some cases we return without resetting the
    inactivity counter.

Comments:   Improve the instruction count here - pradeepb

--*/

{
    USHORT SourceSocket;
    PNDIS_BUFFER DataBuffer = NULL;
    PUCHAR DataBufferData;
    UINT DataBufferLength;


    //
    // First get the source socket.
    //
    SourceSocket = IpxHeader->SourceSocket;
    if ((SourceSocket == RIP_SOCKET) ||
        (SourceSocket == SAP_SOCKET)) {

         return;

    }

    if (SourceSocket == NB_SOCKET) {

        UCHAR ConnectionControlFlag;
        UCHAR DataStreamType;
        USHORT TotalDataLength;

        //
        // ConnectionControlFlag and DataStreamType will always follow
        // IpxHeader
        //
        ConnectionControlFlag = ((PUCHAR)(IpxHeader+1))[0];
        DataStreamType = ((PUCHAR)(IpxHeader+1))[1];

        //
        // If this is a SYS packet with or without a request for ACK and
        // has session data in it.
        //
        if (((ConnectionControlFlag == 0x80) || (ConnectionControlFlag == 0xc0)) &&
            (DataStreamType == 0x06)) {

             //
             // TotalDataLength is in the same buffer.
             //
             TotalDataLength = ((USHORT UNALIGNED *)(IpxHeader+1))[4];

            //
            // No need to update the WAN activity counter
            //
            if (TotalDataLength == 0) {
                return;
            }
        }

    } else {

        UCHAR KeepAliveSignature;


        //
        // Now see if it is an NCP keep alive. It can be from rip or from
        // NCP on this machine
        //
        // NOTE: We cannot come here for an SMB packet - [IsaacHe - 12/15].
        //
        if (PacketLength == sizeof(IPX_HEADER) + 2) {

            //
            // Get the client data buffer
            //
            NdisQueryPacket(Packet, NULL, NULL, &DataBuffer, NULL);

            //
            // If the included header length is 0, it is from rip
            //
            if (IncludedHeaderLength == 0) {

                //
                // Get the second buffer in the packet. The second buffer
                // contains the IPX header + other stuff
                //
                DataBuffer = NDIS_BUFFER_LINKAGE(DataBuffer);
            } else {
                //
                // Get the third buffer in the packet.
                //
                DataBuffer = NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE(DataBuffer));
            }

            NdisQueryBufferSafe (DataBuffer, (PVOID *)&DataBufferData, &DataBufferLength, NormalPagePriority);
            
	    if (DataBufferData == NULL) { 
	       return; 
	    }

            if (IncludedHeaderLength == 0) {
              KeepAliveSignature = DataBufferData[sizeof(IPX_HEADER) + 1];
            } else {
              KeepAliveSignature = DataBufferData[1];
            }

            if ((KeepAliveSignature == '?') ||
                (KeepAliveSignature == 'Y')) {
                return;
            }
        }
    }


    //
    // This was a normal packet, so reset this.
    //

    Binding->WanInactivityCounter = 0;

}   /* IpxUpdateWanInactivityCounter */

#if DBG
ULONG IpxPadCount = 0;
#endif


NDIS_STATUS
IpxSendFramePreFwd(
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    )

/*++

Routine Description:

    This routine is called by NB/SPX to send a frame.

Arguments:

    LocalTarget - The local target of the send - NB will have the LocalTarget in the Send_Reserved part
                  of the packet; SPX will not now, but will later.

    Packet - The NDIS packet.

    PacketLength - The length of the packet, starting at the IPX header.

    IncludedHeaderLength - The length of the header included in the
        first buffer that needs to be moved if it does not wind up
        MacHeaderOffset bytes into the packet.

Return Value:

    Return of IpxSendFrame


--*/

{
    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PUCHAR Header;
    PNDIS_BUFFER HeaderBuffer;
    PUCHAR IpxHeader;
    PUCHAR EthernetHeader;
    PIPX_HEADER pIpxHeader;
    UINT TempHeaderBufferLength;
    PDEVICE Device = IpxDevice;
    PIPX_HEADER TempHeader;
    NTSTATUS    ret;
    BOOLEAN     fIterate=FALSE;
    PBINDING     pBinding = NULL;
    
    //
    // Figure out the IpxHeader - it is always at the top of the second MDL.
    //
    NdisQueryPacket (Packet, NULL, NULL, &HeaderBuffer, NULL);
    NdisQueryBufferSafe (HeaderBuffer, &EthernetHeader, &TempHeaderBufferLength, HighPagePriority);
    NdisQueryBufferSafe (NDIS_BUFFER_LINKAGE(HeaderBuffer), &IpxHeader, &TempHeaderBufferLength, HighPagePriority);

    if (EthernetHeader == NULL || IpxHeader == NULL) {
       return NDIS_STATUS_FAILURE; 
    }
	//
	// Set this now, will change later
	//
	Reserved->CurrentNicId = 0;

    //
    // Copy the LocalTarget into the send reserved area of the packet.
    //
    Reserved->LocalTarget = *LocalTarget;

	//
	// If the NicId in the handle is ITERATIVE_NIC_ID, then this could be a send
	// over all NICs in the case of NB/SPX.
	//
	if (NIC_FROM_LOCAL_TARGET(LocalTarget) == (USHORT)ITERATIVE_NIC_ID) {
		CTEAssert(Reserved->Identifier == IDENTIFIER_NB ||
						Reserved->Identifier == IDENTIFIER_SPX);
        
        //
        // If there are no real adapters, send on loopback and then quit.
        if (Device->RealAdapters) {
            
            //
            // Start with the first REAL NIC
            //

            Reserved->CurrentNicId = FIRST_REAL_BINDING;
            FILL_LOCAL_TARGET(&Reserved->LocalTarget, FIRST_REAL_BINDING);


        } else {

            //
            // Use loopback
            //
            Reserved->CurrentNicId = LOOPBACK_NIC_ID;
            FILL_LOCAL_TARGET(&Reserved->LocalTarget, LOOPBACK_NIC_ID);

        }

        IPX_DEBUG(SEND, ("Iteration over NICs started, reserved: %lx\n", Reserved));
        Reserved->Net0SendSucceeded = FALSE;
        Reserved->PacketLength = PacketLength;
        fIterate = TRUE;

    }
    
    //
    // If the Forwarder is installed, send the packet out for filtering
    //
    if (Device->ForwarderBound) {
       #ifdef SUNDOWN
	 ULONG_PTR FwdAdapterContext = INVALID_CONTEXT_VALUE;
       #else
	 ULONG FwdAdapterContext = INVALID_CONTEXT_VALUE;
       #endif
       
        PBINDING    Binding;

        //
        // Figure out the FwdAdapterContext; if the NicId is 0
        // then no NicId is specified (since we never return a
        // NicId of 0 in a FindRoute).
        //

        //
        // We need to fix the following problems with respect to type 20 iterative bcasts :
        //  1. IPX will not bcast on a down WAN line (thus the Fwd cannot bring up a demand-dial line).
        //  2. IPX bcasts on every Nic (since it is not any wiser about selecting relevant Nics).
        //  3. If the first bcast fails, the whole send fails.
        //
        // All the above (except 3.) occur because the Fwd knows more about the Nics than IPX does; hence
        // we let the Fwd decide which lines he wants to send a bcast on. Thus, for Type20 pkts, we pass
        // up the invalid Fwd context so the Fwd decides the next Nic to send on.
        //
        if (!((((PIPX_HEADER)IpxHeader)->PacketType == 0x14) && fIterate) &&
            Reserved->LocalTarget.NicId &&
            (Binding = NIC_ID_TO_BINDING(Device, Reserved->LocalTarget.NicId)) &&
            (GET_LONG_VALUE(Binding->ReferenceCount) == 2)) {
                //
                // If proper NicId specified, and the adapter has been opened by
                // the forwarder, set the FwdAdapterContext.
                //
                FwdAdapterContext = Binding->FwdAdapterContext;
        }
#if DBG
        else {
            if (((PIPX_HEADER)IpxHeader)->PacketType == 0x14) {
                IPX_DEBUG(SEND, ("SendComplete: IpxHeader has Type20: %lx\n", IpxHeader));
            }
        }
#endif

        //
        // Call the InternalSend to filter the packet and get to know
        // the correct adapter context
        //
        ret = (*Device->UpperDrivers[IDENTIFIER_RIP].InternalSendHandler)(
                   &Reserved->LocalTarget,
                   FwdAdapterContext,
                   Packet,
                   IpxHeader,
                   IpxHeader+sizeof(IPX_HEADER),    // the data starts after the IPX Header.
                   PacketLength,
                   fIterate);

        //
        // The FWD might not yet know of the Nics going away [109160].
        //
        if (NULL == NIC_ID_TO_BINDING(Device, Reserved->LocalTarget.NicId)) {

           ret = STATUS_DROP_SILENTLY; 

        }

        if (ret == STATUS_SUCCESS) {
            //
            // The adapter could have gone away and we have indicated to the Forwarder
            // but the Forwarder has not yet closed the adapter.
            // [ZZ] adapters do not go away now.
            //
            // what if the binding is NULL here? Can we trust the Forwarder to
            // give us a non-NULL binding?
            //


            if (GET_LONG_VALUE(NIC_ID_TO_BINDING(Device, Reserved->LocalTarget.NicId)->ReferenceCount) == 1) {
                IPX_DEBUG(SEND, ("IPX: SendFramePreFwd: FWD returned SUCCESS, Ref count is 1\n"));
                return NDIS_STATUS_SUCCESS;
            } else {

                //
                // Fill up the changed LocalTarget for the client except in the ITERATE case.
                //
                if (!fIterate) {
                    *LocalTarget = Reserved->LocalTarget;
                }

                IPX_DEBUG(SEND, ("IPX: SendFramePreFwd: FWD returned SUCCESS, sending out on wire\n"));
                goto SendPkt;
            }
        } else if (ret == STATUS_PENDING) {
            //
            // LocalTarget will get filled up in InternalSendComplete
            //
            IPX_DEBUG(SEND, ("SendFramePreFwd: FWD returned PENDING\n"));
            return NDIS_STATUS_PENDING;
        } else if (ret == STATUS_DROP_SILENTLY) {
            //
            // This was a keepalive which the router is spoofing. Drop it silently.
            //
            IPX_DEBUG(SEND, ("IPX: SendFramePreFwd: FWD returned STATUS_DROP_SILENTLY - dropping pkt.\n"));
            return NDIS_STATUS_SUCCESS;
        }

        //
        // else DISCARD - this means that either the packet failed the send
        // or that the preferred NicId was not good.
        //
        return STATUS_NETWORK_UNREACHABLE;

    } else {

        //
        // Work around NdisMBlahX bug.
        // Check if this is a self-directed packet and loop it back.
        // 
SendPkt:
        
        pIpxHeader = (PIPX_HEADER) IpxHeader;

        if ((IPX_NODE_EQUAL(pIpxHeader->SourceNode, pIpxHeader->DestinationNode)) && 
            (*(UNALIGNED ULONG *)pIpxHeader->SourceNetwork == *(UNALIGNED ULONG *)pIpxHeader->DestinationNetwork)) {

            IPX_DEBUG(TEMP, ("Source Net: %lx + Source Address: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n", 
                     *(UNALIGNED ULONG *)pIpxHeader->SourceNetwork, 
                     pIpxHeader->SourceNode[0], 
                     pIpxHeader->SourceNode[1], 
                     pIpxHeader->SourceNode[2], 
                     pIpxHeader->SourceNode[3], 
                     pIpxHeader->SourceNode[4], 
                     pIpxHeader->SourceNode[5]));

            IPX_DEBUG(TEMP, ("Dest Net: %lx + DestinationAddress: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x \n", 
                     *(UNALIGNED ULONG *)pIpxHeader->DestinationNetwork,
                     pIpxHeader->DestinationNode[0],
                     pIpxHeader->DestinationNode[1],
                     pIpxHeader->DestinationNode[2],
                     pIpxHeader->DestinationNode[3],
                     pIpxHeader->DestinationNode[4],
                     pIpxHeader->DestinationNode[5]
                     ));

            IPX_DEBUG(TEMP, ("Well, It is self-directed. Loop it back ourselves\n"));
            FILL_LOCAL_TARGET(LocalTarget, LOOPBACK_NIC_ID);


        } else { 

            pBinding = NIC_ID_TO_BINDING(Device, Reserved->LocalTarget.NicId);

            if (pBinding) {
             
                if (IPX_NODE_EQUAL(Reserved->LocalTarget.MacAddress, pBinding->LocalAddress.NodeAddress)) {
            
                    IPX_DEBUG(TEMP, ("Source Net:%lx, Source Address: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
                                     *(UNALIGNED ULONG *)pIpxHeader->SourceNetwork, 
                                     pIpxHeader->SourceNode[0], 
                                     pIpxHeader->SourceNode[1], 
                                     pIpxHeader->SourceNode[2], 
                                     pIpxHeader->SourceNode[3], 
                                     pIpxHeader->SourceNode[4], 
                                     pIpxHeader->SourceNode[5]));
                
                    IPX_DEBUG(TEMP, ("Dest Net:%lx, DestAddress: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x \n", 
                                     *(UNALIGNED ULONG *)pIpxHeader->DestinationNetwork,
                                     pIpxHeader->DestinationNode[0],
                                     pIpxHeader->DestinationNode[1],
                                     pIpxHeader->DestinationNode[2],
                                     pIpxHeader->DestinationNode[3],
                                     pIpxHeader->DestinationNode[4],
                                     pIpxHeader->DestinationNode[5]
                                     ));

                    IPX_DEBUG(TEMP, ("Well, It is self-directed. Loop it back ourselves (NIC_HANDLE is the same!)\n"));
                    FILL_LOCAL_TARGET(LocalTarget, LOOPBACK_NIC_ID);
            
                } 
        
            } else {
            
                IPX_DEBUG(TEMP, ("Source Net:%lx, Source Address: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
                                 *(UNALIGNED ULONG *)pIpxHeader->SourceNetwork, 
                                 pIpxHeader->SourceNode[0], 
                                 pIpxHeader->SourceNode[1], 
                                 pIpxHeader->SourceNode[2], 
                                 pIpxHeader->SourceNode[3], 
                                 pIpxHeader->SourceNode[4], 
                                 pIpxHeader->SourceNode[5]));

                IPX_DEBUG(TEMP, ("Dest Net: %lx, LocalAddress: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x \n", 
                                 *(UNALIGNED ULONG *)pIpxHeader->DestinationNetwork,
                                 pIpxHeader->DestinationNode[0],
                                 pIpxHeader->DestinationNode[1],
                                 pIpxHeader->DestinationNode[2],
                                 pIpxHeader->DestinationNode[3],
                                 pIpxHeader->DestinationNode[4],
                                 pIpxHeader->DestinationNode[5]
                                 ));

            } 

        }

        if (NIC_FROM_LOCAL_TARGET(LocalTarget) == (USHORT)LOOPBACK_NIC_ID) {
            //
            // Enque this packet to the LoopbackQueue on the binding.
            // If the LoopbackRtn is not already scheduled, schedule it.
            //
            IPX_DEBUG(LOOPB, ("Mac.c: Packet: %x\n", Packet));

            //
            // Recalculate packet counts here.
            // Assume an 802_3802_2 header and use that length.
            // Adjust the MAC header's length to the right value
            //
            NdisAdjustBufferLength (HeaderBuffer, 17);
            NdisRecalculatePacketCounts (Packet);
            IpxLoopbackEnque(Packet, NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID)->Adapter);

            //
            // The upper driver waits for the SendComplete.
            //
            return  STATUS_PENDING;
        }

		return IpxSendFrame (			
			&Reserved->LocalTarget,
			Packet,
			PacketLength,
			IncludedHeaderLength);

	}
}


NDIS_STATUS
IpxSendFrame(
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    )

/*++

Routine Description:

    This routine constructs a MAC header in a packet and submits
    it to the appropriate NDIS driver.

    It is assumed that the first buffer in the packet contains
    an IPX header at an offset based on the media type. This
    IPX header is moved around if needed.

    Check that Binding is not NULL.

Arguments:

    LocalTarget - The local target of the send.

    Packet - The NDIS packet.

    PacketLength - The length of the packet, starting at the IPX header.

    IncludedHeaderLength - The length of the header included in the
        first buffer that needs to be moved if it does not wind up
        MacHeaderOffset bytes into the packet.

Return Value:

    None.

--*/

{

    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PDEVICE Device = IpxDevice;
    PUCHAR Header;
    PBINDING Binding, MasterBinding;
    PADAPTER Adapter;
    ULONG TwoBytes;
    PNDIS_BUFFER HeaderBuffer;
    UINT TempHeaderBufferLength;
    ULONG HeaderLength=0;
    UCHAR SourceRoutingBuffer[18];
    PUCHAR SourceRouting;
    ULONG SourceRoutingLength;
    NDIS_STATUS Status;
    ULONG BufferLength;
    UCHAR DestinationType;
    UCHAR SourceRoutingIdentifier;
    ULONG HeaderSizeRequired;
    PIPX_HEADER TempHeader;
    USHORT PktLength;

    IPX_DEFINE_LOCK_HANDLE(LockHandle1)
    IPX_DEFINE_LOCK_HANDLE(LockHandle)

   

#ifdef  SNMP
//
// This should not include the forwarded packets; on host side, it is 0.
// On router, the AdvSysForwPackets are subtracted in the sub-agent code.
//
    ++IPX_MIB_ENTRY(Device, SysOutRequests);
#endif  SNMP

	//
	// Get the lock on the binding array
	//
	IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

	Binding = NIC_HANDLE_TO_BINDING(Device, &LocalTarget->NicHandle);
	
	if (Binding == NULL) {
		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
		IPX_DEBUG(PNP, ("Invalid NIC handle: %lx\n", LocalTarget->NicHandle));
        //
        // Return a unique error that NB/SPX see and re-query the NicId.
        //
#ifdef  SNMP
        ++IPX_MIB_ENTRY(Device, SysOutMalformedRequests);
#endif  SNMP
		return STATUS_DEVICE_DOES_NOT_EXIST;
	}

	IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);

	Adapter = Binding->Adapter;

	IpxReferenceAdapter(Adapter);
	
       
	//
	// Release the lock
	//
	IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

    //
    // For IPX and other protocols that are guaranteed to have allocated
    // the header from non-paged pool, use the buffer directly.  For others,
    // query the packet for the pointer to the MDL.
    //
    if (Reserved->Identifier >= IDENTIFIER_IPX) {
        HeaderBuffer = Reserved->HeaderBuffer;
        Header = Reserved->Header;

    } else {
        NdisQueryPacket (Packet, NULL, NULL, &HeaderBuffer, NULL);
        NdisQueryBufferSafe(HeaderBuffer, &Header, &TempHeaderBufferLength, HighPagePriority);
	if (Header == NULL) {
	   return NDIS_STATUS_FAILURE; 
	}
    }

    CTEAssert (Reserved->PaddingBuffer == NULL);

    //
    // First move the packet around if needed.
    //

    if (Reserved->Identifier < IDENTIFIER_IPX) {

        //
        // Only RIP will have IncludedHeaderLength as 0.  I don't know
        // why we have the comment about RIP inside this if statement.
        //
        if (IncludedHeaderLength > 0) {

            //
            // Spx can handle a virtual net as long as it is
            // not 0. Netbios always needs to use the real address.
            // We need to hack the ipx source address for packets
            // which are sent by spx if we have a fake virtual
            // net, and packets sent by netbios unless we are
            // bound to only one card.
            //

            //
            // We handle binding sets as follows, based on who
            // sent the frame to us:
            //
            // RIP: Since we only tell RIP about the masters at
            // bind time, and hide slaves on indications, it should
            // never be sending on a slave binding. Since RIP knows
            // the real net and node of every binding we don't
            // need to modify the packet at all.
            //
            // NB: For broadcasts we want to put the first card's
            // address in the IPX source but round-robin the
            // actual sends over all cards (broadcasts shouldn't
            // be passed in with a slave's NIC ID). For directed
            // packets, which may come in on a slave, we should
            // put the slave's address in the IPX source.
            //
            // SPX: SPX does not send broadcasts. For directed
            // frames we want to use the slave's net and node
            // in the IPX source.
            //

            if (Reserved->Identifier == IDENTIFIER_NB) {

                CTEAssert (IncludedHeaderLength >= sizeof(IPX_HEADER));

                //
                // Get the packet length from the ipx header.  Compare with
                // the max. allowed datagram size.
                //
                TempHeader = (PIPX_HEADER)(&Header[Device->IncludedHeaderOffset]);
                PktLength = ((TempHeader->PacketLength[0] << 8) |
                                        (TempHeader->PacketLength[1]));

//
// Not the most efficient way to do this.  NWLNKNB should do this.
// Doing it in ipx means doing it for all packets (even those sent on
// connections).  Will remove this later when nwlnknb change has been
// tested.
//

                if (PktLength > (Binding->AnnouncedMaxDatagramSize + sizeof(IPX_HEADER)))       {
                   IPX_DEBUG (SEND, ("Send %d bytes too large (%d)\n",
                          PktLength,
                          Binding->AnnouncedMaxDatagramSize + sizeof(IPX_HEADER)));

					//
					// Dereference the binding and adapter
					//
					IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
					IpxDereferenceAdapter(Adapter);
#ifdef  SNMP
                    ++IPX_MIB_ENTRY(Device, SysOutMalformedRequests);
#endif  SNMP
                   return STATUS_INVALID_BUFFER_SIZE;
                }

                if (Device->ValidBindings > 1) {


                    //
                    // Store this now, since even if we round-robin the
                    // actual send we want the binding set master's net
                    // and node in the IPX source address.
                    //

                    *(UNALIGNED ULONG *)TempHeader->SourceNetwork = Binding->LocalAddress.NetworkAddress;
                    RtlCopyMemory (TempHeader->SourceNode, Binding->LocalAddress.NodeAddress, 6);

                    if (Binding->BindingSetMember) {

                        if (IPX_NODE_BROADCAST(LocalTarget->MacAddress)) {

                            //
                            // This is a broadcast, so we round-robin the
                            // sends through the binding set.
                            //
                            //
                            // We dont have a lock here - the masterbinding could be bogus
                            //
            				IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
					        IpxDereferenceAdapter(Adapter);
                            MasterBinding = Binding->MasterBinding;
                            Binding = MasterBinding->CurrentSendBinding;
                            MasterBinding->CurrentSendBinding = Binding->NextBinding;
                            Adapter = Binding->Adapter;

            				IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
					        IpxReferenceAdapter(Adapter);
                        }

                    }
                }

                //
                // [STEFANS]: Replace all source addresses with the virtualnet# to allow for sends
                // on 0 network number WAN lines (typically between routers).
                //
                if (Device->VirtualNetwork) {
                    *(UNALIGNED ULONG *)TempHeader->SourceNetwork = Device->SourceAddress.NetworkAddress;
                    RtlCopyMemory (TempHeader->SourceNode, Device->SourceAddress.NodeAddress, 6);
                }

            } else if (Reserved->Identifier == IDENTIFIER_SPX) {

                //
                // Need to update this if we have multiple cards but
                // a zero virtual net.
                //

                if (Device->MultiCardZeroVirtual) {

                    CTEAssert (IncludedHeaderLength >= sizeof(IPX_HEADER));

                    TempHeader = (PIPX_HEADER)(&Header[Device->IncludedHeaderOffset]);

                    *(UNALIGNED ULONG *)TempHeader->SourceNetwork = Binding->LocalAddress.NetworkAddress;
                    RtlCopyMemory (TempHeader->SourceNode, Binding->LocalAddress.NodeAddress, 6);

                }

            } else {

                //
                // For a rip packet it should not be in a binding set,
                // or if it is it should be the master.
                //
#if DBG
                CTEAssert ((!Binding->BindingSetMember) ||
                           (Binding->CurrentSendBinding));
#endif
            }


#if 0
            //
            // There is a header included, we need to adjust it.
            // The header will be at Device->IncludedHeaderOffset.
            //

            if (LocalTarget->MacAddress[0] & Adapter->MacInfo.BroadcastMask) {
                HeaderSizeRequired = Adapter->BcMcHeaderSizes[Binding->FrameType];
            } else {
                HeaderSizeRequired = Adapter->DefHeaderSizes[Binding->FrameType];
            }

            if (HeaderSizeRequired != Device->IncludedHeaderOffset) {

                RtlMoveMemory(
                    &Header[HeaderSizeRequired],
                    &Header[Device->IncludedHeaderOffset],
                    IncludedHeaderLength);
            }
#endif
        }
    }


    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
    if (Adapter->State != ADAPTER_STATE_STOPPING) {

       IpxReferenceAdapter1(Adapter,ADAP_REF_SEND); 
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
	
    } else {
       
       IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
       IpxDereferenceAdapter(Adapter);
	    
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
       return NDIS_STATUS_FAILURE;
    }

    switch (Adapter->MacInfo.MediumType) {

    case NdisMedium802_3:

        //
        // [FW] This will allow both LINE_UP and LINE_CONFIG states
        //
        if (!Binding->LineUp) {
            //
            // Bug #17273 return proper error message
            //
            // return STATUS_DEVICE_DOES_NOT_EXIST;    // Make this a separate switch that generally falls through?
			//
			// Derefernce the binding and adapter
			//
			IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
			IpxDereferenceAdapter(Adapter);
			IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND); 
#ifdef  SNMP
            ++IPX_MIB_ENTRY(Device, SysOutDiscards);
#endif  SNMP
            return STATUS_NETWORK_UNREACHABLE;
        }

        if (Adapter->MacInfo.MediumAsync) {

            IPX_HEADER UNALIGNED * IpxHeader;
            PNDIS_BUFFER            IpxNdisBuff;
            UINT                   IpxHeaderLen;

#if 0
            //
            // The header should have been moved here.
            //

            CTEAssert(Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_ETHERNET_II] ==
                            Adapter->DefHeaderSizes[ISN_FRAME_TYPE_ETHERNET_II]);


            IpxHeader = (IPX_HEADER UNALIGNED *)
                    (&Header[Adapter->DefHeaderSizes[ISN_FRAME_TYPE_ETHERNET_II]]);
#endif
            //
            // The Ipx header is always the second ndis buffer in the mdl
            // chain.  Get it and then query the va of the same.
            //
            IpxNdisBuff = NDIS_BUFFER_LINKAGE(HeaderBuffer);
            NdisQueryBufferSafe (IpxNdisBuff, (PVOID *)&IpxHeader, &IpxHeaderLen, HighPagePriority);

	    if (IpxHeader == NULL) {
	       return NDIS_STATUS_FAILURE; 
	    }
//            IpxHeader = (IPX_HEADER UNALIGNED *) (&Header[MAC_HEADER_SIZE]);

            //
            // If this is a type 20 name frame from Netbios and we are
            // on a dialin WAN line, drop it if configured to.
            //
            // The 0x01 bit of DisableDialinNetbios controls
            // internal->WAN packets, which we handle here.
            //
            //

            //
            // SS# 33592: In case of iterative sends, the IncludedHeaderLength is not set properly
            // since we dont keep track of the length that came in the first time (we track the PacketLength
            // however). The included length field is used here for checking for NB_NAME_FRAMES, but elsewhere
            // used only to distinguish between whether RIP or NB/SPX sent the packet (IncludedHeaderLen ==0 for RIP)
            // The ideal solution here is to do way with this field altogether, but for the beta we will just use the
            // PacketLength field for comparison here since we are assured that this will be equal to the InclHeaderLen
            // for any type 0x14 packet that comes down from NB.
            //
            // Remove the IncludedHeaderLength field.
            //

            //
            // [FW] do this only if the forwarder is not bound
            //
            if (!Device->ForwarderBound &&
                (!Binding->DialOutAsync) &&
                (Reserved->Identifier == IDENTIFIER_NB) &&
                // (IncludedHeaderLength == sizeof(IPX_HEADER) + 50) && // 50 == sizeof(NB_NAME_FRAME)
                (PacketLength == sizeof(IPX_HEADER) + 50) && // 50 == sizeof(NB_NAME_FRAME)
                ((Device->DisableDialinNetbios & 0x01) != 0) &&
                (IpxHeader->PacketType == 0x14)) {
				//
				// Derefernce the binding and adapter
				//
				IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
				IpxDereferenceAdapter(Adapter);
				IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND); 
                return STATUS_SUCCESS;
            }


            //
            // We do checks to see if we should reset the inactivity
            // counter. We normally need to check for netbios
            // session alives, packets from rip, packets from
            // sap, and ncp keep alives. In fact sap and ncp
            // packets don't come through here.
            //

            IpxUpdateWanInactivityCounter(
                Binding,
                IpxHeader,
                IncludedHeaderLength,
                Packet,
                PacketLength);


            //
            // In order for loopback to work properly, we need to put the local MAC address for locally destined
            // pkts so NdisWAN can loop them back.
            //
            if (IPX_NODE_EQUAL(LocalTarget->MacAddress, Binding->LocalAddress.NodeAddress)) {
                RtlCopyMemory (Header, Binding->LocalMacAddress.Address, 6);
            } else {
                RtlCopyMemory (Header, Binding->RemoteMacAddress.Address, 6);
            }

        } else {

            RtlCopyMemory (Header, LocalTarget->MacAddress, 6);
        }

        RtlCopyMemory (Header+6, Binding->LocalMacAddress.Address, 6);

        switch (Binding->FrameType) {

        case ISN_FRAME_TYPE_802_2:
            TwoBytes = PacketLength + 3;
            Header[14] = 0xe0;
            Header[15] = 0xe0;
            Header[16] = 0x03;
            HeaderLength = 17;
            break;
        case ISN_FRAME_TYPE_802_3:
            TwoBytes = PacketLength;
            HeaderLength = 14;
            break;
        case ISN_FRAME_TYPE_ETHERNET_II:
            TwoBytes = Adapter->BindSap;
            HeaderLength = 14;
            break;
        case ISN_FRAME_TYPE_SNAP:
            TwoBytes = PacketLength + 8;
            Header[14] = 0xaa;
            Header[15] = 0xaa;
            Header[16] = 0x03;
            Header[17] = 0x00;
            Header[18] = 0x00;
            Header[19] = 0x00;
            *(UNALIGNED USHORT *)(&Header[20]) = Adapter->BindSapNetworkOrder;
            HeaderLength = 22;
            break;
        }

        Header[12] = (UCHAR)(TwoBytes / 256);
        Header[13] = (UCHAR)(TwoBytes % 256);

        //BufferLength = IncludedHeaderLength + HeaderLength;
        BufferLength = HeaderLength;

        //
        // Pad odd-length packets if needed.
        //

        if ((((PacketLength + HeaderLength) & 1) != 0) &&
            (Device->EthernetPadToEven) &&
            (!Adapter->MacInfo.MediumAsync)) {

            PNDIS_BUFFER CurBuffer;
            PIPX_PADDING_BUFFER PaddingBuffer = IpxPaddingBuffer;
            UINT Offset;
            UINT LastBufferLength;

            //
            // Find the tail of the current packet.
            //

            CurBuffer = HeaderBuffer;
            while (NDIS_BUFFER_LINKAGE(CurBuffer) != NULL) {
                CurBuffer = NDIS_BUFFER_LINKAGE(CurBuffer);
            }

            //
            // If the last byte of the last NDIS_BUFFER is not at the end of
            // the page, then we can simply increase the NDIS_BUFFER ByteCount
            // by one.
            // Otherwise, we must use the global padding buffer.
            //

            NdisQueryBufferOffset( CurBuffer, &Offset, &LastBufferLength );

            if ( ((Offset + LastBufferLength) & (PAGE_SIZE - 1)) != 0) {
                if ( CurBuffer == HeaderBuffer ) {
                    BufferLength++;             // Just bump this length
                } else {
                    NdisAdjustBufferLength( CurBuffer, (LastBufferLength + 1) );

                    Reserved->PreviousTail = NULL;
                    Reserved->PaddingBuffer = (PIPX_PADDING_BUFFER)CurBuffer;

		    IPX_DEBUG(TEMP,("IpxSendFrame:Set PaddingBuffer for %p\n", Packet)); 
                }

            } else {

                CTEAssert (NDIS_BUFFER_LINKAGE(PaddingBuffer->NdisBuffer) == NULL);

                Reserved->PreviousTail = CurBuffer;
                NDIS_BUFFER_LINKAGE (CurBuffer) = PaddingBuffer->NdisBuffer;
                Reserved->PaddingBuffer = PaddingBuffer;
                IPX_DEBUG(TEMP,("IpxSendFrame:Set PaddingBuffer for %p\n", Packet)); 

            }

            if (TwoBytes != Adapter->BindSap) {
                CTEAssert(TwoBytes & 1);
                TwoBytes += 1;
                Header[12] = (UCHAR)(TwoBytes / 256);
                Header[13] = (UCHAR)(TwoBytes % 256);
            }

#if DBG
            ++IpxPadCount;
#endif
        }

        break;

    case NdisMedium802_5:

        if (Reserved->Identifier >= IDENTIFIER_IPX) {

            DestinationType = Reserved->DestinationType;
            SourceRoutingIdentifier = IDENTIFIER_IPX;

        } else {

            if (LocalTarget->MacAddress[0] & 0x80) {
                if (*(UNALIGNED ULONG *)(&LocalTarget->MacAddress[2]) != 0xffffffff) {
                    DestinationType = DESTINATION_MCAST;
                } else {
                    DestinationType = DESTINATION_BCAST;
                }
            } else {
                DestinationType = DESTINATION_DEF;
            }
            SourceRoutingIdentifier = Reserved->Identifier;

        }

        if (DestinationType == DESTINATION_DEF) {

            MacLookupSourceRouting(
                SourceRoutingIdentifier,
                Binding,
                LocalTarget->MacAddress,
                SourceRoutingBuffer,
                &SourceRoutingLength);

            if (SourceRoutingLength != 0) {

//                PUCHAR IpxHeader = Header + Binding->DefHeaderSize;
                  PUCHAR IpxHeader = Header + MAC_HEADER_SIZE;

                //
                // Need to slide the header down to accomodate the SR.
                //

                SourceRouting = SourceRoutingBuffer;
//                RtlMoveMemory (IpxHeader+SourceRoutingLength, IpxHeader, IncludedHeaderLength);
            }

        } else {

            //
            // For these packets we assume that the header is in the
            // right place.
            //

            if (!Adapter->SourceRouting) {

                SourceRoutingLength = 0;

            } else {

                if (DestinationType == DESTINATION_BCAST) {

                    if (Binding->AllRouteBroadcast) {
                        SourceRouting = AllRouteSourceRouting;
                    } else {
                        SourceRouting = SingleRouteSourceRouting;
                    }
                    SourceRoutingLength = 2;

                } else {

                    CTEAssert (DestinationType == DESTINATION_MCAST);

                    if (Binding->AllRouteMulticast) {
                        SourceRouting = AllRouteSourceRouting;
                    } else {
                        SourceRouting = SingleRouteSourceRouting;
                    }
                    SourceRoutingLength = 2;

                }
            }

#if 0
            if (SourceRoutingLength != 0) {

               // PUCHAR IpxHeader = Header + Binding->BcMcHeaderSize;
                PUCHAR IpxHeader = Header + MAC_HEADER_SIZE;

                //
                // Need to slide the header down to accomodate the SR.
                //

                RtlMoveMemory (IpxHeader+SourceRoutingLength, IpxHeader, IncludedHeaderLength);
            }
#endif

        }

        Header[0] = TR_PREAMBLE_AC;
        Header[1] = TR_PREAMBLE_FC;
        RtlCopyMemory (Header+2, LocalTarget->MacAddress, 6);
        RtlCopyMemory (Header+8, Binding->LocalMacAddress.Address, 6);

        if (SourceRoutingLength != 0) {
            Header[8] |= TR_SOURCE_ROUTE_FLAG;
            RtlCopyMemory (Header+14, SourceRouting, SourceRoutingLength);
        }

        Header += (14 + SourceRoutingLength);

        switch (Binding->FrameType) {
        case ISN_FRAME_TYPE_802_2:
        case ISN_FRAME_TYPE_802_3:
        case ISN_FRAME_TYPE_ETHERNET_II:
            Header[0] = 0xe0;
            Header[1] = 0xe0;
            Header[2] = 0x03;
            HeaderLength = 17;
            break;
        case ISN_FRAME_TYPE_SNAP:
            Header[0] = 0xaa;
            Header[1] = 0xaa;
            Header[2] = 0x03;
            Header[3] = 0x00;
            Header[4] = 0x00;
            Header[5] = 0x00;
            *(UNALIGNED USHORT *)(&Header[6]) = Adapter->BindSapNetworkOrder;
            HeaderLength = 22;
            break;
        }

//        BufferLength = IncludedHeaderLength + HeaderLength + SourceRoutingLength;
          BufferLength = HeaderLength + SourceRoutingLength;

        break;

    case NdisMediumFddi:

        Header[0] = FDDI_HEADER_BYTE;
        RtlCopyMemory (Header+1, LocalTarget->MacAddress, 6);
        RtlCopyMemory (Header+7, Binding->LocalMacAddress.Address, 6);

        switch (Binding->FrameType) {
        case ISN_FRAME_TYPE_802_3:
            HeaderLength = 13;
            break;
        case ISN_FRAME_TYPE_802_2:
        case ISN_FRAME_TYPE_ETHERNET_II:
            Header[13] = 0xe0;
            Header[14] = 0xe0;
            Header[15] = 0x03;
            HeaderLength = 16;
            break;
        case ISN_FRAME_TYPE_SNAP:
            Header[13] = 0xaa;
            Header[14] = 0xaa;
            Header[15] = 0x03;
            Header[16] = 0x00;
            Header[17] = 0x00;
            Header[18] = 0x00;
            *(UNALIGNED USHORT *)(&Header[19]) = Adapter->BindSapNetworkOrder;
            HeaderLength = 21;
            break;
        }

//        BufferLength = IncludedHeaderLength + HeaderLength;
        BufferLength = HeaderLength;

        break;

    case NdisMediumArcnet878_2:

        //
        // Convert broadcast address to 0 (the arcnet broadcast).
        //

        Header[0] = Binding->LocalMacAddress.Address[5];
        if (LocalTarget->MacAddress[5] == 0xff) {
            Header[1] = 0x00;
        } else {
            Header[1] = LocalTarget->MacAddress[5];
        }
        Header[2] = ARCNET_PROTOCOL_ID;

        //
        // Binding->FrameType is not used.
        //

        HeaderLength = 3;
//        BufferLength = IncludedHeaderLength + HeaderLength;
        BufferLength = HeaderLength;

        break;

    }

    //
    // Adjust the MAC header's length to the right value
    //
    NdisAdjustBufferLength (HeaderBuffer, BufferLength);
    NdisRecalculatePacketCounts (Packet);

#if 0
    {
       PMDL mdl;
       mdl = (PMDL)NDIS_BUFFER_LINKAGE(HeaderBuffer);
       if (mdl) {

           KdPrint(("**Bytecount %x %x\n",mdl->ByteCount, mdl));
           if ((LONG)mdl->ByteCount < 0) {
               DbgBreakPoint();
           }
       }
    }
#endif

#if DBG
    {
        ULONG SendFlag;
        ULONG Temp;
        PNDIS_BUFFER FirstPacketBuffer;
        PNDIS_BUFFER SecondPacketBuffer;
        IPX_HEADER DumpHeader;
        UCHAR DumpData[14];

        NdisQueryPacket (Packet, NULL, NULL, &FirstPacketBuffer, NULL);
        SecondPacketBuffer = NDIS_BUFFER_LINKAGE(FirstPacketBuffer);
        TdiCopyMdlToBuffer(SecondPacketBuffer, 0, &DumpHeader, 0, sizeof(IPX_HEADER), &Temp);
        if (Reserved->Identifier == IDENTIFIER_NB) {
            SendFlag = IPX_PACKET_LOG_SEND_NB;
        } else if (Reserved->Identifier == IDENTIFIER_SPX) {
            SendFlag = IPX_PACKET_LOG_SEND_SPX;
        } else if (Reserved->Identifier == IDENTIFIER_RIP) {
            SendFlag = IPX_PACKET_LOG_SEND_RIP;
        } else {
            if (DumpHeader.SourceSocket == IpxPacketLogSocket) {
                SendFlag = IPX_PACKET_LOG_SEND_SOCKET | IPX_PACKET_LOG_SEND_OTHER;
            } else {
                SendFlag = IPX_PACKET_LOG_SEND_OTHER;
            }
        }

#if 0
        if (PACKET_LOG(SendFlag)) {

            TdiCopyMdlToBuffer(SecondPacketBuffer, sizeof(IPX_HEADER), &DumpData, 0, 14, &Temp);

            IpxLogPacket(
                TRUE,
                LocalTarget->MacAddress,
                Binding->LocalMacAddress.Address,
                (USHORT)PacketLength,
                &DumpHeader,
                DumpData);

        }
#endif
    }
#endif

    ++Device->Statistics.PacketsSent;


    NdisSend(
       &Status,
       Adapter->NdisBindingHandle,
       Packet);
    
    IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND); 

    if (Status != STATUS_PENDING) {

       IPX_DEBUG(TEMP,("Status is not pending (%ld). Reserved (%p)\n",Status,Reserved)); 

       if (Reserved->PaddingBuffer) {

  	   IPX_DEBUG(TEMP,("Padding buffer is not null. \n")); 

           //
           // Remove padding if it was done.
           //

            if ( Reserved->PreviousTail ) {
                NDIS_BUFFER_LINKAGE (Reserved->PreviousTail) = (PNDIS_BUFFER)NULL;
            } else {
                PNDIS_BUFFER LastBuffer = (PNDIS_BUFFER)Reserved->PaddingBuffer;
                UINT LastBufferLength;

                NdisQueryBuffer( LastBuffer, NULL, &LastBufferLength );
                NdisAdjustBufferLength( LastBuffer, (LastBufferLength - 1) );
#if DBG
                    if ((Reserved->Identifier == IDENTIFIER_RIP) &&
                        (LastBufferLength == 1500)) {
                        DbgPrint("Packet: %lx\n", Packet);
                        DbgBreakPoint();
                    }
#endif DBG
            }

            Reserved->PaddingBuffer = NULL;
            IPX_DEBUG(TEMP,("IpxSendFrame:Cleared PaddingBuffer for %p\n", Packet)); 

            if (Reserved->Identifier < IDENTIFIER_IPX) {
                NdisRecalculatePacketCounts (Packet);
            }
    	}

		//
		// If this was an NB/SPX packet, and there was an
		// iterative send going on, then call the SendComplete
		// handler.
		//
		if ((Reserved->Identifier == IDENTIFIER_NB ||
			 Reserved->Identifier == IDENTIFIER_SPX) &&
			(Reserved->CurrentNicId)) {

			IpxSendComplete(
				(NDIS_HANDLE)Binding->Adapter,
				Packet,
				Status);
		
			Status = STATUS_PENDING;
		}
	}

    //
	// Derefernce the binding and adapter
	//
	IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
	IpxDereferenceAdapter(Adapter);

    return Status;

}   /* IpxSendFrame */


NDIS_STATUS
IpxSendFrame802_3802_3(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    )


/*++

Routine Description:

    This routine constructs a MAC header in a packet and submits
    it to the appropriate NDIS driver.

    It is assumed that the first buffer in the packet contains
    an IPX header at an offset based on the media type. This
    IPX header is moved around if needed.

    THIS FUNCTION ONLY CONSTRUCT NDISMEDIUM802_3 FRAMES IN
    THE ISN_FRAME_TYPE_802_3 FORMAT.

Arguments:

    Adapter - The adapter on which we are sending.

    LocalTarget - The local target of the send.

    Packet - The NDIS packet.

    PacketLength - The length of the packet, starting at the IPX header.

    IncludedHeaderLength - The length of the header included in the
        first buffer that needs to be moved if it does not wind up
        MacHeaderOffset bytes into the packet.

	//
	// Remove the IncludedHeaderLength parameter from here
	//
Return Value:

    None.

--*/

{
    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PUCHAR Header;
    NDIS_STATUS Status;
    LONG HeaderLength;

    IPX_DEFINE_LOCK_HANDLE(LockHandle)

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
    if (Adapter->State != ADAPTER_STATE_STOPPING) {

       IpxReferenceAdapter1(Adapter,ADAP_REF_SEND); 
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
    
    } else {
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
       return NDIS_STATUS_FAILURE;
    }

       Header = Reserved->Header;

#if  BACK_FILL
	BACK_FILL_HEADER(Header, Reserved, 14, Packet);
	IPX_DEBUG(SEND,("Backfill request 802_3802_3!! %x %x %x\n", Packet, Reserved, Reserved->HeaderBuffer));
#endif

    RtlCopyMemory (Header, LocalTarget->MacAddress, 6);
    RtlCopyMemory (Header+6, Adapter->LocalMacAddress.Address, 6);

    //
    // Pad odd-length packets if needed.
    //

    if (((PacketLength & 1) != 0) &&
        (IpxDevice->EthernetPadToEven)) {

        PNDIS_BUFFER CurBuffer;
        PIPX_PADDING_BUFFER PaddingBuffer = IpxPaddingBuffer;
        UINT Offset;
        UINT LastBufferLength;

        //
        // Find the tail of the current packet.
        //

        CurBuffer = Reserved->HeaderBuffer;
        while (NDIS_BUFFER_LINKAGE(CurBuffer) != NULL) {
            CurBuffer = NDIS_BUFFER_LINKAGE(CurBuffer);
        }

        //
        // If the last byte of the last NDIS_BUFFER is not at the end of
        // the page, then we can simply increase the NDIS_BUFFER ByteCount
        // by one.
        // Otherwise, we must use the global padding buffer.
        //

        NdisQueryBufferOffset( CurBuffer, &Offset, &LastBufferLength );

        if ( ((Offset + LastBufferLength) & (PAGE_SIZE - 1)) != 0) {
#if BACK_FILL
            if (0) {

#else
            if ( CurBuffer == Reserved->HeaderBuffer ) {
                IncludedHeaderLength++;             // Just bump this length
#endif
            } else {
                NdisAdjustBufferLength( CurBuffer, (LastBufferLength + 1) );

                Reserved->PreviousTail = NULL;
                Reserved->PaddingBuffer = (PIPX_PADDING_BUFFER)CurBuffer;
            }

        } else {

            CTEAssert (NDIS_BUFFER_LINKAGE(PaddingBuffer->NdisBuffer) == NULL);

            Reserved->PreviousTail = CurBuffer;
            NDIS_BUFFER_LINKAGE (CurBuffer) = PaddingBuffer->NdisBuffer;
            Reserved->PaddingBuffer = PaddingBuffer;

        }

        ++PacketLength;
#if DBG
        ++IpxPadCount;
#endif

    }

    Header[12] = (UCHAR)(PacketLength / 256);
    Header[13] = (UCHAR)(PacketLength % 256);

    //NdisAdjustBufferLength (Reserved->HeaderBuffer, IncludedHeaderLength + 14);
#if BACK_FILL
	BACK_FILL_ADJUST_BUFFER_LENGTH(Reserved, 14);
#else
    NdisAdjustBufferLength (Reserved->HeaderBuffer, 14);
#endif

    NdisRecalculatePacketCounts (Packet);
    
    NdisSend(
       &Status,
       Adapter->NdisBindingHandle,
       Packet);

    IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND); 
    
    return Status;

}   /* IpxSendFrame802_3802_3 */


NDIS_STATUS
IpxSendFrame802_3802_2(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    )

/*++

Routine Description:

    This routine constructs a MAC header in a packet and submits
    it to the appropriate NDIS driver.

    It is assumed that the first buffer in the packet contains
    an IPX header at an offset based on the media type. This
    IPX header is moved around if needed.

    THIS FUNCTION ONLY CONSTRUCT NDISMEDIUM802_3 FRAMES IN
    THE ISN_FRAME_TYPE_802_2 FORMAT.

Arguments:

    Adapter - The adapter on which we are sending.

    LocalTarget - The local target of the send.

    Packet - The NDIS packet.

    PacketLength - The length of the packet, starting at the IPX header.

    IncludedHeaderLength - The length of the header included in the
        first buffer that needs to be moved if it does not wind up
        MacHeaderOffset bytes into the packet.

Return Value:

    None.

--*/

{
    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PUCHAR Header;
    ULONG TwoBytes;
    NDIS_STATUS Status;

    IPX_DEFINE_LOCK_HANDLE(LockHandle)

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
    if (Adapter->State != ADAPTER_STATE_STOPPING) {

       IpxReferenceAdapter1(Adapter,ADAP_REF_SEND); 
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
    
    } else {
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
       return NDIS_STATUS_FAILURE;
    }

    Header = Reserved->Header;

#if  BACK_FILL
	BACK_FILL_HEADER(Header, Reserved, 17, Packet);
  	IPX_DEBUG(SEND, ("Backfill request 802_3802_3!! %x %x %x\n", Packet, Reserved, Reserved->HeaderBuffer));
   	IPX_DEBUG(SEND, ("packet=%x, usermdl %x\n",Packet,Reserved->HeaderBuffer));
#endif

    RtlCopyMemory (Header, LocalTarget->MacAddress, 6);
    RtlCopyMemory (Header+6, Adapter->LocalMacAddress.Address, 6);

    TwoBytes = PacketLength + 3;
    Header[14] = 0xe0;
    Header[15] = 0xe0;
    Header[16] = 0x03;

    //
    // Pad odd-length packets if needed.
    //

    if (((PacketLength & 1) == 0) &&
        (IpxDevice->EthernetPadToEven)) {

        PNDIS_BUFFER CurBuffer;
        PIPX_PADDING_BUFFER PaddingBuffer = IpxPaddingBuffer;
        UINT    Offset;
        UINT LastBufferLength;

        //
        // Find the tail of the current packet.
        //

        CurBuffer = Reserved->HeaderBuffer;
        while (NDIS_BUFFER_LINKAGE(CurBuffer) != NULL) {
            CurBuffer = NDIS_BUFFER_LINKAGE(CurBuffer);
        }

        //
        // If the last byte of the last NDIS_BUFFER is not at the end of
        // the page, then we can simply increase the NDIS_BUFFER ByteCount
        // by one.
        // Otherwise, we must use the global padding buffer.
        //

        NdisQueryBufferOffset( CurBuffer, &Offset, &LastBufferLength );

        if ( ((Offset + LastBufferLength) & (PAGE_SIZE - 1)) != 0 ) {
#if BACK_FILL
            if (0) {
#else
            if ( CurBuffer == Reserved->HeaderBuffer ) {

                IncludedHeaderLength++;             // Just bump this length
#endif
            } else {
                NdisAdjustBufferLength( CurBuffer, (LastBufferLength + 1) );

                Reserved->PreviousTail = NULL;
                Reserved->PaddingBuffer = (PIPX_PADDING_BUFFER)CurBuffer;
		IPX_DEBUG(TEMP,("IpxSendFrame802_3802_2:Set PaddingBuffer for %p\n", Packet)); 
		
            }

        } else {

            CTEAssert (NDIS_BUFFER_LINKAGE(PaddingBuffer->NdisBuffer) == NULL);

            Reserved->PreviousTail = CurBuffer;
            NDIS_BUFFER_LINKAGE (CurBuffer) = PaddingBuffer->NdisBuffer;
            Reserved->PaddingBuffer = PaddingBuffer;
	    IPX_DEBUG(TEMP,("IpxSendFrame802_3802_:Set PaddingBuffer for %p\n", Packet)); 
	    

        }

        ++TwoBytes;
#if DBG
        ++IpxPadCount;
#endif

    }

    Header[12] = (UCHAR)(TwoBytes / 256);
    Header[13] = (UCHAR)(TwoBytes % 256);

//    NdisAdjustBufferLength (Reserved->HeaderBuffer, IncludedHeaderLength + 17);

#if BACK_FILL
	BACK_FILL_ADJUST_BUFFER_LENGTH(Reserved, 17);
#else
    NdisAdjustBufferLength (Reserved->HeaderBuffer, 17);
#endif

    NdisRecalculatePacketCounts (Packet);


    NdisSend(
            &Status,
            Adapter->NdisBindingHandle,
            Packet);
    
    IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND); 
    
    return Status;

}   /* IpxSendFrame802_3802_2 */


NDIS_STATUS
IpxSendFrame802_3EthernetII(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    )

/*++

Routine Description:

    This routine constructs a MAC header in a packet and submits
    it to the appropriate NDIS driver.

    It is assumed that the first buffer in the packet contains
    an IPX header at an offset based on the media type. This
    IPX header is moved around if needed.

    THIS FUNCTION ONLY CONSTRUCT NDISMEDIUM802_3 FRAMES IN
    THE ISN_FRAME_TYPE_ETHERNET_II FORMAT.

Arguments:

    Adapter - The adapter on which we are sending.

    LocalTarget - The local target of the send.

    Packet - The NDIS packet.

    PacketLength - The length of the packet, starting at the IPX header.

    IncludedHeaderLength - The length of the header included in the
        first buffer that needs to be moved if it does not wind up
        MacHeaderOffset bytes into the packet.

Return Value:

    None.

--*/

{
    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PUCHAR Header;
    NDIS_STATUS Status;

    IPX_DEFINE_LOCK_HANDLE(LockHandle)

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
    if (Adapter->State != ADAPTER_STATE_STOPPING) {

       IpxReferenceAdapter1(Adapter,ADAP_REF_SEND); 
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
    
    } else {
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
       return NDIS_STATUS_FAILURE;
    }

    Header = Reserved->Header;

#if BACK_FILL
	BACK_FILL_HEADER(Header, Reserved, 14, Packet);
#endif BACK_FILL

    RtlCopyMemory (Header, LocalTarget->MacAddress, 6);
    RtlCopyMemory (Header+6, Adapter->LocalMacAddress.Address, 6);

    *(UNALIGNED USHORT *)(&Header[12]) = Adapter->BindSapNetworkOrder;

    //
    // Pad odd-length packets if needed.
    //

    if (((PacketLength & 1) != 0) &&
        (IpxDevice->EthernetPadToEven)) {

        PNDIS_BUFFER CurBuffer;
        PIPX_PADDING_BUFFER PaddingBuffer = IpxPaddingBuffer;
        UINT Offset;
        UINT LastBufferLength;

        //
        // Find the tail of the current packet.
        //

        CurBuffer = Reserved->HeaderBuffer;
        while (NDIS_BUFFER_LINKAGE(CurBuffer) != NULL) {
            CurBuffer = NDIS_BUFFER_LINKAGE(CurBuffer);
        }

        //
        // If the last byte of the last NDIS_BUFFER is not at the end of
        // the page, then we can simply increase the NDIS_BUFFER ByteCount
        // by one.
        // Otherwise, we must use the global padding buffer.
        //

        NdisQueryBufferOffset( CurBuffer, &Offset, &LastBufferLength );

        if ( ((Offset + LastBufferLength) & (PAGE_SIZE - 1)) != 0) {

#if BACK_FILL
            if (0) {

#else
            if ( CurBuffer == Reserved->HeaderBuffer ) {
                IncludedHeaderLength++;             // Just bump this length
#endif
            } else {
                NdisAdjustBufferLength( CurBuffer, (LastBufferLength + 1) );

                Reserved->PreviousTail = NULL;
                Reserved->PaddingBuffer = (PIPX_PADDING_BUFFER)CurBuffer;
            }

        } else {

            CTEAssert (NDIS_BUFFER_LINKAGE(PaddingBuffer->NdisBuffer) == NULL);

            Reserved->PreviousTail = CurBuffer;
            NDIS_BUFFER_LINKAGE (CurBuffer) = PaddingBuffer->NdisBuffer;
            Reserved->PaddingBuffer = PaddingBuffer;

        }

#if DBG
        ++IpxPadCount;
#endif

    }

  //  NdisAdjustBufferLength (Reserved->HeaderBuffer, IncludedHeaderLength + 14);

#if BACK_FILL
	BACK_FILL_ADJUST_BUFFER_LENGTH(Reserved, 14);
#else
    NdisAdjustBufferLength (Reserved->HeaderBuffer, 14);
#endif
    NdisRecalculatePacketCounts (Packet);


    NdisSend(
       &Status,
       Adapter->NdisBindingHandle,
       Packet);

    IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND); 


    return Status;

}   /* IpxSendFrame802_3EthernetII */


NDIS_STATUS
IpxSendFrame802_3Snap(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    )

/*++

Routine Description:

    This routine constructs a MAC header in a packet and submits
    it to the appropriate NDIS driver.

    It is assumed that the first buffer in the packet contains
    an IPX header at an offset based on the media type. This
    IPX header is moved around if needed.

    THIS FUNCTION ONLY CONSTRUCT NDISMEDIUM802_3 FRAMES IN
    THE ISN_FRAME_TYPE_SNAP FORMAT.

Arguments:

    Adapter - The adapter on which we are sending.

    LocalTarget - The local target of the send.

    Packet - The NDIS packet.

    PacketLength - The length of the packet, starting at the IPX header.

    IncludedHeaderLength - The length of the header included in the
        first buffer that needs to be moved if it does not wind up
        MacHeaderOffset bytes into the packet.

Return Value:

    None.

--*/

{
    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PUCHAR Header;
    ULONG TwoBytes;
    NDIS_STATUS Status;

    IPX_DEFINE_LOCK_HANDLE(LockHandle)

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
    if (Adapter->State != ADAPTER_STATE_STOPPING) {

       IpxReferenceAdapter1(Adapter,ADAP_REF_SEND); 
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
    
    } else {
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
       return NDIS_STATUS_FAILURE;
    }

    Header = Reserved->Header;

#if BACK_FILL
	BACK_FILL_HEADER(Header, Reserved, 22, Packet);
#endif BACK_FILL

	RtlCopyMemory (Header, LocalTarget->MacAddress, 6);
    RtlCopyMemory (Header+6, Adapter->LocalMacAddress.Address, 6);

    TwoBytes = PacketLength + 8;
    Header[14] = 0xaa;
    Header[15] = 0xaa;
    Header[16] = 0x03;
    Header[17] = 0x00;
    Header[18] = 0x00;
    Header[19] = 0x00;
    *(UNALIGNED USHORT *)(&Header[20]) = Adapter->BindSapNetworkOrder;

    //
    // Pad odd-length packets if needed.
    //

    if (((PacketLength & 1) == 0) &&
        (IpxDevice->EthernetPadToEven)) {

        PNDIS_BUFFER CurBuffer;
        PIPX_PADDING_BUFFER PaddingBuffer = IpxPaddingBuffer;
        UINT  Offset;
        UINT LastBufferLength;

        //
        // Find the tail of the current packet.
        //

        CurBuffer = Reserved->HeaderBuffer;
        while (NDIS_BUFFER_LINKAGE(CurBuffer) != NULL) {
            CurBuffer = NDIS_BUFFER_LINKAGE(CurBuffer);
        }

        //
        // If the last byte of the last NDIS_BUFFER is not at the end of
        // the page, then we can simply increase the NDIS_BUFFER ByteCount
        // by one.
        // Otherwise, we must use the global padding buffer.
        //

        NdisQueryBufferOffset( CurBuffer, &Offset, &LastBufferLength );

        if ( ((Offset + LastBufferLength) & (PAGE_SIZE  - 1)) != 0) {

#if BACK_FILL
            if (0) {

#else
            if ( CurBuffer == Reserved->HeaderBuffer ) {
                IncludedHeaderLength++;             // Just bump this length
#endif
            } else {
                NdisAdjustBufferLength( CurBuffer, (LastBufferLength + 1) );

                Reserved->PreviousTail = NULL;
                Reserved->PaddingBuffer = (PIPX_PADDING_BUFFER)CurBuffer;
            }

        } else {

            CTEAssert (NDIS_BUFFER_LINKAGE(PaddingBuffer->NdisBuffer) == NULL);

            Reserved->PreviousTail = CurBuffer;
            NDIS_BUFFER_LINKAGE (CurBuffer) = PaddingBuffer->NdisBuffer;
            Reserved->PaddingBuffer = PaddingBuffer;

        }

        ++TwoBytes;
#if DBG
        ++IpxPadCount;
#endif

    }

    Header[12] = (UCHAR)(TwoBytes / 256);
    Header[13] = (UCHAR)(TwoBytes % 256);

  //  NdisAdjustBufferLength (Reserved->HeaderBuffer, IncludedHeaderLength + 22);
#if BACK_FILL
	BACK_FILL_ADJUST_BUFFER_LENGTH(Reserved, 22);
#else
    NdisAdjustBufferLength (Reserved->HeaderBuffer, 22);
#endif

    NdisRecalculatePacketCounts (Packet);
    

    NdisSend(
       &Status,
       Adapter->NdisBindingHandle,
       Packet);

    IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND); 

    return Status;

}   /* IpxSendFrame802_3Snap */


NDIS_STATUS
IpxSendFrame802_5802_2(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    )

/*++

Routine Description:

    This routine constructs a MAC header in a packet and submits
    it to the appropriate NDIS driver.

    It is assumed that the first buffer in the packet contains
    an IPX header at an offset based on the media type. This
    IPX header is moved around if needed.

    THIS FUNCTION ONLY CONSTRUCT NDISMEDIUM802_5 FRAMES IN
    THE ISN_FRAME_TYPE_802_2 FORMAT.

Arguments:

    Adapter - The adapter on which we are sending.

    LocalTarget - The local target of the send.

    Packet - The NDIS packet.

    PacketLength - The length of the packet, starting at the IPX header.

    IncludedHeaderLength - The length of the header included in the
        first buffer that needs to be moved if it does not wind up
        MacHeaderOffset bytes into the packet.

Return Value:

    None.

--*/

{
    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PBINDING Binding = Adapter->Bindings[ISN_FRAME_TYPE_802_2];
    PUCHAR Header;
    ULONG HeaderLength;
    UCHAR SourceRoutingBuffer[18];
    PUCHAR SourceRouting;
    ULONG SourceRoutingLength;
    NDIS_STATUS Status;
    ULONG BufferLength;
    UCHAR DestinationType;

    IPX_DEFINE_LOCK_HANDLE(LockHandle)

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
    if (Adapter->State != ADAPTER_STATE_STOPPING) {

       IpxReferenceAdapter1(Adapter,ADAP_REF_SEND); 
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
    
    } else {
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
       return NDIS_STATUS_FAILURE;
    }

    Header = Reserved->Header;

#if BACK_FILL
	BACK_FILL_HEADER(Header, Reserved, 17, Packet);
#endif BACK_FILL

	DestinationType = Reserved->DestinationType;

    if (DestinationType == DESTINATION_DEF) {

        MacLookupSourceRouting(
            Reserved->Identifier,
            Binding,
            LocalTarget->MacAddress,
            SourceRoutingBuffer,
            &SourceRoutingLength);

        if (SourceRoutingLength != 0) {

            //PUCHAR IpxHeader = Header + Binding->DefHeaderSize;
            PUCHAR IpxHeader = Header + MAC_HEADER_SIZE;

            //
            // Need to slide the header down to accomodate the SR.
            //

            SourceRouting = SourceRoutingBuffer;
//            RtlMoveMemory (IpxHeader+SourceRoutingLength, IpxHeader, IncludedHeaderLength);
        }

    } else {

        //
        // For these packets we assume that the header is in the
        // right place.
        //

        if (!Adapter->SourceRouting) {

            SourceRoutingLength = 0;

        } else {

            if (DestinationType == DESTINATION_BCAST) {

                if (Binding->AllRouteBroadcast) {
                    SourceRouting = AllRouteSourceRouting;
                } else {
                    SourceRouting = SingleRouteSourceRouting;
                }
                SourceRoutingLength = 2;

            } else {

                CTEAssert (DestinationType == DESTINATION_MCAST);

                if (Binding->AllRouteMulticast) {
                    SourceRouting = AllRouteSourceRouting;
                } else {
                    SourceRouting = SingleRouteSourceRouting;
                }
                SourceRoutingLength = 2;

            }
        }

#if 0
        if (SourceRoutingLength != 0) {

            PUCHAR IpxHeader = Header + Binding->BcMcHeaderSize;

            //
            // Need to slide the header down to accomodate the SR.
            //

            RtlMoveMemory (IpxHeader+SourceRoutingLength, IpxHeader, IncludedHeaderLength);
        }
#endif
    }

    Header[0] = TR_PREAMBLE_AC;
    Header[1] = TR_PREAMBLE_FC;
    RtlCopyMemory (Header+2, LocalTarget->MacAddress, 6);
    RtlCopyMemory (Header+8, Adapter->LocalMacAddress.Address, 6);

    if (SourceRoutingLength != 0) {
        Header[8] |= TR_SOURCE_ROUTE_FLAG;
        RtlCopyMemory (Header+14, SourceRouting, SourceRoutingLength);
    }

    Header += (14 + SourceRoutingLength);

    Header[0] = 0xe0;
    Header[1] = 0xe0;
    Header[2] = 0x03;
    HeaderLength = 17;

    //BufferLength = IncludedHeaderLength + HeaderLength + SourceRoutingLength;
    BufferLength = HeaderLength + SourceRoutingLength;

#if BACK_FILL
	BACK_FILL_ADJUST_BUFFER_LENGTH(Reserved, BufferLength);
#else
    NdisAdjustBufferLength (Reserved->HeaderBuffer, BufferLength);
#endif

    NdisRecalculatePacketCounts (Packet);

    NdisSend(
       &Status,
       Adapter->NdisBindingHandle,
       Packet);

    IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND); 

    return Status;

}   /* IpxSendFrame802_5802_2 */


NDIS_STATUS
IpxSendFrame802_5Snap(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    )

/*++

Routine Description:

    This routine constructs a MAC header in a packet and submits
    it to the appropriate NDIS driver.

    It is assumed that the first buffer in the packet contains
    an IPX header at an offset based on the media type. This
    IPX header is moved around if needed.

    THIS FUNCTION ONLY CONSTRUCT NDISMEDIUM802_5 FRAMES IN
    THE ISN_FRAME_TYPE_SNAP FORMAT.

Arguments:

    Adapter - The adapter on which we are sending.

    LocalTarget - The local target of the send.

    Packet - The NDIS packet.

    PacketLength - The length of the packet, starting at the IPX header.

    IncludedHeaderLength - The length of the header included in the
        first buffer that needs to be moved if it does not wind up
        MacHeaderOffset bytes into the packet.

Return Value:

    None.

--*/

{
    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PBINDING Binding = Adapter->Bindings[ISN_FRAME_TYPE_SNAP];
    PUCHAR Header;
    ULONG HeaderLength;
    UCHAR SourceRoutingBuffer[18];
    PUCHAR SourceRouting;
    ULONG SourceRoutingLength;
    NDIS_STATUS Status;
    ULONG BufferLength;
    UCHAR DestinationType;

    IPX_DEFINE_LOCK_HANDLE(LockHandle)

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
    if (Adapter->State != ADAPTER_STATE_STOPPING) {

       IpxReferenceAdapter1(Adapter,ADAP_REF_SEND); 
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
    
    } else {
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
       return NDIS_STATUS_FAILURE;
    }

    Header = Reserved->Header;

#if BACK_FILL
	BACK_FILL_HEADER(Header, Reserved, 22, Packet);
#endif BACK_FILL

    DestinationType = Reserved->DestinationType;

    if (DestinationType == DESTINATION_DEF) {

        MacLookupSourceRouting(
            Reserved->Identifier,
            Binding,
            LocalTarget->MacAddress,
            SourceRoutingBuffer,
            &SourceRoutingLength);

        if (SourceRoutingLength != 0) {

//            PUCHAR IpxHeader = Header + Binding->DefHeaderSize;

            //
            // Need to slide the header down to accomodate the SR.
            //

            SourceRouting = SourceRoutingBuffer;
 //           RtlMoveMemory (IpxHeader+SourceRoutingLength, IpxHeader, IncludedHeaderLength);
        }

    } else {

        //
        // For these packets we assume that the header is in the
        // right place.
        //

        if (!Adapter->SourceRouting) {

            SourceRoutingLength = 0;

        } else {

            if (DestinationType == DESTINATION_BCAST) {

                if (Binding->AllRouteBroadcast) {
                    SourceRouting = AllRouteSourceRouting;
                } else {
                    SourceRouting = SingleRouteSourceRouting;
                }
                SourceRoutingLength = 2;

            } else {

                CTEAssert (DestinationType == DESTINATION_MCAST);

                if (Binding->AllRouteMulticast) {
                    SourceRouting = AllRouteSourceRouting;
                } else {
                    SourceRouting = SingleRouteSourceRouting;
                }
                SourceRoutingLength = 2;

            }

            if (SourceRoutingLength != 0) {

  //              PUCHAR IpxHeader = Header + Binding->BcMcHeaderSize;

                //
                // Need to slide the header down to accomodate the SR.
                //

   //             RtlMoveMemory (IpxHeader+SourceRoutingLength, IpxHeader, IncludedHeaderLength);
            }
        }
    }

    Header[0] = TR_PREAMBLE_AC;
    Header[1] = TR_PREAMBLE_FC;
    RtlCopyMemory (Header+2, LocalTarget->MacAddress, 6);
    RtlCopyMemory (Header+8, Adapter->LocalMacAddress.Address, 6);

    if (SourceRoutingLength != 0) {
        Header[8] |= TR_SOURCE_ROUTE_FLAG;
        RtlCopyMemory (Header+14, SourceRouting, SourceRoutingLength);
    }

    Header += (14 + SourceRoutingLength);

    Header[0] = 0xaa;
    Header[1] = 0xaa;
    Header[2] = 0x03;
    Header[3] = 0x00;
    Header[4] = 0x00;
    Header[5] = 0x00;
    *(UNALIGNED USHORT *)(&Header[6]) = Adapter->BindSapNetworkOrder;
    HeaderLength = 22;

    //BufferLength = IncludedHeaderLength + HeaderLength + SourceRoutingLength;
    BufferLength =  HeaderLength + SourceRoutingLength;

#if BACK_FILL
	BACK_FILL_ADJUST_BUFFER_LENGTH(Reserved, BufferLength);
#else
    NdisAdjustBufferLength (Reserved->HeaderBuffer, BufferLength);
#endif
    NdisRecalculatePacketCounts (Packet);

    NdisSend(
       &Status,
       Adapter->NdisBindingHandle,
       Packet);

    IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND); 

    return Status;

}   /* IpxSendFrame802_5Snap */


NDIS_STATUS
IpxSendFrameFddi802_3(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    )

/*++

Routine Description:

    This routine constructs a MAC header in a packet and submits
    it to the appropriate NDIS driver.

    It is assumed that the first buffer in the packet contains
    an IPX header at an offset based on the media type. This
    IPX header is moved around if needed.

    THIS FUNCTION ONLY CONSTRUCT NDISMEDIUMFDDI FRAMES IN
    THE ISN_FRAME_TYPE_802_3 FORMAT.

Arguments:

    Adapter - The adapter on which we are sending.

    LocalTarget - The local target of the send.

    Packet - The NDIS packet.

    PacketLength - The length of the packet, starting at the IPX header.

    IncludedHeaderLength - The length of the header included in the
        first buffer that needs to be moved if it does not wind up
        MacHeaderOffset bytes into the packet.

Return Value:

    None.

--*/

{
    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PUCHAR Header;
    NDIS_STATUS Status;

    IPX_DEFINE_LOCK_HANDLE(LockHandle)

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
    if (Adapter->State != ADAPTER_STATE_STOPPING) {

       IpxReferenceAdapter1(Adapter,ADAP_REF_SEND); 
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
    
    } else {
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
       return NDIS_STATUS_FAILURE;
    }

    Header = Reserved->Header;

#if BACK_FILL
	BACK_FILL_HEADER(Header, Reserved, 13, Packet);
#endif BACK_FILL

    Header[0] = FDDI_HEADER_BYTE;
    RtlCopyMemory (Header+1, LocalTarget->MacAddress, 6);
    RtlCopyMemory (Header+7, Adapter->LocalMacAddress.Address, 6);

//    NdisAdjustBufferLength (Reserved->HeaderBuffer, IncludedHeaderLength + 13);

#if BACK_FILL
	BACK_FILL_ADJUST_BUFFER_LENGTH(Reserved, 13);
#else
    NdisAdjustBufferLength (Reserved->HeaderBuffer, 13);
#endif

    NdisRecalculatePacketCounts (Packet);


    NdisSend(
       &Status,
       Adapter->NdisBindingHandle,
       Packet);

    IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND); 

    return Status;

}   /* IpxSendFrameFddi802_3 */


NDIS_STATUS
IpxSendFrameFddi802_2(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    )

/*++

Routine Description:

    This routine constructs a MAC header in a packet and submits
    it to the appropriate NDIS driver.

    It is assumed that the first buffer in the packet contains
    an IPX header at an offset based on the media type. This
    IPX header is moved around if needed.

    THIS FUNCTION ONLY CONSTRUCT NDISMEDIUMFDDI FRAMES IN
    THE ISN_FRAME_TYPE_802_2 FORMAT.

Arguments:

    Adapter - The adapter on which we are sending.

    LocalTarget - The local target of the send.

    Packet - The NDIS packet.

    PacketLength - The length of the packet, starting at the IPX header.

    IncludedHeaderLength - The length of the header included in the
        first buffer that needs to be moved if it does not wind up
        MacHeaderOffset bytes into the packet.

Return Value:

    None.

--*/

{
    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PUCHAR Header;
    NDIS_STATUS Status;
    IPX_DEFINE_LOCK_HANDLE(LockHandle)

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
    if (Adapter->State != ADAPTER_STATE_STOPPING) {

       IpxReferenceAdapter1(Adapter,ADAP_REF_SEND); 
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
    
    } else {
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
       return NDIS_STATUS_FAILURE;
    }

    Header = Reserved->Header;

#if BACK_FILL
	BACK_FILL_HEADER(Header, Reserved, 16, Packet);
#endif BACK_FILL

    Header[0] = FDDI_HEADER_BYTE;
    RtlCopyMemory (Header+1, LocalTarget->MacAddress, 6);
    RtlCopyMemory (Header+7, Adapter->LocalMacAddress.Address, 6);

    Header[13] = 0xe0;
    Header[14] = 0xe0;
    Header[15] = 0x03;

//    NdisAdjustBufferLength (Reserved->HeaderBuffer, IncludedHeaderLength + 16);

#if BACK_FILL
	BACK_FILL_ADJUST_BUFFER_LENGTH(Reserved, 16);
#else
    NdisAdjustBufferLength (Reserved->HeaderBuffer, 16);
#endif

    NdisRecalculatePacketCounts (Packet);

    NdisSend(
       &Status,
       Adapter->NdisBindingHandle,
       Packet);

    IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND); 

    return Status;

}   /* IpxSendFrameFddi802_2 */


NDIS_STATUS
IpxSendFrameFddiSnap(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    )

/*++

Routine Description:

    This routine constructs a MAC header in a packet and submits
    it to the appropriate NDIS driver.

    It is assumed that the first buffer in the packet contains
    an IPX header at an offset based on the media type. This
    IPX header is moved around if needed.

    THIS FUNCTION ONLY CONSTRUCT NDISMEDIUMFDDI FRAMES IN
    THE ISN_FRAME_TYPE_SNAP FORMAT.

Arguments:

    Adapter - The adapter on which we are sending.

    LocalTarget - The local target of the send.

    Packet - The NDIS packet.

    PacketLength - The length of the packet, starting at the IPX header.

    IncludedHeaderLength - The length of the header included in the
        first buffer that needs to be moved if it does not wind up
        MacHeaderOffset bytes into the packet.

Return Value:

    None.

--*/

{
    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PUCHAR Header;
    NDIS_STATUS Status;

    IPX_DEFINE_LOCK_HANDLE(LockHandle)

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
    if (Adapter->State != ADAPTER_STATE_STOPPING) {

       IpxReferenceAdapter1(Adapter,ADAP_REF_SEND); 
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
    
    } else {
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
       return NDIS_STATUS_FAILURE;
    }

    Header = Reserved->Header;

#if BACK_FILL
	BACK_FILL_HEADER(Header, Reserved, 21, Packet);
#endif BACK_FILL

	Header[0] = FDDI_HEADER_BYTE;
    RtlCopyMemory (Header+1, LocalTarget->MacAddress, 6);
    RtlCopyMemory (Header+7, Adapter->LocalMacAddress.Address, 6);

    Header[13] = 0xaa;
    Header[14] = 0xaa;
    Header[15] = 0x03;
    Header[16] = 0x00;
    Header[17] = 0x00;
    Header[18] = 0x00;
    *(UNALIGNED USHORT *)(&Header[19]) = Adapter->BindSapNetworkOrder;

//    NdisAdjustBufferLength (Reserved->HeaderBuffer, IncludedHeaderLength + 21);

#if BACK_FILL
	BACK_FILL_ADJUST_BUFFER_LENGTH(Reserved, 21);
#else
    NdisAdjustBufferLength (Reserved->HeaderBuffer, 21);
#endif

    NdisRecalculatePacketCounts (Packet);


    NdisSend(
       &Status,
       Adapter->NdisBindingHandle,
       Packet);
    
    IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND);

    return Status;

}   /* IpxSendFrameFddiSnap */


NDIS_STATUS
IpxSendFrameArcnet878_2(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    )

/*++

Routine Description:

    This routine constructs a MAC header in a packet and submits
    it to the appropriate NDIS driver.

    It is assumed that the first buffer in the packet contains
    an IPX header at an offset based on the media type. This
    IPX header is moved around if needed.

    THIS FUNCTION ONLY CONSTRUCT NDISMEDIUMARCNET878_2 FRAMES IN
    THE ISN_FRAME_TYPE_802_2 FORMAT.

Arguments:

    Adapter - The adapter on which we are sending.

    LocalTarget - The local target of the send.

    Packet - The NDIS packet.

    PacketLength - The length of the packet, starting at the IPX header.

    IncludedHeaderLength - The length of the header included in the
        first buffer that needs to be moved if it does not wind up
        MacHeaderOffset bytes into the packet.

Return Value:

    None.

--*/

{
    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PUCHAR Header;
    NDIS_STATUS Status;

    IPX_DEFINE_LOCK_HANDLE(LockHandle)

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
    if (Adapter->State != ADAPTER_STATE_STOPPING) {

       IpxReferenceAdapter1(Adapter,ADAP_REF_SEND); 
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
    
    } else {
       IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
       return NDIS_STATUS_FAILURE;
    }
    
    Header = Reserved->Header;

#if BACK_FILL
	BACK_FILL_HEADER(Header, Reserved, 3, Packet);
#endif BACK_FILL
    //
    // Convert broadcast address to 0 (the arcnet broadcast).
    //

    Header[0] = Adapter->LocalMacAddress.Address[5];
    if (LocalTarget->MacAddress[5] == 0xff) {
        Header[1] = 0x00;
    } else {
        Header[1] = LocalTarget->MacAddress[5];
    }
    Header[2] = ARCNET_PROTOCOL_ID;

//    NdisAdjustBufferLength (Reserved->HeaderBuffer, IncludedHeaderLength + 3);

#if BACK_FILL
	BACK_FILL_ADJUST_BUFFER_LENGTH(Reserved, 3);
#else
    NdisAdjustBufferLength (Reserved->HeaderBuffer, 3);
#endif

    NdisRecalculatePacketCounts (Packet);

    NdisSend(
       &Status,
       Adapter->NdisBindingHandle,
       Packet);

    IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND); 

    return Status;

}   /* IpxSendFrameFddiArcnet878_2 */


NDIS_STATUS
IpxSendFrameWanEthernetII(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    )

/*++

Routine Description:

    This routine constructs a MAC header in a packet and submits
    it to the appropriate NDIS driver.

    It is assumed that the first buffer in the packet contains
    an IPX header at an offset based on the media type. This
    IPX header is moved around if needed.

    THIS FUNCTION ONLY CONSTRUCT NDISMEDIUMWAN FRAMES IN
    THE ISN_FRAME_TYPE_ETHERNET_II FORMAT.

Arguments:

    Adapter - The adapter on which we are sending.

    LocalTarget - The local target of the send.

    Packet - The NDIS packet.

    PacketLength - The length of the packet, starting at the IPX header.

    IncludedHeaderLength - The length of the header included in the
        first buffer that needs to be moved if it does not wind up
        MacHeaderOffset bytes into the packet.

Return Value:

    None.

--*/

{
    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PUCHAR Header;
    NDIS_STATUS Status;

    PBINDING Binding;

    IPX_DEFINE_LOCK_HANDLE(LockHandle1)
	IPX_GET_LOCK1(&IpxDevice->BindAccessLock, &LockHandle1);
	Binding = NIC_ID_TO_BINDING(IpxDevice, NIC_FROM_LOCAL_TARGET(LocalTarget));
	IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);

	IPX_FREE_LOCK1(&IpxDevice->BindAccessLock, LockHandle1);


    //
    // [FW] This will allow both LINE_UP and LINE_CONFIG states
    //
    if (Binding->LineUp) {

       IPX_DEFINE_LOCK_HANDLE(LockHandle)

       IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
       if (Adapter->State != ADAPTER_STATE_STOPPING) {

	  IpxReferenceAdapter1(Adapter,ADAP_REF_SEND); 
	  IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
       
       } else {
	  IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
          IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
	  return NDIS_STATUS_FAILURE;
       }

        Header = Reserved->Header;

#if BACK_FILL
		BACK_FILL_HEADER(Header, Reserved, 14, Packet);

        //
        // Call UpdateWanInactivity only if this is not a backfill packet, since
        // SMB server does not do KeepAlives. In case, of backfilled packets, reset
        // the counter regardless.
        //
        if (!Reserved->BackFill) {
            IpxUpdateWanInactivityCounter(
                Binding,
                (IPX_HEADER UNALIGNED *)(Header + IpxDevice->IncludedHeaderOffset),
                IncludedHeaderLength,
                Packet,
                PacketLength);
        } else {
            Binding->WanInactivityCounter = 0;
        }

#else
        //
        // We do checks to see if we should reset the inactivity
        // counter. We normally need to check for netbios
        // session alives, packets from rip, packets from
        // sap, and ncp keep alives. In fact netbios packets
        // and rip packets don't come through here.
        //

        IpxUpdateWanInactivityCounter(
            Binding,
            (IPX_HEADER UNALIGNED *)(Header + IpxDevice->IncludedHeaderOffset),
            IncludedHeaderLength,
            Packet,
            PacketLength);
#endif BACK_FILL

        //
        // In order for loopback to work properly, we need to put the local MAC address for locally destined
        // pkts so NdisWAN can loop them back.
        //
        if (IPX_NODE_EQUAL(LocalTarget->MacAddress, Binding->LocalAddress.NodeAddress)) {
            RtlCopyMemory (Header, Binding->LocalMacAddress.Address, 6);
        } else {
            RtlCopyMemory (Header, Binding->RemoteMacAddress.Address, 6);
        }
        // RtlCopyMemory (Header, Binding->RemoteMacAddress.Address, 6);
        RtlCopyMemory (Header+6, Binding->LocalMacAddress.Address, 6);

        *(UNALIGNED USHORT *)(&Header[12]) = Adapter->BindSapNetworkOrder;

//        NdisAdjustBufferLength (Reserved->HeaderBuffer, IncludedHeaderLength + 14);

#if BACK_FILL
		BACK_FILL_ADJUST_BUFFER_LENGTH(Reserved, 14);
#else
		NdisAdjustBufferLength (Reserved->HeaderBuffer, 14);
#endif
		NdisRecalculatePacketCounts (Packet);


		NdisSend(
                    &Status,
                    Adapter->NdisBindingHandle,
                    Packet);

                IpxDereferenceAdapter1(Adapter,ADAP_REF_SEND); 

		IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
        return Status;

    } else {

        //
        // Bug #17273 return proper error message
        //

        // return STATUS_DEVICE_DOES_NOT_EXIST;

		IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
        return STATUS_NETWORK_UNREACHABLE;
    }

}   /* IpxSendFrameWanEthernetII */


VOID
MacUpdateSourceRouting(
    IN ULONG Database,
    IN PADAPTER Adapter,
    IN PUCHAR MacHeader,
    IN ULONG MacHeaderLength
    )

/*++

Routine Description:

    This routine is called when a valid IPX frame is received from
    a remote. It gives the source routing database a change to
    update itself to include information about this remote.

Arguments:

    Database - The "database" to use (IPX, SPX, NB, RIP).

    Adapter - The adapter the frame was received on.

    MacHeader - The MAC header of the received frame.

    MacHeaderLength - The length of the MAC header.

Return Value:

    None.

--*/

{
    PSOURCE_ROUTE Current;
    ULONG Hash;
    LONG Result;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)

    CTEAssert (((LONG)Database >= 0) && (Database <= 3));

    //
    // If this adapter is configured for no source routing, don't
    // need to do anything.
    //

    if (!Adapter->SourceRouting) {
        return;
    }

    //
    // See if this source routing is relevant. We don't
    // care about two-byte source routing since that
    // indicates it did not cross a router. If there
    // is nothing in the database, then don't add
    // this if it is minimal (if it is not, we need
    // to add it so we will find it on sending).
    //

    if ((Adapter->SourceRoutingEmpty[Database]) &&
        (MacHeaderLength <= 16)) {
        return;
    }

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);

    //
    // Try to find this address in the database.
    //

    Hash = MacSourceRoutingHash (MacHeader+8);
    Current = Adapter->SourceRoutingHeads[Database][Hash];

    while (Current != (PSOURCE_ROUTE)NULL) {

        IPX_NODE_COMPARE (MacHeader+8, Current->MacAddress, &Result);

        if (Result == 0) {

            //
            // We found routing for this node. If the data is the
            // same as what we have, update the time since used to
            // prevent aging.
            //

            if ((Current->SourceRoutingLength == MacHeaderLength-14) &&
                (RtlEqualMemory (Current->SourceRouting, MacHeader+14, MacHeaderLength-14))) {

                Current->TimeSinceUsed = 0;
            }
            IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
            return;

        } else {

            Current = Current->Next;
        }

    }

    //
    // Not found, insert a new node at the front of the list.
    //

    Current = (PSOURCE_ROUTE)IpxAllocateMemory (SOURCE_ROUTE_SIZE(MacHeaderLength-14), MEMORY_SOURCE_ROUTE, "SourceRouting");

    if (Current == (PSOURCE_ROUTE)NULL) {
        IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
        return;
    }

    Current->Next = Adapter->SourceRoutingHeads[Database][Hash];
    Adapter->SourceRoutingHeads[Database][Hash] = Current;

    Adapter->SourceRoutingEmpty[Database] = FALSE;

    RtlCopyMemory (Current->MacAddress, MacHeader+8, 6);
    Current->MacAddress[0] &= 0x7f;
    Current->SourceRoutingLength = (UCHAR)(MacHeaderLength - 14);
    RtlCopyMemory (Current->SourceRouting, MacHeader+14, MacHeaderLength - 14);

    Current->TimeSinceUsed = 0;

    IPX_DEBUG (SOURCE_ROUTE, ("Adding source route %lx for %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
                  Current, Current->MacAddress[0], Current->MacAddress[1],
                  Current->MacAddress[2], Current->MacAddress[3],
                  Current->MacAddress[4], Current->MacAddress[5]));

    IPX_FREE_LOCK (&Adapter->Lock, LockHandle);

}   /* MacUpdateSourceRouting */


VOID
MacLookupSourceRouting(
    IN ULONG Database,
    IN PBINDING Binding,
    IN UCHAR MacAddress[6],
    IN OUT UCHAR SourceRouting[18],
    OUT PULONG SourceRoutingLength
    )

/*++

Routine Description:

    This routine looks up a target address in the adapter's
    source routing database to see if source routing information
    needs to be added to the frame.

Arguments:

    Database - The "database" to use (IPX, SPX, NB, RIP).

    Binding - The binding the frame is being sent on.

    MacAddress - The destination address.

    SourceRouting - Buffer to hold the returned source routing info.

    SourceRoutingLength - The returned source routing length.

Return Value:

    None.

--*/

{
    PSOURCE_ROUTE Current;
    PADAPTER Adapter = Binding->Adapter;
    ULONG Hash;
    LONG Result;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)


    //
    // If this adapter is configured for no source routing, don't
    // insert any.
    //

    if (!Adapter->SourceRouting) {
        *SourceRoutingLength = 0;
        return;
    }

    //
    // See if source routing has not been important so far.
    //
    // This is wrong because we may be sending a directed
    // packet to somebody on the other side of a router, without
    // ever having received a routed packet. We fix this for the
    // moment by only setting SourceRoutingEmpty for netbios
    // which uses broadcasts for discovery.
    //

    if (Adapter->SourceRoutingEmpty[Database]) {
        *SourceRoutingLength = 0;
        return;
    }

    Hash = MacSourceRoutingHash (MacAddress);

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);
    Current = Adapter->SourceRoutingHeads[Database][Hash];

    while (Current != (PSOURCE_ROUTE)NULL) {

        IPX_NODE_COMPARE (MacAddress, Current->MacAddress, &Result);

        if (Result == 0) {

            //
            // We found routing for this node.
            //

            if (Current->SourceRoutingLength <= 2) {
                *SourceRoutingLength = 0;
            } else {
                RtlCopyMemory (SourceRouting, Current->SourceRouting, Current->SourceRoutingLength);
                SourceRouting[0] = (SourceRouting[0] & TR_LENGTH_MASK);
                SourceRouting[1] = (SourceRouting[1] ^ TR_DIRECTION_MASK);
                *SourceRoutingLength = Current->SourceRoutingLength;
            }
            IPX_FREE_LOCK (&Adapter->Lock, LockHandle);
            return;

        } else {

            Current = Current->Next;

        }

    }

    IPX_FREE_LOCK (&Adapter->Lock, LockHandle);

    //
    // We did not find this node, use the default.
    //

    if (Binding->AllRouteDirected) {
        RtlCopyMemory (SourceRouting, AllRouteSourceRouting, 2);
    } else {
        RtlCopyMemory (SourceRouting, SingleRouteSourceRouting, 2);
    }
    *SourceRoutingLength = 2;

}   /* MacLookupSourceRouting */


VOID
MacSourceRoutingTimeout(
    CTEEvent * Event,
    PVOID Context
    )

/*++

Routine Description:

    This routine is called when the source routing timer expires.
    It is called every minute.

Arguments:

    Event - The event used to queue the timer.

    Context - The context, which is the device pointer.

Return Value:

    None.

--*/

{
    PDEVICE Device = (PDEVICE)Context;
    PADAPTER Adapter;
    PBINDING Binding;
    PSOURCE_ROUTE Current, OldCurrent, Previous;
    UINT i, j, k;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)



    IPX_DEFINE_LOCK_HANDLE(LockHandle1)
	//
	// Get a lock on the access path.
	//
	IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
    ++Device->SourceRoutingTime;
    {
    ULONG   Index = MIN (Device->MaxBindings, Device->ValidBindings);

    for (i = FIRST_REAL_BINDING; i <= Index; i++) {

		if (Binding = NIC_ID_TO_BINDING(Device, i)) {

            Adapter = Binding->Adapter;

            if (Adapter->LastSourceRoutingTime != Device->SourceRoutingTime) {

                //
                // We need to scan this adapter's source routing
                // tree for stale routes. To simplify the scan we
                // only delete entries that have at least one
                // child that is NULL.
                //

                Adapter->LastSourceRoutingTime = Device->SourceRoutingTime;

                for (j = 0; j < IDENTIFIER_TOTAL; j++) {

                    for (k = 0; k < SOURCE_ROUTE_HASH_SIZE; k++) {

                        if (Adapter->SourceRoutingHeads[j][k] == (PSOURCE_ROUTE)NULL) {
                            continue;
                        }

                        IPX_GET_LOCK (&Adapter->Lock, &LockHandle);

                        Current = Adapter->SourceRoutingHeads[j][k];
                        Previous = (PSOURCE_ROUTE)NULL;

                        while (Current != (PSOURCE_ROUTE)NULL) {

                            ++Current->TimeSinceUsed;

                            if (Current->TimeSinceUsed >= Device->SourceRouteUsageTime) {

                                //
                                // A stale entry needs to be aged.
                                //

                                if (Previous) {
                                    Previous->Next = Current->Next;
                                } else {
                                    Adapter->SourceRoutingHeads[j][k] = Current->Next;
                                }

                                OldCurrent = Current;
                                Current = Current->Next;

                                IPX_DEBUG (SOURCE_ROUTE, ("Aging out source-route entry %lx\n", OldCurrent));
                                IpxFreeMemory (OldCurrent, SOURCE_ROUTE_SIZE (OldCurrent->SourceRoutingLength), MEMORY_SOURCE_ROUTE, "SourceRouting");

                            } else {

                                Previous = Current;
                                Current = Current->Next;
                            }

                        }

                        IPX_FREE_LOCK (&Adapter->Lock, LockHandle);

                    }   // for loop through the database's hash list

                }   // for loop through the adapter's four databases

            }   // if adapter's database needs to be checked

        }   // if binding exists

    }   // for loop through every binding
    }

	IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

    //
    // Now restart the timer unless we should not (which means
    // we are being unloaded).
    //

    if (Device->SourceRoutingUsed) {

        CTEStartTimer(
            &Device->SourceRoutingTimer,
            60000,                     // one minute timeout
            MacSourceRoutingTimeout,
            (PVOID)Device);

    } else {

        IpxDereferenceDevice (Device, DREF_SR_TIMER);
    }

}   /* MacSourceRoutingTimeout */


VOID
MacSourceRoutingRemove(
    IN PBINDING Binding,
    IN UCHAR MacAddress[6]
    )

/*++

Routine Description:

    This routine is called by the IPX action handler when an
    IPXROUTE use has specified that source routing for a given
    MAC address should be removed.

Arguments:

    Binding - The binding to modify.

    MacAddress - The MAC address to remove.

Return Value:

    None.

--*/

{

    PSOURCE_ROUTE Current, Previous;
    PADAPTER Adapter = Binding->Adapter;
    ULONG Hash;
    ULONG Database;
    LONG Result;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)

    //
    // Scan through to find the matching entry in each database.
    //

    Hash = MacSourceRoutingHash (MacAddress);

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);

    for (Database = 0; Database < IDENTIFIER_TOTAL; Database++) {

        Current = Adapter->SourceRoutingHeads[Database][Hash];
        Previous = NULL;

        while (Current != (PSOURCE_ROUTE)NULL) {

            IPX_NODE_COMPARE (MacAddress, Current->MacAddress, &Result);

            if (Result == 0) {

                if (Previous) {
                    Previous->Next = Current->Next;
                } else {
                    Adapter->SourceRoutingHeads[Database][Hash] = Current->Next;
                }

                IPX_DEBUG (SOURCE_ROUTE, ("IPXROUTE freeing source-route entry %lx\n", Current));
                IpxFreeMemory (Current, SOURCE_ROUTE_SIZE (Current->SourceRoutingLength), MEMORY_SOURCE_ROUTE, "SourceRouting");

                break;

            } else {

                Previous = Current;
                Current = Current->Next;

            }

        }

    }

    IPX_FREE_LOCK (&Adapter->Lock, LockHandle);

}   /* MacSourceRoutingRemove */


VOID
MacSourceRoutingClear(
    IN PBINDING Binding
    )

/*++

Routine Description:

    This routine is called by the IPX action handler when an
    IPXROUTE use has specified that source routing for a given
    binding should be cleared entirely.

Arguments:

    Binding - The binding to be cleared.

    MacAddress - The MAC address to remove.

Return Value:

    None.

--*/

{
    PSOURCE_ROUTE Current;
    PADAPTER Adapter = Binding->Adapter;
    ULONG Database, Hash;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)

    //
    // Scan through and remove every entry in the database.
    //

    IPX_GET_LOCK (&Adapter->Lock, &LockHandle);

    for (Database = 0; Database < IDENTIFIER_TOTAL; Database++) {

        for (Hash = 0; Hash < SOURCE_ROUTE_HASH_SIZE; Hash++) {

            while (Adapter->SourceRoutingHeads[Database][Hash]) {

                Current = Adapter->SourceRoutingHeads[Database][Hash];
                Adapter->SourceRoutingHeads[Database][Hash] = Current->Next;

                IpxFreeMemory (Current, SOURCE_ROUTE_SIZE (Current->SourceRoutingLength), MEMORY_SOURCE_ROUTE, "SourceRouting");

            }
        }
    }

    IPX_FREE_LOCK (&Adapter->Lock, LockHandle);

}   /* MacSourceRoutingClear */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\loopback.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    loopback.c

Abstract:

    This module contains the routines to implement loopback

Author:

    Sanjay Anand (SanjayAn) 2/6/96

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Global lock to control access to the Loopback queue
//
DEFINE_LOCK_STRUCTURE(LoopLock)

//
// Head and tail of the Loopback queue
//
PNDIS_PACKET    LoopXmitHead = (PNDIS_PACKET)NULL;
PNDIS_PACKET    LoopXmitTail = (PNDIS_PACKET)NULL;

CTEEvent        LoopXmitEvent;
BOOLEAN         LoopXmitRtnRunning = 0;

//
// MaximumPacket sized buffer to hold the lookahead data.
//
// In PnP this value can change
//
// PUCHAR   LookaheadBuffer=NULL;
#define LOOP_LOOKAHEAD_SIZE   128 + sizeof(IPX_HEADER) + 8 + 34


VOID
IpxDoLoopback(
    IN  CTEEvent    *Event,
    IN  PVOID       Context
    )
/*++

Routine Description:

    Does the actual loopback.

Arguments:

    Event - Pointer to event structure.

    Context - Pointer to ZZ

Return Value:

    None.

--*/
{
    PNDIS_PACKET    Packet;     // Pointer to packet being transmitted
    PNDIS_BUFFER    Buffer;     // Current NDIS buffer being processed.
    ULONG   TotalLength; // Total length of send.
    ULONG   LookaheadLength; // Bytes in lookahead.
    ULONG   Copied;     // Bytes copied so far.
    PUCHAR  CopyPtr;   // Pointer to buffer being copied into.
    PUCHAR  SrcPtr;    // Pointer to buffer being copied from.
    ULONG   SrcLength;  // Length of src buffer.
    BOOLEAN Rcvd = FALSE;
    PIPX_SEND_RESERVED Reserved;
    ULONG   MacSize;
    PNDIS_PACKET    *PacketPtr;
    UCHAR   LookaheadBuffer[LOOP_LOOKAHEAD_SIZE];

	IPX_DEFINE_LOCK_HANDLE(Handle)

    KIRQL   OldIrql;

	CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

	//
	// Raise IRQL so we can acquire locks at DPC level in the receive code.
	// Also to be able to ReceiveIndicate at DPC
    //
    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    IPX_GET_LOCK(&LoopLock, &Handle);

	if (LoopXmitRtnRunning) {
        IPX_FREE_LOCK(&LoopLock, Handle);
        KeLowerIrql(OldIrql);
		return;
	}

	LoopXmitRtnRunning = 1;

    for (;;) {

        //
        // Get the next packet from the list.
        //
        Packet = LoopXmitHead;

        if (Packet != (PNDIS_PACKET)NULL) {
            Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
            LoopXmitHead = (PNDIS_PACKET)(Reserved->PaddingBuffer);
            IPX_FREE_LOCK(&LoopLock, Handle);
        } else {                            // Nothing left to do.
		    LoopXmitRtnRunning = 0;
            IPX_FREE_LOCK(&LoopLock, Handle);
            break;
        }

        //
        // We use the PaddingBuffer section as the next ptr.
        //
        Reserved->PaddingBuffer = NULL;

        IPX_DEBUG(LOOPB, ("Packet: %lx\n", Packet));

        NdisQueryPacket(Packet, NULL, NULL, &Buffer, &TotalLength);

        NdisQueryBuffer(Buffer, NULL, &MacSize);

        IPX_DEBUG(LOOPB, ("Buffer: %lx Totalpktlen: %lx MacSize: %lx\n", Buffer, TotalLength, MacSize));

        LookaheadLength = MIN(LOOP_LOOKAHEAD_SIZE, TotalLength);
        Copied = 0;
        CopyPtr = LookaheadBuffer;
        while (Copied < LookaheadLength) {
            ULONG    ThisCopy;   // Bytes to copy this time.

#ifdef  DBG
            if (!Buffer) {
                DbgBreakPoint();
                IPX_GET_LOCK(&LoopLock, &Handle);
                LoopXmitRtnRunning = 0;
                IPX_FREE_LOCK(&LoopLock, Handle);
                KeLowerIrql(OldIrql);
                return;
            }
#endif

            NdisQueryBufferSafe(Buffer, &SrcPtr, &SrcLength, HighPagePriority);

	    if (SrcPtr == NULL) {
	       DbgPrint("IpxDoLoopback: NdisQuerybufferSafe returned null pointer\n"); 
	       IPX_GET_LOCK(&LoopLock, &Handle);
	       LoopXmitRtnRunning = 0;
	       IPX_FREE_LOCK(&LoopLock, Handle);
	       KeLowerIrql(OldIrql);
	       return;
	    }

            ThisCopy = MIN(SrcLength, LookaheadLength - Copied);
            CTEMemCopy(CopyPtr, SrcPtr, ThisCopy);
            Copied += ThisCopy;
            CopyPtr += ThisCopy;
            NdisGetNextBuffer(Buffer, &Buffer);
        }

        Rcvd = TRUE;

#ifdef  BACK_FILL
        //
        // For Backfill packets, the MAC header is not yet set up; for others, it is the size
        // of the first MDL (17).
        //
        if ((Reserved->Identifier == IDENTIFIER_IPX) &&
            (Reserved->BackFill)) {
            MacSize = 0;
        }
#endif
        IpxReceiveIndication(   (NDIS_HANDLE)IPX_LOOPBACK_COOKIE,    // BindingContext
                                Packet,                 // ReceiveContext
                                (MacSize) ? LookaheadBuffer : NULL,        // HeaderBuffer
                                MacSize,        // HeaderBufferSize
                                LookaheadBuffer+MacSize,        // LookAheadBuffer
                                LookaheadLength-MacSize,        // LookAheadBufferSize
                                TotalLength-MacSize);           // PacketSize

        IpxSendComplete(Context, Packet, NDIS_STATUS_SUCCESS);

        //
		// Give other threads a chance to run.
		//
        KeLowerIrql(OldIrql);
        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
        IPX_GET_LOCK(&LoopLock, &Handle);
    }

    if (Rcvd) {
        IpxReceiveComplete(Context);
	}

    KeLowerIrql(OldIrql);
}


VOID
IpxInitLoopback()
/*++

Routine Description:

    Initializes various loopback structures.

Arguments:

Return Value:

    None.

--*/
{
    CTEInitLock(&LoopLock);
    CTEInitEvent(&LoopXmitEvent, IpxDoLoopback);
    return;
}


VOID
IpxLoopbackEnque(
    IN PNDIS_PACKET Packet,
    IN PVOID    Context
    )

/*++

Routine Description:

    Enqueues a packet to the loopbackQ

Arguments:

    Packet - The packet to be enqueued.

    Context -  Pointer to the adapter corresp to the first binding.

Return Value:

    None.

--*/
{
    PIPX_SEND_RESERVED  Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
	IPX_DEFINE_LOCK_HANDLE(LockHandle)

    //
    // We use the PaddingBuffer as the next ptr.
    //
    Reserved->PaddingBuffer = NULL;

    IPX_GET_LOCK(&LoopLock, &LockHandle);

    //
    // LoopbackQ is empty
    //
    if (LoopXmitHead == (PNDIS_PACKET)NULL) {
        LoopXmitHead = Packet;
    } else {
        Reserved = (PIPX_SEND_RESERVED)(LoopXmitTail->ProtocolReserved);
        (PNDIS_PACKET)(Reserved->PaddingBuffer) = Packet;
    }
    LoopXmitTail = Packet;

    IPX_DEBUG(LOOPB, ("Enqued packet: %lx, Reserved: %lx\n", Packet, Reserved));

    //
    // If this routine is not already running, schedule it as a work item.
    //
    if (!LoopXmitRtnRunning) {
        CTEScheduleEvent(&LoopXmitEvent, Context);
    }

    IPX_FREE_LOCK(&LoopLock, LockHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\ipxprocs.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ipxprocs.h

Abstract:

    This module contains definitions specific to the
    IPX module of the ISN transport.

Author:

    Adam Barr (adamba) 2-September-1993

Environment:

    Kernel mode

Revision History:

   Sanjay Anand (SanjayAn) 3-Oct-1995
   Changes to support transfer of buffer ownership to transports - tagged [CH]
 	1. Added new functions - IpxReceivePacket, IpxReceiveIndicationCommon

   Sanjay Anand (SanjayAn) 27-Oct-1995
   Changes to support Plug and Play

--*/


//
// MACROS.
//
//
// Debugging aids
//

//
//  VOID
//  PANIC(
//      IN PSZ Message
//      );
//

#if DBG
#define PANIC(Msg) \
    CTEPrint ((Msg))
#else
#define PANIC(Msg)
#endif


//
// These are define to allow CTEPrints that disappear when
// DBG is 0.
//

#if STEFAN_DBG
// #if DBG
#define IpxPrint0(fmt) DbgPrint(fmt)
#define IpxPrint1(fmt,v0) DbgPrint(fmt,v0)
#define IpxPrint2(fmt,v0,v1) DbgPrint(fmt,v0,v1)
#define IpxPrint3(fmt,v0,v1,v2) DbgPrint(fmt,v0,v1,v2)
#define IpxPrint4(fmt,v0,v1,v2,v3) DbgPrint(fmt,v0,v1,v2,v3)
#define IpxPrint5(fmt,v0,v1,v2,v3,v4) DbgPrint(fmt,v0,v1,v2,v3,v4)
#define IpxPrint6(fmt,v0,v1,v2,v3,v4,v5) DbgPrint(fmt,v0,v1,v2,v3,v4,v5)
#else
#define IpxPrint0(fmt)
#define IpxPrint1(fmt,v0)
#define IpxPrint2(fmt,v0,v1)
#define IpxPrint3(fmt,v0,v1,v2)
#define IpxPrint4(fmt,v0,v1,v2,v3)
#define IpxPrint5(fmt,v0,v1,v2,v3,v4)
#define IpxPrint6(fmt,v0,v1,v2,v3,v4,v5)
#endif


//
// Routines to log packets to a buffer.
//

#if DBG
#define IPX_PACKET_LOG 1
#endif

#ifdef IPX_PACKET_LOG

//
// The size of this is 64 bytes for easy display.
//

typedef struct _IPX_PACKET_LOG_ENTRY {
    UCHAR SendReceive;
    UCHAR TimeStamp[5];                  // low 5 digits of tick count.
    UCHAR DestMac[6];
    UCHAR SrcMac[6];
    UCHAR Length[2];
    IPX_HEADER IpxHeader;
    UCHAR Data[14];
} IPX_PACKET_LOG_ENTRY, *PIPX_PACKET_LOG_ENTRY;

#define IPX_PACKET_LOG_LENGTH 128
extern ULONG IpxPacketLogDebug;
extern USHORT IpxPacketLogSocket;
EXTERNAL_LOCK(IpxPacketLogLock);
extern IPX_PACKET_LOG_ENTRY IpxPacketLog[IPX_PACKET_LOG_LENGTH];
extern PIPX_PACKET_LOG_ENTRY IpxPacketLogLoc;
extern PIPX_PACKET_LOG_ENTRY IpxPacketLogEnd;

//
// Bit fields in IpxPacketLogDebug
//

#define IPX_PACKET_LOG_RCV_RIP      0x0001     // All RIP packets
#define IPX_PACKET_LOG_RCV_SPX      0x0002     // All SPX packets
#define IPX_PACKET_LOG_RCV_NB       0x0004     // All Netbios packets
#define IPX_PACKET_LOG_RCV_OTHER    0x0008     // All TDI client packets
#define IPX_PACKET_LOG_RCV_SOCKET   0x0010     // All packets to IpxPacketLogSocket
#define IPX_PACKET_LOG_RCV_ALL      0x0020     // All packets (even non-IPX)

#define IPX_PACKET_LOG_SEND_RIP     0x0001     // All RIP packets
#define IPX_PACKET_LOG_SEND_SPX     0x0002     // All SPX packets
#define IPX_PACKET_LOG_SEND_NB      0x0004     // All Netbios packets
#define IPX_PACKET_LOG_SEND_OTHER   0x0008     // All TDI client packets
#define IPX_PACKET_LOG_SEND_SOCKET  0x0010     // All packets from IpxPacketLogSocket

VOID
IpxLogPacket(
    IN BOOLEAN Send,
    IN PUCHAR DestMac,
    IN PUCHAR SrcMac,
    IN USHORT Length,
    IN PVOID IpxHeader,
    IN PVOID Data
    );

#define PACKET_LOG(_Bit)   (IpxPacketLogDebug & (_Bit))

#else  // IPX_PACKET_LOG

#define IpxLogPacket(_MacHeader,_Length,_IpxHeader,_Data)
#define PACKET_LOG(_Bit)    0

#endif // IPX_PACKET_LOG

//
// In load-only PnP, references are not needed on adapters. This should be changed
// to actually take the reference post 4.0.
//
// Revisit Post 4.0 - Keep the actual instructions around for ease of activation later.
//
#define IpxReferenceAdapter(_adapter)
    // InterlockedIncrement(&(_adapter)->ReferenceCount)

#define IpxDereferenceAdapter(_adapter)
/*
    if (InterlockedDecrement(&(_adapter)->ReferenceCount) == 0) {\
        IpxCloseNdis(_adapter); \
        IpxDestroyAdapter(_adapter);\
    }\
*/

//
// In load-only PnP case, we dont need the references on bindings. All such references
// have been changed to this macro.
//
#define IpxReferenceBinding1(_Binding, _Type)

#define IpxDereferenceBinding1(_Binding, _Type)

#if DBG

#define IpxReferenceBinding(_Binding, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_Binding)->RefTypes[_Type], \
        1, \
        &IpxGlobalInterlock); \
    IpxRefBinding (_Binding)

#define IpxDereferenceBinding(_Binding, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_Binding)->RefTypes[_Type], \
        (ULONG)-1, \
        &IpxGlobalInterlock); \
    IpxDerefBinding (_Binding)

#define IpxReferenceDevice(_Device, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_Device)->RefTypes[_Type], \
        1, \
        &IpxGlobalInterlock); \
    IpxRefDevice (_Device)

#define IpxDereferenceDevice(_Device, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_Device)->RefTypes[_Type], \
        (ULONG)-1, \
        &IpxGlobalInterlock); \
    CTEAssert ((_Device)->RefTypes[_Type] >= 0); \
    IpxDerefDevice (_Device)

#define IpxReferenceAdapter1(_Adapter, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_Adapter)->RefTypes[_Type], \
        1, \
        &IpxGlobalInterlock); \
    IpxRefAdapter (_Adapter)

#define IpxDereferenceAdapter1(_Adapter, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_Adapter)->RefTypes[_Type], \
        (ULONG)-1, \
        &IpxGlobalInterlock); \
	   ASSERT((_Adapter)->RefTypes[_Type] >= 0); \
    IpxDerefAdapter (_Adapter)

#define IpxReferenceAddress(_Address, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_Address)->RefTypes[_Type], \
        1, \
        &IpxGlobalInterlock); \
    IpxRefAddress (_Address)

#define IpxReferenceAddressLock(_Address, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_Address)->RefTypes[_Type], \
        1, \
        &IpxGlobalInterlock); \
    IpxRefAddressLock (_Address)

#define IpxDereferenceAddress(_Address, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_Address)->RefTypes[_Type], \
        (ULONG)-1, \
        &IpxGlobalInterlock); \
    IpxDerefAddress (_Address)

#define IpxDereferenceAddressSync(_Address, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_Address)->RefTypes[_Type], \
        (ULONG)-1, \
        &IpxGlobalInterlock); \
    IpxDerefAddressSync (_Address)


#define IpxReferenceAddressFile(_AddressFile, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_AddressFile)->RefTypes[_Type], \
        1, \
        &IpxGlobalInterlock); \
    IpxRefAddressFile (_AddressFile)

#define IpxReferenceAddressFileLock(_AddressFile, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_AddressFile)->RefTypes[_Type], \
        1, \
        &IpxGlobalInterlock); \
    IpxRefAddressFileLock (_AddressFile)

#define IpxReferenceAddressFileSync(_AddressFile, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_AddressFile)->RefTypes[_Type], \
        1, \
        &IpxGlobalInterlock); \
    IpxRefAddressFileSync (_AddressFile)

#define IpxDereferenceAddressFile(_AddressFile, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_AddressFile)->RefTypes[_Type], \
        (ULONG)-1, \
        &IpxGlobalInterlock); \
    IpxDerefAddressFile (_AddressFile)

#define IpxDereferenceAddressFileSync(_AddressFile, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_AddressFile)->RefTypes[_Type], \
        (ULONG)-1, \
        &IpxGlobalInterlock); \
    IpxDerefAddressFileSync (_AddressFile)

#define IpxTransferReferenceAddressFile(_AddressFile, _OldType, _NewType) \
    (VOID)IPX_ADD_ULONG ( \
        &(_AddressFile)->RefTypes[_NewType], \
        1, \
        &IpxGlobalInterlock); \
    (VOID)IPX_ADD_ULONG ( \
        &(_AddressFile)->RefTypes[_OldType], \
        (ULONG)-1, \
        &IpxGlobalInterlock);

#define IpxReferenceRt(_Rt, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_Rt)->RefTypes[_Type], \
        1, \
        &IpxGlobalInterlock); \
    IpxRefRt (_Rt)

#define IpxDereferenceRt(_Rt, _Type) \
    (VOID)IPX_ADD_ULONG ( \
        &(_Rt)->RefTypes[_Type], \
        (ULONG)-1, \
        &IpxGlobalInterlock); \
    IpxDerefRt (_Rt)

#else  // DBG

#define IpxReferenceBinding(_Binding, _Type) \
    InterlockedIncrement(&(_Binding)->ReferenceCount)

#define IpxDereferenceBinding(_Binding, _Type) \
    IpxDerefBinding (_Binding)

#define IpxReferenceDevice(_Device, _Type) \
    InterlockedIncrement(&(_Device)->ReferenceCount)

#define IpxDereferenceDevice(_Device, _Type) \
    IpxDerefDevice (_Device)

#define IpxReferenceAdapter1(_Adapter, _Type) \
    InterlockedIncrement(&(_Adapter)->ReferenceCount)

#define IpxDereferenceAdapter1(_Adapter, _Type) \
    IpxDerefAdapter (_Adapter)


#define IpxReferenceAddress(_Address, _Type) \
    InterlockedIncrement(&(_Address)->ReferenceCount)

#define IpxReferenceAddressLock(_Address, _Type) \
    InterlockedIncrement(&(_Address)->ReferenceCount)

#define IpxDereferenceAddress(_Address, _Type) \
    IpxDerefAddress (_Address)

#define IpxDereferenceAddressSync(_Address, _Type) \
    IpxDerefAddressSync (_Address)

#define IpxReferenceAddressFile(_AddressFile, _Type) \
    InterlockedIncrement(&(_AddressFile)->ReferenceCount)

#define IpxReferenceAddressFileLock(_AddressFile, _Type) \
    InterlockedIncrement(&(_AddressFile)->ReferenceCount)

#define IpxReferenceAddressFileSync(_AddressFile, _Type) \
    (VOID)IPX_ADD_ULONG( \
        &(_AddressFile)->ReferenceCount, \
        1, \
        (_AddressFile)->AddressLock)

#define IpxDereferenceAddressFile(_AddressFile, _Type) \
    if (InterlockedDecrement(&(_AddressFile)->ReferenceCount) == 0) { \
        IpxDestroyAddressFile (_AddressFile); \
    }

#define IpxDereferenceAddressFileSync(_AddressFile, _Type) \
    if (InterlockedDecrement(&(_AddressFile)->ReferenceCount) == 0) { \
        IpxDestroyAddressFile (_AddressFile); \
    }

#define IpxTransferReferenceAddressFile(_AddressFile, _OldType, _NewType)

#define IpxReferenceRt(_Rt, _Type) \
    InterlockedIncrement(&(_Rt)->ReferenceCount)

#define IpxDereferenceRt(_Rt, _Type) \
    IpxDerefRt (_Rt)

#endif // DBG



#if DBG

#define IpxAllocateMemory(_BytesNeeded,_Tag,_Description) \
    IpxpAllocateTaggedMemory(_BytesNeeded,_Tag,_Description)

#define IpxFreeMemory(_Memory,_BytesAllocated,_Tag,_Description) \
    IpxpFreeTaggedMemory(_Memory,_BytesAllocated,_Tag,_Description)

#else // DBG

#if TRACK

PVOID
IpxAllocateMemoryTrack(
    IN ULONG BytesNeeded,
    IN ULONG Tag,
    IN ULONG ModLine
    );

VOID
IpxFreeMemoryTrack(
    IN PVOID Memory
    );

#define IpxAllocateMemory(_BytesNeeded,_Tag,_Description) \
    IpxAllocateMemoryTrack(_BytesNeeded,_Tag,MODULE+__LINE__)

#define IpxFreeMemory(_Memory,_BytesAllocated,_Tag,_Description) \
    IpxFreeMemoryTrack(_Memory)

#else

#define IpxAllocateMemory(_BytesNeeded,_Tag,_Description) \
    IpxpAllocateMemory(_BytesNeeded,_Tag,(BOOLEAN)((_Tag) != MEMORY_CONFIG))

#define IpxFreeMemory(_Memory,_BytesAllocated,_Tag,_Description) \
    IpxpFreeMemory(_Memory,_BytesAllocated,(BOOLEAN)((_Tag) != MEMORY_CONFIG))


#endif // TRACK
#endif // DBG


//
// This routine compares two node addresses.
//

#define IPX_NODE_EQUAL(_A,_B) \
    ((*(UNALIGNED ULONG *)((PUCHAR)(_A)) == *(UNALIGNED ULONG *)((PUCHAR)(_B))) && \
     (*(UNALIGNED USHORT *)(((PUCHAR)(_A))+4) == *(UNALIGNED USHORT *)(((PUCHAR)(_B))+4)))

//
// This routine checks if an address is the broadcast address.
//

#define IPX_NODE_BROADCAST(_A) \
    ((*(UNALIGNED ULONG *)((PUCHAR)(_A)) == 0xffffffff) && \
     (*(UNALIGNED USHORT *)(((PUCHAR)(_A))+4) == 0xffff))

//
// This routine does an ordered compare of two node addresses. It
// can handle the first address having the source-routing bit on.
//

#define IPX_NODE_COMPARE(_A,_B,_R) \
    if ((*(_R) = (*(UNALIGNED SHORT *)(((PUCHAR)(_A))+4) - *(UNALIGNED SHORT *)(((PUCHAR)(_B))+4))) == 0) { \
        *(_R) = ((*(UNALIGNED LONG *)((PUCHAR)(_A)) & 0xffffff7f) - *(UNALIGNED LONG *)((PUCHAR)(_B))); \
    }



//
// Routines in action.c
//

NTSTATUS
IpxTdiAction(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

VOID
IpxCancelAction(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
IpxAbortLineChanges(
    IN PVOID ControlChannelContext
    );

VOID
IpxAbortNtfChanges(
    IN PVOID ControlChannelContext
    );

NTSTATUS
IpxIndicateLineUp(
    IN  PDEVICE Device,
    IN  USHORT  NicId,
    IN  ULONG   Network,
    IN  UCHAR   LocalNode[6],
    IN  UCHAR   RemoteNode[6]
    );

//
// Routines in adapter.c
//

VOID
IpxRefBinding(
    IN PBINDING Binding
    );

VOID
IpxDerefBinding(
    IN PBINDING Binding
    );

NTSTATUS
IpxCreateAdapter(
    IN PDEVICE Device,
    IN PUNICODE_STRING AdapterName,
    IN OUT PADAPTER *AdapterPtr
    );

VOID
IpxDestroyAdapter(
    IN PADAPTER Adapter
    );

NTSTATUS
IpxCreateBinding(
    IN PDEVICE Device,
    IN PBINDING_CONFIG ConfigBinding OPTIONAL,
    IN ULONG NetworkNumberIndex,
    IN PWCHAR AdapterName,
    IN OUT PBINDING *BindingPtr
    );

VOID
IpxDestroyBinding(
    IN PBINDING Binding
    );

VOID
IpxAllocateBindingPool(
    IN PDEVICE Device
    );

PSLIST_ENTRY
IpxPopBinding(
    PDEVICE Device
    );

//
// [FW] New functions added for Forwarder support
//
#ifdef SUNDOWN
NTSTATUS
IpxOpenAdapter(
   IN    NIC_HANDLE  AdapterIndex,
   IN    ULONG_PTR FwdAdapterContext,
   OUT   PNIC_HANDLE IpxAdapterContext
   );
#else
NTSTATUS
IpxOpenAdapter(
   IN    NIC_HANDLE  AdapterIndex,
   IN    ULONG FwdAdapterContext,
   OUT   PNIC_HANDLE IpxAdapterContext
   );
#endif



NTSTATUS
IpxCloseAdapter(
   IN NIC_HANDLE  IpxAdapterContext
   );

//
// Routines in address.c
//

TDI_ADDRESS_IPX UNALIGNED *
IpxParseTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress
    );

BOOLEAN
IpxValidateTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress,
    IN ULONG TransportAddressLength
    );

#if DBG

VOID
IpxBuildTdiAddress(
    IN PVOID AddressBuffer,
    IN ULONG Network,
    IN UCHAR Node[6],
    IN USHORT Socket
    );

#else

#define IpxBuildTdiAddress(_AddressBuffer,_Network,_Node,_Socket) { \
    TA_IPX_ADDRESS UNALIGNED * _IpxAddress = (TA_IPX_ADDRESS UNALIGNED *)(_AddressBuffer); \
    _IpxAddress->TAAddressCount = 1; \
    _IpxAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_IPX); \
    _IpxAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX; \
    _IpxAddress->Address[0].Address[0].NetworkAddress = (_Network); \
    _IpxAddress->Address[0].Address[0].Socket = (_Socket); \
    RtlCopyMemory(_IpxAddress->Address[0].Address[0].NodeAddress, (_Node), 6); \
}

#endif

NTSTATUS
IpxOpenAddress(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

NTSTATUS
IpxOpenAddressM(
    IN PDEVICE Device,
    IN PREQUEST Request,
    IN ULONG     Index
    );

USHORT
IpxAssignSocket(
    IN PDEVICE Device
    );

PADDRESS
IpxCreateAddress(
    IN PDEVICE Device,
    IN USHORT Socket
    );

NTSTATUS
IpxVerifyAddressFile(
    IN PADDRESS_FILE AddressFile
    );

VOID
IpxDestroyAddress(
    IN PVOID Parameter
    );

#if DBG

VOID
IpxRefAddress(
    IN PADDRESS Address
    );

VOID
IpxRefAddressLock(
    IN PADDRESS Address
    );

#endif

VOID
IpxDerefAddress(
    IN PADDRESS Address
    );

VOID
IpxDerefAddressSync(
    IN PADDRESS Address
    );

PADDRESS_FILE
IpxCreateAddressFile(
    IN PDEVICE Device
    );

NTSTATUS
IpxDestroyAddressFile(
    IN PADDRESS_FILE AddressFile
    );

#if DBG

VOID
IpxRefAddressFile(
    IN PADDRESS_FILE AddressFile
    );

VOID
IpxRefAddressFileLock(
    IN PADDRESS_FILE AddressFile
    );

VOID
IpxRefAddressFileSync(
    IN PADDRESS_FILE AddressFile
    );

VOID
IpxDerefAddressFile(
    IN PADDRESS_FILE AddressFile
    );

VOID
IpxDerefAddressFileSync(
    IN PADDRESS_FILE AddressFile
    );

#endif

PADDRESS
IpxLookupAddress(
    IN PDEVICE Device,
    IN USHORT Socket
    );

NTSTATUS
IpxStopAddressFile(
    IN PADDRESS_FILE AddressFile
    );

NTSTATUS
IpxCloseAddressFile(
    IN PDEVICE Device,
    IN PREQUEST Request
    );


//
// Routines in device.c
//

VOID
IpxRefDevice(
    IN PDEVICE Device
    );

VOID
IpxDerefDevice(
    IN PDEVICE Device
    );

VOID
IpxRefAdapter(
    IN PADAPTER Adapter
    );

VOID
IpxDerefAdapter(
    IN PADAPTER Adapter
    );

NTSTATUS
IpxCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING DeviceName,
    IN ULONG SegmentCount,
    IN OUT PDEVICE *DevicePtr
    );

VOID
IpxDestroyDevice(
    IN PDEVICE Device
    );


//
// Routines in driver.c
//
VOID
IpxPnPUpdateDevice(
    IN  PDEVICE Device
    );

BOOLEAN
IpxIsAddressLocal(
    IN TDI_ADDRESS_IPX UNALIGNED * SourceAddress
    );

PVOID
IpxpAllocateMemory(
    IN ULONG BytesNeeded,
    IN ULONG Tag,
    IN BOOLEAN ChargeDevice
    );

VOID
IpxpFreeMemory(
    IN PVOID Memory,
    IN ULONG BytesAllocated,
    IN BOOLEAN ChargeDevice
    );

#if DBG

PVOID
IpxpAllocateTaggedMemory(
    IN ULONG BytesNeeded,
    IN ULONG Tag,
    IN PUCHAR Description
    );

VOID
IpxpFreeTaggedMemory(
    IN PVOID Memory,
    IN ULONG BytesAllocated,
    IN ULONG Tag,
    IN PUCHAR Description
    );

#endif

VOID
IpxWriteResourceErrorLog(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS ErrorCode,
    IN ULONG BytesNeeded,
    IN ULONG UniqueErrorValue
    );

VOID
IpxWriteGeneralErrorLog(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PWSTR SecondString,
    IN ULONG DumpDataCount,
    IN ULONG DumpData[]
    );

VOID
IpxWriteOidErrorLog(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS ErrorCode,
    IN NTSTATUS FinalStatus,
    IN PWSTR AdapterString,
    IN ULONG OidValue
    );

ULONG
IpxResolveAutoDetect(
    IN PDEVICE Device,
    IN ULONG ValidBindings,
	IN CTELockHandle	*LockHandle1,
    IN PUNICODE_STRING RegistryPath,
    IN PADAPTER Adapter
    );

VOID
IpxResolveBindingSets(
    IN PDEVICE Device,
    IN ULONG ValidBindings
    );

NTSTATUS
IpxBindToAdapter(
    IN PDEVICE Device,
    IN PBINDING_CONFIG ConfigAdapter,
	IN PADAPTER	*AdapterPtr,
    IN ULONG FrameTypeIndex
    );

NTSTATUS
IpxUnBindFromAdapter(
    IN PBINDING Binding
    );

VOID
IpxPnPUpdateBindingArray(
    IN PDEVICE Device,
    IN PADAPTER	Adapter,
    IN PBINDING_CONFIG  ConfigBinding
    );

VOID
IpxPnPToLoad();

NTSTATUS
IpxPnPReallocateBindingArray(
    IN  PDEVICE     Device,
    IN  ULONG       Size
    );


//
// Routines in event.c
//

NTSTATUS
IpxTdiSetEventHandler(
    IN PREQUEST Request
    );


//
// Routines in ind.c
//

//
// [CH] Added these two functions
//
INT
IpxReceivePacket (
    IN NDIS_HANDLE ProtocolBindingContext,
	IN PNDIS_PACKET Packet
    );

NDIS_STATUS
IpxReceiveIndicationCommon(
    IN NDIS_HANDLE BindingContext,
    IN NDIS_HANDLE ReceiveContext,
    IN PVOID HeaderBuffer,
    IN UINT HeaderBufferSize,
    IN PVOID LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT PacketSize,
	IN PMDL	pMdl,
	IN PINT pTdiClientCount
    );

NDIS_STATUS
IpxReceiveIndication(
    IN NDIS_HANDLE BindingContext,
    IN NDIS_HANDLE ReceiveContext,
    IN PVOID HeaderBuffer,
    IN UINT HeaderBufferSize,
    IN PVOID LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT PacketSize
    );

VOID
IpxReceiveComplete(
    IN NDIS_HANDLE BindingContext
    );

NTSTATUS
IpxUpdateBindingNetwork(
    IN PDEVICE Device,
    IN PBINDING Binding,
    IN ULONG Network
    );

BOOLEAN
IpxNewVirtualNetwork(
    IN  PDEVICE Device,
    IN  BOOLEAN NewVirtualNetwork
	);
//
// Routines in internal.c
//

NTSTATUS
IpxInternalBind(
    IN PDEVICE Device,
    IN PIRP Irp
    );

NTSTATUS
IpxInternalUnbind(
    IN PDEVICE Device,
    IN UINT Identifier
    );

VOID
IpxInternalFindRoute(
    IN PIPX_FIND_ROUTE_REQUEST FindRouteRequest
    );

NTSTATUS
IpxInternalQuery(
    IN ULONG InternalQueryType,
	IN PNIC_HANDLE	NicHandle OPTIONAL,
    IN OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG BufferLengthNeeded OPTIONAL
);

VOID
IpxPnPCompletionHandler(
                       IN PNET_PNP_EVENT NetPnPEvent,
                       IN NTSTATUS Status
                       );

VOID
IpxInternalIncrementWanInactivity(
#ifdef	_PNP_LATER
    IN NIC_HANDLE NicHandle
#else
    IN USHORT NicId
#endif
);

ULONG
IpxInternalQueryWanInactivity(
#ifdef	_PNP_LATER
	IN	NIC_HANDLE	NicHandle
#else
    IN USHORT NicId
#endif
);

VOID
IpxPnPIsnIndicate(
    IN PVOID	Param
);

//
// Routines in ndis.c
//

NTSTATUS
IpxRegisterProtocol(
    IN PNDIS_STRING NameString
    );

VOID
IpxDeregisterProtocol(
    VOID
    );

NTSTATUS
IpxInitializeNdis(
    IN PADAPTER Adapter,
    IN PBINDING_CONFIG ConfigBinding
    );

VOID
IpxAddBroadcast(
    IN PDEVICE Device
    );

VOID
IpxRemoveBroadcast(
    IN PDEVICE Device
    );

VOID
IpxBroadcastOperation(
    IN PVOID Parameter
    );

BOOLEAN
IpxIsAddressLocal(
    IN TDI_ADDRESS_IPX UNALIGNED * SourceAddress
    );

VOID
IpxCloseNdis(
    IN PADAPTER Adapter
    );

VOID
IpxOpenAdapterComplete(
    IN NDIS_HANDLE BindingContext,
    IN NDIS_STATUS NdisStatus,
    IN NDIS_STATUS OpenErrorStatus
    );

VOID
IpxCloseAdapterComplete(
    IN NDIS_HANDLE BindingContext,
    IN NDIS_STATUS NdisStatus
    );

VOID
IpxResetComplete(
    IN NDIS_HANDLE BindingContext,
    IN NDIS_STATUS NdisStatus
    );

VOID
IpxRequestComplete(
    IN NDIS_HANDLE BindingContext,
    IN PNDIS_REQUEST NdisRequest,
    IN NDIS_STATUS NdisStatus
    );

VOID
IpxStatus(
    IN NDIS_HANDLE NdisBindingContext,
    IN NDIS_STATUS NdisStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    );

VOID
IpxStatusComplete(
    IN NDIS_HANDLE NdisBindingContext
    );


VOID
IpxBindAdapter(
	OUT PNDIS_STATUS Status,
	IN	NDIS_HANDLE	 BindContext,
	IN	PNDIS_STRING    DeviceName,
	IN	PVOID		 SystemSpecific1,
	IN	PVOID		 SystemSpecific2
	);

VOID
IpxNdisUnload(
    VOID 
    );
//
// Internal to IPX.
// Create a loopback binding (adapter) in DriverEntry. 
// It will stick around for ever.
//

NTSTATUS
IpxBindLoopbackAdapter(
	);

VOID
IpxUnbindAdapter(
	OUT PNDIS_STATUS Status,
	IN	NDIS_HANDLE ProtocolBindingContext,
	IN	NDIS_HANDLE UnbindContext
	);

/*
VOID
IpxTranslate(
	OUT PNDIS_STATUS Status,
	IN NDIS_HANDLE     ProtocolBindingContext,
	OUT	PNET_PNP_ID   IdList,
	IN ULONG           IdListLength,
	OUT PULONG         BytesReturned
	);
*/

NDIS_STATUS
IpxPnPEventHandler(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNET_PNP_EVENT NetPnPEvent
    );

//
// Routines in mac.c
//

VOID
MacInitializeBindingInfo(
    IN struct _BINDING * Binding,
    IN struct _ADAPTER * Adapter
    );

VOID
MacInitializeMacInfo(
    IN NDIS_MEDIUM MacType,
    OUT PNDIS_INFORMATION MacInfo
    );

VOID
MacMapFrameType(
    IN NDIS_MEDIUM MacType,
    IN ULONG FrameType,
    OUT ULONG * MappedFrameType
    );

VOID
MacReturnMaxDataSize(
    IN PNDIS_INFORMATION MacInfo,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength,
    IN UINT DeviceMaxFrameSize,
    OUT PUINT MaxFrameSize
    );

NDIS_STATUS
IpxSendFramePreFwd(
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

NDIS_STATUS
IpxSendFrame(
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

NDIS_STATUS
IpxSendFrame802_3802_3(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

NDIS_STATUS
IpxSendFrame802_3802_2(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

NDIS_STATUS
IpxSendFrame802_3EthernetII(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

NDIS_STATUS
IpxSendFrame802_3Snap(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

NDIS_STATUS
IpxSendFrame802_5802_2(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

NDIS_STATUS
IpxSendFrame802_5Snap(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

NDIS_STATUS
IpxSendFrameFddi802_3(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

NDIS_STATUS
IpxSendFrameFddi802_2(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

NDIS_STATUS
IpxSendFrameFddiSnap(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

NDIS_STATUS
IpxSendFrameArcnet878_2(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

NDIS_STATUS
IpxSendFrameWanEthernetII(
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

VOID
MacUpdateSourceRouting(
    IN ULONG Database,
    IN PADAPTER Adapter,
    IN PUCHAR MacHeader,
    IN ULONG MacHeaderLength
    );

VOID
MacLookupSourceRouting(
    IN ULONG Database,
    IN PBINDING Binding,
    IN UCHAR NextRouter[6],
    IN OUT UCHAR SourceRouting[18],
    OUT PULONG SourceRoutingLength
    );

VOID
MacSourceRoutingTimeout(
    CTEEvent * Event,
    PVOID Context
    );

VOID
MacSourceRoutingRemove(
    IN PBINDING Binding,
    IN UCHAR MacAddress[6]
    );

VOID
MacSourceRoutingClear(
    IN PBINDING Binding
    );


//
// Routines in packet.c
//

NTSTATUS
IpxInitializeSendPacket(
    IN PDEVICE Device,
    IN PIPX_SEND_PACKET Packet,
    IN PUCHAR Header
    );

#if BACK_FILL
NTSTATUS
IpxInitializeBackFillPacket(
    IN PDEVICE Device,
    IN PIPX_SEND_PACKET Packet,
    IN PUCHAR Header
    );
#endif

NTSTATUS
IpxInitializeReceivePacket(
    IN PDEVICE Device,
    IN PIPX_RECEIVE_PACKET Packet
    );

NTSTATUS
NbiInitializeReceiveBuffer(
    IN PADAPTER Adapter,
    IN PIPX_RECEIVE_BUFFER ReceiveBuffer,
    IN PUCHAR DataBuffer,
    IN ULONG DataBufferLength
    );

NTSTATUS
IpxInitializePaddingBuffer(
    IN PDEVICE Device,
    IN PIPX_PADDING_BUFFER PaddingBuffer,
    IN ULONG DataBufferLength
    );

VOID
IpxDeinitializeSendPacket(
    IN PDEVICE Device,
    IN PIPX_SEND_PACKET Packet
    );

#if BACK_FILL
VOID
IpxDeinitializeBackFillPacket(
    IN PDEVICE Device,
    IN PIPX_SEND_PACKET Packet
    );
#endif

VOID
IpxDeinitializeReceivePacket(
    IN PDEVICE Device,
    IN PIPX_RECEIVE_PACKET Packet
    );

VOID
IpxDeinitializeReceiveBuffer(
    IN PADAPTER Adapter,
    IN PIPX_RECEIVE_BUFFER ReceiveBuffer,
    IN ULONG DataBufferLength
    );

VOID
IpxDeinitializePaddingBuffer(
    IN PDEVICE Device,
    IN PIPX_PADDING_BUFFER PaddingBuffer,
    IN ULONG DataBufferLength
    );

VOID
IpxAllocateSendPool(
    IN PDEVICE Device
    );

#if BACK_FILL
VOID
IpxAllocateBackFillPool(
    IN PDEVICE Device
    );
#endif

VOID
IpxAllocateReceivePool(
    IN PDEVICE Device
    );

VOID
IpxAllocateReceiveBufferPool(
    IN PADAPTER Adapter
    );

PSLIST_ENTRY
IpxPopSendPacket(
    IN PDEVICE Device
    );

#if BACK_FILL
PSLIST_ENTRY
IpxPopBackFillPacket(
    IN PDEVICE Device
    );
#endif

PSLIST_ENTRY
IpxPopReceivePacket(
    IN PDEVICE Device
    );

PSLIST_ENTRY
IpxPopReceiveBuffer(
    IN PADAPTER Adapter
    );

PIPX_PADDING_BUFFER
IpxAllocatePaddingBuffer(
    IN PDEVICE Device
    );

VOID
IpxFreePaddingBuffer(
    IN PDEVICE Device
    );



//
// Routines in query.c
//

NTSTATUS
IpxTdiQueryInformation(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

NTSTATUS
IpxTdiSetInformation(
    IN PDEVICE Device,
    IN PREQUEST Request
    );


//
// Routines in receive.c
//

VOID
IpxTransferDataComplete(
    IN NDIS_HANDLE BindingContext,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus,
    IN UINT BytesTransferred
    );


VOID
IpxTransferData(
	OUT PNDIS_STATUS Status,
	IN NDIS_HANDLE NdisBindingHandle,
	IN NDIS_HANDLE MacReceiveContext,
	IN UINT ByteOffset,
	IN UINT BytesToTransfer,
	IN OUT PNDIS_PACKET Packet,
	OUT PUINT BytesTransferred
    );

NTSTATUS
IpxTdiReceiveDatagram(
    IN PREQUEST Request
    );

VOID
IpxCancelReceiveDatagram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


//
// Routines in rip.c
//

NTSTATUS
RipGetLocalTarget(
    IN ULONG Segment,
    IN TDI_ADDRESS_IPX UNALIGNED * RemoteAddress,
    IN UCHAR Type,
    OUT PIPX_LOCAL_TARGET LocalTarget,
    OUT USHORT Counts[2] OPTIONAL
    );

NTSTATUS
RipQueueRequest(
    IN ULONG Network,
    IN USHORT Operation
    );

VOID
RipSendResponse(
    IN PBINDING Binding,
    IN TDI_ADDRESS_IPX UNALIGNED * RemoteAddress,
    IN PIPX_LOCAL_TARGET LocalTarget
    );

VOID
RipShortTimeout(
    CTEEvent * Event,
    PVOID Context
    );

VOID
RipLongTimeout(
    CTEEvent * Event,
    PVOID Context
    );

VOID
RipCleanupPacket(
    IN PDEVICE Device,
    IN PIPX_SEND_RESERVED RipReserved
    );

VOID
RipProcessResponse(
    IN PDEVICE Device,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN RIP_PACKET UNALIGNED * RipPacket
    );

VOID
RipHandleRoutePending(
    IN PDEVICE Device,
    IN UCHAR Network[4],
    IN CTELockHandle LockHandle,
    IN BOOLEAN Success,
    IN OPTIONAL PIPX_LOCAL_TARGET LocalTarget,
    IN OPTIONAL USHORT HopCount,
    IN OPTIONAL USHORT TickCount
    );

NTSTATUS
RipInsertLocalNetwork(
    IN ULONG Network,
    IN USHORT NicId,
    IN NDIS_HANDLE NdisBindingContext,
    IN USHORT Count
    );

VOID
RipAdjustForBindingChange(
    IN USHORT NicId,
    IN USHORT NewNicId,
    IN IPX_BINDING_CHANGE_TYPE ChangeType
    );

UINT
RipGetSegment(
    IN UCHAR Network[4]
    );

PIPX_ROUTE_ENTRY
RipGetRoute(
    IN UINT Segment,
    IN UCHAR Network[4]
    );

BOOLEAN
RipAddRoute(
    IN UINT Segment,
    IN PIPX_ROUTE_ENTRY RouteEntry
    );

BOOLEAN
RipDeleteRoute(
    IN UINT Segment,
    IN PIPX_ROUTE_ENTRY RouteEntry
    );

PIPX_ROUTE_ENTRY
RipGetFirstRoute(
    IN UINT Segment
    );

PIPX_ROUTE_ENTRY
RipGetNextRoute(
    IN UINT Segment
    );

VOID
RipDropRemoteEntries(
    VOID
    );


//
// Routines in send.c
//

VOID
IpxSendComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus
    );

NTSTATUS
IpxTdiSendDatagram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PREQUEST Request
    );


//
// Routines in rt.c
//


NTSTATUS
GetNewNics(
 PDEVICE,
 PREQUEST,
 BOOLEAN,
 PNWLINK_ACTION,
 UINT,
 BOOLEAN OldIrp
);

NTSTATUS
OpenRtAddress(
    IN PDEVICE Device,
    IN PIRP Request
    );

NTSTATUS
CloseRtAddress(
    IN  PDEVICE  pDevice,
    IN  PIRP            pIrp
    );

NTSTATUS
CleanupRtAddress(
    IN  PDEVICE  pDevice,
    IN  PIRP            pIrp
    );

NTSTATUS
SendIrpFromRt (
    IN  PDEVICE  pDevice,
    IN  PIRP        pIrp
    );

NTSTATUS
RcvIrpFromRt (
    IN  PDEVICE  pDevice,
    IN  PIRP        pIrp
    );
NTSTATUS
PassDgToRt (
    IN PDEVICE                  pDevice,
    IN PIPX_DATAGRAM_OPTIONS2   pContext,
    IN ULONG                    Index,
    IN VOID UNALIGNED           *pDgrm,
    IN ULONG                    uNumBytes
    );

NTSTATUS
NTCheckSetCancelRoutine(
    IN  PIRP            pIrp,
    IN  PVOID           CancelRoutine,
    IN  PDEVICE  pDevice
    );


VOID
NTIoComplete(
    IN  PIRP            pIrp,
    IN  NTSTATUS        Status,
    IN  ULONG           SentLength);

VOID
IpxRefRt(
  PRT_INFO pRt);

VOID
IpxDerefRt(
  PRT_INFO pRt);

VOID
IpxDestroyRt(
  PRT_INFO pRt);

#if DBG
VOID
IpxConstructHeader(
    IN PUCHAR Header,
    IN USHORT PacketLength,
    IN UCHAR PacketType,
    IN TDI_ADDRESS_IPX UNALIGNED * RemoteAddress,
    IN PTDI_ADDRESS_IPX LocalAddress
    );
#else
#define IpxConstructHeader(_Header,_PacketLength,_PacketType,_RemoteAddress,_LocalAddress) { \
    PIPX_HEADER _IpxHeader = (PIPX_HEADER)(_Header); \
    _IpxHeader->CheckSum = 0xffff; \
    _IpxHeader->PacketLength[0] = (UCHAR)((_PacketLength) / 256); \
    _IpxHeader->PacketLength[1] = (UCHAR)((_PacketLength) % 256); \
    _IpxHeader->TransportControl = 0; \
    _IpxHeader->PacketType = (_PacketType); \
    RtlCopyMemory(_IpxHeader->DestinationNetwork, (PVOID)(_RemoteAddress), 12); \
    RtlCopyMemory(_IpxHeader->SourceNetwork, (_LocalAddress), 12); \
}
#endif

//
// Routines in loopback.c
//

VOID
IpxDoLoopback(
    IN  CTEEvent    *Event,
    IN  PVOID       Context
    );

VOID
IpxInitLoopback();

VOID
IpxLoopbackEnque(
    IN PNDIS_PACKET Packet,
    IN PVOID    Context
    );


//
// [FW] InternalSendCompletion from Forwarder
//

// [FW] Added length here
VOID
IpxInternalSendComplete(
   IN PIPX_LOCAL_TARGET LocalTarget,
   IN PNDIS_PACKET      Packet,
   IN ULONG             PacketLength,
   IN NTSTATUS          Status
   );

NDIS_STATUS
IpxSubmitNdisRequest(
    IN PADAPTER Adapter,
    IN PNDIS_REQUEST NdisRequest,
    IN PNDIS_STRING AdapterString
    );

VOID
IpxDelayedSubmitNdisRequest(
    IN PVOID	Param
);

UINT 
IpxGetChainedMDLLength( 
    PNDIS_BUFFER pMDL 
); 

BOOLEAN
IpxHasInformedNbLoopback(); 

VOID
IpxInformNbLoopback();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\ipxtypes.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ipxtypes.h

Abstract:

    This module contains definitions specific to the
    IPX module of the ISN transport.

Author:

    Adam Barr (adamba) 2-September-1993

Environment:

    Kernel mode

Revision History:

   Sanjay Anand (SanjayAn) 3-Oct-1995
   Changes to support transfer of buffer ownership to transports - tagged [CH]

   Sanjay Anand (SanjayAn) 27-Oct-1995
   Changes to support Plug and Play

--*/

#ifdef  SNMP
#include    <hipxmib.h>
#endif  SNMP

//
// Definition of the protocol reserved field of a send packet.
//

typedef struct _IPX_SEND_RESERVED {
    UCHAR Identifier;                  // 0 for IPX packets
    BOOLEAN SendInProgress;            // used in an NdisSend
    BOOLEAN OwnedByAddress;            // packet is owned by an address
    UCHAR DestinationType;             // one of DEF, BCAST, MCAST
    struct _IPX_PADDING_BUFFER * PaddingBuffer; // if one was allocated
    PNDIS_BUFFER PreviousTail;         // if padding buffer was appended
	IPX_LOCAL_TARGET	LocalTarget;
	USHORT CurrentNicId;           // current binding being tried for net 0 sends
	ULONG	PacketLength;		   // length that comes into IpxSendFrame initially
	BOOLEAN Net0SendSucceeded;     // at least one NdisSend succeeded for net 0 sends
    SLIST_ENTRY PoolLinkage;           // when on free queue
    LIST_ENTRY GlobalLinkage;          // all packets are on this
    LIST_ENTRY WaitLinkage;            // when on WaitingForRoute/WaitingRipPackets
#ifdef IPX_TRACK_POOL
    PVOID Pool;                        // send pool it was allocated from
#endif
    struct _ADDRESS * Address;         // that owns this packet, if ones does

    //
    // The next fields are used differently depending on whether
    // the packet is being used for a datagram send or a rip request.
    //

    union {
      struct {
        PREQUEST Request;              // send datagram request
        struct _ADDRESS_FILE * AddressFile; // that this send is on
        USHORT CurrentNicId;           // current binding being tried for net 0 sends
        BOOLEAN Net0SendSucceeded;     // at least one NdisSend succeeded for net 0 sends
        BOOLEAN OutgoingSap;           // packet is sent from the SAP socket
      } SR_DG;
      struct {
        ULONG Network;                 // net we are looking for
        USHORT CurrentNicId;           // current binding being tried
        UCHAR RetryCount;              // number of times sent; 0xfe = response, 0xff = down
        BOOLEAN RouteFound;            // network has been found
        USHORT SendTime;               // timer expirations when sent.
        BOOLEAN NoIdAdvance;           // don't advance CurrentNicId this time.
      } SR_RIP;
    } u;

    PUCHAR Header;                     // points to the MAC/IPX header
    PNDIS_BUFFER HeaderBuffer;         // the NDIS_BUFFER describing Header;
#if BACK_FILL
    BOOLEAN BackFill;                  // 1 if we are using SMB's extended header
    PNDIS_BUFFER IpxHeader;            //  Place holder for our IpxHeader
    PNDIS_BUFFER MacHeader;            // Place holder for our mac header
    PVOID MappedSystemVa;
    PVOID ByteOffset;
    LONG UserLength;
#endif
} IPX_SEND_RESERVED, *PIPX_SEND_RESERVED;

//
// Values for the DestinationType field.
//

UNICODE_STRING  IpxDeviceName;

#define DESTINATION_DEF   1
#define DESTINATION_BCAST 2
#define DESTINATION_MCAST 3

// Used to cache multiple TdiDeregisterDeviceObject calls. 
// Assume TDI will never return TdiRegisterationHandle of this value. 
#define TDI_DEREGISTERED_COOKIE 0x12345678
//
// Used to indicate to IpxReceiveIndication that this is a loopback packet
// Assumption: Ndis cannot return this as the NdisBindingHandle value since
// that is a pointer (our pointers shd in kernel space, if not in Nonpaged pool).
//
#define IPX_LOOPBACK_COOKIE     0x00460007

//
// This is the net num that IPX loopback adapter (binding) uses until a real
// binding comes up. 
//

#define INITIAL_LOOPBACK_NET_ADDRESS    0x1234cdef

// #define IPX_INITIAL_LOOPBACK_NODE_ADDRESS  "0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1"

//
//	MIN/MAX macros
//
#define	MIN(a, b)	(((a) < (b)) ? (a) : (b))
#define	MAX(a, b)	(((a) > (b)) ? (a) : (b))


//
// In order to avoid a lock to read a value, this is used.
// As long as the final value has made it to _b by the time
// the check is made, this works fine.
//

#define	ASSIGN_LOOP(_a, _b) \
	do { \
		_a = _b; \
	} while ( _a != _b  );

//
// Gets the value of a Ulong (possibly a pointer) by adding 0 in an interlocked manner.
// This relies on the fact that the return of the ExchangeAdd will be the value prior to
// addition. Since the value added is 0, the final value stays the same.
//

#ifdef SUNDOWN

#define GET_VALUE(x) \
    InterlockedExchangePointer((PVOID *)&(x),(PVOID)(x))
    
#define GET_LONG_VALUE(x) \
    InterlockedExchangeAdd((PULONG)&(x), 0)
    
#else

#define GET_LONG_VALUE(x) \
    InterlockedExchangeAdd((PULONG)&(x), 0)

#endif

#ifdef SUNDOWN

#define SET_VALUE(x,y) \
InterlockedExchangePointer((PVOID *)&(x), (PVOID)(y))

#else

#define SET_VALUE(x,y) \
InterlockedExchange((PLONG)&(x), (LONG)(y))

#endif
    
#define SET_VALUE_ULONG(x,y) \
InterlockedExchange((PLONG)&(x), (LONG)(y))


/*
PBINDING
NIC_ID_TO_BINDING (
	IN	PDEVICE	_device,
	IN	USHORT	_nicid
	);
*/
//
// We need to ensure that the binding array pointer is valid hence use the interlocked operation.
// Also, the binding pointer read out of the array should be valid. Since the bindings are never
// freed (IPX maintains a pool of bindings), the pointer thus retrieved will always point to
// memory that belongs to us, which in the worst case could point to a re-claimed binding block.
//
// we can eliminate the second interlock if we always ensure that the bindings in an array
// dont change i.e. when we move around bindings, do them in a copy and make that the master (thru'
// a single ulong exchange).
//
// A problem that still remains here is that even if we get a valid (IPX owned non-paged) ptr out of
// the array, we still cannot atomically get a ref on the binding
// We might need those locks after all.... (revisit post SUR when the delete is enabled).
//

//
// NicId cast to SHORT so DemandDial Nic (0xffff) maps to -1.
//
#define	NIC_ID_TO_BINDING(_device, _nicid) \
	((PBINDING)GET_VALUE( ((PBIND_ARRAY_ELEM) GET_VALUE( (_device)->Bindings) )[(SHORT)_nicid].Binding ))

/*
PBINDING
NIC_ID_TO_BINDING_NO_ILOCK (
	IN	PDEVICE	_device,
	IN	USHORT	_nicid
	);
*/
//
// No interlocked operations are used here to get to the binding. This is used in the PnP add/delete
// adapter paths on the assumption that NDIS will serialize the addition/deletion of cards. [JammelH: 5/15/96]
//
#define	NIC_ID_TO_BINDING_NO_ILOCK(_device, _nicid) \
	((_device)->Bindings[_nicid].Binding)

/*
VOID
INSERT_BINDING(
	IN	PDEVICE	_device,
	IN	USHORT	_nicid,
	IN	PBINDING	_binding
	)
*/
//
// We dont do a get_value for the first arg of the macro since we are the writer and
// this value cannot change from under us here (NDIS will not give us two PnP Add adapter
// indications simultaneously).
//
#define	INSERT_BINDING(_device,	_nicid, _binding) \
	SET_VALUE((_device)->Bindings[_nicid].Binding, (_binding));

/*
VOID
SET_VERSION(
	IN	PDEVICE	_device,
	IN	USHORT	_nicid
	)
*/
#define	SET_VERSION(_device, _nicid) \
	SET_VALUE_ULONG((_device)->Bindings[_nicid].Version, ++(_device)->BindingVersionNumber);

/*
PBINDING
NIC_HANDLE_TO_BINDING (
	IN	PDEVICE	_device,
	IN	PNIC_HANDLE	_nichandle,
	);
*/
#ifdef  _PNP_LATER
#define	NIC_HANDLE_TO_BINDING(_device, _nichandle) \
	(((_nichandle)->Signature == IPX_BINDING_SIGNATURE) && \
		((_nichandle)->Version == (_device)->Bindings[(_nichandle)->NicId].Version)) ? \
			(_device)->Bindings[(_nichandle)->NicId].Binding : NULL;
#else

#define	NIC_HANDLE_TO_BINDING(_device, _nichandle) \
		NIC_ID_TO_BINDING(_device, (_nichandle)->NicId);
#endif

/*
VOID
FILL_LOCAL_TARGET(
	IN	PLOCAL_TARGET	_localtarget,
	IN	USHORT			_nicid
	)
*/

#define	FILL_LOCAL_TARGET(_localtarget, _nicid) \
	NIC_HANDLE_FROM_NIC((_localtarget)->NicHandle, _nicid)

#define	NIC_FROM_LOCAL_TARGET(_localtarget) \
	(_localtarget)->NicHandle.NicId


//
// Definition of the protocol reserved field of a receive packet.
//

typedef struct _IPX_RECEIVE_RESERVED {
    UCHAR Identifier;                  // 0 for IPX packets
    BOOLEAN TransferInProgress;        // used in an NdisTransferData
    BOOLEAN OwnedByAddress;            // packet is owned by an address
#ifdef IPX_TRACK_POOL
    PVOID Pool;                        // send pool it was allocated from
#endif
    struct _ADDRESS * Address;         // that owns this packet, if ones does
    PREQUEST SingleRequest;            // if transfer is for one only
    struct _IPX_RECEIVE_BUFFER * ReceiveBuffer; // if transfer is for multiple requests
    SLIST_ENTRY PoolLinkage;           // when on free queue
    LIST_ENTRY GlobalLinkage;          // all packets are on this
    LIST_ENTRY Requests;               // waiting on this transfer
    PVOID      pContext;
    ULONG    Index;
} IPX_RECEIVE_RESERVED, *PIPX_RECEIVE_RESERVED;

//
// The amount of data we need in our standard header, rounded up
// to the next longword bounday.
//
// Make this declaration in one place
//
#define PACKET_HEADER_SIZE  (MAC_HEADER_SIZE + IPX_HEADER_SIZE + RIP_PACKET_SIZE)

//
// Types to abstract NDIS packets. This is to allow us to
// switch from using our own memory for packets to using
// authentically allocated NDIS packets.
//

// #define IPX_OWN_PACKETS 1

#define IpxAllocateSendPacket(_Device,_SendPacket,_Status) { \
    NdisReinitializePacket((PNDIS_PACKET)(PACKET(_SendPacket))); \
    *(_Status) = STATUS_SUCCESS; \
}

#define IpxAllocateReceivePacket(_Device,_ReceivePacket,_Status) { \
    NdisReinitializePacket((PNDIS_PACKET)(PACKET(_ReceivePacket))); \
    *(_Status) = STATUS_SUCCESS; \
}

#ifdef IPX_OWN_PACKETS

#define NDIS_PACKET_SIZE 48
// #define NDIS_PACKET_SIZE FIELD_OFFSET(NDIS_PACKET,ProtocolReserved[0])

typedef struct _IPX_SEND_PACKET {
    UCHAR Data[NDIS_PACKET_SIZE+sizeof(IPX_SEND_RESERVED)];
} IPX_SEND_PACKET, *PIPX_SEND_PACKET;

typedef struct _IPX_RECEIVE_PACKET {
    UCHAR Data[NDIS_PACKET_SIZE+sizeof(IPX_RECEIVE_RESERVED)];
} IPX_RECEIVE_PACKET, *PIPX_RECEIVE_PACKET;

#define PACKET(_Packet) ((PNDIS_PACKET)((_Packet)->Data))

#define IpxFreeSendPacket(_Device,_Packet)

#define IpxFreeReceivePacket(_Device,_Packet)

#else  // IPX_OWN_PACKETS

typedef struct _IPX_SEND_PACKET {
    PNDIS_PACKET Packet;
    NDIS_HANDLE PoolHandle;
} IPX_SEND_PACKET, *PIPX_SEND_PACKET;

typedef struct _IPX_RECEIVE_PACKET {
    PNDIS_PACKET Packet;
    NDIS_HANDLE PoolHandle;
} IPX_RECEIVE_PACKET, *PIPX_RECEIVE_PACKET;

#define PACKET(_Packet) ((_Packet)->Packet)

extern	NDIS_HANDLE	IpxGlobalPacketPool;

#define IpxAllocateSingleSendPacket(_Device,_SendPacket,_Status) { \
    NdisAllocatePacket(_Status, &(_SendPacket)->Packet, IpxGlobalPacketPool); \
    if (*(_Status) == NDIS_STATUS_SUCCESS) { \
        (_Device)->MemoryUsage += sizeof(IPX_SEND_RESERVED); \
    } else {\
        IPX_DEBUG (PACKET, ("Could not allocate Ndis packet memory\n"));\
    }\
}

#define IpxAllocateSingleReceivePacket(_Device,_ReceivePacket,_Status) { \
    NdisAllocatePacket(_Status, &(_ReceivePacket)->Packet, IpxGlobalPacketPool); \
    if (*(_Status) == NDIS_STATUS_SUCCESS) { \
        (_Device)->MemoryUsage += sizeof(IPX_RECEIVE_RESERVED); \
    } else {\
        IPX_DEBUG (PACKET, ("Could not allocate Ndis packet memory\n"));\
    }\
}

#define IpxFreeSingleSendPacket(_Device,_Packet) { \
    (_Device)->MemoryUsage -= sizeof(IPX_SEND_RESERVED); \
}

#define IpxFreeSingleReceivePacket(_Device,_Packet) { \
    (_Device)->MemoryUsage -= sizeof(IPX_RECEIVE_RESERVED); \
}

#define IpxFreeSendPacket(_Device,_Packet)  NdisFreePacket(PACKET(_Packet))

#define IpxFreeReceivePacket(_Device,_Packet)   NdisFreePacket(PACKET(_Packet))

#endif // IPX_OWN_PACKETS

#define SEND_RESERVED(_Packet) ((PIPX_SEND_RESERVED)((PACKET(_Packet))->ProtocolReserved))
#define RECEIVE_RESERVED(_Packet) ((PIPX_RECEIVE_RESERVED)((PACKET(_Packet))->ProtocolReserved))


//
// This is the structure that contains a receive buffer for
// datagrams that are going to multiple recipients.
//

typedef struct _IPX_RECEIVE_BUFFER {
    LIST_ENTRY GlobalLinkage;            // all buffers are on this
#ifdef IPX_TRACK_POOL
    PVOID Pool;                          // receive buffer pool was allocated from
#endif
    SLIST_ENTRY PoolLinkage;             // when on free list
    PNDIS_BUFFER NdisBuffer;             // length of the NDIS buffer
    ULONG DataLength;                  // length of the data
    PUCHAR Data;                         // the actual data
} IPX_RECEIVE_BUFFER, *PIPX_RECEIVE_BUFFER;


//
// This is the structure that contains a padding buffer for
// padding ethernet frames out to an even number of bytes.
//

typedef struct _IPX_PADDING_BUFFER {
    LIST_ENTRY GlobalLinkage;            // all buffers are on this
    SINGLE_LIST_ENTRY PoolLinkage;       // when on free list
    PNDIS_BUFFER NdisBuffer;             // length of the NDIS buffer
    ULONG DataLength;                    // length of the data
    UCHAR Data[1];                       // the actual pad data
} IPX_PADDING_BUFFER, *PIPX_PADDING_BUFFER;

#ifdef  IPX_OWN_PACKETS

typedef struct _IPX_SEND_POOL {
    LIST_ENTRY Linkage;
    UINT PacketCount;
    UINT PacketFree;
    IPX_SEND_PACKET Packets[1];
} IPX_SEND_POOL, *PIPX_SEND_POOL;

typedef struct _IPX_RECEIVE_POOL {
    LIST_ENTRY Linkage;
    UINT PacketCount;
    UINT PacketFree;
    IPX_RECEIVE_PACKET Packets[1];
} IPX_RECEIVE_POOL, *PIPX_RECEIVE_POOL;
#else

typedef struct _IPX_PACKET_POOL {
    LIST_ENTRY Linkage;
    PUCHAR  Header;
    NDIS_HANDLE PoolHandle;
} IPX_PACKET_POOL, *PIPX_PACKET_POOL;

typedef IPX_PACKET_POOL IPX_RECEIVE_POOL, *PIPX_RECEIVE_POOL;
typedef IPX_PACKET_POOL IPX_SEND_POOL, *PIPX_SEND_POOL;

#endif // IPX_OWN_PACKETS

typedef struct _IPX_RECEIVE_BUFFER_POOL {
    LIST_ENTRY Linkage;
    UINT BufferCount;
    UINT BufferFree;
    IPX_RECEIVE_BUFFER Buffers[1];
    // after the packets the data buffers are allocated also.
} IPX_RECEIVE_BUFFER_POOL, *PIPX_RECEIVE_BUFFER_POOL;

//
// Number of upper drivers we support.
//

#define UPPER_DRIVER_COUNT   3



//
// Tags for memory allocation.
//

#define MEMORY_CONFIG        0
#define MEMORY_ADAPTER       1
#define MEMORY_ADDRESS       2
#define MEMORY_PACKET        3
#define MEMORY_RIP           4
#define MEMORY_SOURCE_ROUTE  5
#define MEMORY_BINDING       6
#define	MEMORY_QUERY		 7
#define MEMORY_WORK_ITEM     8

#define MEMORY_MAX           9

#if DBG

//
// Holds the allocations for a specific memory type.
//

typedef struct _MEMORY_TAG {
    ULONG Tag;
    ULONG BytesAllocated;
} MEMORY_TAG, *PMEMORY_TAG;

EXTERNAL_LOCK(IpxMemoryInterlock);
extern MEMORY_TAG IpxMemoryTag[MEMORY_MAX];

#endif

//
// This structure contains the work item info for the
// IPX data which we free on a delayed queue.
//

typedef struct _IPX_DELAYED_FREE_ITEM {
    WORK_QUEUE_ITEM WorkItem;
    PVOID           Context;
    ULONG           ContextSize;
} IPX_DELAYED_FREE_ITEM, *PIPX_DELAYED_FREE_ITEM;

//
// This structure contains the work item info to call
// NdisRequest at PASSIVE Level
//

typedef struct _IPX_DELAYED_NDISREQUEST_ITEM {
    WORK_QUEUE_ITEM WorkItem;
    PVOID           Adapter;
    NDIS_REQUEST    IpxRequest;
    int 	    AddrListSize; 
} IPX_DELAYED_NDISREQUEST_ITEM, *PIPX_DELAYED_NDISREQUEST_ITEM;

//
// This defines the reasons we delete rip entries for a binding.
//

typedef enum _IPX_BINDING_CHANGE_TYPE {
    IpxBindingDeleted,
    IpxBindingMoved,
    IpxBindingDown
} IPX_BINDING_CHANGE_TYPE, *PIPX_BINDING_CHANGE_TYPE;


//
// This structure contains information about a single
// source routing entry.
//

typedef struct _SOURCE_ROUTE {

    struct _SOURCE_ROUTE * Next;          // next in hash list

    UCHAR MacAddress[6];                  // remote MAC address
    UCHAR TimeSinceUsed;                  // timer expirations since last used
    UCHAR SourceRoutingLength;            // length of the data

    UCHAR SourceRouting[1];               // source routing data, stored as received in

} SOURCE_ROUTE, *PSOURCE_ROUTE;

#define SOURCE_ROUTE_SIZE(_SourceRoutingLength) \
    (FIELD_OFFSET(SOURCE_ROUTE, SourceRouting[0]) + (_SourceRoutingLength))

#define SOURCE_ROUTE_HASH_SIZE   16

//
// ULONG
// MacSourceRoutingHash(
//     IN PUCHAR MacAddress
//     )
//
// /*++
//
// Routine Description:
//
//     This routine returns a hash value based on the MAC address
//     that is pointed to. It will be between 0 and SOURCE_ROUTE_HASH_SIZE.
//
// Arguments:
//
//     MacAddress - The MAC address. NOTE: The source-routing bit may
//         or may not be on in the first byte, this routine will handle
//         that.
//
// Return Value:
//
//     The hash value.
//
// --*/
//

#define MacSourceRoutingHash(_MacAddress) \
    ((ULONG)((_MacAddress)[5] % SOURCE_ROUTE_HASH_SIZE))


#define ADAP_REF_CREATE 0
#define ADAP_REF_NDISREQ 1
#define ADAP_REF_SEND 2
#define ADAP_REF_UNBIND 3

#define ADAP_REF_TOTAL 	4

#define ADAPTER_STATE_OPEN 0
#define ADAPTER_STATE_STOPPING 1

//
// this structure describes a single NDIS adapter that IPX is
// bound to.
//

struct _DEVICE;
struct _BINDING; 

typedef struct _ADAPTER {

    CSHORT Type;                          // type of this structure
    USHORT Size;                          // size of this structure

#if DBG
    UCHAR Signature1[4];                  // contains "IAD1"
#endif

#if DBG
    LONG RefTypes[ADAP_REF_TOTAL];
#endif
    ULONG ReferenceCount;

    ULONG BindingCount;                   // number bound to this adapter

    //
    // Handle returned by the NDIS wrapper after we bind to it.
    //

    NDIS_HANDLE NdisBindingHandle;

    //
    // The queue of (currently receive only) requests waiting to complete.
    //

    LIST_ENTRY RequestCompletionQueue;

    //
    // IPX header normal offsets for directed and
    // broadcast/multicast frames.
    //

    ULONG DefHeaderSizes[ISN_FRAME_TYPE_MAX];
    ULONG BcMcHeaderSizes[ISN_FRAME_TYPE_MAX];

    //
    // List of buffers to be used for transfers.
    //

    ULONG AllocatedReceiveBuffers;
    LIST_ENTRY ReceiveBufferPoolList;
    SLIST_HEADER ReceiveBufferList;

    //
    // List of ethernet padding buffers.
    //

    ULONG AllocatedPaddingBuffers;
    SINGLE_LIST_ENTRY PaddingBufferList;

    struct _BINDING * Bindings[ISN_FRAME_TYPE_MAX];  // the binding for each frame type.

    //
    // TRUE if broadcast reception is enabled on this adapter.
    //

    BOOLEAN BroadcastEnabled;

    UCHAR State; 

    //
    // TRUE if we have enabled an auto-detected frame type
    // on this adapter -- used to prevent multiple ones.
    // 

    // BOOLEAN AutoDetectFound;

    // Keeps the binding on which we auto-detected frame type. 
    // It replaces AutoDetectFound. If it is not null, then
    // it has the same meaning as AutoDetectFound = TRUE. 
    // We need this so we don't remove this binding in 
    // IpxResolveAutodetect. 

    struct _BINDING * AutoDetectFoundOnBinding;
    
    //
    // TRUE if we got a response to at least one of our
    // auto-detect frames.
    //

    BOOLEAN AutoDetectResponse;

    //
    // This is TRUE if we are auto-detecting and we have
    // found the default auto-detect type on the net.
    //

    BOOLEAN DefaultAutoDetected;

    //
    // For WAN adapters, we support multiple bindings per
    // adapter, all with the same frame type. For them we
    // demultiplex using the local mac address. This stores
    // the range of device NIC IDs associated with this
    // particular address.
    //

    USHORT FirstWanNicId;
    USHORT LastWanNicId;
    ULONG WanNicIdCount;

    //
    // This is based on the configuration.
    //

    USHORT BindSap;                     // usually 0x8137
    USHORT BindSapNetworkOrder;         // usually 0x3781
    BOOLEAN SourceRouting;
    BOOLEAN EnableFunctionalAddress;
    BOOLEAN EnableWanRouter;
    BOOLEAN Disabled;                   // Used in NDIS_MEDIA_SENSE
    ULONG ConfigMaxPacketSize;

    //
    // TRUE if the tree is empty, so we can check quickly.
    //

    BOOLEAN SourceRoutingEmpty[IDENTIFIER_TOTAL];

    //
    // These are kept around for error logging, and stored right
    // after this structure.
    //

    PWCHAR AdapterName;
    ULONG AdapterNameLength;

    struct _DEVICE * Device;

    CTELock Lock;
    CTELock * DeviceLock;

    //
    // some MAC addresses we use in the transport
    //

    HARDWARE_ADDRESS LocalMacAddress;      // our local hardware address.

    //
    // The value of Device->SourceRoutingTime the last time
    // we checked the list for timeouts (this is so we can
    // tell in the timeout code when two bindings point to the
    // same adapter).
    //

    CHAR LastSourceRoutingTime;

    //
    // These are used while initializing the MAC driver.
    //

    KEVENT NdisRequestEvent;            // used for pended requests.
    NDIS_STATUS NdisRequestStatus;      // records request status.
    NDIS_STATUS OpenErrorStatus;        // if Status is NDIS_STATUS_OPEN_FAILED.

    //
    // This is the Mac type we must build the packet header for and know the
    // offsets for.
    //

    NDIS_INFORMATION MacInfo;

    ULONG MaxReceivePacketSize;         // does not include the MAC header
    ULONG MaxSendPacketSize;            // includes the MAC header
    ULONG ReceiveBufferSpace;           // as queried from the card

    //
    // This information is used to keep track of the speed of
    // the underlying medium.
    //

    ULONG MediumSpeed;                    // in units of 100 bytes/sec

    //
    // The source routing tree for each of the identifiers
    //

    PSOURCE_ROUTE SourceRoutingHeads[IDENTIFIER_TOTAL][SOURCE_ROUTE_HASH_SIZE];

    KEVENT NdisEvent; 

    void * PNPContext; 

} ADAPTER, * PADAPTER;

#define ASSERT_ADAPTER(_Adapter) \
    CTEAssert (((_Adapter)->Type == IPX_ADAPTER_SIGNATURE) && ((_Adapter)->Size == sizeof(ADAPTER)))


//
// These are the media and frame type specific MAC header
// constructors that we call in the main TDI send path.
//

typedef NDIS_STATUS
(*IPX_SEND_FRAME_HANDLER) (
    IN PADAPTER Adapter,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
    );

//
// These are the states a WAN line can be in.
//
typedef enum _WAN_LINE_STATE{
    LINE_DOWN,
    LINE_UP,
    LINE_CONFIG
} WAN_LINE_STATE, *PWAN_LINE_STATE;

#define BREF_BOUND 1
#define	BREF_DEVICE_ACCESS	2
#define	BREF_ADAPTER_ACCESS 3

//
// [FW] New flag to indicate the KFWD opened an adapter
//
#define BREF_FWDOPEN 4

#define BREF_TOTAL 5

typedef struct _BINDING {

#if DBG
    LONG RefTypes[BREF_TOTAL];
#endif

    CSHORT Type;                          // type of this structure
    USHORT Size;                          // size of this structure

#if DBG
    UCHAR Signature1[4];                  // contains "IBI1"
#endif

    ULONG ReferenceCount;

    SLIST_ENTRY PoolLinkage;              // when on free queue

    //
    // Adapter this binding is on.
    //

    PADAPTER Adapter;

    //
    // ID identifying us to the system (will be the index
    // in Device->Bindings[]).
    //

    USHORT NicId;

    //
    // For LANs these will be the same as the adapter's, for WANs
    // they change on line up indications.
    //

    ULONG MaxSendPacketSize;
    ULONG MediumSpeed;                    // in units of 100 bytes/sec
    HARDWARE_ADDRESS LocalMacAddress;     // our local hardware address.

    //
    // This is used for WAN lines, all sends go to this address
    // which is given on line up.
    //

    HARDWARE_ADDRESS RemoteMacAddress;

    //
    // For WAN lines, holds the remote address indicated to us
    // in the IPXCP_CONFIGURATION structure -- this is used to
    // select a binding to send to when WanGlobalNetworkNumber
    // is TRUE.
    //

    UCHAR WanRemoteNode[6];

    //
    // TRUE if this binding was set up to allow auto-detection,
    // instead of being configured explicitly in the registry.
    //

    BOOLEAN AutoDetect;

    //
    // TRUE if this binding was set up for auto-detection AND
    // was the default in the registry.
    //

    BOOLEAN DefaultAutoDetect;

    //
    // During auto-detect when we are processing responses from
    // various networks, these keep track of how many responses
    // we have received that match the current guess at the
    // network number, and how many don't (the current guess
    // is stored in TentativeNetworkAddress).
    //

    USHORT MatchingResponses;
    USHORT NonMatchingResponses;

    //
    // During auto-detect, stores the current guess at the
    // network number.
    //

    ULONG TentativeNetworkAddress;

    //
    // TRUE if this binding is part of a binding set.
    //

    BOOLEAN BindingSetMember;

    //
    // TRUE if this binding should receive broadcasts (this
    // rotates through the members of a binding set).
    //

    BOOLEAN ReceiveBroadcast;

    //
    // TRUE for WAN lines if we are up.
    //
    // BOOLEAN LineUp;
    WAN_LINE_STATE  LineUp;

    //
    // Media Sense: Is this adapter disabled 
    //

    BOOLEAN          Disabled;
    
    //
    // TRUE if this is a WAN line and is dialout.
    //

    BOOLEAN DialOutAsync;

    union {

        //
        // Used when a binding is active, if it is a member
        // of a binding set.
        //

        struct {

            //
            // Used to link members of a binding set in a circular list.
            // NULL for non-set members.
            //

            struct _BINDING * NextBinding;

            //
            // If this binding is a master of a binding set, this points
            // to the binding to use for the next send. For other members
            // of a binding set it is NULL. We use this to determine
            // if a binding is a master or not.
            //

            struct _BINDING * CurrentSendBinding;

            //
            // For binding set members, points to the master binding
            // (if this is the master it points to itself).
            //

            struct _BINDING * MasterBinding;

        };

        //
        // This is used when we are first binding to adapters,
        // and the device's Bindings array is not yet allocated.
        //

        LIST_ENTRY InitialLinkage;

    };

    //
    // Used by rip to keep track of unused wan lines.
    //

    ULONG WanInactivityCounter;

    //
    // Our local address, we don't use the socket but we keep
    // it here so we can do quick copies. It contains the
    // real network that we are bound to and our node
    // address on that net (typically the adapter's MAC
    // address but it will change for WANs).
    //

    TDI_ADDRESS_IPX LocalAddress;

    IPX_SEND_FRAME_HANDLER SendFrameHandler;

    struct _DEVICE * Device;

    CTELock * DeviceLock;

    ULONG DefHeaderSize;          // IPX header offset for directed frames
    ULONG BcMcHeaderSize;         // IPX header offset for broadcast/multicast

    ULONG AnnouncedMaxDatagramSize;  // what we advertise -- assumes worst-case SR
    ULONG RealMaxDatagramSize;       // what will really break the card
    ULONG MaxLookaheadData;

    //
    // Configuration parameters. We overlay all of them except
    // FrameType over the worker thread item we use to delay
    // deletion -- all the others are not needed once the
    // binding is up. Some of the config parameters are stored
    // in the adapter, these are the ones that are modified
    // per-binding.
    //

    ULONG FrameType;
    union {
        struct {
            ULONG ConfiguredNetworkNumber;
            BOOLEAN AllRouteDirected;
            BOOLEAN AllRouteBroadcast;
            BOOLEAN AllRouteMulticast;
        };
        WORK_QUEUE_ITEM WanDelayedQueueItem;
    };

#ifdef SUNDOWN
    ULONG_PTR FwdAdapterContext;    // [FW]
#else
    ULONG FwdAdapterContext;    // [FW]
#endif

    ULONG InterfaceIndex;       // [FW]

    ULONG ConnectionId; 	    // [FW] used to match TimeSinceLastActivity IOCtls

    ULONG IpxwanConfigRequired; // [FW] used to indicate to the adapter dll whether the line up is for Router or IpxWan.

    BOOLEAN  fInfoIndicated;       //Info indicated to user app

	//
	// Indicates whether this binding was indicated to the ISN driver
	//
	BOOLEAN	IsnInformed[UPPER_DRIVER_COUNT];

    //
    // Keeps the NetAddressRegistrationHandle.
    //
    ULONG   PastAutoDetection;
    HANDLE  TdiRegistrationHandle;
} BINDING, * PBINDING;


typedef struct _IPX_BINDING_POOL {
    LIST_ENTRY Linkage;
    UINT BindingCount;
    BINDING Bindings[1];
} IPX_BINDING_POOL, *PIPX_BINDING_POOL;

//
// This structure defines the control structure for a single
// router table segment.
//

typedef struct _ROUTER_SEGMENT {
    LIST_ENTRY WaitingForRoute;       // packets waiting for a route in this segment
    LIST_ENTRY FindWaitingForRoute;   // find route requests waiting for a route in this segment
    LIST_ENTRY WaitingLocalTarget;    // QUERY_IPX_LOCAL_TARGETs waiting for a route in this segment
    LIST_ENTRY WaitingReripNetnum;    // MIPX_RERIPNETNUMs waiting for a route in this segment
    LIST_ENTRY Entries;
    PLIST_ENTRY EnumerateLocation;
} ROUTER_SEGMENT, *PROUTER_SEGMENT;


//
// Number of buckets in the address hash table. This is
// a multiple of 2 so hashing is quick.
//

#define IPX_ADDRESS_HASH_COUNT     16

//
// Routine to convert a socket to a hash index. We use the
// high bits because it is stored reversed.
//

#define IPX_HASH_SOCKET(_S)        ((((_S) & 0xff00) >> 8) % IPX_ADDRESS_HASH_COUNT)

//
// This macro gets the socket hash right out of the IPX header.
//

#define IPX_DEST_SOCKET_HASH(_IpxHeader)   (((PUCHAR)&(_IpxHeader)->DestinationSocket)[1] % IPX_ADDRESS_HASH_COUNT)


//
// This structure defines the per-device structure for IPX
// (one of these is allocated globally).
//

#define DREF_CREATE     0
#define DREF_LOADED     1
#define DREF_ADAPTER    2
#define DREF_ADDRESS    3
#define DREF_SR_TIMER   4
#define DREF_RIP_TIMER  5
#define DREF_LONG_TIMER 6
#define DREF_RIP_PACKET 7
#define DREF_ADDRESS_NOTIFY 8
#define DREF_LINE_CHANGE 9
#define DREF_NIC_NOTIFY 10
#define DREF_BINDING	11
#define DREF_PNP	12

#define DREF_TOTAL      13

//
// Pre-allocated binding array size
//
#define	MAX_BINDINGS	280

//
// Our new binding array is composed of the following binding
// array element
//
typedef	struct	_BIND_ARRAY_ELEM {
	PBINDING	Binding;
	ULONG		Version;
} BIND_ARRAY_ELEM, *PBIND_ARRAY_ELEM;


typedef struct _DEVICE {

#if DBG
    LONG RefTypes[DREF_TOTAL];
#endif

    CSHORT Type;                          // type of this structure
    USHORT Size;                          // size of this structure

#if DBG
    UCHAR Signature1[4];                // contains "IDC1"
#endif

    CTELock Interlock;                  // GLOBAL lock for reference count.
                                        //  (used in ExInterlockedXxx calls)

    ULONG   NoMoreInitAdapters;
    ULONG   InitTimeAdapters;
    HANDLE  TdiProviderReadyHandle;
    PNET_PNP_EVENT  NetPnPEvent;
    //
    // These are temporary versions of these counters, during
    // timer expiration we update the real ones.
    //

    ULONG TempDatagramBytesSent;
    ULONG TempDatagramsSent;
    ULONG TempDatagramBytesReceived;
    ULONG TempDatagramsReceived;

    //
    // Configuration parameters.
    //

    BOOLEAN EthernetPadToEven;
    BOOLEAN SingleNetworkActive;
    BOOLEAN DisableDialoutSap;

    //
    // TRUE if we have multiple cards but a virtual network of 0.
    //

    BOOLEAN MultiCardZeroVirtual;

    CTELock Lock;

    //
    // Lock to access the sequenced lists in the device.
    //
    CTELock SListsLock;

    LONG ReferenceCount;                // activity count/this provider.


	//
	// Lock used to control the access to a binding (either from the
	// binding array in the device or from the binding array in the
	// adapter.
	//
    //	CTELock BindAccessLock;

    //
    // Registry Path for use when PnP adapters appear.
    //
    PWSTR RegistryPathBuffer;

	UNICODE_STRING	RegistryPath;

	//
	// Binding array has the Version number too
	//
	PBIND_ARRAY_ELEM   Bindings;  // allocated when number is determined.
	ULONG BindingCount;         // total allocated in Bindings.

	//
    // Monotonically increasing version number kept in bindings.
	// Hopefully this will not wrap around...
	//
	ULONG	BindingVersionNumber;


    //
    // ValidBindings is the number of bindings in the array which may
    // be valid (they are lan bindings or down wan binding placeholders).
    // It will be less than BindingCount by the number of auto-detect
    // bindings that are thrown away. HighestExternalNicId is ValidBindings
    // minus any binding set slaves which are moved to the end of the
    // array. SapNicCount is like HighestExternalNicId except that
    // if WanGlobalNetworkNumber is TRUE it will count all WAN bindings
    // as one. HighestExternalType20NicId is like HighestExternalNicId
    // except it stops when all the remaining bindings are down wan
    // lines, or dialin wan lines if DisableDialinNetbios bit 1 is on.
    //

    USHORT ValidBindings;
    USHORT HighestExternalNicId;
    USHORT SapNicCount;
    USHORT HighestType20NicId;
	//
	// Keeps track of the last LAN binding's position in the binding array
	//
	USHORT HighestLanNicId;

    //
    // This keeps track of the current size of the binding array
    //
	USHORT MaxBindings;

    //
    // [FW] To keep track of the number of WAN lines currently UP
    //
    USHORT UpWanLineCount;

    //
    // This will tell us if we have real adapters yet.
    //
    ULONG RealAdapters;


    LIST_ENTRY GlobalSendPacketList;
    LIST_ENTRY GlobalReceivePacketList;
    LIST_ENTRY GlobalReceiveBufferList;

#if BACK_FILL
    LIST_ENTRY GlobalBackFillPacketList;
#endif

    //
    // Action requests from SAP waiting for an adapter status to change.
    //

    LIST_ENTRY AddressNotifyQueue;

    //
    // Action requests from nwrdr waiting for the WAN line
    // to go up/down.
    //

    LIST_ENTRY LineChangeQueue;

    //
    // Action requests from forwarder waiting for the NIC change notification
    //
    LIST_ENTRY NicNtfQueue;
    LIST_ENTRY NicNtfComplQueue;

    //
    // All packet pools are chained on these lists.
    //

    LIST_ENTRY SendPoolList;
    LIST_ENTRY ReceivePoolList;


#if BACK_FILL
    LIST_ENTRY BackFillPoolList;
    SLIST_HEADER BackFillPacketList;
#endif

    LIST_ENTRY BindingPoolList;
    SLIST_HEADER BindingList;

    SLIST_HEADER SendPacketList;
    SLIST_HEADER ReceivePacketList;
    PIPX_PADDING_BUFFER PaddingBuffer;

    UCHAR State;

    UCHAR FrameTypeDefault;

    //
    // This holds state if SingleNetworkActive is TRUE. If
    // it is TRUE then WAN nets are active; if it is FALSE
    // then LAN nets are active.
    //

    BOOLEAN ActiveNetworkWan;

    //
    // TRUE if we have a virtual network.
    //

    BOOLEAN VirtualNetwork;

    //
    // If we are set up for SingleNetworkActive, we may have
    // to start our broadcast of net 0 frames somewhere other
    // than NIC ID 1, so that we don't send to the wrong type.
    //

    USHORT FirstLanNicId;
    USHORT FirstWanNicId;

    //
    // This holds the total memory allocated for the above structures.
    //

    LONG MemoryUsage;
    LONG MemoryLimit;

    //
    // How many of various resources have been allocated.
    //

    ULONG AllocatedDatagrams;
    ULONG AllocatedReceivePackets;
    ULONG AllocatedPaddingBuffers;

    //
    // Other configuration parameters.
    //

    ULONG InitDatagrams;
    ULONG MaxDatagrams;
    ULONG RipAgeTime;
    ULONG RipCount;
    ULONG RipTimeout;
    ULONG RipUsageTime;
    ULONG SourceRouteUsageTime;
    USHORT SocketStart;
    USHORT SocketEnd;
    ULONG SocketUniqueness;
    ULONG VirtualNetworkNumber;
    ULONG EthernetExtraPadding;
    BOOLEAN DedicatedRouter;
    BOOLEAN VirtualNetworkOptional;
    UCHAR DisableDialinNetbios;

    //
    // These are currently not read from the registry.
    //

    ULONG InitReceivePackets;
    ULONG InitReceiveBuffers;
    ULONG MaxReceivePackets;
    ULONG MaxReceiveBuffers;

    ULONG MaxPoolBindings;
    ULONG AllocatedBindings;
    ULONG InitBindings;

    //
    // This contains the next unique indentified to use as
    // the FsContext in the file object associated with an
    // open of the control channel.
    //

    LARGE_INTEGER ControlChannelIdentifier;

    //
    // This registry parameter controls whether IPX checks (and discards)
    // packets with mismatched Source addresses in the receive path.
    //
    BOOLEAN VerifySourceAddress;

    //
    // Where the current socket allocation is.
    //
    USHORT CurrentSocket;

    //
    // Number of segments in the RIP database.
    //

    ULONG SegmentCount;

    //
    // Points to an array of locks for the RIP database (these
    // are stored outside of the ROUTER_SEGMENT so the array
    // can be exposed to the RIP upper driver as one piece).
    //

    CTELock *SegmentLocks;

    //
    // Points to an array of ROUTER_SEGMENT fields for
    // various RIP control fields.
    //

    ROUTER_SEGMENT *Segments;

    //
    // Queue of RIP packets waiting to be sent.
    //

    LIST_ENTRY WaitingRipPackets;
    ULONG RipPacketCount;

    //
    // Timer that keeps RIP requests RIP_GRANULARITY ms apart.
    //

    BOOLEAN RipShortTimerActive;
    USHORT RipSendTime;
    CTETimer RipShortTimer;

    //
    // Timer that runs to age out unused rip entries (if the
    // router is not bound) and re-rip every so often for
    // active entries.
    //

    CTETimer RipLongTimer;

    //
    // This controls the source routing timeout code.
    //

    BOOLEAN SourceRoutingUsed;    // TRUE if any 802.5 bindings exist.
    CHAR SourceRoutingTime;       // incremented each time timer fires.
    CTETimer SourceRoutingTimer;  // runs every minute.

    //
    // [FW] Kicks in every minute if at least one WAN line is up. Increments
    // the WAN incativity counter on all UP WAN bindings.
    //
    CTETimer WanInactivityTimer;

    //
    // These are the merging of the binding values.
    //

    ULONG LinkSpeed;
    ULONG MacOptions;

    //
    // Where we tell upper drivers to put their headers.
    //

    ULONG IncludedHeaderOffset;

    //
    // A pre-allocated header containing our node and network,
    // plus an unused socket (so the structure is a known size
    // for easy copying).
    //

    TDI_ADDRESS_IPX SourceAddress;

    //
    // The following field is an array of list heads of ADDRESS objects that
    // are defined for this transport provider.  To edit the list, you must
    // hold the spinlock of the device context object.
    //

    LIST_ENTRY AddressDatabases[IPX_ADDRESS_HASH_COUNT];   // list of defined transport addresses.

    //
    // Holds the last address we looked up.
    //

    PVOID LastAddress;

    NDIS_HANDLE NdisBufferPoolHandle;

    //
    // The following structure contains statistics counters for use
    // by TdiQueryInformation and TdiSetInformation.  They should not
    // be used for maintenance of internal data structures.
    //

    TDI_PROVIDER_INFO Information;      // information about this provider.

    //
    // Information.MaxDatagramSize is the minimum size we can
    // send to all bindings assuming worst-case source routing;
    // this is the value that won't break any network drivers.
    //

    ULONG RealMaxDatagramSize;

#if DBG
    UCHAR Signature2[4];                // contains "IDC2"
#endif

    //
    // Indicates whether each upper driver is bound
    // (Netbios = 0, SPX = 1, RIP = 2).
    //

    BOOLEAN ForwarderBound;

    BOOLEAN UpperDriverBound[UPPER_DRIVER_COUNT];

    //
    // TRUE if any driver is bound.
    //

    BOOLEAN AnyUpperDriverBound;

    //
    // Whether a receive complete should be indicated to
    // this upper driver.
    //

    BOOLEAN ReceiveCompletePending[UPPER_DRIVER_COUNT];

    //
    // Control channel identifier for each of the upper
    // drivers' bindings.
    //

    LARGE_INTEGER UpperDriverControlChannel[UPPER_DRIVER_COUNT];

    //
    // Entry points and other information for each of the
    // upper drivers.
    //

    IPX_INTERNAL_BIND_INPUT UpperDrivers[UPPER_DRIVER_COUNT];

    //
    // How many upper drivers want broadcast enabled.
    //

    ULONG EnableBroadcastCount;

    //
    // Indicates if an enable broadcast operation is in
    // progress.
    //

    BOOLEAN EnableBroadcastPending;

    //
    // Indicates if a disable broadcast operation is in
    // progress.
    //

    BOOLEAN DisableBroadcastPending;

    //
    // Indicates if the current operation should be
    // reversed when it is finished.
    //

    BOOLEAN ReverseBroadcastOperation;

    //
    // TRUE if RIP wants a single network number for all WANs
    //

    BOOLEAN WanGlobalNetworkNumber;

    //
    // If WanGlobalNetworkNumber is TRUE, then this holds the
    // actual value of the network number, once we know it.
    //

    ULONG GlobalWanNetwork;

    //
    // Set to TRUE if WanGlobalNetworkNumber is TRUE and we
    // have already completed a queued notify from SAP. In
    // this case GlobalWanNetwork will be set correctly.
    //

    BOOLEAN GlobalNetworkIndicated;

    //
    // TRUE if we need to act as a RIP announcer/responder
    // for our virtual net.
    //

    BOOLEAN RipResponder;

    //
    // TRUE if we have already logged an error because someone
    // sent a SAP response but we have multiple cards with no
    // virtual network.
    //

    BOOLEAN SapWarningLogged;

    //
    // Used to queue up a worker thread to perform
    // broadcast operations.
    //

    WORK_QUEUE_ITEM BroadcastOperationQueueItem;

    //
    // Used to queue up a worker thread to perform
    // PnP indications to upper drivers.
    //

    WORK_QUEUE_ITEM PnPIndicationsQueueItemNb;
    WORK_QUEUE_ITEM PnPIndicationsQueueItemSpx;

    //
    // This event is used when unloading to signal that
    // the reference count is now 0.
    //

    KEVENT UnloadEvent;
    BOOLEAN UnloadWaiting;

    //
    // Counters for most of the statistics that IPX maintains;
    // some of these are kept elsewhere. Including the structure
    // itself wastes a little space but ensures that the alignment
    // inside the structure is correct.
    //

    TDI_PROVIDER_STATISTICS Statistics;


    //
    // This is TRUE if we have any adapters where we are
    // auto-detecting the frame type.
    //

    BOOLEAN AutoDetect;

    //
    // This is TRUE if we are auto-detecting and we have
    // found the default auto-detect type on the net.
    //

    BOOLEAN DefaultAutoDetected;

    //
    // Our state during auto-detect. After we are done this
    // will stay at AutoDetectDone;
    //

    UCHAR AutoDetectState;

    //
    // If we are auto-detecting, this event is used to stall
    // our initialization code while we do auto-detection --
    // this is so we have a constant view of the world once
    // we return from DriverEntry.
    //

    KEVENT AutoDetectEvent;

    //
    // Counters for "active" time.
    //

    LARGE_INTEGER IpxStartTime;

    //
    // This resource guards access to the ShareAccess
    // and SecurityDescriptor fields in addresses.
    //

    ERESOURCE AddressResource;

    //
    // Points back to the system device object.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Used to store the Tdi registration handle for deviceobject notifications.
    //
    HANDLE         TdiRegistrationHandle;

    //
    // Used to store the TA_ADDRESS which is indicated up to Tdi clients as adapters appear.
    //
    PTA_ADDRESS    TdiRegistrationAddress;

#ifdef  SNMP
    NOVIPXMIB_BASE  MibBase;
#endif  SNMP

    // Notification events, signaled once Loopback adapter is informed to nb. 
    KEVENT NbEvent; 
    //
    // These are kept around for error logging, and stored right
    // after this structure.
    //

    PWCHAR DeviceName;
    ULONG DeviceNameLength;

} DEVICE, * PDEVICE;


extern PDEVICE IpxDevice;
extern PIPX_PADDING_BUFFER IpxPaddingBuffer;
#if DBG
EXTERNAL_LOCK(IpxGlobalInterlock);
#endif

#ifdef  SNMP
#define IPX_MIB_ENTRY(Device, Variable) ((Device)->MibBase.Variable)
#endif SNMP

//
// device state definitions
//

#define DEVICE_STATE_CLOSED   0x00
#define DEVICE_STATE_OPEN     0x01
#define DEVICE_STATE_STOPPING 0x02


//
// New state which comes between CLOSED and OPEN. At this state,
// there are no adapters in the system and so no network activity
// is possible.
//
#define	DEVICE_STATE_LOADED	  0x03

//
// This is the state of our auto-detect if we do it.
//

#define AUTO_DETECT_STATE_INIT        0x00  // still initializing the device
#define AUTO_DETECT_STATE_RUNNING     0x01  // sent ffffffff query, waiting for responses
#define AUTO_DETECT_STATE_PROCESSING  0x02  // processing the responses
#define AUTO_DETECT_STATE_DONE        0x03  // detection is done, IPX is active



#define IPX_TDI_RESOURCES     9


//
// This structure is pointed to by the FsContext field in the FILE_OBJECT
// for this Address.  This structure is the base for all activities on
// the open file object within the transport provider.  All active connections
// on the address point to this structure, although no queues exist here to do
// work from. This structure also maintains a reference to an ADDRESS
// structure, which describes the address that it is bound to.
//

#define AFREF_CREATE     0
#define AFREF_RCV_DGRAM  1
#define AFREF_SEND_DGRAM 2
#define AFREF_VERIFY     3
#define AFREF_INDICATION 4

#define AFREF_TOTAL  8

typedef struct _ADDRESS_FILE {

#if DBG
    LONG RefTypes[AFREF_TOTAL];
#endif

    CSHORT Type;
    CSHORT Size;

    LIST_ENTRY Linkage;                 // next address file on this address.
                                        // also used for linkage in the
                                        // look-aside list

    ULONG ReferenceCount;               // number of references to this object.

    //
    // the current state of the address file structure; this is either open or
    // closing
    //

    UCHAR State;

    CTELock * AddressLock;

    //
    // The following fields are kept for housekeeping purposes.
    //

    PREQUEST Request;                  // the request used for open or close
    struct _ADDRESS *Address;          // address to which we are bound.
#ifdef ISN_NT
    PFILE_OBJECT FileObject;           // easy backlink to file object.
#endif
    struct _DEVICE *Device;            // device to which we are attached.

    //
    //
    // TRUE if ExtendedAddressing, ReceiveIpxHeader,
    // FilterOnPacketType, or ReceiveFlagAddressing is TRUE.
    //

    BOOLEAN SpecialReceiveProcessing;

    //
    // The remote address of a send datagram includes the
    // packet type. and on a receive datagram includes
    // the packet type AND a flags byte indicating information
    // about the frame (was it broadcast, was it sent from
    // this machine).
    //

    BOOLEAN ExtendedAddressing;

    //
    // TRUE if the address on a receive datagram includes
    // the packet type and a flags byte (like ExtendedAddressing),
    // but on send the address is normal (no packet type).
    //

    BOOLEAN ReceiveFlagsAddressing;

    //
    // Is the IPX header received with the data.
    //

    BOOLEAN ReceiveIpxHeader;

    //
    // The packet type to use if it is unspecified in the send.
    //

    UCHAR DefaultPacketType;

    //
    // TRUE if packet type filtering is enabled.
    //

    BOOLEAN FilterOnPacketType;

    //
    // The packet type to filter on.
    //

    UCHAR FilteredType;

    //
    // Does this address file want broadcast packets.
    //

    BOOLEAN EnableBroadcast;

    //
    // This is set to TRUE if this is the SAP socket -- we
    // put this under SpecialReceiveProcessing to avoid
    // hitting the main path.
    //

    BOOLEAN IsSapSocket;

    //
    // The following queue is used to queue receive datagram requests
    // on this address file. Send datagram requests are queued on the
    // address itself. These queues are managed by the EXECUTIVE interlocked
    // list management routines. The actual objects which get queued to this
    // structure are request control blocks (RCBs).
    //

    LIST_ENTRY ReceiveDatagramQueue;    // FIFO of outstanding TdiReceiveDatagrams.

    //
    // This holds the request used to close this address file,
    // for pended completion.
    //

    PREQUEST CloseRequest;

    //
    // handler for kernel event actions. First we have a set of booleans that
    // indicate whether or not this address has an event handler of the given
    // type registered.
    //

    //
    // [CH] Added the chained receive handlers.
    //

    BOOLEAN RegisteredReceiveDatagramHandler;
	BOOLEAN RegisteredChainedReceiveDatagramHandler;
    BOOLEAN RegisteredErrorHandler;

    //
    // The following function pointer always points to a TDI_IND_RECEIVE_DATAGRAM
    // event handler for the address.  If the NULL handler is specified in a
    // TdiSetEventHandler, this this points to an internal routine which does
    // not accept the incoming data.
    //

    PTDI_IND_RECEIVE_DATAGRAM ReceiveDatagramHandler;
    PVOID ReceiveDatagramHandlerContext;
	PTDI_IND_CHAINED_RECEIVE_DATAGRAM ChainedReceiveDatagramHandler;
    PVOID ChainedReceiveDatagramHandlerContext;

    //
    // The following function pointer always points to a TDI_IND_ERROR
    // handler for the address.  If the NULL handler is specified in a
    // TdiSetEventHandler, this this points to an internal routine which
    // simply returns successfully.
    //

    PTDI_IND_ERROR ErrorHandler;
    PVOID ErrorHandlerContext;

} ADDRESS_FILE, *PADDRESS_FILE;

#define ADDRESSFILE_STATE_OPENING   0x00    // not yet open for business
#define ADDRESSFILE_STATE_OPEN      0x01    // open for business
#define ADDRESSFILE_STATE_CLOSING   0x02    // closing


//
// This structure defines an ADDRESS, or active transport address,
// maintained by the transport provider.  It contains all the visible
// components of the address (such as the TSAP and network name components),
// and it also contains other maintenance parts, such as a reference count,
// ACL, and so on. All outstanding connection-oriented and connectionless
// data transfer requests are queued here.
//

#define AREF_ADDRESS_FILE 0
#define AREF_LOOKUP       1
#define AREF_RECEIVE      2

#define AREF_TOTAL   4

typedef struct _ADDRESS {

#if DBG
    LONG RefTypes[AREF_TOTAL];
#endif

    USHORT Size;
    CSHORT Type;

/*  ULONGs to allow for Interlocked operations.

    BOOLEAN SendPacketInUse;        // put these after so header is aligned.

    BOOLEAN ReceivePacketInUse;
#if BACK_FILL
    BOOLEAN BackFillPacketInUse;
#endif
*/

    ULONG SendPacketInUse;        // put these after so header is aligned.

    ULONG ReceivePacketInUse;
#if BACK_FILL
    ULONG BackFillPacketInUse;
#endif

    LIST_ENTRY Linkage;                 // next address/this device object.
    ULONG ReferenceCount;                // number of references to this object.

    CTELock Lock;

    //
    // The following fields comprise the actual address itself.
    //

    PREQUEST Request;                   // pointer to address creation request.

    USHORT Socket;                      // the socket this address corresponds to.
    USHORT SendSourceSocket;            // used for sends; may be == Socket or 0

    //
    // The following fields are used to maintain state about this address.
    //

    BOOLEAN Stopping;
    ULONG Flags;                        // attributes of the address.
    struct _DEVICE *Device;             // device context to which we are attached.
    CTELock * DeviceLock;

    //
    // The following queues is used to hold send datagrams for this
    // address. Receive datagrams are queued to the address file. Requests are
    // processed in a first-in, first-out manner, so that the very next request
    // to be serviced is always at the head of its respective queue.  These
    // queues are managed by the EXECUTIVE interlocked list management routines.
    // The actual objects which get queued to this structure are request control
    // blocks (RCBs).
    //

    LIST_ENTRY AddressFileDatabase; // list of defined address file objects

    //
    // Holds our source address, used for construcing datagrams
    // quickly.
    //

    TDI_ADDRESS_IPX LocalAddress;

    IPX_SEND_PACKET SendPacket;
    IPX_RECEIVE_PACKET ReceivePacket;

#if BACK_FILL
    IPX_SEND_PACKET BackFillPacket;
#endif


    UCHAR SendPacketHeader[IPX_MAXIMUM_MAC + sizeof(IPX_HEADER)];

#ifdef ISN_NT

    //
    // These two can be a union because they are not used
    // concurrently.
    //

    union {

        //
        // This structure is used for checking share access.
        //

        SHARE_ACCESS ShareAccess;

        //
        // Used for delaying IpxDestroyAddress to a thread so
        // we can access the security descriptor.
        //

        WORK_QUEUE_ITEM DestroyAddressQueueItem;

    } u;

    //
    // This structure is used to hold ACLs on the address.

    PSECURITY_DESCRIPTOR SecurityDescriptor;

#endif

    ULONG    Index;
    BOOLEAN  RtAdd;

} ADDRESS, *PADDRESS;

#define ADDRESS_FLAGS_STOPPING  0x00000001

//
// In order to increase the range of ControlChannelIds, we have a large integer to represent
// monotonically increasing ControlChannelIdentifiers. This large integer is packed into the
// 6 Bytes as follows:
//
//      REQUEST_OPEN_CONTEXT(_Request) - 4 bytes
//      Upper 2 bytes of REQUEST_OPEN_TYPE(_Request) - 2 bytes
//
// IPX_CC_MASK is used to mask out the upper 2 bytes of the OPEN_TYPE.
// MAX_CCID is 2^48.
//
#define IPX_CC_MASK     0x0000ffff

#define MAX_CCID        0xffffffffffff

#ifdef _WIN64
#define CCID_FROM_REQUEST(_ccid, _Request) \
    (_ccid).QuadPart = (ULONG_PTR)(REQUEST_OPEN_CONTEXT(_Request)); \

#else

#define CCID_FROM_REQUEST(_ccid, _Request) \
    (_ccid).LowPart = (ULONG)(REQUEST_OPEN_CONTEXT(_Request)); \
    (_ccid).HighPart = ((ULONG)(REQUEST_OPEN_TYPE(_Request)) >> 16);

#endif


//#define USER_BUFFER_OFFSET FIELD_OFFSET(RTRCV_BUFFER, DgrmLength)
#define USER_BUFFER_OFFSET FIELD_OFFSET(RTRCV_BUFFER, Options)
//
// This structure keeps track of the WINS recv Irp and any datagram
// queued to go up to WINS (name service datagrams)
//
#define REFRT_TOTAL 8

#define  RT_CREATE 0
#define RT_CLEANUP 1
#define RT_CLOSE 2
#define RT_SEND 3
#define RT_RCV 4
#define RT_IRPIN  5
#define RT_BUFF  6
#define RT_EXTRACT  7


#define RT_EMPTY      0
#define RT_OPEN        1
#define RT_CLOSING     2
#define RT_CLOSED      3


#define RT_IRP_MAX     1000
#define RT_BUFF_MAX    1000

//
// Max. memory allocated for queueing buffers to be received by the RT
// manager
//
#define RT_MAX_BUFF_MEM  65000      //bytes

//
// Get Index corresponding to the address object opened by RT. BTW We
// can not have more than one Address file (client) for a RT address.
//
#ifdef SUNDOWN
#define RT_ADDRESS_INDEX(_pIrp)   (((ULONG_PTR)REQUEST_OPEN_TYPE(_pIrp)) - ROUTER_ADDRESS_FILE)
#else
#define RT_ADDRESS_INDEX(_pIrp)   (((ULONG)REQUEST_OPEN_TYPE(_pIrp)) - ROUTER_ADDRESS_FILE)
#endif



typedef struct _RT_IRP {
    PADDRESS_FILE   AddressFile;
    LIST_ENTRY      RcvIrpList;
    ULONG           NoOfRcvIrps;
    LIST_ENTRY      RcvList;            // linked list of Datagrams Q'd to rcv
    ULONG           NoOfRcvBuffs;       // linked list of Datagrams Q'd to rcv
    BOOLEAN         State;
       } RT_IRP, *PRT_IRP;

typedef struct
{
#if DBG
    LONG RefTypes[REFRT_TOTAL];
#endif

    CSHORT Type;                          // type of this structure
    USHORT Size;                          // size of this structure

#if DBG
    UCHAR Signature[4];                  // contains "IBI1"
#endif
    LIST_ENTRY      CompletedIrps;     // linked list of Datagrams Q'd to rcv
    LIST_ENTRY      HolderIrpsList;    // Holds Irps
    CTELock         Lock;
    ULONG           ReferenceCount;
    ULONG           RcvMemoryAllocated; // bytes buffered so far
    ULONG           RcvMemoryMax;       // max # of bytes to buffer on Rcv
    PDEVICE         pDevice;           // the devicecontext used by wins
    UCHAR           NoOfAdds;
    RT_IRP          AddFl[IPX_RT_MAX_ADDRESSES];
} RT_INFO, *PRT_INFO;

//
// RT Rcv Buffer structure
//
typedef struct
{
    LIST_ENTRY      Linkage;
    ULONG           TotalAllocSize;
    ULONG           UserBufferLengthToPass;
    IPX_DATAGRAM_OPTIONS2    Options;

} RTRCV_BUFFER, *PRTRCV_BUFFER;

typedef struct _IPX_NDIS_REQUEST {
    NDIS_REQUEST NdisRequest; 
    KEVENT NdisRequestEvent;        
    NDIS_STATUS Status; 
} IPX_NDIS_REQUEST, *PIPX_NDIS_REQUEST; 

#define OFFSET_OPTIONS_IN_RCVBUFF  FIELD_OFFSET(RTRCV_BUFFER, Options)
#define OFFSET_PKT_IN_RCVBUFF  (FIELD_OFFSET(RTRCV_BUFFER, Options) + FIELD_OFFSET(IPX_DATAGRAM_OPTIONS2, Data))
#define OFFSET_PKT_IN_OPTIONS  FIELD_OFFSET(IPX_DATAGRAM_OPTIONS2, Data)

extern PRT_INFO pRtInfo;

//
// We keep the demand-dial binding at the beginning of the binding array; this keeps
// track of the number of extra bindings that we have.
// Currently 1 (for demand-dial), we could also keep other bindings like the loopback
// binding, etc.
//
#define DEMAND_DIAL_NIC_ID      DEMAND_DIAL_ADAPTER_CONTEXT
#define LOOPBACK_NIC_ID         1 //VIRTUAL_NET_ADAPTER_CONTEXT

//
// Handy defines - ShreeM
//
#define FIRST_REAL_BINDING      2
#define LAST_REAL_BINDING       2

#define EXTRA_BINDINGS          2

// 
// Used in Media Sense
//

#define  COMPLETE_MATCH    1
#define  PARTIAL_MATCH     2
#define  DISABLED          0
#define  ENABLED           1

UINT
CompareBindingCharacteristics(
                              PBINDING Binding1, 
                              PBINDING Binding2
                              );

BOOLEAN 
IpxNcpaChanges(
               PNET_PNP_EVENT NetPnPEvent
               );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\ipxpnp.h ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    ipxpnp.h

Abstract:

    This module contains definitions specific to the
    IPX module for PnP/PM.

Author:

    Shreedhar Madhavapeddi (ShreeM) 24-February-1993

Environment:

    Kernel mode

Revision History:

--*/

#if     defined(_PNP_POWER_)

typedef enum IPX_PNP_PROCESSING_STATE {
        NONE_DONE,
        SPX_DONE,
        NB_DONE,
        ALL_DONE
} PnPState;

typedef
struct  _NetPnPEventReserved {
    
    NDIS_HANDLE         *ProtocolBindingContext;
    PTDI_PNP_CONTEXT    Context1;
    PTDI_PNP_CONTEXT    Context2;
    PnPState            State;
    IPX_PNP_OPCODE      OpCode;
    NTSTATUS            Status[3];

} NetPnPEventReserved, *PNetPnPEventReserved;

#endif _PNP_POWER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\mac.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    mac.h

Abstract:

    This header file defines manifest constants and necessary macros for use
    by transports dealing with multiple MAC cards through the NDIS interface.

Revision History:

--*/


//
// We need this to define information about the MAC. Note that
// it is a strange structure in that the first four elements
// are for use internally by the mac.c routines, while the
// DeviceContext knows about and uses the last two.
//

typedef struct _NDIS_INFORMATION {

    NDIS_MEDIUM MediumType;
    NDIS_MEDIUM RealMediumType;
    BOOLEAN SourceRouting;
    BOOLEAN MediumAsync;
    UCHAR BroadcastMask;
    ULONG CopyLookahead;
    ULONG MacOptions;
    ULONG MinHeaderLength;
    ULONG MaxHeaderLength;

} NDIS_INFORMATION, * PNDIS_INFORMATION;


#define TR_SOURCE_ROUTE_FLAG    0x80

#define ARCNET_PROTOCOL_ID      0xFA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\ndis.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ndis.c

Abstract:

    This module contains code which implements the routines used to
    initialize the IPX <-> NDIS interface, as well as most of the
    interface routines.

Environment:

    Kernel mode

Revision History:

    Sanjay Anand (SanjayAn) 3-Oct-1995
    Changes to support transfer of buffer ownership to transports
    1. Added the ReceivePacketHandler to the ProtChars.

    Sanjay Anand (SanjayAn) 27-Oct-1995
    Changes to support Plug and Play

	Tony Bell (TonyBe) 10-Dec-1995
	Changes to support new NdisWan Lineup.

--*/

#include "precomp.h"
#pragma hdrstop

//
// This is a one-per-driver variable used in binding
// to the NDIS interface.
//

NDIS_HANDLE IpxNdisProtocolHandle = (NDIS_HANDLE)NULL;
NDIS_HANDLE	IpxGlobalPacketPool = (NDIS_HANDLE)NULL;
extern CTELock IpxGlobalInterlock; 


void
IpxMediaSenseHandler(
    IN CTEEvent *WorkerThreadEvent,
    IN PVOID Context);

void
LineDownOnWorkerThread(
    IN CTEEvent *WorkerThreadEvent,
    IN PVOID Context);

void
LineUpOnWorkerThread(
    IN CTEEvent *WorkerThreadEvent,
    IN PVOID Context);

#ifndef	max
#define	max(a, b)	((a) > (b)) ? (a) : (b)
#endif



NTSTATUS
IpxRegisterProtocol(
    IN PNDIS_STRING NameString
    )

/*++

Routine Description:

    This routine introduces this transport to the NDIS interface.

Arguments:

    NameString - The name of the transport.

Return Value:

    The function value is the status of the operation.
    STATUS_SUCCESS if all goes well,
    Failure status if we tried to register and couldn't,
    STATUS_INSUFFICIENT_RESOURCES if we couldn't even try to register.

--*/

{
    NDIS_STATUS ndisStatus;

    NDIS_PROTOCOL_CHARACTERISTICS ProtChars;    // Used temporarily to register

    RtlZeroMemory(&ProtChars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    //
    // Set up the characteristics of this protocol
    //
#if NDIS40
    ProtChars.MajorNdisVersion = 4;

    ProtChars.ReceivePacketHandler = IpxReceivePacket;
#else
    ProtChars.MajorNdisVersion = 3;
#endif
    ProtChars.MinorNdisVersion = 0;

    ProtChars.Name = *NameString;

    ProtChars.OpenAdapterCompleteHandler = IpxOpenAdapterComplete;
    ProtChars.CloseAdapterCompleteHandler = IpxCloseAdapterComplete;
    ProtChars.ResetCompleteHandler = IpxResetComplete;
    ProtChars.RequestCompleteHandler = IpxRequestComplete;

    ProtChars.SendCompleteHandler = IpxSendComplete;
    ProtChars.TransferDataCompleteHandler = IpxTransferDataComplete;

    ProtChars.ReceiveHandler = IpxReceiveIndication;
    ProtChars.ReceiveCompleteHandler = IpxReceiveComplete;
    ProtChars.StatusHandler = IpxStatus;
    ProtChars.StatusCompleteHandler = IpxStatusComplete;

    ProtChars.BindAdapterHandler = IpxBindAdapter;
    ProtChars.UnbindAdapterHandler = IpxUnbindAdapter;
    ProtChars.UnloadHandler = IpxNdisUnload; 

    //
    // We pass up the NET_PNP_EVENT structures passed in by NDIS
    // to the Transports via TDI. We pass on the response from TDI to NDIS.
    //
#ifdef _PNP_POWER_
    ProtChars.PnPEventHandler = IpxPnPEventHandler;
#endif

    NdisRegisterProtocol (
        &ndisStatus,
        &IpxNdisProtocolHandle,
        &ProtChars,
        (UINT)sizeof(NDIS_PROTOCOL_CHARACTERISTICS) + NameString->Length);

    if (ndisStatus != NDIS_STATUS_SUCCESS) {
        return (NTSTATUS)ndisStatus;
    }
	
    //
	// Allocate a pool of packets for use by single send/receive
	//
    IpxGlobalPacketPool = (void *) NDIS_PACKET_POOL_TAG_FOR_NWLNKIPX;
	NdisAllocatePacketPoolEx(&ndisStatus,
							 &IpxGlobalPacketPool,
							 10,
							 90,
							 max(sizeof(IPX_SEND_RESERVED), sizeof(IPX_RECEIVE_RESERVED)));
    
    NdisSetPacketPoolProtocolId(IpxGlobalPacketPool, NDIS_PROTOCOL_ID_IPX);

    return STATUS_SUCCESS;

}   /* IpxRegisterProtocol */


VOID
IpxDeregisterProtocol (
    VOID
    )

/*++

Routine Description:

    This routine removes this transport to the NDIS interface.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NDIS_STATUS ndisStatus;
    CTELockHandle LockHandle;
    NDIS_HANDLE LocalNdisProtocolHandle = (NDIS_HANDLE)NULL;
    NDIS_HANDLE	LocalGlobalPacketPool = (NDIS_HANDLE)NULL;


    CTEGetLock (&IpxGlobalInterlock, &LockHandle);
    
    if (IpxNdisProtocolHandle != (NDIS_HANDLE)NULL) {
       LocalNdisProtocolHandle = IpxNdisProtocolHandle; 
       IpxNdisProtocolHandle = (NDIS_HANDLE) NULL; 
       CTEFreeLock (&IpxGlobalInterlock, LockHandle);
       NdisDeregisterProtocol (
            &ndisStatus,
            LocalNdisProtocolHandle);
       ASSERT(ndisStatus == NDIS_STATUS_SUCCESS);  
    } else {
       CTEFreeLock (&IpxGlobalInterlock, LockHandle);
    }
	
    CTEGetLock (&IpxGlobalInterlock, &LockHandle);

    if (IpxGlobalPacketPool != NULL) {
       LocalGlobalPacketPool = IpxGlobalPacketPool; 
       IpxGlobalPacketPool = (NDIS_HANDLE) NULL; 
       CTEFreeLock (&IpxGlobalInterlock, LockHandle);
       
       NdisFreePacketPool(LocalGlobalPacketPool);

    } else {
       CTEFreeLock (&IpxGlobalInterlock, LockHandle);
    }

}   /* IpxDeregisterProtocol */

VOID
IpxDelayedSubmitNdisRequest(
    IN PVOID	Param
)

/*++

Routine Description:

   This routine submit an ndis request at PASSIVE level. We assume that Adatper structure
   still exist. IpxDestroyAdapter will delay 1 sec to allow this thread to finish. 

Arguments:

    Param - pointer to the work item.

Return Value:

    None.

--*/
{
    PIPX_DELAYED_NDISREQUEST_ITEM DelayedNdisItem = (PIPX_DELAYED_NDISREQUEST_ITEM) Param;
    PADAPTER        Adapter;
    UNICODE_STRING  AdapterName;
    NDIS_REQUEST    IpxRequest;
    NDIS_STATUS     NdisStatus;  

    Adapter = (PADAPTER) DelayedNdisItem->Adapter;

    RtlInitUnicodeString(&AdapterName, Adapter->AdapterName);
    IpxRequest = DelayedNdisItem->IpxRequest; 
    
    NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, &AdapterName);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
       IPX_DEBUG(PNP, ("Setting the QoS OID SUCCESS\n"));
    } else {
       IPX_DEBUG(PNP, ("Setting the QoS OID failed - Error %lx\n", NdisStatus));
    }	

    IpxFreeMemory(IpxRequest.DATA.SET_INFORMATION.InformationBuffer,
		  DelayedNdisItem->AddrListSize,
		  MEMORY_ADAPTER,
		  "QoS specific stuff");
    
    IpxFreeMemory (
        DelayedNdisItem,
        sizeof (IPX_DELAYED_NDISREQUEST_ITEM),
        MEMORY_WORK_ITEM,
        "Work Item");

    IpxDereferenceDevice (Adapter->Device, DREF_ADAPTER);
    IpxDereferenceAdapter1(Adapter,ADAP_REF_NDISREQ);

} /* IpxDelayedSubmitNdisRequest */

NDIS_STATUS
IpxSubmitNdisRequest(
    IN PADAPTER Adapter,
    IN PNDIS_REQUEST Request,
    IN PNDIS_STRING AdapterString
    )

/*++

Routine Description:

    This routine passed an NDIS_REQUEST to the MAC and waits
    until it has completed before returning the final status.

Arguments:

    Adapter - Pointer to the device context for this driver.

    Request - Pointer to the NDIS_REQUEST to submit.

    AdapterString - The name of the adapter, in case an error needs
        to be logged.

Return Value:

    The function value is the status of the operation.

--*/
{
    NDIS_STATUS NdisStatus;

    IPX_NDIS_REQUEST IpxRequest; 

    RtlZeroMemory(&IpxRequest, sizeof(IpxRequest)); 
    RtlCopyMemory(&IpxRequest, Request, sizeof(NDIS_REQUEST)); 
    KeInitializeEvent(&IpxRequest.NdisRequestEvent,NotificationEvent,FALSE);
    IpxRequest.Status = NDIS_STATUS_SUCCESS; 

    NdisRequest(
        &NdisStatus,
        Adapter->NdisBindingHandle,
        (PNDIS_REQUEST) &IpxRequest);

    if (NdisStatus == NDIS_STATUS_PENDING) {

        //
        // The completion routine will set NdisRequestStatus.
        //

        KeWaitForSingleObject(
            &IpxRequest.NdisRequestEvent,
            Executive,
            KernelMode,
            TRUE,
            (PLARGE_INTEGER)NULL
            );

        NdisStatus = IpxRequest.Status;

        KeResetEvent(
            &IpxRequest.NdisRequestEvent
            );
    }


    // Skip event log when QoS is not installed. 
    if (NdisStatus != NDIS_STATUS_SUCCESS && 
	// This is not related to QoS
	(Request->DATA.QUERY_INFORMATION.Oid != OID_GEN_NETWORK_LAYER_ADDRESSES ||
	 // or it is related to QoS and the status is not the status when QoS is 
	 // not installed.
	 (Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_NETWORK_LAYER_ADDRESSES &&
	  NdisStatus != NDIS_STATUS_INVALID_OID))) {

        IPX_DEBUG (NDIS, ("%s on OID %8.8lx failed %lx\n",
                               Request->RequestType == NdisRequestSetInformation ? "Set" : "Query",
                               Request->DATA.QUERY_INFORMATION.Oid,
                               NdisStatus));

        IpxWriteOidErrorLog(
            Adapter->Device->DeviceObject,
            Request->RequestType == NdisRequestSetInformation ?
                EVENT_TRANSPORT_SET_OID_FAILED : EVENT_TRANSPORT_QUERY_OID_FAILED,
            NdisStatus,
            AdapterString->Buffer,
            Request->DATA.QUERY_INFORMATION.Oid);

    } else {

        IPX_DEBUG (NDIS, ("%s on OID %8.8lx succeeded\n",
                               Request->RequestType == NdisRequestSetInformation ? "Set" : "Query",
                               Request->DATA.QUERY_INFORMATION.Oid));
    }

    return NdisStatus;

}   /* IpxSubmitNdisRequest */


NTSTATUS
IpxInitializeNdis(
    IN PADAPTER Adapter,
    IN PBINDING_CONFIG ConfigBinding
    )

/*++

Routine Description:

    This routine introduces this transport to the NDIS interface and sets up
    any necessary NDIS data structures (Buffer pools and such). It will be
    called for each adapter opened by this transport.

Arguments:

    Adapter - Structure describing this binding.

    ConfigAdapter - Configuration information for this binding.

Return Value:

    The function value is the status of the operation.

--*/

{
    NDIS_STATUS NdisStatus;
    NDIS_STATUS OpenErrorStatus;
    NDIS_MEDIUM IpxSupportedMedia[] = { NdisMedium802_3, NdisMedium802_5, NdisMediumFddi, NdisMediumArcnet878_2, NdisMediumWan };
    UINT SelectedMedium;
    NDIS_REQUEST IpxRequest;
    ULONG MinimumLookahead;
    UCHAR WanProtocolId[6] = { 0x80, 0x00, 0x00, 0x00, 0x81, 0x37 };
    UCHAR FunctionalAddress[4] = { 0x00, 0x80, 0x00, 0x00 };
    ULONG WanHeaderFormat = NdisWanHeaderEther