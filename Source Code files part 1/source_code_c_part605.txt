              return E_POINTER;
            }
			ATL_LOCKT();
            *pBandwidth = m_Bandwidth;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Bandwidth)(/*[in]*/ long NewBandwidth) {
		ATL_LOCKT();
        m_Bandwidth = NewBandwidth;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_LPInnerFEC)(/*[out, retval]*/ FECMethod *pLPInnerFECMethod) {
        try {
            if (!pLPInnerFECMethod) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pLPInnerFECMethod = m_LPInnerFECMethod;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_LPInnerFEC)(/*[in]*/ FECMethod NewLPInnerFECMethod) {
		ATL_LOCKT();
        m_LPInnerFECMethod = NewLPInnerFECMethod;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_LPInnerFECRate)(/*[out, retval]*/ BinaryConvolutionCodeRate *pLPInnerFECRate) {
        try {
            if (!pLPInnerFECRate) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pLPInnerFECRate = m_LPInnerFECRate;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_LPInnerFECRate)(/*[in]*/ BinaryConvolutionCodeRate NewLPInnerFECRate) {
		ATL_LOCKT();
        m_LPInnerFECRate = NewLPInnerFECRate;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_HAlpha)(/*[out, retval]*/ HierarchyAlpha *pHierarchyAlpha) {
        try {
            if (!pHierarchyAlpha) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pHierarchyAlpha = m_HAlpha;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_HAlpha)(/*[in]*/ HierarchyAlpha NewHierarchyAlpha) {
		ATL_LOCKT();
        m_HAlpha = NewHierarchyAlpha;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Guard)(/*[out, retval]*/ GuardInterval *pGuardInterval) {
        try {
            if (!pGuardInterval) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pGuardInterval = m_GuardInterval;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Guard)(/*[in]*/ GuardInterval NewGuardInterval) {
		ATL_LOCKT();
        m_GuardInterval = NewGuardInterval;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Mode)(/*[out, retval]*/ TransmissionMode *pTransmissionMode) {
        try {
            if (!pTransmissionMode) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pTransmissionMode = m_XmitMode;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Mode)(/*[in]*/ TransmissionMode NewTransmissionMode) {
		ATL_LOCKT();
        m_XmitMode = NewTransmissionMode;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_OtherFrequencyInUse)(/*[out, retval]*/ VARIANT_BOOL *pOtherFrequencyInUse) {
        try {
            if (!pOtherFrequencyInUse) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pOtherFrequencyInUse = m_OtherFreqInUse;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_OtherFrequencyInUse)(/*[in]*/ VARIANT_BOOL NewOtherFrequencyInUse) {
		ATL_LOCKT();
        m_OtherFreqInUse = NewOtherFrequencyInUse;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (ILocator **ppNew) {
		try {
			if (!ppNew) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppNew);
			if (FAILED(hr)) {
				return hr;
			}
            T* pt = static_cast<T*>(*ppNew);
			pt->m_Bandwidth = m_Bandwidth;
	        pt->m_LPInnerFECMethod = m_LPInnerFECMethod;;
            pt->m_LPInnerFECRate = m_LPInnerFECRate;
			pt->m_HAlpha = m_HAlpha;
			pt->m_GuardInterval = m_GuardInterval;
			pt->m_XmitMode = m_XmitMode;
			pt->m_OtherFreqInUse = m_OtherFreqInUse;

    

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

typedef CComQIPtr<IDVBTLocator> PQDVBTLocator;

}; // namespace

#endif // DVBTLOCATORIMPL_H
// end of file -- DVBTLocatorimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\encoderimpl.h ===
//==========================================================================;
//
// encoderimpl.h : additional infrastructure to support implementing IMSVidEncoder
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef ENCODERIMPL_H
#define ENCODERIMPL_H

#include "featureimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidEncoder>
    class DECLSPEC_NOVTABLE IMSVidEncoderImpl : public IMSVidFeatureImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:
	    virtual ~IMSVidEncoderImpl() {}
};

}; /// namespace

#endif
// end of file - encoderimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\dvbtsimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBtsimpl.h : 
// Copyright (c) Microsoft Corporation 1999.

#ifndef DVBTSIMPL_H
#define DVBTSIMPL_H

#include "tuningspaceimpl.h"
#include "dvbTuneRequest.h"

namespace BDATuningModel {

template<class T,
         class TUNEREQUESTTYPE = CDVBTuneRequest,
         class MostDerived = IDVBTuningSpace2, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IDVBTuningSpaceImpl : 
	public ITuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, LibID, wMajor, wMinor, tihclass>,
    public IMPEG2TuneRequestSupport
{

public:

    DVBSystemType m_SystemType;
    long m_NetworkID;

    IDVBTuningSpaceImpl(DVBSystemType systypei = DVB_Cable) : m_SystemType(systypei), m_NetworkID(-1) {}
    virtual ~IDVBTuningSpaceImpl() {}
    typedef ITuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    
    BEGIN_PROP_MAP(IDVBTuningSpaceImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("System Type", m_SystemType, VT_I4)
        PROP_DATA_ENTRY("Network ID", m_NetworkID, VT_I4)
    END_PROPERTY_MAP()

// IDVBTS
    STDMETHOD(get_SystemType)(DVBSystemType *pSysType)
    {
        if (!pSysType) {
            return E_POINTER;
        }
		ATL_LOCKT();
        *pSysType = m_SystemType;

	    return NOERROR;
    }

    STDMETHOD(put_SystemType)(DVBSystemType NewSysType)
    {
		ATL_LOCKT();
        m_SystemType = NewSysType;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_NetworkID)(long *pNetID)
    {
        if (!pNetID) {
            return E_POINTER;
        }
		ATL_LOCKT();
        *pNetID = m_NetworkID;

	    return NOERROR;
    }

    STDMETHOD(put_NetworkID)(long NewNetID)
    {
		ATL_LOCKT();
        m_NetworkID = NewNetID;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    // override standard ITuningSpaceImpl
    STDMETHOD(put_DefaultLocator)(ILocator *pLoc) {
		ATL_LOCKT();
        if (pLoc) {
            switch (m_SystemType) {
            case DVB_Terrestrial: {
                PQDVBTLocator p(pLoc);
                if (!p) {
                    return DISP_E_TYPEMISMATCH;
                }
                break;
            } 
            case DVB_Satellite: {
                PQDVBSLocator p(pLoc);
                if (!p) {
                    return DISP_E_TYPEMISMATCH;
                }
                break;
            }
            case DVB_Cable:
                // dvb cable locator is same as base locator
            default:
                break;
            };
        }
        return basetype::put_DefaultLocator(pLoc);
    }
    STDMETHOD(Clone) (ITuningSpace **ppTS) {
        try {
			if (!ppTS) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTS);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppTS);
            pt->m_SystemType = m_SystemType;
            pt->m_NetworkID = m_NetworkID;
			return NOERROR;
        } CATCHCOM_CLEANUP(if (*ppTS) {
                               (*ppTS)->Release();
                               *ppTS = NULL;
                           }
                          );
	}

};

}; // namespace

#endif // DVBTSIMPL_H
// end of file -- DVBtsimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\dvbtunerequestimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTuneRequestimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef DVBTUNEREQUESTIMPL_H
#define DVBTUNEREQUESTIMPL_H

#include <tune.h>
#include "tunerequestimpl.h"

typedef CComQIPtr<IDVBTLocator> PQDVBTLocator;
typedef CComQIPtr<IDVBSLocator> PQDVBSLocator;

namespace BDATuningModel {

template<class T,
         class MostDerived = IDVBTuneRequest, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IDVBTuneRequestImpl : 
	public ITuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IDVBTuneRequest
public:
    typedef ITuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;

	IDVBTuneRequestImpl() : m_ONID(-1), m_TSID(-1), m_SID(-1){}
    virtual ~IDVBTuneRequestImpl() {}
    BEGIN_PROP_MAP(IDVBTuneRequestImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Original Network ID", m_ONID, VT_I4)
        PROP_DATA_ENTRY("Transport Stream ID", m_TSID, VT_I4)
        PROP_DATA_ENTRY("Service ID", m_SID, VT_I4)
    END_PROP_MAP()

	long m_ONID;
	long m_TSID;
	long m_SID;

    STDMETHOD(get_ONID)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_ONID;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_ONID)(long newVal)
    {
		ATL_LOCKT();
        m_ONID = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_TSID)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_TSID;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_TSID)(long newVal)
    {
		ATL_LOCKT();
        m_TSID = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_SID)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_SID;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_SID)(long newVal)
    {
		ATL_LOCKT();
        m_SID = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

	STDMETHOD(Clone) (ITuneRequest **ppTR) {
		try {
			if (!ppTR) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTR);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppTR);
			pt->m_ONID = m_ONID;
			pt->m_TSID = m_TSID;
			pt->m_SID = m_SID;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

    STDMETHOD(put_Locator)(ILocator *pLocator)
    {
        try {
			ATL_LOCKT();
            if (pLocator) {
                TNDVBTuningSpace ts(m_TS);
                if (!ts) {
                    return E_UNEXPECTED;
                }
                DVBSystemType st = ts.SystemType();
                switch (st) {
                case DVB_Terrestrial: {
                    PQDVBTLocator l(pLocator);
                    if (!l) {
                        return DISP_E_TYPEMISMATCH;
                    }
                    break;
                }
                case DVB_Satellite: {
                    PQDVBSLocator l(pLocator);
                    if (!l) {
                        return DISP_E_TYPEMISMATCH;
                    }
                    break;
                }
                case DVB_Cable:
                    //dvb c locator is same as base ILocator
                default: {

                }}
            }
            return basetype::put_Locator(pLocator);
        } catch (...) {
            return E_POINTER;
        }
    }


};

}; // namespace

#endif // DVBTUNEREQUESTIMPL_H
// end of file -- atschchanneltunerequestimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\errsupp.h ===
/////////////////////////////////////////////////////////////////////////////////////
// errsupp.h : error reporting for implementation helper templates
// Copyright (c) Microsoft Corporation 1999-2000.

#ifndef ERRSUPP_H
#define ERRSUPP_H
#include <winbase.h>
#pragma once

namespace BDATuningModel {
inline HRESULT WINAPI ImplReportError(const CLSID& clsid, UINT nID, const IID& iid,
	HRESULT hRes, HINSTANCE hInst = _Module.GetResourceInstance(), ...)
{    
	va_list arguments;
	va_start(arguments, hInst);
	return AtlSetErrorInfo(clsid, nID, iid, hRes, hInst, &arguments);
}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\featureimpl.h ===
//==========================================================================;
//
// featureimpl.h : additional infrastructure to support implementing IMSVidFeatureDevice
// nicely from c++
// Copyright (c) Microsoft Corporation 2000.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef FEATUREIMPL_H
#define FEATUREIMPL_H

#include "devimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID Category, class MostDerivedInterface = IMSVidFeatureDevice>
    class DECLSPEC_NOVTABLE IMSVidFeatureImpl : public IMSVidDeviceImpl<T, LibID, Category, MostDerivedInterface> {
public:
};

}; // namespace

#endif
// end of file - featureimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\fwdseq.h ===
//==========================================================================;
//
// fwdseq.h : forward sequence infrastructure to extend the dshow stuff so that it
// works nicely from c++
// Copyright (c) Microsoft Corporation 1995-1999.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef FWDSEQ_H
#define FWDSEQ_H

#include <arity.h>

template<class Base, class Enumerator_Type, class Value_Type,
         class Base_Inner = Base,
         class Enumerator_Type_Inner = Enumerator_Type,
         class Value_Type_Inner = Value_Type,
         class Allocator = typename Value_Type::stl_allocator>  class Forward_Sequence;

// NOTE: all of this stuff with the indirected static templated functions for fetch, reset, next
// is to get around an assortment of compiler bugs.
// a) you can't have a pointer to a member function as a template parm if it references earlier template parms
// b) in the initializations of these fetch,reset,next functions if we globally initialize the
// constructor isn't getting called and the vtable isn't set up.  hence we create them off the
// heap at runtime.

// enumerator_iterator
// this is an stl based forward iterator for dealing with legacy com enumerators with no prev method
template<
    class Enumerator_Type,
    class Value_Type,
    class Enumerator_Type_Inner = Enumerator_Type,
    class Value_Type_Inner = Value_Type,
    class difference_type = ptrdiff_t
    > class enumerator_iterator : public std::iterator<std::forward_iterator_tag, Value_Type, difference_type> {
public:
    // these are for com enumerators so use __stdcall version of binders
    static std_arity0pmf<Enumerator_Type_Inner, HRESULT> *Reset;
    static std_arity1pmf<Enumerator_Type_Inner, Value_Type_Inner *, HRESULT> *Next;

        inline enumerator_iterator(const Enumerator_Type e = Enumerator_Type(), const Value_Type c = Value_Type()) : enumerator_state(e), current_value(c) {
                if (enumerator_state != NULL) {
                        if (!current_value) {
#ifdef FORWARD_TRACE
                TRACELM(TRACE_PAINT, "enumerator_iterator constructor, attempting reset");
#endif
                                Enumerator_Type_Inner *peti = enumerator_state;
                                HRESULT hr = (*Reset)(*peti);
                                if (SUCCEEDED(hr)) {
                                        Value_Type temp_val;
#ifdef FORWARD_TRACE
                    TRACELM(TRACE_PAINT, "enumerator_iterator constructor, attempting next()");
#endif
                                        hr = (*Next)(*peti, &temp_val);
                                        if (SUCCEEDED(hr) && hr != S_FALSE) {
                                                current_value = temp_val;
#ifdef FORWARD_TRACE
                                                TRACELSM(TRACE_PAINT, (dbgDump << "enumerator_iterator constructor, set to first value = " << current_value), "");
#endif
                                        }
#ifdef FORWARD_TRACE
                                TRACELSM(TRACE_PAINT, (dbgDump << "enumerator_iterator constructor, next() hr = " << hr), "");
#endif
                                }
                        }
                } else {
                        current_value = Value_Type();
                }
#ifdef FORWARD_TRACE
        TRACELM(TRACE_PAINT, "enumerator_iterator constructor complete");
#endif
        }
        inline enumerator_iterator(const enumerator_iterator &e) : enumerator_state(e.enumerator_state), current_value(e.current_value) {}

        inline Value_Type operator*() const     { return current_value; }
        inline enumerator_iterator& operator++() {
                if (enumerator_state) {
                        Value_Type temp_val;
                        Enumerator_Type_Inner *peti = enumerator_state;
                        HRESULT hr = (*Next)(*peti, &temp_val);
                        if (SUCCEEDED(hr) && (hr != S_FALSE)) {
                                current_value = temp_val;
                        } else {
                                current_value = Value_Type();
                        }
                } else {
                        current_value = Value_Type();
                }
                return (*this);
        }
        inline enumerator_iterator operator++(int)      {
                enumerator_iterator Tmp = *this;
                ++*this;
                return (Tmp);
        }
        inline enumerator_iterator& operator=(const enumerator_iterator &e) {
                if (&e != this) {
                        enumerator_state = e.enumerator_state;
                        current_value = e.current_value;
                }
                return *this;
        }
        inline bool operator==(const enumerator_iterator& e) const {
#ifdef FORWARD_TRACE
                TRACELSM(TRACE_PAINT, (dbgDump << "enumerator_iterator operator==() current_value = " << current_value << " e.current_value = " << e.current_value), "");
#endif
                return (current_value == e.current_value);
        }
        inline bool operator!=(const enumerator_iterator& e) const
                {return (!(*this == e)); }
        inline Value_Type CurrentValue() const
                {return current_value; }
        protected:
                Enumerator_Type enumerator_state;
                Value_Type current_value;
};

// const_enumerator_iterator
template<class Enumerator_Type, class Value_Type,
                 class Enumerator_Type_Inner = Enumerator_Type,
                 class Value_Type_Inner = Value_Type,
                 class difference_type = ptrdiff_t> class const_enumerator_iterator :
                        public enumerator_iterator<Enumerator_Type, 
                                                   Value_Type,                                                                           
                                                   Enumerator_Type_Inner, 
                                                   Value_Type_Inner, 
                                                   difference_type> {
public:
        inline const_enumerator_iterator(const Enumerator_Type e = Enumerator_Type(), const Value_Type c = Value_Type()) :
                enumerator_iterator<Enumerator_Type, 
                                    Value_Type,
                                    Enumerator_Type_Inner, 
                                    Value_Type_Inner, 
                                    difference_type>(e, c) {}
        inline const_enumerator_iterator(const enumerator_iterator<Enumerator_Type, 
                                                                   Value_Type,
                                                                   Enumerator_Type_Inner,
                                                                   Value_Type_Inner, 
                                                                   difference_type> &e) :
                enumerator_iterator<Enumerator_Type, 
                                    Value_Type,
                                    Enumerator_Type_Inner, 
                                    Value_Type_Inner, 
                                    difference_type>(e) {}
        inline const_enumerator_iterator(const const_enumerator_iterator &e) :
                        enumerator_iterator<Enumerator_Type, 
                                            Value_Type,
                                            Enumerator_Type_Inner, 
                                            Value_Type_Inner, 
                                            difference_type>(e) {}
        inline const Value_Type operator*() const {
        return enumerator_iterator<Enumerator_Type, 
                                   Value_Type,
                                   Enumerator_Type_Inner,
                                   Value_Type_Inner, 
                                   difference_type>::operator*(); }
        inline const_enumerator_iterator& operator=(const const_enumerator_iterator &e) {
                if (&e != this) {
                        enumerator_iterator<Enumerator_Type, 
                                            Value_Type,
                                            Enumerator_Type_Inner,
                                            Value_Type_Inner, 
                                            difference_type>::operator=(e);
                }
                return *this;
        }
};

// this is a stl based template for containing legacy com collections
// this is *almost* a standard stl sequence container class.  the reason its
// not a complete sequence container is because for many of the com enumerators we have no prev method
// and therefore, no efficient way of reverse iterating through the collection.
// so we can't provide a bidirectional iterator only a forward one.
// call this a forward sequence container if you will

// Base is smart pointer wrapper class being contained in this container
// Base_Inner is actual wrapped class that the smart pointer class contains(usually com IXXX).
// if you're making a forward_sequence out of some ordinary class instead of a smart pointer class
// then use the default and make both Base_Inner == Base
template<
    class Base,
    class Enumerator_Type,
    class Value_Type,
    class Base_Inner /*= Base */,
    class Enumerator_Type_Inner /*= Enumerator_Type */,
    class Value_Type_Inner /*= Value_Type */,
    class Allocator /*= Value_Type::stl_allocator */
>  class Forward_Sequence : public Base {
public:

    Forward_Sequence(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) : Base(rclsid, pUnkOuter, dwClsContext) {}
    virtual ~Forward_Sequence() {}

    typedef typename Allocator::value_type value_type;
        typedef typename Allocator::value_type& reference;
        typedef const typename Allocator::value_type& const_reference;
        typedef typename Allocator::size_type size_type;
        typedef typename Allocator::difference_type difference_type;



    // the compiler doesn't recognize this typedef in this template.  but, derived classes
    // can refer to it.
    typedef std_arity1pmf<Base_Inner, Enumerator_Type_Inner **, HRESULT> FetchType;

    static FetchType* Fetch;

    virtual FetchType* GetFetch() const {
        return Fetch;
    }

        typedef enumerator_iterator<Enumerator_Type, 
                                    Value_Type, 
                                    Enumerator_Type_Inner, 
                                    Value_Type_Inner, 
                                    difference_type> iterator;
        friend iterator;

        typedef const_enumerator_iterator<Enumerator_Type, 
                                          Value_Type, 
                                          Enumerator_Type_Inner, 
                                          Value_Type_Inner, 
                                          difference_type> const_iterator;
        friend const_iterator;

        Forward_Sequence() {}
        Forward_Sequence(const Forward_Sequence &a) : Base(a) { }
        Forward_Sequence(const Base &a) : Base(a) {}
        Forward_Sequence(Base_Inner *p) : Base(p) {}
		Forward_Sequence(IUnknown *p) : Base(p) {}
        iterator begin() {
                Enumerator_Type temp_enum;
                if (!(*this)) {
                    return iterator();
                }
#ifdef FORWARD_TRACE
        TRACELM(TRACE_DETAIL, "iterator ForwardSequence::begin() attempting fetch");
#endif
        Base_Inner *peti = *this;
        HRESULT hr = (*(GetFetch()))(*peti, &temp_enum);
                if (SUCCEEDED(hr)) {
#ifdef FORWARD_TRACE
            TRACELM(TRACE_DETAIL, "iterator ForwardSequence::begin() fetch succeeded");
#endif
                        return iterator(temp_enum);
                } else {
#ifdef FORWARD_TRACE
            TRACELM(TRACE_DETAIL, "iterator ForwardSequence::begin() fetch failed");
#endif
                        return iterator();
                }
        }
        const_iterator begin() const {
                Enumerator_Type temp_enum;
#ifdef FORWARD_TRACE
        TRACELM(TRACE_DETAIL, "const_iterator ForwardSequence::begin() attempting fetch");
#endif
        Base_Inner *peti = *this;
                HRESULT hr = (*(GetFetch()))(*peti, &temp_enum);
                if (SUCCEEDED(hr)) {
#ifdef FORWARD_TRACE
            TRACELM(TRACE_DETAIL, "const_iterator ForwardSequence::begin() fetch succeeded");
#endif
            return iterator(temp_enum);
                } else {
#ifdef FORWARD_TRACE
            TRACELM(TRACE_DETAIL, "const_iterator ForwardSequence::begin() fetch failed");
#endif
                        return iterator();
                }
        }

        iterator end() {
#ifdef FORWARD_TRACE
            TRACELM(TRACE_DETAIL, "iterator ForwardSequence::end()");
#endif
            return iterator();
        }
        const_iterator end() const { return const_iterator(); }

};


#endif
// end of file fwdseq.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\fileplaybackimpl.h ===
//==========================================================================;
//
// fileplaybackimpl.h : additional infrastructure to support implementing IMSVidPlayback
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef FILEPLAYBACKIMPL_H
#define FILEPLAYBACKIMPL_H
#include "playbackimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidFilePlayback>
    class DECLSPEC_NOVTABLE IMSVidFilePlaybackImpl :         
    	public IMSVidPlaybackImpl<T, LibID, KSCategory, MostDerivedInterface> {
protected:
    CComBSTR m_FileName;
    int m_iReader;
    bool m_fGraphInit;

public:
    IMSVidFilePlaybackImpl() : 
          m_iReader(-1),
          m_fGraphInit(false)
          {}
	
    virtual ~IMSVidFilePlaybackImpl() {} 


	STDMETHOD(get_FileName)(BSTR * pFileName) {
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
        if (!pFileName) {
			return E_POINTER;
        }
			
        *pFileName = m_FileName.Copy();

		return NOERROR;
	}
    STDMETHOD(InitGraph)(){
        TRACELM(TRACE_DETAIL,  "MSVidFilePlaybackImpl::InitGraph()");
        HRESULT hr = put_CurrentPosition(0);
        if(FAILED(hr)){
            //ASSERT(SUCCEEDED(hr)); // This fails sometimes, we should just ignore it.
            TRACELM(TRACE_ERROR,  "MSVidFilePlaybackImpl::InitGraph() put_CurrentPosition(0) failed");
        }

        hr = put_Rate(1);
        if(FAILED(hr)){
            //ASSERT(SUCCEEDED(hr)); // This fails sometimes, we should just ignore it.
            TRACELM(TRACE_ERROR,  "MSVidFilePlaybackImpl::InitGraph() put_Rate(1) Normal failed");
        }
        hr = IMSVidPlaybackImpl<T, LibID, KSCategory, MostDerivedInterface>::put_Rate(1);
        if(FAILED(hr)){
            //ASSERT(SUCCEEDED(hr)); // This fails sometimes, we should just ignore it.
            TRACELM(TRACE_ERROR,  "MSVidFilePlaybackImpl::InitGraph() put_Rate(1) Base class failed");
        }
        return NOERROR;
    }
    STDMETHOD(put_FileName) (BSTR FileName) {
	    if (!FileName) {
		    return E_POINTER;
	    }
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
        try {
            HRESULT hr;
            TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlaybackImpl::put_FileName() name =  " << FileName), "");
            if (m_pGraph && !m_pGraph.IsStopped()) {
	            return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidFilePlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            if (m_pContainer) {
                InitGraph();
                
                T* pT = static_cast<T*>(this);
                hr = m_pContainer->Decompose(pT);
                if (FAILED(hr)) {
                    return ImplReportError(__uuidof(T), IDS_CANT_REMOVE_SEG, __uuidof(IMSVidFilePlayback), hr);
                }
            }
            if (m_Filters.size() && m_pContainer) {
                for (DSFilterList::iterator i = m_Filters.begin(); i != m_Filters.end(); ++i) {
                    bool rc = m_pGraph.RemoveFilter(*i);
                    if (!rc) {
                        TRACELM(TRACE_ERROR,  "MSVidFilePlaybackImpl::put_FileName() can't remove filter");
			            return ImplReportError(__uuidof(T), IDS_CANT_REMOVE_FILTER, __uuidof(IMSVidFilePlayback), E_UNEXPECTED);
                    }
                }
                m_Filters.clear();
            }
                        
            m_FileName = FileName;
            m_fGraphInit = true;
        } catch(ComException &e) {
            m_Filters.clear();
            m_iReader = -1;
            return e;
        }

        return NOERROR;
    }
};

}; // namespace

#endif
// end of file - fileplaybackimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\filterenum.h ===
//////////////////////////////////////////
// filters.h : header for CFilters IEnumFilters implementation on 
// top of stl vector of filters
// copyright (c) 1999 Microsoft Corp.

#pragma once

#ifndef FILTERS_H_
#define FILTERS_H_

#include <vector>
#include <dsextend.h>
#include <objectwithsiteimplsec.h>

class ATL_NO_VTABLE CFilterEnumOnDSFilterListBase : public CComObjectRootEx<CComSingleThreadModel>,
	public IEnumFilters,
    public IObjectWithSiteImplSec<CFilterEnumOnDSFilterListBase>
{
    BEGIN_COM_MAP(CFilterEnumOnDSFilterListBase)
	    COM_INTERFACE_ENTRY(IEnumFilters)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    virtual ~CFilterEnumOnDSFilterListBase() {}
};

/////////////////////////////////////////////////////////////////////////////
// CFilters
class CFilterEnumOnDSFilterList : public CComObject<CFilterEnumOnDSFilterListBase>
{
public:
	CFilterEnumOnDSFilterList(DSFilterList &Fi) : m_Filters(Fi) {
        i = m_Filters.begin();
	}
	CFilterEnumOnDSFilterList(CFilterEnumOnDSFilterList &orig) : m_Filters(orig.m_Filters) {
        i = m_Filters.begin();
        DSFilterList::iterator i2 = orig.m_Filters.begin();
        for (; i2 != orig.i && i2 != orig.m_Filters.end(); ++i, ++i2);
	}

    virtual ~CFilterEnumOnDSFilterList() {
        m_Filters.clear();
    }


// IDevEnum
public:
	DSFilterList m_Filters;
	DSFilterList::iterator i;
// IEnumVARIANT
	STDMETHOD(Next)(ULONG celt, IBaseFilter **pOutF, ULONG * pceltFetched)
	{
		// pceltFetched can legally == 0
		//
		if (pceltFetched != NULL) {
			try {
				*pceltFetched = 0;
			} catch(...) {
				return E_POINTER;
			}
		}
	    HRESULT hr = NOERROR ;
		try {
		    // Retrieve the next celt elements.
		    for (;i != m_Filters.end() && celt != 0; ++i, --celt, ++pOutF) {
			    hr = (*i).CopyTo(pOutF);
                if (FAILED(hr)){
                    return hr;
                }
			    if (pceltFetched != NULL) {
				    (*pceltFetched)++ ;
			    }
		    }
		} catch(...) {
			return E_POINTER;
		}
		if (celt != 0) {
		   hr = ResultFromScode( S_FALSE ) ;
		}
		return hr;
	}
	STDMETHOD(Skip)(ULONG celt)
	{        
		for (;i != m_Filters.end() && celt--; ++i);
		return (celt == 0 ? NOERROR : ResultFromScode( S_FALSE )) ;
	}
	STDMETHOD(Reset)()
	{
		i = m_Filters.begin();
		return NOERROR;
	}
	STDMETHOD(Clone)(IEnumFilters **ppenum)
	{
		if (ppenum == NULL)
			return E_POINTER;
		PQEnumFilters temp;
		try {
			temp = new CFilterEnumOnDSFilterList(*this);
		} catch(...) {
			return E_OUTOFMEMORY;
		}
		try {
			*ppenum = temp.Detach();
		} catch(...) {
			return E_POINTER;
		}
		return NOERROR;
	}
};

#endif 
//end of file filters.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\inputimpl.h ===
//==========================================================================;
//
// inputimpl.h : additional infrastructure to support implementing IMSVidInputDevice
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef INPUTIMPL_H
#define INPUTIMPL_H

#include "devimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID Category, class MostDerivedInterface = IMSVidInputDevice>
    class DECLSPEC_NOVTABLE IMSVidInputDeviceImpl : public IMSVidDeviceImpl<T, LibID, Category, MostDerivedInterface> {
public:
};

}; // namespace

#endif
// end of file - inputimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\languagecomponenttypeimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// LanguageComponentTypeimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef LANGUAGECOMPONENTTYPEIMPL_H
#define LANGUAGECOMPONENTTYPEIMPL_H

#include "componenttypeimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = ILanguageComponentType, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE ILanguageComponentTypeImpl : 
	public IComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// ILanguageComponentType
public:
    long m_LangID;

    ILanguageComponentTypeImpl() : m_LangID(-1) {}
    virtual ~ILanguageComponentTypeImpl() {}
//    typedef ILanguageComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
    typedef IComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    BEGIN_PROP_MAP(ILanguageComponentTypeImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Content LangID", m_LangID, VT_I4)
    END_PROP_MAP()

    STDMETHOD(get_LangID)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_LangID;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_LangID)(long newVal)
    {
		ATL_LOCKT();
        m_LangID = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (IComponentType **ppCT) {
		try {
			if (!ppCT) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppCT);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppCT);
			pt->m_LangID = m_LangID;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};

}; // namespace

#endif // LANGUAGECOMPONENTTYPEIMPL_H
// end of file -- languagecomponenttypeimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\locatorimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// Locatorimpl.h : implementation helper template for locator interface
// Copyright (c) Microsoft Corporation 2000.

#ifndef LOCATORIMPL_H
#define LOCATORIMPL_H

namespace BDATuningModel {

template<class T,
         class MostDerived = ILocator, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE ILocatorImpl : 
    public IPersistPropertyBagImpl<T>,
	public IDispatchImpl<MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// ILocator
public:

	long m_Frequency;
	FECMethod m_InnerFECMethod;
	BinaryConvolutionCodeRate m_InnerFECRate;
	FECMethod m_OuterFECMethod;
	BinaryConvolutionCodeRate m_OuterFECRate;
	ModulationType m_Modulation;
    long m_SymbolRate;

    ILocatorImpl() : m_Frequency(-1),
 	                 m_InnerFECMethod(BDA_FEC_METHOD_NOT_SET),
 	                 m_InnerFECRate(BDA_BCC_RATE_NOT_SET),
 	                 m_OuterFECMethod(BDA_FEC_METHOD_NOT_SET),
	                 m_OuterFECRate(BDA_BCC_RATE_NOT_SET),
	                 m_SymbolRate(-1),
                     m_Modulation(BDA_MOD_NOT_SET) {}
    virtual ~ILocatorImpl() {}
    typedef ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
    BEGIN_PROP_MAP(thistype)
        PROP_DATA_ENTRY("Frequency", m_Frequency, VT_I4)
        PROP_DATA_ENTRY("InnerFECMethod", m_InnerFECMethod, VT_I4)
        PROP_DATA_ENTRY("InnerFECRate", m_InnerFECRate, VT_I4)
        PROP_DATA_ENTRY("OuterFECMethod", m_OuterFECMethod, VT_I4)
        PROP_DATA_ENTRY("OuterFECRate", m_OuterFECRate, VT_I4)
        PROP_DATA_ENTRY("ModulationType", m_Modulation, VT_I4)
        PROP_DATA_ENTRY("SymbolRate", m_SymbolRate, VT_I4)
    END_PROP_MAP()

// ILocator
public:
    STDMETHOD(get_CarrierFrequency)(/*[out, retval]*/ long *pFrequency) {
        try {
            if (!pFrequency) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pFrequency = m_Frequency;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_CarrierFrequency)(/*[in]*/ long NewFrequency) {
		ATL_LOCKT();
        m_Frequency = NewFrequency;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_InnerFEC)(/*[out, retval]*/ FECMethod *pFEC) {
        try {
            if (!pFEC) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pFEC = m_InnerFECMethod;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_InnerFEC)(/*[in]*/ FECMethod NewFEC) {
		ATL_LOCKT();
        m_InnerFECMethod = NewFEC;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_InnerFECRate)(/*[out, retval]*/ BinaryConvolutionCodeRate *pFECRate) {
        try {
            if (!pFECRate) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pFECRate = m_InnerFECRate;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_InnerFECRate)(/*[in]*/ BinaryConvolutionCodeRate NewFECRate) {
		ATL_LOCKT();
        m_InnerFECRate = NewFECRate;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_OuterFEC)(/*[out, retval]*/ FECMethod *pFEC) {
        try {
            if (!pFEC) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pFEC = m_OuterFECMethod;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_OuterFEC)(/*[in]*/ FECMethod NewFEC) {
		ATL_LOCKT();
        m_OuterFECMethod = NewFEC;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_OuterFECRate)(/*[out, retval]*/ BinaryConvolutionCodeRate *pFECRate) {
        try {
            if (!pFECRate) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pFECRate = m_OuterFECRate;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_OuterFECRate)(/*[in]*/ BinaryConvolutionCodeRate NewFECRate) {
		ATL_LOCKT();
        m_OuterFECRate = NewFECRate;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Modulation)(/*[out, retval]*/ ModulationType* pModulation) {
        try {
            if (!pModulation) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pModulation = m_Modulation;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Modulation)(/*[in]*/ ModulationType NewModulation) {
		ATL_LOCKT();
        m_Modulation = NewModulation;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_SymbolRate)(/*[out, retval]*/ long* pSymbolRate) {
        try {
            if (!pSymbolRate) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pSymbolRate = m_SymbolRate;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_SymbolRate)(/*[in]*/ long NewSymbolRate) {
		ATL_LOCKT();
        m_SymbolRate = NewSymbolRate;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (ILocator **ppL) {
		try {
			if (!ppL) {
				return E_POINTER;
			}
			ATL_LOCKT();
			T* pt = static_cast<T*>(new CComObject<T>);
			if (!pt) {
				return E_OUTOFMEMORY;
			}
			pt->m_Frequency = m_Frequency;
			pt->m_InnerFECMethod = m_InnerFECMethod;
			pt->m_InnerFECRate = m_InnerFECRate;
			pt->m_OuterFECMethod = m_OuterFECMethod;
			pt->m_OuterFECRate = m_OuterFECRate;
			pt->m_Modulation = m_Modulation;
            pt->m_SymbolRate = m_SymbolRate;
			pt->m_bRequiresSave = true;
			pt->AddRef();
			*ppL = pt;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

}; // namespace

#endif // LOCATORIMPL_H
// end of file -- locatorimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\ksextend.h ===
//==========================================================================;
//
// ksextend.h : additional infrastructure to extend the ks stuff so that it
// works nicely from c++
// Copyright (c) Microsoft Corporation 1995-1997.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef KSEXTEND_H
#define KSEXTEND_H

#include <strmif.h>
#include <uuids.h>

#include <ks.h>
#include <ksmedia.h>
//NOTE: ksproxy won't define IKsPin without __STREAMS__ and then it requires CMediaType from 
// mtype.h
#define __STREAMS__
// for some reason in the area of media types the am guys have severely blurred the distinction
// between their public client interface for apps and their internal class hierarchy for building
// filters.  mtype.h and mtype.cpp should be combined and placed into \sdk\include instead of
// classes\base\include.  they should also put an ifdef MMSYSTEM_H around their definitions
// that use WAVEFORMATEX, so its not necessary to put all that stuff into your app if you're not
// using it.  to work around this i'm using the following hack:
#include <mtype.h>

#include <ksproxy.h>
#include <stextend.h>
#include <w32extend.h>

const int KSMEDIUM_INPUTFLAG = 0x1;
typedef unsigned char UBYTE;

typedef CComQIPtr<IKsPropertySet, &IID_IKsPropertySet> PQKSPropertySet;
typedef CComQIPtr<IKsPin, &__uuidof(IKsPin)> PQKSPin;

class KSPinMedium : public KSIDENTIFIER {
public:
    KSPinMedium() { memset(this, 0, sizeof(*this)); }
    KSPinMedium(REFGUID SetInit, ULONG IdInit, ULONG FlagsInit) {
        Set = SetInit;
        Id = IdInit;
        Flags = FlagsInit;
    }
    KSPinMedium(const KSPinMedium &rhs) {
        Set = rhs.Set;
        Id = rhs.Id;
        Flags = rhs.Flags;
    }
    KSPinMedium(const KSIDENTIFIER &rhs) {
        Set = rhs.Set;
        Id = rhs.Id;
        Flags = rhs.Flags;
    }

    KSPinMedium& operator=(const KSPinMedium &rhs) {
        if (&rhs != this) {
            Set = rhs.Set;
            Id = rhs.Id;
            Flags = rhs.Flags;
        }
        return *this;
    }

#if 0
    // hopefully we can get the ks guys to fix their anonymous union problem
    // so that we don't need this hack
    operator KSIDENTIFIER() { return *(reinterpret_cast<KSIDENTIFIER*>(this)); }
#endif

    KSPinMedium& operator=(const KSIDENTIFIER &rhs) {
        if (&rhs != reinterpret_cast<KSIDENTIFIER*>(this)) {
            Set = rhs.Set;
            Id = rhs.Id;
            Flags = rhs.Flags;
        }
        return *this;
    }
    bool operator==(const KSPinMedium &rhs) const {
        // NOTE: at some point there will be a flag in Flags to
        // indicate whether or not Id is significant for this object
        // at that point this method will need to change
        return (Id == rhs.Id && Set == rhs.Set);
    }
    bool operator!=(const KSPinMedium &rhs) const {
        // NOTE: at some point there will be a flag in Flags to
        // indicate whether or not Id is significant for this object
        // at that point this method will need to change
        return !(*this == rhs);
    }
};


#ifdef _DEBUG
inline tostream &operator<<(tostream &dc, const KSPinMedium &g) {
        GUID2 g2(g.Set);
        dc << _T("KsPinMedium( ");
        g2.Dump(dc);
        dc << _T(", ") << hexdump(g.Id) << _T(", ") << hexdump(g.Flags) << _T(")");
        return dc;
}
#if 0
inline CDumpContext &operator<<(CDumpContext &dc, const KSPinMedium &g) {
        GUID2 g2(g.Set);
        dc << "KsPinMedium( ";
        g2.Dump(dc);
        dc << ", " << hexdump(g.Id) << ", " << hexdump(g.Flags) << ")";
        return dc;
}

template<> struct equal_to<KSPinMedium> {
    bool operator()(const KSPinMedium& _X, const KSPinMedium& _Y) const {
        TraceDump << "equal_to<KSPinMedium> x = " << _X << " y = " << _Y;
                return (_X == _Y);
    }
};
#endif

#endif

const KSPinMedium NULL_MEDIUM(GUID_NULL, 0, 0);
const KSPinMedium HOST_MEMORY_MEDIUM(KSMEDIUMSETID_Standard, 0, 0);

// this is basically a CComQIPtr with appropriate CoMem* allocate/copy semantics
// instead of refcount semantics and without the QI stuff.
class PQKsMultipleItem {
public:
    KSMULTIPLE_ITEM *p;

    PQKsMultipleItem() : p(NULL) {}
    virtual ~PQKsMultipleItem() {
        if (p) {
            CoTaskMemFree(p);
            p = NULL;
        }
    }

    operator KSMULTIPLE_ITEM*() const {return p;}
    KSMULTIPLE_ITEM& operator*() const {_ASSERTE(p!=NULL); return *p; }
    KSMULTIPLE_ITEM ** operator&() {ASSERT(p == NULL); return &p; }
    KSMULTIPLE_ITEM * operator->() const {_ASSERTE(p!=NULL); return p; }
    PQKsMultipleItem * address(void) { return this; }
    const PQKsMultipleItem * const_address(void) const { return this; }

    // this is expensive.  don't do it unless you have to.
    PQKsMultipleItem& operator=(const KSMULTIPLE_ITEM &d) {
        if (&d != p) {
            if (p) {
                CoTaskMemFree(p);
            }
            p = reinterpret_cast<KSMULTIPLE_ITEM *>(CoTaskMemAlloc(d.Size));
            memcpy(p, &d, d.Size);
        }
        return *this;
    }
    PQKsMultipleItem& operator=(const KSMULTIPLE_ITEM *pd) {
        if (pd != p) {
            if (p) {
                CoTaskMemFree(p);
            }
            p = reinterpret_cast<KSMULTIPLE_ITEM *>(CoTaskMemAlloc(pd->Size));
            memcpy(p, pd, pd->Size);
        }
        return *this;
    }
    PQKsMultipleItem& operator=(const PQKsMultipleItem &d) {
        if (d.const_address() != this) {
            if (p) {
                CoTaskMemFree(p);
            }
            p = reinterpret_cast<KSMULTIPLE_ITEM *>(CoTaskMemAlloc(d.p->Size));
            memcpy(p, d.p, d.p->Size);
        }
        return *this;
    }
    PQKsMultipleItem& operator=(int d) {
        if (p) {
            CoTaskMemFree(p);
            p = NULL;
        }
        return *this;
    }

#if 0
    bool operator==(const PQKsMultipleItem &d) const {
        return p->majortype == d.p->majortype &&
               (p->subtype == GUID_NULL || d.p->subtype == GUID_NULL || p->subtype == d.p->subtype);
    }
    bool operator!=(const PQKsMultipleItem &d) const {
        return !(*this == d);
    }
#endif

private:
    // i don't want spend the time to do a layered refcounted implementation here
    // but since these are CoTaskMem alloc'd we can't have multiple ref's without
    // a high risk of leaks.  so we're just going to disallow the copy constructor
    // since copying is expensive anyway.  we will allow explicit assignment which will
    // do a copy

    PQKsMultipleItem(const PQKsMultipleItem &d);

};

// this is a stl based template for containing KSMULTIPLEITEM lists
// i've only implemented the stuff i need for certain of the stl predicates so this
// isn't a complete collection with a true random access or bidirectional iterator
// furthermore this won't work correctly with hterogeneous KSMULTIPLEITEM lists it
// also won't work right for KSMI lists that have sizes and count headers in the sub items.
// it could be easily extended to do all of these things but i don't have time and all
// i need it for is mediums

// Base is smart pointer wrapper class being contained in this container
// Base_Inner is actual wrapped class that the smart pointer class contains
template<class Value_Type, class Allocator = std::allocator<Value_Type> >  class KsMultipleItem_Sequence : public PQKsMultipleItem {
public:

    typedef typename Allocator::value_type value_type;
        typedef typename Allocator::size_type size_type;
        typedef typename Allocator::difference_type difference_type;
        typedef Allocator allocator_type;
    typedef typename Allocator::pointer value_ptr;
    typedef typename Allocator::const_pointer value_cptr;
        typedef typename Allocator::reference reference;
        typedef typename Allocator::const_reference const_reference;


    // CLASS iterator
        class iterator;
        friend class iterator;
        class iterator : public std::_Bidit<Value_Type, difference_type> {
        public:
			iterator(KsMultipleItem_Sequence<Value_Type, Allocator> *outerinit = NULL, value_type *currentinit = NULL) :
				outer(outerinit), current(currentinit) {}
			iterator(iterator &e) : current(e.current), outer(e.outer) {}
			reference operator*() const {return *current;}
			value_ptr operator->() const {return current; }
			iterator& operator++() {
				if (current) {
					current++;
					if (current >= reinterpret_cast<value_type *>(reinterpret_cast<UBYTE *>(outer->p) + outer->p->Size)) {
						current = NULL;
					}
				} else {
					current = reinterpret_cast<value_type *>(const_cast<UBYTE *>(reinterpret_cast<const UBYTE *>(outer->p)) + sizeof(KSMULTIPLE_ITEM));
				}
				return *this;
			}
			iterator& operator++(int) {
				iterator Tmp = *this;
				++*this;
				return Tmp; 
			}
			iterator& operator--() {
				if (current) {
					current--;
					if (current < reinterpret_cast<value_type *>(const_cast<UBYTE *>(reinterpret_cast<const UBYTE *>(outer->p)) + sizeof(KSMULTIPLE_ITEM))) {
						current = NULL;
					}
				} else {
					current = reinterpret_cast<value_type *>(reinterpret_cast<UBYTE *>(outer->p) + (outer->p->Size - sizeof(value_type)));
				}
				return (*this);
			}
			iterator operator--(int) {
				iterator _Tmp = *this;
				--*this;
				return (_Tmp);
			}
			bool operator==(const iterator& rhs) const
					{return (current == rhs.current); }
			bool operator!=(const iterator& rhs) const
					{return (!(*this == rhs)); }
        protected:
			value_type *current;
			const KsMultipleItem_Sequence<Value_Type, Allocator> *outer;
        };
                // CLASS const_iterator
        class const_iterator;
        friend class const_iterator;
        class const_iterator : public iterator {
        public:
			const_iterator(const KsMultipleItem_Sequence<Value_Type, Allocator> *outerinit = NULL, value_type *currentinit = NULL) {
				outer = outerinit;
				current = currentinit;
			}
			const_iterator(const_iterator &e) {
				current = e.current;
				outer = e.outer;
			}
			const_reference operator*() const {return iterator::operator*(); }
			value_cptr operator->() const {return iterator::operator->(); }
			const_iterator& operator++() { iterator::operator++(); return *this;}
			const_iterator operator++(int) {
							const_iterator Tmp = *this;
							++*this;
							return (Tmp);
			}
			const_iterator& operator--() {iterator::operator--(); return (*this); }
			const_iterator operator--(int) {
							const_iterator Tmp = *this;
							--*this;
							return (Tmp); 
			}
            bool operator==(const const_iterator& rhs) const
		        {return iterator::operator==(rhs); }
            bool operator!=(const const_iterator& rhs) const
                {return (!(*this == rhs)); }
        };

		KsMultipleItem_Sequence() {}
		virtual ~KsMultipleItem_Sequence() {}
		iterator begin() {
			return iterator(this, ((p->Count) ? reinterpret_cast<value_ptr>(reinterpret_cast<UBYTE *>(p) + sizeof(KSMULTIPLE_ITEM)) : NULL));
		}
		const_iterator begin() const {
			return const_iterator(this, ((p->Count) ? reinterpret_cast<value_ptr>(reinterpret_cast<UBYTE *>(p) + sizeof(KSMULTIPLE_ITEM)) : NULL));
		}
		iterator end() { return iterator(); }
		const_iterator end() const { return const_iterator(); }
		size_type size() const {
			return p->Count;
		}



private:
    // no copy constructor, its too expensive.  see PQKsMultiple item for further details
        KsMultipleItem_Sequence(KsMultipleItem_Sequence &a);
        KsMultipleItem_Sequence(PQKsMultipleItem &a);

};

typedef KsMultipleItem_Sequence<KSPinMedium> KSMediumList;


#endif
// end of file - ksextend.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\mpeg2componentimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2Componentimpl.h : implementation helper template for MPEG2component interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef MPEG2COMPONENTIMPL_H
#define MPEG2COMPONENTIMPL_H

#include "componentimpl.h"
#include "MPEG2componenttype.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IMPEG2Component, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IMPEG2ComponentImpl : 
	public IComponentImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IMPEG2Component
public:
    long m_PID;
    long m_PCRPID;
	long m_ProgramNumber;

    IMPEG2ComponentImpl() : m_PID(-1),
                            m_PCRPID(-1),
                            m_ProgramNumber(-1) {}
    virtual ~IMPEG2ComponentImpl() {}
    typedef IMPEG2ComponentImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
	typedef IComponentImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    BEGIN_PROP_MAP(thistype)
        CHAIN_PROP_MAP(basetype)		
        PROP_DATA_ENTRY("PID", m_PID, VT_I4)
        PROP_DATA_ENTRY("PCRPID", m_PCRPID, VT_I4)
        PROP_DATA_ENTRY("ProgramNumber", m_ProgramNumber, VT_I4)
    END_PROP_MAP()

// IMPEG2Component
public:
    STDMETHOD(put_Type)(/*[in]*/ IComponentType*  pNewVal) {
        try {
            if (!pNewVal) {
                return E_POINTER;
            }
            PQMPEG2ComponentType pT(pNewVal);
            if (!pT) {
                return DISP_E_TYPEMISMATCH;
            }
            return basetype::put_Type(pNewVal);
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_PID)(/*[out, retval]*/ long *pPID) {
        try {
            if (!pPID) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pPID = m_PID;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_PID)(/*[in]*/ long NewPID) {
		ATL_LOCKT();
        m_PID = NewPID;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_PCRPID)(/*[out, retval]*/ long *pPCRPID) {
        try {
            if (!pPCRPID) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pPCRPID = m_PCRPID;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_PCRPID)(/*[in]*/ long NewPCRPID) {
        m_PCRPID = NewPCRPID;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_ProgramNumber)(/*[out, retval]*/ long *pProgramNumber) {
        try {
            if (!pProgramNumber) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pProgramNumber = m_ProgramNumber;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_ProgramNumber)(/*[in]*/ long NewProgramNumber) {
		ATL_LOCKT();
        m_ProgramNumber = NewProgramNumber;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (IComponent **ppNew) {
		try {
			if (!ppNew) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppNew);
			if (FAILED(hr)) {
				return hr;
			}
            T* pt = static_cast<T*>(*ppNew);
			pt->m_PCRPID = m_PCRPID;
			pt->m_PID = m_PID;
			pt->m_ProgramNumber = m_ProgramNumber;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

}; // namespace
#endif // MPEG2COMPONENTIMPL_H
// end of file -- MPEG2componentimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\mpeg2componenttypeimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2ComponentTypeimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef MPEG2COMPONENTTYPEIMPL_H
#define MPEG2COMPONENTTYPEIMPL_H

#include "languagecomponenttypeimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IMPEG2ComponentType, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IMPEG2ComponentTypeImpl : 
	public ILanguageComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IMPEG2ComponentType
public:
    MPEG2StreamType m_StreamType;

    IMPEG2ComponentTypeImpl() : m_StreamType(BDA_UNITIALIZED_MPEG2STREAMTYPE) {}
    virtual ~IMPEG2ComponentTypeImpl() {}
//    typedef IMPEG2ComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
    typedef ILanguageComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    BEGIN_PROP_MAP(IMPEG2ComponentTypeImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Stream Type", m_StreamType, VT_I4)
    END_PROP_MAP()

    STDMETHOD(get_StreamType)(MPEG2StreamType *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_StreamType;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_StreamType)(MPEG2StreamType newVal)
    {
		ATL_LOCKT();
        m_StreamType = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (IComponentType **ppCT) {
		try {
			if (!ppCT) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppCT);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppCT);
			pt->m_StreamType = m_StreamType;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

}; // namespace

#endif // MPEG2COMPONENTTYPEIMPL_H
// end of file -- MPEG2componenttypeimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\objectwithsiteimplsec.h ===
///////////////////////////////////////////////////////////
// ObjectWithSiteImplSec.h : Secure implementation of IObjectWithSite
// Copyright (c) Microsoft Corporation 2002.

#pragma once

#ifndef OBJECTWITHSITEIMPLSEC_H
#define OBJECTWITHSITEIMPLSEC_H

#include <w32extend.h>

template<class T> 
class ATL_NO_VTABLE IObjectWithSiteImplSec : public IObjectWithSite {

public:

    PUnknown m_pSite;

// IObjectWithSite
    STDMETHOD(GetSite)(REFIID iid, void** ppvSite) {
        if (!ppvSite) {
            return E_POINTER;
        }
		T* pT = static_cast<T*>(this);

        if (!pT->m_pSite) {
            return E_NOINTERFACE;
        }
        return pT->m_pSite->QueryInterface(iid, ppvSite);
    }
    STDMETHOD(SetSite)(IUnknown* pSite) {
        HRESULT hr = IsSafeSite(pSite);
        if (SUCCEEDED(hr)) {
		    T* pT = static_cast<T*>(this);
            pT->m_pSite = pSite;
        }
        return hr;
    }

};

#endif // OBJECTWITHSITEIMPLSEC_H
// end of file objectwithsiteimplsec.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\mpeg2tunerequestimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2TuneRequestimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef MPEG2TUNEREQUESTIMPL_H
#define MPEG2TUNEREQUESTIMPL_H

#include <tune.h>
#include "tunerequestimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IMPEG2TuneRequest, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IMPEG2TuneRequestImpl : 
	public ITuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IMPEG2TuneRequest
public:
	typedef ITuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;

	IMPEG2TuneRequestImpl() : m_TSID(-1), m_ProgNo(-1) {}
	virtual ~IMPEG2TuneRequestImpl() {}
    BEGIN_PROP_MAP(IMPEG2TuneRequestImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("TSID", m_TSID, VT_I4)
        PROP_DATA_ENTRY("ProgNo", m_ProgNo, VT_I4)
    END_PROP_MAP()

	long m_TSID;
    long m_ProgNo;
    STDMETHOD(get_TSID)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_TSID;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_TSID)(long newVal)
    {
		ATL_LOCKT();
		if (!m_TS) {
			return E_UNEXPECTED;
		}
        m_TSID = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_ProgNo)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_ProgNo;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_ProgNo)(long newVal)
    {
		ATL_LOCKT();
		if (!m_TS) {
			return E_UNEXPECTED;
		}
        m_ProgNo = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (ITuneRequest **ppTR) {
		try {
			if (!ppTR) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTR);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppTR);
			pt->m_TSID = m_TSID;
			pt->m_ProgNo = m_ProgNo;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};
typedef CComQIPtr<IMPEG2TuneRequest> PQMPEG2TuneRequest;

}; // namespace

#endif // MPEG2TUNEREQUESTIMPL_H
// end of file -- MPEG2tunerequestimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\objreghelp.h ===
//==========================================================================;
//
// reghelp : registration helpers that share .rgs scripts for various kinds of classes
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#ifndef OBJREGHELP_H_
#define OBJREGHELP_H_

#ifndef _ATL_STATIC_REGISTRY
#error these registration helpers only work when _ATL_STATIC_REGISTRY is defined
#endif

#include <atltmp.h>

// much code copied from atl's statreg.h

// atl middle layers filter out the registry return code and turns everything 
// into DISP_E_EXCEPTION.  by explicitly allocating a CRegObject
// and calling into it instead of through com into atl.dll we can
// trace in and figure out what's wrong with our script when we goof.

#ifndef MAX_GUID_LEN
#define MAX_GUID_LEN (39 * sizeof(OLECHAR))
#endif

__declspec(selectany) LPCOLESTR pszAutoReg = {
L"HKCR { "
	L"%COMPONENT%.%PROGID%.1 = s '%DESCRIPTION%' { "
		L"CLSID = s '%CLSID%' "
    L"} "
	L"%COMPONENT%.%PROGID% = s '%DESCRIPTION%' { "
		L"CLSID = s '%CLSID%' "
		L"CurVer = s '%COMPONENT%.%PROGID%.1' "
	L"} "
	L"NoRemove CLSID { "
		L"ForceRemove %CLSID% = s '%DESCRIPTION%' { "
			L"ProgID = s '%COMPONENT%.%PROGID%.1' "
			L"VersionIndependentProgID = s '%COMPONENT%.%PROGID%' "
			L"ForceRemove 'Programmable' "
			L"InprocServer32 = s '%MODULE%' { "
				L"val ThreadingModel = s '%THREAD%' "
			L"} "
			L"'TypeLib' = s '%TYPELIB%' "
		L"} "
	L"} "
L"} "
};

__declspec(selectany) LPCOLESTR pszNonAutoReg = {
L"HKCR { "
	L"NoRemove CLSID { "
		L"ForceRemove %CLSID% = s '%DESCRIPTION%' { "
			L"InprocServer32 = s '%MODULE%' { "
				L"val ThreadingModel = s '%THREAD%' "
			L"} "
			L"'TypeLib' = s '%TYPELIB%' "
		L"} "
	L"} "
L"} "
};


__declspec(selectany) LPCOLESTR pszFullControl = {
L"HKCR { "
	L"NoRemove CLSID { "
		L"%CLSID% { "
			L"ForceRemove 'Control' "
			L"ForceRemove 'Insertable' "
			L"ForceRemove 'ToolboxBitmap32' = s '%MODULE%, 101' "
			L"'MiscStatus' = s '0' { "
			    L"'1' = s '%OLEMISC%' "
			L"} "
			L"'Version' = s '%VERSION%' "
		L"} "
	L"} "
L"} "
};

__declspec(selectany) LPCOLESTR pszProtocol = {
L"HKCR { "
    L"NoRemove PROTOCOLS { "
		L"NoRemove Handler { "
			L"ForceRemove %PROTOCOL% { "
				L"val '' = s '%DESCRIPTION%' "
				L"val 'CLSID' = s '%CLSID%' "
			L"} "
		L"} "
    L"} "
L"} "
L"HKCU { "
    L"NoRemove Software { "
		L"NoRemove Microsoft { "
			L"NoRemove Windows { "
				L"NoRemove CurrentVersion { "
					L"NoRemove Internet Settings { "
						L"NoRemove ZoneMap { "
							L"NoRemove ProtocolDefaults { "
								L"val '%PROTOCOL%' = d 3 "
							L"} "
						L"} "
					L"} "
				L"} "
			L"} "
		L"} "
    L"} "
L"} "
};

enum MacroNameList {
	mnlModule,
	mnlComponent,
	mnlProgID,
	mnlCLSID,
	mnlDesc,
	mnlTypeLib,
	mnlVersion,
	mnlProtocol,
	mnlOleMisc,
	mnlThread,
};

__declspec(selectany) LPCOLESTR pszMacroNames[] = {
	L"MODULE",
	L"COMPONENT",
	L"PROGID",
	L"CLSID",
	L"DESCRIPTION",
	L"TYPELIB",
	L"VERSION",
	L"PROTOCOL",
	L"OLEMISC",
	L"THREAD",
};

enum ThreadVal {
	tvApartment,
	tvFree,
	tvBoth,
};

__declspec(selectany) LPCOLESTR pszThreadValNames[] = {
	L"Apartment",
	L"Free",
	L"Both",
};

using ::ATL::ATL::CRegObject;

class CObjRegHelp {
public:
	/////////// 
	static HRESULT InsertModuleName(CRegObject& ro) {
		/////////// from AtlLModuleupdate
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(_Module.m_hInst, szModule, _MAX_PATH);

		LPOLESTR pszModule;
		USES_CONVERSION;

		if ((_Module.m_hInst == NULL) || (_Module.m_hInst == GetModuleHandle(NULL))) { // register as EXE
			// Convert to short path to work around bug in NT4's CreateProcess
			TCHAR szModuleShort[_MAX_PATH];
			int cbShortName = GetShortPathName(szModule, szModuleShort, _MAX_PATH);

			if (cbShortName == _MAX_PATH)
				return E_OUTOFMEMORY;

			pszModule = (cbShortName == 0 || cbShortName == ERROR_INVALID_PARAMETER) ? T2OLE(szModule) : T2OLE(szModuleShort);
		} else {
			pszModule = T2OLE(szModule);
		}


		int nLen = ocslen(pszModule);
		LPOLESTR pszModuleQuote = new OLECHAR[nLen*2+1];
        if (!pszModuleQuote) {
            return E_OUTOFMEMORY;
        }
		CComModule::ReplaceSingleQuote(pszModuleQuote, pszModule);
		HRESULT hr = ro.AddReplacement(pszMacroNames[mnlModule], pszModuleQuote);
        delete[] pszModuleQuote;
        return hr;
	}
	/////////// 
	static HRESULT InsertGUID(CRegObject &ro, LPCOLESTR pszMacro, REFCLSID guid) {
			OLECHAR szGUID[MAX_GUID_LEN];
			int rc = StringFromGUID2(guid, szGUID, MAX_GUID_LEN);
			if (!rc) {
				return E_UNEXPECTED;
			}
			return ro.AddReplacement(pszMacro, szGUID);
	}

	/////////// 
	static HRESULT RegisterAutomationClass(bool bRegister,
									CRegObject& ro,
									const UINT nidComponent, 
									const UINT nidProgID, 
									const UINT nidDesc, 
									REFCLSID clsCLSID,
									REFCLSID clsTypeLib,
									ThreadVal tval = tvApartment) {

			USES_CONVERSION;
			// module
			HRESULT hr = InsertModuleName(ro);
			if (FAILED(hr)) {
				return hr;
			}

			// clsid
			hr = InsertGUID(ro, pszMacroNames[mnlCLSID], clsCLSID);
			if (FAILED(hr)) {
				return hr;
			}

			// typelib
			hr = InsertGUID(ro, pszMacroNames[mnlTypeLib], clsTypeLib);
			if (FAILED(hr)) {
				return hr;
			}

			// threading model
			hr = ro.AddReplacement(pszMacroNames[mnlThread], pszThreadValNames[tval]);
			if (FAILED(hr)) {
				return hr;
			}

			// component
			CString cs;
			if (!cs.LoadString(nidComponent)) {
				return E_INVALIDARG;
			}
			hr = ro.AddReplacement(pszMacroNames[mnlComponent], T2COLE(cs));
			if (FAILED(hr)) {
				return hr;
			}

			// progid
			if (!cs.LoadString(nidProgID)) {
				return E_INVALIDARG;
			}
			hr = ro.AddReplacement(pszMacroNames[mnlProgID], T2COLE(cs));
			if (FAILED(hr)) {
				return hr;
			}

			// desc
			if (!cs.LoadString(nidDesc)) {
				return E_INVALIDARG;
			}
			hr = ro.AddReplacement(pszMacroNames[mnlDesc], T2COLE(cs));
			if (FAILED(hr)) {
				return hr;
			}

			if (bRegister) {
				return ro.StringRegister(pszAutoReg);
			} else {
				return ro.StringUnregister(pszAutoReg);
			}
	}

	/////////// 
	static HRESULT RegisterNonAutomationClass(bool bRegister,
				  					   CRegObject& ro,
									   const UINT nidDesc, 
									   REFCLSID clsCLSID,
									   REFCLSID clsTypeLib,
									   ThreadVal tval = tvApartment) {
			// module
			HRESULT hr = InsertModuleName(ro);
			if (FAILED(hr)) {
				return hr;
			}

			// clsid
			hr = InsertGUID(ro, pszMacroNames[mnlCLSID], clsCLSID);
			if (FAILED(hr)) {
				return hr;
			}

			// typelib
			hr = InsertGUID(ro, pszMacroNames[mnlTypeLib], clsTypeLib);
			if (FAILED(hr)) {
				return hr;
			}

			// threading model
			hr = ro.AddReplacement(pszMacroNames[mnlThread], pszThreadValNames[tval]);
			if (FAILED(hr)) {
				return hr;
			}

			CString cs;
			USES_CONVERSION;
			// desc
			if (!cs.LoadString(nidDesc)) {
				return E_INVALIDARG;
			}
			hr = ro.AddReplacement(pszMacroNames[mnlDesc], T2COLE(cs));
			if (FAILED(hr)) {
				return hr;
			}

			if (bRegister) {
				return ro.StringRegister(pszNonAutoReg);
			} else {
				return ro.StringUnregister(pszAutoReg);
			}
	}

	/////////// 
	static HRESULT RegisterFullControl(bool bRegister,
				  					   CRegObject& ro,
									   const int iMajor,
									   const int iMinor,
									   const DWORD dwOleMiscStatusBits) {

			CString cs;
			USES_CONVERSION;
			// version
			cs.Format(_T("%d.%d"), iMajor, iMinor);
			HRESULT hr = ro.AddReplacement(pszMacroNames[mnlVersion], T2COLE(cs));
			if (FAILED(hr)) {
				return hr;
			}
			cs.Format(_T("%ld"), dwOleMiscStatusBits);
			hr = ro.AddReplacement(pszMacroNames[mnlOleMisc], T2COLE(cs));
			if (FAILED(hr)) {
				return hr;
			}

			if (bRegister) {
				return ro.StringRegister(pszFullControl);
			} else {
				return ro.StringUnregister(pszFullControl);
			}
	}

	/////////// 
	static HRESULT RegisterProtocol(bool bRegister,
				  					   CRegObject& ro,
									   LPCOLESTR szProtocol) {
			HRESULT hr = ro.AddReplacement(pszMacroNames[mnlProtocol], szProtocol);
			if (FAILED(hr)) {
				return hr;
			}

			if (bRegister) {
				return ro.StringRegister(pszProtocol);
			} else {
				return ro.StringUnregister(pszProtocol);
			}
	}

	/////////// 
	static HRESULT RegisterExtraScript(CRegObject &ro, bool bRegister, 
											  const UINT nidExtraScriptID) {
		TCHAR szModule[_MAX_PATH];
		USES_CONVERSION;
		GetModuleFileName(_Module.m_hInst, szModule, _MAX_PATH);
		if (bRegister) {
			return ro.ResourceRegister(T2OLE(szModule), nidExtraScriptID, OLESTR("REGISTRY"));
		} else {
			return ro.ResourceUnregister(T2OLE(szModule), nidExtraScriptID, OLESTR("REGISTRY"));
		}
	}

};

/////////// 
#define REGISTER_AUTOMATION_OBJECT(nidComponent, nidProgID, nidDESC, clsTypeLib, clsCLSID) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		return CObjRegHelp::RegisterAutomationClass(bRegister ? true : false, ro, nidComponent, \
									   nidProgID, nidDESC, clsCLSID, clsTypeLib); \
	}

#define REGISTER_AUTOMATION_OBJECT_WITH_TM(nidComponent, nidProgID, nidDESC, clsTypeLib, clsCLSID, tvVal) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		return CObjRegHelp::RegisterAutomationClass(bRegister ? true : false, ro, nidComponent, \
									   nidProgID, nidDESC, clsCLSID, clsTypeLib, tvVal); \
	}

/////////// 
#define REGISTER_AUTOMATION_OBJECT_AND_RGS(nidExtraScript, nidComponent, nidProgID, nidDESC, clsTypeLib, clsCLSID) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		HRESULT hr = CObjRegHelp::RegisterAutomationClass(bRegister ? true : false, ro, nidComponent, \
												   	      nidProgID, nidDESC, clsCLSID, \
														  clsTypeLib); \
		if (FAILED(hr)) { \
			return hr; \
		} \
		return CObjRegHelp::RegisterExtraScript(ro, nidExtraScript); \
	}

/////////// 
#define REGISTER_NONAUTOMATION_OBJECT(nidComponent, nidDESC, clsTypeLib, clsCLSID) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		return CObjRegHelp::RegisterNonAutomationClass(bRegister ? true : false, ro, nidDESC, clsCLSID, clsTypeLib); \
	}

#define REGISTER_NONAUTOMATION_OBJECT_WITH_TM(nidComponent, nidDESC, clsTypeLib, clsCLSID, tvVal) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		return CObjRegHelp::RegisterNonAutomationClass(bRegister ? true : false, ro, nidDESC, clsCLSID, clsTypeLib, tvVal); \
	}

/////////// 
#define REGISTER_NONAUTOMATION_OBJECT_AND_RGS(nidExtraScript, nidDESC, clsTypeLib, clsCLSID) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		HRESULT hr = CObjRegHelp::RegisterNonAutomationClass(bRegister ? true : false, ro, \
														     nidDESC, clsCLSID, \
															 clsTypeLib); \
		if (FAILED(hr)) { \
			return hr; \
		} \
		return CObjRegHelp::RegisterExtraScript(ro, nidExtraScript); \
	}

/////////// 
#define REGISTER_FULL_CONTROL(nidComponent, nidProgID, nidDESC, clsTypeLib, clsCLSID, wMajor, wMinor, OleMisc) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		HRESULT hr = CObjRegHelp::RegisterAutomationClass(bRegister ? true : false, ro, nidComponent, \
												   	      nidProgID, nidDESC, clsCLSID, \
														  clsTypeLib); \
		if (FAILED(hr)) { \
			return hr; \
		} \
		return CObjRegHelp::RegisterFullControl(bRegister ? true : false, ro, wMajor, wMinor, OleMisc); \
	}


/////////// 
#define REGISTER_PROTOCOL(nidComponent, nidDESC, clsTypeLib, clsCLSID, szProtocol) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		HRESULT hr = CObjRegHelp::RegisterNonAutomationClass(bRegister ? true : false, \
															 ro, \
															 nidDESC, \
															 clsCLSID, \
															 clsTypeLib); \
		if (FAILED(hr)) { \
			return hr; \
		} \
		return CObjRegHelp::RegisterProtocol(bRegister ? true : false, ro, szProtocol); \
	}

#endif 
//end of file objreghelp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\mtype.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Class that holds and manages media type information, December 1994

// helper class that derived pin objects can use to compare media
// types etc. Has same data members as the struct AM_MEDIA_TYPE defined
// in the streams IDL file, but also has (non-virtual) functions

#include "stdafx.h"
#include <streams.h>
#include <mmreg.h>

CMediaType::~CMediaType(){
    FreeMediaType(*this);
}


CMediaType::CMediaType()
{
    InitMediaType();
}


CMediaType::CMediaType(const GUID * type)
{
    InitMediaType();
    majortype = *type;
}


// copy constructor does a deep copy of the format block

CMediaType::CMediaType(const AM_MEDIA_TYPE& rt)
{
    CopyMediaType(this, &rt);
}

CMediaType::CMediaType(const CMediaType& rt)
{
    CopyMediaType(this, &rt);
}

// this class inherits publicly from AM_MEDIA_TYPE so the compiler could generate
// the following assignment operator itself, however it could introduce some
// memory conflicts and leaks in the process because the structure contains
// a dynamically allocated block (pbFormat) which it will not copy correctly

CMediaType&
CMediaType::operator=(const AM_MEDIA_TYPE& rt)
{
    if (&rt != this) {
        FreeMediaType(*this);
        CopyMediaType(this, &rt);
    }
    return *this;
}


CMediaType&
CMediaType::operator=(const CMediaType& rt)
{
    *this = (AM_MEDIA_TYPE &) rt;
    return *this;
}

BOOL
CMediaType::operator == (const CMediaType& rt) const
{
    // I don't believe we need to check sample size or
    // temporal compression flags, since I think these must
    // be represented in the type, subtype and format somehow. They
    // are pulled out as separate flags so that people who don't understand
    // the particular format representation can still see them, but
    // they should duplicate information in the format block.

    return ((IsEqualGUID(majortype,rt.majortype) == TRUE) &&
        (IsEqualGUID(subtype,rt.subtype) == TRUE) &&
        (IsEqualGUID(formattype,rt.formattype) == TRUE) &&
        (cbFormat == rt.cbFormat) &&
        ( (cbFormat == 0) ||
          (memcmp(pbFormat, rt.pbFormat, cbFormat) == 0)));
}


BOOL
CMediaType::operator != (const CMediaType& rt) const
{
    /* Check to see if they are equal */

    if (*this == rt) {
        return FALSE;
    }
    return TRUE;
}


BOOL
CMediaType::IsValid() const
{
    return (!IsEqualGUID(majortype,GUID_NULL));
}


void
CMediaType::SetType(const GUID* ptype)
{
    majortype = *ptype;
}


void
CMediaType::SetSubtype(const GUID* ptype)
{
    subtype = *ptype;
}


ULONG
CMediaType::GetSampleSize() const {
    if (IsFixedSize()) {
        return lSampleSize;
    } else {
        return 0;
    }
}


void
CMediaType::SetSampleSize(ULONG sz) {
    if (sz == 0) {
        SetVariableSize();
    } else {
        bFixedSizeSamples = TRUE;
        lSampleSize = sz;
    }
}


void
CMediaType::SetVariableSize() {
    bFixedSizeSamples = FALSE;
}


void
CMediaType::SetTemporalCompression(BOOL bCompressed) {
    bTemporalCompression = bCompressed;
}

BOOL
CMediaType::SetFormat(BYTE * pformat, ULONG cb)
{
    if (NULL == AllocFormatBuffer(cb))
	return(FALSE);

    ASSERT(pbFormat);
    // pbFormat is memory CoTaskMemAlloc'd cb in length, in the AllocFormatBuffer function
    memcpy(pbFormat, pformat, cb);
    return(TRUE);
}


// set the type of the media type format block, this type defines what you
// will actually find in the format pointer. For example FORMAT_VideoInfo or
// FORMAT_WaveFormatEx. In the future this may be an interface pointer to a
// property set. Before sending out media types this should be filled in.

void
CMediaType::SetFormatType(const GUID *pformattype)
{
    formattype = *pformattype;
}


// reset the format buffer

void CMediaType::ResetFormatBuffer()
{
    if (cbFormat) {
        CoTaskMemFree((PVOID)pbFormat);
    }
    cbFormat = 0;
    pbFormat = NULL;
}


// allocate length bytes for the format and return a read/write pointer
// If we cannot allocate the new block of memory we return NULL leaving
// the original block of memory untouched (as does ReallocFormatBuffer)

BYTE*
CMediaType::AllocFormatBuffer(ULONG length)
{
    ASSERT(length);

    // do the types have the same buffer size

    if (cbFormat == length) {
        return pbFormat;
    }

    // allocate the new format buffer

    BYTE *pNewFormat = (PBYTE)CoTaskMemAlloc(length);
    if (pNewFormat == NULL) {
        if (length <= cbFormat) return pbFormat; //reuse the old block anyway.
        return NULL;
    }

    // delete the old format

    if (cbFormat != 0) {
        ASSERT(pbFormat);
        CoTaskMemFree((PVOID)pbFormat);
    }

    cbFormat = length;
    pbFormat = pNewFormat;
    return pbFormat;
}


// reallocate length bytes for the format and return a read/write pointer
// to it. We keep as much information as we can given the new buffer size
// if this fails the original format buffer is left untouched. The caller
// is responsible for ensuring the size of memory required is non zero

BYTE*
CMediaType::ReallocFormatBuffer(ULONG length)
{
    ASSERT(length);

    // do the types have the same buffer size

    if (cbFormat == length) {
        return pbFormat;
    }

    // allocate the new format buffer

    BYTE *pNewFormat = (PBYTE)CoTaskMemAlloc(length);
    if (pNewFormat == NULL) {
        if (length <= cbFormat) return pbFormat; //reuse the old block anyway.
        return NULL;
    }

    // copy any previous format (or part of if new is smaller)
    // delete the old format and replace with the new one

    if (cbFormat != 0) {
        ASSERT(pbFormat);
        memcpy(pNewFormat,pbFormat,min(length,cbFormat));
        CoTaskMemFree((PVOID)pbFormat);
    }

    cbFormat = length;
    pbFormat = pNewFormat;
    return pNewFormat;
}

// initialise a media type structure

void CMediaType::InitMediaType()
{
    ZeroMemory((PVOID)this, sizeof(*this));
    lSampleSize = 1;
    bFixedSizeSamples = TRUE;
}


// a partially specified media type can be passed to IPin::Connect
// as a constraint on the media type used in the connection.
// the type, subtype or format type can be null.
BOOL
CMediaType::IsPartiallySpecified(void) const
{
    if ((majortype == GUID_NULL) ||
        (formattype == GUID_NULL)) {
            return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
CMediaType::MatchesPartial(const CMediaType* ppartial) const
{
    if ((ppartial->majortype != GUID_NULL) &&
        (majortype != ppartial->majortype)) {
            return FALSE;
    }
    if ((ppartial->subtype != GUID_NULL) &&
        (subtype != ppartial->subtype)) {
            return FALSE;
    }

    if (ppartial->formattype != GUID_NULL) {
        // if the format block is specified then it must match exactly
        if (formattype != ppartial->formattype) {
            return FALSE;
        }
        if (cbFormat != ppartial->cbFormat) {
            return FALSE;
        }
        if ((cbFormat != 0) &&
            (memcmp(pbFormat, ppartial->pbFormat, cbFormat) != 0)) {
                return FALSE;
        }
    }

    return TRUE;

}



// general purpose function to delete a heap allocated AM_MEDIA_TYPE structure
// which is useful when calling IEnumMediaTypes::Next as the interface
// implementation allocates the structures which you must later delete
// the format block may also be a pointer to an interface to release

void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt)
{
    // allow NULL pointers for coding simplicity

    if (pmt == NULL) {
        return;
    }

    FreeMediaType(*pmt);
    CoTaskMemFree((PVOID)pmt);
}


// this also comes in useful when using the IEnumMediaTypes interface so
// that you can copy a media type, you can do nearly the same by creating
// a CMediaType object but as soon as it goes out of scope the destructor
// will delete the memory it allocated (this takes a copy of the memory)

AM_MEDIA_TYPE * WINAPI CreateMediaType(AM_MEDIA_TYPE const *pSrc)
{
    ASSERT(pSrc);

    // Allocate a block of memory for the media type

    AM_MEDIA_TYPE *pMediaType =
        (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));

    if (pMediaType == NULL) {
        return NULL;
    }
    // Copy the variable length format block

    CopyMediaType(pMediaType,pSrc);

    return pMediaType;
}


//  Copy 1 media type to another

void WINAPI CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource)
{
    //  We'll leak if we copy onto one that already exists - there's one
    //  case we can check like that - copying to itself.
    ASSERT(pmtSource != pmtTarget);
    *pmtTarget = *pmtSource;
    if (pmtSource->cbFormat != 0) {
        ASSERT(pmtSource->pbFormat != NULL);
        pmtTarget->pbFormat = (PBYTE)CoTaskMemAlloc(pmtSource->cbFormat);
        if (pmtTarget->pbFormat == NULL) {
            pmtTarget->cbFormat = 0;
        } else {
            // pmtTarget->pbFormat equals memory CoTaskMemAlloc'd pmtSource->cbFormat in length
            CopyMemory((PVOID)pmtTarget->pbFormat, (PVOID)pmtSource->pbFormat,
                       pmtTarget->cbFormat);
        }
    }
    if (pmtTarget->pUnk != NULL) {
        pmtTarget->pUnk->AddRef();
    }
}

//  Free an existing media type (ie free resources it holds)

void WINAPI FreeMediaType(AM_MEDIA_TYPE& mt)
{
    if (mt.cbFormat != 0) {
        CoTaskMemFree((PVOID)mt.pbFormat);

        // Strictly unnecessary but tidier
        mt.cbFormat = 0;
        mt.pbFormat = NULL;
    }
    if (mt.pUnk != NULL) {
        mt.pUnk->Release();
        mt.pUnk = NULL;
    }
}

// eliminate very many spurious warnings from MS compiler
#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\mtype.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Class that holds and manages media type information, December 1994

#ifndef __MTYPE__
#define __MTYPE__

/* Helper class that derived pin objects can use to compare media
   types etc. Has same data members as the struct AM_MEDIA_TYPE defined
   in the streams IDL file, but also has (non-virtual) functions */

class CMediaType : public _AMMediaType {

public:

    ~CMediaType();
    CMediaType();
    CMediaType(const GUID * majortype);
    CMediaType(const AM_MEDIA_TYPE&);
    CMediaType(const CMediaType&);

    CMediaType& operator=(const CMediaType&);
    CMediaType& operator=(const AM_MEDIA_TYPE&);

    BOOL operator == (const CMediaType&) const;
    BOOL operator != (const CMediaType&) const;

    BOOL IsValid() const;

    const GUID *Type() const { return &majortype;} ;
    void SetType(const GUID *);
    const GUID *Subtype() const { return &subtype;} ;
    void SetSubtype(const GUID *);

    BOOL IsFixedSize() const {return bFixedSizeSamples; };
    BOOL IsTemporalCompressed() const {return bTemporalCompression; };
    ULONG GetSampleSize() const;

    void SetSampleSize(ULONG sz);
    void SetVariableSize();
    void SetTemporalCompression(BOOL bCompressed);

    // read/write pointer to format - can't change length without
    // calling SetFormat, AllocFormatBuffer or ReallocFormatBuffer

    BYTE*   Format() const {return pbFormat; };
    ULONG   FormatLength() const { return cbFormat; };

    void SetFormatType(const GUID *);
    const GUID *FormatType() const {return &formattype; };
    BOOL SetFormat(BYTE *pFormat, ULONG length);
    void ResetFormatBuffer();
    BYTE* AllocFormatBuffer(ULONG length);
    BYTE* ReallocFormatBuffer(ULONG length);

    void InitMediaType();

    BOOL MatchesPartial(const CMediaType* ppartial) const;
    BOOL IsPartiallySpecified(void) const;
};


/* General purpose functions to copy and delete a task allocated AM_MEDIA_TYPE
   structure which is useful when using the IEnumMediaFormats interface as
   the implementation allocates the structures which you must later delete */

void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt);
AM_MEDIA_TYPE * WINAPI CreateMediaType(AM_MEDIA_TYPE const *pSrc);
void WINAPI CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource);
void WINAPI FreeMediaType(AM_MEDIA_TYPE& mt);

//  Initialize a media type from a WAVEFORMATEX

STDAPI CreateAudioMediaType(
    const WAVEFORMATEX *pwfx,
    AM_MEDIA_TYPE *pmt,
    BOOL bSetFormat);

#endif /* __MTYPE__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\odsstream.h ===
// odsstream.h c++ std lib output stream using win32 OutputDebugString
// copied from vc98 fstream
// Copyright (c) Microsoft Corporation 1998.

#pragma once

#if !defined(DEBUG) && (defined(_DBG) || defined(DBG) || defined(_DEBUG))
#define DEBUG 1
#endif

#if !defined(ODSSTREAM_H) && defined(DEBUG)
#define ODSSTREAM_H

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#include <tchar.h>
#include <ostream>
#include <tstring.h>

inline bool Debugputc(TCHAR outch) {
        TCHAR o[2];
        o[0] = outch;
        o[1] = 0;
        TCHAR *p = o;
        OutputDebugString(p);
        return true;
}

                // TEMPLATE CLASS basic_debugbuf
template<class _E, class _Tr = std::char_traits<_E> >
class basic_debugbuf : public std::basic_streambuf<_E, _Tr> {
public:

        typedef typename std::codecvt<_E, TCHAR, typename _Tr::state_type> _Cvt;
        typedef typename std::basic_streambuf<_E, _Tr> _Mysb;
        typedef basic_debugbuf<_E, _Tr> _Myt;

        basic_debugbuf() : _Loc(), _Mysb() {
                _Init();
        }
        virtual ~basic_debugbuf() {
                delete _Str;
        }
protected:
        virtual int_type overflow(int_type _C = _Tr::eof()) {
                if (_Tr::eq_int_type(_Tr::eof(), _C)) {
                        return (_Tr::not_eof(_C));
                } else if (pptr() != 0 && pptr() < epptr()) {
                        *_Pninc() = _Tr::to_char_type(_C);
                        return (_C);
                } else if (_Pcvt == 0) {
                        Debugputc(_Tr::to_char_type(_C));
                        return _C;
                } else {
                        const int _NC = 8;
                        const _E _X = _Tr::to_char_type(_C);
                        const _E *_S;
                        TCHAR *_D;
                        _Str->erase();
                        for (size_t _I = _NC; ; _I += _NC) {
                                _Str->append(_NC, '\0');
                                switch (_Pcvt->out(_State,
                                        &_X, &_X + 1, _S,
                                        _Str->begin(), _Str->end(), _D)) {
                                case std::codecvt_base::partial:
                                        if (_S == &_X)
                                                return (_Tr::eof());
                                case std::codecvt_base::ok:     {// can fall through
                                        size_t _N = _D - _Str->begin();
                                        OutputDebugString(_Str->begin());
                                        return _C;
                                }
                                case std::codecvt_base::noconv:
                                        Debugputc(_X);
                                        return _C;
                                default:
                                        return (_Tr::eof());
                                }
                        }
                }
        }
        virtual int_type uflow() {return (_Tr::eof());}
        void _Init() {
                static _Tr::state_type _Stinit;
                _Loc.locale::~locale();
                new (&_Loc) std::locale;
                _Str = 0;
                _Mysb::_Init();
                _State = _Stinit;
                _State0 = _Stinit;
                _Pcvt = 0;
        }

        void _Initcvt() {
                _Pcvt = (_Cvt *)&_USE(getloc(), _Cvt);
                _Loc = _ADDFAC(_Loc, _Pcvt);
                if (_Pcvt->always_noconv())
                        _Pcvt = 0;
                if (_Str == 0)
                        _Str = new string;
        }
private:
        _Cvt *_Pcvt;
        typename _Tr::state_type _State0;
        typename _Tr::state_type _State;
        Tstring *_Str;
        std::locale _Loc;
};

template<class _E, class _Tr = std::char_traits<_E> >
class basic_otstream : public std::basic_ostream<_E, _Tr> {
public:
        typedef std::basic_ostream<_E, _Tr> MytBase;
        typedef std::basic_ios<_E, _Tr> _Myios;
        typedef std::basic_streambuf<_E, _Tr> _Mysb;

        typedef basic_otstream<_E, _Tr> _Myt;
        basic_otstream() {}
        explicit basic_otstream(std::basic_streambuf<_E, _Tr> *_S,
                bool _Isstd = false, bool _Doinit = true) : std::basic_ostream<_E, _Tr>(_S, _Isstd, _Doinit) {}
        virtual ~basic_otstream()
                {}

#if 0
        template<class T> inline _Myt& operator<<(T i) {
                MytBase::operator<<(i);
                return *this;
        }
#endif

        inline _Myt& operator<<(_Myt& (__cdecl *_F)(_Myt&)) {
                return ((*_F)(*this));
        }

        inline _Myt& operator<<(MytBase& (__cdecl *_F)(MytBase&)) {
                MytBase::operator<<(_F);
                return *this;
        }

        inline _Myt& operator<<(_Myios& (__cdecl *_F)(_Myios&)) {
                MytBase::operator<<(f);
                return *this;
        }

        inline _Myt& operator<<(_Mysb *b) {
                MytBase::operator<<(b);
                return *this;
        }

        inline _Myt& operator<<(const void *const i) {
                MytBase::operator<<(i);
                return *this;
        }

        inline _Myt& operator<<(float i) {
                MytBase::operator<<(i);
                return *this;
        }

        inline _Myt& operator<<(double i) {
                MytBase::operator<<(i);
                return *this;
        }

        inline _Myt& operator<<(int i) {
                MytBase::operator<<(i);
                return *this;
        }

        inline _Myt& operator<<(unsigned int i) {
                MytBase::operator<<(i);
                return *this;
        }

        inline _Myt& operator<<(long i) {
                MytBase::operator<<(i);
                return *this;
        }

        inline _Myt& operator<<(unsigned long i) {
                MytBase::operator<<(i);
                return *this;
        }
#ifdef _UNICODE
        _Myt& operator<<(LPCSTR _X) {
                USES_CONVERSION;
                return operator<<(A2W(_X));
        }
#else
        _Myt& operator<<(const OLECHAR *_X) {
                USES_CONVERSION;
                operator<<(W2A(_X));
                return *this;
        }
#endif
        _Myt& operator<<(LPCTSTR _X) {
                std::operator<<(static_cast<MytBase&>(*this), _X);
                return *this;
        }

#if 0
        inline _Myt& operator<<(Tstring t) {
                return operator<<(t.c_str());
        }
#endif
};
typedef basic_otstream<TCHAR> tostream;

// TEMPLATE CLASS basic_ofstream
template<class _E, class _Tr = std::char_traits<_E> >
class basic_odebugstream : public basic_otstream<_E, _Tr> {
public:
        typedef basic_odebugstream<_E, _Tr> _Myt;
        typedef basic_debugbuf<_E, _Tr> _Myfb;
        basic_odebugstream()
                : basic_otstream<_E, _Tr>(&_Fb) {}
        basic_odebugstream(_Myt &mt) : basic_otstream<_E, _Tr>(mt._Fb) {}
        virtual ~basic_odebugstream()
                {}
private:
        _Myfb _Fb;
};



#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

typedef basic_debugbuf<TCHAR> TdbgBuf;
typedef basic_odebugstream<TCHAR> TdbgStream;

// the msvc 6 crt fstream header this was copied from contained the following notice:
/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */


#endif
// end of file odsstream.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\outputimpl.h ===
//==========================================================================;
//
// inputimpl.h : additional infrastructure to support implementing IMSVidOutputDevice
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef OUTPUTIMPL_H
#define OUTPUTIMPL_H

#include "devimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID Category, class MostDerivedInterface = IMSVidOutputDevice>
    class DECLSPEC_NOVTABLE IMSVidOutputDeviceImpl : public IMSVidDeviceImpl<T, LibID, Category, MostDerivedInterface> {
public:
};

}; // namespace

#endif
// end of file - inputimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\pbsegimpl.h ===
//==========================================================================;
//
// pbsegimpl.h : additional infrastructure to support implementing IMSVidGraphSegment for
//   playback segments
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef PBSEGIMPL_H
#define PBSEGIMPL_H

#include <segimpl.h>
#include <evcode.h>
#include <deviceeventimpl.h>

namespace MSVideoControl {

template<class T, enum MSVidSegmentType segtype, LPCGUID pCategory, class MostDerivedClass = IMSVidGraphSegment> 
    class DECLSPEC_NOVTABLE IMSVidPBGraphSegmentImpl : 
        public IMSVidGraphSegmentImpl<T, segtype, pCategory, MostDerivedClass> {
protected:

public:
    // DON'T addref the container.  we're guaranteed nested lifetimes
    // and an addref creates circular refcounts so we never unload.

    IMSVidPBGraphSegmentImpl() {}
    virtual ~IMSVidPBGraphSegmentImpl() {}
    STDMETHOD(OnEventNotify)(LONG lEvent, LONG_PTR lParm1, LONG_PTR lParm2) {
        if (lEvent == EC_COMPLETE) {
            T* pt = static_cast<T*>(this);
            CComQIPtr<IMSVidPlayback> ppb(this);
            if (!ppb) {
                return E_UNEXPECTED;
            }
            pt->Fire_EndOfMedia(ppb);
    
            // call Stop to make sure graph is stopped properly
            PQVidCtl pV(m_pContainer);
            pV->Stop();
            return NOERROR;  // we notify caller that we handled the event if stop() fails
        } 
        return E_NOTIMPL;
    }

};

template <class T, const IID* piid = &IID_IMSVidPlaybackEvent, class CDV = CComDynamicUnkArray>
class CProxy_PlaybackEvent : public CProxy_DeviceEvent<T, piid, CDV>
{
public:
	VOID Fire_EndOfMedia(IMSVidPlayback *pPBDev)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = pPBDev;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidEndOfMedia, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}

};


}; // namespace

#endif
// end of file - pbsegimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\playbackimpl.h ===
//==========================================================================;
//
// playbackimpl.h : additional infrastructure to support implementing IMSVidPlayback
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef PLAYBACKIMPL_H
#define PLAYBACKIMPL_H
#include <math.h>
#include "inputimpl.h"
#include <uuids.h>
namespace MSVideoControl {

#define BACKWARDS_STEPPING 0
const long nano_to_hundredths = 100000;    
template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidPlayback>
    class DECLSPEC_NOVTABLE IMSVidPlaybackImpl :         
    	public IMSVidInputDeviceImpl<T, LibID, KSCategory, MostDerivedInterface> {
protected:
    bool m_fEnableResetOnStop;
public:
    IMSVidPlaybackImpl():        
        m_fEnableResetOnStop(false) {}
	
    virtual ~IMSVidPlaybackImpl() {} 
//-----------------------------------------------------------------------------------------
// Name:
//-----------------------------------------------------------------------------------------
    STDMETHOD(get_Length)(/*[out, retval]*/long *lLength){
        HRESULT hr = S_OK;
        LONGLONG tempval;
        PositionModeList curMode;
        try{
            // Checking args and init'ing interfaces
            if (!lLength){
                return E_POINTER;
            }
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }

            // See if object supports IMediaSeeking
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                // Find out what postion mode is being used
                hr = get_PositionMode(&curMode);
                if(FAILED(hr)){
                    return hr;
                }
                hr = PQIMSeeking->GetDuration(&tempval);
                if(FAILED(hr)){
                    return hr;
                }
                // If it is FrameMode no conversion needed
                if(curMode == FrameMode){
                    *lLength = static_cast<long>(tempval);
                    hr = S_OK;
                    return hr;
                }
                // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
                else if(curMode == TenthsSecondsMode){
                    *lLength = static_cast<long>(tempval / nano_to_hundredths);
                    hr = S_OK;
                    return hr;
                }
                // If it is some other mode not supported by the vidctl
                else{
                    return E_UNEXPECTED;
                }
            }
    
            // See if object supports IMediaPostion
            PQMediaPosition PQIMPos(m_pGraph);
            if(PQIMPos){
                // Get position
                double tempDub;
                hr =  PQIMPos->get_CurrentPosition(&tempDub);
                // IMediaPostion only supports 100 Nanosecond units
                *lLength = static_cast<long>(tempDub / nano_to_hundredths);
                hr = S_OK;
                return hr;
            }
            // Could Not QI IMedia Seeking or Position
            return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
            
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
    
//-----------------------------------------------------------------------------------------
// Name: get_CurrentPosition(LONGLONG*)
//-----------------------------------------------------------------------------------------
    STDMETHOD(get_CurrentPosition)(/*[out,retval]*/long *lPosition) {
        HRESULT hr = S_OK;
        LONGLONG tempval;
        PositionModeList curMode;
        try{
            // Checking args and init'ing interfaces
            if (!lPosition){
                return E_POINTER;
            }
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }

            // See if object supports IMediaSeeking
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                // Find out what postion mode is being used
                hr = get_PositionMode(&curMode);
                if(FAILED(hr)){
                    return hr;
                }
                hr = PQIMSeeking->GetCurrentPosition(&tempval);
                if(FAILED(hr)){
                    return hr;
                }
                // If it is FrameMode no conversion needed
                if(curMode == FrameMode){
                    *lPosition = static_cast<long>(tempval);
                    hr = S_OK;
                    return hr;
                }
                // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
                else if(curMode == TenthsSecondsMode){
                    *lPosition = static_cast<long>(tempval / nano_to_hundredths);
                    hr = S_OK;
                    return hr;
                }
                // If it is some other mode not supported by the vidctl
                else{
                    return E_UNEXPECTED;
                }
            }
    
            // See if object supports IMediaPostion
            PQMediaPosition PQIMPos(m_pGraph);
            if(PQIMPos){
                // Get position
                double tempDub;
                hr =  PQIMPos->get_CurrentPosition(&tempDub);
                // IMediaPostion only supports 100 Nanosecond units
                *lPosition = static_cast<long>(tempDub / nano_to_hundredths);
                hr = S_OK;
                return hr;
            }
            // Could Not QI IMedia Seeking or Position
            return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
            
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
//-----------------------------------------------------------------------------------------
// Name: put_CurrentPosition(LONGLONG)
//-----------------------------------------------------------------------------------------
	STDMETHOD(put_CurrentPosition)(/*[in]*/long lPosition) {
        HRESULT hr = S_OK;
        LONGLONG tempval = 0;
        PositionModeList curMode;
            LONG curPos;
            try{
            // Checking args and interfaces
            if (!m_pGraph) {
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }

			hr = get_CurrentPosition(&curPos);
			if(curPos == lPosition){
				return NOERROR;
			}
            // Check for a IMediaSeeking Interface
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                // Get the position Mode
                hr = get_PositionMode(&curMode);
                if(FAILED(hr)){
                    return hr;
                }
                tempval = lPosition;
                // If it is in TenthsSecondsMode convert input into 100 nanosecond units
                if(curMode == TenthsSecondsMode){
                    tempval = static_cast<LONGLONG>(lPosition);
                    tempval = tempval * nano_to_hundredths;
                }
                // If it is in some other mode
                else if(curMode != FrameMode){
                    return E_UNEXPECTED;
                }
                // Set the new Position
#if 0
                if(curPos > lPosition && !m_pGraph.IsStopped()){

					DWORD seekingFlags = AM_SEEKING_CanSeekBackwards;
					hr = PQIMSeeking->CheckCapabilities(&seekingFlags);
					if(FAILED(hr)){
						return hr;
					}

				}
#endif
                hr = PQIMSeeking->SetPositions(&tempval, AM_SEEKING_AbsolutePositioning, NULL, 0);
                return hr;
            }
            // Check for a IMediaPostion
            PQMediaPosition PQIMPos(m_pGraph);
            if(PQIMPos){
                if(curPos > lPosition && !m_pGraph.IsStopped()){
					long canSeekBackwardRetVal;
                	PQIMPos->CanSeekBackward(&canSeekBackwardRetVal);
            		if(canSeekBackwardRetVal != -1){// OATRUE = -1
                 		return E_INVALIDARG;
            		}
                }
                // IMediaPosition only does 100 nanosecond units
                double tempDub = lPosition;
                tempDub = tempDub * nano_to_hundredths;
                hr = PQIMPos->put_CurrentPosition(tempDub);
                return hr;
            }
            // Could Not QI Media Position or Seeking
            return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
            
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
//-----------------------------------------------------------------------------------------
// Name: put_PositionMode(LONGLONG)
//-----------------------------------------------------------------------------------------

    STDMETHOD(put_PositionMode)(/*[in]*/PositionModeList lPositionMode) {
        HRESULT hr = S_OK;
        double testval;
        get_Rate(&testval);
        try{
            // Checking args and interfaces
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            // only valid values
            if(lPositionMode != FrameMode && lPositionMode != TenthsSecondsMode){
                return E_INVALIDARG;
            }
            // Try for a IMediaSeeking
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                // Set the new mode
                if(lPositionMode == FrameMode){
                    return PQIMSeeking->SetTimeFormat( &( static_cast<GUID>(TIME_FORMAT_FRAME) ) );
                }
                if(lPositionMode == TenthsSecondsMode){
                    return PQIMSeeking->SetTimeFormat(&(static_cast<GUID>(TIME_FORMAT_MEDIA_TIME)));
                }
            }
            // Try for a IMediaPosition
            PQMediaPosition PQIMPos(m_pGraph);
            if(PQIMPos){
                // Only supports TenthsSecondsMode
                if(lPositionMode == TenthsSecondsMode){
                    return S_OK;
                }
                else{
                    return E_FAIL;
                }
            }
            // Could Not QI
            return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
            
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }


//-----------------------------------------------------------------------------------------
// Name: get_PositionMode(LONGLONG*)
//-----------------------------------------------------------------------------------------
    STDMETHOD(get_PositionMode)(/*[out,retval]*/PositionModeList* lPositionMode) {
        HRESULT hr = S_OK;
        double testval;
        get_Rate(&testval);
        try{
            // Checking args and interfaces
            if(!lPositionMode){
                return E_POINTER;
            }
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            // Get an IMediaSeeking Interface
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                // Get the mode
                GUID cur_mode;
                hr = PQIMSeeking->GetTimeFormat(&cur_mode);
                if(FAILED(hr)){
                    return hr;
                }
                // Check to see which mode it is in
                if(cur_mode == static_cast<GUID>(TIME_FORMAT_FRAME)){
                    *lPositionMode = FrameMode;
                    return S_OK;
                }
                if(cur_mode == static_cast<GUID>(TIME_FORMAT_MEDIA_TIME)){
                    *lPositionMode = TenthsSecondsMode;
                    return S_OK;
                }
                // Not in a vidctl supported mode
                else{
                    return E_FAIL;
                }
            }
            // Get IMediaPosition
            PQMediaPosition PQIMPos(m_pGraph);
            if(PQIMPos){
                // Only supports TenthsSecondsMode
                *lPositionMode = TenthsSecondsMode;
                return S_OK;
            }
            // Could Not QI
            return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
            
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }

	STDMETHOD(get_Duration)(double *dPos) {
        return E_NOTIMPL;
    }
	STDMETHOD(get_PrerollTime)(double *dPos) {
        return E_NOTIMPL;
    }
	STDMETHOD(put_PrerollTime)(double dPos) {
        return E_NOTIMPL;
    }
	STDMETHOD(get_StartTime)(double *StartTime) {
        return E_NOTIMPL;
    }
	STDMETHOD(put_StartTime)(double StartTime) {
        return E_NOTIMPL;
    }
	STDMETHOD(get_StopTime)(double *StopTime) {
        return E_NOTIMPL;
    }
	STDMETHOD(put_StopTime)(double StopTime) {
        return E_NOTIMPL;
    }

//-----------------------------------------------------------------------------------------
// Name: get_EnableResetOnStop(VARIANT_BOOL*)
//-----------------------------------------------------------------------------------------
    STDMETHOD(get_EnableResetOnStop)(/*[out, retval]*/ VARIANT_BOOL *pVal){
        HRESULT hr = S_OK;
        
        try {
            if(NULL == pVal){ 
                throw(E_POINTER);
            }

            if(m_fEnableResetOnStop == true){
                *pVal = VARIANT_TRUE;
            }
            else{
                *pVal = VARIANT_FALSE;
            }
       
        }
        
        catch(HRESULT hrTmp){  
            hr = hrTmp;
        }
        
        catch(...){
            hr = E_UNEXPECTED;
        }
        
        return hr;
    }// end of function get_EnableResetOnStop 
//-----------------------------------------------------------------------------------------
// Name: put_EnableResetOnStop(VARIANT_BOOL)
//-----------------------------------------------------------------------------------------
    STDMETHOD(put_EnableResetOnStop)(/*[in]*/ VARIANT_BOOL newVal){
        HRESULT hr = S_OK;
        
        try {
            if(newVal == VARIANT_TRUE){ 
                m_fEnableResetOnStop = true;
            }
            else{
                m_fEnableResetOnStop = false;
            }
        }
        catch(...){   
            hr = E_UNEXPECTED;
        }
        
        return hr;
    }// end of function put_EnableResetOnStop

//-----------------------------------------------------------------------------------------
// Name: get_CanStep(VARIANT_BOOL, VARIANT_BOOL*)
//-----------------------------------------------------------------------------------------
    STDMETHOD(get_CanStep)(VARIANT_BOOL fBackwards, VARIANT_BOOL *pfCan){
        // NOTE: NO ONE supports backwords stepping (why not? who knows)
        // so just like everyone else we dont either
        try{
            // Checking args and interfaces 
       
            if(NULL == pfCan){
                // Passed a NULL Pointer
                return E_POINTER;
            }

            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
			}

            //Get a VideoFrameStep Interface
			PQVideoFrameStep pVFS(m_pGraph);
            if(!pVFS){
                // Could Not QI
				return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);          
			}
            
            
#if BACKWARDS_STEPPING // Checking for Backward Stepping should always be 0
            if(fBackwards == VARIANT_TRUE){
                // Backwords Stepping Not Supported Most Likely
                if(pVFS->CanStep(TRUE, NULL)==S_OK){
                    // It is all Good, Can Step Backwords
                    *pfCan = VARIANT_TRUE;
                    return S_OK;
                }
                
                *pfCan = VARIANT_FALSE;
                return S_OK;
            }
#else // Still checking for Backward Stepping
            if(fBackwards == VARIANT_TRUE){
                *pfCan = VARIANT_FALSE;
                return S_OK;
            }
            
#endif // End checking for Backward Stepping          

            // Checking for Forward Stepping 
            else{
                if(pVFS->CanStep(FALSE, NULL)==S_OK){
                    // It is all Good, Can Step Forward
                    *pfCan = VARIANT_TRUE;
                    return S_OK;
                }
                
                else{
                    // Can't Step
                    *pfCan = VARIANT_FALSE;
                    return S_OK;
                }
            }
        }
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;   
        }
    }

//-----------------------------------------------------------------------------------------
// Name: Step(long)
//-----------------------------------------------------------------------------------------
    STDMETHOD(Step)(long lStep){
        try{
            // Checking args and interfaces
            
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            
            PQVideoFrameStep pVFS(m_pGraph);
            
            if(!pVFS){
                // Could Not QI
                return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
                
            }
            
#if BACKWARDS_STEPPING // Checking for Backward Stepping should always be 0
            // If backwords stepping set rate or what ever needs to be done
            
            if(lStep < 0){
                // Backwords Stepping Not Supported Most Likely
                if(pVFS->CanStep(TRUE, NULL)==S_OK){
                    // It is all Good, Can Step Backwords
                    CComQIPtr<IMediaPosition> IMPos(m_pGraph);
                    CComQIPtr<IMediaControl> IMCon(m_pGraph);
                    if(IMPos&&IMCon){
                        OAFilterState enterState;
                        IMCon->GetState(INFINITE , &enterState);
                        HRESULT hr = IMPos->put_Rate(1);
                        if(SUCCEEDED(hr)){
                            hr = pVFS->Step((-lStep), NULL);
                            if(SUCCEEDED(hr)){
                                return S_OK;
                            }
                            else{
                                return E_UNEXPECTED;
                            }
                            
                        }
                    }
                }
                // Backwords stepping not supported
                return E_NOTIMPL;
            }
#else // Still checking for Backward Stepping

            if(lStep < 0){
                return E_NOTIMPL;
            }

#endif // End checking for Backward Stepping 
            // Make it step
            return pVFS->Step(lStep, NULL);
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
    
    // note: the following methods control the playback device *NOT* the graph. 
    // if the underlying source filter only supports these functions via 
    // imediacontrol on the graph then this device segment object should return E_NOTIMPL.
    STDMETHOD(Run)() {
        return E_NOTIMPL;
    }
    STDMETHOD(Pause)() {
        return E_NOTIMPL;
    }
    STDMETHOD(Stop)() {
        return E_NOTIMPL;
    }
//-----------------------------------------------------------------------------------------
// Name: put_Rate(double)
//-----------------------------------------------------------------------------------------
    STDMETHOD(put_Rate)(double lRate){
        HRESULT hr = S_OK;
        try{
            /*** Checking args and init'ing interfaces ***/
            
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }

            // Attempt to set the rate using IMediaSeeking
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                return PQIMSeeking->SetRate(lRate);
            }
            
            // If IMediaSeeking FAILS try IMediaPostion
            PQMediaPosition PQIMPos(m_pGraph);
            if(PQIMPos){
                // Change rate
                return PQIMPos->put_Rate((double)lRate);
            }
            
            // Could Not QI Either one set the error
                return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
//-----------------------------------------------------------------------------------------
// Name: get_Rate(double*)
//-----------------------------------------------------------------------------------------
    STDMETHOD(get_Rate)(double *plRate){
        HRESULT hr = S_OK;
        double curRate = 1;
        try{
            /*** Checking args and init'ing interfaces ***/
            if (!plRate){
                return E_POINTER;
            }
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                hr = PQIMSeeking->GetRate(&curRate);
            }
            else{
                PQMediaPosition PQIMPos(m_pGraph);
                if(PQIMPos){
                    // Get rate
                    hr = PQIMPos->get_Rate(&curRate);
                }
                // Could Not QI
                else{
                    return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
                }
            }
            
            if(SUCCEEDED(hr)){
                *plRate = curRate;
                TRACELSM(TRACE_DETAIL, (dbgDump << "Playbackimpl::get_Rate() rate = " << curRate), "");
            }
            else{
                TRACELSM(TRACE_ERROR, (dbgDump << "Playbackimpl::get_Rate() get_rate failed"), "");
            }
            return hr;
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }

};

}; // namespace

#endif
// end of file - playbackimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\segimpl.h ===
//==========================================================================;
//
// segimpl.h : additional infrastructure to support implementing IMSVidGraphSegment 
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef SEGIMPL_H
#define SEGIMPL_H

#include <segment.h>
#include <seg.h>
#include <filterenum.h>
#include "devsegimpl.h"

namespace MSVideoControl {

typedef CComQIPtr<IMSVidCtl> PQVidCtl;

template<class T, enum MSVidSegmentType segtype, LPCGUID pCategory, class MostDerivedClass = IMSVidGraphSegment> 
    class DECLSPEC_NOVTABLE IMSVidGraphSegmentImpl : 
        public MostDerivedClass,
        public virtual CMSVidDeviceSegmentImpl {
protected:
    HRESULT Unload() {
        if (!m_fInit || !m_pContainer) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidGraphSegment), CO_E_NOTINITIALIZED);
        }
        try {
            ASSERT(m_pContainer.GetGraph() == m_pGraph);
            // undone: dynamic graph building may allow this
            if (!m_pGraph.IsStopped()) {
				return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidGraphSegment), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            if (m_pGraph) {
#ifdef CRASH
                std::for_each(m_Filters.begin(), 
                              m_Filters.end(),
                               arity1_member_obj(m_pGraph, 
                                                 arity1_member(&DSGraph::RemoveFilter))
                             );
#else
#if 0                
                std::for_each(m_Filters.begin(), 
                              m_Filters.end(),
                              arity1opmf<arity1pmf<DSGraph, DSFilter&, bool> >(
                                  m_pGraph, 
                                  arity1_member(&DSGraph::RemoveFilter)));
#endif
                for(DSFilterList::iterator i = m_Filters.begin(); i != m_Filters.end(); ++i){
                    HRESULT hr = m_pGraph->RemoveFilter(*i);
                    _ASSERT((L"Failed to remove filter from graph during Unload.", SUCCEEDED(hr)));
                }
#endif
            }
            m_Filters.clear();
            m_pGraph.Release();
            // DON'T release the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            // thus, we didn't addref and a release will over release and
            // cause destruction before other people are done with the container
            m_pContainer.p = NULL;
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
  	    return NOERROR;
    }

public:
    // DON'T addref the container.  we're guaranteed nested lifetimes
    // and an addref creates circular refcounts so we never unload.

    IMSVidGraphSegmentImpl() {}
    virtual ~IMSVidGraphSegmentImpl() {
        if (m_fInit && m_pContainer) {
            Unload();
        }
    }
    STDMETHOD(GetClassID) (LPCLSID guid) {
        try {
            memcpy(guid, &__uuidof(T), sizeof(CLSID));
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Init)(IUnknown * pInit) {
        if (m_fInit) {
            return NOERROR;
        }
        try {
            m_pDev = pInit;
            m_fInit = true;
		    return NOERROR;
        } catch(...) {
            m_fInit = false;
            return E_POINTER;
        }
	}
	STDMETHOD(get_Init)(IUnknown **	pInit) {
		try{
			if (!pInit)	{
				return E_POINTER;
			}
			m_pDev.CopyTo(pInit);
			return NOERROR;
		} catch(...) {
			m_fInit	= false;
			return E_POINTER;
		}
    }

    STDMETHOD(get_Container)(IMSVidGraphSegmentContainer **ppCtl) {
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidGraphSegment), CO_E_NOTINITIALIZED);
        }
        try {
            return m_pContainer.CopyTo(ppCtl);
        } catch(...) {
            return E_POINTER;
        }
	}
    STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl) {
        try {
            if (!pCtl) {
                return Unload();
            }
            if (m_pContainer) {
				if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
					//undone: support moving to different graph
					return ImplReportError(__uuidof(T), IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidGraphSegment), CO_E_ALREADYINITIALIZED);
				} else {
					return NO_ERROR;
				}
            }
            // DON'T addref the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            m_pContainer.p = pCtl;
            m_pGraph = m_pContainer.GetGraph();
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}
    STDMETHOD(EnumFilters)(IEnumFilters * * pNewEnum) {
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidGraphSegment), CO_E_NOTINITIALIZED);
        }
		if (pNewEnum == NULL)
			return E_POINTER;
        PQEnumFilters p;
        try {
            p = new CFilterEnumOnDSFilterList(m_Filters);
        } catch (...) {
            return E_OUTOFMEMORY;
        }
        try {
            *pNewEnum = p.Detach();
        } catch (...) {
            return E_POINTER;
        }
        return NOERROR;
	}
    STDMETHOD(get_Type)(MSVidSegmentType *pType) { 
        try {
            *pType = segtype;
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_Category)(GUID *pGuid) {
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidGraphSegment), CO_E_NOTINITIALIZED);
        }
        try {
            memcpy(pGuid, pCategory, sizeof(*pGuid));
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
	}
    STDMETHOD(Build)() {
        return E_NOTIMPL;
    }
    STDMETHOD(PreRun)() {
        return E_NOTIMPL;
    }
    STDMETHOD(PostRun)() {
        return E_NOTIMPL;
    }
    STDMETHOD(PreStop)() {
        return E_NOTIMPL;
    }
    STDMETHOD(PostStop)() {
        return E_NOTIMPL;
    }
    STDMETHOD(Select)(IUnknown *pItem) {
        return E_NOTIMPL;
    }
    STDMETHOD(OnEventNotify)(LONG lEvent, LONG_PTR lParm1, LONG_PTR lParm2) {
        return E_NOTIMPL;
    }
    STDMETHOD(OnWindowMessage)(UINT uMsg, WPARAM wParam, LPARAM lParam) {
        return E_NOTIMPL;
    }
    STDMETHOD(Decompose)(){
        return E_NOTIMPL;
    }

};

}; // namespace

#endif
// end of file - segimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\segment.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1995-1999.
//
//--------------------------------------------------------------------------;
//
// segment.cpp : implementation of various graph segment extension classes
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include <bdamedia.h>

#include "devices.h"
#include "seg.h"

#include "closedcaptioning.h"
#include "MSViddataservices.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidClosedCaptioning, CClosedCaptioning)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidDataServices, CDataServices)

// VWSegment
#if 0
// note: the compiler is generating but never calling the code to construct these initializers so the pointers
// are staying null.  we work around this by providing a function which dynamically allocating them on the heap 
// and calling it in our dllmain.
std_arity1pmf<IMSVidGraphSegment, IEnumFilters **, HRESULT> * VWGraphSegment::Fetch = &std_arity1_member(&IMSVidGraphSegment::EnumFilters);
// reset and next use same types as DSGraphContainer so same template expansion already initialized
#else
std_arity1pmf<IMSVidGraphSegment, IEnumFilters **, HRESULT> * VWGraphSegment::Fetch = NULL;
// reset and next use same types as DSGraphContainer so same template expansion already initialized
#endif

namespace MSVideoControl {
// work around compiler bug as per above description
void CtorStaticVWSegmentFwdSeqPMFs(void) {
    // DSGraphContainer
    VWGraphSegment::Fetch = new std_arity1pmf<IMSVidGraphSegment, IEnumFilters **, HRESULT>(&IMSVidGraphSegment::EnumFilters);
}

// work around compiler bug as per above description
void DtorStaticVWSegmentFwdSeqPMFs(void) {
    // DSGraphContainer
    delete VWGraphSegment::Fetch;
}

VWSegmentContainer VWGraphSegment::Container(void) {
    VWSegmentContainer g;
    HRESULT hr = (*this)->get_Container(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

MSVidSegmentType VWGraphSegment::Type(void) {
    MSVidSegmentType t;
    HRESULT hr = (*this)->get_Type(&t);
    ASSERT(SUCCEEDED(hr));
    return t;
}

DSGraph VWGraphSegment::Graph(void) {
    DSGraph g;
    HRESULT hr = (Container())->get_Graph(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

GUID2 VWGraphSegment::Category(void) {
    GUID2 g;
    HRESULT hr = (*this)->get_Category(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

GUID2 VWGraphSegment::ClassID(void) {
    GUID2 g;
    HRESULT hr = (*this)->GetClassID(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

}; // namespace

#endif //TUNING_MODEL_ONLY

// end of file - segment.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\scalingrect.h ===
/////////////////////////////////////////////////////////////////////////////
// scalingrect.h : gdi based rect with auto scaling for associated window handle
// Copyright (c) Microsoft Corporation 2000.

#pragma once

#ifndef SCALINGRECT_H
#define SCALINGRECT_H

#include <atltmp.h>
#include <throw.h>
#include <trace.h>

#define INVALID_HWND ((HWND) INVALID_HANDLE_VALUE)
typedef CComQIPtr<IOleInPlaceSiteWindowless> PQSiteWindowless;

class CScalingRect : public CRect {
public:
    CScalingRect(const long l = 0,
                 const long t = 0,
                 const long r = 0,
                 const long b = 0,
                 const HWND iOwner = INVALID_HWND) :
                         CRect(l, t, r, b),
						 m_hOwner(iOwner),
						 m_bRequiresSave(true) {}

    CScalingRect(const HWND iOwner) : m_bRequiresSave(true) {
		if (iOwner == INVALID_HWND) {
			CRect(0, 0, 0, 0);
		} else if (::IsWindow(iOwner)) {
            if (!::GetWindowRect(iOwner, this)) {
                    THROWCOM(E_UNEXPECTED);
            }
		} else {
			THROWCOM(E_INVALIDARG);
		}
		m_hOwner = iOwner;
	}

    CScalingRect(const CSize& sz, const HWND iOwner = INVALID_HWND) : 
					CRect(CPoint(0, 0), sz),
					 m_hOwner(iOwner),
					 m_bRequiresSave(true) {}

    CScalingRect(const POINT& pt1, POINT& pt2 = CPoint(0, 0), const HWND iOwner = INVALID_HWND) : 
					CRect(pt1, pt2),
					 m_hOwner(iOwner),
					 m_bRequiresSave(true) {}

    CScalingRect(const POINT& pt1, SIZE& sz = CSize(0, 0), const HWND iOwner = INVALID_HWND) : 
					CRect(pt1, sz),
					 m_hOwner(iOwner),
					 m_bRequiresSave(true) {}

    CScalingRect(const RECT& iPos,
                 const HWND iOwner = INVALID_HWND) :
                         CRect(iPos),
						 m_hOwner(iOwner),
						 m_bRequiresSave(true) {}

    CScalingRect(const CRect& iPos,
                 const HWND iOwner = INVALID_HWND) :
                         CRect(iPos),
						 m_hOwner(iOwner),
						 m_bRequiresSave(true) {}

	CScalingRect& operator=(const CScalingRect& rhs) {
        if (this != &rhs && *this != rhs) {
			CRect::operator=(rhs);
			if ((m_hOwner != INVALID_HWND) && (rhs.m_hOwner != INVALID_HWND) && (m_hOwner != rhs.m_hOwner)) {
				::MapWindowPoints(rhs.m_hOwner, m_hOwner, reinterpret_cast<LPPOINT>(static_cast<LPRECT>(this)), 2);
			}
            m_bRequiresSave = true;
        }
        return *this;
    }

	CScalingRect& operator=(const CRect& rhs) {
        if (this != &rhs && (CRect(*this) != rhs)) {
            CRect::operator=(rhs);
            m_bRequiresSave = true;
        }
        return *this;
    }

    bool operator==(const CScalingRect& rhs) const {
            CRect r(rhs);
            if (rhs.m_hOwner != INVALID_HWND && m_hOwner != INVALID_HWND && rhs.m_hOwner != m_hOwner) {
				::MapWindowPoints(rhs.m_hOwner, m_hOwner, reinterpret_cast<LPPOINT>(static_cast<LPRECT>(r)), 2);
			}
            return !!CRect::operator==(r);
    }
    bool operator !=(const CScalingRect& rhs) const {
            return !operator==(rhs);
    }
    bool operator==(const CRect& rhs) const {
            return CRect::operator==(rhs) != 0;
    }
    bool operator !=(const CRect& rhs) const {
            return !operator==(rhs);
    }
    bool operator==(LPCRECT rhs) const {
            return CRect::operator==(*rhs) != 0;
    }
    bool operator !=(LPCRECT rhs) const {
            return !operator==(rhs);
    }
    bool operator==(const RECT& rhs) const {
            return CRect::operator==(rhs) != 0;
    }
    bool operator !=(const RECT& rhs) const {
            return !operator==(rhs);
    }

    long Width() { return CRect::Width(); }
    long Height() { return CRect::Height(); }
    void Width(long cx) {
        right = left + cx;
    }
    void Height(long cy) {
        bottom = top + cy;
    }
    HWND Owner() const { return m_hOwner; }
    void Owner(const HWND h) {
		if (m_hOwner != h) {
			if ((m_hOwner != INVALID_HWND) && (h != INVALID_HWND)) {
				::MapWindowPoints(m_hOwner, h, reinterpret_cast<LPPOINT>(static_cast<LPRECT>(this)), 2);
			}
			m_hOwner = h;
			m_bRequiresSave = true;
		}
        return;
    }

    bool IsDirty() const { return m_bRequiresSave; }
    void Dirty(const bool fVal) { m_bRequiresSave = fVal; }
    bool m_bRequiresSave;
private:
    HWND m_hOwner;
};


#endif
// end of file scalingrect.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\stextend.h ===
//==========================================================================;
//
// stextend.h : extensions to vc++ 5.0 stl templates
// Copyright (c) Microsoft Corporation 1997.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef STEXTEND_H
#define STEXTEND_H

#include <utility>
#include <functional>

#if 1
#include <arity.h>  //generated .h from aritygen
#else
#include <stx.h>    // old one from win98
#endif


#pragma warning(disable:4503)
#pragma warning(disable:4181)

template<class _T1, class _T2> inline
bool __cdecl operator!(const std::pair<_T1, _T2>& _X)
        {return ((!(_X.first)) && (!(_X.second))); }

template<class Ty1, class Ty2> struct equal_to2 : std::binary_function<Ty1, Ty2, bool> {
	bool operator()(const Ty1& X, const Ty2& Y) const {return (X == Y); }
};



#endif
// end of file stextend.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\seg.h ===
//==========================================================================;
//
// seg.h : additional infrastructure to support using IMSVidGraphSegment nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef SEG_H
#define SEG_H

#include <segment.h>
#include <fwdseq.h>
#include <devseq.h>
#include <dsextend.h>
#include <objectwithsiteimplsec.h>

namespace MSVideoControl {

typedef CComQIPtr<IMSVidGraphSegment, &__uuidof(IMSVidGraphSegment)> PQGraphSegment;

typedef Forward_Sequence<
    PQGraphSegment,
    PQEnumFilters,
    DSFilter,
    IMSVidGraphSegment, 
    IEnumFilters, 
    IBaseFilter*> VWGraphSegmentSequence;

class VWSegmentContainer;

class VWGraphSegment : public VWGraphSegmentSequence {
public:
    inline VWGraphSegment() {}
    virtual ~VWGraphSegment() {}
    inline VWGraphSegment(const PQGraphSegment &a) : VWGraphSegmentSequence(a) {}
    inline VWGraphSegment(IMSVidGraphSegment *p) : VWGraphSegmentSequence(p) {}
    inline VWGraphSegment(IUnknown *p) : VWGraphSegmentSequence(p) {}
    inline VWGraphSegment(const VWGraphSegment &a) : VWGraphSegmentSequence(a) {}
    inline VWGraphSegment(const CComVariant &v) : VWGraphSegmentSequence(((v.vt == VT_UNKNOWN) ? v.punkVal : (v.vt == VT_DISPATCH ? v.pdispVal : NULL))) {}
    VWSegmentContainer Container(void);
    MSVidSegmentType Type(void);
    DSGraph Graph(void);
    GUID2 Category();
	GUID2 ClassID();
};

typedef CComQIPtr<IMSVidGraphSegmentContainer, &__uuidof(IMSVidGraphSegmentContainer)> PQSegmentContainer;
class VWSegmentContainer : public PQSegmentContainer {
public:
    inline VWSegmentContainer() {}
    inline VWSegmentContainer(const PQSegmentContainer &a) : PQSegmentContainer(a) {}
    inline VWSegmentContainer(IUnknown *p) : PQSegmentContainer(p) {}
    inline VWSegmentContainer(IMSVidGraphSegmentContainer *p) : PQSegmentContainer(p) {}
    inline VWSegmentContainer(const VWSegmentContainer &a) : PQSegmentContainer(a) {}
    virtual ~VWSegmentContainer() {}
    DSGraph GetGraph(void) {
        DSGraph g;
        IMSVidGraphSegmentContainer* p = (*this);
        if (p) {
            p->get_Graph(&g);
        }
        return g;
    }
};

typedef std::vector<VWGraphSegment> VWSegmentList;
typedef CComQIPtr<IEnumMSVidGraphSegment, &__uuidof(IEnumMSVidGraphSegment)> PQEnumSegment;

void CtorStaticVWSegmentFwdSeqPMFs(void);
void DtorStaticVWSegmentFwdSeqPMFs(void);


class ATL_NO_VTABLE CSegEnumBase : public CComObjectRootEx<CComSingleThreadModel>,
	public IEnumMSVidGraphSegment,
    public IObjectWithSiteImplSec<CSegEnumBase>
{
    BEGIN_COM_MAP(CSegEnumBase)
	    COM_INTERFACE_ENTRY(IEnumMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    virtual ~CSegEnumBase() {}
};

/////////////////////////////////////////////////////////////////////////////
// CSegEnum
class CSegEnum : public CComObject<CSegEnumBase>
{
public:

    CSegEnum(DeviceCollection &d) {
		for (DeviceCollection::iterator i = d.begin(); i != d.end(); ++i) {
			VWGraphSegment seg(*i);
			ASSERT(seg);
			m_pSegments.push_back(seg);
		}
	}

    CSegEnum(VWSegmentList &s) : m_pSegments(s), i(s.begin()) {
	}
	CSegEnum(CSegEnum &orig) : m_pSegments(orig.m_pSegments) {
        i = m_pSegments.begin();
        VWSegmentList::iterator i2 = orig.m_pSegments.end();
        for (;i2 != orig.i; ++i2, ++i);
	}
    virtual ~CSegEnum() {
        i = m_pSegments.end();
        m_pSegments.clear();
    }
// ISegEnum
public:
	VWSegmentList m_pSegments;
    VWSegmentList::iterator i;
// IEnumMSVidGraphSegment
	STDMETHOD(Next)(ULONG celt, IMSVidGraphSegment **rgvar, ULONG * pceltFetched)
	{
		// pceltFetched can legally == 0
		//
		if (pceltFetched != NULL) {
			try {
				*pceltFetched = 0;
			} catch(...) {
				return E_POINTER;
			}
		}

		// Retrieve the next celt elements.
		HRESULT hr = NOERROR ;
		for (ULONG l = 0;i != m_pSegments.end() && celt != 0 ; ++i, ++l, --celt) {
			(*i).CopyTo(&rgvar[l]);
			if (pceltFetched != NULL) {
				(*pceltFetched)++ ;
			}
		}

		if (celt != 0) {
		   hr = ResultFromScode( S_FALSE ) ;
		}

		return hr ;
	}
	STDMETHOD(Skip)(ULONG celt)
	{
		for (;i != m_pSegments.end() && celt--; ++i);
		return (celt == 0 ? NOERROR : ResultFromScode( S_FALSE )) ;
	}
	STDMETHOD(Reset)()
	{
		i = m_pSegments.begin();
		return NOERROR;
	}
	STDMETHOD(Clone)(IEnumMSVidGraphSegment * * ppenum)
	{
		PQEnumSegment temp;
		try {
			temp = new CSegEnum(*this);
		} catch(...) {
			return E_OUTOFMEMORY;
		}
		try {
			*ppenum = temp.Detach();
		} catch(...) {
			return E_POINTER;
		}
		return NOERROR;
	}
};

};
#endif
// end of file seg.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\propertybag2impl.h ===
/////////////////////////////////////////////////////////////////////////////
//
// propertybag2impl.h : helper functions for implementing IPropertyBag2
// Copyright (c) Microsoft Corporation 1999.
//
// this code assumes that you're also implementing IPropertyBag and reflects
// bag2's read/write to bag's read/write
//


template <class T>
class ATL_NO_VTABLE IPropertyBag2Impl : public IPropertyBag2
{

// IPropertyBag2
STDMETHOD(Read)(ULONG cProperties, PROPBAG2* pPropBag, IErrorLog* pErrLog, VARIANT* pvarValue, HRESULT* phrError) {
    HRESULT hrc = NOERROR;
    if (!phrError || !pPropBag) {
        return E_POINTER;
    }
    try {            
		ATL_LOCKT();
       for (ULONG i = 0; i < cProperties; ++i) {
            phrError[i] = pT->Read(pPropBag[i].pstrName, pvarValue + i, pErrLog);
            if (FAILED(phrError[i])) {
                hrc = E_FAIL;
            }
        }
        return hrc;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

STDMETHOD(Write)(ULONG cProperties, PROPBAG2* pPropBag, VARIANT* pvarValue) {
    HRESULT hrc = NOERROR;
    if (!pvarValue || !pPropBag) {
        return E_POINTER;
    }
    try {            
		ATL_LOCKT();
        for (ULONG i = 0; i < cProperties; ++i) {
            VARIANT *pVAR = pvarValue + i;
            LPCOLESTR s = pPropBag[i].pstrName;
            HRESULT hr = pT->Write(s, pVAR);
            if (FAILED(hr)) {
                hrc = E_FAIL;
            }
        }
        return hrc;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\trace.cpp ===
//
// trace.cpp -- global vars for trace.h
// copyright (c) Microsoft Corp. 1998
//
// this file should be include in stdafx.cpp

#ifdef DEBUG
#include "tstring.h"
#include <ostream>
#include <fstream>
#include "trace.h"
#include <process.h>


DWORD dwTraceLevel = 0;  // default to trace_error
tostream* tdbgout;
DWORD dwTraceIndent = 0;

typedef basic_oftstream<TCHAR> tfstream;

void DebugInit(LPCTSTR pszModule) {
        if (!pszModule) {
                dwTraceLevel = TRACE_ERROR;
        tdbgout = new TdbgStream;
                return;
        }
        CRegKey c;
        TCHAR szLogFile[MAX_PATH + 1];
        szLogFile[0] = 0;
        CString keyname(_T("SOFTWARE\\Debug\\"));
        keyname += pszModule;
        DWORD rc = c.Open(HKEY_LOCAL_MACHINE, keyname, KEY_READ);
        if (rc == ERROR_SUCCESS) {
                rc = c.QueryValue(dwTraceLevel, _T("Trace"));
                if (rc != ERROR_SUCCESS) {
                        dwTraceLevel = 1;
                }
                DWORD len = sizeof(szLogFile);
                rc = c.QueryValue(szLogFile, _T("LogFile"), &len);
                if (rc != ERROR_SUCCESS) {
                        szLogFile[0] = 0;
                }
                if(_tcslen(szLogFile)){
                    TCHAR szPID[MAX_PATH+1];
                    _itot(_getpid(), szPID, 10);
                    StringCchCat(szLogFile, sizeof(szLogFile)/sizeof(szLogFile[0]), szPID);
                    StringCchCat(szLogFile, sizeof(szLogFile)/sizeof(szLogFile[0]), _T(".log"));
                }
        }
    if (!_tcslen(szLogFile)) {
        tdbgout = new TdbgStream;
    } else {
        USES_CONVERSION;
        tdbgout = new tfstream(T2CA(szLogFile), std::ios::out);
    }
}

void DebugTerm(void) {
    dbgDump.flush();
    delete tdbgout;
    tdbgout = NULL;
}

#endif

// end of file - trace.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\trace.h ===
// trace.h : tracing helper macros
// Copyright (c) Microsoft Corporation 1995-1997.

#pragma once
#pragma warning(disable : 4296)
#ifndef TRACE_H
#define TRACE_H

// if you want to use the vidctl helper *impl templates without using the
// vidctl trace/debug infrastructure then #define NO_VIDCTL_TRACE_SUPPORT
// separately if you don't want to use the vidctl ASSERT then 
// #define NO_VIDCTL_ASSERT_SUPPORT
#ifdef NO_VIDCTL_TRACE_SUPPORT
#ifndef TRACELM
#define TRACELM(level, msg)
#endif
#ifndef TRACELS
#define TRACELS(level, stmt)
#endif
#ifndef TRACELSM
#define TRACELSM(level, stmt, msg)
#endif
#ifndef BEGIN_TRACEL
#define BEGIN_TRACEL(level)
#endif
#ifndef TRACES
#define TRACES(stmt)
#endif
#ifndef END_TRACEL
#define END_TRACEL
#endif
#ifndef END_TRACELM
#define END_TRACELM(msg)
#endif
#ifndef TRACEINDENT
#define TRACEINDENT()
#endif
#ifndef TRACEOUTDENT
#define TRACEOUTDENT()
#endif
#else // NO_VIDCTL_TRACE_SUPPORT
#ifdef NO_VIDCTL_ASSERT_SUPPORT
#ifndef ASSERT
#define ASSERT(x)
#endif
#else // NO_VIDCTL_ASSERT_SUPPORT
#if !defined(DEBUG) && (defined(_DBG) || defined(DBG) || defined(_DEBUG))
#define DEBUG 1
#endif
#if !defined(_DEBUG) && (defined(_DBG) || defined(DBG) || defined(DEBUG))
#define _DEBUG 1
#endif

#ifdef DEBUG

enum {
    TRACE_ALWAYS = 0,
    TRACE_ERROR,
    TRACE_DEBUG,
    TRACE_DETAIL,
    TRACE_PAINT,
    TRACE_TEMP,
};

#pragma warning (push)
#pragma warning (disable : 4018) // sign/unsign mismatch in ostream line 312
#include <fstream>
#include <tstring.h>
#include <odsstream.h>
#pragma warning (pop)

#define STRSAFE_NO_CB_FUNCTIONS
#include <strsafe.h>
#define SIZEOF_CH(X) (sizeof(X)/sizeof(X[0]))

inline Tstring hexdump(unsigned long ul) {
        TCHAR c[32];
        _ltot(ul, c, 16);
        return Tstring(c);
}

#ifdef DUMP_TIME_STAMPS
extern  _int64 g_ulFreq, g_ulTimeStart;
extern  DumpPerfTime();
#else
#define DumpPerfTime()
#endif

#define DUMP_TID
#ifdef DUMP_TID
inline Tstring DumpTid() {
    TCHAR c[32];
    (void) StringCchPrintf(c, SIZEOF_CH(c), _T("T0x%8.8lX: "), ::GetCurrentThreadId());
    return Tstring(c);
}
#else // DUMP_TID
#define DumpTid()
#endif // DUMP_TID

extern DWORD dwTraceLevel;
extern DWORD dwTraceIndent;
extern tostream* tdbgout;
#define dbgDump (*tdbgout)
void DebugInit(LPCTSTR pszLogFile = NULL);
void DebugTerm(void);

inline tostream& DumpHdr(tostream& tout) {
        DumpPerfTime();
        tout << DumpTid();
        for (DWORD i = 0; i < dwTraceIndent; ++i) {
                tout << "    ";
        }
        return tout;
}

template<class _E, class _Tr = std::char_traits<_E> >
        class basic_oftstream : public basic_otstream<_E, _Tr> {
public:
        typedef basic_oftstream<_E, _Tr> _Myt;
        typedef std::basic_filebuf<_E, _Tr> _Myfb;
        basic_oftstream()
                : basic_otstream<_E, _Tr>(&_Fb) {}
        explicit basic_oftstream(const char *_S,
                ios_base::openmode _M = out | trunc)
                : basic_otstream<_E, _Tr>(&_Fb)
                {if (_Fb.open(_S, _M | out) == 0)
                        setstate(failbit); }
        virtual ~basic_oftstream()
                {}
        _Myfb *rdbuf() const
                {return ((_Myfb *)&_Fb); }
        bool is_open() const
                {return (_Fb.is_open()); }
        void open(const char *_S, ios_base::openmode _M = out | trunc)
                {if (_Fb.open(_S, _M | out) == 0)
                        setstate(failbit); }
        void open(const char *_S, ios_base::open_mode _M)
                {open(_S, (openmode)_M); }
        void close()
                {if (_Fb.close() == 0)
                        setstate(failbit); }
private:
        _Myfb _Fb;
        };

#define TRACELM(level, msg) if (dwTraceLevel >= level) { DumpHdr(dbgDump) << msg << _T("\r\n"); dbgDump.flush(); };
#define TRACELS(level, stmt) if (dwTraceLevel >= level) { stmt; }
#define TRACELSM(level, stmt, msg) if (dwTraceLevel >= level) {DumpHdr(dbgDump);  stmt; dbgDump << msg << _T("\r\n");  dbgDump.flush(); }
#define BEGIN_TRACEL(level) if (dwTraceLevel >= level) {
#define TRACES(stmt) stmt;
#define END_TRACEL }
#define END_TRACELM(msg) {DumpHdr(dbgDump) << msg << _T("\r\n");  dbgDump.flush(); } }

#ifdef _M_IX86
#define ASSERT(f) \
        do  { \
                if (!(f)) { \
                        dbgDump << "ASSERT Failed (" #f ") at: " << __FILE__ << " " << __LINE__;  dbgDump.flush(); \
                        _ASSERT(f);\
                } \
        } while (0)
#else
#define ASSERT(f) \
        do  { \
                if (!(f)) { \
                        dbgDump << "ASSERT Failed (" #f ") at: " << __FILE__ << " " << __LINE__;  dbgDump.flush(); \
                        _ASSERT(f);\
                } \
        } while (0)
#endif // _M_IX86

inline void TRACEINDENT() { ++dwTraceIndent; }
inline void TRACEOUTDENT() { ASSERT(dwTraceIndent != 0); --dwTraceIndent; }

#else //debug

#define TRACELM(level, msg)
#define TRACELS(level, stmt)
#define TRACELSM(level, stmt, msg)
#define BEGIN_TRACEL(level)
#define TRACES(stmt)
#define END_TRACEL
#define END_TRACELM(msg)
#define ASSERT(x)
#define TRACEINDENT()
#define TRACEOUTDENT()
#pragma warning (push)
#pragma warning (disable : 4018) // sign/unsign mismatch in ostream line 312
#include <fstream>
#pragma warning (pop)
#define STRSAFE_NO_CB_FUNCTIONS
#include <strsafe.h>
#define SIZEOF_CH(X) (sizeof(X)/sizeof(X[0]))

#endif // DEBUG
#endif // NO_VIDCTL_ASSERT_SUPPORT
#endif // NO_VIDCTL_TRACE_SUPPORT

#endif // TRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\throw.h ===
//==========================================================================;
//
// throw.h : exception handling code
// Copyright (c) Microsoft Corporation 1998.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef THROW_H
#define THROW_H

class ComException {
public:
    ComException(HRESULT hr) : m_hr(hr) {}
    ComException(ComException &ce) : m_hr(ce.m_hr) {}
        ComException& operator=(ComException &rhs) {
                if (this != &rhs) {
                        m_hr = rhs.m_hr;
                }
                return *this;
        }
        ComException& operator=(HRESULT rhs) {
                m_hr = rhs;
                return *this;
        }
        operator HRESULT() {
                return m_hr;
        }
private:
    HRESULT m_hr;
};


#define THROWCOM(x) throw ComException(x)

#define CATCHCOM_CLEANUP(x) catch (ComException& e) { \
                                { x; } \
                                return e; \
                            }

#define CATCHCOM() CATCHCOM_CLEANUP(;)

#define CATCHALL_CLEANUP(x) CATCHCOM_CLEANUP(x) \
                            catch (std::bad_alloc& e) { \
                                { x; } \
                                return E_OUTOFMEMORY; \
                            } catch (std::exception& e) { \
                                { x; } \
                                return E_UNEXPECTED; \
                            }

#define CATCHALL()  CATCHALL_CLEANUP(;)

#endif
// end of file throw.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\tunerequestimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// TuneRequestimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef TUNEREQUESTIMPL_H
#define TUNEREQUESTIMPL_H

#pragma once
#include <tuner.h>
#include <Components.h>

namespace BDATuningModel {

typedef CComQIPtr<ITuningSpace> PQTuningSpace;
typedef CComQIPtr<ILocator> PQLocator;

template<class T,
         class MostDerived = ITuneRequest, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE ITuneRequestImpl : 
    public IPersistPropertyBagImpl<T>,
	public IDispatchImpl<MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// ITuneRequest
public:
	bool m_bRequiresSave;
	ITuneRequestImpl() : m_bRequiresSave(false) {
        m_Components = new CComObject<CComponents>;
    }
    virtual ~ITuneRequestImpl() {}
	// undone: the below map entry stores a copy of the tuning space contents instead of a 
	// reference to the tuning space.  This should be changed to store a tuning space moniker
    BEGIN_PROP_MAP(ITuneRequestImpl)
        PROP_DATA_QI_ENTRY("Tuning Space", m_TS.p, __uuidof(ITuningSpace))
        PROP_DATA_QI_ENTRY("Locator", m_Locator.p, __uuidof(ILocator))
    END_PROP_MAP()

	PQTuningSpace m_TS;
	PQComponents m_Components;
	PQLocator m_Locator;

	STDMETHOD(get_TuningSpace)(/* [out, retval] */ ITuningSpace **ppTS){ 
		try {
			if (!ppTS) {
				return E_POINTER;
			}
			ATL_LOCKT();
            if (!m_TS) {
                return E_UNEXPECTED;
            }
			return m_TS.CopyTo(ppTS);
		} catch (...) {
			return E_OUTOFMEMORY;
		}
    }
	STDMETHOD(get_Components)(/* [out, retval] */ IComponents **ppC){ 
		try {
			if (!ppC) {
				return E_POINTER;
			}
			ATL_LOCKT();
            if (!m_Components) {
                return E_UNEXPECTED;
            }
			return m_Components.CopyTo(ppC);
		} catch (...) {
			return E_OUTOFMEMORY;
		}
    }
	STDMETHOD(Clone) (ITuneRequest **ppTR) {
		try {
			if (!ppTR) {
				return E_POINTER;
			}
			ATL_LOCKT();
			T* pt = static_cast<T*>(new CComObject<T>);
			if (!pt) {
				return E_OUTOFMEMORY;
			}
            if (!m_TS) {
                // corrupt tune request.  we can't have a tunerequest without an
                // attached tuning space since the tuning space is the factory
                // and always sets this property to non-null at creation time.
                // the only way to get a NULL is for an unpersist from a corrupt store
                // or a bug in a tuning space's implementation.
                return E_UNEXPECTED;
            }
            ASSERT(!pt->m_TS);
			HRESULT hr = m_TS->Clone(&pt->m_TS);
			if (m_Components) {
                if (pt->m_Components) {
                    pt->m_Components.Release();
                }
                ASSERT(!pt->m_Components);
				hr = m_Components->Clone(&pt->m_Components);
				if (FAILED(hr)) {
					delete pt;
					return hr;
				}
			}
			if (m_Locator) {
                ASSERT(!pt->m_Locator);
				hr = m_Locator->Clone(&pt->m_Locator);
				if (FAILED(hr)) {
					delete pt;
					return hr;
				}
			}
			pt->m_bRequiresSave = true;
			pt->AddRef();
			*ppTR = pt;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
    STDMETHOD(get_Locator) (ILocator **ppLocator) {
		try {
			if (!ppLocator) {
				return E_POINTER;
			}
			ATL_LOCKT();
			return m_Locator.CopyTo(ppLocator);
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
    };

    STDMETHOD(put_Locator) (ILocator *pLocator) {
		try {
			ATL_LOCKT();
            m_Locator = pLocator;
	        MARK_DIRTY(T);

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
    };

};

typedef CComQIPtr<ITuneRequest> PQTuneRequest;

}; // namespace

#endif // TUNEREQUESTIMPL_H
// end of file -- tunerequestimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\tunerimpl.h ===
//==========================================================================;
//
// tunerimpl.h : additional infrastructure to support implementing IMSVidTuner 
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef TUNERIMPL_H
#define TUNERIMPL_H

#include "videoinputimpl.h"
#include "tune.h"
#include <deviceeventimpl.h>

namespace MSVideoControl {

    template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidTuner>
    class DECLSPEC_NOVTABLE IMSVidTunerImpl :         
        public IMSVidVideoInputImpl<T, LibID, KSCategory, MostDerivedInterface> {
    public:

        TNTuningSpace m_TS;
        TNTuneRequest m_pCurrentTR;

        IMSVidTunerImpl() : m_TS(), m_pCurrentTR() {}
        virtual ~IMSVidTunerImpl() {}
        virtual HRESULT DoTune(TNTuneRequest& pTR) = 0;
        virtual HRESULT UpdateTR(TNTuneRequest& pTR) = 0;
        // IMSVidInputDevice
        STDMETHOD(IsViewable)(VARIANT* pv, VARIANT_BOOL *pfViewable)
        {
            if (!m_fInit) {
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidTuner), CO_E_NOTINITIALIZED);
            }
            if (!pv) {
                return E_POINTER;
            }
            return E_NOTIMPL;
        }

        STDMETHOD(View)(VARIANT* pv) {
            if (!m_fInit) {
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidTuner), CO_E_NOTINITIALIZED);
            }
            if (!pv) {
                return E_POINTER;
            }
            try {
                if (pv->vt != VT_DISPATCH && pv->vt != VT_UNKNOWN) {
                    return ImplReportError(__uuidof(T), IDS_INVALID_CONTENT, __uuidof(IMSVidTuner), E_INVALIDARG);
                }
                PQTuneRequest tr((pv->vt == VT_UNKNOWN) ? pv->punkVal : pv->pdispVal);
                if (!tr) {
                    return ImplReportError(__uuidof(T), IDS_INVALID_CONTENT, __uuidof(IMSVidTuner), E_INVALIDARG);
                }

                return put_Tune(tr);
            } catch(...) {
                return E_UNEXPECTED;
            }
        }

        // IMSVidTuner
        STDMETHOD(put_Tune)(ITuneRequest *pTR) {
            TRACELM(TRACE_DETAIL, "IMSVidTunerImpl<>::put_Tune()");
            if (!m_fInit) {
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidTuner), CO_E_NOTINITIALIZED);
            }
            if (!pTR) {
                return E_POINTER;
            }
            try {
                TNTuneRequest req(pTR);
                ASSERT(req);
                if (m_TS) {
                    // if this tuner has been initialized propertly it will have a tuning space
                    // that it handles already specified.  in that case, we should only
                    // handle tune requests for our ts
                    TNTuningSpace ts(req.TuningSpace());
                    if (ts != m_TS) {
                        return ImplReportError(__uuidof(T), IDS_INVALID_TS, __uuidof(IMSVidTuner), E_INVALIDARG);
                    }
                } else {
                    // undone: if dev init is correct this case should never occur
                    // return E_UNEXPECTED;
                }
                HRESULT hr = DoTune(req);
                if (SUCCEEDED(hr)) {
                    m_pCurrentTR = req;
                    m_pCurrentTR.Clone();
                    if (!m_TS) {
                        // undone: this is bad.  temporary hack until dev init is correct.
                        m_TS = req.TuningSpace();
                        m_TS.Clone();
                    }
                }
                return hr;
            } catch(...) {
                return E_INVALIDARG;
            }
        }
        STDMETHOD(get_Tune)(ITuneRequest **ppTR) {
            if (!m_fInit) {
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidTuner), CO_E_NOTINITIALIZED);
            }
            if (!ppTR) {
                return E_POINTER;
            }
            try {
                HRESULT hr = UpdateTR(m_pCurrentTR);
                if (FAILED(hr)) {
                    return hr;
                }
                return m_pCurrentTR.CopyTo(ppTR);
            } catch(...) {
                return E_INVALIDARG;
            }
        }

        STDMETHOD(get_TuningSpace)(ITuningSpace **ppTS) {
            if (!m_fInit) {
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidTuner), CO_E_NOTINITIALIZED);
            }
            if (ppTS == NULL)
                return E_POINTER;
            try {
                m_TS.CopyTo(ppTS);
                return NOERROR;
            } catch(...) {
                return E_UNEXPECTED;
            }
        }
        STDMETHOD(put_TuningSpace)(ITuningSpace* pTS) {
            return E_NOTIMPL;
        }
        };


    template <class T, const IID* piid = &IID_IMSVidTunerEvent, class CDV = CComDynamicUnkArray>
    class CProxy_Tuner : public CProxy_DeviceEvent<T, piid, CDV>
    {
        //Warning this class may be recreated by the wizard.
    public:
        VOID Fire_OnTuneChanged(IMSVidTuner *pTunerDev)
        {
            T* pT = static_cast<T*>(this);
            int nConnectionIndex;
            CComVariant* pvars = new CComVariant[1];
            int nConnections = m_vec.GetSize();

            for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
            {
                pT->Lock();
                CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
                pT->Unlock();
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
                if (pDispatch != NULL)
                {
                    pvars[0] = pTunerDev;
                    DISPPARAMS disp = { pvars, NULL, 1, 0 };
                    pDispatch->Invoke(eventidOnTuneChanged, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                }
            }
            delete[] pvars;

        }

    };


}; // namespace

#endif
// end of file - tunerimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\tstring.h ===
// tstring.h string helpers
// Copyright (c) Microsoft Corporation 1998.

#pragma once

#ifndef TSTRING_H
#define TSTRING_H

#include <tchar.h>
#include <string>
#include <atlconv.h>
#ifndef USE_TSTRING_CSTRING
#include <atltmp.h>
#endif

#ifdef DEBUG
typedef std::basic_string<TCHAR> base_tstring;
class Tstring : public base_tstring {
public:
	inline Tstring() {}
	virtual ~Tstring() {}
	inline Tstring(const base_tstring &ts) : base_tstring(ts) {}
	inline Tstring(const Tstring &ts) : base_tstring(ts) {}

	inline Tstring &operator=(const Tstring &rhs) {
		if (this != rhs.const_address()) {
			base_tstring::operator=(rhs);
		}
		return *this;
	}
	inline Tstring &operator=(const TCHAR *rhs) {
		if (this != reinterpret_cast<const Tstring *>(rhs)) {
			base_tstring::operator=(rhs);
		}
		return *this;
	}

	inline LPCTSTR operator&() const {
    // NOTE: this is based on c++ std basic_string. all caveats about
    // c_str method apply: ptr is read-only and invalid after another
    // non-const member is called
		return c_str();
	}

#ifndef _UNICODE
	inline Tstring &operator=(const LPCOLESTR rhs) {
		if (this != reinterpret_cast<const Tstring *>(rhs)) {
			USES_CONVERSION;
			base_tstring::operator=(OLE2T(rhs));
		}
		return *this;
	}
#else
	inline Tstring &operator=(const LPCSTR rhs) {
		if (this != reinterpret_cast<const Tstring *>(rhs)) {
			USES_CONVERSION;
			base_tstring::operator=(A2T(rhs));
		}
		return *this;
	}
#endif

    inline const Tstring *const_address() const {
        return this;
    }

    inline Tstring *address() {
        return this;
    }

};
#endif

#ifdef USE_TSTRING_CSTRING
class CString : public Tstring {
public:
	inline CString() : Tstring() {}
	inline CString(const Tstring &ts) : Tstring(ts) {}
	inline CString(const CString &cs) : Tstring(cs) {}
	virtual ~CString() {}
	inline LPCTSTR operator&() const {
    // NOTE: this is based on c++ std basic_string. all caveats about
    // c_str method apply: ptr is read-only and invalid after another
    // non-const member is called
		return c_str();
	}
	inline CString &operator=(const CString &rhs) {
		if (this != rhs.const_address()) {
			Tstring::operator=(rhs);
		}
		return *this;
	}
	inline CString &operator=(const TCHAR *rhs) {
		if (this != reinterpret_cast<const CString *>(rhs)) {
			Tstring::operator=(rhs);
		}
		return *this;
	}
    inline const CString *const_address() const {
        return this;
    }

    inline CString *address() {
        return this;
    }

	bool IsEmpty(void) const {
		return size() == 0;
	};
};
#endif

#endif
// end of file tstring.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\tuningspacecollectionimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// TuningSpaceCollectionImpl.h : Declaration of the TuningSpaceCollectionImpl.h
// Copyright (c) Microsoft Corporation 1999-2000

#include <tuner.h>

namespace BDATuningModel {

typedef CComQIPtr<ITuningSpace> PQTuningSpace;
typedef std::map<ULONG, CComVariant> TuningSpaceContainer_t;  // id->object mapping, id's not contiguous

// utilities for element management semantics for TuningSpaceContainerEnum_t
class stlmapClone
{
public:
	static HRESULT copy(VARIANT* p1, std::pair<const ULONG, CComVariant> *p2) {
		if (p2->second.vt != VT_DISPATCH && p2->second.vt != VT_UNKNOWN) {
			return DISP_E_TYPEMISMATCH;
		}
		PQTuningSpace pts(p2->second.punkVal);
		if (!pts) {
			return E_UNEXPECTED;
		}
		p1->vt = p2->second.vt;
		PQTuningSpace pnewts;
		HRESULT hr = pts->Clone(&pnewts);
		if (FAILED(hr)) {
			return hr;
		}
		p1->punkVal = pnewts.Detach();
		return NOERROR;
	}
	static void init(VARIANT* p) {VariantInit(p);}
	static void destroy(VARIANT* p) {VariantClear(p);}
};
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, stlmapClone, TuningSpaceContainer_t, CComMultiThreadModel> TuningSpaceContainerEnum_t;
class stlmapClone2
{
public:
	static HRESULT copy(ITuningSpace** p1, std::pair<const ULONG, CComVariant> *p2) {
		if (p2->second.vt != VT_DISPATCH && p2->second.vt != VT_UNKNOWN) {
			return DISP_E_TYPEMISMATCH;
		}
        PQTuningSpace p(p2->second.punkVal);
        if (!p) {
            return E_UNEXPECTED;
        }
        // don't ASSERT(p1 && !*p1);  if !p1 then clone will return E_POINTER and p1 itself
        // can point to unitialized memory if the caller passed down a new'd array of pointers
        // to enum::Next(). therefore if this clone causes a leak then its the callers bug
		return p->Clone(p1);
	}
	static void init(ITuningSpace** p) {*p = NULL;}
	static void destroy(ITuningSpace** p) {(*p)->Release(); *p = NULL;}
};
typedef CComEnumOnSTL<IEnumTuningSpaces, &__uuidof(IEnumTuningSpaces), ITuningSpace*, stlmapClone2, TuningSpaceContainer_t, CComMultiThreadModel> TuningSpaceEnum_t;


template<class T, class TSInterface, LPCGUID TSInterfaceID, LPCGUID TypeLibID> class TuningSpaceCollectionImpl : 
	public IDispatchImpl<TSInterface, TSInterfaceID, TypeLibID> {
public:

    TuningSpaceContainer_t m_mapTuningSpaces;

    virtual ~TuningSpaceCollectionImpl() {
        m_mapTuningSpaces.clear();
    }

	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IEnumVARIANT** ppVal) {
		try {
			if (ppVal == NULL) {
				return E_POINTER;
			}
			CComObject<TuningSpaceContainerEnum_t>* p;

			*ppVal = NULL;

			HRESULT hr = CComObject<TuningSpaceContainerEnum_t>::CreateInstance(&p);
			if (FAILED(hr) || !p) {
				return E_OUTOFMEMORY;
			}
			ATL_LOCKT();
			hr = p->Init(pT->GetUnknown(), m_mapTuningSpaces);
			if (FAILED(hr)) {
				delete p;
				return hr;
			}
			hr = p->QueryInterface(__uuidof(IEnumVARIANT), reinterpret_cast<LPVOID *>(ppVal));
			if (FAILED(hr)) {
				delete p;
				return hr;
			}
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}

	}
	STDMETHOD(get_EnumTuningSpaces)(/*[out, retval]*/ IEnumTuningSpaces** ppNewEnum) {
		if (!ppNewEnum) {
			return E_POINTER;
		}
		try {
			CComObject<TuningSpaceEnum_t>* p;

			*ppNewEnum = NULL;

			HRESULT hr = CComObject<TuningSpaceEnum_t>::CreateInstance(&p);
			if (FAILED(hr) || !p) {
				return E_OUTOFMEMORY;
			}
			ATL_LOCKT();
			hr = p->Init(pT->GetUnknown(), m_mapTuningSpaces);
			if (FAILED(hr)) {
				delete p;
				return hr;
			}
			hr = p->QueryInterface(__uuidof(IEnumTuningSpaces), (void**)ppNewEnum);
			if (FAILED(hr)) {
				delete p;
				return hr;
			}

			return NOERROR;
		} catch(...) {
			return E_UNEXPECTED;
		}
	}

	STDMETHOD(get_Count)(/*[out, retval]*/ long *plVal) {
		if (!plVal) {
			return E_POINTER;
		}
		try {
			ATL_LOCKT();
			*plVal = static_cast<long>(m_mapTuningSpaces.size());
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}

};

}; // namespace

// end of file - tuningspacecollectionimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\vidrect.h ===
//==========================================================================;
//
// vidrect.h : automation compliant auto-scaling gdi rect object
// Copyright (c) Microsoft Corporation 2000.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef VIDRECT_H
#define VIDRECT_H

#include <scalingrect.h>
#include <segment.h>
#include <dsextend.h>
#include <objectwithsiteimplsec.h>

#define INVALID_HWND_VALUE   (reinterpret_cast<HWND>(INVALID_HANDLE_VALUE))

namespace MSVideoControl {

typedef CComQIPtr<IMSVidRect, &__uuidof(IMSVidRect)> PQVidRect;


class ATL_NO_VTABLE __declspec(uuid("CB4276E6-7D5F-4cf1-9727-629C5E6DB6AE")) CVidRectBase : 
    public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CVidRectBase, &__uuidof(CVidRectBase)>,
	public CScalingRect,
    public IObjectWithSiteImplSec<CVidRectBase>,
	public IDispatchImpl<IMSVidRect, &__uuidof(IMSVidRect)>,
    public IObjectSafetyImpl<CVidRectBase, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
	public IPersistPropertyBagImpl<CVidRectBase>
{
BEGIN_COM_MAP(CVidRectBase)
	COM_INTERFACE_ENTRY(IMSVidRect)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()
DECLARE_PROTECT_FINAL_CONSTRUCT()
REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_VIDRECT_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CVidRectBase));

	BEGIN_CATEGORY_MAP(CMSVidBDATuner)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CVidRectBase)
        PROP_DATA_ENTRY("Top", top, VT_I4)
        PROP_DATA_ENTRY("Left", left, VT_I4)
        PROP_DATA_ENTRY("Right", right, VT_I4)
        PROP_DATA_ENTRY("Bottom", bottom, VT_I4)
    END_PROPERTY_MAP()

    CVidRectBase(const CRect& ri, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(ri, hwndi);
	}
    CVidRectBase(const CScalingRect& ri, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(ri, hwndi);
	}
	CVidRectBase(LONG l, LONG t, LONG r, LONG b, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(l, t, r, b, hwndi);
	}
	CVidRectBase(const RECT& srcRect, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(srcRect, hwndi);
	}
	CVidRectBase(LPCRECT lpSrcRect, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(lpSrcRect, hwndi);
	}
	CVidRectBase(POINT point, SIZE size, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(point, size, hwndi);
	}
	CVidRectBase(POINT topLeft, POINT bottomRight, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(topLeft, bottomRight, hwndi);
	}
	CVidRectBase(const CVidRectBase& vri) {
		CScalingRect::CScalingRect(vri);
	}

	CVidRectBase& operator=(const CVidRectBase& srcRect) {
		if (&srcRect != this) {
			CScalingRect::operator=(srcRect);
		}
		return *this;
	}
    CVidRectBase(){}
    virtual ~CVidRectBase() {}

    STDMETHOD(get_Top)(/*[out, retval]*/ LONG* plTopVal) {
		try {
			if (!plTopVal) {
				return E_POINTER;
			}
			*plTopVal = top;
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}
    STDMETHOD(put_Top)(/*[in]*/ LONG TopVal) {
		top = TopVal;
		m_bRequiresSave = true;
		return NOERROR;
	}
    STDMETHOD(get_Left)(/*[out, retval]*/ LONG* plLeftVal) {
		try {
			if (!plLeftVal) {
				return E_POINTER;
			}
			*plLeftVal = left;
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}
    STDMETHOD(put_Left)(/*[in]*/ LONG LeftVal) {
		left = LeftVal;
		m_bRequiresSave = true;
		return NOERROR;
	}
    STDMETHOD(get_Width)(/*[out, retval]*/ LONG* plWidthVal) {
		try {
			if (!plWidthVal) {
				return E_POINTER;
			}
			*plWidthVal = Width();
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}
    STDMETHOD(put_Width)(/*[in]*/ LONG WidthVal) {
		right = left + WidthVal;
		m_bRequiresSave = true;
		return NOERROR;
	}
    STDMETHOD(get_Height)(/*[out, retval]*/ LONG* plHeightVal) {
		try {
			if (!plHeightVal) {
				return E_POINTER;
			}
			*plHeightVal = Height();
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}
    STDMETHOD(put_Height)(/*[in]*/ LONG HeightVal) {
		bottom = top + HeightVal;
		m_bRequiresSave = true;
		return NOERROR;
	}
    STDMETHOD(get_HWnd)(/*[out, retval]*/ HWND* plHWndVal) {
		try {
			if (!plHWndVal) {
				return E_POINTER;
			}
			*plHWndVal = Owner();
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}
    STDMETHOD(put_HWnd)(/*[in]*/ HWND HWndVal) {
		try {
			Owner(HWndVal);
			return NOERROR;
		} catch(...) {
			return E_UNEXPECTED;
		}
	}
    STDMETHOD(put_Rect)(/*[in]*/ IMSVidRect* pVidRect) {
		try {
			if (!pVidRect) {
				return E_POINTER;
			}
			*this = *(static_cast<CVidRectBase*>(pVidRect));
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}
};

/////////////////////////////////////////////////////////////////////////////
// CVidRect
class CVidRect : public CComObject<CVidRectBase>
{
public:
	// undone add ctors and op= for all permutations of RECTL, POINTL, SIZEL

    CVidRect(const CRect& ri, HWND hwndi = INVALID_HWND_VALUE) {
		CVidRectBase::CVidRectBase(ri, hwndi);
	}
	CVidRect(LONG l, LONG t, LONG r, LONG b, HWND hwndi = INVALID_HWND_VALUE) {
		CVidRectBase::CVidRectBase(l, t, r, b, hwndi);
	}
	CVidRect(const RECT& srcRect, HWND hwndi = INVALID_HWND_VALUE) {
		CVidRectBase::CVidRectBase(srcRect, hwndi);
	}
	CVidRect(LPCRECT lpSrcRect, HWND hwndi = INVALID_HWND_VALUE) {
		CVidRectBase::CVidRectBase(lpSrcRect, hwndi);
	}
	CVidRect(POINT point, SIZE size, HWND hwndi = INVALID_HWND_VALUE) {
		CVidRectBase::CVidRectBase(point, size, hwndi);
	}
	CVidRect(POINT topLeft, POINT bottomRight, HWND hwndi = INVALID_HWND_VALUE) {
		CVidRectBase::CVidRectBase(topLeft, bottomRight, hwndi);
	}
	CVidRect(const CVidRect& vri) {
		CVidRectBase::CVidRectBase(vri);
	}

	CVidRect& operator=(const CVidRect& srcRect) {
		if (&srcRect != this) {
			CVidRectBase::operator=(srcRect);
		}
		return *this;
	}


    virtual ~CVidRect() {}

	// IPersistPropertyBag

};

};
#endif
// end of file vidrect.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\videoinputimpl.h ===
//==========================================================================;
//
// videoinputmpl.h : additional infrastructure to support implementing IMSVidVideoInput
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef VIDEOINPUTIMPL_H
#define VIDEOINPUTIMPL_H

#include "inputimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidVideoInputDevice>
    class DECLSPEC_NOVTABLE IMSVidVideoInputImpl :         
        public IMSVidInputDeviceImpl<T, LibID, KSCategory, MostDerivedInterface> {
//        public virtual CMSVidDeviceSegmentImpl {
public:
	IMSVidVideoInputImpl() {}
    virtual ~IMSVidVideoInputImpl() {}
    STDMETHOD(get_ImageSourceWidth)(long *x) {
        return E_NOTIMPL;
	}
    STDMETHOD(get_ImageSourceHeight)(long *y) {
        return E_NOTIMPL;
	}
    STDMETHOD(get_OverScan)(long *plPercent) {
        return E_NOTIMPL;
	}
    STDMETHOD(put_OverScan)(long lPercent) {
        return E_NOTIMPL;
	}
    STDMETHOD(get_Volume)(long *lVol) {
        return E_NOTIMPL;
	}
    STDMETHOD(put_Volume)(long lVol) {
        return E_NOTIMPL;
	}
    STDMETHOD(put_Balance)(long lBal) {
        return E_NOTIMPL;
	}
    STDMETHOD(get_Balance)(long *lBal) {
        return E_NOTIMPL;
	}
};

}; // namespace
#endif
// end of file - videoinputimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\webdvdimpl.h ===
//==========================================================================;
//
// webdvdimpl.h : additional infrastructure to support implementing IMSVidPlayback
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef WEBDVDIMPL_H
#define WEBDVDIMPL_H

#include "playbackimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidWebDVD>
    class DECLSPEC_NOVTABLE IMSVidWebDVDImpl :         
    	public IMSVidPlaybackImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:
    virtual ~IMSVidWebDVDImpl() {}
};
}; // namespace

#endif
// end of file - webdvdimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\xdsimpl.h ===
//==========================================================================;
//
// XDSimpl.h : additional infrastructure to support implementing IMSVidXDS
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef XDSIMPL_H
#define XDSIMPL_H

#include "featureimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidXDS>
    class DECLSPEC_NOVTABLE IMSVidXDSImpl : public IMSVidFeatureImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:
	    virtual ~IMSVidXDSImpl() {}
};

}; /// namespace

#endif
// end of file - XDSimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\tuningspaceimpl.h ===
// TuningSpace.h : Declaration of the CTuningSpace
// Copyright (c) Microsoft Corporation 1999.

#ifndef TUNINGSPACEIMPL_H
#define TUNINGSPACEIMPL_H

#include <tuner.h>
#include "componenttypes.h"

namespace BDATuningModel {

const int MAX_DEFAULT_PREFERRED_COMPONENT_TYPES = 64;

template<class T,
		 class TuneRequestType,
         class MostDerived = ITuningSpace, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE ITuningSpaceImpl : 
    public IPersistPropertyBagImpl<T>,
	public IDispatchImpl<MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{

public:
    ITuningSpaceImpl() {}
    virtual ~ITuningSpaceImpl() {}
    typedef ITuningSpaceImpl<T, TuneRequestType, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
    typedef CComQIPtr<ILocator> PQLocator;

    BEGIN_PROP_MAP(thistype)
        PROP_DATA_ENTRY("Name", m_UniqueName.m_str, VT_BSTR)
        PROP_DATA_ENTRY("Description", m_FriendlyName.m_str, VT_BSTR)
        PROP_DATA_ENTRY("Network Type", m_NetworkType.m_str, VT_BSTR)
        PROP_DATA_QI_ENTRY("Default Component Types", m_DefaultPreferredComponents.p, __uuidof(IComponentTypes))
        PROP_DATA_ENTRY("Frequency Mapping", m_FrequencyMapping.m_str, VT_BSTR_BLOB)
        PROP_DATA_QI_ENTRY("Default Locator", m_DefaultLocator.p, __uuidof(ILocator))
    END_PROPERTY_MAP()

	// note: don't put a com map in an impl.  it will override the derived classes
	// and script clients will get only get type info for the base class methods .  
	// only provide a com map in the most derived class representing the actual coclass
    
	CComBSTR m_UniqueName;
    CComBSTR m_FriendlyName;
    CComBSTR m_FrequencyMapping;
    CComBSTR m_NetworkType;
    PQComponentTypes m_DefaultPreferredComponents;
    PQLocator m_DefaultLocator;

// ITuningSpace
	STDMETHOD(get_UniqueName)(/* [out, retval] */ BSTR *pName){
		if (!pName) {
			return E_POINTER;
		}
		ATL_LOCKT();
        return m_UniqueName.CopyTo(pName);
    }
	STDMETHOD(put_UniqueName)(/* [in] */ BSTR Name){ 
		CHECKBSTRLIMIT(Name);
		ATL_LOCKT();
        m_UniqueName = Name;
        MARK_DIRTY(T);

    	return NOERROR;
    }
	STDMETHOD(get_FriendlyName)(/* [out, retval] */ BSTR *pName){ 
		if (!pName) {
			return E_POINTER;
		}
		ATL_LOCKT();
        return m_FriendlyName.CopyTo(pName);
    }
	STDMETHOD(put_FriendlyName)(/* [in] */ BSTR Name){ 
		CHECKBSTRLIMIT(Name);
		ATL_LOCKT();
        m_FriendlyName = Name;
        MARK_DIRTY(T);

    	return NOERROR;
    }
	STDMETHOD(get_CLSID)(/* [out, retval] */ BSTR *pbstrCLSID){ 
		if (!pbstrCLSID) {
			return E_POINTER;
		}
        try {
            GUID2 g;
			HRESULT hr = GetClassID(&g);
			if (FAILED(hr)) {
				return hr;
			}
			ATL_LOCKT();
            *pbstrCLSID = g.GetBSTR();
			return NOERROR;
        } CATCHCOM();
    }
	STDMETHOD(get_NetworkType)(/* [out, retval] */ BSTR *pNetworkTypeGuid){ 
		if (!pNetworkTypeGuid) {
			return E_POINTER;
		}
        try {
            GUID2 g;
			HRESULT hr = get__NetworkType(&g);
			if (FAILED(hr)) {
				return hr;
			}
            *pNetworkTypeGuid = g.GetBSTR();
			return NOERROR;
        } CATCHCOM();
    }
    // should be network provider clsid
	STDMETHOD(put_NetworkType)(/* [in] */ BSTR NetworkTypeGuid){ 
        try {
            GUID2 g(NetworkTypeGuid);
            return put__NetworkType(g);
        } CATCHCOM();
    }

	STDMETHOD(get__NetworkType)(/* [out, retval] */ GUID* pNetworkTypeGuid){ 
        if (!pNetworkTypeGuid) {
            return E_POINTER;
        }
        try {
			ATL_LOCKT();
            GUID2 g(m_NetworkType);
            memcpy(pNetworkTypeGuid, &g, sizeof(GUID));
    	    return NOERROR;
        } CATCHCOM();
    }
	STDMETHOD(put__NetworkType)(/* [out, retval] */ REFCLSID pNetworkTypeGuid){ 
        try {
            GUID2 g(pNetworkTypeGuid);
			ATL_LOCKT();
            // NOTE: the network type guid is the clsid for the network provider filter
            // for this type of this tuning space.  since we're only allowing 
            // ourselves to run from trusted zones we can assume that this clsid is also
            // trustworthy.  however, if we do more security review and decide to enable
            // use of the tuning model from the internet zone then this is no longer safe.
            // in this case, we need to get IInternetHostSecurityManager from IE and 
            // call ProcessURLAction(URLACTION_ACTIVEX_RUN) and make sure we get back
            // URLPOLICY_ALLOW.  otherwise, we're bypassing IE's list of known bad
            // objects.
            // see ericli's complete guide to script security part I on http://pgm/wsh
            // for more details.
            m_NetworkType = g.GetBSTR();
            MARK_DIRTY(T);
    	    return NOERROR;
        } CATCHCOM();
    }

	STDMETHOD(EnumCategoryGUIDs)(/* [out, retval] */ IEnumGUID **ppEnum){ 
        return E_NOTIMPL; 
    }
	STDMETHOD(EnumDeviceMonikers)(/* [out, retval] */ IEnumMoniker **ppEnum){ 
        return E_NOTIMPL; 
    }
	STDMETHOD(get_DefaultPreferredComponentTypes)(/* [out, retval] */ IComponentTypes** ppComponentTypes){ 
        if (!ppComponentTypes) {
            return E_POINTER;
        }

		ATL_LOCKT();
        m_DefaultPreferredComponents.CopyTo(ppComponentTypes);

    	return NOERROR;
    }
	STDMETHOD(put_DefaultPreferredComponentTypes)(/* [in] */ IComponentTypes* pNewComponentTypes){ 
        try {
            HRESULT hr = NOERROR;
            PQComponentTypes pct;
            if (pNewComponentTypes) {
                long lCount = 0;
                hr = pNewComponentTypes->get_Count(&lCount);
                if (FAILED(hr) || lCount > MAX_DEFAULT_PREFERRED_COMPONENT_TYPES) {
                    return E_INVALIDARG;
                }
                hr = pNewComponentTypes->Clone(&pct);
            }
            if (SUCCEEDED(hr)) {
    			ATL_LOCKT();
                m_DefaultPreferredComponents = pct;
                MARK_DIRTY(T);
            }
    	    return hr;
        } CATCHCOM();
    }
	STDMETHOD(CreateTuneRequest)(/* [out, retval] */ ITuneRequest **ppTuneRequest){ 
		if (!ppTuneRequest) {
			return E_POINTER;
		}
        TuneRequestType *pt = NULL;
		try {
			pt = new CComObject<TuneRequestType>;
			if (!pt) {
				return E_OUTOFMEMORY;
			}
			ATL_LOCKT();
			HRESULT hr = Clone(&pt->m_TS);
            if (FAILED(hr)) {
                delete pt;
                return hr;
            }
			pt->AddRef();
			*ppTuneRequest = pt;
			return NOERROR;
        } CATCHCOM_CLEANUP(delete pt);
    }
	STDMETHOD(get_FrequencyMapping)(/* [out, retval] */ BSTR *pMap){ 
        if(!pMap){
            return E_POINTER;
        }
		ATL_LOCKT();
        return m_FrequencyMapping.CopyTo(pMap);
    }
	STDMETHOD(put_FrequencyMapping)(/* [in] */ BSTR Map){ 
		CHECKBSTRLIMIT(Map);
		ATL_LOCKT();
        m_FrequencyMapping = &Map;
        MARK_DIRTY(T);

    	return NOERROR;
    }

	STDMETHOD(get_DefaultLocator)(/* [out, retval] */ ILocator** ppLocator){ 
        if (!ppLocator) {
            return E_POINTER;
        }
		ATL_LOCKT();
        m_DefaultLocator.CopyTo(ppLocator);

    	return NOERROR;
    }
	STDMETHOD(put_DefaultLocator)(/* [in] */ ILocator* NewLocator){ 
        try {
			ATL_LOCKT();
            PQLocator pl;
            HRESULT hr = NOERROR;
            if (NewLocator) {
                hr = NewLocator->Clone(&pl);
            }
            if (SUCCEEDED(hr)) {
                m_DefaultLocator = pl;
                MARK_DIRTY(T);
            }
    	    return hr;
        } CATCHCOM();
    }
	STDMETHOD(Clone) (ITuningSpace **ppTR) {
        T* pt = NULL;
		try {
			if (!ppTR) {
				return E_POINTER;
			}
			ATL_LOCKT();
			pt = static_cast<T*>(new CComObject<T>);
			if (!pt) {
				return E_OUTOFMEMORY;
			}
    
            pt->m_UniqueName = m_UniqueName;
            pt->m_FriendlyName = m_FriendlyName;
            pt->m_NetworkType = m_NetworkType;
            if (m_DefaultPreferredComponents) {
                ASSERT(!pt->m_DefaultPreferredComponents);
                HRESULT hr = m_DefaultPreferredComponents->Clone(&pt->m_DefaultPreferredComponents);
                if (FAILED(hr)) {
                    delete pt;
                    return hr;
                }
            }
            pt->m_FrequencyMapping = m_FrequencyMapping;
            if (m_DefaultLocator) {
                ASSERT(!pt->m_DefaultLocator);
                HRESULT hr = m_DefaultLocator->Clone(&pt->m_DefaultLocator);
                if (FAILED(hr)) {
                    delete pt;
                    return hr;
                }
            }
            
            pt->m_bRequiresSave = true;
			pt->AddRef();
			*ppTR = pt;
			return NOERROR;
        } CATCHCOM_CLEANUP(delete pt);
	}

};

}; //namespace

#endif // TUNINGSPACEIMPL_H
// end of file -- tuningspaceimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\w32extend.h ===
// w32extend.h - win32 helpers
// copyright (c) Microsoft Corp. 1998

#pragma once

#ifndef W32EXTEND_H
#define W32EXTEND_H

#include <guiddef.h>
#include <ocidl.h>
#include <urlmon.h>
#if defined(DEBUG) || defined(W32_OBJECT_STREAMING)
#include <atlconv.h>
#endif
using namespace ::ATL;
#include <atltmp.h>

#include <trace.h>
#include <throw.h>

// build a class to override the standard GUID in basetyps.h
// in order to put them into STL containers and dump them to debug
class GUID2 : public GUID {
private:
    void init(const LPCOLESTR guid) {
			OLECHAR temp[42];  // max guid string size
            HRESULT hr = StringCchCopyW(temp, SIZEOF_CH(temp), guid);
            if (FAILED(hr)) {
	            memset(this, 0, sizeof(GUID));
                THROWCOM(hr);
            }
            hr = CLSIDFromString(temp, this);
            if (FAILED(hr)) {
	            memset(this, 0, sizeof(GUID));
                THROWCOM(hr);
            }
    }

public:
    inline GUID2() : GUID(GUID_NULL) {}
    inline GUID2(const GUID2 &g) : GUID(g) {}
    inline GUID2(const struct _GUID &g) : GUID(g) {}
    inline GUID2(const struct _GUID *g) : GUID(*g) {}
    inline GUID2(const BSTR guid) {
        if (!guid || !SysStringLen(guid)) {
            memset(this, 0, sizeof(GUID));
        } else {
            init(guid);
        }
    }
    inline GUID2(const LPCOLESTR guid) {
        if (!guid || !ocslen(guid)) {
            memset(this, 0, sizeof(GUID));
        } else {
            init(guid);
        }
    }

    // operators
    GUID2 & operator=(const BSTR guid) {
        if (!guid || !SysStringLen(guid)) {
            memset(this, 0, sizeof(GUID));
        } else {
            init(guid);
        }
        return *this;
    }
    GUID2& operator=(const LPCOLESTR guid) {
        if (!guid || !ocslen(guid)) {
            memset(this, 0, sizeof(GUID));
        } else {
            init(guid);
        }
    }
    GUID2 & operator=(const GUID2 &g) {
        if (&g != this) {
            ASSERT(sizeof(*this) == sizeof(struct _GUID));
            memcpy(this, &g, sizeof(GUID2));
        }
        return *this;
    }
    GUID2 & operator=(const struct _GUID &g) {
        if (&g != this) {
            ASSERT(sizeof(*this) == sizeof(g));
            memcpy(this, &g, min(sizeof(GUID2), sizeof(GUID)));
        }
        return *this;
    }

    BSTR GetBSTR() const {
        OLECHAR guidstr[(((sizeof(_GUID) * 2/* bin to char*/) + 1/*str null term*/) * 2/*ansi to unicode*/)];
        int rc = StringFromGUID2(*this, guidstr, sizeof(guidstr)/sizeof(OLECHAR));
        ASSERT(rc);
        return SysAllocString(guidstr);
    }
#if defined(DEBUG) || defined(W32_OBJECT_STREAMING)
    void inline Dump(tostream &dc) const {
        BSTR guidstr(GetBSTR());
        USES_CONVERSION;
        dc << OLE2T(guidstr);
        ::SysFreeString(guidstr);
        return;
    }
#endif
    bool inline operator<(const GUID2 &op2) const {
        if (memcmp(this, &op2, sizeof(GUID2)) < 0) {
                return true;
        }
        return false;
    }
    bool inline operator>(const GUID2 &op2) const {
        if (memcmp(this, &op2, sizeof(GUID2)) > 0) {
                return true;
        }
        return false;
    }
    bool inline operator==(const GUID2 &op2) const {
        if (!memcmp(this, &op2, sizeof(GUID2))) {
                return true;
        }
        return false;
    }
    bool inline operator!=(const GUID2 &op2) const {
        if (memcmp(this, &op2, sizeof(GUID2))) {
                return true;
        }
        return false;
    }
    bool inline operator<(const GUID &op2) const {
        if (memcmp(this, &op2, sizeof(GUID)) < 0) {
                return true;
        }
        return false;
    }
    bool inline operator>(const GUID &op2) const {
        if (memcmp(this, &op2, sizeof(GUID)) > 0) {
                return true;
        }
        return false;
    }
    bool inline operator==(const GUID &op2) const {
        if (!memcmp(this, &op2, sizeof(GUID))) {
                return true;
        }
        return false;
    }
    bool inline operator!=(const GUID &op2) const {
        if (memcmp(this, &op2, sizeof(GUID))) {
                return true;
        }
        return false;
    }

};

typedef CComPtr<IUnknown> PUnknown;

#if defined(DEBUG) || defined(W32_OBJECT_STREAMING)
inline tostream &operator<<(tostream &dc, const GUID2 &g)
{
    g.Dump(dc);
    return dc;
}

inline tostream &operator<<(tostream &dc, const GUID &g)
{
    GUID2 g2(g);
    g2.Dump(dc);
    return dc;
}

inline tostream &operator<<(tostream &dc, const RECT& r)
{
    dc << "T(" << r.top << 
          ") L(" << r.left << 
          ") B(" << r.bottom << 
          ") R(" << r.right << 
          ") W(" << (r.right - r.left) << 
          ") H(" << (r.bottom - r.top) << ")";
    return dc;
}
inline tostream &operator<<(tostream &dc, const SIZE& s)
{
    dc << "X(" << s.cx << ") Y(" << s.cy << ")";
    return dc;
}
#if 0
inline tostream &operator<<(tostream &dc, ULONGLONG &ul) {
    TCHAR buf[128];
    _stprintf(buf, "%I64X", ul);
    dc << buf;
    return dc;
}
#endif

inline tostream &operator<<(tostream &dc, const VARIANT &v)
{
    USES_CONVERSION;
    switch (v.vt) {
    case VT_UI4:
        dc << _T("VT_UI4: ") << v.ulVal;
        break;
    case VT_UI8: {
        dc << _T("VT_UI8: ");
        TCHAR buf[128];
        _ui64tot(v.ullVal, buf, 16);
        dc << buf;
    } break;
    case VT_BSTR:
        dc << _T("VT_BSTR: ") << OLE2T(v.bstrVal);
        break;
    case VT_UNKNOWN:
        dc << _T("VT_UNKNOWN: ") << v.punkVal;
        break;
    case VT_DISPATCH:
        dc << _T("VT_DISPATCH: ") << v.pdispVal;
        break;
    case VT_UI1 | VT_ARRAY:
        dc << _T("VT_UI1 | VT_ARRAY: blob");
        break;
    default:
        dc << std::endl << "cant dump variant.  vt = " << (int)v.vt << std::endl;
    }
    return dc;
}
#endif

inline bool operator!(const VARIANT &v) {
    return v.vt == VT_EMPTY || v.vt == VT_NULL;
}
// provide an operator form and work around the fact that VarCmp
// only supports unsigned ints of size 1
inline bool operator==(const VARIANT &lhs, const VARIANT &rhs) {
    HRESULT hrc = VarCmp(const_cast<VARIANT*>(&lhs), 
                         const_cast<VARIANT*>(&rhs), 
                         LOCALE_USER_DEFAULT, 
                         0);
    if (hrc == DISP_E_BADVARTYPE) {
        // check for types VarCmp doesn't support that we need to support
        // coerce unsigned to next largest signed if possible and then
        // fall back to VarCmp for lowest risk way to get most identical
        // behavior
        // for UI8 which is max compiler supports we'll do the compare
        // ourselves using the compiler support
        switch (lhs.vt) {
        case VT_UI2: {
            VARIANT v;
            VariantInit(&v);
            hrc = VariantChangeTypeEx(&v, const_cast<VARIANT *>(&lhs), LOCALE_USER_DEFAULT, 0, VT_I4);
            if (SUCCEEDED(hrc)) {
                return operator==(v, rhs);
            }
		} break;
        case VT_UI4: {
            VARIANT v;
            VariantInit(&v);
            hrc = VariantChangeTypeEx(&v, const_cast<VARIANT *>(&lhs), LOCALE_USER_DEFAULT, 0, VT_I8);
            if (SUCCEEDED(hrc)) {
                return operator==(v, rhs);
            }
        } break;
        case VT_UI8: {
            if (rhs.vt == VT_UI8) {
                return lhs.ullVal == rhs.ullVal;
            } 
            VARIANT v;
            VariantInit(&v);
            hrc = VariantChangeTypeEx(&v, const_cast<VARIANT *>(&rhs), LOCALE_USER_DEFAULT, 0, VT_UI8);
            if (SUCCEEDED(hrc)) {
                return operator==(lhs, v);
            }
        } break;
        default: {
            // the problem is either lhs of some type we can't help with
            // or its the rhs.  so we'll check the rhs...
            switch(rhs.vt) {
            case VT_UI2: {
                VARIANT v;
                VariantInit(&v);
                hrc = VariantChangeTypeEx(&v, const_cast<VARIANT *>(&rhs), LOCALE_USER_DEFAULT, 0, VT_I4);
                if (SUCCEEDED(hrc)) {
                    return operator==(lhs, v);
                }
            } break;
            case VT_UI4: {
                VARIANT v;
                VariantInit(&v);
                hrc = VariantChangeTypeEx(&v, const_cast<VARIANT *>(&rhs), LOCALE_USER_DEFAULT, 0, VT_I8);
                if (SUCCEEDED(hrc)) {
                    return operator==(lhs, v);
                }
            } break;
            case VT_UI8: {
                if (lhs.vt == VT_UI8) {
                    return lhs.ullVal == rhs.ullVal;
                } 
                VARIANT v;
                VariantInit(&v);
                hrc = VariantChangeTypeEx(&v, const_cast<VARIANT *>(&lhs), LOCALE_USER_DEFAULT, 0, VT_UI8);
                if (SUCCEEDED(hrc)) {
                    return operator==(v, rhs);
                }
            }}; //switch rhs
            // must be some other bad type we can't help with
        }}; //switch lhs
    }
    return (hrc == VARCMP_EQ);
}
inline bool operator!=(const VARIANT &lhs, const VARIANT &rhs) {
    return !operator==(lhs, rhs);
}
typedef CComQIPtr<IEnumVARIANT, &IID_IEnumVARIANT> PQEnumVARIANT;

typedef CComPtr<IUnknown> PUnknown;
typedef CComQIPtr<IPersist> PQPersist;
typedef CComQIPtr<IPropertyBag, &IID_IPropertyBag> PQPropertyBag;
typedef CComQIPtr<IPropertyBag2> PQPropertyBag2;
typedef CComQIPtr<IPersistPropertyBag> PQPersistPropertyBag;
typedef CComQIPtr<IPersistPropertyBag2> PQPersistPropertyBag2;
typedef CComQIPtr<IMoniker, &IID_IMoniker> PQMoniker;
typedef CComQIPtr<IBindCtx> PQBindCtx;
typedef CComQIPtr<IServiceProvider> PQServiceProvider;
typedef CComQIPtr<IGlobalInterfaceTable> PQGIT;
typedef CComQIPtr<IRunningObjectTable> PQROT;
typedef CComQIPtr<IOleWindow> PQOleWindow;
typedef CComQIPtr<IMalloc> PQMalloc;
typedef CComQIPtr<IObjectWithSite> PQObjectWithSite;
typedef CComQIPtr<IConnectionPoint> PQConnectionPoint;
typedef CComQIPtr<IInternetHostSecurityManager> PQSecurityManager;



class W32Moniker : public PQMoniker {
public:
    inline W32Moniker() {}
    inline W32Moniker(const PQMoniker &a) : PQMoniker(a) {}
    inline W32Moniker(IMoniker *p) : PQMoniker(p) {}
    inline W32Moniker(IUnknown *p) : PQMoniker(p) {}
    inline W32Moniker(const W32Moniker &a) : PQMoniker(a) {}

    PQPropertyBag GetPropertyBag() const {
        PQPropertyBag pPropBag;
        HRESULT hr = (*this)->BindToStorage(0, 0, IID_IPropertyBag, reinterpret_cast<LPVOID *>(&pPropBag));
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "W32Moniker::GetPropertyBag() can't bind to storage hr = " << hr), "");
            THROWCOM(hr);
        }
        return pPropBag;
    }
    PUnknown GetObject() const {
        PUnknown pObj;
        HRESULT hr = (*this)->BindToObject(0, 0, __uuidof(IUnknown), reinterpret_cast<LPVOID *>(&pObj));
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "W32Moniker::GetObject() can't bind to object.  hr = " << hr), "");
            THROWCOM(hr);
        }
        return pObj;
    }
	CString DisplayName() const {
		LPOLESTR lpszName;
		HRESULT hr = (*this)->GetDisplayName(NULL, NULL, &lpszName);
		if (FAILED(hr)) {
			return CString();
		}
		CString rc(lpszName);
		CoTaskMemFree(lpszName);
		return rc;
	}
};

inline HRESULT IsSafeZone(DWORD dwZone) {
    switch (dwZone) {
    case URLZONE_LOCAL_MACHINE:
    case URLZONE_INTRANET:
    case URLZONE_TRUSTED:
        // the fixed list of zones we trust
        return NOERROR;
    default:  
        // everything else is untrusted
        return E_FAIL;
    }
}
inline HRESULT IsSafeSite(IUnknown* pSite) {
    PQServiceProvider psp(pSite);
    if (!psp) {
        // no service provider interface on the site implies that we're not running in IE
        // so by defn running local and trusted thus we return OK
        return NOERROR;
    }
    PQSecurityManager pManager;
    HRESULT hr = psp->QueryService(SID_SInternetHostSecurityManager, IID_IInternetHostSecurityManager, (LPVOID *)&pManager);
    if (FAILED(hr)) {
        // no security manager interface on the site's service provider implies that we're not 
        // running in IE, so by defn running local and trusted thus we return OK
        return NOERROR;
    }
    const int MAXZONE = MAX_SIZE_SECURITY_ID+6/*scheme*/+4/*zone(dword)*/+1/*wildcard*/+1/*trailing null*/;
    char pbSecurityId[MAXZONE];
    DWORD pcbSecurityId = sizeof(pbSecurityId);
    ZeroMemory(pbSecurityId, sizeof(pbSecurityId));
    hr = pManager->GetSecurityId(reinterpret_cast<BYTE*>(pbSecurityId), &pcbSecurityId, NULL);
    if(FAILED(hr)){
        // security manager not working(unexpected). but, the site tried to provide one. thus we
        // must assume untrusted content and fail
        return E_FAIL;   
    }
    char *pbEnd = pbSecurityId + pcbSecurityId - 1;
    if (*pbEnd == '*') {  //ignore the optional wildcard flag
        pbEnd--;
    }
    pbEnd -= 3;  // point to beginning of little endian zone dword
    DWORD dwZone = *(reinterpret_cast<long *>(pbEnd));
    return IsSafeZone(dwZone);
}

typedef CComQIPtr<IDispatch, &IID_IDispatch> PQDispatch;

#endif // w32extend.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\vidvidimpl.h ===
//==========================================================================;
// MSVidVideoRenderer.h : Declaration of the CMSVidVideoRenderer
// copyright (c) Microsoft Corp. 1998-1999.
//==========================================================================;

#ifndef __MSVidVIDEORENDERERIMPL_H_
#define __MSVidVIDEORENDERERIMPL_H_

#pragma once

#include <algorithm>
#include <evcode.h>
#include <uuids.h>
#include <amvideo.h>
#include <strmif.h>
#include "vidrect.h"
#include "vrsegimpl.h"
#include "outputimpl.h"
#include "seg.h"
#include "videorenderercp.h"
#include "strmif.h"
#include "resource.h"       // main symbols



//typedef CComQIPtr<IVMRSurfaceAllocator> PQVMRSAlloc;
//typedef CComQIPtr<IVMRAlphaBitmap> PQVMRAlphaBitm;
/////////////////////////////////////////////////////////////////////////////
// CMSVidVideoRenderer
template<class T, LPCGUID LibID, LPCGUID Category, class MostDerivedClass = IMSVidVideoRenderer>
    class DECLSPEC_NOVTABLE IMSVidVideoRendererImpl :
        public IMSVidOutputDeviceImpl<T, LibID, Category, MostDerivedClass>,
    	public IMSVidVRGraphSegmentImpl<T> {
    public:
    IMSVidVideoRendererImpl() 
	{
        m_opacity = -1;
        m_rectPosition.top = -1;
        m_rectPosition.left = -1;
        m_rectPosition.bottom = -1;
        m_rectPosition.right = -1;
        m_SourceSize = sslFullSize;
        m_lOverScan = 1;
	}
    virtual ~IMSVidVideoRendererImpl() {
            m_PQIPicture.Release();
    }
protected:
typedef IMSVidVRGraphSegmentImpl<T> VRSegbasetype;
    PQIPic m_PQIPicture;
    FLOAT m_opacity;
    NORMALIZEDRECT m_rectPosition;
    SourceSizeList m_SourceSize;
    LONG m_lOverScan;
    CScalingRect m_ClipRect;

public:
    virtual HRESULT SetVRConfig() {
        HRESULT hr = S_OK;
        if (m_pVMR) {
            hr = VRSegbasetype::SetVRConfig();
            if (FAILED(hr)) {
                return hr;
            }
            if(m_pVMRWC){
                hr = m_pVMRWC->SetColorKey(m_ColorKey);
            }
            else{
                return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), E_FAIL);  
            }
            if (FAILED(hr)  && hr != E_NOTIMPL) {
                return hr;
            }
        }
        return NOERROR;
    }

    STDMETHOD(Refresh)() {
        ReComputeSourceRect();
        return VRSegbasetype::Refresh();
    }

// IMSVidVideoRenderer
	STDMETHOD(get_OverScan)(LONG * plPercent)
	{
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        if (plPercent == NULL) {
			return E_POINTER;
        }
        try {
            *plPercent = m_lOverScan;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }

	}
	STDMETHOD(put_OverScan)(LONG lPercent)
	{
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        try {
            if(lPercent > 4900 || lPercent < 0){
                return ImplReportError(__uuidof(T), IDS_INVALID_OVERSCAN, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);  
            }
            m_lOverScan = lPercent;
            return ReComputeSourceRect();
        } catch(...) {
            return E_UNEXPECTED;
        }
	}

	
    STDMETHOD(get_SourceSize)(/*[out, retval]*/ SourceSizeList *pCurrentSize) {
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        if (!pCurrentSize) {
			return E_POINTER;
        }
        try {
            *pCurrentSize = m_SourceSize;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
    // TODO: add checks for input value being null
    STDMETHOD(get_MaxVidRect)(/*[out, retval]*/ IMSVidRect **ppVidRect){ 
        HRESULT hr = S_OK;
        CComQIPtr<IMSVidRect>PQIMSVRect;
        try{
            PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(0,0,0,0));
            if(!PQIMSVRect){
                throw(E_UNEXPECTED);
            }

            if(!m_pVMR){
                throw(ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED));
            }
            long dwWidth, dwHeight;
            if(m_pVMRWC){
                hr = m_pVMRWC->GetMaxIdealVideoSize(&dwWidth, &dwHeight);
                if(FAILED(hr)){
                    throw(hr);
                }
            }
            else{
                throw(ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), E_FAIL));  
            }
            PQIMSVRect->put_Height(dwHeight);
            PQIMSVRect->put_Width(dwWidth);
        }
        catch(HRESULT hres){
            PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(-1,-1,-1,-1));
            *ppVidRect = PQIMSVRect.Detach();
            return hres;
        }
        *ppVidRect = PQIMSVRect.Detach();
        return hr;
        
    }
    STDMETHOD(get_MinVidRect)(/*[out, retval]*/ IMSVidRect **ppVidRect){ 
        HRESULT hr = S_OK;
        CComQIPtr<IMSVidRect>PQIMSVRect;
        try{
            PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(0,0,0,0));
            if(!PQIMSVRect){
                throw(E_UNEXPECTED);
            }
            if(!m_pVMR){
                throw(ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED));
            }
            long dwWidth, dwHeight;
            if(m_pVMRWC){
                hr = m_pVMRWC->GetMinIdealVideoSize(&dwWidth, &dwHeight);
                if(FAILED(hr)){
                    throw(hr);
                }
            }
            else{
                throw(ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IMSVidVideoRenderer), E_FAIL));  
            }
            PQIMSVRect->put_Height(dwHeight);
            PQIMSVRect->put_Width(dwWidth);

        }
        catch(HRESULT hres){
            PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(-1,-1,-1,-1));
            *ppVidRect = PQIMSVRect.Detach();
            return hres;
        }
        *ppVidRect = PQIMSVRect.Detach();
        return hr;
        
    }
    STDMETHOD(put_SourceSize)(/*[in]*/ SourceSizeList NewSize) {
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        try {
            SourceSizeList prev = m_SourceSize;
            m_SourceSize = NewSize;
            if (m_SourceSize != prev) {
                return ReComputeSourceRect();
            }
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
    STDMETHOD(get_CustomCompositorClass)(/*[out, retval]*/ BSTR *CompositorCLSID) {
        try{
            if(!CompositorCLSID){
                return E_POINTER;
            }
            GUID2 gRetVal;
            HRESULT hr = get__CustomCompositorClass(&gRetVal);
            if(SUCCEEDED(hr)){
                *CompositorCLSID = gRetVal.GetBSTR();
                return S_OK;
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
		return S_OK;
	}
    STDMETHOD(get__CustomCompositorClass)(/*[out, retval]*/ GUID* CompositorCLSID) {
        HRESULT hr = S_OK;
        try{

            if(!CompositorCLSID){
                return E_POINTER;
            }
            if(m_compositorGuid != GUID_NULL){
                *CompositorCLSID = m_compositorGuid;
                return S_OK;
            }
            PQVMRImageComp pRetVal;
            hr = get__CustomCompositor(&pRetVal);            
            if(FAILED(hr)){
                return hr;
            }
            CComQIPtr<IPersist> ipRet(pRetVal);

            hr = ipRet->GetClassID((CLSID*)CompositorCLSID);
            if(SUCCEEDED(hr)){
                return S_OK;
            }
            else{
                return E_UNEXPECTED;
            }
            
        }
        catch(...){
            return E_UNEXPECTED;
        }
		return S_OK;
	}

    STDMETHOD(put_CustomCompositorClass)(/*[in]*/ BSTR CompositorCLSID) {
        try{
            GUID2 inGuid(CompositorCLSID);
            HRESULT hr = put__CustomCompositorClass(inGuid);
            if(SUCCEEDED(hr)){
                return S_OK;
            }
            else{
                return hr;
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
        return S_OK;
    }

    STDMETHOD(put__CustomCompositorClass)(/*[in]*/ REFCLSID CompositorCLSID) {
        try{
            CComQIPtr<IVMRImageCompositor>IVMRICPtr;
            IVMRICPtr.Release();
            HRESULT hr = CoCreateInstance( CompositorCLSID, NULL, CLSCTX_INPROC_SERVER, IID_IVMRImageCompositor, (LPVOID*) &IVMRICPtr);
            if(FAILED(hr)){
                return E_UNEXPECTED;
            }
            hr = put__CustomCompositor(IVMRICPtr);
            if(FAILED(hr)){
                return hr;
            }
            else{
                return S_OK;
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
        return S_OK;
	}

    STDMETHOD(get__CustomCompositor)(/*[out, retval]*/ IVMRImageCompositor** Compositor) {
        try{
            if(!Compositor){
                return E_POINTER;
            }
            if(!ImCompositor){
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);;
            }
            else{
                *Compositor = ImCompositor;
                return S_OK;
            }  
        }
        catch(...){
            return E_UNEXPECTED;
        }
		return S_OK;
	}

    STDMETHOD(put__CustomCompositor)(/*[in]*/ IVMRImageCompositor* Compositor) {
        try{
            if(!Compositor){
                return E_POINTER;
            }
            ImCompositor = Compositor;
            HRESULT hr = CleanupVMR();
            if(FAILED(hr)){
                return hr;
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
        return S_OK;
        
    }

    STDMETHOD(get_AvailableSourceRect)(IMSVidRect **ppVidRect) {
        CComQIPtr<IMSVidRect>PQIMSVRect =  static_cast<IMSVidRect *>(new CVidRect(0,0,0,0));
        try{
            if(!ppVidRect){
                return E_POINTER;
            }
            SIZE Size, Ar;
            HRESULT hr = get_NativeSize(&Size, &Ar);
            hr = PQIMSVRect->put_Height(Size.cy);
            if(FAILED(hr)){
                throw(hr);
            }
            hr = PQIMSVRect->put_Width(Size.cx);
            if(FAILED(hr)){
                throw(hr);
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
        *ppVidRect = PQIMSVRect.Detach();
        return S_OK;
    }

    STDMETHOD(put_ClippedSourceRect)(IMSVidRect *pVidRect) {
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        if (!pVidRect) {
            return E_POINTER;
        }
        try {
            m_ClipRect = *(static_cast<CScalingRect*>(static_cast<CVidRect*>(pVidRect)));
            return ReComputeSourceRect();
        } catch(...) {
            return E_UNEXPECTED;
        }
	}

    STDMETHOD(get_ClippedSourceRect)(IMSVidRect **ppVidRect) {
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        if (!ppVidRect) {
			return E_POINTER;
        }
        try {
            CComQIPtr<IMSVidRect>PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(-1,-1,-1,-1));
            PQIMSVRect->put_Left(m_ClipRect.left);
            PQIMSVRect->put_Height(m_ClipRect.bottom - m_ClipRect.top);
            PQIMSVRect->put_Top(m_ClipRect.top);
            PQIMSVRect->put_Width(m_ClipRect.right - m_ClipRect.left);            
            *ppVidRect = PQIMSVRect.Detach();
            return S_OK;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
/*************************************************************************/
/* Function:    Capture                                                  */
/* Description: Returns the current image on screen                      */
/*************************************************************************/
 
STDMETHOD(Capture)(IPictureDisp **currentImage){
        HBITMAP hBitmap = 0;
        HPALETTE hPalette = 0;
        //VMRALPHABITMAP vmrAlphaBitmapStruct;
        CComQIPtr<IPicture> retPicture;
        PICTDESC PictDescStruct;
        HRESULT hr = S_OK;
        BYTE *lpDIB = NULL;
        try{
            if(!currentImage){
                throw(E_POINTER);
            }
            if(!m_pVMR){
                throw(E_FAIL);
            }
            if(m_pVMRWC){
                hr = m_pVMRWC->GetCurrentImage(&lpDIB);
            }
            else{
                throw(ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IMSVidVideoRenderer), E_FAIL));  
            }
            if(FAILED(hr)){
                throw(hr);
            }
            HDC     curDC   = GetDC(NULL);
            UINT    wUsage  = DIB_RGB_COLORS;
            DWORD   dwFlags = CBM_INIT;
            hBitmap = CreateDIBitmap(curDC,
                reinterpret_cast<BITMAPINFOHEADER*>(lpDIB), dwFlags,
                reinterpret_cast<void *>((LPBYTE)(lpDIB) + (int)(reinterpret_cast<BITMAPINFOHEADER*>(lpDIB)->biSize)),
                reinterpret_cast<BITMAPINFO*>(lpDIB),
                wUsage);
            
            
            ReleaseDC(NULL,curDC);
            ZeroMemory(&PictDescStruct, sizeof(PictDescStruct));
            PictDescStruct.bmp.hbitmap = hBitmap;
            PictDescStruct.bmp.hpal = NULL;
            PictDescStruct.picType = PICTYPE_BITMAP; 
            PictDescStruct.cbSizeofstruct = sizeof(PictDescStruct);
            hr = OleCreatePictureIndirect(&PictDescStruct, IID_IPicture, TRUE, (void **)&retPicture);
            if(SUCCEEDED(hr)){
                hr = retPicture.QueryInterface(reinterpret_cast<IPictureDisp**>(currentImage));
                return hr;
            }
            else{
                throw(hr);
            }
            

        }
        catch(HRESULT hres){
            hr = hres;
        }
        catch(...){
            hr = E_UNEXPECTED;
        }
        if(lpDIB){
            CoTaskMemFree(lpDIB);
        }
        return hr;
}
/*************************************************************************/
/* Function:    get_MixerBitmap                                          */
/* Description: Returns the current alpha bitmap to script wrapped in a  */
/*              IPictureDisp.                                            */
/*************************************************************************/
    STDMETHOD(get_MixerBitmap)(/*[out,retval]*/ IPictureDisp** ppIPDisp){
#if 0
        HDC *pHDC = NULL; 
        HBITMAP hBitmap = 0;
        HPALETTE hPalette = 0;
        VMRALPHABITMAP vmrAlphaBitmapStruct;
        PQIPicDisp retPicture;
        CComQIPtr<IVMRMixerBitmap> PQIVMRMixerBitmap;
        PICTDESC PictDescStruct;
        try{
            HRESULT hr = get__MixerBitmap(&PQIVMRMixerBitmap);
            if(FAILED(hr)){
                return hr; 
            }
            hr = PQIVMRMixerBitmap->GetAlphaBitmapParameters(&vmrAlphaBitmapStruct);
            if(FAILED(hr)){
                return hr; 
            }
            hr = vmrAlphaBitmapStruct.pDDS->GetDC(pHDC); 
            if(FAILED(hr)){
                return hr;
            }
            hBitmap = static_cast<HBITMAP>(GetCurrentObject(*pHDC, OBJ_BITMAP));
            if(!hBitmap){ 
                return hr;
            }
            hPalette = static_cast<HPALETTE>(GetCurrentObject(*pHDC, OBJ_PAL)); 
            if(!hPalette){
                return hr ;
            }
            PictDescStruct.bmp.hbitmap = hBitmap;
            PictDescStruct.bmp.hpal = hPalette;
            PictDescStruct.picType = PICTYPE_BITMAP; 
            PictDescStruct.cbSizeofstruct = sizeof(PictDescStruct.bmp);
            hr = OleCreatePictureIndirect(&PictDescStruct, IID_IPictureDisp, true, reinterpret_cast<void**> (&retPicture));
            if(FAILED(hr)){
                return hr;
            }
        }
        catch(HRESULT hr){
            return hr;
        }
        catch(...){
            return E_FAIL;
        }
        ppIPDisp = &retPicture.Detach(); 
        return S_OK;
#endif    
        // If m_PQIPicture is set, return it
        try{
            if(m_PQIPicture){
                CComQIPtr<IPictureDisp> PQIPDisp(m_PQIPicture);
                *ppIPDisp = PQIPDisp.Detach();
                throw S_OK;
            }
            else{
                throw ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
            }

        }
        catch(HRESULT hres){
            return hres;
        }
        catch(...){
            return E_UNEXPECTED;
        }
        
    }
    
    /*************************************************************************/
    /* Function:    get__MixerBitmap                                         */
    /* Description: Returns the IVMRMixerBitmap from the VMR                 */
    /*************************************************************************/
    STDMETHOD(get__MixerBitmap)(/*[out, retval]*/ IVMRMixerBitmap ** ppIVMRMBitmap){
        try{
            if(!ppIVMRMBitmap){
                return E_POINTER;
            }
            // Make sure there is a VMR filter init'ed
            if(!m_pVMR){
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
            }
            CComQIPtr<IVMRMixerBitmap> PQIVMRMBitmap(m_pVMR);
            *ppIVMRMBitmap = PQIVMRMBitmap.Detach();
        }
        catch(HRESULT hr){
            return hr;
        }
        catch(...){
            return E_UNEXPECTED;
        }
        return S_OK;
    }
    /*************************************************************************/
    /* Function:    put_MixerBitmap                                          */
    /* Description: Updates the current VMR Alpha Bitmap                     */
    /*              uses SutupMixerBitmap helper function                    */
    /*************************************************************************/    
    STDMETHOD(put_MixerBitmap)(/*[in*/  IPictureDisp* pIPDisp){ 
        try{
            return SetupMixerBitmap(pIPDisp);
        }
        catch(HRESULT hr){
            return hr;
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }

    /*************************************************************************/
    /* Function:    put__MixerBitmap                                         */
    /* Description: Updates the current VMR Alpha Bitmap                     */
    /*              directly using the VMR fucntions                         */
    /*************************************************************************/    
    STDMETHOD(put__MixerBitmap)(/*[in]*/ VMRALPHABITMAP * pVMRAlphaBitmapStruct){ //pMixerPicture
        try{
            HRESULT hr = S_OK;
            if(!pVMRAlphaBitmapStruct){
                return E_POINTER;   
            }
            // Make sure there is a vmr to add the bitmap to
            if(!m_pVMR){
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
            }
            // Querry the vmr for the MixerBitmap Interface
            CComQIPtr<IVMRMixerBitmap> pVMRMBitmap(m_pVMR);
            if (!pVMRMBitmap) {
                return E_UNEXPECTED;
            }
            // Set the mixer bitmap to pVMRAlphaBitmapStruct
            hr = pVMRMBitmap->SetAlphaBitmap(pVMRAlphaBitmapStruct);
            return hr;
        }
        catch(HRESULT hr){
            return hr;
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }
    
    /**************************************************************************/
    /* Function:    get_MixerBitmapPositionRect                               */
    /* Description: Lets script folk access the position of the overlay bitmap*/
    /*              the units are normalized vs the display rect so the values*/
    /*              should be between 0 and 1 though will be converted if they*/
    /*              are not                                                   */
    /**************************************************************************/   
    STDMETHOD(get_MixerBitmapPositionRect)(/*[out,retval]*/IMSVidRect **ppIMSVRect){
        HRESULT hr = S_OK;
        CComQIPtr<IMSVidRect>PQIMSVRect;
        try{
            CComQIPtr<IVMRMixerBitmap> PQIVMRMBitmap;
            PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(-1,-1,-1,-1));
            VMRALPHABITMAP VMRAlphaBitmap;
            if(!m_pVMR){
                hr = S_FALSE;
                throw(hr);
            }
            hr = get__MixerBitmap(&PQIVMRMBitmap);
            // If the VMRBitmap is not set on the VRM, if it is not make sure that the local one is set
            if(SUCCEEDED(hr) ){    
                // QI for the Parameters
                hr = PQIVMRMBitmap->GetAlphaBitmapParameters(&VMRAlphaBitmap);
                // if it fails or they are not set make sure that the local copy is
                if(SUCCEEDED(hr)){
                    // Make sure that the rDest points are valid top and left : [0,1)
                    // and right and bottom (0,1]
                    if(VMRAlphaBitmap.rDest.top >= 0   && VMRAlphaBitmap.rDest.left >= 0   && 
                        VMRAlphaBitmap.rDest.top < 1    && VMRAlphaBitmap.rDest.left < 1    &&
                        VMRAlphaBitmap.rDest.right <= 1 && VMRAlphaBitmap.rDest.bottom <= 1 &&
                        VMRAlphaBitmap.rDest.right > 0 && VMRAlphaBitmap.rDest.bottom > 0){
                        // Make sure the local copy of the normalized rect is upto date
                        m_rectPosition = VMRAlphaBitmap.rDest;           
                    }
                }
            }
            if( m_rectPosition.left < 0 || m_rectPosition.top < 0 || 
                m_rectPosition.right < 0 || m_rectPosition.bottom < 0 ){ 
                hr = S_FALSE;
                throw(hr);
            }
            else{
                // Convert and copy the values in the local copy of the normalized rect to the return rect
                hr = PQIMSVRect->put_Top(static_cast<long> (m_rectPosition.top * m_rectDest.Height()));
                if(FAILED(hr)){
                    hr = ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
                    throw(hr);
                }
                // bottom * height - top
                hr = PQIMSVRect->put_Height(static_cast<long>((m_rectPosition.bottom * m_rectDest.Height())
                    - (m_rectPosition.top * m_rectDest.Height())));
                if(FAILED(hr)){
                    hr = ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
                    throw(hr);
                }            
                // right * width - left
                hr = PQIMSVRect->put_Width(static_cast<long>(m_rectPosition.right * m_rectDest.Width() 
                    - (m_rectPosition.left * m_rectDest.Width())));
                if(FAILED(hr)){
                    hr = ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
                    throw(hr);
                }
                hr = PQIMSVRect->put_Left(static_cast<long>(m_rectPosition.left * m_rectDest.Width()));
                if(FAILED(hr)){
                    hr = ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
                    throw(hr);
                }
            }
            *ppIMSVRect = PQIMSVRect.Detach();
            return S_OK;
        }
        catch(HRESULT hres){
            if(FAILED(hres)){
                return hres;
            }
            if(m_rectDest){
                PQIMSVRect.Release();
                PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(m_rectDest));
            }
            else{
                PQIMSVRect.Release();
                PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(-1,-1,-1,-1));
            }
            *ppIMSVRect = PQIMSVRect.Detach();                    
            return S_FALSE;
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }

    /**************************************************************************/
    /* Function:    put_MixerBitmapPositionRect                               */
    /* Description: Lets script folk change the position of the overlay bitmap*/
    /*              the units are normalized vs the display rect so the values*/
    /*              should be between 0 and 1 though will be converted if they*/
    /*              are not                                                   */
    /**************************************************************************/       
    STDMETHOD(put_MixerBitmapPositionRect)(/*[in]*/ IMSVidRect *pIMSVRect){ 

        if(pIMSVRect){
            NORMALIZEDRECT NormalizedRectStruct;
            long lValue;
            NormalizedRectStruct.left = -1.f;
            NormalizedRectStruct.top = -1.f;
            NormalizedRectStruct.right = -1.f;
            NormalizedRectStruct.bottom = -1.f;
            if(SUCCEEDED(pIMSVRect->get_Left(&lValue))){
                if(m_rectDest.Width() != 0){
                    // check m_rectDest.Width() for zero
                    if(lValue > 0){
                        NormalizedRectStruct.left = 
                            static_cast<float>(lValue)/static_cast<float>(m_rectDest.Width());
                    }
                    else{
                        NormalizedRectStruct.left = static_cast<float>(lValue); 
                    }
                }
            }
            if(SUCCEEDED(pIMSVRect->get_Top(&lValue))){
                if(m_rectDest.Height() != 0){
                    if(lValue > 0){
                        NormalizedRectStruct.top = 
                            static_cast<float>(lValue)/static_cast<float>(m_rectDest.Height());
                    }
                    else{
                        NormalizedRectStruct.top = static_cast<float>(lValue);
                    }
                }
            }
            if(SUCCEEDED(pIMSVRect->get_Width(&lValue))){
                if(m_rectDest.Width() != 0){      
                    if(lValue > 0){
                        NormalizedRectStruct.right = 
                            (static_cast<float>(lValue)/static_cast<float>(m_rectDest.Width())) 
                            + static_cast<float>(NormalizedRectStruct.left);
                    }
                }
            }
            if(SUCCEEDED(pIMSVRect->get_Height(&lValue))){
                if(m_rectDest.Width() != 0){
                    if(lValue > 0){
                        NormalizedRectStruct.bottom = 
                            (static_cast<float>(lValue)/static_cast<float>(m_rectDest.Height())) 
                            + static_cast<float>(NormalizedRectStruct.top);
                    }
                }
            }
            if(NormalizedRectStruct.top < 0 || NormalizedRectStruct.left < 0 || 
                NormalizedRectStruct.top > 1 || NormalizedRectStruct.left > 1 || 
                NormalizedRectStruct.right < 0 || NormalizedRectStruct.bottom < 0 || 
                NormalizedRectStruct.right > 1 || NormalizedRectStruct.bottom > 1){
                return ImplReportError(__uuidof(T), IDS_E_MIXERSRC, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
            }
            m_rectPosition = NormalizedRectStruct;
        }
        if(m_PQIPicture == NULL){
            return S_OK;
        }
        else{
            return SetupMixerBitmap(reinterpret_cast<IPictureDisp*>(-1));
        }
    }
    /**************************************************************************/
    /* Function:    get_MixerBitmapOpacity                                    */
    /* Description: lets script access the opacity value                      */
    /*              should be between 0 and 100 (%)                           */
    /**************************************************************************/    
    STDMETHOD(get_MixerBitmapOpacity)(/*[out,retval]*/ int *pwOpacity){
        CComQIPtr<IVMRMixerBitmap> PQIVMRMBitmap;
        VMRALPHABITMAP VMRAlphaBitmapStruct;
        HRESULT hr = get__MixerBitmap(&PQIVMRMBitmap);
        if(SUCCEEDED(hr)){
            hr = PQIVMRMBitmap->GetAlphaBitmapParameters(&VMRAlphaBitmapStruct);
            if(SUCCEEDED(hr)){    
                if(m_opacity != VMRAlphaBitmapStruct.fAlpha){
                    m_opacity = VMRAlphaBitmapStruct.fAlpha;
                }
            }
        }
        if(m_opacity == -1){ 
            return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        if(m_opacity > 1 || m_opacity < 0){
            return E_UNEXPECTED;
        }
        *pwOpacity = static_cast<int>(m_opacity*100);
        return S_OK;
    }
    /**************************************************************************/
    /* Function:    put_MixerBitmapOpacity                                    */
    /* Description: lets script set the value opacity                         */
    /*              should be between 0 and 100 (%)                           */
    /**************************************************************************/     
    STDMETHOD(put_MixerBitmapOpacity)(/*[in]*/ int wOpacity){
        // make sure the value is between 0 and 100
        if(wOpacity >=0 && wOpacity <= 100){
            if(wOpacity == 0){
                //if it is 0 set it by hand instead of deviding by 0
                m_opacity = static_cast<float>(wOpacity);
            }
            m_opacity = static_cast<float>(wOpacity)/100.f;
        }
        else{
            return ImplReportError(__uuidof(T), IDS_E_OPACITY, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
        }
        if(!m_PQIPicture){
            return S_OK;
        }
        else{
            HRESULT hr = SetupMixerBitmap(reinterpret_cast<IPictureDisp*>(-1));
            return hr;
        }
    }
    /**************************************************************************/
    /* Function:    SetupMixerBitmap                                          */
    /* Description: big nasty function to set bitmap, opacity and the position*/
    /*              rect. It wraps everyting up in a mixer bitmap struct and  */
    /*              then passes it off to put__MixerBitmap                    */
    /*              It is both a helper function and a automation method so   */
    /*              that script people can make sure that transparent overlays*/
    /*              dont show up opaque for a few frames                      */
    /*                  for reference the vmralphabitmap struct               */
    /* typedef struct _VMRALPHABITMAP {                                       */
    /*  DWORD                   dwFlags;// flags word = VMRBITMAP_HDC         */
    /*  HDC                     hdc;    // DC for the bitmap to copy          */
    /*  LPDIRECTDRAWSURFACE7    pDDS;   // DirectDraw surface to copy IGNORED */
    /*  RECT                    rSrc;   // rectangle to copy from the sourceR */
    /*  NORMALIZEDRECT          rDest;  // output rectangle in composition space*/
    /*  FLOAT	            fAlpha;     // opacity of the bitmap              */
    /*  } VMRALPHABITMAP, *PVMRALPHABITMAP;                                   */
    /**************************************************************************/ 
    STDMETHOD(SetupMixerBitmap)(/*[in]*/ IPictureDisp* pIPDisp = NULL, /*[in]*/ long wOpacity = -1, 
        /*[in]*/ IMSVidRect *pIMSVRect = NULL){
        VMRALPHABITMAP VMRAlphaBitmapStruct;
        ZeroMemory(&VMRAlphaBitmapStruct, sizeof(VMRALPHABITMAP));

        RECT rSource;
        ZeroMemory(&rSource, sizeof(RECT));
        
        long lPicHeight, lPicWidth;
        
        HRESULT hr = S_OK;
        
        try{
            if(!pIPDisp){
				if(m_PQIPicture){
					m_PQIPicture.Release();
				}
                VMRAlphaBitmapStruct.dwFlags = VMRBITMAP_DISABLE;
                return hr = put__MixerBitmap(&VMRAlphaBitmapStruct);
            }
            // Our input is a IPictureDisp which we need to massage into a VMRALPHABITMAP
            // Problem is that it does not quite all go in but what does we will keep and pass on up
			
			if(pIPDisp == reinterpret_cast<IPictureDisp*>(-1)){
				CComQIPtr<IPicture>PQIPicture(m_PQIPicture); 
                if(!PQIPicture){
                    return S_OK;
                }
			} 
			else if(pIPDisp){
                // QI for a IPicture
                CComQIPtr<IPicture>PQIPicture(pIPDisp); 
                if(!PQIPicture){
                    return E_NOINTERFACE;
                }
                // Save the IPicture for possible use later
                m_PQIPicture = PQIPicture;
            }

            // Get the source rect size (and for some reason ole returns the size 
            // in tenths of a millimeter so I need to convert it)
            short shortType;
            m_PQIPicture->get_Type(&shortType);
            if(shortType != PICTYPE_BITMAP){
                return ImplReportError(__uuidof(T), IDS_E_MIXERBADFORMAT, __uuidof(IMSVidVideoRenderer), E_INVALIDARG); // Need to add a the is not a valid picture string 
            }
            hr = m_PQIPicture->get_Height(&lPicHeight);
            if(FAILED(hr)){
                return ImplReportError(__uuidof(T), IDS_E_IPICTURE, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
            }
            hr = m_PQIPicture->get_Width(&lPicWidth);
            if(FAILED(hr)){
                return ImplReportError(__uuidof(T), IDS_E_IPICTURE, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
            }
            SIZEL x, y; 
            AtlHiMetricToPixel((const SIZEL*)&lPicWidth, &(x));
            AtlHiMetricToPixel((const SIZEL*)&lPicHeight, &(y));
            // The AtlHiMetricToPixel function returns a size with the cx value set (no idea why)
            rSource.right = x.cx;
            rSource.bottom = y.cx;
            

            // create a hdc to store the bitmap
            HDC memHDC = CreateCompatibleDC(NULL);
            
            // create a bitmap to store in the hdc
            HBITMAP memHBIT = 0; 

            // pull out the bitmap from the IlPicture
            hr = m_PQIPicture->get_Handle(reinterpret_cast<OLE_HANDLE*>(&memHBIT));
            if(FAILED(hr)){
                return ImplReportError(__uuidof(T), IDS_E_IPICTURE, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
            }

            // Stuff the bitmap into a hdc and keep handle to delete bitmap later
            HBITMAP delHBIT = static_cast<HBITMAP>(SelectObject(memHDC, memHBIT));

            // Put all of the collected info into a VMRBITMAP stuct and pass it on
            VMRAlphaBitmapStruct.rSrc = rSource;
            VMRAlphaBitmapStruct.hdc = memHDC;
            VMRAlphaBitmapStruct.dwFlags = VMRBITMAP_HDC;
            
            // If the wOpacity value is valid use it
            if(wOpacity >=0 && wOpacity <= 100){
                if(wOpacity == 0){
                    m_opacity = wOpacity;
                }
                m_opacity = static_cast<float>(wOpacity/100.f);
                VMRAlphaBitmapStruct.fAlpha = static_cast<float>(m_opacity);
            }
            // wOpacity is not set so check other values
            // if m_opacity is set use it, if not default to 50% (.5)
            else if (wOpacity == -1){
                if(m_opacity < 0){
                    VMRAlphaBitmapStruct.fAlpha = .5f;
                }
                else{
                    VMRAlphaBitmapStruct.fAlpha = m_opacity;
                }
            } 
            // Bad wOpacity value give them an error
            else{
                return ImplReportError(__uuidof(T), IDS_E_OPACITY, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
            }
            // If the m_rectPostion is set use it, else default to full screen 
            if(pIMSVRect){
                NORMALIZEDRECT NormalizedRectStruct;
                long lValue;
                NormalizedRectStruct.left = -1.f;
                NormalizedRectStruct.top = -1.f;
                NormalizedRectStruct.right = -1.f;
                NormalizedRectStruct.bottom = -1.f;
                if(SUCCEEDED(pIMSVRect->get_Left(&lValue))){
                    if(m_rectDest.Width() != 0){
                        // check m_rectDest.Width() for zero
                        if(lValue > 0){
                            NormalizedRectStruct.left = 
                                static_cast<float>(lValue)/static_cast<float>(m_rectDest.Width());
                        }
                        else{
                            NormalizedRectStruct.left = static_cast<float>(lValue); 
                        }
                    }
                }
                if(SUCCEEDED(pIMSVRect->get_Top(&lValue))){
                    if(m_rectDest.Height() != 0){
                        if(lValue > 0){
                            NormalizedRectStruct.top = 
                                static_cast<float>(lValue)/static_cast<float>(m_rectDest.Height());
                        }
                        else{
                            NormalizedRectStruct.top = static_cast<float>(lValue);
                        }
                    }
                }
                if(SUCCEEDED(pIMSVRect->get_Width(&lValue))){
                    if(m_rectDest.Width() != 0){      
                        if(lValue > 0){
                            NormalizedRectStruct.right = 
                                (static_cast<float>(lValue)/static_cast<float>(m_rectDest.Width())) 
                                + static_cast<float>(NormalizedRectStruct.left);
                        }
                    }
                }
                if(SUCCEEDED(pIMSVRect->get_Height(&lValue))){
                    if(m_rectDest.Width() != 0){
                        if(lValue > 0){
                            NormalizedRectStruct.bottom = 
                                (static_cast<float>(lValue)/static_cast<float>(m_rectDest.Height())) 
                                + static_cast<float>(NormalizedRectStruct.top);
                        }
                    }
                }
                if(NormalizedRectStruct.top < 0 || NormalizedRectStruct.left < 0 || 
                    NormalizedRectStruct.top > 1 || NormalizedRectStruct.left > 1 || 
                    NormalizedRectStruct.right < 0 || NormalizedRectStruct.bottom < 0 || 
                    NormalizedRectStruct.right > 1 || NormalizedRectStruct.bottom > 1){
                    return ImplReportError(__uuidof(T), IDS_E_MIXERSRC, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
                }
                m_rectPosition = NormalizedRectStruct;
                VMRAlphaBitmapStruct.rDest = m_rectPosition;
            }
            else{
                if( m_rectPosition.left < 0 || m_rectPosition.top < 0 || m_rectPosition.right < 0 || m_rectPosition.bottom < 0 ){
                    VMRAlphaBitmapStruct.rDest.left = 0.f;
                    VMRAlphaBitmapStruct.rDest.top = 0.f;
                    VMRAlphaBitmapStruct.rDest.right = 1.f;
                    VMRAlphaBitmapStruct.rDest.bottom = 1.f;
                }
                else{
                    VMRAlphaBitmapStruct.rDest = m_rectPosition;
                }
            }
            // If it is all valid then this is all good
            hr = put__MixerBitmap(&VMRAlphaBitmapStruct);

            if(!DeleteDC(memHDC)){
                return ImplReportError(__uuidof(T), IDS_E_CANT_DELETE, __uuidof(IMSVidVideoRenderer), ERROR_DS_CANT_DELETE);
            }
            if(SUCCEEDED(hr)){
                return S_OK;
            }
            else{
                return hr;
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_UsingOverlay)(/*[out, retval]*/ VARIANT_BOOL *pfUseOverlay) {
        return get_UseOverlay(pfUseOverlay);
    }
    STDMETHOD(put_UsingOverlay)(/*[in]*/ VARIANT_BOOL fUseOverlayVal) {
        return put_UseOverlay(fUseOverlayVal);
    }
    STDMETHOD(get_FramesPerSecond)(/*[out, retval]*/ long *pVal){
        try{
            if(pVal){
                if(!m_pVMR){
                    throw(ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED));
                }
                IQualProp *IQProp = NULL;
                HRESULT hr = m_pVMR->QueryInterface(IID_IQualProp, reinterpret_cast<void**>(&IQProp));
                if(FAILED(hr)){
                    return hr;
                } 
                if(!IQProp){
                    return E_NOINTERFACE;
                }
                hr = IQProp->get_AvgFrameRate(reinterpret_cast<int*>(pVal));
                IQProp->Release();
                return hr;
            }
            else{
                return E_POINTER;
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(put_DecimateInput)(/*[in]*/ VARIANT_BOOL bDeci){
        try{
            if(bDeci != VARIANT_TRUE && bDeci != VARIANT_FALSE){
                return E_INVALIDARG;
            }
            m_Decimate = (bDeci == VARIANT_TRUE);
            if(!m_pVMR){
                return S_OK;
            }
            DWORD curPrefs;
            DWORD deci;
            CComQIPtr<IVMRMixerControl>PQIVMRMixer(m_pVMR);
            if(!PQIVMRMixer){
                return E_UNEXPECTED;
            }
            HRESULT hr = PQIVMRMixer->GetMixingPrefs(&curPrefs);
            if(FAILED(hr)){
                return hr;
            }
            deci = (m_Decimate?MixerPref_DecimateOutput:MixerPref_NoDecimation);
            if(!(curPrefs&deci)){
                hr = CleanupVMR();
                if(FAILED(hr)){
                    return hr;
                }
            }
            return NOERROR;
        }
        catch(...){
            return E_UNEXPECTED;
        }

    }

    STDMETHOD(get_DecimateInput)(/*[out,retval]*/ VARIANT_BOOL *pDeci){
        try{
            if(!pDeci){
                return E_POINTER;
            }
            if(!m_pVMR){
                throw(ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED));
            }
            DWORD curPrefs;
            CComQIPtr<IVMRMixerControl>PQIVMRMixer(m_pVMR);
            if(!PQIVMRMixer){
                return E_UNEXPECTED;
            }
            HRESULT hr = PQIVMRMixer->GetMixingPrefs(&curPrefs);
            if(FAILED(hr)){
                return hr;
            }
            *pDeci = ((curPrefs&MixerPref_DecimateMask)==MixerPref_DecimateOutput)? VARIANT_TRUE : VARIANT_FALSE;
            return NOERROR;
        }
        catch(...){
            return E_UNEXPECTED;
        }

    }

    STDMETHOD(ReComputeSourceRect)() {
        switch (m_SourceSize) {
    case sslFullSize: {
        CSize sz;
        CSize ar;
        if(m_pVMRWC){
            HRESULT hr = m_pVMRWC->GetNativeVideoSize(&sz.cx, &sz.cy, &ar.cx, &ar.cy);
            if (FAILED(hr)) {
                return hr;
            }
            TRACELSM(TRACE_PAINT, (dbgDump << "CMSVidVideoRenderer::ReComputeSourceRect() sslFullSize vmr sz = " << sz), "");
        }
        CRect r(0, 0, sz.cx, sz.cy);
        TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidVideoRenderer::ReComputeSource() full = " << r), "");
        return put_Source(r);
                      } break;
    case sslClipByOverScan: {
        CSize sz;
        CSize ar;
        if(m_pVMRWC){
            HRESULT hr = m_pVMRWC->GetNativeVideoSize(&sz.cx, &sz.cy, &ar.cx, &ar.cy);
            if (FAILED(hr)) {
                return hr;
            }
            TRACELSM(TRACE_PAINT, (dbgDump << "CMSVidVideoRenderer::ReComputeSourceRect() sslClipByOverScan vmr sz = " << sz), "");
        }
        CRect r(0, 0, sz.cx, sz.cy);
        CRect r2;
        float fpct = m_lOverScan / 10000.0; // overscan is in hundredths of pct, i.e 1.75% == 175
        long wcrop = (long)(r.Width() * fpct + 0.5);
        long hcrop = (long)(r.Height() * fpct + 0.5);
        r2.left = 0 + wcrop;
        r2.top = 0 + hcrop;
        r2.right = r2.left + r.Width() - (2.0 * wcrop);
        r2.bottom = r2.top + r.Height() - (2.0 * hcrop);
        TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidVideoRenderer::ReComputeSource() over = " << m_lOverScan <<
            " w " << wcrop <<
            " h " << hcrop), "");
        TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidVideoRenderer::ReComputeSource() full = " << r << " clip = " << r2), "");

        return put_Source(r2);
                            } break;
    case sslClipByClipRect: {
        TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidVideoRenderer::ReComputeSource() cliprect = " << m_ClipRect), "");
        if(m_ClipRect.Width() == 0 && m_ClipRect.Height() == 0){
            CSize sz;
            CSize ar;
            if(m_pVMRWC){
                HRESULT hr = m_pVMRWC->GetNativeVideoSize(&sz.cx, &sz.cy, &ar.cx, &ar.cy);
                if (FAILED(hr)) {
                    return hr;
                }

                TRACELSM(TRACE_PAINT, (dbgDump << "CMSVidVideoRenderer::ReComputeSourceRect() sslClipByClipRect vmr sz = " << sz), "");
            }
            CRect r(0, 0, sz.cx, sz.cy);
            TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidVideoRenderer::ReComputeSource() full = " << r), "");
            return put_Source(r);   
        } else{
            TRACELSM(TRACE_PAINT, (dbgDump << "CMSVidVideoRenderer::ReComputeSourceRect() sslClipByClipRect cliprect = " << m_ClipRect), "");
            return put_Source(m_ClipRect);
        }
                            } break;
    default:{
        return E_INVALIDARG;
            } break;
        }

        return NOERROR;
    }
};
#endif //__MSVidVIDEORENDERER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\vrsegimpl.h ===
//==========================================================================;
//
// vrsegimpl.h : additional infrastructure to support implementing IMSVidVRGraphSegment
// nicely from c++
// Copyright (c) Microsoft Corporation 1999-2000
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef VRSEGIMPL_H
#define VRSEGIMPL_H

#include "segimpl.h"
#include "devices.h"
#include <deviceeventimpl.h>

namespace MSVideoControl {
const int VIDCTL_NONMIXINGMODE = -1;
const int VIDCTL_MIXINGMODE = 0;
const int DEFAULT_MAX_STREAMS = 4;  // dvd needs 3(video, cc, subpic) plus we want a spare

#ifndef SPI_GETDROPSHADOW
#define SPI_GETDROPSHADOW                   0x1024
#endif

#ifndef SPI_SETDROPSHADOW
#define SPI_SETDROPSHADOW                   0x1025
#endif
#if 0
const COLORKEY DEFAULT_COLOR_KEY = { CK_RGB, 0, 0xff00ff, 0xff00ff};  // magenta
const AM_ASPECT_RATIO_MODE DEFAULT_ASPECT_RATIO_MODE = AM_ARMODE_STRETCHED;
#else
const OLE_COLOR DEFAULT_COLOR_KEY = 0xff00ff;  // magenta
const OLE_COLOR DEFAULT_BORDER_COLOR = 0x000000;  // black
#endif

typedef CComQIPtr<IVMRWindowlessControl> PQWindowlessControl;
typedef CComQIPtr<IPicture> PQIPic;
typedef CComQIPtr<IPictureDisp> PQIPicDisp;
typedef CComQIPtr<IVMRFilterConfig> PQVMRConfig;
typedef CComQIPtr<IVMRSurfaceAllocator> PQVMRSAlloc;
typedef CComQIPtr<IVMRImageCompositor> PQVMRImageComp;

template<class T, class MostDerivedClass = IMSVidVRGraphSegment>
    class DECLSPEC_NOVTABLE IMSVidVRGraphSegmentImpl :
        public IMSVidGraphSegmentImpl<T, MSVidSEG_DEST, &GUID_NULL,  MostDerivedClass>  {
protected:
        typedef IMSVidGraphSegmentImpl<T, MSVidSEG_DEST, &GUID_NULL,  MostDerivedClass> basetype;

        IMSVidVRGraphSegmentImpl() :
            m_hOwner(INVALID_HWND),
            m_fUseOverlay(false),
            m_fVisible(false),
            m_iVideoRenderer(-1),
            m_rectDest(0, 0, 0, 0),
            m_rectSrc(0, 0, 0, 0),
            m_ColorKey(DEFAULT_COLOR_KEY),
            m_BorderColor(DEFAULT_BORDER_COLOR),
            m_fMaintainAspectRatio(true),
            m_fHaveOriginalSystemEffects(false),
            m_bDropShadows(false),
            m_bSmoothing(false),
            m_vmrMixing(true),
            m_Decimate(false),
            m_vmRendererMode(VMRMode_Renderless),
            m_compositorGuid(GUID_NULL),
            m_APid(-1),
            m_vidSuppressEffects(true)
            {}

        PQVMRImageComp ImCompositor;
        GUID2 m_compositorGuid;
        HWND m_hOwner;
        bool m_fUseOverlay;
        bool m_fVisible;
        CRect m_rectSrc;
        CRect m_rectDest;
        PQVMRConfig m_pVMR;
        PQVMRWindowlessControl m_pVMRWC;
        int m_iVideoRenderer;
        OLE_COLOR m_ColorKey;
        OLE_COLOR m_BorderColor;
        BOOL m_bSmoothing;
        BOOL m_bDropShadows;
        bool m_fHaveOriginalSystemEffects;
        bool m_fMaintainAspectRatio;
        LONG m_vmRendererMode;
        bool m_vmrMixing;
        BOOL m_Decimate;
        PQVMRSAlloc qiSurfAlloc;
        long m_APid;
        bool m_vidSuppressEffects;

public:
    virtual ~IMSVidVRGraphSegmentImpl() {}
    void DisableAPM() {
        SetThreadExecutionState(ES_DISPLAY_REQUIRED | ES_CONTINUOUS);
    }

    void EnableAPM() {
        SetThreadExecutionState(ES_CONTINUOUS);
    }

    HRESULT Unload(void) {
        IMSVidGraphSegmentImpl<CMSVidVideoRenderer, MSVidSEG_DEST, &GUID_NULL>::Unload();
        m_iVideoRenderer = -1;
    }

    HRESULT UpdatePos() {
        if(!m_pVMRWC){
            return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), S_FALSE);
        }
        CRect s(m_rectSrc), d(m_rectDest);
        if (!s ||
            !m_fVisible ||
            m_hOwner == INVALID_HWND ||
            !::IsWindow(m_hOwner) ||
            !d.Width() ||
            !d.Height()) {
            d = CRect();
        }
        if (!d) {
            s = CRect();
        }
#if 0
            if (d && m_hOwner != INVALID_HWND) {
                ::MapWindowPoints(GetDesktopWindow(), m_hOwner, reinterpret_cast<LPPOINT>(&d), 2);
            }
#endif
            TRACELSM(TRACE_PAINT, (dbgDump << "VRSegimpl::UpdatePos() s = " << s << " d = " << d), "");
#if 0       
            PUnknown vidUnknown(m_pContainer);
            DWORD Temp_id = (DWORD_PTR)(vidUnknown.p);
            if(m_APid == Temp_id){
#endif
                return m_pVMRWC->SetVideoPosition(s, d);
#if 0
            }

            else{
            return NO_ERROR;
            }
#endif
    }

    virtual HRESULT SetVRConfig() {
        if (m_pVMR) {
            HRESULT hr;
            DWORD dwRenderPrefs = 0;

            if (m_fUseOverlay) {
                if(m_vidSuppressEffects){
                    if (!m_fHaveOriginalSystemEffects) {
                        if (!SystemParametersInfo(SPI_GETFONTSMOOTHING, 0, &m_bSmoothing, 0)) {
                            TRACELSM(TRACE_ERROR, (dbgDump << "VRSegimpl::SetVRConfig() can't get original drop shadows rc = " << GetLastError()), "");            
                        }
                        if (!SystemParametersInfo(SPI_GETDROPSHADOW, 0, &m_bDropShadows, 0)) {
                            TRACELSM(TRACE_ERROR, (dbgDump << "VRSegimpl::SetVRConfig() can't get original font smoothing rc = " << GetLastError()), "");            
                        }
                        m_fHaveOriginalSystemEffects = true;
                    }
                    BOOL val = FALSE;
                    if (!SystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(FALSE), 0)) { // only send change notice once on the last one
                        TRACELSM(TRACE_ERROR, (dbgDump << "VRSegimpl::SetVRConfig() can't turn off font smoothing rc = " << GetLastError()), "");            
                    }
                    if (!SystemParametersInfo(SPI_SETFONTSMOOTHING, FALSE, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE)) {
                        TRACELSM(TRACE_ERROR, (dbgDump << "VRSegimpl::SetVRConfig() can't turn off font smoothing rc = " << GetLastError()), "");            
                    }
                }
                dwRenderPrefs = /*RenderPrefs_ForceOverlays |*/ RenderPrefs_DoNotRenderColorKeyAndBorder;
                TRACELM(TRACE_DETAIL, "IMSVidGraphSegmentImpl::SetVRConfig() forcing overlays");
            } else {
                TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidGraphSegmentImpl::SetVRConfig() border color = " << hexdump(m_BorderColor)), "");
                if(m_pVMRWC){
                    hr = m_pVMRWC->SetBorderColor(m_BorderColor);
                    if (FAILED(hr)) {
                        return hr;
                    }
                }
                dwRenderPrefs = RenderPrefs_ForceOffscreen; // no overlays allowed
            }
            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidGraphSegmentImpl::SetVRConfig() rprefs = " << hexdump(dwRenderPrefs)), "");
            hr = m_pVMR->SetRenderingPrefs(dwRenderPrefs);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::SetVRConfig() can't set vmr rendering prefs: hr = " << std::hex << hr), "");
                return E_UNEXPECTED;
            }

#if 0
                hr = m_pVMR->SetBorderColor(0x0101ff);
//                hr = m_pVMR->SetBorderColor(m_BorderColor);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::SetVRConfig() border hack failed hr = " << hexdump(hr)), "");
                }
#endif

            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidGraphSegmentImpl::SetVRConfig() armode = " << (m_fMaintainAspectRatio ? "VMR_ARMODE_LETTER_BOX" : "VMR_ARMODE_NONE")), "");
            if(m_pVMRWC){
                if (m_fUseOverlay) {
                    // if we're doing the colorkey and all that then don't let the vmr
                    // do letterboxing because we get rounding errors which causes
                    // colorkey colored lines around the edges
                    hr = m_pVMRWC->SetAspectRatioMode(VMR_ARMODE_NONE);
                    if (FAILED(hr)) {
                        return hr;
                    }
                } else {
                    hr = m_pVMRWC->SetAspectRatioMode(m_fMaintainAspectRatio ? VMR_ARMODE_LETTER_BOX : VMR_ARMODE_NONE);
                    if (FAILED(hr)) {
                        return hr;
                    }
                }
            }
            // compositor should be set regardless of whether or not we're using overlays
            CComQIPtr<IVMRImageCompositor> IVMRICptr(ImCompositor);
            if(IVMRICptr){
                hr = m_pVMR->SetImageCompositor(IVMRICptr);
                if(FAILED(hr)){
                    TRACELSM(TRACE_ERROR, (dbgDump << "SetVRConfig() SetImageCompositor failed hr = " << hexdump(hr)), "");
                    return hr;
                }
            }
            if (!m_rectSrc) {
                CSize s, a;
                hr = get_NativeSize(&s, &a);
                if (FAILED(hr)) {
                    return hr;
                }
                m_rectSrc = CRect(CPoint(0, 0), s);
            }
            hr = UpdatePos();
            if (FAILED(hr)) {
                return hr;
            }
            // reminder: color key is set by override in video renderer derived class after we return to it
            if (m_hOwner != INVALID_HWND && ::IsWindow(m_hOwner)) {
                if(m_pVMRWC){
#if 0
                    // stop state race condition temp fix
                    PUnknown vidUnknown(m_pContainer);
                    DWORD Temp_id = (DWORD_PTR)(vidUnknown.p);
                    if(m_APid == Temp_id){
#endif
                        hr = m_pVMRWC->SetVideoClippingWindow(m_hOwner);
                        if (FAILED(hr)) {
                            TRACELSM(TRACE_ERROR, (dbgDump << "SetVRConfig() SetClipWnd failed hr = " << hexdump(hr)), "");
                            return hr;
                        }
#if 0
                    }
#endif
                }
            }

        }
        return NOERROR;
    }
    STDMETHOD(CheckVMRMode)(){
        try{
            PQVidCtl pqCtl;
            HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
            if(FAILED(hr)){
                return hr;
            }
            PQInputDevice pqIDev;
            hr = pqCtl->get_InputActive(&pqIDev);
            if(FAILED(hr)){
                return E_UNEXPECTED;
            }
            GUID2 inputID, classID;
            hr = pqIDev->get__ClassID(&inputID);
            if(FAILED(hr)){
                return hr;
            }
            if(inputID == CLSID_MSVidBDATunerDevice){
                PQFeatures pF;
                hr = pqCtl->get_FeaturesActive(&pF);
                if (FAILED(hr)) {
                    return hr;
                }

                CFeatures* pC = static_cast<CFeatures *>(pF.p);

                for (DeviceCollection::iterator i = pC->m_Devices.begin(); i != pC->m_Devices.end(); ++i) {
                    PQFeature f(*i);
                    hr = f->get__ClassID(&classID);
                    if (FAILED(hr)) {
                        //   TRACELM(TRACE_ERROR, "CTVProt::GetVidCtl() Can't get feature class id");
                        continue;
                    }
                    if (classID == CLSID_MSVidClosedCaptioning) {
                        break;
                    }
                }

                if(classID == CLSID_MSVidClosedCaptioning){
                    if(!m_vmrMixing){
                        hr = put__VMRendererMode(VIDCTL_MIXINGMODE);
                    }
                }
                else{
                    if(m_vmrMixing){
                        hr = put__VMRendererMode(VIDCTL_NONMIXINGMODE);
                    }
                }
                if(FAILED(hr)){
                    return E_UNEXPECTED;
                }
            }
            else{
                if(!m_vmrMixing){
                    hr = put__VMRendererMode(VIDCTL_MIXINGMODE);
                    if(FAILED(hr)){
                        return E_UNEXPECTED;
                    }
                }
            }
            return NOERROR;
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }

    // IGraphSegment
    STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl) {
        try {
            HRESULT hr = IMSVidGraphSegmentImpl<T, MSVidSEG_DEST, &GUID_NULL,  MostDerivedClass>::put_Container(pCtl);
            if (FAILED(hr)) {
                return hr;
            }
            if(pCtl){
                hr = CheckVMRMode();
                if(FAILED(hr)){
                    return hr;
                }
            }
           return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(CleanupVMR)(){
        try{
            HRESULT hr = S_OK;
            if(m_pVMR){
                if(m_pContainer){
                    CComQIPtr<IMSVidCtl> pq_vidCtl;
                    hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pq_vidCtl));
                    if(FAILED(hr)){
                        return hr;
                    }
                    MSVidCtlStateList state;
                    hr = pq_vidCtl->get_State(&state);
                    if(FAILED(hr)){
                        return hr;
                    }
                    if(state != STATE_UNBUILT){
                        hr = pq_vidCtl->Stop();
                        if(FAILED(hr)){
                            return hr;
                        }
                        hr = pq_vidCtl->Decompose();
                        if(FAILED(hr)){
                            return hr;
                        }
                    }
                    DSFilter vr(m_pVMR);
                    m_pGraph->RemoveFilter(vr);
                    vr.Release();
                    m_Filters.clear();
                    m_iVideoRenderer = -1;
                }
                CComQIPtr<IVMRSurfaceAllocatorNotify>qiSan;
                qiSan = m_pVMR;
                if(!qiSan){
                    _ASSERT(false);
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::CleanupVMR() can't qi for surface allocator notify: hr = " << std::hex << hr), "");
                }
                else{
                    hr = qiSan->AdviseSurfaceAllocator(m_APid, NULL);
                    if(FAILED(hr)){
                        _ASSERT(false);
                        TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::CleanupVMR() advise surface allocator (NULL) failed: hr = " << std::hex << hr), "");
                    }
                    qiSan.Release();
                    if (qiSurfAlloc) {
                        hr = qiSurfAlloc->AdviseNotify(NULL);
                    }
                }
                m_pVMRWC.Release();
                qiSurfAlloc.Release();
                m_pVMR.Release();

                _ASSERT(!m_pVMR);
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
        return S_OK;
    }
    STDMETHOD(Build)() {
        TRACELM(TRACE_DETAIL, "IMSVidVRGraphSegmentImpl::Build()");
        if (!m_fInit || !m_pGraph) {
            return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVRGraphSegment), CO_E_NOTINITIALIZED);
        }
        try {
            CString csName;
            if (!m_pVMR) {
                HRESULT hr = m_pVMR.CoCreateInstance(CLSID_VideoMixingRenderer, NULL, CLSCTX_INPROC_SERVER);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't load vmr: hr = " << std::hex << hr), "");
                    return ImplReportError(__uuidof(T), IDS_CANT_CREATE_FILTER, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);
                }
                // Here is what is going on
                // We are not putting the vmr into renderless mode and passing in the default allocator/presenter
                // This is to support the use of custom allocator/presenters
                hr = m_pVMR->SetRenderingMode(m_vmRendererMode);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't set vmr rendering mode: hr = " << std::hex << hr), "");
                    return ImplReportError(__uuidof(T), IDS_CANT_SET_VR_DEFAULTS, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);
                }

                // If we are in mixing mode, do that which needs to be done
                if(m_vmrMixing){
                    hr = m_pVMR->SetNumberOfStreams(DEFAULT_MAX_STREAMS);
                    if (FAILED(hr)) {
                        TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't set vmr stream count: hr = " << std::hex << hr), "");
                        return ImplReportError(__uuidof(T), IDS_CANT_SET_VR_DEFAULTS, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);
                    }
                    DWORD curPrefs;
                    DWORD deci;
                    CComQIPtr<IVMRMixerControl>PQIVMRMixer(m_pVMR);
                    if(!PQIVMRMixer){
                        TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't get vmr mixer control: hr = " << std::hex << hr), "");
                        return E_UNEXPECTED;
                    }
                    hr = PQIVMRMixer->GetMixingPrefs(&curPrefs);
                    if(FAILED(hr)){
                        TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't get vmr mixer prefs: hr = " << std::hex << hr), "");
                        return hr;
                    }
                    deci = (m_Decimate?MixerPref_DecimateOutput:MixerPref_NoDecimation);
                    if(!(curPrefs&deci)){
                        curPrefs = (curPrefs&(~MixerPref_DecimateMask))|deci;
                        hr = PQIVMRMixer->SetMixingPrefs(curPrefs);
                        if(FAILED(hr)){
                            TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't set vmr mixer prefs: hr = " << std::hex << hr), "");
                            return hr;
                        }
                    }

                }

                // Set up the allocator presenter
                if(!qiSurfAlloc){
                    hr = qiSurfAlloc.CoCreateInstance(CLSID_AllocPresenter, NULL, CLSCTX_INPROC_SERVER);
                    if(FAILED(hr)){
                        _ASSERT(false);
                        TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't cocreate default surface allocator : hr = " << std::hex << hr), "");
                        return ImplReportError(__uuidof(T), IDS_CANT_CREATE_FILTER, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);

                    }
                }
                CComQIPtr<IVMRSurfaceAllocatorNotify>qiSan;
                qiSan = m_pVMR;
                if(!qiSan){
                    _ASSERT(false);
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't qi for surface allocator notify: hr = " << std::hex << hr), "");
                    return ImplReportError(__uuidof(T), IDS_CANT_CREATE_FILTER, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);
                }
                if(m_APid == -1){
                    PUnknown vidUnknown(m_pContainer);
                    m_APid = (DWORD_PTR)(vidUnknown.p);
                }
                hr = qiSan->AdviseSurfaceAllocator(m_APid, qiSurfAlloc);
                if(FAILED(hr)){
                    _ASSERT(false);
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't set surface allocator: hr = " << std::hex << hr), "");
                    return ImplReportError(__uuidof(T), IDS_CANT_CREATE_FILTER, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);
                }
                hr = qiSurfAlloc->AdviseNotify(qiSan);
                if(FAILED(hr)){
                    _ASSERT(false);
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't advise notify: hr = " << std::hex << hr), "");
                    return ImplReportError(__uuidof(T), IDS_CANT_CREATE_FILTER, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);
                }
                // Windowless control comes from alloc/presenter (vmr just proxys it through in the windowless case
                // so this should act exactly like being in windless mode
                m_pVMRWC = qiSurfAlloc;
            }
            DSFilter vr(m_pVMR);
            if (!vr) {
                ASSERT(false);
                return ImplReportError(__uuidof(T), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
            }
            if (m_iVideoRenderer == -1) {
                m_Filters.push_back(vr);
                csName = _T("Video Mixing Renderer");
                m_pGraph.AddFilter(vr, csName);
            }
            m_iVideoRenderer = 0;
            ASSERT(m_iVideoRenderer == 0);
            SetVRConfig();  // ignore errors, we'll try again at run time
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(PreRun)() {
        try {
            if (!m_pVMR) {
                return HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
            }
            m_rectDest = CRect(0, 0, 0, 0);
            m_rectSrc  = CRect(0, 0, 0, 0);

            if(m_vidSuppressEffects){
                DisableAPM();
            }
            HRESULT hr = UpdatePos();
            if (FAILED(hr)) {
                return hr;
            }
            return SetVRConfig();
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(PostStop)() {
        try {
            m_rectDest = CRect(0, 0, 0, 0);
            m_rectSrc  = CRect(0, 0, 0, 0);
            if (m_fHaveOriginalSystemEffects) {
                if (!SystemParametersInfo(SPI_SETDROPSHADOW, 0, &m_bDropShadows, 0)) { // only send change notice once on the last one
                    TRACELSM(TRACE_ERROR, (dbgDump << "VRSegimpl::SetVRConfig() can't turn off drop shadows rc = " << GetLastError()), "");            
                }
                if (!SystemParametersInfo(SPI_SETFONTSMOOTHING, m_bSmoothing, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "VRSegimpl::PostStop() can't restore font smoothing rc = " << GetLastError()), "");            
                }
            }
            EnableAPM();
            return put_Visible(VARIANT_FALSE);
        } catch (...) {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }
	
    // IMSVidVRGraphSegment
    STDMETHOD(put__VMRendererMode)(/*[in]*/ LONG dwMode){
        try{
            bool changed, mMode;
            changed = false;
            HRESULT  hr = S_OK;
            CString csName;
            if (dwMode == VIDCTL_NONMIXINGMODE || dwMode == VIDCTL_MIXINGMODE){
                mMode = (dwMode==VIDCTL_MIXINGMODE)?true:false;
                if(mMode != m_vmrMixing){
                    m_vmrMixing = mMode;
                    changed = true;
                }
            }
            else{
                return E_FAIL;
            }
            if(changed){
                hr = CleanupVMR();
                return hr;
            }
            else{
                return NOERROR;
            }
        }
        catch(HRESULT hres){
            return hres;
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(get_Owner)(/*[out, retval]*/ HWND* phWnd) {
        try {
            if (!phWnd) {
                return E_POINTER;
            }
            *phWnd = m_hOwner;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(put_Owner)(/*[in]*/ HWND hWnd) {
       try {
            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidVRGraphSegmentImpl<>::put_Owner() hWnd= " << hexdump(reinterpret_cast<ULONG_PTR>(hWnd))), "");
            if (m_hOwner == hWnd) {
                return NOERROR;
            }
            if (m_iVideoRenderer == -1 || !m_Filters[m_iVideoRenderer] || !m_pGraph || !m_pVMR) {
                return NOERROR;
            }
            m_hOwner = hWnd;
            if (m_hOwner != INVALID_HWND) {
                if(m_pVMRWC){
#if 0
                    // stop state race condition temp fix
                    PUnknown vidUnknown(m_pContainer);
                    DWORD Temp_id = (DWORD_PTR)(vidUnknown.p);
                    if(m_APid == Temp_id){
#endif
                        HRESULT hr = m_pVMRWC->SetVideoClippingWindow(m_hOwner);
                        if (FAILED(hr)) {
                            TRACELSM(TRACE_ERROR, (dbgDump << "put_Owner() SetClipWnd failed hr = " << hexdump(hr)), "");
                            return hr;
                        }
#if 0
                    }
#endif
                }
            }
            return UpdatePos(); // force a refresh if we're changing clip rects
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_UseOverlay)(/*[out, retval]*/ VARIANT_BOOL *fUseOverlay) {
        try {
            if (!fUseOverlay) {
                return E_POINTER;
            }
            *fUseOverlay = m_fUseOverlay ? VARIANT_TRUE : VARIANT_FALSE;
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(put_UseOverlay)(/*[in]*/ VARIANT_BOOL fUseOverlayVal) {
        try {
            TRACELSM(TRACE_PAINT, (dbgDump << "VRSegimpl::put_UseOverlay() use_overlay = " << fUseOverlayVal), "");
            bool fUseOverlay = (fUseOverlayVal == VARIANT_TRUE);
            if (fUseOverlay == m_fUseOverlay) {
                return NOERROR;
            }
            m_fUseOverlay = fUseOverlay;
            if (!m_pVMR) {
                return NOERROR;
            }
            return SetVRConfig();
        } catch(...) {
            return E_POINTER;
        }
    }
    // from top-level control visibility state
    STDMETHOD(get_Visible)(/*[out, retval]*/ VARIANT_BOOL* fVisible) {
        try {
            if (!fVisible) {
                return E_POINTER;
            }
            *fVisible = m_fVisible ? VARIANT_TRUE : VARIANT_FALSE;
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(put_Visible)(/*[in]*/ VARIANT_BOOL fVisibleVal) {
        try {
            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidVRGraphSegmentImpl<>::put_Visible() fV = " << fVisibleVal), "");
            bool fVisible = (fVisibleVal == VARIANT_TRUE);
            if (fVisible == m_fVisible) {
                return NOERROR;
            }
            m_fVisible = fVisible;
            if (!m_pGraph || m_pGraph.GetState() == State_Stopped || m_iVideoRenderer == -1 || !m_pVMR) {
                return NOERROR;
            }
            HRESULT hr = UpdatePos();
            if (FAILED(hr)) {
                return hr;
            }
            if (!!m_pGraph && m_pGraph.IsPlaying()) {
                if (m_fVisible) {
                    if(m_vidSuppressEffects){
                        DisableAPM();
                    }
                } else {
                    EnableAPM();
                }
            }
            return NOERROR;
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_Source)(/*[out, retval]*/ LPRECT pRect) {
        try {
            if (!pRect) {
                return E_POINTER;
            }
            *pRect = m_rectSrc;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(put_Source)(/*[in]*/ RECT pRect) {
       try {
            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidVRGraphSegmentImpl<>::put_Source() r = " << pRect), "");
            if (m_rectSrc == pRect) {
                return NOERROR;
            }
            if (m_iVideoRenderer == -1 || !m_Filters[m_iVideoRenderer] || !m_pGraph || !m_pVMR) {
                return NOERROR;
            }
            m_rectSrc = pRect;
            return UpdatePos();
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_Destination)(/*[out, retval]*/ LPRECT pRect) {
        try {
            if (!pRect) {
                return E_POINTER;
            }
            *pRect = m_rectDest;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(put_Destination)(/*[in]*/ RECT pRect) {
       try {
            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidVRGraphSegmentImpl<>::put_Dest() r = " << pRect), "");
            if (m_rectDest == pRect) {
                return NOERROR;
            }
            if (m_iVideoRenderer == -1 || !m_Filters[m_iVideoRenderer] || !m_pGraph || !m_pVMR) {
                return NOERROR;
            }

            TRACELM(TRACE_DETAIL, "IMSVidVRGraphSegmentImpl<>::put_Dest() setting");
            m_rectDest = pRect;
            return UpdatePos();
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_NativeSize)(/*[out]*/ LPSIZE pSize, LPSIZE pAR) {
        try {
            if (!pSize) {
                return E_POINTER;
            }

            if (m_iVideoRenderer == -1 || !m_Filters[m_iVideoRenderer] || !m_pGraph || !m_pVMR) {
                *pSize = CSize(0, 0);
                return NOERROR;
            }
            if(m_pVMRWC){
                HRESULT hr = m_pVMRWC->GetNativeVideoSize(&pSize->cx, &pSize->cy, &pAR->cx, &pAR->cy);
                if (FAILED(hr)) {
                    return hr;
                }
            }
            else{
                return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), S_FALSE);
            }
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    // from top-level control refresh method
    STDMETHOD(Refresh)() {
        try {
            if (!m_pVMR) {
                return NOERROR;
            }
            HRESULT hr = SetVRConfig();
            if (FAILED(hr)) {
                return hr;
            }
            hr = UpdatePos();
            if (FAILED(hr)) {
                return hr;
            }
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(DisplayChange)() {
        if (m_pVMR) {
            if(m_pVMRWC){
                return m_pVMRWC->DisplayModeChanged();
            }
        }
        return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), S_FALSE);
    }

    STDMETHOD(RePaint)(HDC hdc) {
        if (m_pVMR) {
            if(m_pVMRWC){
                return m_pVMRWC->RepaintVideo(m_hOwner, hdc);
            }
        }
        return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), S_FALSE);
    }

// IMSVidVRSegment
    STDMETHOD(get_ColorKey)(OLE_COLOR* pColorKey) {
        try {
            if (!pColorKey) {
                return E_POINTER;
            }
            *pColorKey = m_ColorKey;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(put_ColorKey)(OLE_COLOR ColorKey) {
        try {
            if (m_ColorKey == ColorKey) {
                return NOERROR;
            }
            m_ColorKey = ColorKey;
            if (!m_pVMR) {
                return NOERROR;
            }
            if(m_pVMRWC){
                return m_pVMRWC->SetColorKey(m_ColorKey);
            }
            else{
                return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), S_FALSE);
            }
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(get_BorderColor)(OLE_COLOR* pBorderColor) {
        try {
            if (!pBorderColor) {
                return E_POINTER;
            }
            *pBorderColor = m_BorderColor;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(put_BorderColor)(OLE_COLOR BorderColor) {
        try {
            if (m_BorderColor == BorderColor) {
                return NOERROR;
            }
            m_BorderColor = BorderColor;
            if (!m_pVMR) {
                return NOERROR;
            }
            if(m_pVMRWC){
                return m_pVMRWC->SetBorderColor(m_BorderColor);
            }
            else{
                return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), S_FALSE);
            }
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_MaintainAspectRatio)(/*[out, retval]*/ VARIANT_BOOL* fMaintainAspectRatio) {
        try {
            if (!fMaintainAspectRatio) {
                return E_POINTER;
            }
            *fMaintainAspectRatio = m_fMaintainAspectRatio ? VARIANT_TRUE : VARIANT_FALSE;
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(put_MaintainAspectRatio)(/*[in]*/ VARIANT_BOOL fMaintainAspectRatioVal) {
        try {
            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidVRGraphSegmentImpl<>::put_MaintainAspectRatio() fV = " << fMaintainAspectRatioVal), "");
            bool fMaintainAspectRatio = (fMaintainAspectRatioVal == VARIANT_TRUE);
            if (fMaintainAspectRatio == m_fMaintainAspectRatio) {
                return NOERROR;
            }
            m_fMaintainAspectRatio = fMaintainAspectRatio;
            if (!m_pGraph || m_pGraph.GetState() == State_Stopped || m_iVideoRenderer == -1 || !m_pVMR) {
                return NOERROR;
            }
            HRESULT hr = SetVRConfig();
            if (FAILED(hr)) {
                return hr;
            }
            return NOERROR;
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

};

template <class T, const IID* piid, class CDV = CComDynamicUnkArray>
class CProxy_VRSeg : public CProxy_DeviceEvent<T, piid, CDV>
{
public:
    VOID Fire_OverlayUnavailable()
    {
        Fire_VoidMethod(eventidOverlayUnavailable);
    }

};


typedef CComQIPtr<IMSVidVRGraphSegment> PQVRGraphSegment;

}; // namespace

#endif
// end of file - vrsegimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\atl\atlbase.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLBASE_H__
#define __ATLBASE_H__

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(disable: 4201) // nameless unions are part of C++
#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4505) // unreferenced local function has been removed
#pragma warning(disable: 4512) // can't generate assignment operator (so what?)
#pragma warning(disable: 4514) // unreferenced inlines are common
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4237) // bool
#pragma warning(disable: 4710) // function couldn't be inlined
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
#pragma warning(disable: 4097) // typedef name used as synonym for class-name
#pragma warning(disable: 4786) // identifier was truncated in the debug information
#pragma warning(disable: 4268) // const static/global data initialized to zeros
#pragma warning(disable: 4291) // allow placement new
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <atldef.h>

#include <windows.h>
#include <winnls.h>
#include <ole2.h>

#include <comcat.h>
#include <stddef.h>

#ifdef new
#pragma push_macro("new")
#define _ATL_REDEF_NEW
#undef new
#endif

#include <tchar.h>
#include <malloc.h>

#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
        #include <crtdbg.h>
#endif

#include <olectl.h>
#include <winreg.h>
#include <atliface.h>

#ifdef _DEBUG
#include <stdio.h>
#include <stdarg.h>
#endif

#include <atlconv.h>

#include <shlwapi.h>

#pragma pack(push, _ATL_PACKING)

#if defined(_ATL_DLL)
        #pragma comment(lib, "atl.lib")
#endif

extern "C" const __declspec(selectany) GUID LIBID_ATLLib = {0x44EC0535,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) CLSID CLSID_Registrar = {0x44EC053A,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IRegistrar = {0x44EC053B,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IAxWinHostWindow = {0xb6ea2050,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IAxWinAmbientDispatch = {0xb6ea2051,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IInternalConnection = {0x72AD0770,0x6A9F,0x11d1,{0xBC,0xEC,0x00,0x60,0x08,0x8F,0x44,0x4E}};
extern "C" const __declspec(selectany) IID IID_IDocHostUIHandlerDispatch = {0x425B5AF0,0x65F1,0x11d1,{0x96,0x11,0x00,0x00,0xF8,0x1E,0x0D,0x0D}};

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

struct _ATL_CATMAP_ENTRY
{
   int iType;
   const CATID* pcatid;
};

#define _ATL_CATMAP_ENTRY_END 0
#define _ATL_CATMAP_ENTRY_IMPLEMENTED 1
#define _ATL_CATMAP_ENTRY_REQUIRED 2

typedef HRESULT (WINAPI _ATL_CREATORFUNC)(void* pv, REFIID riid, LPVOID* ppv);
typedef HRESULT (WINAPI _ATL_CREATORARGFUNC)(void* pv, REFIID riid, LPVOID* ppv, DWORD_PTR dw);
typedef HRESULT (WINAPI _ATL_MODULEFUNC)(DWORD_PTR dw);
typedef LPCTSTR (WINAPI _ATL_DESCRIPTIONFUNC)();
typedef const struct _ATL_CATMAP_ENTRY* (_ATL_CATMAPFUNC)();
typedef void (__stdcall _ATL_TERMFUNC)(DWORD_PTR dw);

struct _ATL_TERMFUNC_ELEM
{
        _ATL_TERMFUNC* pFunc;
        DWORD_PTR dw;
        _ATL_TERMFUNC_ELEM* pNext;
};

struct _ATL_OBJMAP_ENTRY
{
        const CLSID* pclsid;
        HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
        _ATL_CREATORFUNC* pfnGetClassObject;
        _ATL_CREATORFUNC* pfnCreateInstance;
        IUnknown* pCF;
        DWORD dwRegister;
        _ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
        _ATL_CATMAPFUNC* pfnGetCategoryMap;
        HRESULT WINAPI RevokeClassObject()
        {
                return CoRevokeClassObject(dwRegister);
        }
        HRESULT WINAPI RegisterClassObject(DWORD dwClsContext, DWORD dwFlags)
        {
                IUnknown* p = NULL;
                if (pfnGetClassObject == NULL)
                        return S_OK;
                HRESULT hRes = pfnGetClassObject(pfnCreateInstance, IID_IUnknown, (LPVOID*) &p);
                if (SUCCEEDED(hRes))
                        hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &dwRegister);
                if (p != NULL)
                        p->Release();
                return hRes;
        }
// Added in ATL 3.0
        void (WINAPI *pfnObjectMain)(bool bStarting);
};

struct _ATL_REGMAP_ENTRY
{
        LPCOLESTR     szKey;
        LPCOLESTR     szData;
};

struct _AtlCreateWndData
{
        void* m_pThis;
        DWORD m_dwThreadID;
        _AtlCreateWndData* m_pNext;
};

struct _ATL_MODULE_21
{
// Attributes
public:
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
	HINSTANCE m_hInstTypeLib;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	union
	{
		CRITICAL_SECTION m_csTypeInfoHolder;
		CRITICAL_SECTION m_csStaticDataInit;
	};
	CRITICAL_SECTION m_csWindowCreate;
	CRITICAL_SECTION m_csObjMap;
};

struct _ATL_MODULE_30
{
// Attributes
public:
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
	HINSTANCE m_hInstTypeLib;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	union
	{
		CRITICAL_SECTION m_csTypeInfoHolder;
		CRITICAL_SECTION m_csStaticDataInit;
	};
	CRITICAL_SECTION m_csWindowCreate;
	CRITICAL_SECTION m_csObjMap;
// Original Size = 100
// Stuff added in ATL 3.0
	DWORD dwAtlBuildVer;
	_AtlCreateWndData* m_pCreateWndList;
	bool m_bDestroyHeap;
	GUID* pguidVer;
	DWORD m_dwHeaps;    // Number of heaps we have (-1)
	HANDLE* m_phHeaps;
	int m_nHeap;        // Which heap to choose from
	_ATL_TERMFUNC_ELEM* m_pTermFuncs;
};

struct _ATL_MODULE
{
// Attributes
public:
        UINT cbSize;
        HINSTANCE m_hInst;
        HINSTANCE m_hInstResource;
        HINSTANCE m_hInstTypeLib;
        _ATL_OBJMAP_ENTRY* m_pObjMap;
        LONG m_nLockCnt;
        HANDLE m_hHeap;
        union
        {
                CRITICAL_SECTION m_csTypeInfoHolder;
                CRITICAL_SECTION m_csStaticDataInit;
        };
        CRITICAL_SECTION m_csWindowCreate;
        CRITICAL_SECTION m_csObjMap;
// Original Size = 100
// Stuff added in ATL 3.0
        DWORD dwAtlBuildVer;
        _AtlCreateWndData* m_pCreateWndList;
        bool m_bDestroyHeap;
        GUID* pguidVer;
        DWORD m_dwHeaps;    // Number of heaps we have (-1)
        HANDLE* m_phHeaps;
        int m_nHeap;        // Which heap to choose from
        _ATL_TERMFUNC_ELEM* m_pTermFuncs;
// Stuff added in ATL 6.1
	LONG m_nNextWindowID;
};

const int _nAtlModuleVer21Size = sizeof( _ATL_MODULE_21 );
const int _nAtlModuleVer30Size = sizeof( _ATL_MODULE_30 );


//This define makes debugging asserts easier.
#define _ATL_SIMPLEMAPENTRY ((_ATL_CREATORARGFUNC*)1)

struct _ATL_INTMAP_ENTRY
{
        const IID* piid;       // the interface id (IID)
		DWORD_PTR dw;
        _ATL_CREATORARGFUNC* pFunc; //NULL:end, 1:offset, n:ptr
};

/////////////////////////////////////////////////////////////////////////////
// Thunks for __stdcall member functions


#if defined(_M_IX86)
#pragma pack(push,1)
struct _stdcallthunk
{
        DWORD   m_mov;          // mov dword ptr [esp+0x4], pThis (esp+0x4 is hWnd)
        DWORD   m_this;         //
        BYTE    m_jmp;          // jmp WndProc
        DWORD   m_relproc;      // relative jmp
        void Init(DWORD_PTR proc, void* pThis)
        {
                m_mov = 0x042444C7;  //C7 44 24 0C
                m_this = PtrToUlong(pThis);
                m_jmp = 0xe9;
                m_relproc = DWORD((INT_PTR)proc - ((INT_PTR)this+sizeof(_stdcallthunk)));
                // write block from data cache and
                //  flush from instruction cache
                FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
        }
};
#pragma pack(pop)
#elif defined (_M_AMD64)
#pragma pack(push,2)
struct _stdcallthunk
{
    USHORT  RcxMov;         // mov rcx, pThis
    ULONG64 RcxImm;         // 
    USHORT  RaxMov;         // mov rax, target
    ULONG64 RaxImm;         //
    USHORT  RaxJmp;         // jmp target
    void Init(DWORD_PTR proc, void *pThis)
    {
        RcxMov = 0xb948;          // mov rcx, pThis
        RcxImm = (ULONG64)pThis;  // 
        RaxMov = 0xb848;          // mov rax, target
        RaxImm = (ULONG64)proc;   //
        RaxJmp = 0xe0ff;          // jmp rax
        FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
    }
};
#pragma pack(pop)
#elif defined(_M_IA64)
#pragma pack(push,8)
extern "C" LRESULT CALLBACK _WndProcThunkProc( HWND, UINT, WPARAM, LPARAM );
struct _FuncDesc
{
        void* pfn;
        void* gp;
};
struct _stdcallthunk
{
        _FuncDesc m_funcdesc;
        void* m_pFunc;
        void* m_pThis;
        void Init(DWORD_PTR proc, void* pThis)
        {
                const _FuncDesc* pThunkProc;

                pThunkProc = reinterpret_cast< const _FuncDesc* >( _WndProcThunkProc );
                m_funcdesc.pfn = pThunkProc->pfn;
                m_funcdesc.gp = &m_pFunc;
                m_pFunc = reinterpret_cast< void* >( proc );
                m_pThis = pThis;
                ::FlushInstructionCache( GetCurrentProcess(), this, sizeof( _stdcallthunk ) );
        }
};
#pragma pack(pop)
#else
#error Only AMD64, IA64, and X86 supported
#endif

class CDynamicStdCallThunk
{
public:
        _stdcallthunk *pThunk;

        CDynamicStdCallThunk()
        {
                pThunk = NULL;
        }

        ~CDynamicStdCallThunk()
        {
                if (pThunk)
                        HeapFree(GetProcessHeap(), 0, pThunk);
        }

        void Init(DWORD_PTR proc, void *pThis)
        {
                ATLASSERT(!pThunk);
                pThunk = static_cast<_stdcallthunk *>(HeapAlloc(GetProcessHeap(), 
                        HEAP_GENERATE_EXCEPTIONS, sizeof(_stdcallthunk)));
                ATLASSERT(pThunk);
                pThunk->Init(proc, pThis);
        }
};
typedef CDynamicStdCallThunk CStdCallThunk;

/////////////////////////////////////////////////////////////////////////////
// QI Support

ATLAPI AtlInternalQueryInterface(void* pThis,
        const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject);

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp);
ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid);

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

ATLAPI AtlFreeMarshalStream(IStream* pStream);
ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream);
ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk);

ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent);

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc,
        DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes,
        HINSTANCE hInst);

/////////////////////////////////////////////////////////////////////////////
// Module

ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags);
ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM);
ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv);
ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE*pM, LPCOLESTR lpszRes,
        BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg = NULL);
ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib);

ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h);
ATLAPI AtlModuleTerm(_ATL_MODULE* pM);
ATLAPI_(DWORD) AtlGetVersion(void* pReserved);
ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject);
ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM);
ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD_PTR dw);

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Error to HRESULT helpers

inline HRESULT AtlHresultFromLastError()
{
        DWORD dwErr = ::GetLastError();
        return HRESULT_FROM_WIN32(dwErr);
}

inline HRESULT AtlHresultFromWin32(DWORD nError)
{
        return( HRESULT_FROM_WIN32( nError ) );
}

enum atlTraceFlags
{
        // Application defined categories
        atlTraceUser        = 0x00000001,
        atlTraceUser2       = 0x00000002,
        atlTraceUser3       = 0x00000004,
        atlTraceUser4       = 0x00000008,
        // ATL defined categories
        atlTraceGeneral     = 0x00000020,
        atlTraceCOM         = 0x00000040,
        atlTraceQI      = 0x00000080,
        atlTraceRegistrar   = 0x00000100,
        atlTraceRefcount    = 0x00000200,
        atlTraceWindowing   = 0x00000400,
        atlTraceControls    = 0x00000800,
        atlTraceHosting     = 0x00001000,
        atlTraceDBClient    = 0x00002000,
        atlTraceDBProvider  = 0x00004000,
        atlTraceSnapin      = 0x00008000,
        atlTraceNotImpl     = 0x00010000,
};

#ifndef ATL_TRACE_CATEGORY
#define ATL_TRACE_CATEGORY 0xFFFFFFFF
#endif

#ifdef _DEBUG

#ifndef ATL_TRACE_LEVEL
#define ATL_TRACE_LEVEL 0
#endif

inline void _cdecl AtlTrace(LPCSTR lpszFormat, ...)
{
        va_list args;
        va_start(args, lpszFormat);

        int nBuf;
        char szBuffer[512];

        nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
        ATLASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

        OutputDebugStringA(szBuffer);
        va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCSTR lpszFormat, ...)
{
        if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
        {
                va_list args;
                va_start(args, lpszFormat);

                int nBuf;
                char szBuffer[512];

                nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
                ATLASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

                OutputDebugStringA("ATL: ");
                OutputDebugStringA(szBuffer);
                va_end(args);
        }
}
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR lpszFormat, ...)
{
        va_list args;
        va_start(args, lpszFormat);

        int nBuf;
        WCHAR szBuffer[512];

        nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
        ATLASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

        OutputDebugStringW(szBuffer);
        va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCWSTR lpszFormat, ...)
{
        if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
        {
                va_list args;
                va_start(args, lpszFormat);

                int nBuf;
                WCHAR szBuffer[512];

                nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
                ATLASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

                OutputDebugStringW(L"ATL: ");
                OutputDebugStringW(szBuffer);
                va_end(args);
        }
}
#endif //!OLE2ANSI


#ifndef ATLTRACE
#define ATLTRACE            AtlTrace
#define ATLTRACE2           AtlTrace2
#endif
#define ATLTRACENOTIMPL(funcname)   ATLTRACE2(atlTraceNotImpl, 2, _T("ATL: %s not implemented.\n"), funcname); return E_NOTIMPL
#else // !DEBUG
inline void _cdecl AtlTrace(LPCSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCSTR , ...){}
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCWSTR , ...){}
#endif //OLE2ANSI
#ifndef ATLTRACE
#define ATLTRACE            1 ? (void)0 : AtlTrace
#define ATLTRACE2           1 ? (void)0 : AtlTrace2
#endif //ATLTRACE
#define ATLTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG

// Validation macro for OUT pointer
// Used in QI and CreateInstance
#define _ATL_VALIDATE_OUT_POINTER(x)        ATLASSERT(x != NULL);        \
        if (x == NULL)        \
                return E_POINTER;        \
        *x = NULL

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#ifndef _WIN64
#pragma comment(lib, "olepro32.lib")
#endif
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")
#pragma comment(lib, "uuid.lib")



template <class Ty> class stl_smart_ptr_allocator {
public:
                typedef size_t size_type;
                typedef ptrdiff_t difference_type;
                typedef Ty *pointer;
                typedef const Ty *const_pointer;
                typedef Ty & reference;
                typedef const Ty & const_reference;
                typedef Ty value_type;
                pointer address(reference _X) const
                                {return ((_X.address)()); }
                const_pointer address(const_reference _X) const
                                {return ((_X.const_address)()); }
                pointer allocate(ptrdiff_t _N, const void *)
                {if (_N < 0)
                                        _N = 0;
                        return ((pointer)operator new(
                                (size_type)_N * sizeof (Ty))); }
                char *_Charalloc(ptrdiff_t _N)
                {if (_N < 0)
                                        _N = 0;
                        return ((char *)operator new(
                                (size_type)_N * sizeof (char))); }
                void deallocate(void *_P, size_type)
                                {operator delete(_P); }
                void construct(pointer _P, const Ty& _V)
                        {new ((void *)_P) Ty(_V); }
                // note: there is an stl bug regarding allocators and the list container
                // (vc6 list line 222) the template takes the address of the object
                // which breaks for smart pointers because the & is overloaded.
                // the correct thing is for construct to be defined as a reference
                // and list not use & so that the allocator can use a private method
                // of obtaining the object address
                // i've gone ahead and defined the correct method here on the remote
                // chance that this will get fixed in the future
                void construct(reference R, const Ty& _V)
                        {new ((void *)R.address()) Ty(_V); }
                void destroy(pointer _P)
                                {_Destroy(_P); }
                size_type max_size() const
                                {size_type _N = (size_type)(-1) / sizeof (Ty);
                                return (0 < _N ? _N : 1); }
        inline void _Destroy(Ty *_P)
                        {(_P)->~Ty();}

        inline void _Destroy(char *_P)
                        {}
        inline void _Destroy(wchar_t *_P)
                        {}
};

// return that all specializations of this allocator are interchangeable
//
// Note: we need these operators bacause they are called by swap friend function
//
template <class T1, class T2>
bool operator== (const stl_smart_ptr_allocator<T1>&,
        const stl_smart_ptr_allocator<T2>&){
        return true;
}
template <class T1, class T2>
bool operator!= (const stl_smart_ptr_allocator<T1>&,
        const stl_smart_ptr_allocator<T2>&){
        return false;
}

static HRESULT AtlSetChildSite(IUnknown* punkChild, IUnknown* punkParent)
{
        if (punkChild == NULL)
                return E_POINTER;

        HRESULT hr;
        IObjectWithSite* pChildSite = NULL;
        hr = punkChild->QueryInterface(IID_IObjectWithSite, (void**)&pChildSite);
        if (SUCCEEDED(hr) && pChildSite != NULL)
        {
                hr = pChildSite->SetSite(punkParent);
                pChildSite->Release();
        }
        return hr;
}

template <class T>
class _NoAddRefReleaseOnCComPtr : public T
{
        private:
                STDMETHOD_(ULONG, AddRef)()=0;
                STDMETHOD_(ULONG, Release)()=0;
};

template <class T>
class CComPtr
{
public:
        typedef T _PtrClass;
        CComPtr()
        {
                p=NULL;
        }
        CComPtr(T* lp)
        {
                if ((p = lp) != NULL)
                        p->AddRef();
        }
        CComPtr(const CComPtr<T>& lp)
        {
                if ((p = lp.p) != NULL)
                        p->AddRef();
        }
        CComPtr(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
            : p(NULL)
        {
                ATLASSERT(p == NULL);
                HRESULT hr = ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                if (FAILED(hr)) ATLASSERT(p == NULL);
        }
        CComPtr(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
            : p(NULL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                if (FAILED(hr)) ATLASSERT(p == NULL);
        }
        ~CComPtr()
        {
                if (p)
                        p->Release();
        }
        void Release()
        {
                IUnknown* pTemp = p;
                if (pTemp)
                {
                        p = NULL;
                        pTemp->Release();
                }
        }
        operator T*() const
        {
                return (T*)p;
        }
        T& operator*() const
        {
                ATLASSERT(p!=NULL);
                return *p;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the p member explicitly.
        T** operator&()
        {
                ATLASSERT(p==NULL);
                return &p;
        }
        _NoAddRefReleaseOnCComPtr<T>* operator->() const
        {
                ATLASSERT(p!=NULL);
                return (_NoAddRefReleaseOnCComPtr<T>*)p;
        }
        T* operator=(T* lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
        }
        T* operator=(const CComPtr<T>& lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
        }
        bool operator!() const
        {
                return (p == NULL);
        }
        bool operator<(T* pT) const
        {
                return p < pT;
        }
        bool operator==(T* pT) const
        {
                return p == pT;
        }
        // Compare two objects for equivalence
        bool IsEqualObject(IUnknown* pOther)
        {
                if (p == NULL && pOther == NULL)
                        return true; // They are both NULL objects

                if (p == NULL || pOther == NULL)
                        return false; // One is NULL the other is not

                CComPtr<IUnknown> punk1;
                CComPtr<IUnknown> punk2;
                p->QueryInterface(IID_IUnknown, (void**)&punk1);
                pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
                return punk1 == punk2;
        }
        void Attach(T* p2)
        {
                if (p)
                        p->Release();
                p = p2;
        }
        T* Detach()
        {
                T* pt = p;
                p = NULL;
                return pt;
        }
#if 0
        HRESULT CopyTo(T** ppT)
        {
                // there should either be a runtime check or an assert(not both).  otherwise
                // we can't depend on the runtime check during unattended api tests and have to
                // place a redundant extra check outside the call to CopyTo to keep assert
                // dialogs from popping up
                // ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
#else
        // we want to enable CopyTo to work correctly with bases of T
        // if INTERFACE isn't a base then we'll get a compile error
        template<class INTERFACE> HRESULT CopyTo(INTERFACE** ppT)
        {
                // there should either be a runtime check or an assert(not both).  otherwise
                // we can't depend on the runtime check during unattended api tests and have to
                // place a redundant extra check outside the call to CopyTo to keep assert
                // dialogs from popping up
                // ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
#endif
        HRESULT SetSite(IUnknown* punkParent)
        {
                return AtlSetChildSite(p, punkParent);
        }
        HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
        {
                return AtlAdvise(p, pUnk, iid, pdw);
        }
        HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                ATLASSERT(p == NULL);
                return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
        }
        HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                return hr;
        }
        template <class Q>
        HRESULT QueryInterface(Q** pp) const
        {
                ATLASSERT(pp != NULL && *pp == NULL);
                return p->QueryInterface(__uuidof(Q), (void**)pp);
        }
                // this allows direct use in stl containers
                // without using the CAdapt template which causes extra addrefs/releases
                //  usage:
                // std::vector<CComPtr<IMytype>, CComPtr<IMytype>::stl_allocator>
        CComPtr<T> * address(void) { return this; }
        const CComPtr<T> * const_address(void) const { return this; }
                typedef stl_smart_ptr_allocator<CComPtr<T> > stl_allocator;

        T* p;
};


template <class T, const IID* piid = &__uuidof(T)>
class CComQIPtr
{
public:
        typedef T _PtrClass;
        CComQIPtr()
        {
                p=NULL;
        }
        CComQIPtr(T* lp)
        {
                if ((p = lp) != NULL)
                        p->AddRef();
        }
        CComQIPtr(const CComQIPtr<T,piid>& lp)
        {
                if ((p = lp.p) != NULL)
                        p->AddRef();
        }
        CComQIPtr(IUnknown* lp)
        {
                p=NULL;
                if (lp != NULL)
                        lp->QueryInterface(*piid, (void **)&p);
        }
        CComQIPtr(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
            : p(NULL)
        {
                ATLASSERT(p == NULL);
                HRESULT hr = ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                if (FAILED(hr)) ATLASSERT(p == NULL);
        }
        CComQIPtr(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
            : p(NULL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                if (FAILED(hr)) ATLASSERT(p == NULL);
        }
        ~CComQIPtr()
        {
                if (p)
                        p->Release();
        }
        void Release()
        {
                IUnknown* pTemp = p;
                if (pTemp)
                {
                        p = NULL;
                        pTemp->Release();
                }
        }
        operator T*() const
        {
                return p;
        }
        T& operator*() const
        {
                ATLASSERT(p!=NULL); return *p;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the p member explicitly.

        T** operator&()
        {
// this is unavoidably triggered by legitimate access inside templates.  example:
// using a CComQIPtr in an stl container and then using IEnumonSTLImpl the ::Next
// method contains a Copy::copy operation that causes this problem.
//            ATLASSERT(p==NULL);
            return &p;
        }
        _NoAddRefReleaseOnCComPtr<T>* operator->() const
        {
                ATLASSERT(p!=NULL);
                return (_NoAddRefReleaseOnCComPtr<T>*)p;
        }
        T* operator=(T* lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
        }
        T* operator=(const CComQIPtr<T,piid>& lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
        }
        T* operator=(IUnknown* lp)
        {
                return (T*)AtlComQIPtrAssign((IUnknown**)&p, lp, *piid);
        }
        bool operator!() const
        {
                return (p == NULL);
        }
        bool operator<(T* pT) const
        {
                return p < pT;
        }
        bool operator==(T* pT) const
        {
                return p == pT;
        }
        // Compare two objects for equivalence
        bool IsEqualObject(IUnknown* pOther)
        {
                if (p == NULL && pOther == NULL)
                        return true; // They are both NULL objects

                if (p == NULL || pOther == NULL)
                        return false; // One is NULL the other is not

                CComPtr<IUnknown> punk1;
                CComPtr<IUnknown> punk2;
                p->QueryInterface(IID_IUnknown, (void**)&punk1);
                pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
                return punk1 == punk2;
        }
        void Attach(T* p2)
        {
                if (p)
                        p->Release();
                p = p2;
        }
        T* Detach()
        {
                T* pt = p;
                p = NULL;
                return pt;
        }
#if 0
        HRESULT CopyTo(T** ppT)
        {
                // there should either be a runtime check or an assert(not both).  otherwise
                // we can't depend on the runtime check during unattended api tests and have to
                // place a redundant extra check outside the call to CopyTo to keep assert
                // dialogs from popping up
                // ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
#else
        // we want to enable CopyTo to work correctly with bases of T
        // if INTERFACE isn't a base then we'll get a compile error
        template<class INTERFACE> HRESULT CopyTo(INTERFACE** ppT)
        {
                // there should either be a runtime check or an assert(not both).  otherwise
                // we can't depend on the runtime check during unattended api tests and have to
                // place a redundant extra check outside the call to CopyTo to keep assert
                // dialogs from popping up
                // ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
#endif


        HRESULT SetSite(IUnknown* punkParent)
        {
                return AtlSetChildSite(p, punkParent);
        }
        HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
        {
                return AtlAdvise(p, pUnk, iid, pdw);
        }
        HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                ATLASSERT(p == NULL);
                return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
        }
        HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                return hr;
        }
        template <class Q>
        HRESULT QueryInterface(Q** pp)
        {
                ATLASSERT(pp != NULL && *pp == NULL);
                return p->QueryInterface(__uuidof(Q), (void**)pp);
        }
                // this allows direct use in stl containers
                // without using the CAdapt template which causes extra addrefs/releases
                //  usage:
                // std::vector<CComQIPtr<IMytype>, CComQIPtr<IMytype>::stl_allocator>
        CComQIPtr<T,piid> * address(void) { return this; }
        const CComQIPtr<T,piid> * const_address(void) const { return this; }
                typedef stl_smart_ptr_allocator<CComQIPtr<T, piid> > stl_allocator;

        T* p;
};

//Specialization to make it work
template<>
class CComQIPtr<IUnknown, &IID_IUnknown>
{
public:
        typedef IUnknown _PtrClass;
        CComQIPtr()
        {
                p=NULL;
        }
        CComQIPtr(IUnknown* lp)
        {
                //Actually do a QI to get identity
                p=NULL;
                if (lp != NULL)
                        lp->QueryInterface(IID_IUnknown, (void **)&p);
        }
        CComQIPtr(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
        {
                if ((p = lp.p) != NULL)
                        p->AddRef();
        }
        CComQIPtr(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
            : p(NULL)
        {
                ATLASSERT(p == NULL);
                HRESULT hr = ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(IUnknown), (void**)&p);
                if (FAILED(hr)) ATLASSERT(p == NULL);
        }
        CComQIPtr(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
            : p(NULL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(IUnknown), (void**)&p);
                if (FAILED(hr)) ATLASSERT(p == NULL);
        }
        ~CComQIPtr()
        {
                if (p)
                        p->Release();
        }
        void Release()
        {
                IUnknown* pTemp = p;
                if (pTemp)
                {
                        p = NULL;
                        pTemp->Release();
                }
        }
        operator IUnknown*() const
        {
                return p;
        }
        IUnknown& operator*() const
        {
                ATLASSERT(p!=NULL);
                return *p;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the p member explicitly.
        IUnknown** operator&()
        {
                ATLASSERT(p==NULL);
                return &p;
        }
        _NoAddRefReleaseOnCComPtr<IUnknown>* operator->() const
        {
                ATLASSERT(p!=NULL);
                return (_NoAddRefReleaseOnCComPtr<IUnknown>*)p;
        }
        IUnknown* operator=(IUnknown* lp)
        {
                //Actually do a QI to get identity
                return (IUnknown*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IUnknown);
        }
        IUnknown* operator=(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
        {
                return (IUnknown*)AtlComPtrAssign((IUnknown**)&p, lp.p);
        }
        bool operator!() const
        {
                return (p == NULL);
        }
        bool operator<(IUnknown* pT) const
        {
                return p < pT;
        }
        bool operator==(IUnknown* pT) const
        {
                return p == pT;
        }
        // Compare two objects for equivalence
        bool IsEqualObject(IUnknown* pOther)
        {
                if (p == NULL && pOther == NULL)
                        return true; // They are both NULL objects

                if (p == NULL || pOther == NULL)
                        return false; // One is NULL the other is not

                CComPtr<IUnknown> punk1;
                CComPtr<IUnknown> punk2;
                p->QueryInterface(IID_IUnknown, (void**)&punk1);
                pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
                return punk1 == punk2;
        }
        IUnknown* Detach()
        {
                IUnknown* pt = p;
                p = NULL;
                return pt;
        }
        HRESULT CopyTo(IUnknown** ppT)
        {
                // there should either be a runtime check or an assert(not both).  otherwise
                // we can't depend on the runtime check during unattended api tests and have to
                // place a redundant extra check outside the call to CopyTo to keep assert
                // dialogs from popping up
                //ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
        HRESULT SetSite(IUnknown* punkParent)
        {
                return AtlSetChildSite(p, punkParent);
        }
        HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
        {
                return AtlAdvise(p, pUnk, iid, pdw);
        }
        HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                ATLASSERT(p == NULL);
                return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(IUnknown), (void**)&p);
        }
        HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(IUnknown), (void**)&p);
                return hr;
        }
        template <class Q>
        HRESULT QueryInterface(Q** pp)
        {
                ATLASSERT(pp != NULL && *pp == NULL);
                return p->QueryInterface(__uuidof(Q), (void**)pp);
        }
                // this allows direct use in stl containers
                // without using the CAdapt template which causes extra addrefs/releases
                //  usage:
                // std::vector<CComPtr<IMytype>, CComPtr<IMytype>::stl_allocator>
        CComQIPtr<IUnknown,  &IID_IUnknown> * address(void) { return this; }
        const CComQIPtr<IUnknown,  &IID_IUnknown> * const_address(void) const { return this; }
                typedef stl_smart_ptr_allocator<CComQIPtr<IUnknown,  &IID_IUnknown> > stl_allocator;

        IUnknown* p;
};

#define com_cast CComQIPtr

#if 0
/////////////////////////////////////////////////////////////
// Class to Adapt CComBSTR and CComPtr for use with STL containers
// the syntax to use it is
// std::vector< CAdapt <CComBSTR> > vect;

template <class T>
class CAdapt
{
public:
        CAdapt()
        {
        }
        CAdapt(const T& rSrc)
        {
                m_T = rSrc;
        }

        CAdapt(const CAdapt& rSrCA)
        {
                m_T = rSrCA.m_T;
        }

        CAdapt& operator=(const T& rSrc)
        {
                m_T = rSrc;
                return *this;
        }
        bool operator<(const T& rSrc) const
        {
                return m_T < rSrc;
        }
        bool operator==(const T& rSrc) const
        {
                return m_T == rSrc;
        }
        operator T&()
        {
                return m_T;
        }

        operator const T&() const
        {
                return m_T;
        }

        T m_T;
};
#endif

/////////////////////////////////////////////////////////////////////////////
// GUID comparison

#ifndef _SYS_GUID_OPERATORS_
inline BOOL InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
          ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
          ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
          ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
          ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}
#endif

inline BOOL InlineIsEqualUnknown(REFGUID rguid1)
{
   return (
          ((PLONG) &rguid1)[0] == 0 &&
          ((PLONG) &rguid1)[1] == 0 &&
#ifdef _ATL_BYTESWAP
          ((PLONG) &rguid1)[2] == 0xC0000000 &&
          ((PLONG) &rguid1)[3] == 0x00000046);
#else
          ((PLONG) &rguid1)[2] == 0x000000C0 &&
          ((PLONG) &rguid1)[3] == 0x46000000);
#endif
}

/////////////////////////////////////////////////////////////////////////////
// Threading Model Support

class CComCriticalSection
{
public:
        void Lock() {EnterCriticalSection(&m_sec);}
        void Unlock() {LeaveCriticalSection(&m_sec);}
        void Init() {InitializeCriticalSection(&m_sec);}
        void Term() {DeleteCriticalSection(&m_sec);}
        CRITICAL_SECTION m_sec;
};

class CComAutoCriticalSection
{
public:
        void Lock() {EnterCriticalSection(&m_sec);}
        void Unlock() {LeaveCriticalSection(&m_sec);}
        CComAutoCriticalSection() {InitializeCriticalSection(&m_sec);}
        ~CComAutoCriticalSection() {DeleteCriticalSection(&m_sec);}
        CRITICAL_SECTION m_sec;
};

class CComFakeCriticalSection
{
public:
        void Lock() {}
        void Unlock() {}
        void Init() {}
        void Term() {}
};

class CComMultiThreadModelNoCS
{
public:
        static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
        static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
        typedef CComFakeCriticalSection AutoCriticalSection;
        typedef CComFakeCriticalSection CriticalSection;
        typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComMultiThreadModel
{
public:
        static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
        static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
        typedef CComAutoCriticalSection AutoCriticalSection;
        typedef CComCriticalSection CriticalSection;
        typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComSingleThreadModel
{
public:
        static ULONG WINAPI Increment(LPLONG p) {return ++(*p);}
        static ULONG WINAPI Decrement(LPLONG p) {return --(*p);}
        typedef CComFakeCriticalSection AutoCriticalSection;
        typedef CComFakeCriticalSection CriticalSection;
        typedef CComSingleThreadModel ThreadModelNoCS;
};

#if defined(_ATL_SINGLE_THREADED)
        typedef CComSingleThreadModel CComObjectThreadModel;
        typedef CComSingleThreadModel CComGlobalsThreadModel;
#elif defined(_ATL_APARTMENT_THREADED)
        typedef CComSingleThreadModel CComObjectThreadModel;
        typedef CComMultiThreadModel CComGlobalsThreadModel;
#else
        typedef CComMultiThreadModel CComObjectThreadModel;
        typedef CComMultiThreadModel CComGlobalsThreadModel;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComModule

#define THREADFLAGS_APARTMENT 0x1
#define THREADFLAGS_BOTH 0x2
#define AUTPRXFLAG 0x4

HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);

#ifdef _ATL_DEBUG_INTERFACES
struct _QIThunk
{
        STDMETHOD(QueryInterface)(REFIID iid, void** pp)
        {
                ATLASSERT(m_dwRef >= 0);
                return pUnk->QueryInterface(iid, pp);
        }
        STDMETHOD_(ULONG, AddRef)()
        {
                if (bBreak)
                        DebugBreak();
                pUnk->AddRef();
                return InternalAddRef();
        }
        ULONG InternalAddRef()
        {
                if (bBreak)
                        DebugBreak();
                ATLASSERT(m_dwRef >= 0);
                long l = InterlockedIncrement(&m_dwRef);
				ATLTRACE(_T("%d> "), m_dwRef);
                AtlDumpIID(iid, lpszClassName, S_OK);
                if (l > m_dwMaxRef)
                        m_dwMaxRef = l;
                return l;
        }
        STDMETHOD_(ULONG, Release)();

        STDMETHOD(f3)();
        STDMETHOD(f4)();
        STDMETHOD(f5)();
        STDMETHOD(f6)();
        STDMETHOD(f7)();
        STDMETHOD(f8)();
        STDMETHOD(f9)();
        STDMETHOD(f10)();
        STDMETHOD(f11)();
        STDMETHOD(f12)();
        STDMETHOD(f13)();
        STDMETHOD(f14)();
        STDMETHOD(f15)();
        STDMETHOD(f16)();
        STDMETHOD(f17)();
        STDMETHOD(f18)();
        STDMETHOD(f19)();
        STDMETHOD(f20)();
        STDMETHOD(f21)();
        STDMETHOD(f22)();
        STDMETHOD(f23)();
        STDMETHOD(f24)();
        STDMETHOD(f25)();
        STDMETHOD(f26)();
        STDMETHOD(f27)();
        STDMETHOD(f28)();
        STDMETHOD(f29)();
        STDMETHOD(f30)();
        STDMETHOD(f31)();
        STDMETHOD(f32)();
        STDMETHOD(f33)();
        STDMETHOD(f34)();
        STDMETHOD(f35)();
        STDMETHOD(f36)();
        STDMETHOD(f37)();
        STDMETHOD(f38)();
        STDMETHOD(f39)();
        STDMETHOD(f40)();
        STDMETHOD(f41)();
        STDMETHOD(f42)();
        STDMETHOD(f43)();
        STDMETHOD(f44)();
        STDMETHOD(f45)();
        STDMETHOD(f46)();
        STDMETHOD(f47)();
        STDMETHOD(f48)();
        STDMETHOD(f49)();
        STDMETHOD(f50)();
        STDMETHOD(f51)();
        STDMETHOD(f52)();
        STDMETHOD(f53)();
        STDMETHOD(f54)();
        STDMETHOD(f55)();
        STDMETHOD(f56)();
        STDMETHOD(f57)();
        STDMETHOD(f58)();
        STDMETHOD(f59)();
        STDMETHOD(f60)();
        STDMETHOD(f61)();
        STDMETHOD(f62)();
        STDMETHOD(f63)();
        STDMETHOD(f64)();
        STDMETHOD(f65)();
        STDMETHOD(f66)();
        STDMETHOD(f67)();
        STDMETHOD(f68)();
        STDMETHOD(f69)();
        STDMETHOD(f70)();
        STDMETHOD(f71)();
        STDMETHOD(f72)();
        STDMETHOD(f73)();
        STDMETHOD(f74)();
        STDMETHOD(f75)();
        STDMETHOD(f76)();
        STDMETHOD(f77)();
        STDMETHOD(f78)();
        STDMETHOD(f79)();
        STDMETHOD(f80)();
        STDMETHOD(f81)();
        STDMETHOD(f82)();
        STDMETHOD(f83)();
        STDMETHOD(f84)();
        STDMETHOD(f85)();
        STDMETHOD(f86)();
        STDMETHOD(f87)();
        STDMETHOD(f88)();
        STDMETHOD(f89)();
        STDMETHOD(f90)();
        STDMETHOD(f91)();
        STDMETHOD(f92)();
        STDMETHOD(f93)();
        STDMETHOD(f94)();
        STDMETHOD(f95)();
        STDMETHOD(f96)();
        STDMETHOD(f97)();
        STDMETHOD(f98)();
        STDMETHOD(f99)();
        STDMETHOD(f100)();
        STDMETHOD(f101)();
        STDMETHOD(f102)();
        STDMETHOD(f103)();
        STDMETHOD(f104)();
        STDMETHOD(f105)();
        STDMETHOD(f106)();
        STDMETHOD(f107)();
        STDMETHOD(f108)();
        STDMETHOD(f109)();
        STDMETHOD(f110)();
        STDMETHOD(f111)();
        STDMETHOD(f112)();
        STDMETHOD(f113)();
        STDMETHOD(f114)();
        STDMETHOD(f115)();
        STDMETHOD(f116)();
        STDMETHOD(f117)();
        STDMETHOD(f118)();
        STDMETHOD(f119)();
        STDMETHOD(f120)();
        STDMETHOD(f121)();
        STDMETHOD(f122)();
        STDMETHOD(f123)();
        STDMETHOD(f124)();
        STDMETHOD(f125)();
        STDMETHOD(f126)();
        STDMETHOD(f127)();
        STDMETHOD(f128)();
        STDMETHOD(f129)();
        STDMETHOD(f130)();
        STDMETHOD(f131)();
        STDMETHOD(f132)();
        STDMETHOD(f133)();
        STDMETHOD(f134)();
        STDMETHOD(f135)();
        STDMETHOD(f136)();
        STDMETHOD(f137)();
        STDMETHOD(f138)();
        STDMETHOD(f139)();
        STDMETHOD(f140)();
        STDMETHOD(f141)();
        STDMETHOD(f142)();
        STDMETHOD(f143)();
        STDMETHOD(f144)();
        STDMETHOD(f145)();
        STDMETHOD(f146)();
        STDMETHOD(f147)();
        STDMETHOD(f148)();
        STDMETHOD(f149)();
        STDMETHOD(f150)();
        STDMETHOD(f151)();
        STDMETHOD(f152)();
        STDMETHOD(f153)();
        STDMETHOD(f154)();
        STDMETHOD(f155)();
        STDMETHOD(f156)();
        STDMETHOD(f157)();
        STDMETHOD(f158)();
        STDMETHOD(f159)();
        STDMETHOD(f160)();
        STDMETHOD(f161)();
        STDMETHOD(f162)();
        STDMETHOD(f163)();
        STDMETHOD(f164)();
        STDMETHOD(f165)();
        STDMETHOD(f166)();
        STDMETHOD(f167)();
        STDMETHOD(f168)();
        STDMETHOD(f169)();
        STDMETHOD(f170)();
        STDMETHOD(f171)();
        STDMETHOD(f172)();
        STDMETHOD(f173)();
        STDMETHOD(f174)();
        STDMETHOD(f175)();
        STDMETHOD(f176)();
        STDMETHOD(f177)();
        STDMETHOD(f178)();
        STDMETHOD(f179)();
        STDMETHOD(f180)();
        STDMETHOD(f181)();
        STDMETHOD(f182)();
        STDMETHOD(f183)();
        STDMETHOD(f184)();
        STDMETHOD(f185)();
        STDMETHOD(f186)();
        STDMETHOD(f187)();
        STDMETHOD(f188)();
        STDMETHOD(f189)();
        STDMETHOD(f190)();
        STDMETHOD(f191)();
        STDMETHOD(f192)();
        STDMETHOD(f193)();
        STDMETHOD(f194)();
        STDMETHOD(f195)();
        STDMETHOD(f196)();
        STDMETHOD(f197)();
        STDMETHOD(f198)();
        STDMETHOD(f199)();
        STDMETHOD(f200)();
        STDMETHOD(f201)();
        STDMETHOD(f202)();
        STDMETHOD(f203)();
        STDMETHOD(f204)();
        STDMETHOD(f205)();
        STDMETHOD(f206)();
        STDMETHOD(f207)();
        STDMETHOD(f208)();
        STDMETHOD(f209)();
        STDMETHOD(f210)();
        STDMETHOD(f211)();
        STDMETHOD(f212)();
        STDMETHOD(f213)();
        STDMETHOD(f214)();
        STDMETHOD(f215)();
        STDMETHOD(f216)();
        STDMETHOD(f217)();
        STDMETHOD(f218)();
        STDMETHOD(f219)();
        STDMETHOD(f220)();
        STDMETHOD(f221)();
        STDMETHOD(f222)();
        STDMETHOD(f223)();
        STDMETHOD(f224)();
        STDMETHOD(f225)();
        STDMETHOD(f226)();
        STDMETHOD(f227)();
        STDMETHOD(f228)();
        STDMETHOD(f229)();
        STDMETHOD(f230)();
        STDMETHOD(f231)();
        STDMETHOD(f232)();
        STDMETHOD(f233)();
        STDMETHOD(f234)();
        STDMETHOD(f235)();
        STDMETHOD(f236)();
        STDMETHOD(f237)();
        STDMETHOD(f238)();
        STDMETHOD(f239)();
        STDMETHOD(f240)();
        STDMETHOD(f241)();
        STDMETHOD(f242)();
        STDMETHOD(f243)();
        STDMETHOD(f244)();
        STDMETHOD(f245)();
        STDMETHOD(f246)();
        STDMETHOD(f247)();
        STDMETHOD(f248)();
        STDMETHOD(f249)();
        STDMETHOD(f250)();
        STDMETHOD(f251)();
        STDMETHOD(f252)();
        STDMETHOD(f253)();
        STDMETHOD(f254)();
        STDMETHOD(f255)();
        STDMETHOD(f256)();
        STDMETHOD(f257)();
        STDMETHOD(f258)();
        STDMETHOD(f259)();
        STDMETHOD(f260)();
        STDMETHOD(f261)();
        STDMETHOD(f262)();
        STDMETHOD(f263)();
        STDMETHOD(f264)();
        STDMETHOD(f265)();
        STDMETHOD(f266)();
        STDMETHOD(f267)();
        STDMETHOD(f268)();
        STDMETHOD(f269)();
        STDMETHOD(f270)();
        STDMETHOD(f271)();
        STDMETHOD(f272)();
        STDMETHOD(f273)();
        STDMETHOD(f274)();
        STDMETHOD(f275)();
        STDMETHOD(f276)();
        STDMETHOD(f277)();
        STDMETHOD(f278)();
        STDMETHOD(f279)();
        STDMETHOD(f280)();
        STDMETHOD(f281)();
        STDMETHOD(f282)();
        STDMETHOD(f283)();
        STDMETHOD(f284)();
        STDMETHOD(f285)();
        STDMETHOD(f286)();
        STDMETHOD(f287)();
        STDMETHOD(f288)();
        STDMETHOD(f289)();
        STDMETHOD(f290)();
        STDMETHOD(f291)();
        STDMETHOD(f292)();
        STDMETHOD(f293)();
        STDMETHOD(f294)();
        STDMETHOD(f295)();
        STDMETHOD(f296)();
        STDMETHOD(f297)();
        STDMETHOD(f298)();
        STDMETHOD(f299)();
        STDMETHOD(f300)();
        STDMETHOD(f301)();
        STDMETHOD(f302)();
        STDMETHOD(f303)();
        STDMETHOD(f304)();
        STDMETHOD(f305)();
        STDMETHOD(f306)();
        STDMETHOD(f307)();
        STDMETHOD(f308)();
        STDMETHOD(f309)();
        STDMETHOD(f310)();
        STDMETHOD(f311)();
        STDMETHOD(f312)();
        STDMETHOD(f313)();
        STDMETHOD(f314)();
        STDMETHOD(f315)();
        STDMETHOD(f316)();
        STDMETHOD(f317)();
        STDMETHOD(f318)();
        STDMETHOD(f319)();
        STDMETHOD(f320)();
        STDMETHOD(f321)();
        STDMETHOD(f322)();
        STDMETHOD(f323)();
        STDMETHOD(f324)();
        STDMETHOD(f325)();
        STDMETHOD(f326)();
        STDMETHOD(f327)();
        STDMETHOD(f328)();
        STDMETHOD(f329)();
        STDMETHOD(f330)();
        STDMETHOD(f331)();
        STDMETHOD(f332)();
        STDMETHOD(f333)();
        STDMETHOD(f334)();
        STDMETHOD(f335)();
        STDMETHOD(f336)();
        STDMETHOD(f337)();
        STDMETHOD(f338)();
        STDMETHOD(f339)();
        STDMETHOD(f340)();
        STDMETHOD(f341)();
        STDMETHOD(f342)();
        STDMETHOD(f343)();
        STDMETHOD(f344)();
        STDMETHOD(f345)();
        STDMETHOD(f346)();
        STDMETHOD(f347)();
        STDMETHOD(f348)();
        STDMETHOD(f349)();
        STDMETHOD(f350)();
        STDMETHOD(f351)();
        STDMETHOD(f352)();
        STDMETHOD(f353)();
        STDMETHOD(f354)();
        STDMETHOD(f355)();
        STDMETHOD(f356)();
        STDMETHOD(f357)();
        STDMETHOD(f358)();
        STDMETHOD(f359)();
        STDMETHOD(f360)();
        STDMETHOD(f361)();
        STDMETHOD(f362)();
        STDMETHOD(f363)();
        STDMETHOD(f364)();
        STDMETHOD(f365)();
        STDMETHOD(f366)();
        STDMETHOD(f367)();
        STDMETHOD(f368)();
        STDMETHOD(f369)();
        STDMETHOD(f370)();
        STDMETHOD(f371)();
        STDMETHOD(f372)();
        STDMETHOD(f373)();
        STDMETHOD(f374)();
        STDMETHOD(f375)();
        STDMETHOD(f376)();
        STDMETHOD(f377)();
        STDMETHOD(f378)();
        STDMETHOD(f379)();
        STDMETHOD(f380)();
        STDMETHOD(f381)();
        STDMETHOD(f382)();
        STDMETHOD(f383)();
        STDMETHOD(f384)();
        STDMETHOD(f385)();
        STDMETHOD(f386)();
        STDMETHOD(f387)();
        STDMETHOD(f388)();
        STDMETHOD(f389)();
        STDMETHOD(f390)();
        STDMETHOD(f391)();
        STDMETHOD(f392)();
        STDMETHOD(f393)();
        STDMETHOD(f394)();
        STDMETHOD(f395)();
        STDMETHOD(f396)();
        STDMETHOD(f397)();
        STDMETHOD(f398)();
        STDMETHOD(f399)();
        STDMETHOD(f400)();
        STDMETHOD(f401)();
        STDMETHOD(f402)();
        STDMETHOD(f403)();
        STDMETHOD(f404)();
        STDMETHOD(f405)();
        STDMETHOD(f406)();
        STDMETHOD(f407)();
        STDMETHOD(f408)();
        STDMETHOD(f409)();
        STDMETHOD(f410)();
        STDMETHOD(f411)();
        STDMETHOD(f412)();
        STDMETHOD(f413)();
        STDMETHOD(f414)();
        STDMETHOD(f415)();
        STDMETHOD(f416)();
        STDMETHOD(f417)();
        STDMETHOD(f418)();
        STDMETHOD(f419)();
        STDMETHOD(f420)();
        STDMETHOD(f421)();
        STDMETHOD(f422)();
        STDMETHOD(f423)();
        STDMETHOD(f424)();
        STDMETHOD(f425)();
        STDMETHOD(f426)();
        STDMETHOD(f427)();
        STDMETHOD(f428)();
        STDMETHOD(f429)();
        STDMETHOD(f430)();
        STDMETHOD(f431)();
        STDMETHOD(f432)();
        STDMETHOD(f433)();
        STDMETHOD(f434)();
        STDMETHOD(f435)();
        STDMETHOD(f436)();
        STDMETHOD(f437)();
        STDMETHOD(f438)();
        STDMETHOD(f439)();
        STDMETHOD(f440)();
        STDMETHOD(f441)();
        STDMETHOD(f442)();
        STDMETHOD(f443)();
        STDMETHOD(f444)();
        STDMETHOD(f445)();
        STDMETHOD(f446)();
        STDMETHOD(f447)();
        STDMETHOD(f448)();
        STDMETHOD(f449)();
        STDMETHOD(f450)();
        STDMETHOD(f451)();
        STDMETHOD(f452)();
        STDMETHOD(f453)();
        STDMETHOD(f454)();
        STDMETHOD(f455)();
        STDMETHOD(f456)();
        STDMETHOD(f457)();
        STDMETHOD(f458)();
        STDMETHOD(f459)();
        STDMETHOD(f460)();
        STDMETHOD(f461)();
        STDMETHOD(f462)();
        STDMETHOD(f463)();
        STDMETHOD(f464)();
        STDMETHOD(f465)();
        STDMETHOD(f466)();
        STDMETHOD(f467)();
        STDMETHOD(f468)();
        STDMETHOD(f469)();
        STDMETHOD(f470)();
        STDMETHOD(f471)();
        STDMETHOD(f472)();
        STDMETHOD(f473)();
        STDMETHOD(f474)();
        STDMETHOD(f475)();
        STDMETHOD(f476)();
        STDMETHOD(f477)();
        STDMETHOD(f478)();
        STDMETHOD(f479)();
        STDMETHOD(f480)();
        STDMETHOD(f481)();
        STDMETHOD(f482)();
        STDMETHOD(f483)();
        STDMETHOD(f484)();
        STDMETHOD(f485)();
        STDMETHOD(f486)();
        STDMETHOD(f487)();
        STDMETHOD(f488)();
        STDMETHOD(f489)();
        STDMETHOD(f490)();
        STDMETHOD(f491)();
        STDMETHOD(f492)();
        STDMETHOD(f493)();
        STDMETHOD(f494)();
        STDMETHOD(f495)();
        STDMETHOD(f496)();
        STDMETHOD(f497)();
        STDMETHOD(f498)();
        STDMETHOD(f499)();
        STDMETHOD(f500)();
        STDMETHOD(f501)();
        STDMETHOD(f502)();
        STDMETHOD(f503)();
        STDMETHOD(f504)();
        STDMETHOD(f505)();
        STDMETHOD(f506)();
        STDMETHOD(f507)();
        STDMETHOD(f508)();
        STDMETHOD(f509)();
        STDMETHOD(f510)();
        STDMETHOD(f511)();
        STDMETHOD(f512)();
        STDMETHOD(f513)();
        STDMETHOD(f514)();
        STDMETHOD(f515)();
        STDMETHOD(f516)();
        STDMETHOD(f517)();
        STDMETHOD(f518)();
        STDMETHOD(f519)();
        STDMETHOD(f520)();
        STDMETHOD(f521)();
        STDMETHOD(f522)();
        STDMETHOD(f523)();
        STDMETHOD(f524)();
        STDMETHOD(f525)();
        STDMETHOD(f526)();
        STDMETHOD(f527)();
        STDMETHOD(f528)();
        STDMETHOD(f529)();
        STDMETHOD(f530)();
        STDMETHOD(f531)();
        STDMETHOD(f532)();
        STDMETHOD(f533)();
        STDMETHOD(f534)();
        STDMETHOD(f535)();
        STDMETHOD(f536)();
        STDMETHOD(f537)();
        STDMETHOD(f538)();
        STDMETHOD(f539)();
        STDMETHOD(f540)();
        STDMETHOD(f541)();
        STDMETHOD(f542)();
        STDMETHOD(f543)();
        STDMETHOD(f544)();
        STDMETHOD(f545)();
        STDMETHOD(f546)();
        STDMETHOD(f547)();
        STDMETHOD(f548)();
        STDMETHOD(f549)();
        STDMETHOD(f550)();
        STDMETHOD(f551)();
        STDMETHOD(f552)();
        STDMETHOD(f553)();
        STDMETHOD(f554)();
        STDMETHOD(f555)();
        STDMETHOD(f556)();
        STDMETHOD(f557)();
        STDMETHOD(f558)();
        STDMETHOD(f559)();
        STDMETHOD(f560)();
        STDMETHOD(f561)();
        STDMETHOD(f562)();
        STDMETHOD(f563)();
        STDMETHOD(f564)();
        STDMETHOD(f565)();
        STDMETHOD(f566)();
        STDMETHOD(f567)();
        STDMETHOD(f568)();
        STDMETHOD(f569)();
        STDMETHOD(f570)();
        STDMETHOD(f571)();
        STDMETHOD(f572)();
        STDMETHOD(f573)();
        STDMETHOD(f574)();
        STDMETHOD(f575)();
        STDMETHOD(f576)();
        STDMETHOD(f577)();
        STDMETHOD(f578)();
        STDMETHOD(f579)();
        STDMETHOD(f580)();
        STDMETHOD(f581)();
        STDMETHOD(f582)();
        STDMETHOD(f583)();
        STDMETHOD(f584)();
        STDMETHOD(f585)();
        STDMETHOD(f586)();
        STDMETHOD(f587)();
        STDMETHOD(f588)();
        STDMETHOD(f589)();
        STDMETHOD(f590)();
        STDMETHOD(f591)();
        STDMETHOD(f592)();
        STDMETHOD(f593)();
        STDMETHOD(f594)();
        STDMETHOD(f595)();
        STDMETHOD(f596)();
        STDMETHOD(f597)();
        STDMETHOD(f598)();
        STDMETHOD(f599)();
        STDMETHOD(f600)();
        STDMETHOD(f601)();
        STDMETHOD(f602)();
        STDMETHOD(f603)();
        STDMETHOD(f604)();
        STDMETHOD(f605)();
        STDMETHOD(f606)();
        STDMETHOD(f607)();
        STDMETHOD(f608)();
        STDMETHOD(f609)();
        STDMETHOD(f610)();
        STDMETHOD(f611)();
        STDMETHOD(f612)();
        STDMETHOD(f613)();
        STDMETHOD(f614)();
        STDMETHOD(f615)();
        STDMETHOD(f616)();
        STDMETHOD(f617)();
        STDMETHOD(f618)();
        STDMETHOD(f619)();
        STDMETHOD(f620)();
        STDMETHOD(f621)();
        STDMETHOD(f622)();
        STDMETHOD(f623)();
        STDMETHOD(f624)();
        STDMETHOD(f625)();
        STDMETHOD(f626)();
        STDMETHOD(f627)();
        STDMETHOD(f628)();
        STDMETHOD(f629)();
        STDMETHOD(f630)();
        STDMETHOD(f631)();
        STDMETHOD(f632)();
        STDMETHOD(f633)();
        STDMETHOD(f634)();
        STDMETHOD(f635)();
        STDMETHOD(f636)();
        STDMETHOD(f637)();
        STDMETHOD(f638)();
        STDMETHOD(f639)();
        STDMETHOD(f640)();
        STDMETHOD(f641)();
        STDMETHOD(f642)();
        STDMETHOD(f643)();
        STDMETHOD(f644)();
        STDMETHOD(f645)();
        STDMETHOD(f646)();
        STDMETHOD(f647)();
        STDMETHOD(f648)();
        STDMETHOD(f649)();
        STDMETHOD(f650)();
        STDMETHOD(f651)();
        STDMETHOD(f652)();
        STDMETHOD(f653)();
        STDMETHOD(f654)();
        STDMETHOD(f655)();
        STDMETHOD(f656)();
        STDMETHOD(f657)();
        STDMETHOD(f658)();
        STDMETHOD(f659)();
        STDMETHOD(f660)();
        STDMETHOD(f661)();
        STDMETHOD(f662)();
        STDMETHOD(f663)();
        STDMETHOD(f664)();
        STDMETHOD(f665)();
        STDMETHOD(f666)();
        STDMETHOD(f667)();
        STDMETHOD(f668)();
        STDMETHOD(f669)();
        STDMETHOD(f670)();
        STDMETHOD(f671)();
        STDMETHOD(f672)();
        STDMETHOD(f673)();
        STDMETHOD(f674)();
        STDMETHOD(f675)();
        STDMETHOD(f676)();
        STDMETHOD(f677)();
        STDMETHOD(f678)();
        STDMETHOD(f679)();
        STDMETHOD(f680)();
        STDMETHOD(f681)();
        STDMETHOD(f682)();
        STDMETHOD(f683)();
        STDMETHOD(f684)();
        STDMETHOD(f685)();
        STDMETHOD(f686)();
        STDMETHOD(f687)();
        STDMETHOD(f688)();
        STDMETHOD(f689)();
        STDMETHOD(f690)();
        STDMETHOD(f691)();
        STDMETHOD(f692)();
        STDMETHOD(f693)();
        STDMETHOD(f694)();
        STDMETHOD(f695)();
        STDMETHOD(f696)();
        STDMETHOD(f697)();
        STDMETHOD(f698)();
        STDMETHOD(f699)();
        STDMETHOD(f700)();
        STDMETHOD(f701)();
        STDMETHOD(f702)();
        STDMETHOD(f703)();
        STDMETHOD(f704)();
        STDMETHOD(f705)();
        STDMETHOD(f706)();
        STDMETHOD(f707)();
        STDMETHOD(f708)();
        STDMETHOD(f709)();
        STDMETHOD(f710)();
        STDMETHOD(f711)();
        STDMETHOD(f712)();
        STDMETHOD(f713)();
        STDMETHOD(f714)();
        STDMETHOD(f715)();
        STDMETHOD(f716)();
        STDMETHOD(f717)();
        STDMETHOD(f718)();
        STDMETHOD(f719)();
        STDMETHOD(f720)();
        STDMETHOD(f721)();
        STDMETHOD(f722)();
        STDMETHOD(f723)();
        STDMETHOD(f724)();
        STDMETHOD(f725)();
        STDMETHOD(f726)();
        STDMETHOD(f727)();
        STDMETHOD(f728)();
        STDMETHOD(f729)();
        STDMETHOD(f730)();
        STDMETHOD(f731)();
        STDMETHOD(f732)();
        STDMETHOD(f733)();
        STDMETHOD(f734)();
        STDMETHOD(f735)();
        STDMETHOD(f736)();
        STDMETHOD(f737)();
        STDMETHOD(f738)();
        STDMETHOD(f739)();
        STDMETHOD(f740)();
        STDMETHOD(f741)();
        STDMETHOD(f742)();
        STDMETHOD(f743)();
        STDMETHOD(f744)();
        STDMETHOD(f745)();
        STDMETHOD(f746)();
        STDMETHOD(f747)();
        STDMETHOD(f748)();
        STDMETHOD(f749)();
        STDMETHOD(f750)();
        STDMETHOD(f751)();
        STDMETHOD(f752)();
        STDMETHOD(f753)();
        STDMETHOD(f754)();
        STDMETHOD(f755)();
        STDMETHOD(f756)();
        STDMETHOD(f757)();
        STDMETHOD(f758)();
        STDMETHOD(f759)();
        STDMETHOD(f760)();
        STDMETHOD(f761)();
        STDMETHOD(f762)();
        STDMETHOD(f763)();
        STDMETHOD(f764)();
        STDMETHOD(f765)();
        STDMETHOD(f766)();
        STDMETHOD(f767)();
        STDMETHOD(f768)();
        STDMETHOD(f769)();
        STDMETHOD(f770)();
        STDMETHOD(f771)();
        STDMETHOD(f772)();
        STDMETHOD(f773)();
        STDMETHOD(f774)();
        STDMETHOD(f775)();
        STDMETHOD(f776)();
        STDMETHOD(f777)();
        STDMETHOD(f778)();
        STDMETHOD(f779)();
        STDMETHOD(f780)();
        STDMETHOD(f781)();
        STDMETHOD(f782)();
        STDMETHOD(f783)();
        STDMETHOD(f784)();
        STDMETHOD(f785)();
        STDMETHOD(f786)();
        STDMETHOD(f787)();
        STDMETHOD(f788)();
        STDMETHOD(f789)();
        STDMETHOD(f790)();
        STDMETHOD(f791)();
        STDMETHOD(f792)();
        STDMETHOD(f793)();
        STDMETHOD(f794)();
        STDMETHOD(f795)();
        STDMETHOD(f796)();
        STDMETHOD(f797)();
        STDMETHOD(f798)();
        STDMETHOD(f799)();
        STDMETHOD(f800)();
        STDMETHOD(f801)();
        STDMETHOD(f802)();
        STDMETHOD(f803)();
        STDMETHOD(f804)();
        STDMETHOD(f805)();
        STDMETHOD(f806)();
        STDMETHOD(f807)();
        STDMETHOD(f808)();
        STDMETHOD(f809)();
        STDMETHOD(f810)();
        STDMETHOD(f811)();
        STDMETHOD(f812)();
        STDMETHOD(f813)();
        STDMETHOD(f814)();
        STDMETHOD(f815)();
        STDMETHOD(f816)();
        STDMETHOD(f817)();
        STDMETHOD(f818)();
        STDMETHOD(f819)();
        STDMETHOD(f820)();
        STDMETHOD(f821)();
        STDMETHOD(f822)();
        STDMETHOD(f823)();
        STDMETHOD(f824)();
        STDMETHOD(f825)();
        STDMETHOD(f826)();
        STDMETHOD(f827)();
        STDMETHOD(f828)();
        STDMETHOD(f829)();
        STDMETHOD(f830)();
        STDMETHOD(f831)();
        STDMETHOD(f832)();
        STDMETHOD(f833)();
        STDMETHOD(f834)();
        STDMETHOD(f835)();
        STDMETHOD(f836)();
        STDMETHOD(f837)();
        STDMETHOD(f838)();
        STDMETHOD(f839)();
        STDMETHOD(f840)();
        STDMETHOD(f841)();
        STDMETHOD(f842)();
        STDMETHOD(f843)();
        STDMETHOD(f844)();
        STDMETHOD(f845)();
        STDMETHOD(f846)();
        STDMETHOD(f847)();
        STDMETHOD(f848)();
        STDMETHOD(f849)();
        STDMETHOD(f850)();
        STDMETHOD(f851)();
        STDMETHOD(f852)();
        STDMETHOD(f853)();
        STDMETHOD(f854)();
        STDMETHOD(f855)();
        STDMETHOD(f856)();
        STDMETHOD(f857)();
        STDMETHOD(f858)();
        STDMETHOD(f859)();
        STDMETHOD(f860)();
        STDMETHOD(f861)();
        STDMETHOD(f862)();
        STDMETHOD(f863)();
        STDMETHOD(f864)();
        STDMETHOD(f865)();
        STDMETHOD(f866)();
        STDMETHOD(f867)();
        STDMETHOD(f868)();
        STDMETHOD(f869)();
        STDMETHOD(f870)();
        STDMETHOD(f871)();
        STDMETHOD(f872)();
        STDMETHOD(f873)();
        STDMETHOD(f874)();
        STDMETHOD(f875)();
        STDMETHOD(f876)();
        STDMETHOD(f877)();
        STDMETHOD(f878)();
        STDMETHOD(f879)();
        STDMETHOD(f880)();
        STDMETHOD(f881)();
        STDMETHOD(f882)();
        STDMETHOD(f883)();
        STDMETHOD(f884)();
        STDMETHOD(f885)();
        STDMETHOD(f886)();
        STDMETHOD(f887)();
        STDMETHOD(f888)();
        STDMETHOD(f889)();
        STDMETHOD(f890)();
        STDMETHOD(f891)();
        STDMETHOD(f892)();
        STDMETHOD(f893)();
        STDMETHOD(f894)();
        STDMETHOD(f895)();
        STDMETHOD(f896)();
        STDMETHOD(f897)();
        STDMETHOD(f898)();
        STDMETHOD(f899)();
        STDMETHOD(f900)();
        STDMETHOD(f901)();
        STDMETHOD(f902)();
        STDMETHOD(f903)();
        STDMETHOD(f904)();
        STDMETHOD(f905)();
        STDMETHOD(f906)();
        STDMETHOD(f907)();
        STDMETHOD(f908)();
        STDMETHOD(f909)();
        STDMETHOD(f910)();
        STDMETHOD(f911)();
        STDMETHOD(f912)();
        STDMETHOD(f913)();
        STDMETHOD(f914)();
        STDMETHOD(f915)();
        STDMETHOD(f916)();
        STDMETHOD(f917)();
        STDMETHOD(f918)();
        STDMETHOD(f919)();
        STDMETHOD(f920)();
        STDMETHOD(f921)();
        STDMETHOD(f922)();
        STDMETHOD(f923)();
        STDMETHOD(f924)();
        STDMETHOD(f925)();
        STDMETHOD(f926)();
        STDMETHOD(f927)();
        STDMETHOD(f928)();
        STDMETHOD(f929)();
        STDMETHOD(f930)();
        STDMETHOD(f931)();
        STDMETHOD(f932)();
        STDMETHOD(f933)();
        STDMETHOD(f934)();
        STDMETHOD(f935)();
        STDMETHOD(f936)();
        STDMETHOD(f937)();
        STDMETHOD(f938)();
        STDMETHOD(f939)();
        STDMETHOD(f940)();
        STDMETHOD(f941)();
        STDMETHOD(f942)();
        STDMETHOD(f943)();
        STDMETHOD(f944)();
        STDMETHOD(f945)();
        STDMETHOD(f946)();
        STDMETHOD(f947)();
        STDMETHOD(f948)();
        STDMETHOD(f949)();
        STDMETHOD(f950)();
        STDMETHOD(f951)();
        STDMETHOD(f952)();
        STDMETHOD(f953)();
        STDMETHOD(f954)();
        STDMETHOD(f955)();
        STDMETHOD(f956)();
        STDMETHOD(f957)();
        STDMETHOD(f958)();
        STDMETHOD(f959)();
        STDMETHOD(f960)();
        STDMETHOD(f961)();
        STDMETHOD(f962)();
        STDMETHOD(f963)();
        STDMETHOD(f964)();
        STDMETHOD(f965)();
        STDMETHOD(f966)();
        STDMETHOD(f967)();
        STDMETHOD(f968)();
        STDMETHOD(f969)();
        STDMETHOD(f970)();
        STDMETHOD(f971)();
        STDMETHOD(f972)();
        STDMETHOD(f973)();
        STDMETHOD(f974)();
        STDMETHOD(f975)();
        STDMETHOD(f976)();
        STDMETHOD(f977)();
        STDMETHOD(f978)();
        STDMETHOD(f979)();
        STDMETHOD(f980)();
        STDMETHOD(f981)();
        STDMETHOD(f982)();
        STDMETHOD(f983)();
        STDMETHOD(f984)();
        STDMETHOD(f985)();
        STDMETHOD(f986)();
        STDMETHOD(f987)();
        STDMETHOD(f988)();
        STDMETHOD(f989)();
        STDMETHOD(f990)();
        STDMETHOD(f991)();
        STDMETHOD(f992)();
        STDMETHOD(f993)();
        STDMETHOD(f994)();
        STDMETHOD(f995)();
        STDMETHOD(f996)();
        STDMETHOD(f997)();
        STDMETHOD(f998)();
        STDMETHOD(f999)();
        STDMETHOD(f1000)();
        STDMETHOD(f1001)();
        STDMETHOD(f1002)();
        STDMETHOD(f1003)();
        STDMETHOD(f1004)();
        STDMETHOD(f1005)();
        STDMETHOD(f1006)();
        STDMETHOD(f1007)();
        STDMETHOD(f1008)();
        STDMETHOD(f1009)();
        STDMETHOD(f1010)();
        STDMETHOD(f1011)();
        STDMETHOD(f1012)();
        STDMETHOD(f1013)();
        STDMETHOD(f1014)();
        STDMETHOD(f1015)();
        STDMETHOD(f1016)();
        STDMETHOD(f1017)();
        STDMETHOD(f1018)();
        STDMETHOD(f1019)();
        STDMETHOD(f1020)();
        STDMETHOD(f1021)();
        STDMETHOD(f1022)();
        STDMETHOD(f1023)();
        STDMETHOD(f1024)();
        _QIThunk(IUnknown* pOrig, LPCTSTR p, const IID& i, UINT n, bool b)
        {
                lpszClassName = p;
                iid = i;
                nIndex = n;
                m_dwRef = 0;
                m_dwMaxRef = 0;
                pUnk = pOrig;
                bBreak = b;
                bNonAddRefThunk = false;
        }
        IUnknown* pUnk;
        long m_dwRef;
        long m_dwMaxRef;
        LPCTSTR lpszClassName;
        IID iid;
        UINT nIndex;
        bool bBreak;
        bool bNonAddRefThunk;
        void Dump()
        {
                TCHAR buf[256];
                if (m_dwRef != 0)
                {
                        wsprintf(buf, _T("INTERFACE LEAK: RefCount = %d, MaxRefCount = %d, {Allocation = %d} "), m_dwRef, m_dwMaxRef, nIndex);
                        OutputDebugString(buf);
                        AtlDumpIID(iid, lpszClassName, S_OK);
                }
                else
                {
                        wsprintf(buf, _T("NonAddRef Thunk LEAK: {Allocation = %d}\n"), nIndex);
                        OutputDebugString(buf);
                }
        }
};

#endif


/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

template <class T>
class CSimpleArray
{
public:
        T* m_aT;
        int m_nSize;
        int m_nAllocSize;

// Construction/destruction
        CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
        { }

        ~CSimpleArray()
        {
                RemoveAll();
        }

// Operations
        int GetSize() const
        {
                return m_nSize;
        }
        BOOL Add(T& t)
        {
                if(m_nSize == m_nAllocSize)
                {
                        T* aT;
                        int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
                        aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
                        if(aT == NULL)
                                return FALSE;
                        m_nAllocSize = nNewAllocSize;
                        m_aT = aT;
                }
                m_nSize++;
                SetAtIndex(m_nSize - 1, t);
                return TRUE;
        }
        BOOL Remove(T& t)
        {
                int nIndex = Find(t);
                if(nIndex == -1)
                        return FALSE;
                return RemoveAt(nIndex);
        }
        BOOL RemoveAt(int nIndex)
        {
                if(nIndex != (m_nSize - 1))
                {
#if _MSC_VER >= 1200
					m_aT[nIndex].~T();
#else
		            T* MyT;
		            MyT = &m_aT[nIndex];
		            MyT->~T();
#endif
                    memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
                }
                m_nSize--;
                return TRUE;
        }
        void RemoveAll()
        {
                if(m_aT != NULL)
                {
					for(int i = 0; i < m_nSize; i++) {
#if _MSC_VER >= 1200
						m_aT[i].~T();
#else
		                T* MyT;
		                MyT = &m_aT[i];
		                MyT->~T();
#endif
		            }
                    free(m_aT);
                    m_aT = NULL;
                }
                m_nSize = 0;
                m_nAllocSize = 0;
        }
        T& operator[] (int nIndex) const
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                return m_aT[nIndex];
        }
        T* GetData() const
        {
                return m_aT;
        }

// Implementation
        class Wrapper
        {
        public:
                Wrapper(T& _t) : t(_t)
                {
                }
                template <class _Ty>
                void *operator new(size_t, _Ty* p)
                {
                        return p;
                }
                T t;
        };
        void SetAtIndex(int nIndex, T& t)
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
				new(m_aT + nIndex) Wrapper(t);
        }
        int Find(T& t) const
        {
                for(int i = 0; i < m_nSize; i++)
                {
                        if(m_aT[i] == t)
                                return i;
                }
                return -1;  // not found
        }
};

// for arrays of simple types
template <class T>
class CSimpleValArray : public CSimpleArray< T >
{
public:
        BOOL Add(T t)
        {
                return CSimpleArray< T >::Add(t);
        }
        BOOL Remove(T t)
        {
                return CSimpleArray< T >::Remove(t);
        }
        T operator[] (int nIndex) const
        {
                return CSimpleArray< T >::operator[](nIndex);
        }
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSimpleMap
{
public:
        TKey* m_aKey;
        TVal* m_aVal;
        int m_nSize;

// Construction/destruction
        CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
        { }

        ~CSimpleMap()
        {
                RemoveAll();
        }

// Operations
        int GetSize() const
        {
                return m_nSize;
        }
        BOOL Add(TKey key, TVal val)
        {
                TKey* pKey;
                pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
                if(pKey == NULL)
                        return FALSE;
                m_aKey = pKey;
                TVal* pVal;
                pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
                if(pVal == NULL)
                        return FALSE;
                m_aVal = pVal;
                m_nSize++;
                SetAtIndex(m_nSize - 1, key, val);
                return TRUE;
        }
        BOOL Remove(TKey key)
        {
                int nIndex = FindKey(key);
                if(nIndex == -1)
                        return FALSE;
                if(nIndex != (m_nSize - 1))
                {
                        m_aKey[nIndex].~TKey();
                        m_aVal[nIndex].~TVal();
                        memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
                        memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
                }
                TKey* pKey;
                pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
                if(pKey != NULL || m_nSize == 1)
                        m_aKey = pKey;
                TVal* pVal;
                pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
                if(pVal != NULL || m_nSize == 1)
                        m_aVal = pVal;
                m_nSize--;
                return TRUE;
        }
        void RemoveAll()
        {
                if(m_aKey != NULL)
                {
                        for(int i = 0; i < m_nSize; i++)
                        {
                                m_aKey[i].~TKey();
                                m_aVal[i].~TVal();
                        }
                        free(m_aKey);
                        m_aKey = NULL;
                }
                if(m_aVal != NULL)
                {
                        free(m_aVal);
                        m_aVal = NULL;
                }

                m_nSize = 0;
        }
        BOOL SetAt(TKey key, TVal val)
        {
                int nIndex = FindKey(key);
                if(nIndex == -1)
                        return FALSE;
                SetAtIndex(nIndex, key, val);
                return TRUE;
        }
        TVal Lookup(TKey key) const
        {
                int nIndex = FindKey(key);
                if(nIndex == -1)
                        return NULL;    // must be able to convert
                return GetValueAt(nIndex);
        }
        TKey ReverseLookup(TVal val) const
        {
                int nIndex = FindVal(val);
                if(nIndex == -1)
                        return NULL;    // must be able to convert
                return GetKeyAt(nIndex);
        }
        TKey& GetKeyAt(int nIndex) const
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                return m_aKey[nIndex];
        }
        TVal& GetValueAt(int nIndex) const
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                return m_aVal[nIndex];
        }

// Implementation

        template <typename T>
        class Wrapper
        {
        public:
                Wrapper(T& _t) : t(_t)
                {
                }
                template <typename _Ty>
                void *operator new(size_t, _Ty* p)
                {
                        return p;
                }
                T t;
        };
        void SetAtIndex(int nIndex, TKey& key, TVal& val)
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                new(m_aKey + nIndex) Wrapper<TKey>(key);
                new(m_aVal + nIndex) Wrapper<TVal>(val);
        }
        int FindKey(TKey& key) const
        {
                for(int i = 0; i < m_nSize; i++)
                {
                        if(m_aKey[i] == key)
                                return i;
                }
                return -1;  // not found
        }
        int FindVal(TVal& val) const
        {
                for(int i = 0; i < m_nSize; i++)
                {
                        if(m_aVal[i] == val)
                                return i;
                }
                return -1;  // not found
        }
};


class CComModule;
__declspec(selectany) CComModule* _pModule=NULL;

// {B62F5910-6528-11d1-9611-0000F81E0D0D}
_declspec(selectany) GUID GUID_ATLVer30 = { 0xb62f5910, 0x6528, 0x11d1, { 0x96, 0x11, 0x0, 0x0, 0xf8, 0x1e, 0xd, 0xd } };

class CComModule : public _ATL_MODULE
{
// Operations
public:
        static GUID m_libid;
#ifdef _ATL_DEBUG_INTERFACES
        UINT m_nIndexQI;
        UINT m_nIndexBreakAt;
        CSimpleArray<_QIThunk*>* m_paThunks;
#endif // _ATL_DEBUG_INTERFACES

        void AddCreateWndData(_AtlCreateWndData* pData, void* pObject)
        {
                AtlModuleAddCreateWndData(this, pData, pObject);
        }
        void* ExtractCreateWndData()
        {
                return AtlModuleExtractCreateWndData(this);
        }

		LONG GetNextWindowID()
		{
			LONG nID;

			nID = InterlockedIncrement(&m_nNextWindowID);

			return nID;
		}

        HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL)
        {
                pguidVer = &GUID_ATLVer30;
                _pModule = this;
                cbSize = sizeof(_ATL_MODULE);
                dwAtlBuildVer = _ATL_VER;
                AtlModuleInit(this, p, h);
                if (plibid != NULL)
                        memcpy((void*)&m_libid, plibid, sizeof(GUID));
				m_nNextWindowID = 1;
#ifdef _ATL_MIN_CRT
                // Create a base heap
                m_hHeap = HeapCreate(0, 0, 0);

#ifndef _ATL_NO_MP_HEAP
				SYSTEM_INFO si;
				GetSystemInfo(&si);
				if (si.dwNumberOfProcessors > 1) 
				{
                        DWORD dwHeaps = si.dwNumberOfProcessors * 2;
                        m_dwHeaps = 0xFFFFFFFF;
                        for (int bits = 0; bits < 32; bits++)
                        {
                                if (dwHeaps & 0x80000000)
                                        break;
                                dwHeaps <<= 1;
                                m_dwHeaps >>= 1;
                        }
                        m_dwHeaps >>= 1;

                        // Allocate more heaps for each processor
                        m_phHeaps = (HANDLE*) HeapAlloc(m_hHeap, _ATL_HEAPFLAGS, sizeof(HANDLE) * (m_dwHeaps + 1));
                        for (DWORD i = 0; i <= m_dwHeaps; i++)
                                m_phHeaps[i] = HeapCreate(0, 0, 0);
                }
                else
#endif
                {
                        m_phHeaps = NULL;
                        m_dwHeaps = 0;
                }
#endif
#ifdef _ATL_DEBUG_INTERFACES
                m_nIndexQI = 0;
                m_nIndexBreakAt = 0;
                m_paThunks = NULL;
                ATLTRY(m_paThunks = new CSimpleArray<_QIThunk*>);
                if (m_paThunks == NULL)
                        return E_OUTOFMEMORY;
#endif // _ATL_DEBUG_INTERFACES
                return S_OK;
        }
#ifdef _ATL_DEBUG_INTERFACES
        HRESULT AddThunk(IUnknown** pp, LPCTSTR lpsz, REFIID iid)
        {
                if ((pp == NULL) || (*pp == NULL))
                        return E_POINTER;
                IUnknown* p = *pp;
                _QIThunk* pThunk = NULL;
                EnterCriticalSection(&m_csObjMap);
                // Check if exists already for identity
                if (InlineIsEqualUnknown(iid))
                {
                        for (int i = 0; i < m_paThunks->GetSize(); i++)
                        {
                                if (m_paThunks->operator[](i)->pUnk == p)
                                {
                                        m_paThunks->operator[](i)->InternalAddRef();
                                        pThunk = m_paThunks->operator[](i);
                                        break;
                                }
                        }
                }
                if (pThunk == NULL)
                {
                        ++m_nIndexQI;
                        if (m_nIndexBreakAt == m_nIndexQI)
                                DebugBreak();
                        ATLTRY(pThunk = new _QIThunk(p, lpsz, iid, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
                        if (pThunk == NULL)
                                return E_OUTOFMEMORY;
                        pThunk->InternalAddRef();
                        m_paThunks->Add(pThunk);
                }
                LeaveCriticalSection(&m_csObjMap);
                *pp = (IUnknown*)pThunk;
                return S_OK;
        }
        HRESULT AddNonAddRefThunk(IUnknown* p, LPCTSTR lpsz, IUnknown** ppThunkRet)
        {
                _QIThunk* pThunk = NULL;
                EnterCriticalSection(&m_csObjMap);
                // Check if exists already for identity
                for (int i = 0; i < m_paThunks->GetSize(); i++)
                {
                        if (m_paThunks->operator[](i)->pUnk == p)
                        {
                                m_paThunks->operator[](i)->bNonAddRefThunk = true;
                                pThunk = m_paThunks->operator[](i);
                                break;
                        }
                }
                if (pThunk == NULL)
                {
                        ++m_nIndexQI;
                        if (m_nIndexBreakAt == m_nIndexQI)
                                DebugBreak();
                        ATLTRY(pThunk = new _QIThunk(p, lpsz, IID_IUnknown, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
                        if (pThunk == NULL)
                        {
                                *ppThunkRet = NULL;
                                return E_OUTOFMEMORY;
                        }
                        pThunk->bNonAddRefThunk = true;
                        m_paThunks->Add(pThunk);
                }
                LeaveCriticalSection(&m_csObjMap);
                *ppThunkRet = (IUnknown*)pThunk;
                return S_OK;;
        }
        void DeleteNonAddRefThunk(IUnknown* pUnk)
        {
                EnterCriticalSection(&m_csObjMap);
                for (int i = 0; i < m_paThunks->GetSize(); i++)
                {
                        if (m_paThunks->operator[](i)->pUnk == pUnk)
                        {
                                delete m_paThunks->operator[](i);
                                m_paThunks->RemoveAt(i);
                                break;
                        }
                }
                LeaveCriticalSection(&m_csObjMap);
        }
        void DeleteThunk(_QIThunk* p)
        {
                EnterCriticalSection(&m_csObjMap);
                int nIndex = m_paThunks->Find(p);
                if (nIndex != -1)
                {
                        delete m_paThunks->operator[](nIndex);
                        m_paThunks->RemoveAt(nIndex);
                }
                LeaveCriticalSection(&m_csObjMap);
        }
        bool DumpLeakedThunks()
        {
                bool b = false;
                for (int i = 0; i < m_paThunks->GetSize(); i++)
                {
                        b = true;
                        m_paThunks->operator[](i)->Dump();
                        delete m_paThunks->operator[](i);
                }
                m_paThunks->RemoveAll();
                return b;
        }
#endif // _ATL_DEBUG_INTERFACES
        void Term()
        {
#ifdef _ATL_DEBUG_INTERFACES
                m_bDestroyHeap = false; // prevent heap from going away
                AtlModuleTerm(this);
                DumpLeakedThunks();
                delete m_paThunks;
#ifndef _ATL_NO_MP_HEAP
                if (m_phHeaps != NULL)
                {
                        for (DWORD i = 0; i <= m_dwHeaps; i++)
                                HeapDestroy(m_phHeaps[i]);
                }
#endif
                if (m_hHeap != NULL)
                        HeapDestroy(m_hHeap);
#else
                AtlModuleTerm(this);
#endif // _ATL_DEBUG_INTERFACES
        }

        HRESULT AddTermFunc(_ATL_TERMFUNC* pFunc, DWORD_PTR dw)
        {
                return AtlModuleAddTermFunc(this, pFunc, dw);
        }

        LONG Lock()
        {
                return CComGlobalsThreadModel::Increment(&m_nLockCnt);
        }
        LONG Unlock()
        {
                return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
        }
        LONG GetLockCount()
        {
                return m_nLockCnt;
        }

        HINSTANCE GetModuleInstance() {return m_hInst;}
        HINSTANCE GetResourceInstance() {return m_hInstResource;}
        HINSTANCE GetTypeLibInstance() {return m_hInstTypeLib;}

        // Registry support (helpers)
        HRESULT RegisterTypeLib()
        {
                return AtlModuleRegisterTypeLib(this, NULL);
        }
        HRESULT RegisterTypeLib(LPCTSTR lpszIndex)
        {
                USES_CONVERSION;
                return AtlModuleRegisterTypeLib(this, T2COLE(lpszIndex));
        }
        HRESULT UnRegisterTypeLib()
        {
                return AtlModuleUnRegisterTypeLib(this, NULL);
        }
        HRESULT UnRegisterTypeLib(LPCTSTR lpszIndex)
        {
                USES_CONVERSION;
                return AtlModuleUnRegisterTypeLib(this, T2COLE(lpszIndex));
        }
        HRESULT RegisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL)
        {
                return AtlModuleRegisterServer(this, bRegTypeLib, pCLSID);
        }

        HRESULT UnregisterServer(const CLSID* pCLSID = NULL)
        {
                return AtlModuleUnregisterServer(this, pCLSID);
        }
        HRESULT UnregisterServer(BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL)
        {
                return AtlModuleUnregisterServerEx(this, bUnRegTypeLib, pCLSID);
        }

        // Resource-based Registration
        HRESULT WINAPI UpdateRegistryFromResourceD(LPCTSTR lpszRes, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
        {
                USES_CONVERSION;
                return AtlModuleUpdateRegistryFromResourceD(this, T2COLE(lpszRes), bRegister,
                        pMapEntries);
        }
        HRESULT WINAPI UpdateRegistryFromResourceD(UINT nResID, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
        {
                return AtlModuleUpdateRegistryFromResourceD(this,
                        (LPCOLESTR)MAKEINTRESOURCE(nResID), bRegister, pMapEntries);
        }

#ifdef _ATL_STATIC_REGISTRY
        // Statically linking to Registry Ponent
        HRESULT WINAPI UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
        HRESULT WINAPI UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
#endif

        // Standard Registration
        HRESULT WINAPI UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
                LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister);
        HRESULT WINAPI RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
                LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags);
        HRESULT WINAPI UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
                LPCTSTR lpszVerIndProgID);

        // Register/Revoke All Class Factories with the OS (EXE only)
        HRESULT RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags)
        {
                return AtlModuleRegisterClassObjects(this, dwClsContext, dwFlags);
        }
        HRESULT RevokeClassObjects()
        {
                return AtlModuleRevokeClassObjects(this);
        }

        // Obtain a Class Factory (DLL only)
        HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
        {
                return AtlModuleGetClassObject(this, rclsid, riid, ppv);
        }

        // Only used in CComAutoThreadModule
        HRESULT CreateInstance(void* /*pfnCreateInstance*/, REFIID /*riid*/, void** /*ppvObj*/)
        {
                ATLASSERT(FALSE);
                return E_NOTIMPL;
        }
        static HRESULT RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc);

        static void ReplaceSingleQuote(LPOLESTR lpDest, LPCOLESTR lp)
        {
                while (*lp)
                {
                        *lpDest++ = *lp;
                        if (*lp == OLESTR('\''))
                                *lpDest++ = *lp;
                        lp++;
                }
                *lpDest = NULL;
        }
};

#ifdef _ATL_DEBUG_INTERFACES
inline ULONG _QIThunk::Release()
{
	if (bBreak)
		DebugBreak();
	ATLASSERT(m_dwRef > 0);
	ULONG l = InterlockedDecrement(&m_dwRef);
	ATLTRACE(_T("%d< "), m_dwRef);
	AtlDumpIID(iid, lpszClassName, S_OK);
	pUnk->Release();
	if (l == 0 && !bNonAddRefThunk)
		_pModule->DeleteThunk(this);
	return l;
}

inline static void atlBadThunkCall()
{
        ATLASSERT(FALSE && "Call through deleted thunk");
}

#ifdef _M_IX86
#define IMPL_THUNK(n)\
__declspec(naked) inline HRESULT _QIThunk::f##n()\
{\
	__asm mov eax, [esp+4]\
	__asm cmp dword ptr [eax+8], 0\
	__asm jg goodref\
	__asm call atlBadThunkCall\
	__asm goodref:\
	__asm mov eax, [esp+4]\
	__asm mov eax, dword ptr [eax+4]\
	__asm mov [esp+4], eax\
	__asm mov eax, dword ptr [eax]\
	__asm mov eax, dword ptr [eax+4*n]\
	__asm jmp eax\
}

#else
#define IMPL_THUNK(x)
#endif

IMPL_THUNK(3)
IMPL_THUNK(4)
IMPL_THUNK(5)
IMPL_THUNK(6)
IMPL_THUNK(7)
IMPL_THUNK(8)
IMPL_THUNK(9)
IMPL_THUNK(10)
IMPL_THUNK(11)
IMPL_THUNK(12)
IMPL_THUNK(13)
IMPL_THUNK(14)
IMPL_THUNK(15)
IMPL_THUNK(16)
IMPL_THUNK(17)
IMPL_THUNK(18)
IMPL_THUNK(19)
IMPL_THUNK(20)
IMPL_THUNK(21)
IMPL_THUNK(22)
IMPL_THUNK(23)
IMPL_THUNK(24)
IMPL_THUNK(25)
IMPL_THUNK(26)
IMPL_THUNK(27)
IMPL_THUNK(28)
IMPL_THUNK(29)
IMPL_THUNK(30)
IMPL_THUNK(31)
IMPL_THUNK(32)
IMPL_THUNK(33)
IMPL_THUNK(34)
IMPL_THUNK(35)
IMPL_THUNK(36)
IMPL_THUNK(37)
IMPL_THUNK(38)
IMPL_THUNK(39)
IMPL_THUNK(40)
IMPL_THUNK(41)
IMPL_THUNK(42)
IMPL_THUNK(43)
IMPL_THUNK(44)
IMPL_THUNK(45)
IMPL_THUNK(46)
IMPL_THUNK(47)
IMPL_THUNK(48)
IMPL_THUNK(49)
IMPL_THUNK(50)
IMPL_THUNK(51)
IMPL_THUNK(52)
IMPL_THUNK(53)
IMPL_THUNK(54)
IMPL_THUNK(55)
IMPL_THUNK(56)
IMPL_THUNK(57)
IMPL_THUNK(58)
IMPL_THUNK(59)
IMPL_THUNK(60)
IMPL_THUNK(61)
IMPL_THUNK(62)
IMPL_THUNK(63)
IMPL_THUNK(64)
IMPL_THUNK(65)
IMPL_THUNK(66)
IMPL_THUNK(67)
IMPL_THUNK(68)
IMPL_THUNK(69)
IMPL_THUNK(70)
IMPL_THUNK(71)
IMPL_THUNK(72)
IMPL_THUNK(73)
IMPL_THUNK(74)
IMPL_THUNK(75)
IMPL_THUNK(76)
IMPL_THUNK(77)
IMPL_THUNK(78)
IMPL_THUNK(79)
IMPL_THUNK(80)
IMPL_THUNK(81)
IMPL_THUNK(82)
IMPL_THUNK(83)
IMPL_THUNK(84)
IMPL_THUNK(85)
IMPL_THUNK(86)
IMPL_THUNK(87)
IMPL_THUNK(88)
IMPL_THUNK(89)
IMPL_THUNK(90)
IMPL_THUNK(91)
IMPL_THUNK(92)
IMPL_THUNK(93)
IMPL_THUNK(94)
IMPL_THUNK(95)
IMPL_THUNK(96)
IMPL_THUNK(97)
IMPL_THUNK(98)
IMPL_THUNK(99)
IMPL_THUNK(100)
IMPL_THUNK(101)
IMPL_THUNK(102)
IMPL_THUNK(103)
IMPL_THUNK(104)
IMPL_THUNK(105)
IMPL_THUNK(106)
IMPL_THUNK(107)
IMPL_THUNK(108)
IMPL_THUNK(109)
IMPL_THUNK(110)
IMPL_THUNK(111)
IMPL_THUNK(112)
IMPL_THUNK(113)
IMPL_THUNK(114)
IMPL_THUNK(115)
IMPL_THUNK(116)
IMPL_THUNK(117)
IMPL_THUNK(118)
IMPL_THUNK(119)
IMPL_THUNK(120)
IMPL_THUNK(121)
IMPL_THUNK(122)
IMPL_THUNK(123)
IMPL_THUNK(124)
IMPL_THUNK(125)
IMPL_THUNK(126)
IMPL_THUNK(127)
IMPL_THUNK(128)
IMPL_THUNK(129)
IMPL_THUNK(130)
IMPL_THUNK(131)
IMPL_THUNK(132)
IMPL_THUNK(133)
IMPL_THUNK(134)
IMPL_THUNK(135)
IMPL_THUNK(136)
IMPL_THUNK(137)
IMPL_THUNK(138)
IMPL_THUNK(139)
IMPL_THUNK(140)
IMPL_THUNK(141)
IMPL_THUNK(142)
IMPL_THUNK(143)
IMPL_THUNK(144)
IMPL_THUNK(145)
IMPL_THUNK(146)
IMPL_THUNK(147)
IMPL_THUNK(148)
IMPL_THUNK(149)
IMPL_THUNK(150)
IMPL_THUNK(151)
IMPL_THUNK(152)
IMPL_THUNK(153)
IMPL_THUNK(154)
IMPL_THUNK(155)
IMPL_THUNK(156)
IMPL_THUNK(157)
IMPL_THUNK(158)
IMPL_THUNK(159)
IMPL_THUNK(160)
IMPL_THUNK(161)
IMPL_THUNK(162)
IMPL_THUNK(163)
IMPL_THUNK(164)
IMPL_THUNK(165)
IMPL_THUNK(166)
IMPL_THUNK(167)
IMPL_THUNK(168)
IMPL_THUNK(169)
IMPL_THUNK(170)
IMPL_THUNK(171)
IMPL_THUNK(172)
IMPL_THUNK(173)
IMPL_THUNK(174)
IMPL_THUNK(175)
IMPL_THUNK(176)
IMPL_THUNK(177)
IMPL_THUNK(178)
IMPL_THUNK(179)
IMPL_THUNK(180)
IMPL_THUNK(181)
IMPL_THUNK(182)
IMPL_THUNK(183)
IMPL_THUNK(184)
IMPL_THUNK(185)
IMPL_THUNK(186)
IMPL_THUNK(187)
IMPL_THUNK(188)
IMPL_THUNK(189)
IMPL_THUNK(190)
IMPL_THUNK(191)
IMPL_THUNK(192)
IMPL_THUNK(193)
IMPL_THUNK(194)
IMPL_THUNK(195)
IMPL_THUNK(196)
IMPL_THUNK(197)
IMPL_THUNK(198)
IMPL_THUNK(199)
IMPL_THUNK(200)
IMPL_THUNK(201)
IMPL_THUNK(202)
IMPL_THUNK(203)
IMPL_THUNK(204)
IMPL_THUNK(205)
IMPL_THUNK(206)
IMPL_THUNK(207)
IMPL_THUNK(208)
IMPL_THUNK(209)
IMPL_THUNK(210)
IMPL_THUNK(211)
IMPL_THUNK(212)
IMPL_THUNK(213)
IMPL_THUNK(214)
IMPL_THUNK(215)
IMPL_THUNK(216)
IMPL_THUNK(217)
IMPL_THUNK(218)
IMPL_THUNK(219)
IMPL_THUNK(220)
IMPL_THUNK(221)
IMPL_THUNK(222)
IMPL_THUNK(223)
IMPL_THUNK(224)
IMPL_THUNK(225)
IMPL_THUNK(226)
IMPL_THUNK(227)
IMPL_THUNK(228)
IMPL_THUNK(229)
IMPL_THUNK(230)
IMPL_THUNK(231)
IMPL_THUNK(232)
IMPL_THUNK(233)
IMPL_THUNK(234)
IMPL_THUNK(235)
IMPL_THUNK(236)
IMPL_THUNK(237)
IMPL_THUNK(238)
IMPL_THUNK(239)
IMPL_THUNK(240)
IMPL_THUNK(241)
IMPL_THUNK(242)
IMPL_THUNK(243)
IMPL_THUNK(244)
IMPL_THUNK(245)
IMPL_THUNK(246)
IMPL_THUNK(247)
IMPL_THUNK(248)
IMPL_THUNK(249)
IMPL_THUNK(250)
IMPL_THUNK(251)
IMPL_THUNK(252)
IMPL_THUNK(253)
IMPL_THUNK(254)
IMPL_THUNK(255)
IMPL_THUNK(256)
IMPL_THUNK(257)
IMPL_THUNK(258)
IMPL_THUNK(259)
IMPL_THUNK(260)
IMPL_THUNK(261)
IMPL_THUNK(262)
IMPL_THUNK(263)
IMPL_THUNK(264)
IMPL_THUNK(265)
IMPL_THUNK(266)
IMPL_THUNK(267)
IMPL_THUNK(268)
IMPL_THUNK(269)
IMPL_THUNK(270)
IMPL_THUNK(271)
IMPL_THUNK(272)
IMPL_THUNK(273)
IMPL_THUNK(274)
IMPL_THUNK(275)
IMPL_THUNK(276)
IMPL_THUNK(277)
IMPL_THUNK(278)
IMPL_THUNK(279)
IMPL_THUNK(280)
IMPL_THUNK(281)
IMPL_THUNK(282)
IMPL_THUNK(283)
IMPL_THUNK(284)
IMPL_THUNK(285)
IMPL_THUNK(286)
IMPL_THUNK(287)
IMPL_THUNK(288)
IMPL_THUNK(289)
IMPL_THUNK(290)
IMPL_THUNK(291)
IMPL_THUNK(292)
IMPL_THUNK(293)
IMPL_THUNK(294)
IMPL_THUNK(295)
IMPL_THUNK(296)
IMPL_THUNK(297)
IMPL_THUNK(298)
IMPL_THUNK(299)
IMPL_THUNK(300)
IMPL_THUNK(301)
IMPL_THUNK(302)
IMPL_THUNK(303)
IMPL_THUNK(304)
IMPL_THUNK(305)
IMPL_THUNK(306)
IMPL_THUNK(307)
IMPL_THUNK(308)
IMPL_THUNK(309)
IMPL_THUNK(310)
IMPL_THUNK(311)
IMPL_THUNK(312)
IMPL_THUNK(313)
IMPL_THUNK(314)
IMPL_THUNK(315)
IMPL_THUNK(316)
IMPL_THUNK(317)
IMPL_THUNK(318)
IMPL_THUNK(319)
IMPL_THUNK(320)
IMPL_THUNK(321)
IMPL_THUNK(322)
IMPL_THUNK(323)
IMPL_THUNK(324)
IMPL_THUNK(325)
IMPL_THUNK(326)
IMPL_THUNK(327)
IMPL_THUNK(328)
IMPL_THUNK(329)
IMPL_THUNK(330)
IMPL_THUNK(331)
IMPL_THUNK(332)
IMPL_THUNK(333)
IMPL_THUNK(334)
IMPL_THUNK(335)
IMPL_THUNK(336)
IMPL_THUNK(337)
IMPL_THUNK(338)
IMPL_THUNK(339)
IMPL_THUNK(340)
IMPL_THUNK(341)
IMPL_THUNK(342)
IMPL_THUNK(343)
IMPL_THUNK(344)
IMPL_THUNK(345)
IMPL_THUNK(346)
IMPL_THUNK(347)
IMPL_THUNK(348)
IMPL_THUNK(349)
IMPL_THUNK(350)
IMPL_THUNK(351)
IMPL_THUNK(352)
IMPL_THUNK(353)
IMPL_THUNK(354)
IMPL_THUNK(355)
IMPL_THUNK(356)
IMPL_THUNK(357)
IMPL_THUNK(358)
IMPL_THUNK(359)
IMPL_THUNK(360)
IMPL_THUNK(361)
IMPL_THUNK(362)
IMPL_THUNK(363)
IMPL_THUNK(364)
IMPL_THUNK(365)
IMPL_THUNK(366)
IMPL_THUNK(367)
IMPL_THUNK(368)
IMPL_THUNK(369)
IMPL_THUNK(370)
IMPL_THUNK(371)
IMPL_THUNK(372)
IMPL_THUNK(373)
IMPL_THUNK(374)
IMPL_THUNK(375)
IMPL_THUNK(376)
IMPL_THUNK(377)
IMPL_THUNK(378)
IMPL_THUNK(379)
IMPL_THUNK(380)
IMPL_THUNK(381)
IMPL_THUNK(382)
IMPL_THUNK(383)
IMPL_THUNK(384)
IMPL_THUNK(385)
IMPL_THUNK(386)
IMPL_THUNK(387)
IMPL_THUNK(388)
IMPL_THUNK(389)
IMPL_THUNK(390)
IMPL_THUNK(391)
IMPL_THUNK(392)
IMPL_THUNK(393)
IMPL_THUNK(394)
IMPL_THUNK(395)
IMPL_THUNK(396)
IMPL_THUNK(397)
IMPL_THUNK(398)
IMPL_THUNK(399)
IMPL_THUNK(400)
IMPL_THUNK(401)
IMPL_THUNK(402)
IMPL_THUNK(403)
IMPL_THUNK(404)
IMPL_THUNK(405)
IMPL_THUNK(406)
IMPL_THUNK(407)
IMPL_THUNK(408)
IMPL_THUNK(409)
IMPL_THUNK(410)
IMPL_THUNK(411)
IMPL_THUNK(412)
IMPL_THUNK(413)
IMPL_THUNK(414)
IMPL_THUNK(415)
IMPL_THUNK(416)
IMPL_THUNK(417)
IMPL_THUNK(418)
IMPL_THUNK(419)
IMPL_THUNK(420)
IMPL_THUNK(421)
IMPL_THUNK(422)
IMPL_THUNK(423)
IMPL_THUNK(424)
IMPL_THUNK(425)
IMPL_THUNK(426)
IMPL_THUNK(427)
IMPL_THUNK(428)
IMPL_THUNK(429)
IMPL_THUNK(430)
IMPL_THUNK(431)
IMPL_THUNK(432)
IMPL_THUNK(433)
IMPL_THUNK(434)
IMPL_THUNK(435)
IMPL_THUNK(436)
IMPL_THUNK(437)
IMPL_THUNK(438)
IMPL_THUNK(439)
IMPL_THUNK(440)
IMPL_THUNK(441)
IMPL_THUNK(442)
IMPL_THUNK(443)
IMPL_THUNK(444)
IMPL_THUNK(445)
IMPL_THUNK(446)
IMPL_THUNK(447)
IMPL_THUNK(448)
IMPL_THUNK(449)
IMPL_THUNK(450)
IMPL_THUNK(451)
IMPL_THUNK(452)
IMPL_THUNK(453)
IMPL_THUNK(454)
IMPL_THUNK(455)
IMPL_THUNK(456)
IMPL_THUNK(457)
IMPL_THUNK(458)
IMPL_THUNK(459)
IMPL_THUNK(460)
IMPL_THUNK(461)
IMPL_THUNK(462)
IMPL_THUNK(463)
IMPL_THUNK(464)
IMPL_THUNK(465)
IMPL_THUNK(466)
IMPL_THUNK(467)
IMPL_THUNK(468)
IMPL_THUNK(469)
IMPL_THUNK(470)
IMPL_THUNK(471)
IMPL_THUNK(472)
IMPL_THUNK(473)
IMPL_THUNK(474)
IMPL_THUNK(475)
IMPL_THUNK(476)
IMPL_THUNK(477)
IMPL_THUNK(478)
IMPL_THUNK(479)
IMPL_THUNK(480)
IMPL_THUNK(481)
IMPL_THUNK(482)
IMPL_THUNK(483)
IMPL_THUNK(484)
IMPL_THUNK(485)
IMPL_THUNK(486)
IMPL_THUNK(487)
IMPL_THUNK(488)
IMPL_THUNK(489)
IMPL_THUNK(490)
IMPL_THUNK(491)
IMPL_THUNK(492)
IMPL_THUNK(493)
IMPL_THUNK(494)
IMPL_THUNK(495)
IMPL_THUNK(496)
IMPL_THUNK(497)
IMPL_THUNK(498)
IMPL_THUNK(499)
IMPL_THUNK(500)
IMPL_THUNK(501)
IMPL_THUNK(502)
IMPL_THUNK(503)
IMPL_THUNK(504)
IMPL_THUNK(505)
IMPL_THUNK(506)
IMPL_THUNK(507)
IMPL_THUNK(508)
IMPL_THUNK(509)
IMPL_THUNK(510)
IMPL_THUNK(511)
IMPL_THUNK(512)
IMPL_THUNK(513)
IMPL_THUNK(514)
IMPL_THUNK(515)
IMPL_THUNK(516)
IMPL_THUNK(517)
IMPL_THUNK(518)
IMPL_THUNK(519)
IMPL_THUNK(520)
IMPL_THUNK(521)
IMPL_THUNK(522)
IMPL_THUNK(523)
IMPL_THUNK(524)
IMPL_THUNK(525)
IMPL_THUNK(526)
IMPL_THUNK(527)
IMPL_THUNK(528)
IMPL_THUNK(529)
IMPL_THUNK(530)
IMPL_THUNK(531)
IMPL_THUNK(532)
IMPL_THUNK(533)
IMPL_THUNK(534)
IMPL_THUNK(535)
IMPL_THUNK(536)
IMPL_THUNK(537)
IMPL_THUNK(538)
IMPL_THUNK(539)
IMPL_THUNK(540)
IMPL_THUNK(541)
IMPL_THUNK(542)
IMPL_THUNK(543)
IMPL_THUNK(544)
IMPL_THUNK(545)
IMPL_THUNK(546)
IMPL_THUNK(547)
IMPL_THUNK(548)
IMPL_THUNK(549)
IMPL_THUNK(550)
IMPL_THUNK(551)
IMPL_THUNK(552)
IMPL_THUNK(553)
IMPL_THUNK(554)
IMPL_THUNK(555)
IMPL_THUNK(556)
IMPL_THUNK(557)
IMPL_THUNK(558)
IMPL_THUNK(559)
IMPL_THUNK(560)
IMPL_THUNK(561)
IMPL_THUNK(562)
IMPL_THUNK(563)
IMPL_THUNK(564)
IMPL_THUNK(565)
IMPL_THUNK(566)
IMPL_THUNK(567)
IMPL_THUNK(568)
IMPL_THUNK(569)
IMPL_THUNK(570)
IMPL_THUNK(571)
IMPL_THUNK(572)
IMPL_THUNK(573)
IMPL_THUNK(574)
IMPL_THUNK(575)
IMPL_THUNK(576)
IMPL_THUNK(577)
IMPL_THUNK(578)
IMPL_THUNK(579)
IMPL_THUNK(580)
IMPL_THUNK(581)
IMPL_THUNK(582)
IMPL_THUNK(583)
IMPL_THUNK(584)
IMPL_THUNK(585)
IMPL_THUNK(586)
IMPL_THUNK(587)
IMPL_THUNK(588)
IMPL_THUNK(589)
IMPL_THUNK(590)
IMPL_THUNK(591)
IMPL_THUNK(592)
IMPL_THUNK(593)
IMPL_THUNK(594)
IMPL_THUNK(595)
IMPL_THUNK(596)
IMPL_THUNK(597)
IMPL_THUNK(598)
IMPL_THUNK(599)
IMPL_THUNK(600)
IMPL_THUNK(601)
IMPL_THUNK(602)
IMPL_THUNK(603)
IMPL_THUNK(604)
IMPL_THUNK(605)
IMPL_THUNK(606)
IMPL_THUNK(607)
IMPL_THUNK(608)
IMPL_THUNK(609)
IMPL_THUNK(610)
IMPL_THUNK(611)
IMPL_THUNK(612)
IMPL_THUNK(613)
IMPL_THUNK(614)
IMPL_THUNK(615)
IMPL_THUNK(616)
IMPL_THUNK(617)
IMPL_THUNK(618)
IMPL_THUNK(619)
IMPL_THUNK(620)
IMPL_THUNK(621)
IMPL_THUNK(622)
IMPL_THUNK(623)
IMPL_THUNK(624)
IMPL_THUNK(625)
IMPL_THUNK(626)
IMPL_THUNK(627)
IMPL_THUNK(628)
IMPL_THUNK(629)
IMPL_THUNK(630)
IMPL_THUNK(631)
IMPL_THUNK(632)
IMPL_THUNK(633)
IMPL_THUNK(634)
IMPL_THUNK(635)
IMPL_THUNK(636)
IMPL_THUNK(637)
IMPL_THUNK(638)
IMPL_THUNK(639)
IMPL_THUNK(640)
IMPL_THUNK(641)
IMPL_THUNK(642)
IMPL_THUNK(643)
IMPL_THUNK(644)
IMPL_THUNK(645)
IMPL_THUNK(646)
IMPL_THUNK(647)
IMPL_THUNK(648)
IMPL_THUNK(649)
IMPL_THUNK(650)
IMPL_THUNK(651)
IMPL_THUNK(652)
IMPL_THUNK(653)
IMPL_THUNK(654)
IMPL_THUNK(655)
IMPL_THUNK(656)
IMPL_THUNK(657)
IMPL_THUNK(658)
IMPL_THUNK(659)
IMPL_THUNK(660)
IMPL_THUNK(661)
IMPL_THUNK(662)
IMPL_THUNK(663)
IMPL_THUNK(664)
IMPL_THUNK(665)
IMPL_THUNK(666)
IMPL_THUNK(667)
IMPL_THUNK(668)
IMPL_THUNK(669)
IMPL_THUNK(670)
IMPL_THUNK(671)
IMPL_THUNK(672)
IMPL_THUNK(673)
IMPL_THUNK(674)
IMPL_THUNK(675)
IMPL_THUNK(676)
IMPL_THUNK(677)
IMPL_THUNK(678)
IMPL_THUNK(679)
IMPL_THUNK(680)
IMPL_THUNK(681)
IMPL_THUNK(682)
IMPL_THUNK(683)
IMPL_THUNK(684)
IMPL_THUNK(685)
IMPL_THUNK(686)
IMPL_THUNK(687)
IMPL_THUNK(688)
IMPL_THUNK(689)
IMPL_THUNK(690)
IMPL_THUNK(691)
IMPL_THUNK(692)
IMPL_THUNK(693)
IMPL_THUNK(694)
IMPL_THUNK(695)
IMPL_THUNK(696)
IMPL_THUNK(697)
IMPL_THUNK(698)
IMPL_THUNK(699)
IMPL_THUNK(700)
IMPL_THUNK(701)
IMPL_THUNK(702)
IMPL_THUNK(703)
IMPL_THUNK(704)
IMPL_THUNK(705)
IMPL_THUNK(706)
IMPL_THUNK(707)
IMPL_THUNK(708)
IMPL_THUNK(709)
IMPL_THUNK(710)
IMPL_THUNK(711)
IMPL_THUNK(712)
IMPL_THUNK(713)
IMPL_THUNK(714)
IMPL_THUNK(715)
IMPL_THUNK(716)
IMPL_THUNK(717)
IMPL_THUNK(718)
IMPL_THUNK(719)
IMPL_THUNK(720)
IMPL_THUNK(721)
IMPL_THUNK(722)
IMPL_THUNK(723)
IMPL_THUNK(724)
IMPL_THUNK(725)
IMPL_THUNK(726)
IMPL_THUNK(727)
IMPL_THUNK(728)
IMPL_THUNK(729)
IMPL_THUNK(730)
IMPL_THUNK(731)
IMPL_THUNK(732)
IMPL_THUNK(733)
IMPL_THUNK(734)
IMPL_THUNK(735)
IMPL_THUNK(736)
IMPL_THUNK(737)
IMPL_THUNK(738)
IMPL_THUNK(739)
IMPL_THUNK(740)
IMPL_THUNK(741)
IMPL_THUNK(742)
IMPL_THUNK(743)
IMPL_THUNK(744)
IMPL_THUNK(745)
IMPL_THUNK(746)
IMPL_THUNK(747)
IMPL_THUNK(748)
IMPL_THUNK(749)
IMPL_THUNK(750)
IMPL_THUNK(751)
IMPL_THUNK(752)
IMPL_THUNK(753)
IMPL_THUNK(754)
IMPL_THUNK(755)
IMPL_THUNK(756)
IMPL_THUNK(757)
IMPL_THUNK(758)
IMPL_THUNK(759)
IMPL_THUNK(760)
IMPL_THUNK(761)
IMPL_THUNK(762)
IMPL_THUNK(763)
IMPL_THUNK(764)
IMPL_THUNK(765)
IMPL_THUNK(766)
IMPL_THUNK(767)
IMPL_THUNK(768)
IMPL_THUNK(769)
IMPL_THUNK(770)
IMPL_THUNK(771)
IMPL_THUNK(772)
IMPL_THUNK(773)
IMPL_THUNK(774)
IMPL_THUNK(775)
IMPL_THUNK(776)
IMPL_THUNK(777)
IMPL_THUNK(778)
IMPL_THUNK(779)
IMPL_THUNK(780)
IMPL_THUNK(781)
IMPL_THUNK(782)
IMPL_THUNK(783)
IMPL_THUNK(784)
IMPL_THUNK(785)
IMPL_THUNK(786)
IMPL_THUNK(787)
IMPL_THUNK(788)
IMPL_THUNK(789)
IMPL_THUNK(790)
IMPL_THUNK(791)
IMPL_THUNK(792)
IMPL_THUNK(793)
IMPL_THUNK(794)
IMPL_THUNK(795)
IMPL_THUNK(796)
IMPL_THUNK(797)
IMPL_THUNK(798)
IMPL_THUNK(799)
IMPL_THUNK(800)
IMPL_THUNK(801)
IMPL_THUNK(802)
IMPL_THUNK(803)
IMPL_THUNK(804)
IMPL_THUNK(805)
IMPL_THUNK(806)
IMPL_THUNK(807)
IMPL_THUNK(808)
IMPL_THUNK(809)
IMPL_THUNK(810)
IMPL_THUNK(811)
IMPL_THUNK(812)
IMPL_THUNK(813)
IMPL_THUNK(814)
IMPL_THUNK(815)
IMPL_THUNK(816)
IMPL_THUNK(817)
IMPL_THUNK(818)
IMPL_THUNK(819)
IMPL_THUNK(820)
IMPL_THUNK(821)
IMPL_THUNK(822)
IMPL_THUNK(823)
IMPL_THUNK(824)
IMPL_THUNK(825)
IMPL_THUNK(826)
IMPL_THUNK(827)
IMPL_THUNK(828)
IMPL_THUNK(829)
IMPL_THUNK(830)
IMPL_THUNK(831)
IMPL_THUNK(832)
IMPL_THUNK(833)
IMPL_THUNK(834)
IMPL_THUNK(835)
IMPL_THUNK(836)
IMPL_THUNK(837)
IMPL_THUNK(838)
IMPL_THUNK(839)
IMPL_THUNK(840)
IMPL_THUNK(841)
IMPL_THUNK(842)
IMPL_THUNK(843)
IMPL_THUNK(844)
IMPL_THUNK(845)
IMPL_THUNK(846)
IMPL_THUNK(847)
IMPL_THUNK(848)
IMPL_THUNK(849)
IMPL_THUNK(850)
IMPL_THUNK(851)
IMPL_THUNK(852)
IMPL_THUNK(853)
IMPL_THUNK(854)
IMPL_THUNK(855)
IMPL_THUNK(856)
IMPL_THUNK(857)
IMPL_THUNK(858)
IMPL_THUNK(859)
IMPL_THUNK(860)
IMPL_THUNK(861)
IMPL_THUNK(862)
IMPL_THUNK(863)
IMPL_THUNK(864)
IMPL_THUNK(865)
IMPL_THUNK(866)
IMPL_THUNK(867)
IMPL_THUNK(868)
IMPL_THUNK(869)
IMPL_THUNK(870)
IMPL_THUNK(871)
IMPL_THUNK(872)
IMPL_THUNK(873)
IMPL_THUNK(874)
IMPL_THUNK(875)
IMPL_THUNK(876)
IMPL_THUNK(877)
IMPL_THUNK(878)
IMPL_THUNK(879)
IMPL_THUNK(880)
IMPL_THUNK(881)
IMPL_THUNK(882)
IMPL_THUNK(883)
IMPL_THUNK(884)
IMPL_THUNK(885)
IMPL_THUNK(886)
IMPL_THUNK(887)
IMPL_THUNK(888)
IMPL_THUNK(889)
IMPL_THUNK(890)
IMPL_THUNK(891)
IMPL_THUNK(892)
IMPL_THUNK(893)
IMPL_THUNK(894)
IMPL_THUNK(895)
IMPL_THUNK(896)
IMPL_THUNK(897)
IMPL_THUNK(898)
IMPL_THUNK(899)
IMPL_THUNK(900)
IMPL_THUNK(901)
IMPL_THUNK(902)
IMPL_THUNK(903)
IMPL_THUNK(904)
IMPL_THUNK(905)
IMPL_THUNK(906)
IMPL_THUNK(907)
IMPL_THUNK(908)
IMPL_THUNK(909)
IMPL_THUNK(910)
IMPL_THUNK(911)
IMPL_THUNK(912)
IMPL_THUNK(913)
IMPL_THUNK(914)
IMPL_THUNK(915)
IMPL_THUNK(916)
IMPL_THUNK(917)
IMPL_THUNK(918)
IMPL_THUNK(919)
IMPL_THUNK(920)
IMPL_THUNK(921)
IMPL_THUNK(922)
IMPL_THUNK(923)
IMPL_THUNK(924)
IMPL_THUNK(925)
IMPL_THUNK(926)
IMPL_THUNK(927)
IMPL_THUNK(928)
IMPL_THUNK(929)
IMPL_THUNK(930)
IMPL_THUNK(931)
IMPL_THUNK(932)
IMPL_THUNK(933)
IMPL_THUNK(934)
IMPL_THUNK(935)
IMPL_THUNK(936)
IMPL_THUNK(937)
IMPL_THUNK(938)
IMPL_THUNK(939)
IMPL_THUNK(940)
IMPL_THUNK(941)
IMPL_THUNK(942)
IMPL_THUNK(943)
IMPL_THUNK(944)
IMPL_THUNK(945)
IMPL_THUNK(946)
IMPL_THUNK(947)
IMPL_THUNK(948)
IMPL_THUNK(949)
IMPL_THUNK(950)
IMPL_THUNK(951)
IMPL_THUNK(952)
IMPL_THUNK(953)
IMPL_THUNK(954)
IMPL_THUNK(955)
IMPL_THUNK(956)
IMPL_THUNK(957)
IMPL_THUNK(958)
IMPL_THUNK(959)
IMPL_THUNK(960)
IMPL_THUNK(961)
IMPL_THUNK(962)
IMPL_THUNK(963)
IMPL_THUNK(964)
IMPL_THUNK(965)
IMPL_THUNK(966)
IMPL_THUNK(967)
IMPL_THUNK(968)
IMPL_THUNK(969)
IMPL_THUNK(970)
IMPL_THUNK(971)
IMPL_THUNK(972)
IMPL_THUNK(973)
IMPL_THUNK(974)
IMPL_THUNK(975)
IMPL_THUNK(976)
IMPL_THUNK(977)
IMPL_THUNK(978)
IMPL_THUNK(979)
IMPL_THUNK(980)
IMPL_THUNK(981)
IMPL_THUNK(982)
IMPL_THUNK(983)
IMPL_THUNK(984)
IMPL_THUNK(985)
IMPL_THUNK(986)
IMPL_THUNK(987)
IMPL_THUNK(988)
IMPL_THUNK(989)
IMPL_THUNK(990)
IMPL_THUNK(991)
IMPL_THUNK(992)
IMPL_THUNK(993)
IMPL_THUNK(994)
IMPL_THUNK(995)
IMPL_THUNK(996)
IMPL_THUNK(997)
IMPL_THUNK(998)
IMPL_THUNK(999)
IMPL_THUNK(1000)
IMPL_THUNK(1001)
IMPL_THUNK(1002)
IMPL_THUNK(1003)
IMPL_THUNK(1004)
IMPL_THUNK(1005)
IMPL_THUNK(1006)
IMPL_THUNK(1007)
IMPL_THUNK(1008)
IMPL_THUNK(1009)
IMPL_THUNK(1010)
IMPL_THUNK(1011)
IMPL_THUNK(1012)
IMPL_THUNK(1013)
IMPL_THUNK(1014)
IMPL_THUNK(1015)
IMPL_THUNK(1016)
IMPL_THUNK(1017)
IMPL_THUNK(1018)
IMPL_THUNK(1019)
IMPL_THUNK(1020)
IMPL_THUNK(1021)
IMPL_THUNK(1022)
IMPL_THUNK(1023)
IMPL_THUNK(1024)

#endif

__declspec(selectany) GUID CComModule::m_libid = {0x0,0x0,0x0,{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0}};

#ifdef _ATL_STATIC_REGISTRY
#define UpdateRegistryFromResource UpdateRegistryFromResourceS
#else
#define UpdateRegistryFromResource UpdateRegistryFromResourceD
#endif

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling classes

class _AtlAptCreateObjData
{
public:
        _ATL_CREATORFUNC* pfnCreateInstance;
        const IID* piid;
        HANDLE hEvent;
        LPSTREAM pStream;
        HRESULT hRes;
};

class CComApartment
{
public:
        CComApartment()
        {
                m_nLockCnt = 0;
        }
        static UINT ATL_CREATE_OBJECT;
        static DWORD WINAPI _Apartment(void* pv)
        {
                return ((CComApartment*)pv)->Apartment();
        }
        DWORD Apartment()
        {
                CoInitialize(NULL);
                MSG msg;
                while(GetMessage(&msg, 0, 0, 0))
                {
                        if (msg.message == ATL_CREATE_OBJECT)
                        {
                                _AtlAptCreateObjData* pdata = (_AtlAptCreateObjData*)msg.lParam;
                                IUnknown* pUnk = NULL;
                                pdata->hRes = pdata->pfnCreateInstance(NULL, IID_IUnknown, (void**)&pUnk);
                                if (SUCCEEDED(pdata->hRes))
                                        pdata->hRes = CoMarshalInterThreadInterfaceInStream(*pdata->piid, pUnk, &pdata->pStream);
                                if (SUCCEEDED(pdata->hRes))
                                {
                                        pUnk->Release();
                                        ATLTRACE2(atlTraceCOM, 2, _T("Object created on thread = %d\n"), GetCurrentThreadId());
                                }
                                SetEvent(pdata->hEvent);
                        }
                        DispatchMessage(&msg);
                }
                CoUninitialize();
                return 0;
        }
        LONG Lock() {return CComGlobalsThreadModel::Increment(&m_nLockCnt);}
        LONG Unlock(){return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
        }
        LONG GetLockCount() {return m_nLockCnt;}

        DWORD m_dwThreadID;
        HANDLE m_hThread;
        LONG m_nLockCnt;
};

__declspec(selectany) UINT CComApartment::ATL_CREATE_OBJECT = 0;

class CComSimpleThreadAllocator
{
public:
        CComSimpleThreadAllocator()
        {
                m_nThread = 0;
        }
        int GetThread(CComApartment* /*pApt*/, int nThreads)
        {
                if (++m_nThread == nThreads)
                        m_nThread = 0;
                return m_nThread;
        }
        int m_nThread;
};

template <class ThreadAllocator = CComSimpleThreadAllocator>
class CComAutoThreadModule : public CComModule
{
public:
        HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL, int nThreads = GetDefaultThreads());
        ~CComAutoThreadModule();
        HRESULT CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj);
        LONG Lock();
        LONG Unlock();
        DWORD dwThreadID;
        int m_nThreads;
        CComApartment* m_pApartments;
        ThreadAllocator m_Allocator;
        static int GetDefaultThreads()
        {
                SYSTEM_INFO si;
                GetSystemInfo(&si);
                return si.dwNumberOfProcessors * 4;
        }
};

/////////////////////////////////////////////////////////////////////////////
// CComBSTR

class CComBSTR
{
public:
        BSTR m_str;
        CComBSTR()
        {
                m_str = NULL;
        }
        /*explicit*/ CComBSTR(int nSize)
        {
                m_str = ::SysAllocStringLen(NULL, nSize);
        }
        /*explicit*/ CComBSTR(int nSize, LPCOLESTR sz)
        {
                m_str = ::SysAllocStringLen(sz, nSize);
        }
        /*explicit*/ CComBSTR(LPCOLESTR pSrc)
        {
                m_str = ::SysAllocString(pSrc);
        }
        /*explicit*/ CComBSTR(const CComBSTR& src)
        {
                m_str = src.Copy();
        }
        /*explicit*/ CComBSTR(const BSTR* psrc)
        {
            if (!psrc) {
                m_str = NULL;
            } else {
			    m_str = ::SysAllocStringByteLen(reinterpret_cast<LPCSTR>(*psrc), ::SysStringByteLen(*psrc));
            }
        }
        /*explicit*/ CComBSTR(REFGUID src)
        {
                LPOLESTR szGuid;
                StringFromCLSID(src, &szGuid);
                m_str = ::SysAllocString(szGuid);
                CoTaskMemFree(szGuid);
        }
        CComBSTR& operator=(const CComBSTR& src)
        {
                if (m_str != src.m_str)
                {
                        if (m_str)
                                ::SysFreeString(m_str);
                        m_str = src.Copy();
                }
                return *this;
        }
        CComBSTR& operator=(const BSTR* psrc)
        {
            if (!psrc) {
                if (m_str)
                        ::SysFreeString(m_str);
                m_str = NULL;
            } else if (*psrc != m_str) {
                if (m_str)
                        ::SysFreeString(m_str);
			    m_str = ::SysAllocStringByteLen(reinterpret_cast<LPCSTR>(*psrc), ::SysStringByteLen(*psrc));
            }
			return *this;
        }

        CComBSTR& operator=(LPCOLESTR pSrc)
        {
                ::SysFreeString(m_str);
                m_str = ::SysAllocString(pSrc);
                return *this;
        }

        ~CComBSTR()
        {
                ::SysFreeString(m_str);
        }
        unsigned int Length() const
        {
                return (m_str == NULL)? 0 : SysStringLen(m_str);
        }
        operator BSTR() const
        {
                return m_str;
        }
        BSTR* operator&()
        {
                return &m_str;
        }
        BSTR Copy() const
        {
                return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
        }
        HRESULT CopyTo(BSTR* pbstr)
        {
                // there should either be a runtime check or an assert(not both).  otherwise
                // we can't depend on the runtime check during unattended api tests and have to
                // place a redundant extra check outside the call to CopyTo to keep assert
                // dialogs from popping up
                // ATLASSERT(pbstr != NULL);
                if (pbstr == NULL)
                        return E_POINTER;
                *pbstr = ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
                if (*pbstr == NULL)
                        return E_OUTOFMEMORY;
                return S_OK;
        }
        void Attach(BSTR src)
        {
                ATLASSERT(m_str == NULL);
                m_str = src;
        }
        BSTR Detach()
        {
                BSTR s = m_str;
                m_str = NULL;
                return s;
        }
        void Empty()
        {
                ::SysFreeString(m_str);
                m_str = NULL;
        }
        bool operator!() const
        {
                return (m_str == NULL);
        }
        HRESULT Append(const CComBSTR& bstrSrc)
        {
                return Append(bstrSrc.m_str, SysStringLen(bstrSrc.m_str));
        }
        HRESULT Append(LPCOLESTR lpsz)
        {
                return Append(lpsz, ocslen(lpsz));
        }
        // a BSTR is just a LPCOLESTR so we need a special version to signify
        // that we are appending a BSTR
        HRESULT AppendBSTR(BSTR p)
        {
                return Append(p, SysStringLen(p));
        }
        HRESULT Append(LPCOLESTR lpsz, int nLen)
        {
                int n1 = Length();
                BSTR b;
                b = ::SysAllocStringLen(NULL, n1+nLen);
                if (b == NULL)
                        return E_OUTOFMEMORY;
                memcpy(b, m_str, n1*sizeof(OLECHAR));
                memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR));
                b[n1+nLen] = NULL;
                SysFreeString(m_str);
                m_str = b;
                return S_OK;
        }
        HRESULT ToLower()
        {
                USES_CONVERSION;
                if (m_str != NULL)
                {
                        LPTSTR psz = CharLower(OLE2T(m_str));
                        if (psz == NULL)
                                return E_OUTOFMEMORY;
                        BSTR b = T2BSTR(psz);
                        if (psz == NULL)
                                return E_OUTOFMEMORY;
                        SysFreeString(m_str);
                        m_str = b;
                }
                return S_OK;
        }
        HRESULT ToUpper()
        {
                USES_CONVERSION;
                if (m_str != NULL)
                {
                        LPTSTR psz = CharUpper(OLE2T(m_str));
                        if (psz == NULL)
                                return E_OUTOFMEMORY;
                        BSTR b = T2BSTR(psz);
                        if (psz == NULL)
                                return E_OUTOFMEMORY;
                        SysFreeString(m_str);
                        m_str = b;
                }
                return S_OK;
        }
        bool LoadString(HINSTANCE hInst, UINT nID)
        {
                USES_CONVERSION;
                TCHAR sz[512];
                UINT nLen = ::LoadString(hInst, nID, sz, 512);
                ATLASSERT(nLen < 511);
                SysFreeString(m_str);
                m_str = (nLen != 0) ? SysAllocString(T2OLE(sz)) : NULL;
                return (nLen != 0);
        }
        bool LoadString(UINT nID)
        {
                return LoadString(_pModule->m_hInstResource, nID);
        }

        CComBSTR& operator+=(const CComBSTR& bstrSrc)
        {
                AppendBSTR(bstrSrc.m_str);
                return *this;
        }
        bool operator<(BSTR bstrSrc) const
        {
                if (bstrSrc == NULL && m_str == NULL)
                        return false;
                if (bstrSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, bstrSrc) < 0;
                return m_str == NULL;
        }
        bool operator==(BSTR bstrSrc) const
        {
                if (bstrSrc == NULL && m_str == NULL)
                        return true;
                if (bstrSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, bstrSrc) == 0;
                return false;
        }
        bool operator<(LPCSTR pszSrc) const
        {
                if (pszSrc == NULL && m_str == NULL)
                        return false;
                USES_CONVERSION;
                if (pszSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, A2W(pszSrc)) < 0;
                return m_str == NULL;
        }
        bool operator==(LPCSTR pszSrc) const
        {
                if (pszSrc == NULL && m_str == NULL)
                        return true;
                USES_CONVERSION;
                if (pszSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, A2W(pszSrc)) == 0;
                return false;
        }
#ifndef OLE2ANSI
        CComBSTR(LPCSTR pSrc)
        {
                m_str = A2WBSTR(pSrc);
        }

        CComBSTR(int nSize, LPCSTR sz)
        {
                m_str = A2WBSTR(sz, nSize);
        }

        void Append(LPCSTR lpsz)
        {
                USES_CONVERSION;
                LPCOLESTR lpo = A2COLE(lpsz);
                Append(lpo, ocslen(lpo));
        }

        CComBSTR& operator=(LPCSTR pSrc)
        {
                ::SysFreeString(m_str);
                m_str = A2WBSTR(pSrc);
                return *this;
        }
#endif
        HRESULT WriteToStream(IStream* pStream)
        {
                ATLASSERT(pStream != NULL);
                ULONG cb;
                ULONG cbStrLen = m_str ? SysStringByteLen(m_str)+sizeof(OLECHAR) : 0;
                HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
                if (FAILED(hr))
                        return hr;
                return cbStrLen ? pStream->Write((void*) m_str, cbStrLen, &cb) : S_OK;
        }
        HRESULT ReadFromStream(IStream* pStream)
        {
                ATLASSERT(pStream != NULL);
                ATLASSERT(m_str == NULL); // should be empty
                ULONG cbStrLen = 0;
                HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), NULL);
                if ((hr == S_OK) && (cbStrLen != 0))
                {
                        //subtract size for terminating NULL which we wrote out
                        //since SysAllocStringByteLen overallocates for the NULL
                        m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
                        if (m_str == NULL)
                                hr = E_OUTOFMEMORY;
                        else
                                hr = pStream->Read((void*) m_str, cbStrLen, NULL);
                }
                if (hr == S_FALSE)
                        hr = E_FAIL;
                return hr;
        }
                // this allows direct use in stl containers
                // without using the CAdapt template which causes extra addrefs/releases
                //  usage:
                // std::vector<CComBSTR, CComBSTR::stl_allocator>
        CComBSTR * address(void) { return this; }
        const CComBSTR * const_address(void) const { return this; }
                typedef stl_smart_ptr_allocator<CComBSTR> stl_allocator;
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
// Constructors
public:
        CComVariant()
        {
            // ideally, we'd use ::VariantInit() here.  but, it doesn't do anything but
            // set the tag to VT_EMPTY.  we must zero out the struct, otherwise there
            // are cases where we set the tag to something non-empty in order to specify the
            // right type to read from a property bag and if there's an error we autodestruct
            // going out of scope and end up calling ::VariantClear with garbage which causes
            // random crashes
            memset(this, 0, sizeof(*this));  // safe since we're a pods
            vt = VT_EMPTY;
        }
        ~CComVariant()
        {
                Clear();
        }

        CComVariant(const VARIANT& varSrc)
        {
                vt = VT_EMPTY;
                InternalCopy(&varSrc);
        }

        CComVariant(const CComVariant& varSrc)
        {
                vt = VT_EMPTY;
                InternalCopy(&varSrc);
        }

        CComVariant(BSTR bstrSrc)
        {
                vt = VT_EMPTY;
                *this = bstrSrc;
        }
        CComVariant(LPCOLESTR lpszSrc)
        {
                vt = VT_EMPTY;
                *this = lpszSrc;
        }

#ifndef OLE2ANSI
        CComVariant(LPCSTR lpszSrc)
        {
                vt = VT_EMPTY;
                *this = lpszSrc;
        }
#endif

        CComVariant(bool bSrc)
        {
                vt = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
                boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
        }

        CComVariant(int nSrc)
        {
                vt = VT_I4;
                lVal = nSrc;
        }
        CComVariant(BYTE nSrc)
        {
                vt = VT_UI1;
                bVal = nSrc;
        }
        CComVariant(short nSrc)
        {
                vt = VT_I2;
                iVal = nSrc;
        }
        CComVariant(long nSrc, VARTYPE vtSrc = VT_I4)
        {
                ATLASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR);
                vt = vtSrc;
                lVal = nSrc;
        }
        CComVariant(float fltSrc)
        {
                vt = VT_R4;
                fltVal = fltSrc;
        }
        CComVariant(double dblSrc)
        {
                vt = VT_R8;
                dblVal = dblSrc;
        }
        CComVariant(CY cySrc)
        {
                vt = VT_CY;
                cyVal.Hi = cySrc.Hi;
                cyVal.Lo = cySrc.Lo;
        }
        CComVariant(IDispatch* pSrc)
        {
                vt = VT_DISPATCH;
                pdispVal = pSrc;
                // Need to AddRef as VariantClear will Release
                if (pdispVal != NULL)
                        pdispVal->AddRef();
        }
        CComVariant(IUnknown* pSrc)
        {
                vt = VT_UNKNOWN;
                punkVal = pSrc;
                // Need to AddRef as VariantClear will Release
                if (punkVal != NULL)
                        punkVal->AddRef();
        }

        CComVariant(SHORT* pSrc)
        {
                vt = VT_I2 | VT_BYREF;
                piVal = pSrc;
        }

// Assignment Operators
public:
        CComVariant& operator=(const CComVariant& varSrc)
        {
                InternalCopy(&varSrc);
                return *this;
        }
        CComVariant& operator=(const VARIANT& varSrc)
        {
                InternalCopy(&varSrc);
                return *this;
        }

        CComVariant& operator=(BSTR bstrSrc)
        {
                InternalClear();
                vt = VT_BSTR;
                bstrVal = ::SysAllocString(bstrSrc);
                if (bstrVal == NULL && bstrSrc != NULL)
                {
                        vt = VT_ERROR;
                        scode = E_OUTOFMEMORY;
                }
                return *this;
        }

        CComVariant& operator=(LPCOLESTR lpszSrc)
        {
                InternalClear();
                vt = VT_BSTR;
                bstrVal = ::SysAllocString(lpszSrc);

                if (bstrVal == NULL && lpszSrc != NULL)
                {
                        vt = VT_ERROR;
                        scode = E_OUTOFMEMORY;
                }
                return *this;
        }

        #ifndef OLE2ANSI
        CComVariant& operator=(LPCSTR lpszSrc)
        {
                USES_CONVERSION;
                InternalClear();
                vt = VT_BSTR;
                bstrVal = ::SysAllocString(A2COLE(lpszSrc));

                if (bstrVal == NULL && lpszSrc != NULL)
                {
                        vt = VT_ERROR;
                        scode = E_OUTOFMEMORY;
                }
                return *this;
        }
        #endif

        CComVariant& operator=(bool bSrc)
        {
                if (vt != VT_BOOL)
                {
                        InternalClear();
                        vt = VT_BOOL;
                }
        #pragma warning(disable: 4310) // cast truncates constant value
                boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
        #pragma warning(default: 4310) // cast truncates constant value
                return *this;
        }

        CComVariant& operator=(int nSrc)
        {
                if (vt != VT_I4)
                {
                        InternalClear();
                        vt = VT_I4;
                }
                lVal = nSrc;

                return *this;
        }

        CComVariant& operator=(BYTE nSrc)
        {
                if (vt != VT_UI1)
                {
                        InternalClear();
                        vt = VT_UI1;
                }
                bVal = nSrc;
                return *this;
        }

        CComVariant& operator=(short nSrc)
        {
                if (vt != VT_I2)
                {
                        InternalClear();
                        vt = VT_I2;
                }
                iVal = nSrc;
                return *this;
        }

        CComVariant& operator=(long nSrc)
        {
                if (vt != VT_I4)
                {
                        InternalClear();
                        vt = VT_I4;
                }
                lVal = nSrc;
                return *this;
        }

        CComVariant& operator=(float fltSrc)
        {
                if (vt != VT_R4)
                {
                        InternalClear();
                        vt = VT_R4;
                }
                fltVal = fltSrc;
                return *this;
        }

        CComVariant& operator=(double dblSrc)
        {
                if (vt != VT_R8)
                {
                        InternalClear();
                        vt = VT_R8;
                }
                dblVal = dblSrc;
                return *this;
        }

        CComVariant& operator=(CY cySrc)
        {
                if (vt != VT_CY)
                {
                        InternalClear();
                        vt = VT_CY;
                }
                cyVal.Hi = cySrc.Hi;
                cyVal.Lo = cySrc.Lo;
                return *this;
        }

        CComVariant& operator=(IDispatch* pSrc)
        {
                InternalClear();
                vt = VT_DISPATCH;
                pdispVal = pSrc;
                // Need to AddRef as VariantClear will Release
                if (pdispVal != NULL)
                        pdispVal->AddRef();
                return *this;
        }

        CComVariant& operator=(IUnknown* pSrc)
        {
                InternalClear();
                vt = VT_UNKNOWN;
                punkVal = pSrc;

                // Need to AddRef as VariantClear will Release
                if (punkVal != NULL)
                        punkVal->AddRef();
                return *this;
        }

        CComVariant& operator=(SHORT* pSrc)
        {
                vt = VT_I2 | VT_BYREF;
                piVal = pSrc;
				return *this;
        }

// Comparison Operators
public:
        bool operator==(const VARIANT& varSrc) const
        {
                if (this == &varSrc)
                        return true;

                // Variants not equal if types don't match
                if (vt != varSrc.vt)
                        return false;

                // Check type specific values
                switch (vt)
                {
                        case VT_EMPTY:
                        case VT_NULL:
                                return true;

                        case VT_BOOL:
                                return boolVal == varSrc.boolVal;

                        case VT_UI1:
                                return bVal == varSrc.bVal;

                        case VT_I2:
                                return iVal == varSrc.iVal;

                        case VT_I4:
                                return lVal == varSrc.lVal;

                        case VT_R4:
                                return fltVal == varSrc.fltVal;

                        case VT_R8:
                                return dblVal == varSrc.dblVal;

                        case VT_BSTR:
                                return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
                                                (::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

                        case VT_ERROR:
                                return scode == varSrc.scode;

                        case VT_DISPATCH:
                                return pdispVal == varSrc.pdispVal;

                        case VT_UNKNOWN:
                                return punkVal == varSrc.punkVal;

                        default:
                                ATLASSERT(false);
                                // fall through
                }

                return false;
        }
        bool operator!=(const VARIANT& varSrc) const {return !operator==(varSrc);}
        bool operator<(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT, 0)==VARCMP_LT;}
        bool operator>(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT, 0)==VARCMP_GT;}
        bool operator!() const {
            switch (vt)
            {
                case VT_EMPTY:
                case VT_NULL:
                    return true;
                case VT_BOOL:
                    return !boolVal;
                case VT_UI1:
                    return !bVal;
                case VT_I2:
                    return !iVal;
                case VT_I4:
                    return !lVal;
                case VT_R4:
                    return !fltVal;
                case VT_R8:
                    return !dblVal;
                case VT_BSTR:
                    return (bstrVal ? !::SysStringByteLen(bstrVal) : true);
                case VT_ERROR:
                    return scode != S_OK;
                case VT_DISPATCH:
                    return !pdispVal;
                case VT_UNKNOWN:
                    return !punkVal;
                default:
                    ATLASSERT(false);
                    // fall through
                    return true;
            }
        }

// Operations
public:
        HRESULT Clear() { return ::VariantClear(this); }
        HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); }
        HRESULT CopyTo(VARIANT* pDest) { return ::VariantCopy(pDest, this); }
        HRESULT Attach(VARIANT* pSrc)
        {
                // Clear out the variant
                HRESULT hr = Clear();
                if (!FAILED(hr))
                {
                        // Copy the contents and give control to CComVariant
                        memcpy(this, pSrc, sizeof(VARIANT));
                        pSrc->vt = VT_EMPTY;
                        hr = S_OK;
                }
                return hr;
        }

        HRESULT Detach(VARIANT* pDest)
        {
                // Clear out the variant
                HRESULT hr = ::VariantClear(pDest);
                if (!FAILED(hr))
                {
                        // Copy the contents and remove control from CComVariant
                        memcpy(pDest, this, sizeof(VARIANT));
                        vt = VT_EMPTY;
                        hr = S_OK;
                }
                return hr;
        }

        HRESULT ChangeType(VARTYPE vtNew, const VARIANT* pSrc = NULL)
        {
                VARIANT* pVar = const_cast<VARIANT*>(pSrc);
                // Convert in place if pSrc is NULL
                if (pVar == NULL)
                        pVar = this;
                // Do nothing if doing in place convert and vts not different
                return ::VariantChangeType(this, pVar, 0, vtNew);
        }

        HRESULT WriteToStream(IStream* pStream);
        HRESULT ReadFromStream(IStream* pStream);

// Implementation
public:
        HRESULT InternalClear()
        {
                HRESULT hr = Clear();
                ATLASSERT(SUCCEEDED(hr));
                if (FAILED(hr))
                {
                        vt = VT_ERROR;
                        scode = hr;
                }
                return hr;
        }

        void InternalCopy(const VARIANT* pSrc)
        {
                HRESULT hr = Copy(pSrc);
                if (FAILED(hr))
                {
                        vt = VT_ERROR;
                        scode = hr;
                }
        }

                // this allows direct use in stl containers
                // without using the CAdapt template which causes extra addrefs/releases
                //  usage:
                // std::vector<CComVariant, CComVariant::stl_allocator>
        CComVariant * address(void) { return this; }
        const CComVariant * const_address(void) const { return this; }
                typedef stl_smart_ptr_allocator<CComVariant> stl_allocator;

};

inline HRESULT CComVariant::WriteToStream(IStream* pStream)
{
        HRESULT hr = pStream->Write(&vt, sizeof(VARTYPE), NULL);
        if (FAILED(hr))
                return hr;

        int cbWrite = 0;
        switch (vt)
        {
        case VT_UNKNOWN:
        case VT_DISPATCH:
                {
                        CComPtr<IPersistStream> spStream;
                        if (punkVal != NULL)
                        {
                                hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
                                if (FAILED(hr))
                                        return hr;
                        }
                        if (spStream != NULL)
                                return OleSaveToStream(spStream, pStream);
                        else
                                return WriteClassStm(pStream, CLSID_NULL);
                }
        case VT_UI1:
        case VT_I1:
                cbWrite = sizeof(BYTE);
                break;
        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
                cbWrite = sizeof(short);
                break;
        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_INT:
        case VT_UINT:
        case VT_ERROR:
                cbWrite = sizeof(long);
                break;
        case VT_R8:
        case VT_CY:
        case VT_DATE:
                cbWrite = sizeof(double);
                break;
        default:
                break;
        }
        if (cbWrite != 0)
                return pStream->Write((void*) &bVal, cbWrite, NULL);

        CComBSTR bstrWrite;
        CComVariant varBSTR;
        if (vt != VT_BSTR)
        {
                hr = VariantChangeType(&varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR);
                if (FAILED(hr))
                        return hr;
                bstrWrite = varBSTR.bstrVal;
        }
        else
                bstrWrite = bstrVal;

        return bstrWrite.WriteToStream(pStream);
}

inline HRESULT CComVariant::ReadFromStream(IStream* pStream)
{
        ATLASSERT(pStream != NULL);
        HRESULT hr;
        hr = VariantClear(this);
        if (FAILED(hr))
                return hr;
        VARTYPE vtRead;
        hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
        if (hr == S_FALSE)
                hr = E_FAIL;
        if (FAILED(hr))
                return hr;

        vt = vtRead;
        int cbRead = 0;
        switch (vtRead)
        {
        case VT_UNKNOWN:
        case VT_DISPATCH:
                {
                        punkVal = NULL;
                        hr = OleLoadFromStream(pStream,
                                (vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,
                                (void**)&punkVal);
                        if (hr == REGDB_E_CLASSNOTREG)
                                hr = S_OK;
                        return S_OK;
                }
        case VT_UI1:
        case VT_I1:
                cbRead = sizeof(BYTE);
                break;
        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
                cbRead = sizeof(short);
                break;
        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_INT:
        case VT_UINT:
        case VT_ERROR:
                cbRead = sizeof(long);
                break;
        case VT_R8:
        case VT_CY:
        case VT_DATE:
                cbRead = sizeof(double);
                break;
        default:
                break;
        }
        if (cbRead != 0)
        {
                hr = pStream->Read((void*) &bVal, cbRead, NULL);
                if (hr == S_FALSE)
                        hr = E_FAIL;
                return hr;
        }
        CComBSTR bstrRead;

        hr = bstrRead.ReadFromStream(pStream);
        if (FAILED(hr))
                return hr;
        vt = VT_BSTR;
        bstrVal = bstrRead.Detach();
        if (vtRead != VT_BSTR)
                hr = ChangeType(vtRead);
        return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
        CRegKey();
        ~CRegKey();

// Attributes
public:
        operator HKEY() const;
        HKEY m_hKey;

// Operations
public:
        LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);
        LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
        LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount);
        LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

        LONG SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
        static LONG WINAPI SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName,
                LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

        LONG Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
                LPTSTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE,
                REGSAM samDesired = KEY_ALL_ACCESS,
                LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
                LPDWORD lpdwDisposition = NULL);
        LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
                REGSAM samDesired = KEY_ALL_ACCESS, DWORD ulOptions = 0);
        LONG Close();
        HKEY Detach();
        void Attach(HKEY hKey);
        LONG DeleteSubKey(LPCTSTR lpszSubKey);
        LONG RecurseDeleteKey(LPCTSTR lpszKey);
        LONG DeleteValue(LPCTSTR lpszValue);
};

inline CRegKey::CRegKey()
{m_hKey = NULL;}

inline CRegKey::~CRegKey()
{Close();}

inline CRegKey::operator HKEY() const
{return m_hKey;}

inline HKEY CRegKey::Detach()
{
        HKEY hKey = m_hKey;
        m_hKey = NULL;
        return hKey;
}

inline void CRegKey::Attach(HKEY hKey)
{
        ATLASSERT(m_hKey == NULL);
        m_hKey = hKey;
}

inline LONG CRegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
        ATLASSERT(m_hKey != NULL);
        return RegDeleteKey(m_hKey, lpszSubKey);
}

inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue)
{
        ATLASSERT(m_hKey != NULL);
        return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}

inline LONG CRegKey::Close()
{
        LONG lRes = ERROR_SUCCESS;
        if (m_hKey != NULL)
        {
                lRes = RegCloseKey(m_hKey);
                m_hKey = NULL;
        }
        return lRes;
}

inline LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
        LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
        ATLASSERT(hKeyParent != NULL);
        DWORD dw;
        HKEY hKey = NULL;
        LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
                lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
        if (lpdwDisposition != NULL)
                *lpdwDisposition = dw;
        if (lRes == ERROR_SUCCESS)
        {
                lRes = Close();
                m_hKey = hKey;
        }
        return lRes;
}

inline LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired, DWORD ulOptions)
{
        ATLASSERT(hKeyParent != NULL);
        HKEY hKey = NULL;
        LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, ulOptions, samDesired, &hKey);
        if (lRes == ERROR_SUCCESS)
        {
                lRes = Close();
                ATLASSERT(lRes == ERROR_SUCCESS);
                m_hKey = hKey;
        }
        return lRes;
}

inline LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
        DWORD dwType = NULL;
        DWORD dwCount = sizeof(DWORD);
        LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
                (LPBYTE)&dwValue, &dwCount);
        ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
        ATLASSERT((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
        return lRes;
}

inline LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
{
        ATLASSERT(pdwCount != NULL);
        DWORD dwType = NULL;
        LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
                (LPBYTE)szValue, pdwCount);
        ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
                         (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
        return lRes;
}

inline LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
        ATLASSERT(lpszValue != NULL);
        CRegKey key;
        LONG lRes = key.Create(hKeyParent, lpszKeyName);
        if (lRes == ERROR_SUCCESS)
                lRes = key.SetValue(lpszValue, lpszValueName);
        return lRes;
}

inline LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
        ATLASSERT(lpszValue != NULL);
        CRegKey key;
        LONG lRes = key.Create(m_hKey, lpszKeyName);
        if (lRes == ERROR_SUCCESS)
                lRes = key.SetValue(lpszValue, lpszValueName);
        return lRes;
}

inline LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
        ATLASSERT(m_hKey != NULL);
        return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
                (BYTE * const)&dwValue, sizeof(DWORD));
}

inline LONG CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
        ATLASSERT(lpszValue != NULL);
        ATLASSERT(m_hKey != NULL);
        return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
                (BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

inline LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
        CRegKey key;
        LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE);
        if (lRes != ERROR_SUCCESS)
                return lRes;
        FILETIME time;
        DWORD dwSize = 256;
        TCHAR szBuffer[256];
        while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
                &time)==ERROR_SUCCESS)
        {
                lRes = key.RecurseDeleteKey(szBuffer);
                if (lRes != ERROR_SUCCESS)
                        return lRes;
                dwSize = 256;
        }
        key.Close();
        return DeleteSubKey(lpszKey);
}

inline HRESULT CComModule::RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc)
{
        CRegKey keyProgID;
        LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID, REG_NONE, REG_OPTION_NON_VOLATILE,  KEY_SET_VALUE);
        if (lRes == ERROR_SUCCESS)
        {
                keyProgID.SetValue(lpszUserDesc);
                keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
                return S_OK;
        }
        return HRESULT_FROM_WIN32(lRes);
}

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>

// Statically linking to Registry Ponent
inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
        struct _ATL_REGMAP_ENTRY* pMapEntries)
{
        USES_CONVERSION;
        ATL::CRegObject ro;
        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);

		LPOLESTR pszModule;
		if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
		{
			// Convert to short path to work around bug in NT4's CreateProcess
			TCHAR szModuleShort[_MAX_PATH];
			int cbShortName = GetShortPathName(szModule, szModuleShort, _MAX_PATH);

			if (cbShortName == _MAX_PATH)
				return E_OUTOFMEMORY;

			pszModule = (cbShortName == 0 || cbShortName == ERROR_INVALID_PARAMETER) ? T2OLE(szModule) : T2OLE(szModuleShort);
		}
		else
			pszModule = T2OLE(szModule);

        int nLen = ocslen(pszModule);
        LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
        ReplaceSingleQuote(pszModuleQuote, pszModule);
        ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
        if (NULL != pMapEntries)
        {
                while (NULL != pMapEntries->szKey)
                {
                        ATLASSERT(NULL != pMapEntries->szData);
                        ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
                        pMapEntries++;
                }
        }

        LPCOLESTR szType = OLESTR("REGISTRY");
        return (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
                        ro.ResourceUnregister(pszModule, nResID, szType);
}

inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
        struct _ATL_REGMAP_ENTRY* pMapEntries)
{
        USES_CONVERSION;
        ATL::CRegObject ro;
        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);

		LPOLESTR pszModule;
		if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
		{
			// Convert to short path to work around bug in NT4's CreateProcess
			TCHAR szModuleShort[_MAX_PATH];
			int cbShortName = GetShortPathName(szModule, szModuleShort, _MAX_PATH);

			if (cbShortName == _MAX_PATH)
				return E_OUTOFMEMORY;

			pszModule = (cbShortName == 0 || cbShortName == ERROR_INVALID_PARAMETER) ? T2OLE(szModule) : T2OLE(szModuleShort);
		}
		else
			pszModule = T2OLE(szModule);

        int nLen = ocslen(pszModule);
        LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
        ReplaceSingleQuote(pszModuleQuote, pszModule);
        ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
        if (NULL != pMapEntries)
        {
                while (NULL != pMapEntries->szKey)
                {
                        ATLASSERT(NULL != pMapEntries->szData);
                        ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
                        pMapEntries++;
                }
        }

        LPCOLESTR szType = OLESTR("REGISTRY");
        LPCOLESTR pszRes = T2COLE(lpszRes);
        return (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) :
                        ro.ResourceUnregisterSz(pszModule, pszRes, szType);
}
#endif //_ATL_STATIC_REGISTRY

inline HRESULT WINAPI CComModule::UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
        LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister)
{
        if (bRegister)
        {
                return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, nDescID,
                        dwFlags);
        }
        else
                return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

inline HRESULT WINAPI CComModule::RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
        LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags)
{
        static const TCHAR szProgID[] = _T("ProgID");
        static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
        static const TCHAR szLS32[] = _T("LocalServer32");
        static const TCHAR szIPS32[] = _T("InprocServer32");
        static const TCHAR szThreadingModel[] = _T("ThreadingModel");
        static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
        static const TCHAR szApartment[] = _T("Apartment");
        static const TCHAR szBoth[] = _T("both");
        USES_CONVERSION;
        HRESULT hRes = S_OK;
        TCHAR szDesc[256];
        LoadString(m_hInst, nDescID, szDesc, 256);
        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(m_hInst, szModule, _MAX_PATH);

        LPOLESTR lpOleStr;
        StringFromCLSID(clsid, &lpOleStr);
        LPTSTR lpsz = OLE2T(lpOleStr);

        hRes = RegisterProgID(lpsz, lpszProgID, szDesc);
        if (hRes == S_OK)
                hRes = RegisterProgID(lpsz, lpszVerIndProgID, szDesc);
        LONG lRes = ERROR_SUCCESS;
        if (hRes == S_OK)
        {
			CRegKey key;
			lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ | KEY_WRITE);
			if (lRes == ERROR_SUCCESS)
			{
				lRes = key.Create(key, lpsz, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE);
				if (lRes == ERROR_SUCCESS)
				{
					key.SetValue(szDesc);
					key.SetKeyValue(szProgID, lpszProgID);
					key.SetKeyValue(szVIProgID, lpszVerIndProgID);

					if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
					{
						// Convert to short path to work around bug in NT4's CreateProcess
						TCHAR szModuleShort[_MAX_PATH];
						int cbShortName = GetShortPathName(szModule, szModuleShort, _MAX_PATH);
						TCHAR* pszModule;

						if (cbShortName == _MAX_PATH)
							return E_OUTOFMEMORY;

						pszModule = (cbShortName == 0 || cbShortName == ERROR_INVALID_PARAMETER) ? szModule : szModuleShort;

						key.SetKeyValue(szLS32, pszModule);
					}
					else
					{
						key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule);
						LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
							(dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
						if (lpszModel != NULL)
							key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
					}
				}
			}
        }
        CoTaskMemFree(lpOleStr);
        if (lRes != ERROR_SUCCESS)
                hRes = HRESULT_FROM_WIN32(lRes);
        return hRes;
}

inline HRESULT WINAPI CComModule::UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
        LPCTSTR lpszVerIndProgID)
{
        USES_CONVERSION;
        CRegKey key;

        key.Attach(HKEY_CLASSES_ROOT);
        if (lpszProgID != NULL && lstrcmpi(lpszProgID, _T("")))
                key.RecurseDeleteKey(lpszProgID);
        if (lpszVerIndProgID != NULL && lstrcmpi(lpszVerIndProgID, _T("")))
                key.RecurseDeleteKey(lpszVerIndProgID);
        LPOLESTR lpOleStr;
        StringFromCLSID(clsid, &lpOleStr);
        LPTSTR lpsz = OLE2T(lpOleStr);
		if (key.Open(key, _T("CLSID"), KEY_READ | KEY_WRITE) == ERROR_SUCCESS)
                key.RecurseDeleteKey(lpsz);
        CoTaskMemFree(lpOleStr);
        return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Large Block Allocation Helper - CVBufHelper & CVirtualBuffer


template <class T>
class CVBufHelper
{
public:
        virtual T* operator()(T* pCurrent) {return pCurrent;}
};

template <class T>
class CVirtualBuffer
{
protected:
        CVirtualBuffer() {}
        T* m_pBase;
        T* m_pCurrent;
        T* m_pTop;
        int m_nMaxElements;
public:
        CVirtualBuffer(int nMaxElements)
        {
                m_nMaxElements = nMaxElements;
                m_pBase = (T*) VirtualAlloc(NULL, sizeof(T) * nMaxElements,
                        MEM_RESERVE, PAGE_READWRITE);
                m_pTop = m_pCurrent = m_pBase;
                // Commit first page - chances are this is all that will be used
                VirtualAlloc(m_pBase, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
        }
        ~CVirtualBuffer()
        {
                VirtualFree(m_pBase, 0, MEM_RELEASE);
        }
        int Except(LPEXCEPTION_POINTERS lpEP)
        {
                EXCEPTION_RECORD* pExcept = lpEP->ExceptionRecord;
                if (pExcept->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
                        return EXCEPTION_CONTINUE_SEARCH;
                BYTE* pAddress = (LPBYTE) pExcept->ExceptionInformation[1];
				VirtualAlloc(pAddress, ((BYTE*)m_pTop - (BYTE*)m_pBase), MEM_COMMIT, PAGE_READWRITE);
                return EXCEPTION_CONTINUE_EXECUTION;
        }
        void Seek(int nElement)
        {
                m_pCurrent = &m_pBase[nElement];
        }
        void SetAt(int nElement, const T& Element)
        {
                __try
                {
                        T* p = &m_pBase[nElement]
                        *p = Element;
                        m_pTop = p > m_pTop ? p : m_pTop;
                }
                __except(Except(GetExceptionInformation()))
                {
                }

        }
        template <class Q>
        void WriteBulk(Q& helper)
        {
                __try
                {
                        m_pCurrent = helper(m_pBase);
                        m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
                }
                __except(Except(GetExceptionInformation()))
                {
                }
        }
        void Write(const T& Element)
        {
                __try
                {
                        *m_pCurrent = Element;
                        m_pCurrent++;
                        m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
                }
                __except(Except(GetExceptionInformation()))
                {
                }
        }
        T& Read()
        {
                return *m_pCurrent;
        }
        operator BSTR()
        {
                BSTR bstrTemp;
                __try
                {
                        bstrTemp = SysAllocStringByteLen((char*) m_pBase,
                                (UINT) ((BYTE*)m_pTop - (BYTE*)m_pBase));
                }
                __except(Except(GetExceptionInformation()))
                {
                }
                return bstrTemp;
        }
        const T& operator[](int nElement) const
        {
                return m_pBase[nElement];
        }
        operator T*()
        {
                return m_pBase;
        }
};

typedef CVirtualBuffer<BYTE> CVirtualBytes;


inline HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr)
{
        if (atlTraceQI & ATL_TRACE_CATEGORY)
        {
                USES_CONVERSION;
                CRegKey key;
                TCHAR szName[100];
                DWORD dwType,dw = sizeof(szName);

                LPOLESTR pszGUID = NULL;
                StringFromCLSID(iid, &pszGUID);
                OutputDebugString(pszClassName);
                OutputDebugString(_T(" - "));

                // Attempt to find it in the interfaces section
                key.Open(HKEY_CLASSES_ROOT, _T("Interface"), KEY_READ);
                if (key.Open(key, OLE2T(pszGUID), KEY_READ) == S_OK)
                {
                        *szName = 0;
                        RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
                        OutputDebugString(szName);
                        goto cleanup;
                }
                // Attempt to find it in the clsid section
                key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ);
                if (key.Open(key, OLE2T(pszGUID), KEY_READ) == S_OK)
                {
                        *szName = 0;
                        RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
                        OutputDebugString(_T("(CLSID\?\?\?) "));
                        OutputDebugString(szName);
                        goto cleanup;
                }
                OutputDebugString(OLE2T(pszGUID));
        cleanup:
                if (hr != S_OK)
                        OutputDebugString(_T(" - failed"));
                OutputDebugString(_T("\n"));
                CoTaskMemFree(pszGUID);
        }
        return hr;
}

#pragma pack(pop)

// WM_FORWARDMSG - used to forward a message to another window for processing
// WPARAM - DWORD dwUserData - defined by user
// LPARAM - LPMSG pMsg - a pointer to the MSG structure
// return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG       0x037F

}; //namespace ATL
using namespace ATL;

//only pull in definition if static linking
#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLBASE_IMPL
#endif
#endif

#ifdef _ATL_REDEF_NEW
#pragma pop_macro("new")
#undef _ATL_REDEF_NEW
#endif

#endif // __ATLBASE_H__

//All exports go here
#ifdef _ATLBASE_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName)
{
        ATLASSERT(lpszPathName != NULL);

        // always capture the complete file name including extension (if present)
        LPCOLESTR lpszTemp = lpszPathName;
        for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )
        {
                LPCOLESTR lp = CharNextO(lpsz);
                // remember last directory/drive separator
                if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
                        lpszTemp = lp;
                lpsz = lp;
        }

		return UINT(lpszTemp-lpszPathName);
}

/////////////////////////////////////////////////////////////////////////////
// QI support

ATLINLINE ATLAPI AtlInternalQueryInterface(void* pThis,
        const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
        ATLASSERT(pThis != NULL);
        // First entry in the com map should be a simple map entry
        ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
        if (ppvObject == NULL)
                return E_POINTER;
        *ppvObject = NULL;
        if (InlineIsEqualUnknown(iid)) // use first interface
        {
						IUnknown* pUnk = (IUnknown*)((DWORD_PTR)pThis+pEntries->dw);
                        pUnk->AddRef();
                        *ppvObject = pUnk;
                        return S_OK;
        }
        while (pEntries->pFunc != NULL)
        {
                BOOL bBlind = (pEntries->piid == NULL);
                if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
                {
                        if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset
                        {
                                ATLASSERT(!bBlind);
								IUnknown* pUnk = (IUnknown*)((DWORD_PTR)pThis+pEntries->dw);
                                pUnk->AddRef();
                                *ppvObject = pUnk;
                                return S_OK;
                        }
                        else //actual function call
                        {
                                HRESULT hRes = pEntries->pFunc(pThis,
                                        iid, ppvObject, pEntries->dw);
                                if (hRes == S_OK || (!bBlind && FAILED(hRes)))
                                        return hRes;
                        }
                }
                pEntries++;
        }
        return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLINLINE ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
        if (lp != NULL)
                lp->AddRef();
        if (*pp)
                (*pp)->Release();
        *pp = lp;
        return lp;
}

ATLINLINE ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
        IUnknown* pTemp = *pp;
        *pp = NULL;
        if (lp != NULL)
                lp->QueryInterface(riid, (void**)pp);
        if (pTemp)
                pTemp->Release();
        return *pp;
}

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

//This API should be called from the same thread that called
//AtlMarshalPtrInProc
ATLINLINE ATLAPI AtlFreeMarshalStream(IStream* pStream)
{
        if (pStream != NULL)
        {
                LARGE_INTEGER l;
                l.QuadPart = 0;
                pStream->Seek(l, STREAM_SEEK_SET, NULL);
                CoReleaseMarshalData(pStream);
                pStream->Release();
        }
        return S_OK;
}

ATLINLINE ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream)
{
        HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
        if (SUCCEEDED(hRes))
        {
                hRes = CoMarshalInterface(*ppStream, iid,
                        pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
                if (FAILED(hRes))
                {
                        (*ppStream)->Release();
                        *ppStream = NULL;
                }
        }
        return hRes;
}

ATLINLINE ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk)
{
        *ppUnk = NULL;
        HRESULT hRes = E_INVALIDARG;
        if (pStream != NULL)
        {
                LARGE_INTEGER l;
                l.QuadPart = 0;
                pStream->Seek(l, STREAM_SEEK_SET, NULL);
                hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
        }
        return hRes;
}

ATLINLINE ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent)
{
        DWORD dwRet;
        MSG msg;

        while(1)
        {
                dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE, INFINITE, QS_ALLINPUT);

                if (dwRet == WAIT_OBJECT_0)
                        return TRUE;    // The event was signaled

                if (dwRet != WAIT_OBJECT_0 + 1)
                        break;          // Something else happened

                // There is one or more window message available. Dispatch them
                while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
                {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                        if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
                                return TRUE; // Event is now signaled.
                }
        }
        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLINLINE ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
        CComPtr<IConnectionPointContainer> pCPC;
        CComPtr<IConnectionPoint> pCP;
        HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
        if (SUCCEEDED(hRes))
                hRes = pCPC->FindConnectionPoint(iid, &pCP);
        if (SUCCEEDED(hRes))
                hRes = pCP->Advise(pUnk, pdw);
        return hRes;
}

ATLINLINE ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
        CComPtr<IConnectionPointContainer> pCPC;
        CComPtr<IConnectionPoint> pCP;
        HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
        if (SUCCEEDED(hRes))
                hRes = pCPC->FindConnectionPoint(iid, &pCP);
        if (SUCCEEDED(hRes))
                hRes = pCP->Unadvise(dw);
        return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLINLINE ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
        LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
        USES_CONVERSION;
        TCHAR szDesc[1024];
        szDesc[0] = NULL;
        // For a valid HRESULT the id should be in the range [0x0200, 0xffff]
		if (IS_INTRESOURCE(lpszDesc)) //id
        {
				UINT nID = LOWORD((DWORD_PTR)lpszDesc);
                ATLASSERT((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
                if (LoadString(hInst, nID, szDesc, 1024) == 0)
                {
                    ATLASSERT(FALSE);
                    lstrcpy(szDesc, _T("Unknown Error"));
                    
           
                }
                lpszDesc = T2OLE(szDesc);
                if (hRes == 0)
                        hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
        }

        CComPtr<ICreateErrorInfo> pICEI;
        if (SUCCEEDED(CreateErrorInfo(&pICEI)))
        {
                CComPtr<IErrorInfo> pErrorInfo;
                pICEI->SetGUID(iid);
                LPOLESTR lpsz;
                ProgIDFromCLSID(clsid, &lpsz);
                if (lpsz != NULL)
                        pICEI->SetSource(lpsz);
                if (dwHelpID != 0 && lpszHelpFile != NULL)
                {
                        pICEI->SetHelpContext(dwHelpID);
                        pICEI->SetHelpFile(const_cast<LPOLESTR>(lpszHelpFile));
                }
                CoTaskMemFree(lpsz);
                pICEI->SetDescription((LPOLESTR)lpszDesc);
                if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
                        SetErrorInfo(0, pErrorInfo);
        }
        return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}

ATLINLINE ATLAPI AtlSetErrorInfo(const CLSID& clsid, HRESULT hr, const IID& iid, HRESULT hRes, HINSTANCE hInst, va_list *Arguments)
{
    // Mostly the same as the default AtlSetErrorInfo but this one loads strings from the module and allows arguments 
    // Arguments argument also allows for no ambiguity
        USES_CONVERSION;
        TCHAR szDesc[1024];
        szDesc[0] = NULL;
        // Attempt to load string from system
        if (LoadString(hInst, hr, szDesc, 1024) == 0){
            // If it is a no go try to load from the module
			if(FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, hInst, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) szDesc, 1023, Arguments) == 0){
				ATLASSERT(FALSE);
				lstrcpy(szDesc, _T("Unknown Error"));
            }
        }
        LPCOLESTR lpszDesc = T2OLE(szDesc);
        if (hRes == 0){
            hRes = hr;
        }

        CComPtr<ICreateErrorInfo> pICEI;
        if (SUCCEEDED(CreateErrorInfo(&pICEI)))
        {
                CComPtr<IErrorInfo> pErrorInfo;
                pICEI->SetGUID(iid);
                LPOLESTR lpsz;
                ProgIDFromCLSID(clsid, &lpsz);
                if (lpsz != NULL)
                        pICEI->SetSource(lpsz);
                CoTaskMemFree(lpsz);
                pICEI->SetDescription((LPOLESTR)lpszDesc);
                if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
                        SetErrorInfo(0, pErrorInfo);
        }
        return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}
/////////////////////////////////////////////////////////////////////////////
// Module

struct _ATL_MODULE20
{
// Attributes
public:
        UINT cbSize;
        HINSTANCE m_hInst;
        HINSTANCE m_hInstResource;
        HINSTANCE m_hInstTypeLib;
        _ATL_OBJMAP_ENTRY* m_pObjMap;
        LONG m_nLockCnt;
        HANDLE m_hHeap;
        CRITICAL_SECTION m_csTypeInfoHolder;
        CRITICAL_SECTION m_csWindowCreate;
        CRITICAL_SECTION m_csObjMap;
};

typedef _ATL_MODULE _ATL_MODULE30;

struct _ATL_OBJMAP_ENTRY20
{
        const CLSID* pclsid;
        HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
        _ATL_CREATORFUNC* pfnGetClassObject;
        _ATL_CREATORFUNC* pfnCreateInstance;
        IUnknown* pCF;
        DWORD dwRegister;
        _ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
};

typedef _ATL_OBJMAP_ENTRY _ATL_OBJMAP_ENTRY30;

inline _ATL_OBJMAP_ENTRY* _NextObjectMapEntry(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* pEntry)
{
        if (pM->cbSize == sizeof(_ATL_MODULE20))
                return (_ATL_OBJMAP_ENTRY*)(((BYTE*)pEntry) + sizeof(_ATL_OBJMAP_ENTRY20));
        return pEntry+1;
}

//Although these functions are big, they are only used once in a module
//so we should make them inline.

ATLINLINE ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
#ifdef _ATL_DLL_IMPL
	if ((pM->cbSize != _nAtlModuleVer21Size) && (pM->cbSize != _nAtlModuleVer30Size) &&
		(pM->cbSize != sizeof(_ATL_MODULE)))
		return E_INVALIDARG;
#else
        ATLASSERT(pM->cbSize == sizeof(_ATL_MODULE));
#endif
        pM->m_pObjMap = p;
        pM->m_hInst = pM->m_hInstTypeLib = pM->m_hInstResource = h;
        pM->m_nLockCnt=0L;
        pM->m_hHeap = NULL;
        InitializeCriticalSection(&pM->m_csTypeInfoHolder);
        InitializeCriticalSection(&pM->m_csWindowCreate);
        InitializeCriticalSection(&pM->m_csObjMap);
#ifdef _ATL_DLL_IMPL
	if (pM->cbSize > _nAtlModuleVer21Size)
#endif
        {
            pM->m_pCreateWndList = NULL;
            pM->m_bDestroyHeap = true;
            pM->m_dwHeaps = 0;
            pM->m_nHeap = 0;
            pM->m_phHeaps = NULL;
            pM->m_pTermFuncs = NULL;
            if (pM->m_pObjMap != NULL)
            {
                    _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
                    while (pEntry->pclsid != NULL)
                    {
                            pEntry->pfnObjectMain(true); //initialize class resources
                            pEntry = _NextObjectMapEntry(pM, pEntry);
                    }
            }
        }

#ifdef _ATL_DLL_IMPL
	if (pM->cbSize > _nAtlModuleVer30Size)
#endif
	{
		pM->m_nNextWindowID = 1;
	}

        return S_OK;
}

ATLINLINE ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        while (pEntry->pclsid != NULL && hRes == S_OK)
        {
                hRes = pEntry->RegisterClassObject(dwClsContext, dwFlags);
                pEntry = _NextObjectMapEntry(pM, pEntry);
        }
        return hRes;
}

ATLINLINE ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        while (pEntry->pclsid != NULL && hRes == S_OK)
        {
                hRes = pEntry->RevokeClassObject();
                pEntry = _NextObjectMapEntry(pM, pEntry);
        }
        return hRes;
}

ATLINLINE ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        if (ppv == NULL)
                return E_POINTER;
        *ppv = NULL;
        while (pEntry->pclsid != NULL)
        {
                if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))
                {
                        if (pEntry->pCF == NULL)
                        {
                                EnterCriticalSection(&pM->m_csObjMap);
                                if (pEntry->pCF == NULL)
                                        hRes = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, IID_IUnknown, (LPVOID*)&pEntry->pCF);
                                LeaveCriticalSection(&pM->m_csObjMap);
                        }
                        if (pEntry->pCF != NULL)
                                hRes = pEntry->pCF->QueryInterface(riid, ppv);
                        break;
                }
                pEntry = _NextObjectMapEntry(pM, pEntry);
        }
        if (*ppv == NULL && hRes == S_OK)
                hRes = CLASS_E_CLASSNOTAVAILABLE;
        return hRes;
}

ATLINLINE ATLAPI AtlModuleTerm(_ATL_MODULE* pM)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_hInst != NULL);
        if (pM->m_pObjMap != NULL)
        {
                _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
                while (pEntry->pclsid != NULL)
                {
                        if (pEntry->pCF != NULL)
                                pEntry->pCF->Release();
                        pEntry->pCF = NULL;
#ifdef _ATL_DLL_IMPL
					if (pM->cbSize > _nAtlModuleVer21Size)
#endif
                                pEntry->pfnObjectMain(false); //cleanup class resources
                        pEntry = _NextObjectMapEntry(pM, pEntry);
                }
        }
        DeleteCriticalSection(&pM->m_csTypeInfoHolder);
        DeleteCriticalSection(&pM->m_csWindowCreate);
        DeleteCriticalSection(&pM->m_csObjMap);

#ifdef _ATL_DLL_IMPL
		if (pM->cbSize > _nAtlModuleVer21Size)
#endif
        {
                _ATL_TERMFUNC_ELEM* pElem = pM->m_pTermFuncs;
                _ATL_TERMFUNC_ELEM* pNext = NULL;
                while (pElem != NULL)
                {
                        pElem->pFunc(pElem->dw);
                        pNext = pElem->pNext;
                        delete pElem;
                        pElem = pNext;
                }
                if (pM->m_hHeap != NULL && pM->m_bDestroyHeap)
                {
#ifndef _ATL_NO_MP_HEAP
                        if (pM->m_phHeaps != NULL)
                        {
                                for (DWORD i = 0; i <= pM->m_dwHeaps; i++)
                                        HeapDestroy(pM->m_phHeaps[i]);
                        }
#endif
                        HeapDestroy(pM->m_hHeap);
                }
        }
        return S_OK;
}

ATLINLINE ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD_PTR dw)
{
        HRESULT hr = S_OK;
        _ATL_TERMFUNC_ELEM* pNew = NULL;
        ATLTRY(pNew = new _ATL_TERMFUNC_ELEM);
        if (pNew == NULL)
                hr = E_OUTOFMEMORY;
        else
        {
                pNew->pFunc = pFunc;
                pNew->dw = dw;
                EnterCriticalSection(&pM->m_csStaticDataInit);
                pNew->pNext = pM->m_pTermFuncs;
                pM->m_pTermFuncs = pNew;
                LeaveCriticalSection(&pM->m_csStaticDataInit);
        }
        return hr;
}

ATLINLINE ATLAPI AtlRegisterClassCategoriesHelper( REFCLSID clsid,
   const struct _ATL_CATMAP_ENTRY* pCatMap, BOOL bRegister )
{
   CComPtr< ICatRegister > pCatRegister;
   HRESULT hResult;
   const struct _ATL_CATMAP_ENTRY* pEntry;
   CATID catid;

   if( pCatMap == NULL )
   {
          return( S_OK );
   }

   hResult = CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL,
          CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pCatRegister );
   if( FAILED( hResult ) )
   {
          // Since not all systems have the category manager installed, we'll allow
          // the registration to succeed even though we didn't register our
          // categories.  If you really want to register categories on a system
          // without the category manager, you can either manually add the
          // appropriate entries to your registry script (.rgs), or you can
          // redistribute comcat.dll.
          return( S_OK );
   }

   hResult = S_OK;
   pEntry = pCatMap;
   while( pEntry->iType != _ATL_CATMAP_ENTRY_END )
   {
          catid = *pEntry->pcatid;
          if( bRegister )
          {
                 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
                 {
                        hResult = pCatRegister->RegisterClassImplCategories( clsid, 1,
                           &catid );
                 }
                 else
                 {
                        ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
                        hResult = pCatRegister->RegisterClassReqCategories( clsid, 1,
                           &catid );
                 }
                 if( FAILED( hResult ) )
                 {
                        return( hResult );
                 }
          }
          else
          {
                 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
                 {
                        pCatRegister->UnRegisterClassImplCategories( clsid, 1, &catid );
                 }
                 else
                 {
                        ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
                        pCatRegister->UnRegisterClassReqCategories( clsid, 1, &catid );
                 }
          }
          pEntry++;
   }

   return( S_OK );
}

ATLINLINE ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_hInst != NULL);
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
        {
                if (pCLSID == NULL)
                {
                        if (pEntry->pfnGetObjectDescription != NULL &&
                                pEntry->pfnGetObjectDescription() != NULL)
                                        continue;
                }
                else
                {
                        if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
                                continue;
                }
                hRes = pEntry->pfnUpdateRegistry(TRUE);
                if (FAILED(hRes))
                        break;
                if (pM->cbSize == sizeof(_ATL_MODULE))
                {
                        hRes = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
                                pEntry->pfnGetCategoryMap(), TRUE );
                        if (FAILED(hRes))
                                break;
                }
        }
        if (SUCCEEDED(hRes) && bRegTypeLib)
                hRes = AtlModuleRegisterTypeLib(pM, 0);
        return hRes;
}

ATLINLINE ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_hInst != NULL);
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
        {
                if (pCLSID == NULL)
                {
                        if (pEntry->pfnGetObjectDescription != NULL
                                && pEntry->pfnGetObjectDescription() != NULL)
                                continue;
                }
                else
                {
                        if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
                                continue;
                }
                pEntry->pfnUpdateRegistry(FALSE); //unregister
				if (pM->cbSize == sizeof(_ATL_MODULE) && pEntry->pfnGetCategoryMap != NULL)
					AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
							pEntry->pfnGetCategoryMap(), FALSE );
        }
        if (bUnRegTypeLib)
                AtlModuleUnRegisterTypeLib(pM, 0);
        return S_OK;
}

ATLINLINE ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID)
{
        return AtlModuleUnregisterServerEx(pM, FALSE, pCLSID);
}

ATLINLINE ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE* pM, LPCOLESTR lpszRes,
        BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg)
{
        USES_CONVERSION;
        ATLASSERT(pM != NULL);
        HRESULT hRes = S_OK;
        CComPtr<IRegistrar> p;
        if (pReg != NULL)
                p = pReg;
        else
        {
                hRes = CoCreateInstance(CLSID_Registrar, NULL,
                        CLSCTX_INPROC_SERVER, IID_IRegistrar, (void**)&p);
        }
        if (SUCCEEDED(hRes))
        {
                TCHAR szModule[_MAX_PATH];
                GetModuleFileName(pM->m_hInst, szModule, _MAX_PATH);

				LPOLESTR pszModule;
				if ((pM->m_hInst == NULL) || (pM->m_hInst == GetModuleHandle(NULL))) // register as EXE
				{
					// Convert to short path to work around bug in NT4's CreateProcess
					TCHAR szModuleShort[_MAX_PATH];
					int cbShortName = GetShortPathName(szModule, szModuleShort, _MAX_PATH);

					if (cbShortName == _MAX_PATH)
						return E_OUTOFMEMORY;

					pszModule = (cbShortName == 0 || cbShortName == ERROR_INVALID_PARAMETER) ? T2OLE(szModule) : T2OLE(szModuleShort);
				}
				else
					pszModule = T2OLE(szModule);


                int nLen = ocslen(pszModule);
                LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
                CComModule::ReplaceSingleQuote(pszModuleQuote, pszModule);
                p->AddReplacement(OLESTR("Module"), pszModuleQuote);

                if (NULL != pMapEntries)
                {
                        while (NULL != pMapEntries->szKey)
                        {
                                ATLASSERT(NULL != pMapEntries->szData);
                                p->AddReplacement((LPOLESTR)pMapEntries->szKey, (LPOLESTR)pMapEntries->szData);
                                pMapEntries++;
                        }
                }
                LPCOLESTR szType = OLESTR("REGISTRY");
				if (DWORD_PTR(lpszRes)<=0xffff)
				{
					if (bRegister)
						hRes = p->ResourceRegister(pszModule, ((UINT)LOWORD((DWORD_PTR)lpszRes)), szType);
					else
						hRes = p->ResourceUnregister(pszModule, ((UINT)LOWORD((DWORD_PTR)lpszRes)), szType);
				}
                else
                {
                        if (bRegister)
                                hRes = p->ResourceRegisterSz(pszModule, lpszRes, szType);
                        else
                                hRes = p->ResourceUnregisterSz(pszModule, lpszRes, szType);
                }

        }
        return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

ATLINLINE ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib)
{
        *pbstrPath = NULL;
        *ppTypeLib = NULL;
        ATLASSERT(pM != NULL);
        USES_CONVERSION;
        ATLASSERT(pM->m_hInstTypeLib != NULL);
        TCHAR szModule[_MAX_PATH+10];
        GetModuleFileName(pM->m_hInstTypeLib, szModule, _MAX_PATH);
        if (lpszIndex != NULL)
                lstrcat(szModule, OLE2CT(lpszIndex));
        LPOLESTR lpszModule = T2OLE(szModule);
        HRESULT hr = LoadTypeLib(lpszModule, ppTypeLib);
        if (!SUCCEEDED(hr))
        {
                // typelib not in module, try <module>.tlb instead
                LPTSTR lpszExt = NULL;
                LPTSTR lpsz;
                for (lpsz = szModule; *lpsz != NULL; lpsz = CharNext(lpsz))
                {
                        if (*lpsz == _T('.'))
                                lpszExt = lpsz;
                }
                if (lpszExt == NULL)
                        lpszExt = lpsz;
                lstrcpy(lpszExt, _T(".tlb"));
                lpszModule = T2OLE(szModule);
                hr = LoadTypeLib(lpszModule, ppTypeLib);
        }
        if (SUCCEEDED(hr))
                *pbstrPath = OLE2BSTR(lpszModule);
        return hr;
}

ATLINLINE ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
        typedef HRESULT (WINAPI *PFNRTL)(REFGUID, WORD, WORD, LCID, SYSKIND);
        CComBSTR bstrPath;
        CComPtr<ITypeLib> pTypeLib;
        HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
        if (SUCCEEDED(hr))
        {
                TLIBATTR* ptla;
                HRESULT hr = pTypeLib->GetLibAttr(&ptla);
                if (SUCCEEDED(hr))
                {
                        HINSTANCE h = LoadLibrary(_T("oleaut32.dll"));
                        if (h != NULL)
                        {
                                PFNRTL pfn = (PFNRTL) GetProcAddress(h, "UnRegisterTypeLib");
                                if (pfn != NULL)
                                        hr = pfn(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);
                                FreeLibrary(h);
                        }
                        pTypeLib->ReleaseTLibAttr(ptla);
                }
        }
        return hr;
}

ATLINLINE ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
        CComBSTR bstrPath;
        CComPtr<ITypeLib> pTypeLib;
        HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
        if (SUCCEEDED(hr))
        {
                OLECHAR szDir[_MAX_PATH];
                ocscpy(szDir, bstrPath);
                szDir[AtlGetDirLen(szDir)] = 0;
                hr = ::RegisterTypeLib(pTypeLib, bstrPath, szDir);
        }
        return hr;
}

ATLINLINE ATLAPI_(DWORD) AtlGetVersion(void* /* pReserved */)
{
        return _ATL_VER;
}

ATLINLINE ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject)
{
        pData->m_pThis = pObject;
        pData->m_dwThreadID = ::GetCurrentThreadId();
        ::EnterCriticalSection(&pM->m_csWindowCreate);
        pData->m_pNext = pM->m_pCreateWndList;
        pM->m_pCreateWndList = pData;
        ::LeaveCriticalSection(&pM->m_csWindowCreate);
}

ATLINLINE ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM)
{
        void* pv = NULL;
        ::EnterCriticalSection(&pM->m_csWindowCreate);
        _AtlCreateWndData* pEntry = pM->m_pCreateWndList;
        if(pEntry != NULL)
        {
                DWORD dwThreadID = ::GetCurrentThreadId();
                _AtlCreateWndData* pPrev = NULL;
                while(pEntry != NULL)
                {
                        if(pEntry->m_dwThreadID == dwThreadID)
                        {
                                if(pPrev == NULL)
                                        pM->m_pCreateWndList = pEntry->m_pNext;
                                else
                                        pPrev->m_pNext = pEntry->m_pNext;
                                pv = pEntry->m_pThis;
                                break;
                        }
                        pPrev = pEntry;
                        pEntry = pEntry->m_pNext;
                }
        }
        ::LeaveCriticalSection(&pM->m_csWindowCreate);
        return pv;
}

/////////////////////////////////////////////////////////////////////////////
// General DLL Version Helpers

inline HRESULT AtlGetDllVersion(HINSTANCE hInstDLL, DLLVERSIONINFO* pDllVersionInfo)
{
        ATLASSERT(pDllVersionInfo != NULL);
        if(::IsBadWritePtr(pDllVersionInfo, sizeof(DWORD)))
                return E_INVALIDARG;

        // We must get this function explicitly because some DLLs don't implement it.
        DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC)::GetProcAddress(hInstDLL, "DllGetVersion");
        if(pfnDllGetVersion == NULL)
                return E_NOTIMPL;

        return (*pfnDllGetVersion)(pDllVersionInfo);
}

inline HRESULT AtlGetDllVersion(LPCTSTR lpstrDllName, DLLVERSIONINFO* pDllVersionInfo)
{
        HINSTANCE hInstDLL = ::LoadLibrary(lpstrDllName);
        if(hInstDLL == NULL)
                return E_FAIL;
        HRESULT hRet = AtlGetDllVersion(hInstDLL, pDllVersionInfo);
        ::FreeLibrary(hInstDLL);
        return hRet;
}

// Common Control Versions:
//   Win95/WinNT 4.0    maj=4 min=00
//   IE 3.x     maj=4 min=70
//   IE 4.0     maj=4 min=71
inline HRESULT AtlGetCommCtrlVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
        ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
        if(::IsBadWritePtr(pdwMajor, sizeof(DWORD)) || ::IsBadWritePtr(pdwMinor, sizeof(DWORD)))
                return E_INVALIDARG;

        DLLVERSIONINFO dvi;
        ::ZeroMemory(&dvi, sizeof(dvi));
        dvi.cbSize = sizeof(dvi);
        HRESULT hRet = AtlGetDllVersion(_T("comctl32.dll"), &dvi);

        if(SUCCEEDED(hRet))
        {
                *pdwMajor = dvi.dwMajorVersion;
                *pdwMinor = dvi.dwMinorVersion;
        }
        else if(hRet == E_NOTIMPL)
        {
                // If DllGetVersion is not there, then the DLL is a version
                // previous to the one shipped with IE 3.x
                *pdwMajor = 4;
                *pdwMinor = 0;
                hRet = S_OK;
        }

        return hRet;
}

// Shell Versions:
//   Win95/WinNT 4.0                    maj=4 min=00
//   IE 3.x, IE 4.0 without Web Integrated Desktop  maj=4 min=00
//   IE 4.0 with Web Integrated Desktop         maj=4 min=71
//   IE 4.01 with Web Integrated Desktop        maj=4 min=72
inline HRESULT AtlGetShellVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
        ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
        if(::IsBadWritePtr(pdwMajor, sizeof(DWORD)) || ::IsBadWritePtr(pdwMinor, sizeof(DWORD)))
                return E_INVALIDARG;

        DLLVERSIONINFO dvi;
        ::ZeroMemory(&dvi, sizeof(dvi));
        dvi.cbSize = sizeof(dvi);
        HRESULT hRet = AtlGetDllVersion(_T("shell32.dll"), &dvi);

        if(SUCCEEDED(hRet))
        {
                *pdwMajor = dvi.dwMajorVersion;
                *pdwMinor = dvi.dwMinorVersion;
        }
        else if(hRet == E_NOTIMPL)
        {
                // If DllGetVersion is not there, then the DLL is a version
                // previous to the one shipped with IE 4.x
                *pdwMajor = 4;
                *pdwMinor = 0;
                hRet = S_OK;
        }

        return hRet;
}

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time
#undef _ATLBASE_IMPL

#endif // _ATLBASE_IMPL

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\atl\atlconv.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.


// seanmcd -- this is a cut down version of atl7's atlconv.h used to replace the atl3
// version in order to get prefast to shut up about use of _alloca
// since it now throws on out of memory conditions in the ctor i've modified it to use my
// exception hierarchy so i don't have to change any of my catches.

#ifndef __ATLCONV_H__
#define __ATLCONV_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4127) // unreachable code
#endif //!_ATL_NO_PRAGMA_WARNINGS

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#if defined(OLE2ANSI)
    #error this version of the atl conversion functions doesn't support OLE2ANSI
#endif

#include <atldef.h>
#include <stddef.h>

#ifndef NO_CUSTOM_THROW
#include <throw.h>
#else
#define THROWCOM(x) throw x;
#endif

#ifndef __wtypes_h__

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_IX86)
#define _X86_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_AMD64)
#define _AMD64_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_M68K)
#define _68K_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_MPPC)
#define _MPPC_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_M_IX86) && !defined(_AMD64_) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <winnls.h>

#if defined(_WIN32)

typedef WCHAR OLECHAR;
typedef OLECHAR  *LPOLESTR;
typedef const OLECHAR  *LPCOLESTR;
#define OLESTR(str) L##str

#else
#error only _WIN32 supported by this version
#endif // _WIN32

#endif	// __wtypes_h__

#ifndef _OLEAUTO_H_
typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h

extern "C"
{
__declspec(dllimport) BSTR __stdcall SysAllocString(const OLECHAR *);
__declspec(dllimport) BSTR __stdcall SysAllocStringLen(const OLECHAR *, UINT);
__declspec(dllimport) INT  __stdcall SysReAllocStringLen(BSTR *, const OLECHAR *, UINT);
}
#endif

// we use our own implementation of InterlockedExchangePointer because of problems with the one in system headers
#ifdef _M_IX86
#undef InterlockedExchangePointer
inline void* WINAPI InterlockedExchangePointer(void** pp, void* pNew) throw()
{
	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );
}
#endif
namespace ATL
{
#ifndef _CONVERSION_DONT_USE_THREAD_LOCALE
typedef UINT (WINAPI *ATLGETTHREADACP)();

inline UINT WINAPI _AtlGetThreadACPFake() throw()
{
	UINT nACP = 0;

	LCID lcidThread = ::GetThreadLocale();

	char szACP[7];
	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
	// executed on Windows 2000.
	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)
	{
		char* pch = szACP;
		while (*pch != '\0')
		{
			nACP *= 10;
			nACP += *pch++ - '0';
		}
	}
	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
	if (nACP == 0)
		nACP = ::GetACP();

	return nACP;
}

inline UINT WINAPI _AtlGetThreadACPReal() throw()
{
	return( CP_THREAD_ACP );
}

extern ATLGETTHREADACP g_pfnGetThreadACP;

inline UINT WINAPI _AtlGetThreadACPThunk() throw()
{
	OSVERSIONINFO ver;
	ATLGETTHREADACP pfnGetThreadACP;

	ver.dwOSVersionInfoSize = sizeof( ver );
	::GetVersionEx( &ver );
	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )
	{
		// On Win2K, CP_THREAD_ACP is supported
		pfnGetThreadACP = _AtlGetThreadACPReal;
	}
	else
	{
		pfnGetThreadACP = _AtlGetThreadACPFake;
	}
	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

	return( g_pfnGetThreadACP() );
}

__declspec( selectany ) ATLGETTHREADACP g_pfnGetThreadACP = _AtlGetThreadACPThunk;

inline UINT WINAPI _AtlGetConversionACP() throw()
{
	return( g_pfnGetThreadACP() );
}

#else

inline UINT WINAPI _AtlGetConversionACP() throw()
{
	return( CP_ACP );
}

#endif  // _CONVERSION_DONT_USE_THREAD_LOCALE

template< int t_nBufferLength = 128 >
class CW2WEX
{
public:
	CW2WEX( LPCWSTR psz ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz );
	}
	CW2WEX( LPCWSTR psz, UINT nCodePage ) throw(...) :
		m_psz( m_szBuffer )
	{
		(void)nCodePage;  // Code page doesn't matter

		Init( psz );
	}
	~CW2WEX() throw()
	{
		if( m_psz != m_szBuffer )
		{
			delete[] m_psz;
		}
	}

	operator LPWSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init( LPCWSTR psz ) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLength = lstrlenW( psz )+1;
		if( nLength > t_nBufferLength )
		{
			m_psz = new WCHAR[nLength];
			if( m_psz == NULL )
			{
				THROWCOM(E_OUTOFMEMORY);
			}
		}
		memcpy( m_psz, psz, nLength*sizeof( wchar_t ) );
	}

public:
	LPWSTR m_psz;
	wchar_t m_szBuffer[t_nBufferLength];

private:
	CW2WEX( const CW2WEX& ) throw();
	CW2WEX& operator=( const CW2WEX& ) throw();
};
typedef CW2WEX<> CW2W;

template< int t_nBufferLength = 128 >
class CA2AEX
{
public:
	CA2AEX( LPCSTR psz ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz );
	}
	CA2AEX( LPCSTR psz, UINT nCodePage ) throw(...) :
		m_psz( m_szBuffer )
	{
		(void)nCodePage;  // Code page doesn't matter

		Init( psz );
	}
	~CA2AEX() throw()
	{
		if( m_psz != m_szBuffer )
		{
			delete[] m_psz;
		}
	}

	operator LPSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init( LPCSTR psz ) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLength = lstrlenA( psz )+1;
		if( nLength > t_nBufferLength )
		{
			m_psz = new char[nLength]
			if( m_psz == NULL )
			{
				THROWCOM(E_OUTOFMEMORY);
			}
		}
		memcpy( m_psz, psz, nLength*sizeof( char ) );
	}

public:
	LPSTR m_psz;
	char m_szBuffer[t_nBufferLength];

private:
	CA2AEX( const CA2AEX& ) throw();
	CA2AEX& operator=( const CA2AEX& ) throw();
};
typedef CA2AEX<> CA2A;

template< int t_nBufferLength = 128 >
class CA2CAEX
{
public:
	CA2CAEX( LPCSTR psz ) throw(...) :
		m_psz( psz )
	{
	}
	CA2CAEX( LPCSTR psz, UINT nCodePage ) throw(...) :
		m_psz( psz )
	{
		(void)nCodePage;
	}
	~CA2CAEX() throw()
	{
	}

	operator LPCSTR() const throw()
	{
		return( m_psz );
	}

public:
	LPCSTR m_psz;

private:
	CA2CAEX( const CA2CAEX& ) throw();
	CA2CAEX& operator=( const CA2CAEX& ) throw();
};
typedef CA2CAEX<> CA2CA;

template< int t_nBufferLength = 128 >
class CW2CWEX
{
public:
	CW2CWEX( LPCWSTR psz ) throw(...) :
		m_psz( psz )
	{
	}
	CW2CWEX( LPCWSTR psz, UINT nCodePage ) throw(...) :
		m_psz( psz )
	{
		(void)nCodePage;
	}
	~CW2CWEX() throw()
	{
	}

	operator LPCWSTR() const throw()
	{
		return( m_psz );
	}

public:
	LPCWSTR m_psz;

private:
	CW2CWEX( const CW2CWEX& ) throw();
	CW2CWEX& operator=( const CW2CWEX& ) throw();
};
typedef CW2CWEX<> CW2CW;

template< int t_nBufferLength = 128 >
class CA2WEX
{
public:
	CA2WEX( LPCSTR psz ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, _AtlGetConversionACP() );
	}
	CA2WEX( LPCSTR psz, UINT nCodePage ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, nCodePage );
	}
	~CA2WEX() throw()
	{
		if( m_psz != m_szBuffer )
		{
			delete[] m_psz;
		}
	}

	operator LPWSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init( LPCSTR psz, UINT nCodePage ) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLengthA = lstrlenA( psz )+1;
		int nLengthW = nLengthA;

		if( nLengthW > t_nBufferLength )
		{
			m_psz = new WCHAR[nLengthW];
			if (m_psz == NULL)
			{
				THROWCOM(E_OUTOFMEMORY);
			}
		}

		::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, m_psz, nLengthW );
	}

public:
	LPWSTR m_psz;
	wchar_t m_szBuffer[t_nBufferLength];

private:
	CA2WEX( const CA2WEX& ) throw();
	CA2WEX& operator=( const CA2WEX& ) throw();
};
typedef CA2WEX<> CA2W;

template< int t_nBufferLength = 128 >
class CW2AEX
{
public:
	CW2AEX( LPCWSTR psz ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, _AtlGetConversionACP() );
	}
	CW2AEX( LPCWSTR psz, UINT nCodePage ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, nCodePage );
	}
	~CW2AEX() throw()
	{
		if( m_psz != m_szBuffer )
		{
			delete[] m_psz;
		}
	}

	operator LPSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init( LPCWSTR psz, UINT nCodePage ) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLengthW = lstrlenW( psz )+1;
		int nLengthA = nLengthW*2;

		if( nLengthA > t_nBufferLength )
		{
			m_psz = new char[nLengthA];
			if (m_psz == NULL)
			{
				THROWCOM(E_OUTOFMEMORY);
			}
		}

		::WideCharToMultiByte( nCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL );
	}

public:
	LPSTR m_psz;
	char m_szBuffer[t_nBufferLength];

private:
	CW2AEX( const CW2AEX& ) throw();
	CW2AEX& operator=( const CW2AEX& ) throw();
};
typedef CW2AEX<> CW2A;

#ifdef _UNICODE

	#define W2T CW2W
	#define CW2TEX CW2WEX
	#define W2CT CW2CW
	#define CW2CTEX CW2CWEX
	#define T2W CW2W
	#define CT2WEX CW2WEX
	#define T2CW CW2CW
	#define CT2CWEX CW2CWEX

	#define A2T CA2W
	#define CA2TEX CA2WEX
	#define A2CT CA2W
	#define CA2CTEX CA2WEX
	#define T2A CW2A
	#define CT2AEX CW2AEX
	#define T2CA CW2A
	#define CT2CAEX CW2AEX

#else  // !_UNICODE

	#define CW2T CW2A
	#define CW2TEX CW2AEX
	#define CW2CT CW2A
	#define CW2CTEX CW2AEX
	#define CT2W CA2W
	#define CT2WEX CA2WEX
	#define CT2CW CA2W
	#define CT2CWEX CA2WEX

	#define CA2T CA2A
	#define CA2TEX CA2AEX
	#define CA2CT CA2CA
	#define CA2CTEX CA2CAEX
	#define CT2A CA2A
	#define CT2AEX CA2AEX
	#define CT2CA CA2CA
	#define CT2CAEX CA2CAEX

#endif  // !_UNICODE

#define OLE2T CW2T
#define COLE2TEX CW2TEX
#define OLE2CT CW2CT
#define COLE2CTEX CW2CTEX
#define T2OLE CT2W
#define CT2OLEEX CT2WEX
#define T2COLE CT2CW
#define CT2COLEEX CT2CWEX

};  // namespace ATL


#define USES_CONVERSION

#define A2W CA2W
#define W2A CW2A
#define A2CW(x) CW2CW(CA2W(x))
#define W2CA(x) CA2CA(CW2A(x))


#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline int ocslen(LPCOLESTR x) throw() { return lstrlenW(x); }
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) throw() { return lstrcpyW(dest, src); }
	inline OLECHAR* ocscat(LPOLESTR dest, LPCOLESTR src) throw() { return lstrcatW(dest, src); }
	inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
	inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
	inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
	inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
	inline LPOLESTR CharNextO(LPCOLESTR lp) throw() {return CharNextW(lp);}
#else
	inline int ocslen(LPCOLESTR x) throw() { return lstrlenW(x); }
	//lstrcpyW doesn't work on Win95, so we do this
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) throw()
	{return (LPOLESTR) memcpy(dest, src, (lstrlenW(src)+1)*sizeof(WCHAR));}
	inline OLECHAR* ocscat(LPOLESTR dest, LPCOLESTR src) throw() { return ocscpy(dest+ocslen(dest), src); }
	//CharNextW doesn't work on Win95 so we use this
	#define T2COLE(lpa) A2CW(lpa)
	#define T2OLE(lpa) A2W(lpa)
	#define OLE2CT(lpo) W2CA(lpo)
	#define OLE2T(lpo) W2A(lpo)
	inline LPOLESTR CharNextO(LPCOLESTR lp) throw() {return (LPOLESTR) ((*lp) ? (lp+1) : lp);}
#endif

	inline LPOLESTR W2OLE(LPWSTR lp) { return lp; }
	inline LPWSTR OLE2W(LPOLESTR lp) { return lp; }
	#define A2OLE A2W
	#define OLE2A W2A
	inline LPCOLESTR W2COLE(LPCWSTR lp) { return lp; }
	inline LPCWSTR OLE2CW(LPCOLESTR lp) { return lp; }
	#define A2COLE A2CW
	#define OLE2CA W2CA

inline BSTR A2WBSTR(LPCSTR lp, int nLen = -1)
{
	if (lp == NULL || nLen == 0)
		return NULL;
    UINT _acp = ATL::_AtlGetConversionACP();
    BSTR str = NULL;
	int nConvertedLen = MultiByteToWideChar(_acp, 0, lp,
		nLen, NULL, NULL);
	int nAllocLen = nConvertedLen;
	if (nLen == -1)
		nAllocLen -= 1;  // Don't allocate terminating '\0'
	str = ::SysAllocStringLen(NULL, nAllocLen);
	if (str != NULL)
	{
		int nResult;
		nResult = MultiByteToWideChar(_acp, 0, lp, nLen, str, nConvertedLen);
		ATLASSERT(nResult == nConvertedLen);
	}
	return str;
}

inline BSTR OLE2BSTR(LPCOLESTR lp) {return ::SysAllocString(lp);}
#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline BSTR T2BSTR(LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {return A2WBSTR(lp);}
	inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);}
#else
	inline BSTR T2BSTR(LPCTSTR lp) {return A2WBSTR(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {return A2WBSTR(lp);}
	inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);}
#endif


#ifdef _WINGDI_
/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars, UINT acp) throw()
{
	ATLASSERT(lpa != NULL);
	ATLASSERT(lpw != NULL);
	if (lpw == NULL)
		return NULL;
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
	return lpw;
}

inline LPDEVMODEW AtlDevModeA2W(LPDEVMODEW lpDevModeW, const DEVMODEA* lpDevModeA)
{
    UINT _acp = ATL::_AtlGetConversionACP();
	if (lpDevModeA == NULL)
		return NULL;
	ATLASSERT(lpDevModeW != NULL);
	AtlA2WHelper(lpDevModeW->dmDeviceName, (LPCSTR)lpDevModeA->dmDeviceName, 32*sizeof(WCHAR), _acp);
	memcpy(&lpDevModeW->dmSpecVersion, &lpDevModeA->dmSpecVersion,
		offsetof(DEVMODEW, dmFormName) - offsetof(DEVMODEW, dmSpecVersion));
	AtlA2WHelper(lpDevModeW->dmFormName, (LPCSTR)lpDevModeA->dmFormName, 32*sizeof(WCHAR), _acp);
	memcpy(&lpDevModeW->dmLogPixels, &lpDevModeA->dmLogPixels,
		sizeof(DEVMODEW) - offsetof(DEVMODEW, dmLogPixels));
	if (lpDevModeA->dmDriverExtra != 0)
		memcpy(lpDevModeW+1, lpDevModeA+1, lpDevModeA->dmDriverExtra);
	lpDevModeW->dmSize = sizeof(DEVMODEW);
	return lpDevModeW;
}

inline LPTEXTMETRICW AtlTextMetricA2W(LPTEXTMETRICW lptmW, LPTEXTMETRICA lptmA)
{
    UINT _acp = ATL::_AtlGetConversionACP();
	if (lptmA == NULL)
		return NULL;
	ATLASSERT(lptmW != NULL);
	memcpy(lptmW, lptmA, sizeof(LONG) * 11);
	memcpy(&lptmW->tmItalic, &lptmA->tmItalic, sizeof(BYTE) * 5);
	MultiByteToWideChar(_acp, 0, (LPCSTR)&lptmA->tmFirstChar, 1, &lptmW->tmFirstChar, 1);
	MultiByteToWideChar(_acp, 0, (LPCSTR)&lptmA->tmLastChar, 1, &lptmW->tmLastChar, 1);
	MultiByteToWideChar(_acp, 0, (LPCSTR)&lptmA->tmDefaultChar, 1, &lptmW->tmDefaultChar, 1);
	MultiByteToWideChar(_acp, 0, (LPCSTR)&lptmA->tmBreakChar, 1, &lptmW->tmBreakChar, 1);
	return lptmW;
}

inline LPTEXTMETRICA AtlTextMetricW2A(LPTEXTMETRICA lptmA, LPTEXTMETRICW lptmW)
{
    UINT _acp = ATL::_AtlGetConversionACP();
	if (lptmW == NULL)
		return NULL;
	ATLASSERT(lptmA != NULL);
	memcpy(lptmA, lptmW, sizeof(LONG) * 11);
	memcpy(&lptmA->tmItalic, &lptmW->tmItalic, sizeof(BYTE) * 5);
	WideCharToMultiByte(_acp, 0, &lptmW->tmFirstChar, 1, (LPSTR)&lptmA->tmFirstChar, 1, NULL, NULL);
	WideCharToMultiByte(_acp, 0, &lptmW->tmLastChar, 1, (LPSTR)&lptmA->tmLastChar, 1, NULL, NULL);
	WideCharToMultiByte(_acp, 0, &lptmW->tmDefaultChar, 1, (LPSTR)&lptmA->tmDefaultChar, 1, NULL, NULL);
	WideCharToMultiByte(_acp, 0, &lptmW->tmBreakChar, 1, (LPSTR)&lptmA->tmBreakChar, 1, NULL, NULL);
	return lptmA;
}

#ifndef ATLDEVMODEA2W
#define ATLDEVMODEA2W AtlDevModeA2W
#define ATLDEVMODEW2A AtlDevModeW2A
#define ATLTEXTMETRICA2W AtlTextMetricA2W
#define ATLTEXTMETRICW2A AtlTextMetricW2A
#endif

#define DEVMODEW2A(lpw)\
	((lpw == NULL) ? NULL : ATLDEVMODEW2A((LPDEVMODEA)alloca(sizeof(DEVMODEA)+lpw->dmDriverExtra), lpw))
#define DEVMODEA2W(lpa)\
	((lpa == NULL) ? NULL : ATLDEVMODEA2W((LPDEVMODEW)alloca(sizeof(DEVMODEW)+lpa->dmDriverExtra), lpa))
#define TEXTMETRICW2A(lptmw)\
	((lptmw == NULL) ? NULL : ATLTEXTMETRICW2A((LPTEXTMETRICA)alloca(sizeof(TEXTMETRICA)), lptmw))
#define TEXTMETRICA2W(lptma)\
	((lptma == NULL) ? NULL : ATLTEXTMETRICA2W((LPTEXTMETRICW)alloca(sizeof(TEXTMETRICW)), lptma))

#define DEVMODEOLE DEVMODEW
#define LPDEVMODEOLE LPDEVMODEW
#define TEXTMETRICOLE TEXTMETRICW
#define LPTEXTMETRICOLE LPTEXTMETRICW

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline LPDEVMODEW DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; }
	inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODEW lp) { return lp; }
	inline LPTEXTMETRICW TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; }
	inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRICW lp) { return lp; }
#else
	#define DEVMODEOLE2T(lpo) DEVMODEW2A(lpo)
	#define DEVMODET2OLE(lpa) DEVMODEA2W(lpa)
	#define TEXTMETRICOLE2T(lptmw) TEXTMETRICW2A(lptmw)
	#define TEXTMETRICT2OLE(lptma) TEXTMETRICA2W(lptma)
#endif

#endif //_WINGDI_


#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif //!_ATL_NO_PRAGMA_WARNINGS

#endif // __ATLCONV_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\atl\atlgdi.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLGDI_H__
#define __ATLGDI_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlgdi.h requires atlbase.h to be included first
#endif

#include <commctrl.h>


#ifdef UNDER_CE

#ifdef TrackPopupMenu
#undef TrackPopupMenu
#endif //TrackPopupMenu

//REVIEW
BOOL IsMenu(HMENU hMenu)
{
	return (hMenu != NULL);
}

#endif //UNDER_CE


namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CDC;
class CPaintDC;
class CClientDC;
class CWindowDC;
class CMenu;
class CPen;
class CBrush;
class CFont;
class CBitmap;
class CPalette;
class CRgn;

/////////////////////////////////////////////////////////////////////////////
// CDC - The device context class

class CDC
{
public:

// Attributes
	HDC m_hDC;

	BOOL m_bAutoRestore;

	HPEN m_hOriginalPen;
	HBRUSH m_hOriginalBrush;
//	HPALETTE m_hOriginalPalette;
	HFONT m_hOriginalFont;
	HBITMAP m_hOriginalBitmap;

	void RestoreAllObjects()
	{
		if(m_hOriginalPen != NULL)
		{
#ifndef UNDER_CE
			ATLASSERT(::GetObjectType(m_hOriginalPen) == OBJ_PEN || ::GetObjectType(m_hOriginalPen) == OBJ_EXTPEN);
#else // CE specific
			ATLASSERT(::GetObjectType(m_hOriginalPen) == OBJ_PEN);
#endif //!UNDER_CE
			::SelectObject(m_hDC, m_hOriginalPen);
			m_hOriginalPen = NULL;
		}
		if(m_hOriginalBrush != NULL)
		{
			ATLASSERT(::GetObjectType(m_hOriginalBrush) == OBJ_BRUSH);
			::SelectObject(m_hDC, m_hOriginalBrush);
			m_hOriginalBrush = NULL;
		}
//		if(m_hOriginalPalette != NULL)
//		{
//			ATLASSERT(::GetObjectType(m_hOriginalPalette) == OBJ_PAL);
//			::SelectPalette(m_hDC, m_hOriginalPalette, FALSE);
//			m_hOriginalPalette = NULL;
//		}
		if(m_hOriginalFont != NULL)
		{
			ATLASSERT(::GetObjectType(m_hOriginalFont) == OBJ_FONT);
			::SelectObject(m_hDC, m_hOriginalFont);
			m_hOriginalFont = NULL;
		}
		if(m_hOriginalBitmap != NULL)
		{
			ATLASSERT(::GetObjectType(m_hOriginalBitmap) == OBJ_BITMAP);
			::SelectObject(m_hDC, m_hOriginalBitmap);
			m_hOriginalBitmap = NULL;
		}
	}

	CDC(HDC hDC = NULL, BOOL bAutoRestore = TRUE) : m_hDC(hDC), m_bAutoRestore(bAutoRestore),
		m_hOriginalPen(NULL), m_hOriginalBrush(NULL), m_hOriginalFont(NULL), m_hOriginalBitmap(NULL)
	{
	}

	~CDC()
	{
		if(m_hDC != NULL)
		{
			if(m_bAutoRestore)
				RestoreAllObjects();
			::DeleteDC(Detach());
		}
	}

	CDC& operator=(HDC hDC)
	{
		m_hDC = hDC;
		return *this;
	}

	void Attach(HDC hDC)
	{
		m_hDC = hDC;
	}

	HDC Detach()
	{
		HDC hDC = m_hDC;
		m_hDC = NULL;
		return hDC;
	}

	operator HDC() const { return m_hDC; }

#ifndef UNDER_CE
	HWND WindowFromDC() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::WindowFromDC(m_hDC);
	}
#endif //!UNDER_CE

	HPEN GetCurrentPen() const
	{
		ATLASSERT(m_hDC != NULL);
		return (HPEN)::GetCurrentObject(m_hDC, OBJ_PEN);
	}
	HBRUSH GetCurrentBrush() const
	{
		ATLASSERT(m_hDC != NULL);
		return (HBRUSH)::GetCurrentObject(m_hDC, OBJ_BRUSH);
	}
	HPALETTE GetCurrentPalette() const
	{
		ATLASSERT(m_hDC != NULL);
		return (HPALETTE)::GetCurrentObject(m_hDC, OBJ_PAL);
	}
	HFONT GetCurrentFont() const
	{
		ATLASSERT(m_hDC != NULL);
		return (HFONT)::GetCurrentObject(m_hDC, OBJ_FONT);
	}
	HBITMAP GetCurrentBitmap() const
	{
		ATLASSERT(m_hDC != NULL);
		return (HBITMAP)::GetCurrentObject(m_hDC, OBJ_BITMAP);
	}

	HDC CreateDC(LPCTSTR lpszDriverName, LPCTSTR lpszDeviceName,
		LPCTSTR lpszOutput, const DEVMODE* lpInitData)
	{
		ATLASSERT(m_hDC == NULL);
		m_hDC = ::CreateDC(lpszDriverName, lpszDeviceName, lpszOutput, lpInitData);
		return m_hDC;
	}

	HDC CreateCompatibleDC(HDC hDC = NULL)
	{
		ATLASSERT(m_hDC == NULL);
		m_hDC = ::CreateCompatibleDC(hDC);
		return m_hDC;
	}

	BOOL DeleteDC()
	{
		if(m_hDC == NULL)
			return FALSE;

		if(m_bAutoRestore)
			RestoreAllObjects();

		return ::DeleteDC(Detach());
	}

// Device-Context Functions
	int SaveDC()
	{
		ATLASSERT(m_hDC != NULL);
		return ::SaveDC(m_hDC);
	}

	BOOL RestoreDC(int nSavedDC)
	{
		ATLASSERT(m_hDC != NULL);
		return ::RestoreDC(m_hDC, nSavedDC);
	}

	int GetDeviceCaps(int nIndex) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetDeviceCaps(m_hDC, nIndex);
	}
#ifndef UNDER_CE
	UINT SetBoundsRect(LPCRECT lpRectBounds, UINT flags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBoundsRect(m_hDC, lpRectBounds, flags);
	}
	UINT GetBoundsRect(LPRECT lpRectBounds, UINT flags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBoundsRect(m_hDC, lpRectBounds, flags);
	}
	BOOL ResetDC(const DEVMODE* lpDevMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ResetDC(m_hDC, lpDevMode) != NULL;
	}
#endif //!UNDER_CE

// Drawing-Tool Functions
#ifndef UNDER_CE
	BOOL GetBrushOrg(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBrushOrgEx(m_hDC, lpPoint);
	}
#endif //!UNDER_CE
	BOOL SetBrushOrg(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBrushOrgEx(m_hDC, x, y, lpPoint);
	}
	BOOL SetBrushOrg(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBrushOrgEx(m_hDC, point.x, point.y, lpPointRet);
	}
#ifndef UNDER_CE
	int EnumObjects(int nObjectType, int (CALLBACK* lpfn)(LPVOID, LPARAM), LPARAM lpData)
	{
		ATLASSERT(m_hDC != NULL);
#ifdef STRICT
		return ::EnumObjects(m_hDC, nObjectType, (GOBJENUMPROC)lpfn, lpData);
#else
		return ::EnumObjects(m_hDC, nObjectType, (GOBJENUMPROC)lpfn, (LPVOID)lpData);
#endif
	}
#endif //!UNDER_CE

// Type-safe selection helpers
	HPEN SelectPen(HPEN hPen)
	{
		ATLASSERT(m_hDC != NULL);
#ifndef UNDER_CE
		ATLASSERT(::GetObjectType(hPen) == OBJ_PEN || ::GetObjectType(hPen) == OBJ_EXTPEN);
#else // CE specific
		ATLASSERT(::GetObjectType(hPen) == OBJ_PEN);
#endif //!UNDER_CE
		HPEN hOldPen = (HPEN)::SelectObject(m_hDC, hPen);
		if(m_hOriginalPen == NULL)
			m_hOriginalPen = hOldPen;
		return hOldPen;
	}
	HBRUSH SelectBrush(HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::GetObjectType(hBrush) == OBJ_BRUSH);
		HBRUSH hOldBrush = (HBRUSH)::SelectObject(m_hDC, hBrush);
		if(m_hOriginalBrush == NULL)
			m_hOriginalBrush = hOldBrush;
		return hOldBrush;
	}
	HFONT SelectFont(HFONT hFont)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::GetObjectType(hFont) == OBJ_FONT);
		HFONT hOldFont = (HFONT)::SelectObject(m_hDC, hFont);
		if(m_hOriginalFont == NULL)
			m_hOriginalFont = hOldFont;
		return hOldFont;
	}
	HBITMAP SelectBitmap(HBITMAP hBitmap)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::GetObjectType(hBitmap) == OBJ_BITMAP);
		HBITMAP hOldBitmap = (HBITMAP)::SelectObject(m_hDC, hBitmap);
		if(m_hOriginalBitmap == NULL)
			m_hOriginalBitmap = hOldBitmap;
		return hOldBitmap;
	}
	HGDIOBJ SelectRgn(HRGN hRgn)       // special return for regions
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::GetObjectType(hRgn) == OBJ_REGION);
		return ::SelectObject(m_hDC, hRgn);
	}

	HGDIOBJ SelectStockObject(int nIndex)
	{
		ATLASSERT(m_hDC != NULL);
		HGDIOBJ hObject = ::GetStockObject(nIndex);
		ATLASSERT(hObject != NULL);
		switch(::GetObjectType(hObject))
		{
		case OBJ_PEN:
#ifndef UNDER_CE
/*?*/		case OBJ_EXTPEN:
#endif //!UNDER_CE
			return SelectPen((HPEN)hObject);
		case OBJ_BRUSH:
			return SelectBrush((HBRUSH)hObject);
		case OBJ_FONT:
			return SelectFont((HFONT)hObject);
		default:
			return NULL;
		}
	}

// Color and Color Palette Functions
	COLORREF GetNearestColor(COLORREF crColor) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetNearestColor(m_hDC, crColor);
	}
	HPALETTE SelectPalette(HPALETTE hPalette, BOOL bForceBackground)
	{
		ATLASSERT(m_hDC != NULL);

		HPALETTE hOldPal = ::SelectPalette(m_hDC, hPalette, bForceBackground);
//		if(/*m_bAutoRestore && */m_hOriginalPal == NULL)
//			m_hOriginalPal = hOldPal;
		return hOldPal;
	}
	UINT RealizePalette()
	{
		ATLASSERT(m_hDC != NULL);
		return ::RealizePalette(m_hDC);
	}
#ifndef UNDER_CE
	void UpdateColors()
	{
		ATLASSERT(m_hDC != NULL);
		::UpdateColors(m_hDC);
	}
#endif //!UNDER_CE

// Drawing-Attribute Functions
	COLORREF GetBkColor() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBkColor(m_hDC);
	}
	int GetBkMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBkMode(m_hDC);
	}
#ifndef UNDER_CE
	int GetPolyFillMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPolyFillMode(m_hDC);
	}
	int GetROP2() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetROP2(m_hDC);
	}
	int GetStretchBltMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetStretchBltMode(m_hDC);
	}
#endif //!UNDER_CE
	COLORREF GetTextColor() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextColor(m_hDC);
	}

	COLORREF SetBkColor(COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBkColor(m_hDC, crColor);
	}
	int SetBkMode(int nBkMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBkMode(m_hDC, nBkMode);
	}
#ifndef UNDER_CE
	int SetPolyFillMode(int nPolyFillMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPolyFillMode(m_hDC, nPolyFillMode);
	}
#endif //!UNDER_CE
	int SetROP2(int nDrawMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetROP2(m_hDC, nDrawMode);
	}
#ifndef UNDER_CE
	int SetStretchBltMode(int nStretchMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetStretchBltMode(m_hDC, nStretchMode);
	}
#endif //!UNDER_CE
	COLORREF SetTextColor(COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextColor(m_hDC, crColor);
	}

#ifndef UNDER_CE
	BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetColorAdjustment(m_hDC, lpColorAdjust);
	}
	BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetColorAdjustment(m_hDC, lpColorAdjust);
	}
#endif //!UNDER_CE

// Mapping Functions
#ifndef UNDER_CE
	int GetMapMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetMapMode(m_hDC);
	}
	BOOL GetViewportOrg(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetViewportOrgEx(m_hDC, lpPoint);
	}
	int SetMapMode(int nMapMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetMapMode(m_hDC, nMapMode);
	}
	// Viewport Origin
	BOOL SetViewportOrg(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetViewportOrgEx(m_hDC, x, y, lpPoint);
	}
	BOOL SetViewportOrg(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return SetViewportOrg(point.x, point.y, lpPointRet);
	}
	BOOL OffsetViewportOrg(int nWidth, int nHeight, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetViewportOrgEx(m_hDC, nWidth, nHeight, lpPoint);
	}

	// Viewport Extent
	BOOL GetViewportExt(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetViewportExtEx(m_hDC, lpSize);
	}
	BOOL SetViewportExt(int x, int y, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetViewportExtEx(m_hDC, x, y, lpSize);
	}
	BOOL SetViewportExt(SIZE size, LPSIZE lpSizeRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return SetViewportExt(size.cx, size.cy, lpSizeRet);
	}
	BOOL ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ScaleViewportExtEx(m_hDC, xNum, xDenom, yNum, yDenom, lpSize);
	}

	// Window Origin
	BOOL GetWindowOrg(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetWindowOrgEx(m_hDC, lpPoint);
	}
	BOOL SetWindowOrg(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetWindowOrgEx(m_hDC, x, y, lpPoint);
	}
	BOOL SetWindowOrg(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return SetWindowOrg(point.x, point.y, lpPointRet);
	}
	BOOL OffsetWindowOrg(int nWidth, int nHeight, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetWindowOrgEx(m_hDC, nWidth, nHeight, lpPoint);
	}

	// Window extent
	BOOL GetWindowExt(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetWindowExtEx(m_hDC, lpSize);
	}
	BOOL SetWindowExt(int x, int y, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetWindowExtEx(m_hDC, x, y, lpSize);
	}
	BOOL SetWindowExt(SIZE size, LPSIZE lpSizeRet)
	{
		ATLASSERT(m_hDC != NULL);
		return SetWindowExt(size.cx, size.cy, lpSizeRet);
	}
	BOOL ScaleWindowExt(int xNum, int xDenom, int yNum, int yDenom, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ScaleWindowExtEx(m_hDC, xNum, xDenom, yNum, yDenom, lpSize);
	}

// Coordinate Functions
	BOOL DPtoLP(LPPOINT lpPoints, int nCount = 1) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::DPtoLP(m_hDC, lpPoints, nCount);
	}
	BOOL DPtoLP(LPRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::DPtoLP(m_hDC, (LPPOINT)lpRect, 2);
	}
	BOOL DPtoLP(LPSIZE lpSize) const
	{
		SIZE sizeWinExt;
		if(!GetWindowExt(&sizeWinExt))
			return FALSE;
		SIZE sizeVpExt;
		if(!GetViewportExt(&sizeVpExt))
			return FALSE;
		lpSize->cx = MulDiv(lpSize->cx, abs(sizeWinExt.cx), abs(sizeVpExt.cx));
		lpSize->cy = MulDiv(lpSize->cy, abs(sizeWinExt.cy), abs(sizeVpExt.cy));
		return TRUE;
	}
	BOOL LPtoDP(LPPOINT lpPoints, int nCount = 1) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::LPtoDP(m_hDC, lpPoints, nCount);
	}
	BOOL LPtoDP(LPRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::LPtoDP(m_hDC, (LPPOINT)lpRect, 2);
	}
	BOOL LPtoDP(LPSIZE lpSize) const
	{
		SIZE sizeWinExt;
		if(!GetWindowExt(&sizeWinExt))
			return FALSE;
		SIZE sizeVpExt;
		if(!GetViewportExt(&sizeVpExt))
			return FALSE;
		lpSize->cx = MulDiv(lpSize->cx, abs(sizeVpExt.cx), abs(sizeWinExt.cx));
		lpSize->cy = MulDiv(lpSize->cy, abs(sizeVpExt.cy), abs(sizeWinExt.cy));
		return TRUE;
	}

// Special Coordinate Functions (useful for dealing with metafiles and OLE)
	#define HIMETRIC_INCH   2540    // HIMETRIC units per inch

	void DPtoHIMETRIC(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		int nMapMode;
		if((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)
		{
			// when using a constrained map mode, map against physical inch
			((CDC*)this)->SetMapMode(MM_HIMETRIC);
			DPtoLP(lpSize);
			((CDC*)this)->SetMapMode(nMapMode);
		}
		else
		{
			// map against logical inch for non-constrained mapping modes
			int cxPerInch = GetDeviceCaps(LOGPIXELSX);
			int cyPerInch = GetDeviceCaps(LOGPIXELSY);
			ATLASSERT(cxPerInch != 0 && cyPerInch != 0);
			lpSize->cx = MulDiv(lpSize->cx, HIMETRIC_INCH, cxPerInch);
			lpSize->cy = MulDiv(lpSize->cy, HIMETRIC_INCH, cyPerInch);
		}
	}

	void HIMETRICtoDP(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		int nMapMode;
		if((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)
		{
			// when using a constrained map mode, map against physical inch
			((CDC*)this)->SetMapMode(MM_HIMETRIC);
			LPtoDP(lpSize);
			((CDC*)this)->SetMapMode(nMapMode);
		}
		else
		{
			// map against logical inch for non-constrained mapping modes
			int cxPerInch = GetDeviceCaps(LOGPIXELSX);
			int cyPerInch = GetDeviceCaps(LOGPIXELSY);
			ATLASSERT(cxPerInch != 0 && cyPerInch != 0);
			lpSize->cx = MulDiv(lpSize->cx, cxPerInch, HIMETRIC_INCH);
			lpSize->cy = MulDiv(lpSize->cy, cyPerInch, HIMETRIC_INCH);
		}
	}

	void LPtoHIMETRIC(LPSIZE lpSize) const
	{
		LPtoDP(lpSize);
		DPtoHIMETRIC(lpSize);
	}

	void HIMETRICtoLP(LPSIZE lpSize) const
	{
		HIMETRICtoDP(lpSize);
		DPtoLP(lpSize);
	}
#endif //!UNDER_CE

// Region Functions
	BOOL FillRgn(HRGN hRgn, HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FillRgn(m_hDC, hRgn, hBrush);
	}
#ifndef UNDER_CE
	BOOL FrameRgn(HRGN hRgn, HBRUSH hBrush, int nWidth, int nHeight)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FrameRgn(m_hDC, hRgn, hBrush, nWidth, nHeight);
	}
	BOOL InvertRgn(HRGN hRgn)
	{
		ATLASSERT(m_hDC != NULL);
		return ::InvertRgn(m_hDC, hRgn);
	}
	BOOL PaintRgn(HRGN hRgn)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PaintRgn(m_hDC, hRgn);
	}
#endif //!UNDER_CE

// Clipping Functions
	int GetClipBox(LPRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetClipBox(m_hDC, lpRect);
	}
#ifndef UNDER_CE
	BOOL PtVisible(int x, int y) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::PtVisible(m_hDC, x, y);
	}
	BOOL PtVisible(POINT point) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::PtVisible(m_hDC, point.x, point.y);
	}
#endif //!UNDER_CE
	BOOL RectVisible(LPCRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::RectVisible(m_hDC, lpRect);
	}
	int SelectClipRgn(HRGN hRgn)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SelectClipRgn(m_hDC, (HRGN)hRgn);
	}
	int ExcludeClipRect(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExcludeClipRect(m_hDC, x1, y1, x2, y2);
	}
	int ExcludeClipRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExcludeClipRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
#ifndef UNDER_CE
	int ExcludeUpdateRgn(HWND hWnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExcludeUpdateRgn(m_hDC, hWnd);
	}
#endif //!UNDER_CE
	int IntersectClipRect(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::IntersectClipRect(m_hDC, x1, y1, x2, y2);
	}
	int IntersectClipRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::IntersectClipRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
#ifndef UNDER_CE
	int OffsetClipRgn(int x, int y)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetClipRgn(m_hDC, x, y);
	}
	int OffsetClipRgn(SIZE size)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetClipRgn(m_hDC, size.cx, size.cy);
	}
	int SelectClipRgn(HRGN hRgn, int nMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExtSelectClipRgn(m_hDC, hRgn, nMode);
	}
#endif //!UNDER_CE

// Line-Output Functions
#ifndef UNDER_CE
//REVIEW
	BOOL GetCurrentPosition(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCurrentPositionEx(m_hDC, lpPoint);
	}
	BOOL MoveTo(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::MoveToEx(m_hDC, x, y, lpPoint);
	}
	BOOL MoveTo(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return MoveTo(point.x, point.y, lpPointRet);
	}
	BOOL LineTo(int x, int y)
	{
		ATLASSERT(m_hDC != NULL);
		return ::LineTo(m_hDC, x, y);
	}
	BOOL LineTo(POINT point)
	{
		ATLASSERT(m_hDC != NULL);
		return LineTo(point.x, point.y);
	}
	BOOL Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Arc(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Arc(m_hDC, lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
			ptEnd.x, ptEnd.y);
	}
#endif //!UNDER_CE
	BOOL Polyline(LPPOINT lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Polyline(m_hDC, lpPoints, nCount);
	}

#ifndef UNDER_CE
	BOOL AngleArc(int x, int y, int nRadius, float fStartAngle, float fSweepAngle)
	{
		ATLASSERT(m_hDC != NULL);
		return ::AngleArc(m_hDC, x, y, nRadius, fStartAngle, fSweepAngle);
	}
	BOOL ArcTo(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ArcTo(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL ArcTo(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ArcTo(lpRect->left, lpRect->top, lpRect->right,
		lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);
	}
	int GetArcDirection() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetArcDirection(m_hDC);
	}
	int SetArcDirection(int nArcDirection)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetArcDirection(m_hDC, nArcDirection);
	}

	BOOL PolyDraw(const POINT* lpPoints, const BYTE* lpTypes, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyDraw(m_hDC, lpPoints, lpTypes, nCount);
	}
	BOOL PolylineTo(const POINT* lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolylineTo(m_hDC, lpPoints, nCount);
	}
	BOOL PolyPolyline(const POINT* lpPoints,
		const DWORD* lpPolyPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyPolyline(m_hDC, lpPoints, lpPolyPoints, nCount);
	}

	BOOL PolyBezier(const POINT* lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyBezier(m_hDC, lpPoints, nCount);
	}
	BOOL PolyBezierTo(const POINT* lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyBezierTo(m_hDC, lpPoints, nCount);
	}
#endif //!UNDER_CE

// Simple Drawing Functions
	BOOL FillRect(LPCRECT lpRect, HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FillRect(m_hDC, lpRect, hBrush);
	}
#ifndef UNDER_CE
	BOOL FrameRect(LPCRECT lpRect, HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FrameRect(m_hDC, lpRect, hBrush);
	}
	BOOL InvertRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::InvertRect(m_hDC, lpRect);
	}
	BOOL DrawIcon(int x, int y, HICON hIcon)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawIcon(m_hDC, x, y, hIcon);
	}
	BOOL DrawIcon(POINT point, HICON hIcon)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawIcon(m_hDC, point.x, point.y, hIcon);
	}

	BOOL DrawState(POINT pt, SIZE size, HBITMAP hBitmap, UINT nFlags, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)hBitmap, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_BITMAP);
	}
	BOOL DrawState(POINT pt, SIZE size, LPCTSTR lpszText, UINT nFlags,
		BOOL bPrefixText = TRUE, int nTextLen = 0, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)lpszText, (WPARAM)nTextLen, pt.x, pt.y, size.cx, size.cy, nFlags | (bPrefixText ? DST_PREFIXTEXT : DST_TEXT));
	}
	BOOL DrawState(POINT pt, SIZE size, DRAWSTATEPROC lpDrawProc,
		LPARAM lData, UINT nFlags, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, lpDrawProc, lData, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_COMPLEX);
	}
#endif //!UNDER_CE

// Ellipse and Polygon Functions
#ifndef UNDER_CE
	BOOL Chord(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Chord(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL Chord(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Chord(m_hDC, lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
			ptEnd.x, ptEnd.y);
	}
#endif //!UNDER_CE
	void DrawFocusRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		::DrawFocusRect(m_hDC, lpRect);
	}
	BOOL Ellipse(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Ellipse(m_hDC, x1, y1, x2, y2);
	}
	BOOL Ellipse(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Ellipse(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
#ifndef UNDER_CE
	BOOL Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Pie(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Pie(m_hDC, lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
			ptEnd.x, ptEnd.y);
	}
#endif //!UNDER_CE
	BOOL Polygon(LPPOINT lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Polygon(m_hDC, lpPoints, nCount);
	}
#ifndef UNDER_CE
	BOOL PolyPolygon(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyPolygon(m_hDC, lpPoints, lpPolyCounts, nCount);
	}
#endif //!UNDER_CE
	BOOL Rectangle(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Rectangle(m_hDC, x1, y1, x2, y2);
	}
	BOOL Rectangle(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Rectangle(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	BOOL RoundRect(int x1, int y1, int x2, int y2, int x3, int y3)
	{
		ATLASSERT(m_hDC != NULL);
		return ::RoundRect(m_hDC, x1, y1, x2, y2, x3, y3);
	}
	BOOL RoundRect(LPCRECT lpRect, POINT point)
	{
		ATLASSERT(m_hDC != NULL);
		return ::RoundRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, point.x, point.y);
	}

// Bitmap Functions
	BOOL PatBlt(int x, int y, int nWidth, int nHeight, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PatBlt(m_hDC, x, y, nWidth, nHeight, dwRop);
	}
	BOOL BitBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC,
		int xSrc, int ySrc, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::BitBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, dwRop);
	}
	BOOL StretchBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC,
		int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::StretchBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, nSrcWidth, nSrcHeight, dwRop);
	}
	COLORREF GetPixel(int x, int y) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPixel(m_hDC, x, y);
	}
	COLORREF GetPixel(POINT point) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPixel(m_hDC, point.x, point.y);
	}
	COLORREF SetPixel(int x, int y, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixel(m_hDC, x, y, crColor);
	}
	COLORREF SetPixel(POINT point, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixel(m_hDC, point.x, point.y, crColor);
	}
#ifndef UNDER_CE
	BOOL FloodFill(int x, int y, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FloodFill(m_hDC, x, y, crColor);
	}
	BOOL ExtFloodFill(int x, int y, COLORREF crColor, UINT nFillType)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExtFloodFill(m_hDC, x, y, crColor, nFillType);
	}
#endif //!UNDER_CE
	BOOL MaskBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC,
		int xSrc, int ySrc, HBITMAP hMaskBitmap, int xMask, int yMask,
		DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::MaskBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, hMaskBitmap, xMask, yMask, dwRop);
	}
#ifndef UNDER_CE
	BOOL PlgBlt(LPPOINT lpPoint, HDC hSrcDC, int xSrc, int ySrc,
		int nWidth, int nHeight, HBITMAP hMaskBitmap, int xMask, int yMask)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PlgBlt(m_hDC, lpPoint, hSrcDC, xSrc, ySrc, nWidth, nHeight, hMaskBitmap, xMask, yMask);
	}
	BOOL SetPixelV(int x, int y, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixelV(m_hDC, x, y, crColor);
	}
	BOOL SetPixelV(POINT point, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixelV(m_hDC, point.x, point.y, crColor);
	}
#endif //!UNDER_CE

// Text Functions
#ifndef UNDER_CE
	BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount = -1)
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::TextOut(m_hDC, x, y, lpszString, nCount);
	}
#endif //!UNDER_CE
	BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				LPCTSTR lpszString, UINT nCount = -1, LPINT lpDxWidths = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect, lpszString, nCount, lpDxWidths);
	}
#ifndef UNDER_CE
	SIZE TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount = -1,
			int nTabPositions = 0, LPINT lpnTabStopPositions = NULL, int nTabOrigin = 0)
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		SIZE size;
		LONG lRes = ::TabbedTextOut(m_hDC, x, y, lpszString, nCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
		size.cx = LOWORD(lRes);
		size.cy = HIWORD(lRes);
		return size;
	}
#endif //!UNDER_CE
	int DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect, UINT nFormat)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawText(m_hDC, lpszString, nCount, lpRect, nFormat);
	}
	BOOL GetTextExtent(LPCTSTR lpszString, int nCount, LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::GetTextExtentPoint32(m_hDC, lpszString, nCount, lpSize);
	}
#ifndef UNDER_CE
	BOOL GetTabbedTextExtent(LPCTSTR lpszString, int nCount,
		int nTabPositions, LPINT lpnTabStopPositions) const
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::GetTabbedTextExtent(m_hDC, lpszString, nCount, nTabPositions, lpnTabStopPositions);
	}
	BOOL GrayString(HBRUSH hBrush,
		BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int), LPARAM lpData,
			int nCount, int x, int y, int nWidth, int nHeight)
	{
		ATLASSERT(m_hDC != NULL);
		return ::GrayString(m_hDC, hBrush, (GRAYSTRINGPROC)lpfnOutput, lpData, nCount, x, y, nWidth, nHeight);
	}
	UINT GetTextAlign() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextAlign(m_hDC);
	}
	UINT SetTextAlign(UINT nFlags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextAlign(m_hDC, nFlags);
	}
#endif //!UNDER_CE
	int GetTextFace(LPTSTR lpszFacename, int nCount) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextFace(m_hDC, nCount, lpszFacename);
	}
	int GetTextFaceLen() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextFace(m_hDC, 0, NULL);
	}
#ifndef _ATL_NO_COM
	BOOL GetTextFace(BSTR& bstrFace) const
	{
		USES_CONVERSION;
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(bstrFace == NULL);

		int nLen = GetTextFaceLen();
		if(nLen == 0)
			return FALSE;

		LPTSTR lpszText = (LPTSTR)_alloca(nLen * sizeof(TCHAR));

		if(!GetTextFace(lpszText, nLen))
			return FALSE;

		bstrFace = ::SysAllocString(T2OLE(lpszText));
		return (bstrFace != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM
	BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextMetrics(m_hDC, lpMetrics);
	}
#ifndef UNDER_CE
	int SetTextJustification(int nBreakExtra, int nBreakCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextJustification(m_hDC, nBreakExtra, nBreakCount);
	}
	int GetTextCharacterExtra() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextCharacterExtra(m_hDC);
	}
	int SetTextCharacterExtra(int nCharExtra)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextCharacterExtra(m_hDC, nCharExtra);
	}
#endif //!UNDER_CE

// Advanced Drawing
	BOOL DrawEdge(LPRECT lpRect, UINT nEdge, UINT nFlags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawEdge(m_hDC, lpRect, nEdge, nFlags);
	}
	BOOL DrawFrameControl(LPRECT lpRect, UINT nType, UINT nState)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawFrameControl(m_hDC, lpRect, nType, nState);
	}

// Scrolling Functions
	BOOL ScrollDC(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip,
		HRGN hRgnUpdate, LPRECT lpRectUpdate)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ScrollDC(m_hDC, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate);
	}

// Font Functions
#ifndef UNDER_CE
	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharWidth(m_hDC, nFirstChar, nLastChar, lpBuffer);
	}
	DWORD SetMapperFlags(DWORD dwFlag)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetMapperFlags(m_hDC, dwFlag);
	}
	BOOL GetAspectRatioFilter(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetAspectRatioFilterEx(m_hDC, lpSize);
	}

	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABC lpabc) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharABCWidths(m_hDC, nFirstChar, nLastChar, lpabc);
	}
	DWORD GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData, DWORD cbData) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetFontData(m_hDC, dwTable, dwOffset, lpData, cbData);
	}
	int GetKerningPairs(int nPairs, LPKERNINGPAIR lpkrnpair) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetKerningPairs(m_hDC, nPairs, lpkrnpair);
	}
	UINT GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetOutlineTextMetrics(m_hDC, cbData, lpotm);
	}
	DWORD GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm,
		DWORD cbBuffer, LPVOID lpBuffer, const MAT2* lpmat2) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetGlyphOutline(m_hDC, nChar, nFormat, lpgm, cbBuffer, lpBuffer, lpmat2);
	}

	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar,
		LPABCFLOAT lpABCF) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharABCWidthsFloat(m_hDC, nFirstChar, nLastChar, lpABCF);
	}
	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar,
		float* lpFloatBuffer) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharWidthFloat(m_hDC, nFirstChar, nLastChar, lpFloatBuffer);
	}
#endif //!UNDER_CE

// Printer/Device Escape Functions
#ifndef UNDER_CE
	int Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Escape(m_hDC, nEscape, nCount, lpszInData, lpOutData);
	}
	int Escape(int nEscape, int nInputSize, LPCSTR lpszInputData,
		int nOutputSize, LPSTR lpszOutputData)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExtEscape(m_hDC, nEscape, nInputSize, lpszInputData, nOutputSize, lpszOutputData);
	}
	int DrawEscape(int nEscape, int nInputSize, LPCSTR lpszInputData)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawEscape(m_hDC, nEscape, nInputSize, lpszInputData);
	}
#endif //!UNDER_CE

	// Escape helpers
	int StartDoc(LPCTSTR lpszDocName)  // old Win3.0 version
	{
		DOCINFO di;
		memset(&di, 0, sizeof(DOCINFO));
		di.cbSize = sizeof(DOCINFO);
		di.lpszDocName = lpszDocName;
		return StartDoc(&di);
	}

	int StartDoc(LPDOCINFO lpDocInfo)
	{
		ATLASSERT(m_hDC != NULL);
		return ::StartDoc(m_hDC, lpDocInfo);
	}
	int StartPage()
	{
		ATLASSERT(m_hDC != NULL);
		return ::StartPage(m_hDC);
	}
	int EndPage()
	{
		ATLASSERT(m_hDC != NULL);
		return ::EndPage(m_hDC);
	}
	int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int))
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetAbortProc(m_hDC, (ABORTPROC)lpfn);
	}
	int AbortDoc()
	{
		ATLASSERT(m_hDC != NULL);
		return ::AbortDoc(m_hDC);
	}
	int EndDoc()
	{
		ATLASSERT(m_hDC != NULL);
		return ::EndDoc(m_hDC);
	}

// MetaFile Functions
#ifndef UNDER_CE
	BOOL PlayMetaFile(HMETAFILE hMF)
	{
		ATLASSERT(m_hDC != NULL);
		if(::GetDeviceCaps(m_hDC, TECHNOLOGY) == DT_METAFILE)
		{
			// playing metafile in metafile, just use core windows API
			return ::PlayMetaFile(m_hDC, hMF);
		}

		// for special playback, lParam == pDC
		return ::EnumMetaFile(m_hDC, hMF, EnumMetaFileProc, (LPARAM)this);
	}
	BOOL PlayMetaFile(HENHMETAFILE hEnhMetaFile, LPCRECT lpBounds)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PlayEnhMetaFile(m_hDC, hEnhMetaFile, lpBounds);
	}
	BOOL AddMetaFileComment(UINT nDataSize, const BYTE* pCommentData) // can be used for enhanced metafiles only
	{
		ATLASSERT(m_hDC != NULL);
		return ::GdiComment(m_hDC, nDataSize, pCommentData);
	}

	// Special handling for metafile playback
	static int CALLBACK EnumMetaFileProc(HDC hDC, HANDLETABLE* pHandleTable, METARECORD* pMetaRec, int nHandles, LPARAM lParam)
	{
		CDC* pDC = (CDC*)lParam;

		switch (pMetaRec->rdFunction)
		{
		case META_SETMAPMODE:
			pDC->SetMapMode((int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETWINDOWEXT:
			pDC->SetWindowExt((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETWINDOWORG:
			pDC->SetWindowOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETVIEWPORTEXT:
			pDC->SetViewportExt((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETVIEWPORTORG:
			pDC->SetViewportOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SCALEWINDOWEXT:
			pDC->ScaleWindowExt((int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2], 
				(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SCALEVIEWPORTEXT:
			pDC->ScaleViewportExt((int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2],
				(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_OFFSETVIEWPORTORG:
			pDC->OffsetViewportOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SAVEDC:
			pDC->SaveDC();
			break;
		case META_RESTOREDC:
			pDC->RestoreDC((int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETBKCOLOR:
			pDC->SetBkColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
			break;
		case META_SETTEXTCOLOR:
			pDC->SetTextColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
			break;

		// need to watch out for SelectObject(HFONT), for custom font mapping
		case META_SELECTOBJECT:
			{
				HGDIOBJ hObject = pHandleTable->objectHandle[pMetaRec->rdParm[0]];
				UINT nObjType = ::GetObjectType(hObject);
				if(nObjType == 0)
				{
					// object type is unknown, determine if it is a font
					HFONT hStockFont = (HFONT)::GetStockObject(SYSTEM_FONT);
/**/					HFONT hFontOld = (HFONT)::SelectObject(pDC->m_hDC, hStockFont);
/**/					HGDIOBJ hObjOld = ::SelectObject(pDC->m_hDC, hObject);
					if(hObjOld == hStockFont)
					{
						// got the stock object back, so must be selecting a font
						pDC->SelectFont((HFONT)hObject);
						break;  // don't play the default record
					}
					else
					{
						// didn't get the stock object back, so restore everything
/**/						::SelectObject(pDC->m_hDC, hFontOld);
/**/						::SelectObject(pDC->m_hDC, hObjOld);
					}
					// and fall through to PlayMetaFileRecord...
				}
				else if(nObjType == OBJ_FONT)
				{
					// play back as CDC::SelectFont(HFONT)
					pDC->SelectFont((HFONT)hObject);
					break;  // don't play the default record
				}
			}
			// fall through...

		default:
			::PlayMetaFileRecord(hDC, pHandleTable, pMetaRec, nHandles);
			break;
		}

		return 1;
	}
#endif //!UNDER_CE

// Path Functions
#ifndef UNDER_CE
	BOOL AbortPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::AbortPath(m_hDC);
	}
	BOOL BeginPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::BeginPath(m_hDC);
	}
	BOOL CloseFigure()
	{
		ATLASSERT(m_hDC != NULL);
		return ::CloseFigure(m_hDC);
	}
	BOOL EndPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::EndPath(m_hDC);
	}
	BOOL FillPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::FillPath(m_hDC);
	}
	BOOL FlattenPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::FlattenPath(m_hDC);
	}
	BOOL StrokeAndFillPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::StrokeAndFillPath(m_hDC);
	}
	BOOL StrokePath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::StrokePath(m_hDC);
	}
	BOOL WidenPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::WidenPath(m_hDC);
	}
	BOOL GetMiterLimit(PFLOAT pfMiterLimit) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetMiterLimit(m_hDC, pfMiterLimit);
	}
	BOOL SetMiterLimit(float fMiterLimit)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetMiterLimit(m_hDC, fMiterLimit, NULL);
	}
	int GetPath(LPPOINT lpPoints, LPBYTE lpTypes, int nCount) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPath(m_hDC, lpPoints, lpTypes, nCount);
	}
	BOOL SelectClipPath(int nMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SelectClipPath(m_hDC, nMode);
	}
#endif //!UNDER_CE

// Misc Helper Functions
	static HBRUSH PASCAL GetHalftoneBrush()
	{
		HBRUSH halftoneBrush;
		WORD grayPattern[8];
		for(int i = 0; i < 8; i++)
			grayPattern[i] = (WORD)(0x5555 << (i & 1));
		HBITMAP grayBitmap = CreateBitmap(8, 8, 1, 1, &grayPattern);
		if(grayBitmap != NULL)
		{
			halftoneBrush = ::CreatePatternBrush(grayBitmap);
			DeleteObject(grayBitmap);
		}
		return halftoneBrush;
	}
	void DrawDragRect(LPCRECT lpRect, SIZE size, LPCRECT lpRectLast, SIZE sizeLast, HBRUSH hBrush = NULL, HBRUSH hBrushLast = NULL)
	{
		// first, determine the update region and select it
		HRGN hRgnNew;
		HRGN hRgnOutside, hRgnInside;
		hRgnOutside = ::CreateRectRgnIndirect(lpRect);
		RECT rect = *lpRect;
		::InflateRect(&rect, -size.cx, -size.cy);
		::IntersectRect(&rect, &rect, lpRect);
		hRgnInside = ::CreateRectRgnIndirect(&rect);
		hRgnNew = ::CreateRectRgn(0, 0, 0, 0);
		::CombineRgn(hRgnNew, hRgnOutside, hRgnInside, RGN_XOR);

		HBRUSH hBrushOld = NULL;
		if(hBrush == NULL)
			hBrush = CDC::GetHalftoneBrush();
		if(hBrushLast == NULL)
			hBrushLast = hBrush;

		HRGN hRgnLast, hRgnUpdate;
		if(lpRectLast != NULL)
		{
			// find difference between new region and old region
			hRgnLast = ::CreateRectRgn(0, 0, 0, 0);
			::SetRectRgn(hRgnOutside, lpRectLast->left, lpRectLast->top, lpRectLast->right, lpRectLast->bottom);
			rect = *lpRectLast;
			::InflateRect(&rect, -sizeLast.cx, -sizeLast.cy);
			::IntersectRect(&rect, &rect, lpRectLast);
			::SetRectRgn(hRgnInside, rect.left, rect.top, rect.right, rect.bottom);
			::CombineRgn(hRgnLast, hRgnOutside, hRgnInside, RGN_XOR);

			// only diff them if brushes are the same
			if(hBrush == hBrushLast)
			{
				hRgnUpdate = ::CreateRectRgn(0, 0, 0, 0);
				::CombineRgn(hRgnUpdate, hRgnLast, hRgnNew, RGN_XOR);
			}
		}
		if(hBrush != hBrushLast && lpRectLast != NULL)
		{
			// brushes are different -- erase old region first
			SelectClipRgn(hRgnLast);
			GetClipBox(&rect);
			hBrushOld = SelectBrush(hBrushLast);
			PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);
			SelectBrush(hBrushOld);
			hBrushOld = NULL;
		}

		// draw into the update/new region
		SelectClipRgn(hRgnUpdate != NULL ? hRgnUpdate : hRgnNew);
		GetClipBox(&rect);
		hBrushOld = SelectBrush(hBrush);
		PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);

		// cleanup DC
		if(hBrushOld != NULL)
			SelectBrush(hBrushOld);
		SelectClipRgn(NULL);
	}
	void FillSolidRect(LPCRECT lpRect, COLORREF clr)
	{
		ATLASSERT(m_hDC != NULL);

		::SetBkColor(m_hDC, clr);
		::ExtTextOut(m_hDC, 0, 0, ETO_OPAQUE, lpRect, NULL, 0, NULL);
	}
	void FillSolidRect(int x, int y, int cx, int cy, COLORREF clr)
	{
		ATLASSERT(m_hDC != NULL);

		::SetBkColor(m_hDC, clr);
		RECT rect = { x, y, x + cx, y + cy };
		::ExtTextOut(m_hDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
	}
	void Draw3dRect(LPCRECT lpRect, COLORREF clrTopLeft, COLORREF clrBottomRight)
	{
		Draw3dRect(lpRect->left, lpRect->top, lpRect->right - lpRect->left,
			lpRect->bottom - lpRect->top, clrTopLeft, clrBottomRight);
	}
	void Draw3dRect(int x, int y, int cx, int cy, COLORREF clrTopLeft, COLORREF clrBottomRight)
	{
		FillSolidRect(x, y, cx - 1, 1, clrTopLeft);
		FillSolidRect(x, y, 1, cy - 1, clrTopLeft);
		FillSolidRect(x + cx, y, -1, cy, clrBottomRight);
		FillSolidRect(x, y + cy, cx, -1, clrBottomRight);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CDC Helpers

class CPaintDC : public CDC
{
public:
	HWND m_hWnd;
	PAINTSTRUCT m_ps;

	CPaintDC(HWND hWnd, BOOL bAutoRestore = TRUE) : CDC(NULL, bAutoRestore)
	{
		ATLASSERT(::IsWindow(hWnd));
		m_hWnd = hWnd;
		m_hDC = ::BeginPaint(hWnd, &m_ps);
	}
	~CPaintDC()
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::IsWindow(m_hWnd));

		if(m_bAutoRestore)
			RestoreAllObjects();

		::EndPaint(m_hWnd, &m_ps);
		Detach();
	}
};

class CClientDC : public CDC
{
public:
	HWND m_hWnd;

	CClientDC(HWND hWnd, BOOL bAutoRestore = TRUE) : CDC(NULL, bAutoRestore)
	{
		ATLASSERT(hWnd == NULL || ::IsWindow(hWnd));
		m_hWnd = hWnd;
		m_hDC = ::GetDC(hWnd);
	}
	~CClientDC()
	{
		ATLASSERT(m_hDC != NULL);

		if(m_bAutoRestore)
			RestoreAllObjects();

		::ReleaseDC(m_hWnd, Detach());
	}
};

class CWindowDC : public CDC
{
public:
	HWND m_hWnd;

	CWindowDC(HWND hWnd, BOOL bAutoRestore = TRUE) : CDC(NULL, bAutoRestore)
	{
		ATLASSERT(hWnd == NULL || ::IsWindow(hWnd));
		m_hWnd = hWnd;
		m_hDC = ::GetWindowDC(hWnd);
	}
	~CWindowDC()
	{
		ATLASSERT(m_hDC != NULL);

		if(m_bAutoRestore)
			RestoreAllObjects();

		::ReleaseDC(m_hWnd, Detach());
	}
};

/////////////////////////////////////////////////////////////////////////////
// CMenu

class CMenu
{
public:
	HMENU m_hMenu;

	CMenu(HMENU hMenu = NULL) : m_hMenu(hMenu) { }

	~CMenu()
	{
		if(m_hMenu != NULL)
			DestroyMenu();
	}

	CMenu& operator=(HMENU hMenu)
	{
		m_hMenu = hMenu;
		return *this;
	}

	void Attach(HMENU hMenuNew)
	{
		ATLASSERT(::IsMenu(hMenuNew));
		m_hMenu = hMenuNew;
	}

	HMENU Detach()
	{
		HMENU hMenu = m_hMenu;
		m_hMenu = NULL;
		return hMenu;
	}

	operator HMENU() const { return m_hMenu; }

	BOOL CreateMenu()
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::CreateMenu();
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL CreatePopupMenu()
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::CreatePopupMenu();
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL LoadMenu(LPCTSTR lpszResourceName)
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::LoadMenu(_Module.GetResourceInstance(), lpszResourceName);
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL LoadMenu(UINT nIDResource)
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(nIDResource));
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
#ifndef UNDER_CE
	BOOL LoadMenuIndirect(const void* lpMenuTemplate)
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::LoadMenuIndirect(lpMenuTemplate);
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
#endif //!UNDER_CE
	BOOL DestroyMenu()
	{
		if (m_hMenu == NULL)
			return FALSE;
		return ::DestroyMenu(Detach());
	}

// Menu Operations
	BOOL DeleteMenu(UINT nPosition, UINT nFlags)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::DeleteMenu(m_hMenu, nPosition, nFlags);
	}
	BOOL TrackPopupMenu(UINT nFlags, int x, int y, HWND hWnd, LPCRECT lpRect = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
#ifndef UNDER_CE
		return ::TrackPopupMenu(m_hMenu, nFlags, x, y, 0, hWnd, lpRect);
#else // CE specific
		return ::TrackPopupMenuEx(m_hMenu, nFlags, x, y, hWnd, NULL);
#endif //!UNDER_CE
	}
	BOOL TrackPopupMenuEx(UINT uFlags, int x, int y, HWND hWnd, LPTPMPARAMS lptpm = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::TrackPopupMenuEx(m_hMenu, uFlags, x, y, hWnd, lptpm);
	}

// Menu Item Operations
	BOOL AppendMenu(UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::AppendMenu(m_hMenu, nFlags, nIDNewItem, lpszNewItem);
	}
#ifndef UNDER_CE
//REVIEW
	BOOL AppendMenu(UINT nFlags, UINT nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::AppendMenu(m_hMenu, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
#endif //!UNDER_CE
	UINT CheckMenuItem(UINT nIDCheckItem, UINT nCheck)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (UINT)::CheckMenuItem(m_hMenu, nIDCheckItem, nCheck);
	}
	UINT EnableMenuItem(UINT nIDEnableItem, UINT nEnable)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::EnableMenuItem(m_hMenu, nIDEnableItem, nEnable);
	}
#ifndef UNDER_CE
	UINT GetMenuItemCount() const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuItemCount(m_hMenu);
	}
	UINT GetMenuItemID(int nPos) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuItemID(m_hMenu, nPos);
	}
	UINT GetMenuState(UINT nID, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuState(m_hMenu, nID, nFlags);
	}
	int GetMenuString(UINT nIDItem, LPTSTR lpString, int nMaxCount, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuString(m_hMenu, nIDItem, lpString, nMaxCount, nFlags);
	}
	int GetMenuStringLen(UINT nIDItem, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuString(m_hMenu, nIDItem, NULL, 0, nFlags);
	}
#ifndef _ATL_NO_COM
	BOOL GetMenuString(UINT nIDItem, BSTR& bstrText, UINT nFlags) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsMenu(m_hMenu));
		ATLASSERT(bstrText == NULL);

		int nLen = GetMenuStringLen(nIDItem, nFlags);
		{
			bstrText = ::SysAllocString(OLESTR(""));
			return (bstrText != NULL) ? TRUE : FALSE;
		}

		LPTSTR lpszText = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));

		if(!GetMenuString(nIDItem, lpszText, nLen, nFlags))
			return FALSE;

		bstrText = ::SysAllocString(T2OLE(lpszText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM
#endif //!UNDER_CE
	HMENU GetSubMenu(int nPos) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetSubMenu(m_hMenu, nPos);
	}
#ifndef UNDER_CE
//REVIEW
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::InsertMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem);
	}
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::InsertMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
#endif //!UNDER_CE
#ifndef UNDER_CE
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::ModifyMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem);
	}
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::ModifyMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
#endif //!UNDER_CE
	BOOL RemoveMenu(UINT nPosition, UINT nFlags)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::RemoveMenu(m_hMenu, nPosition, nFlags);
	}
#ifndef UNDER_CE
	BOOL SetMenuItemBitmaps(UINT nPosition, UINT nFlags, HBITMAP hBmpUnchecked, HBITMAP hBmpChecked)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::SetMenuItemBitmaps(m_hMenu, nPosition, nFlags, hBmpUnchecked, hBmpChecked);
	}
#endif //!UNDER_CE
	BOOL CheckMenuRadioItem(UINT nIDFirst, UINT nIDLast, UINT nIDItem, UINT nFlags)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::CheckMenuRadioItem(m_hMenu, nIDFirst, nIDLast, nIDItem, nFlags);
	}

	BOOL GetMenuItemInfo(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (BOOL)::GetMenuItemInfo(m_hMenu, uItem, bByPosition, lpmii);
	}
	BOOL SetMenuItemInfo(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (BOOL)::SetMenuItemInfo(m_hMenu, uItem, bByPosition, lpmii);
	}
 
// Context Help Functions
#ifndef UNDER_CE
	BOOL SetMenuContextHelpId(DWORD dwContextHelpId)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::SetMenuContextHelpId(m_hMenu, dwContextHelpId);
	}
	DWORD GetMenuContextHelpId() const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuContextHelpId(m_hMenu);
	}
#endif //!UNDER_CE
};

/////////////////////////////////////////////////////////////////////////////
// CPen

class CPen
{
public:
	HPEN m_hPen;

	CPen(HPEN hPen = NULL) : m_hPen(hPen)
	{ }
	~CPen()
	{
		if(m_hPen != NULL)
			DeleteObject();
	}

	CPen& operator=(HPEN hPen)
	{
		m_hPen = hPen;
		return *this;
	}

	void Attach(HPEN hPen)
	{
		m_hPen = hPen;
	}
	HPEN Detach()
	{
		HPEN hPen = m_hPen;
		m_hPen = NULL;
		return hPen;
	}

	operator HPEN() const { return m_hPen; }

	HPEN CreatePen(int nPenStyle, int nWidth, COLORREF crColor)
	{
		ATLASSERT(m_hPen == NULL);
		m_hPen = ::CreatePen(nPenStyle, nWidth, crColor);
		return m_hPen;
	}
#ifndef UNDER_CE
	HPEN CreatePen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush, int nStyleCount = 0, const DWORD* lpStyle = NULL)
	{
		ATLASSERT(m_hPen == NULL);
		m_hPen = ::ExtCreatePen(nPenStyle, nWidth, pLogBrush, nStyleCount, lpStyle);
		return m_hPen;
	}
#endif //!UNDER_CE
	HPEN CreatePenIndirect(LPLOGPEN lpLogPen)
	{
		ATLASSERT(m_hPen == NULL);
		m_hPen = ::CreatePenIndirect(lpLogPen);
		return m_hPen;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hPen != NULL);
		BOOL bRet = ::DeleteObject(m_hPen);
		if(bRet)
			m_hPen = NULL;
		return bRet;
	}

// Attributes
	int GetLogPen(LOGPEN* pLogPen)
	{
		ATLASSERT(m_hPen != NULL);
		return ::GetObject(m_hPen, sizeof(LOGPEN), pLogPen);
	}
#ifndef UNDER_CE
	int GetExtLogPen(EXTLOGPEN* pLogPen)
	{
		ATLASSERT(m_hPen != NULL);
		return ::GetObject(m_hPen, sizeof(EXTLOGPEN), pLogPen);
	}
#endif //!UNDER_CE
};

/////////////////////////////////////////////////////////////////////////////
// CBrush

class CBrush
{
public:
	HBRUSH m_hBrush;

	CBrush(HBRUSH hBrush = NULL) : m_hBrush(hBrush)
	{ }
	~CBrush()
	{
		if(m_hBrush != NULL)
			DeleteObject();
	}

	CBrush& operator=(HBRUSH hBrush)
	{
		m_hBrush = hBrush;
		return *this;
	}

	void Attach(HBRUSH hBrush)
	{
		m_hBrush = hBrush;
	}
	HBRUSH Detach()
	{
		HBRUSH hBrush = m_hBrush;
		m_hBrush = NULL;
		return hBrush;
	}

	operator HBRUSH() const { return m_hBrush; }

	HBRUSH CreateSolidBrush(COLORREF crColor)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateSolidBrush(crColor);
		return m_hBrush;
	}
#ifndef UNDER_CE
	HBRUSH CreateHatchBrush(int nIndex, COLORREF crColor)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateHatchBrush(nIndex, crColor);
		return m_hBrush;
	}
	HBRUSH CreateBrushIndirect(const LOGBRUSH* lpLogBrush)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateBrushIndirect(lpLogBrush);
		return m_hBrush;
	}
#endif //!UNDER_CE
	HBRUSH CreatePatternBrush(HBITMAP hBitmap)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreatePatternBrush(hBitmap);
		return m_hBrush;
	}
#ifndef UNDER_CE
//REVIEW
	HBRUSH CreateDIBPatternBrush(HGLOBAL hPackedDIB, UINT nUsage)
	{
		ATLASSERT(hPackedDIB != NULL);
		const void* lpPackedDIB = ::GlobalLock(hPackedDIB);
		ATLASSERT(lpPackedDIB != NULL);
		m_hBrush = ::CreateDIBPatternBrushPt(lpPackedDIB, nUsage);
		::GlobalUnlock(hPackedDIB);
		return m_hBrush;
	}
#endif //!UNDER_CE
	HBRUSH CreateDIBPatternBrush(const void* lpPackedDIB, UINT nUsage)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateDIBPatternBrushPt(lpPackedDIB, nUsage);
		return m_hBrush;
	}
	HBRUSH CreateSysColorBrush(int nIndex)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::GetSysColorBrush(nIndex);
		return m_hBrush;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hBrush != NULL);
		BOOL bRet = ::DeleteObject(m_hBrush);
		if(bRet)
			m_hBrush = NULL;
		return bRet;
	}

// Attributes
	int GetLogBrush(LOGBRUSH* pLogBrush)
	{
		ATLASSERT(m_hBrush != NULL);
		return ::GetObject(m_hBrush, sizeof(LOGBRUSH), pLogBrush);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CFont

class CFont
{
public:
	HFONT m_hFont;

	CFont(HFONT hFont = NULL) : m_hFont(hFont)
	{ }
	~CFont()
	{
		if(m_hFont != NULL)
			DeleteObject();
	}

	CFont& operator=(HFONT hFont)
	{
		m_hFont = hFont;
		return *this;
	}

	void Attach(HFONT hFont)
	{
		m_hFont = hFont;
	}
	HFONT Detach()
	{
		HFONT hFont = m_hFont;
		m_hFont = NULL;
		return hFont;
	}

	operator HFONT() const { return m_hFont; }

	HFONT CreateFontIndirect(const LOGFONT* lpLogFont)
	{
		ATLASSERT(m_hFont == NULL);
		m_hFont = ::CreateFontIndirect(lpLogFont);
		return m_hFont;
	}
	HFONT CreateFont(int nHeight, int nWidth, int nEscapement,
			int nOrientation, int nWeight, BYTE bItalic, BYTE bUnderline,
			BYTE cStrikeOut, BYTE nCharSet, BYTE nOutPrecision,
			BYTE nClipPrecision, BYTE nQuality, BYTE nPitchAndFamily,
			LPCTSTR lpszFacename)
	{
		ATLASSERT(m_hFont == NULL);
#ifndef UNDER_CE
		m_hFont = ::CreateFont(nHeight, nWidth, nEscapement,
#else // CE specific
		m_hFont = CreateFont(nHeight, nWidth, nEscapement,
#endif //!UNDER_CE
			nOrientation, nWeight, bItalic, bUnderline, cStrikeOut,
			nCharSet, nOutPrecision, nClipPrecision, nQuality,
			nPitchAndFamily, lpszFacename);
		return m_hFont;
	}
#ifndef UNDER_CE
	HFONT CreatePointFont(int nPointSize, LPCTSTR lpszFaceName, HDC hDC = NULL)
	{
		LOGFONT logFont;
		memset(&logFont, 0, sizeof(LOGFONT));
		logFont.lfCharSet = DEFAULT_CHARSET;
		logFont.lfHeight = nPointSize;
		lstrcpyn(logFont.lfFaceName, lpszFaceName, sizeof(logFont.lfFaceName)/sizeof(TCHAR));
		return CreatePointFontIndirect(&logFont, hDC);
	}
	HFONT CreatePointFontIndirect(const LOGFONT* lpLogFont, HDC hDC = NULL)
	{
		HDC hDC1 = (hDC != NULL) ? hDC : (::GetDC(NULL));

		// convert nPointSize to logical units based on hDC
		LOGFONT logFont = *lpLogFont;
		POINT pt;
		pt.y = ::GetDeviceCaps(hDC1, LOGPIXELSY) * logFont.lfHeight;
		pt.y /= 720;    // 72 points/inch, 10 decipoints/point
		::DPtoLP(hDC1, &pt, 1);
		POINT ptOrg = { 0, 0 };
		::DPtoLP(hDC1, &ptOrg, 1);
		logFont.lfHeight = -abs(pt.y - ptOrg.y);

		if(hDC == NULL)
			::ReleaseDC(NULL, hDC1);

		return CreateFontIndirect(&logFont);
	}
#endif //!UNDER_CE

	BOOL DeleteObject()
	{
		ATLASSERT(m_hFont != NULL);
		BOOL bRet = ::DeleteObject(m_hFont);
		if(bRet)
			m_hFont = NULL;
		return bRet;
	}

// Attributes
	int GetLogFont(LOGFONT* pLogFont)
	{
		ATLASSERT(m_hFont != NULL);
		return ::GetObject(m_hFont, sizeof(LOGFONT), pLogFont);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CBitmap

class CBitmap
{
public:
	HBITMAP m_hBitmap;

	CBitmap(HBITMAP hBitmap = NULL) : m_hBitmap(hBitmap)
	{ }
	~CBitmap()
	{
		if(m_hBitmap != NULL)
			DeleteObject();
	}

	CBitmap& operator=(HBITMAP hBitmap)
	{
		m_hBitmap = hBitmap;
		return *this;
	}

	void Attach(HBITMAP hBitmap)
	{
		m_hBitmap = hBitmap;
	}
	HBITMAP Detach()
	{
		HBITMAP hBitmap = m_hBitmap;
		m_hBitmap = NULL;
		return hBitmap;
	}

	operator HBITMAP() const { return m_hBitmap; }

	HBITMAP LoadBitmap(LPCTSTR lpszResourceName)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), lpszResourceName);
		return m_hBitmap;
	}
	HBITMAP LoadBitmap(UINT nIDResource)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(nIDResource));
		return m_hBitmap;
	}
	HBITMAP LoadOEMBitmap(UINT nIDBitmap) // for OBM_/OCR_/OIC_
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(NULL, MAKEINTRESOURCE(nIDBitmap));
		return m_hBitmap;
	}
	HBITMAP LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateMappedBitmap(_Module.GetResourceInstance(), nIDBitmap, (WORD)nFlags, lpColorMap, nMapSize);
		return m_hBitmap;
	}
	HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitcount, const void* lpBits)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmap(nWidth, nHeight, nPlanes, nBitcount, lpBits);
		return m_hBitmap;
	}
#ifndef UNDER_CE
	HBITMAP CreateBitmapIndirect(LPBITMAP lpBitmap)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmapIndirect(lpBitmap);
		return m_hBitmap;
	}
#endif //!UNDER_CE
	HBITMAP CreateCompatibleBitmap(HDC hDC, int nWidth, int nHeight)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateCompatibleBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}
#ifndef UNDER_CE
	HBITMAP CreateDiscardableBitmap(HDC hDC, int nWidth, int nHeight)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateDiscardableBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}
#endif //!UNDER_CE

	BOOL DeleteObject()
	{
		ATLASSERT(m_hBitmap != NULL);
		BOOL bRet = ::DeleteObject(m_hBitmap);
		if(bRet)
			m_hBitmap = NULL;
		return bRet;
	}

// Attributes
	int GetBitmap(BITMAP* pBitMap)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetObject(m_hBitmap, sizeof(BITMAP), pBitMap);
	}

// Operations
#ifndef UNDER_CE
//REVIEW
	DWORD SetBitmapBits(DWORD dwCount, const void* lpBits)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	BOOL SetBitmapDimension(int nWidth, int nHeight, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetBitmapDimensionEx(m_hBitmap, nWidth, nHeight, lpSize);
	}
	BOOL GetBitmapDimension(LPSIZE lpSize) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetBitmapDimensionEx(m_hBitmap, lpSize);
	}
#endif //!UNDER_CE
};

/////////////////////////////////////////////////////////////////////////////
// CPalette

class CPalette
{
public:
	HPALETTE m_hPalette;

	CPalette(HPALETTE hPalette = NULL) : m_hPalette(hPalette)
	{ }
	~CPalette()
	{
		if(m_hPalette != NULL)
			DeleteObject();
	}

	CPalette& operator=(HPALETTE hPalette)
	{
		m_hPalette = hPalette;
		return *this;
	}

	void Attach(HPALETTE hPalette)
	{
		m_hPalette = hPalette;
	}
	HPALETTE Detach()
	{
		HPALETTE hPalette = m_hPalette;
		m_hPalette = NULL;
		return hPalette;
	}

	operator HPALETTE() const { return m_hPalette; }

	HPALETTE CreatePalette(LPLOGPALETTE lpLogPalette)
	{
		ATLASSERT(m_hPalette == NULL);
		m_hPalette = ::CreatePalette(lpLogPalette);
		return m_hPalette;
	}
#ifndef UNDER_CE
	HPALETTE CreateHalftonePalette(HDC hDC)
	{
		ATLASSERT(m_hPalette == NULL);
		ATLASSERT(hDC != NULL);
		m_hPalette = ::CreateHalftonePalette(hDC);
		return m_hPalette;
	}
#endif //!UNDER_CE

	BOOL DeleteObject()
	{
		ATLASSERT(m_hPalette != NULL);
		BOOL bRet = ::DeleteObject(m_hPalette);
		if(bRet)
			m_hPalette = NULL;
		return bRet;
	}

// Attributes
	int GetEntryCount()
	{
		ATLASSERT(m_hPalette != NULL);
		WORD nEntries;
		::GetObject(m_hPalette, sizeof(WORD), &nEntries);
		return (int)nEntries;
	}
	UINT GetPaletteEntries(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors) const
	{
		ATLASSERT(m_hPalette != NULL);
		return ::GetPaletteEntries(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
	}
	UINT SetPaletteEntries(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)
	{
		ATLASSERT(m_hPalette != NULL);
		return ::SetPaletteEntries(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
	}

// Operations
#ifndef UNDER_CE
	void AnimatePalette(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)
	{
		ATLASSERT(m_hPalette != NULL);
		::AnimatePalette(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
	}
	BOOL ResizePalette(UINT nNumEntries)
	{
		ATLASSERT(m_hPalette != NULL);
		return ::ResizePalette(m_hPalette, nNumEntries);
	}
#endif //!UNDER_CE
	UINT GetNearestPaletteIndex(COLORREF crColor) const
	{
		ATLASSERT(m_hPalette != NULL);
		return ::GetNearestPaletteIndex(m_hPalette, crColor);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CRgn

class CRgn
{
public:
	HRGN m_hRgn;
	CRgn(HRGN hRgn = NULL) : m_hRgn(hRgn)
	{ }
	~CRgn()
	{
		if(m_hRgn != NULL)
			DeleteObject();
	}

	CRgn& operator=(HRGN hRgn)
	{
		m_hRgn = hRgn;
		return *this;
	}

	void Attach(HRGN hRgn)
	{
		m_hRgn = hRgn;
	}
	HRGN Detach()
	{
		HRGN hRgn = m_hRgn;
		m_hRgn = NULL;
		return hRgn;
	}

	operator HRGN() const { return m_hRgn; }

	HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateRectRgn(x1, y1, x2, y2);
		return m_hRgn;
	}
	HRGN CreateRectRgnIndirect(LPCRECT lpRect)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateRectRgnIndirect(lpRect);
		return m_hRgn;
	}
#ifndef UNDER_CE
	HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateEllipticRgn(x1, y1, x2, y2);
		return m_hRgn;
	}
	HRGN CreateEllipticRgnIndirect(LPCRECT lpRect)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateEllipticRgnIndirect(lpRect);
		return m_hRgn;
	}
	HRGN CreatePolygonRgn(LPPOINT lpPoints, int nCount, int nMode)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreatePolygonRgn(lpPoints, nCount, nMode);
		return m_hRgn;
	}
	HRGN CreatePolyPolygonRgn(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount, int nPolyFillMode)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreatePolyPolygonRgn(lpPoints, lpPolyCounts, nCount, nPolyFillMode);
		return m_hRgn;
	}
	HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int x3, int y3)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateRoundRectRgn(x1, y1, x2, y2, x3, y3);
		return m_hRgn;
	}
	HRGN CreateFromPath(HDC hDC)
	{
		ATLASSERT(m_hRgn == NULL);
		ATLASSERT(hDC != NULL);
		m_hRgn = ::PathToRegion(hDC);
		return m_hRgn;
	}
	HRGN CreateFromData(const XFORM* lpXForm, int nCount, const RGNDATA* pRgnData)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::ExtCreateRegion(lpXForm, nCount, pRgnData);
		return m_hRgn;
	}
#endif //!UNDER_CE

	BOOL DeleteObject()
	{
		ATLASSERT(m_hRgn != NULL);
		BOOL bRet = ::DeleteObject(m_hRgn);
		if(bRet)
			m_hRgn = NULL;
		return bRet;
	}

// Operations
	void SetRectRgn(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hRgn != NULL);
		::SetRectRgn(m_hRgn, x1, y1, x2, y2);
	}
	void SetRectRgn(LPCRECT lpRect)
	{
		ATLASSERT(m_hRgn != NULL);
		::SetRectRgn(m_hRgn, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	int CombineRgn(HRGN hRgnSrc1, HRGN hRgnSrc2, int nCombineMode)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::CombineRgn(m_hRgn, hRgnSrc1, hRgnSrc2, nCombineMode);
	}
	int CombineRgn(HRGN hRgnSrc, int nCombineMode)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::CombineRgn(m_hRgn, m_hRgn, hRgnSrc, nCombineMode);
	}
	int CopyRgn(HRGN hRgnSrc)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::CombineRgn(m_hRgn, hRgnSrc, NULL, RGN_COPY);
	}
	BOOL EqualRgn(HRGN hRgn) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::EqualRgn(m_hRgn, hRgn);
	}
	int OffsetRgn(int x, int y)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::OffsetRgn(m_hRgn, x, y);
	}
	int OffsetRgn(POINT point)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::OffsetRgn(m_hRgn, point.x, point.y);
	}
	int GetRgnBox(LPRECT lpRect) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::GetRgnBox(m_hRgn, lpRect);
	}
	BOOL PtInRegion(int x, int y) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::PtInRegion(m_hRgn, x, y);
	}
	BOOL PtInRegion(POINT point) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::PtInRegion(m_hRgn, point.x, point.y);
	}
	BOOL RectInRegion(LPCRECT lpRect) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::RectInRegion(m_hRgn, lpRect);
	}
	int GetRegionData(LPRGNDATA lpRgnData, int nDataSize) const
	{
		ATLASSERT(m_hRgn != NULL);
		return (int)::GetRegionData(m_hRgn, nDataSize, lpRgnData);
	}
};

}; //namespace ATL

#endif // __ATLGDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\atl\atlctl.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCTL_H__
#define __ATLCTL_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atlwin.h>

#include <objsafe.h>
#include <urlmon.h>

#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "urlmon.lib")


#define DECLARE_VIEW_STATUS(statusFlags) \
	DWORD _GetViewStatus() \
	{ \
		return statusFlags; \
	}

// Include GUIDs for the new stock property dialogs contained in the dll MSStkProp.DLL
#include "msstkppg.h"
#include "atliface.h"
#define CLSID_MSStockFont CLSID_StockFontPage
#define CLSID_MSStockColor CLSID_StockColorPage
#define CLSID_MSStockPicture CLSID_StockPicturePage

struct ATL_DRAWINFO
{
	UINT cbSize;
	DWORD dwDrawAspect;
	LONG lindex;
	DVTARGETDEVICE* ptd;
	HDC hicTargetDev;
	HDC hdcDraw;
	LPCRECTL prcBounds; //Rectangle in which to draw
	LPCRECTL prcWBounds; //WindowOrg and Ext if metafile
	BOOL bOptimize;
	BOOL bZoomed;
	BOOL bRectInHimetric;
	SIZEL ZoomNum;      //ZoomX = ZoomNum.cx/ZoomNum.cy
	SIZEL ZoomDen;
};

namespace ATL
{

#pragma pack(push, _ATL_PACKING)

// Forward declarations
//
class ATL_NO_VTABLE CComControlBase;
template <class T, class WinBase> class CComControl;

//////////////////////////////////////////////////////////////////////////////
// CFirePropNotifyEvent


// Helper functions for safely communicating with objects who sink IPropertyNotifySink
class CFirePropNotifyEvent
{
public:
	// Ask any objects sinking the IPropertyNotifySink notification if it is ok to edit a specified property
	static HRESULT FireOnRequestEdit(IUnknown* pUnk, DISPID dispID)
	{
		CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pCPC(pUnk);
		if (!pCPC)
			return S_OK;
		CComPtr<IConnectionPoint> pCP;
		pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
		if (!pCP)
			return S_OK;
		CComPtr<IEnumConnections> pEnum;

		if (FAILED(pCP->EnumConnections(&pEnum)))
			return S_OK;
		CONNECTDATA cd;
		while (pEnum->Next(1, &cd, NULL) == S_OK)
		{
			if (cd.pUnk)
			{
				HRESULT hr = S_OK;
				CComQIPtr<IPropertyNotifySink, &IID_IPropertyNotifySink> pSink(cd.pUnk);
				if (pSink)
					hr = pSink->OnRequestEdit(dispID);
				cd.pUnk->Release();
				if (hr == S_FALSE)
					return S_FALSE;
			}
		}
		return S_OK;
	}
	// Notify any objects sinking the IPropertyNotifySink notification that a property has changed
	static HRESULT FireOnChanged(IUnknown* pUnk, DISPID dispID)
	{
		CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pCPC(pUnk);
		if (!pCPC)
			return S_OK;
		CComPtr<IConnectionPoint> pCP;
		pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
		if (!pCP)
			return S_OK;
		CComPtr<IEnumConnections> pEnum;

		if (FAILED(pCP->EnumConnections(&pEnum)))
			return S_OK;
		CONNECTDATA cd;
		while (pEnum->Next(1, &cd, NULL) == S_OK)
		{
			if (cd.pUnk)
			{
				CComQIPtr<IPropertyNotifySink, &IID_IPropertyNotifySink> pSink(cd.pUnk);
				if (pSink)
					pSink->OnChanged(dispID);
				cd.pUnk->Release();
			}
		}
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// CComControlBase

// Holds the essential data members for an ActiveX control and useful helper functions
class ATL_NO_VTABLE CComControlBase
{
public:
	CComControlBase(HWND& h) : m_hWndCD(h)
	{
		memset(this, 0, sizeof(CComControlBase));
		m_phWndCD = &h;
		m_sizeExtent.cx = 2*2540;
		m_sizeExtent.cy = 2*2540;
		m_sizeNatural = m_sizeExtent;
	}
	~CComControlBase()
	{
		if (m_hWndCD != NULL)
			::DestroyWindow(m_hWndCD);
		ATLTRACE2(atlTraceControls,2,_T("Control Destroyed\n"));
	}

// methods
public:
	// Control helper functions can go here non-virtuals only please

	// Mark the control 'dirty' so the container will save it
	void SetDirty(BOOL bDirty)
	{
		m_bRequiresSave = bDirty;
	}
	// Obtain the dirty state for the control 
	BOOL GetDirty()
	{
		return m_bRequiresSave ? TRUE : FALSE;
	}
	// Get the zoom factor (numerator & denominator) which is factor of the natural extent
	void GetZoomInfo(ATL_DRAWINFO& di);
	// Sends a notification that the moniker for the control has changed
	HRESULT SendOnRename(IMoniker *pmk)
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnRename(pmk);
		return hRes;
	}
	// Sends a notification that the control has just saved its data
	HRESULT SendOnSave()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnSave();
		return hRes;
	}
	// Sends a notification that the control has closed its advisory sinks
	HRESULT SendOnClose()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnClose();
		return hRes;
	}
	// Sends a notification that the control's data has changed
	HRESULT SendOnDataChange(DWORD advf = 0);
	// Sends a notification that the control's representation has changed
	HRESULT SendOnViewChange(DWORD dwAspect, LONG lindex = -1)
	{
		if (m_spAdviseSink)
			m_spAdviseSink->OnViewChange(dwAspect, lindex);
		return S_OK;
	}
	// Sends a notification to the container that the control has received focus
	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if (m_bInPlaceActive)
		{
			CComPtr<IOleObject> pOleObject;
			ControlQueryInterface(IID_IOleObject, (void**)&pOleObject);
			if (pOleObject != NULL)
				pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);
			CComQIPtr<IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
			if (m_bInPlaceActive && spSite != NULL)
				spSite->OnFocus(TRUE);
		}
		bHandled = FALSE;
		return 1;
	}
	LRESULT OnKillFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		CComQIPtr<IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
		if (m_bInPlaceActive && spSite != NULL && !::IsChild(m_hWndCD, ::GetFocus()))
			spSite->OnFocus(FALSE);
		bHandled = FALSE;
		return 1;
	}
	LRESULT OnMouseActivate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		BOOL bUserMode = TRUE;
		HRESULT hRet = GetAmbientUserMode(bUserMode);
		// UI activate if in user mode only
		// allow activation if we can't determine mode
		if (FAILED(hRet) || bUserMode)
		{
			CComPtr<IOleObject> pOleObject;
			ControlQueryInterface(IID_IOleObject, (void**)&pOleObject);
			if (pOleObject != NULL)
				pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);
		}
		bHandled = FALSE;
		return 1;
	}
	BOOL PreTranslateAccelerator(LPMSG /*pMsg*/, HRESULT& /*hRet*/)
	{
		return FALSE;
	}

	HRESULT GetAmbientProperty(DISPID dispid, VARIANT& var)
	{
		HRESULT hRes = E_FAIL;
		if (m_spAmbientDispatch.p != NULL)
			hRes = m_spAmbientDispatch.GetProperty(dispid, &var);
		return hRes;
	}
	HRESULT GetAmbientAppearance(short& nAppearance)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_APPEARANCE, var);
		ATLASSERT(var.vt == VT_I2 || var.vt == VT_UI2 || var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		nAppearance = var.iVal;
		return hRes;
	}
	HRESULT GetAmbientBackColor(OLE_COLOR& BackColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_BACKCOLOR, var);
		ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		BackColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientDisplayName(BSTR& bstrDisplayName)
	{
		CComVariant var;
		if (bstrDisplayName)
		{
			SysFreeString(bstrDisplayName);
			bstrDisplayName = NULL;
		}
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME, var);
		if (SUCCEEDED(hRes))
		{
			if (var.vt != VT_BSTR)
				return E_FAIL;
			bstrDisplayName = var.bstrVal;
			var.vt = VT_EMPTY;
			var.bstrVal = NULL;
		}
		return hRes;
	}
	HRESULT GetAmbientFont(IFont** ppFont)
	{
		// caller MUST Release the font!
		if (ppFont == NULL)
			return E_POINTER;
		*ppFont = NULL;
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var);
		ATLASSERT((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes));
		if (SUCCEEDED(hRes) && var.pdispVal)
		{
			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
				hRes = var.pdispVal->QueryInterface(IID_IFont, (void**)ppFont);
			else
				hRes = DISP_E_BADVARTYPE;
		}
		return hRes;
	}
	HRESULT GetAmbientFontDisp(IFontDisp** ppFont)
	{
		// caller MUST Release the font!
		if (ppFont == NULL)
			return E_POINTER;
		*ppFont = NULL;
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var);
		ATLASSERT((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes));
		if (SUCCEEDED(hRes) && var.pdispVal)
		{
			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
				hRes = var.pdispVal->QueryInterface(IID_IFontDisp, (void**)ppFont);
			else
				hRes = DISP_E_BADVARTYPE;
		}
		return hRes;
	}
	HRESULT GetAmbientForeColor(OLE_COLOR& ForeColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FORECOLOR, var);
		ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		ForeColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientLocaleID(LCID& lcid)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_LOCALEID, var);
		ATLASSERT((var.vt == VT_UI4 || var.vt == VT_I4) || FAILED(hRes));
		lcid = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientScaleUnits(BSTR& bstrScaleUnits)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SCALEUNITS, var);
		ATLASSERT(var.vt == VT_BSTR || FAILED(hRes));
		bstrScaleUnits = var.bstrVal;
		return hRes;
	}
	HRESULT GetAmbientTextAlign(short& nTextAlign)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_TEXTALIGN, var);
		ATLASSERT(var.vt == VT_I2 || FAILED(hRes));
		nTextAlign = var.iVal;
		return hRes;
	}
	HRESULT GetAmbientUserMode(BOOL& bUserMode)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bUserMode = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientUIDead(BOOL& bUIDead)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_UIDEAD, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bUIDead = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientShowGrabHandles(BOOL& bShowGrabHandles)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWGRABHANDLES, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bShowGrabHandles = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientShowHatching(BOOL& bShowHatching)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWHATCHING, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bShowHatching = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientMessageReflect(BOOL& bMessageReflect)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bMessageReflect = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientAutoClip(BOOL& bAutoClip)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_AUTOCLIP, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bAutoClip = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientDisplayAsDefault(BOOL& bDisplaysDefault)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYASDEFAULT, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bDisplaysDefault = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientSupportsMnemonics(BOOL& bSupportMnemonics)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SUPPORTSMNEMONICS, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bSupportMnemonics = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientPalette(HPALETTE& hPalette)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_PALETTE, var);
#ifdef _WIN64
		ATLASSERT(var.vt == VT_I8 || var.vt == VT_UI8 || FAILED(hRes));
		hPalette = *(HPALETTE*)&var.dblVal;
#else
		ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		hPalette = reinterpret_cast<HPALETTE>(var.lVal);
#endif
		return hRes;
	}

	HRESULT InternalGetSite(REFIID riid, void** ppUnkSite)
	{
		ATLASSERT(ppUnkSite != NULL);
		if (ppUnkSite == NULL)
			return E_POINTER;
		if (m_spClientSite == NULL)
		{
			*ppUnkSite = NULL;
			return S_OK;
		}
		return m_spClientSite->QueryInterface(riid, ppUnkSite);
	}

	BOOL DoesVerbUIActivate(LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
				b = TRUE;
				break;
		}
		// if no ambient dispatch then in old style OLE container
		if (DoesVerbActivate(iVerb) && m_spAmbientDispatch.p == NULL)
			b = TRUE;
		return b;
	}

	BOOL DoesVerbActivate(LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
			case OLEIVERB_SHOW:
			case OLEIVERB_INPLACEACTIVATE:
				b = TRUE;
				break;
		}
		return b;
	}

	BOOL SetControlFocus(BOOL bGrab);
	HRESULT IQuickActivate_QuickActivate(QACONTAINER *pQACont,
		QACONTROL *pQACtrl);
	HRESULT DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent);
	HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL);

	HRESULT IOleObject_SetClientSite(IOleClientSite *pClientSite);
	HRESULT IOleObject_GetClientSite(IOleClientSite **ppClientSite);
	HRESULT IOleObject_Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection);
	HRESULT IOleObject_Close(DWORD dwSaveOption);
	HRESULT IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel);
	HRESULT IOleInPlaceObject_InPlaceDeactivate(void);
	HRESULT IOleInPlaceObject_UIDeactivate(void);
	HRESULT IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip);
	HRESULT IViewObject_Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
		DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
		LPCRECTL prcBounds, LPCRECTL prcWBounds);
	HRESULT IDataObject_GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);

	HRESULT FireViewChange();
	LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);

	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos) = 0;
	virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv) = 0;
	virtual HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);
	virtual HRESULT OnDraw(ATL_DRAWINFO& /*di*/)
	{
		return S_OK;
	}


// Attributes
public:
	CComPtr<IOleInPlaceSiteWindowless> m_spInPlaceSite;
	CComPtr<IDataAdviseHolder> m_spDataAdviseHolder;
	CComPtr<IOleAdviseHolder> m_spOleAdviseHolder;
	CComPtr<IOleClientSite> m_spClientSite;
	CComPtr<IAdviseSink> m_spAdviseSink;
	CComDispatchDriver m_spAmbientDispatch;

	SIZE m_sizeNatural; //unscaled size in himetric
	SIZE m_sizeExtent;  //current extents in himetric
	RECT m_rcPos; // position in pixels
#pragma warning(disable: 4510 4610) // unnamed union
	union
	{
		HWND& m_hWndCD;
		HWND* m_phWndCD;
	};
#pragma warning(default: 4510 4610)
	union
	{
		// m_nFreezeEvents is the only one actually used
		int m_nFreezeEvents; // count of freezes versus thaws

		// These are here to make stock properties work
		IPictureDisp* m_pMouseIcon;
		IPictureDisp* m_pPicture;
		IFontDisp* m_pFont;
		OLE_COLOR m_clrBackColor;
		OLE_COLOR m_clrBorderColor;
		OLE_COLOR m_clrFillColor;
		OLE_COLOR m_clrForeColor;
		BSTR m_bstrText;
		BSTR m_bstrCaption;
		BOOL m_bValid;
		BOOL m_bTabStop;
		BOOL m_bBorderVisible;
		BOOL m_bEnabled;
		LONG m_nBackStyle;
		LONG m_nBorderStyle;
		LONG m_nBorderWidth;
		LONG m_nDrawMode;
		LONG m_nDrawStyle;
		LONG m_nDrawWidth;
		LONG m_nFillStyle;
		SHORT m_nAppearance;
		LONG m_nMousePointer;
		LONG m_nReadyState;
	};

	unsigned m_bNegotiatedWnd:1;
	unsigned m_bWndLess:1;
	unsigned m_bInPlaceActive:1;
	unsigned m_bUIActive:1;
	unsigned m_bUsingWindowRgn:1;
	unsigned m_bInPlaceSiteEx:1;
	unsigned m_bWindowOnly:1;
	unsigned m_bRequiresSave:1;
	unsigned m_bWasOnceWindowless:1;
	unsigned m_bAutoSize:1; //SetExtent fails if size doesn't match existing
	unsigned m_bRecomposeOnResize:1; //implies OLEMISC_RECOMPOSEONRESIZE
	unsigned m_bResizeNatural:1;  //resize natural extent on SetExtent
	unsigned m_bDrawFromNatural:1; //instead of m_sizeExtent
	unsigned m_bDrawGetDataInHimetric:1; //instead of pixels

	DECLARE_VIEW_STATUS(VIEWSTATUS_OPAQUE)
};

inline HRESULT CComControlBase::IQuickActivate_QuickActivate(QACONTAINER *pQACont,
	QACONTROL *pQACtrl)
{
	ATLASSERT(pQACont != NULL);
	ATLASSERT(pQACtrl != NULL);
	if (!pQACont || !pQACtrl)
		return E_POINTER;

	HRESULT hRes;
	ULONG uCB = pQACtrl->cbSize;
	memset(pQACtrl, 0, uCB);
	pQACtrl->cbSize = uCB;

	// get all interfaces we are going to need
	CComPtr<IOleObject> pOO;
	ControlQueryInterface(IID_IOleObject, (void**)&pOO);
	CComPtr<IViewObjectEx> pVOEX;
	ControlQueryInterface(IID_IViewObjectEx, (void**)&pVOEX);
	CComPtr<IPointerInactive> pPI;
	ControlQueryInterface(IID_IPointerInactive, (void**)&pPI);
	CComPtr<IProvideClassInfo2> pPCI;
	ControlQueryInterface(IID_IProvideClassInfo2, (void**)&pPCI);

	if (pOO == NULL || pVOEX == NULL)
		return E_FAIL;

	hRes = pOO->SetClientSite(pQACont->pClientSite);
    if (FAILED(hRes)) {
        return hRes;
    }

	if (pQACont->pAdviseSink != NULL)
	{
		ATLTRACE2(atlTraceControls,2,_T("Setting up IOleObject Advise\n"));
		pVOEX->SetAdvise(DVASPECT_CONTENT, 0, pQACont->pAdviseSink);
	}

	CComPtr<IConnectionPointContainer> pCPC;
	ControlQueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	if (pQACont->pPropertyNotifySink)
	{
		ATLTRACE2(atlTraceControls,2,_T("Setting up PropNotify CP\n"));
		CComPtr<IConnectionPoint> pCP;
		if (pCPC != NULL)
		{
			hRes = pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
			if (SUCCEEDED(hRes))
				pCP->Advise(pQACont->pPropertyNotifySink, &pQACtrl->dwPropNotifyCookie);
		}
	}

	if (pPCI)
	{
		GUID iidDefaultSrc;
		if (SUCCEEDED(pPCI->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID,
			&iidDefaultSrc)))
		{
			if (pQACont->pUnkEventSink)
			{
				ATLTRACE2(atlTraceControls,2,_T("Setting up Default Out Going Interface\n"));
				CComPtr<IConnectionPoint> pCP;
				if (pCPC != NULL)
				{
					hRes = pCPC->FindConnectionPoint(iidDefaultSrc, &pCP);
					if (SUCCEEDED(hRes))
						pCP->Advise(pQACont->pUnkEventSink, &pQACtrl->dwEventCookie);
				}
			}
		}
	}
	// give information to container
	if (pOO != NULL)
		pOO->GetMiscStatus(DVASPECT_CONTENT, &pQACtrl->dwMiscStatus);

	if (pVOEX != NULL)
		pVOEX->GetViewStatus(&pQACtrl->dwViewStatus);

	if (pPI != NULL)
		pPI->GetActivationPolicy(&pQACtrl->dwPointerActivationPolicy);
	return S_OK;
}

inline BOOL CComControlBase::SetControlFocus(BOOL bGrab)
{
	if (m_bWndLess)
	{
		if (!m_bUIActive && bGrab)
			if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE)))
				return FALSE;

		return (m_spInPlaceSite->SetFocus(bGrab) == S_OK);
	}
	else
	{
		// we've got a window.
		//
		if (m_bInPlaceActive)
		{
			HWND hwnd = (bGrab) ? m_hWndCD : ::GetParent(m_hWndCD);
			if (!m_bUIActive && bGrab)
				return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));
			else
			{
				if (!::IsChild(hwnd, ::GetFocus()))
					::SetFocus(hwnd);
				return TRUE;
			}
		}
	}
	return FALSE;
}

inline HRESULT CComControlBase::DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent)
{
	HRESULT hr = S_OK;
	CComQIPtr <ISpecifyPropertyPages, &IID_ISpecifyPropertyPages> spPages;
	CComQIPtr <IOleObject, &IID_IOleObject> spObj;
	CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);

	if (spSite)
	{
		hr = spSite->ShowPropertyFrame();
		if (SUCCEEDED(hr))
			return hr;
	}

	CComPtr<IUnknown> pUnk;
	ControlQueryInterface(IID_IUnknown, (void**)&pUnk);
	ATLASSERT(pUnk != NULL);
	CAUUID pages;
	spPages = pUnk;
	if (spPages)
	{
		hr = spPages->GetPages(&pages);
		if (SUCCEEDED(hr))
		{
			spObj = pUnk;
			if (spObj)
			{
				LPOLESTR szTitle = NULL;

				spObj->GetUserType(USERCLASSTYPE_SHORT, &szTitle);

				LCID lcid;
				if (FAILED(GetAmbientLocaleID(lcid)))
					lcid = LOCALE_USER_DEFAULT;

				hr = OleCreatePropertyFrame(hwndParent, m_rcPos.top, m_rcPos.left, szTitle,
					1, &pUnk.p, pages.cElems, pages.pElems, lcid, 0, 0);

				CoTaskMemFree(szTitle);
			}
			else
			{
				hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
			}
			CoTaskMemFree(pages.pElems);
		}
	}
	else
	{
		hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
	}

	return hr;
}

inline HRESULT CComControlBase::InPlaceActivate(LONG iVerb, const RECT* /*prcPosRect*/)
{
	HRESULT hr;

	if (m_spClientSite == NULL)
		return S_OK;

	CComPtr<IOleInPlaceObject> pIPO;
	ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	ATLASSERT(pIPO != NULL);

	if (!m_bNegotiatedWnd)
	{
		if (!m_bWindowOnly)
			// Try for windowless site
			hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spInPlaceSite);

		if (m_spInPlaceSite)
		{
			m_bInPlaceSiteEx = TRUE;
			// CanWindowlessActivate returns S_OK or S_FALSE
			if ( m_spInPlaceSite->CanWindowlessActivate() == S_OK )
			{
				m_bWndLess = TRUE;
				m_bWasOnceWindowless = TRUE;
			}
			else
			{
				m_bWndLess = FALSE;
			}
		}
		else
		{
			m_spClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spInPlaceSite);
			if (m_spInPlaceSite)
				m_bInPlaceSiteEx = TRUE;
			else
				hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spInPlaceSite);
		}
	}

	ATLASSERT(m_spInPlaceSite);
	if (!m_spInPlaceSite)
		return E_FAIL;

	m_bNegotiatedWnd = TRUE;

	if (!m_bInPlaceActive)
	{

		BOOL bNoRedraw = FALSE;
		if (m_bWndLess)
			m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, ACTIVATE_WINDOWLESS);
		else
		{
			if (m_bInPlaceSiteEx)
				m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, 0);
			else
			{
				hr = m_spInPlaceSite->CanInPlaceActivate();
				// CanInPlaceActivate returns S_FALSE or S_OK
				if (FAILED(hr))
					return hr;
				if ( hr != S_OK )
				{
				   // CanInPlaceActivate returned S_FALSE.
				   return( E_FAIL );
				}
				m_spInPlaceSite->OnInPlaceActivate();
			}
		}
	}

	m_bInPlaceActive = TRUE;

	// get location in the parent window,
	// as well as some information about the parent
	//
	OLEINPLACEFRAMEINFO frameInfo;
	RECT rcPos, rcClip;
	CComPtr<IOleInPlaceFrame> spInPlaceFrame;
	CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
	frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
	HWND hwndParent;
	if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)
	{
		m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
			&spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);

		if (!m_bWndLess)
		{
			if (m_hWndCD)
			{
				ShowWindow(m_hWndCD, SW_SHOW);
				if (!::IsChild(m_hWndCD, ::GetFocus()))
					::SetFocus(m_hWndCD);
			}
			else
			{
				HWND h = CreateControlWindow(hwndParent, rcPos);
				ATLASSERT(h != NULL);	// will assert if creation failed
				ATLASSERT(h == m_hWndCD);
				h;	// avoid unused warning
			}
		}

		pIPO->SetObjectRects(&rcPos, &rcClip);
	}

	CComPtr<IOleInPlaceActiveObject> spActiveObject;
	ControlQueryInterface(IID_IOleInPlaceActiveObject, (void**)&spActiveObject);

	// Gone active by now, take care of UIACTIVATE
	if (DoesVerbUIActivate(iVerb))
	{
		if (!m_bUIActive)
		{
			m_bUIActive = TRUE;
			hr = m_spInPlaceSite->OnUIActivate();
			if (FAILED(hr))
				return hr;

			SetControlFocus(TRUE);
			// set ourselves up in the host.
			//
			if (spActiveObject)
			{
				if (spInPlaceFrame)
					spInPlaceFrame->SetActiveObject(spActiveObject, NULL);
				if (spInPlaceUIWindow)
					spInPlaceUIWindow->SetActiveObject(spActiveObject, NULL);
			}

			if (spInPlaceFrame)
				spInPlaceFrame->SetBorderSpace(NULL);
			if (spInPlaceUIWindow)
				spInPlaceUIWindow->SetBorderSpace(NULL);
		}
	}

	m_spClientSite->ShowObject();

	return S_OK;
}

inline HRESULT CComControlBase::SendOnDataChange(DWORD advf)
{
	HRESULT hRes = S_OK;
	if (m_spDataAdviseHolder)
	{
		CComPtr<IDataObject> pdo;
		if (SUCCEEDED(ControlQueryInterface(IID_IDataObject, (void**)&pdo)))
			hRes = m_spDataAdviseHolder->SendOnDataChange(pdo, 0, advf);
	}
	return hRes;
}

inline HRESULT CComControlBase::IOleObject_SetClientSite(IOleClientSite *pClientSite)
{
	ATLASSERT(pClientSite == NULL || m_spClientSite == NULL);
	m_spClientSite = pClientSite;
	m_spAmbientDispatch.Release();
	if (m_spClientSite != NULL)
	{
		m_spClientSite->QueryInterface(IID_IDispatch,
			(void**) &m_spAmbientDispatch.p);
	}
	return S_OK;
}

inline HRESULT CComControlBase::IOleObject_GetClientSite(IOleClientSite **ppClientSite)
{
	ATLASSERT(ppClientSite);
	if (ppClientSite == NULL)
		return E_POINTER;

	*ppClientSite = m_spClientSite;
	if (m_spClientSite != NULL)
		m_spClientSite.p->AddRef();
	return S_OK;
}

inline HRESULT CComControlBase::IOleObject_Advise(IAdviseSink *pAdvSink,
	DWORD *pdwConnection)
{
	HRESULT hr = S_OK;
	if (m_spOleAdviseHolder == NULL)
		hr = CreateOleAdviseHolder(&m_spOleAdviseHolder);
	if (SUCCEEDED(hr))
		hr = m_spOleAdviseHolder->Advise(pAdvSink, pdwConnection);
	return hr;
}

inline HRESULT CComControlBase::IOleObject_Close(DWORD dwSaveOption)
{
	CComPtr<IOleInPlaceObject> pIPO;
	ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	ATLASSERT(pIPO != NULL);
	if (m_hWndCD)
	{
		if (m_spClientSite)
			m_spClientSite->OnShowWindow(FALSE);
	}

	if (m_bInPlaceActive)
	{
		HRESULT hr = pIPO->InPlaceDeactivate();
		if (FAILED(hr))
			return hr;
		ATLASSERT(!m_bInPlaceActive);
	}
	if (m_hWndCD)
	{
		ATLTRACE2(atlTraceControls,2,_T("Destroying Window\n"));
		if (::IsWindow(m_hWndCD))
			DestroyWindow(m_hWndCD);
		m_hWndCD = NULL;
	}

	// handle the save flag.
	//
	if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY ||
		dwSaveOption == OLECLOSE_PROMPTSAVE) && m_bRequiresSave)
	{
		if (m_spClientSite)
			m_spClientSite->SaveObject();
		SendOnSave();
	}

	m_spInPlaceSite.Release();
	m_bNegotiatedWnd = FALSE;
	m_bWndLess = FALSE;
	m_bInPlaceSiteEx = FALSE;
	m_spAdviseSink.Release();
	return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_InPlaceDeactivate(void)
{
	CComPtr<IOleInPlaceObject> pIPO;
	ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	ATLASSERT(pIPO != NULL);

	if (!m_bInPlaceActive)
		return S_OK;
	pIPO->UIDeactivate();

	m_bInPlaceActive = FALSE;

	// if we have a window, tell it to go away.
	//
	if (m_hWndCD)
	{
		ATLTRACE2(atlTraceControls,2,_T("Destroying Window\n"));
		if (::IsWindow(m_hWndCD))
			DestroyWindow(m_hWndCD);
		m_hWndCD = NULL;
	}

	if (m_spInPlaceSite)
		m_spInPlaceSite->OnInPlaceDeactivate();

	return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_UIDeactivate(void)
{
	// if we're not UIActive, not much to do.
	//
	if (!m_bUIActive)
		return S_OK;

	m_bUIActive = FALSE;

	// notify frame windows, if appropriate, that we're no longer ui-active.
	//
	CComPtr<IOleInPlaceFrame> spInPlaceFrame;
	CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
	OLEINPLACEFRAMEINFO frameInfo;
	frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
	RECT rcPos, rcClip;

	HWND hwndParent; 
	// This call to GetWindow is a fix for Delphi
	if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)
	{
		m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
			&spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);
		if (spInPlaceUIWindow)
			spInPlaceUIWindow->SetActiveObject(NULL, NULL);
		if (spInPlaceFrame)
			spInPlaceFrame->SetActiveObject(NULL, NULL);
	}
	// we don't need to explicitly release the focus here since somebody
	// else grabbing the focus is what is likely to cause us to get lose it
	//
	m_spInPlaceSite->OnUIDeactivate(FALSE);

	return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip)
{
	if (prcPos == NULL || prcClip == NULL)
		return E_POINTER;

	m_rcPos = *prcPos;
	if (m_hWndCD)
	{
		// the container wants us to clip, so figure out if we really
		// need to
		//
		RECT rcIXect;
		BOOL b = IntersectRect(&rcIXect, prcPos, prcClip);
		HRGN tempRgn = NULL;
		if (b && !EqualRect(&rcIXect, prcPos))
		{
			OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));
			tempRgn = CreateRectRgnIndirect(&rcIXect);
		}

		SetWindowRgn(m_hWndCD, tempRgn, TRUE);

		// set our control's location, but don't change it's size at all
		// [people for whom zooming is important should set that up here]
		//
		SIZEL size = {prcPos->right - prcPos->left, prcPos->bottom - prcPos->top};
		SetWindowPos(m_hWndCD, NULL, prcPos->left,
					 prcPos->top, size.cx, size.cy, SWP_NOZORDER | SWP_NOACTIVATE);
	}

	return S_OK;
}

inline HRESULT CComControlBase::IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
	if (dwDrawAspect != DVASPECT_CONTENT)
		return DV_E_DVASPECT;
	if (psizel == NULL)
		return E_POINTER;

	BOOL bSizeMatchesNatural =
		memcmp(psizel, &m_sizeNatural, sizeof(SIZE)) == 0;

	if (m_bAutoSize) //object can't do any other size
		return (bSizeMatchesNatural) ? S_OK : E_FAIL;

	BOOL bResized = FALSE;
	if (memcmp(psizel, &m_sizeExtent, sizeof(SIZE)) != 0)
	{
		m_sizeExtent = *psizel;
		bResized = TRUE;
	}
	if (m_bResizeNatural && !bSizeMatchesNatural)
	{
		m_sizeNatural = *psizel;
		bResized = TRUE;
	}

	if (m_bRecomposeOnResize && bResized)
	{
		SendOnDataChange();
		FireViewChange();
	}
	return S_OK;
}

inline HRESULT CComControlBase::IViewObject_Draw(DWORD dwDrawAspect, LONG lindex,
	void *pvAspect, DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
	LPCRECTL prcBounds, LPCRECTL prcWBounds)
{
	ATLTRACE2(atlTraceControls,2,_T("Draw dwDrawAspect=%x lindex=%d ptd=%x hic=%x hdc=%x\n"),
		dwDrawAspect, lindex, ptd, hicTargetDev, hdcDraw);
#ifdef _DEBUG
	if (prcBounds == NULL)
		ATLTRACE2(atlTraceControls,2,_T("\tprcBounds=NULL\n"));
	else
		ATLTRACE2(atlTraceControls,2,_T("\tprcBounds=%d,%d,%d,%d\n"), prcBounds->left,
			prcBounds->top, prcBounds->right, prcBounds->bottom);
	if (prcWBounds == NULL)
		ATLTRACE2(atlTraceControls,2,_T("\tprcWBounds=NULL\n"));
	else
		ATLTRACE2(atlTraceControls,2,_T("\tprcWBounds=%d,%d,%d,%d\n"), prcWBounds->left,
			prcWBounds->top, prcWBounds->right, prcWBounds->bottom);
#endif

	if (prcBounds == NULL)
	{
		if (!m_bWndLess)
			return E_INVALIDARG;
		prcBounds = (RECTL*)&m_rcPos;
	}

	// support the aspects required for multi-pass drawing
	switch (dwDrawAspect)
	{
		case DVASPECT_CONTENT:
		case DVASPECT_OPAQUE:
		case DVASPECT_TRANSPARENT:
			break;
		default:
			ATLASSERT(FALSE);
			return DV_E_DVASPECT;
			break;
	}

	// make sure nobody forgets to do this
	if (ptd == NULL)
		hicTargetDev = NULL;

	BOOL bOptimize = FALSE;
	if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb >= sizeof(DVASPECTINFO))
		bOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE);

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = dwDrawAspect;
	di.lindex = lindex;
	di.ptd = ptd;
	di.hicTargetDev = hicTargetDev;
	di.hdcDraw = hdcDraw;
	di.prcBounds = prcBounds;
	di.prcWBounds = prcWBounds;
	di.bOptimize = bOptimize;
	return OnDrawAdvanced(di);
}

inline HRESULT CComControlBase::IDataObject_GetData(FORMATETC *pformatetcIn,
	STGMEDIUM *pmedium)
{
	if (pmedium == NULL)
		return E_POINTER;
	memset(pmedium, 0, sizeof(STGMEDIUM));
	ATLTRACE2(atlTraceControls,2,_T("Format = %x\n"), pformatetcIn->cfFormat);
	ATLTRACE2(atlTraceControls,2,_T("TYMED = %x\n"), pformatetcIn->tymed);

	if ((pformatetcIn->tymed & TYMED_MFPICT) == 0)
		return DATA_E_FORMATETC;

	SIZEL sizeMetric, size;
	if (m_bDrawFromNatural)
		sizeMetric = m_sizeNatural;
	else
		sizeMetric = m_sizeExtent;
	if (!m_bDrawGetDataInHimetric)
		AtlHiMetricToPixel(&sizeMetric, &size);
	else
		size = sizeMetric;
	RECTL rectl = {0 ,0, size.cx, size.cy};

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = DVASPECT_CONTENT;
	di.lindex = -1;
	di.ptd = NULL;
	di.hicTargetDev = NULL;
	di.prcBounds = &rectl;
	di.prcWBounds = &rectl;
	di.bOptimize = TRUE; //we do a SaveDC/RestoreDC
	di.bRectInHimetric = m_bDrawGetDataInHimetric;
	// create appropriate memory metafile DC
	di.hdcDraw = CreateMetaFile(NULL);

	// create attribute DC according to pformatetcIn->ptd

	SaveDC(di.hdcDraw);
	SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
	SetWindowExtEx(di.hdcDraw, rectl.right, rectl.bottom, NULL);
	OnDrawAdvanced(di);
	RestoreDC(di.hdcDraw, -1);

	HMETAFILE hMF = CloseMetaFile(di.hdcDraw);
	if (hMF == NULL)
		return E_UNEXPECTED;

	HGLOBAL hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, sizeof(METAFILEPICT));

	if (NULL==hMem)
	{
		DeleteMetaFile(hMF);
		return ResultFromScode(STG_E_MEDIUMFULL);
	}

	LPMETAFILEPICT pMF=(LPMETAFILEPICT)GlobalLock(hMem);
	pMF->hMF=hMF;
	pMF->mm=MM_ANISOTROPIC;
	pMF->xExt=sizeMetric.cx;
	pMF->yExt=sizeMetric.cy;
	GlobalUnlock(hMem);

	pmedium->tymed = TYMED_MFPICT;
	pmedium->hGlobal = hMem;
	pmedium->pUnkForRelease = NULL;

	return S_OK;
}

inline HRESULT CComControlBase::FireViewChange()
{
	if (m_bInPlaceActive)
	{
		// Active
		if (m_hWndCD != NULL)
			::InvalidateRect(m_hWndCD, NULL, TRUE); // Window based
		else if (m_spInPlaceSite != NULL)
			m_spInPlaceSite->InvalidateRect(NULL, TRUE); // Windowless
	}
	else // Inactive
		SendOnViewChange(DVASPECT_CONTENT);
	return S_OK;
}

inline void CComControlBase::GetZoomInfo(ATL_DRAWINFO& di)
{
	const RECTL& rcPos = *di.prcBounds;
	SIZEL sizeDen;
	if (m_bDrawFromNatural)
		sizeDen = m_sizeNatural;
	else
		sizeDen = m_sizeExtent;
	if (!di.bRectInHimetric)
		AtlHiMetricToPixel(&sizeDen, &sizeDen);
	SIZEL sizeNum = {rcPos.right-rcPos.left, rcPos.bottom-rcPos.top};
	di.ZoomNum.cx = sizeNum.cx;
	di.ZoomNum.cy = sizeNum.cy;
	di.ZoomDen.cx = sizeDen.cx;
	di.ZoomDen.cy = sizeDen.cy;
	if (sizeDen.cx == 0 || sizeDen.cy == 0 ||
		sizeNum.cx == 0 || sizeNum.cy == 0)
	{
		di.ZoomNum.cx = di.ZoomNum.cy = di.ZoomDen.cx = di.ZoomDen.cy = 1;
		di.bZoomed = FALSE;
	}
	else if (sizeNum.cx != sizeDen.cx || sizeNum.cy != sizeDen.cy)
		di.bZoomed = TRUE;
	else
		di.bZoomed = FALSE;
}

inline HRESULT CComControlBase::OnDrawAdvanced(ATL_DRAWINFO& di)
{
	BOOL bDeleteDC = FALSE;
	if (di.hicTargetDev == NULL)
	{
		di.hicTargetDev = AtlCreateTargetDC(di.hdcDraw, di.ptd);
		bDeleteDC = (di.hicTargetDev != di.hdcDraw);
	}
	RECTL rectBoundsDP = *di.prcBounds;
	BOOL bMetafile = GetDeviceCaps(di.hdcDraw, TECHNOLOGY) == DT_METAFILE;
	if (!bMetafile)
	{
		::LPtoDP(di.hicTargetDev, (LPPOINT)&rectBoundsDP, 2);
		SaveDC(di.hdcDraw);
		SetMapMode(di.hdcDraw, MM_TEXT);
		SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
		SetViewportOrgEx(di.hdcDraw, 0, 0, NULL);
		di.bOptimize = TRUE; //since we save the DC we can do this
	}
	di.prcBounds = &rectBoundsDP;
	GetZoomInfo(di);

	HRESULT hRes = OnDraw(di);
	if (bDeleteDC)
		::DeleteDC(di.hicTargetDev);
	if (!bMetafile)
		RestoreDC(di.hdcDraw, -1);
	return hRes;
}

inline LRESULT CComControlBase::OnPaint(UINT /* uMsg */, WPARAM wParam,
	LPARAM /* lParam */, BOOL& /* lResult */)
{
	RECT rc;
	PAINTSTRUCT ps;

	HDC hdc = (wParam != NULL) ? (HDC)wParam : ::BeginPaint(m_hWndCD, &ps);
	if (hdc == NULL)
		return 0;
	::GetClientRect(m_hWndCD, &rc);

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = DVASPECT_CONTENT;
	di.lindex = -1;
	di.hdcDraw = hdc;
	di.prcBounds = (LPCRECTL)&rc;

	OnDrawAdvanced(di);
	if (wParam == NULL)
		::EndPaint(m_hWndCD, &ps);
	return 0;
}

template <class T, class WinBase =  CWindowImpl< T > >
class ATL_NO_VTABLE CComControl :  public CComControlBase, public WinBase
{
public:
	CComControl() : CComControlBase(m_hWnd) {}
	HRESULT FireOnRequestEdit(DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(pT->GetUnknown(), dispID);
	}
	HRESULT FireOnChanged(DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(pT->GetUnknown(), dispID);
	}
	virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv)
	{
		T* pT = static_cast<T*>(this);
		return pT->_InternalQueryInterface(iid, ppv);
	}
	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
	{
		T* pT = static_cast<T*>(this);
		return pT->Create(hWndParent, rcPos);
	}

	typedef CComControl< T, WinBase >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_PAINT, CComControlBase::OnPaint)
		MESSAGE_HANDLER(WM_SETFOCUS, CComControlBase::OnSetFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, CComControlBase::OnKillFocus)
		MESSAGE_HANDLER(WM_MOUSEACTIVATE, CComControlBase::OnMouseActivate)
	END_MSG_MAP()
};

//////////////////////////////////////////////////////////////////////////////
// CComCompositeControl

#ifndef _ATL_NO_HOSTING
template <class T>
class CComCompositeControl : public CComControl< T, CAxDialogImpl< T > >
{
public:
	CComCompositeControl()
	{
		m_hbrBackground = NULL;
	}
	~CComCompositeControl()
	{
		DeleteObject(m_hbrBackground);
	}
	HRESULT AdviseSinkMap(bool bAdvise)
	{
		if(!bAdvise && m_hWnd == NULL)
		{
			// window is gone, controls are already unadvised
			ATLTRACE2(atlTraceControls, 1, _T("CComCompositeControl::AdviseSinkMap called after the window was destroyed\n"));
			return S_OK;
		}
		T* pT = static_cast<T*>(this);
		return AtlAdviseSinkMap(pT, bAdvise);
	}
	HBRUSH m_hbrBackground;
	HRESULT SetBackgroundColorFromAmbient()
	{
		if (m_hbrBackground != NULL)
		{
			DeleteObject(m_hbrBackground);
			m_hbrBackground = NULL;
		}
		OLE_COLOR clr;
		HRESULT hr = GetAmbientBackColor(clr);
		if (SUCCEEDED(hr))
		{
			COLORREF rgb;
			::OleTranslateColor(clr, NULL, &rgb);
			m_hbrBackground = ::CreateSolidBrush(rgb);
			EnumChildWindows(m_hWnd, (WNDENUMPROC)BackgroundColorEnumProc, (LPARAM) clr);
		}
		return hr;
	}
	static BOOL CALLBACK BackgroundColorEnumProc(HWND hwnd, LPARAM l)
	{
		CAxWindow wnd(hwnd);
		CComPtr<IAxWinAmbientDispatch> spDispatch;
		wnd.QueryHost(&spDispatch);
		if (spDispatch != NULL)
			spDispatch->put_BackColor((OLE_COLOR)l);
		return TRUE;
	}
	LRESULT OnDialogColor(UINT, WPARAM w, LPARAM, BOOL&)
	{
		HDC dc = (HDC) w;
		LOGBRUSH lb;
		::GetObject(m_hbrBackground, sizeof(lb), (void*)&lb);
		::SetBkColor(dc, lb.lbColor);
		return (LRESULT)m_hbrBackground;
	}
	HWND Create(HWND hWndParent, RECT& /*rcPos*/, LPARAM dwInitParam = NULL)
	{
		CComControl< T, CAxDialogImpl< T > >::Create(hWndParent, dwInitParam);
		SetBackgroundColorFromAmbient();
		if (m_hWnd != NULL)
			ShowWindow(SW_SHOWNOACTIVATE);
		return m_hWnd;
	}
	BOOL CalcExtent(SIZE& size)
	{
		HINSTANCE hInstance = _Module.GetResourceInstance();
		LPCTSTR lpTemplateName = MAKEINTRESOURCE(T::IDD);
		HRSRC hDlgTempl = FindResource(hInstance, lpTemplateName, RT_DIALOG);
		if (hDlgTempl == NULL)
			return FALSE;
		HGLOBAL hResource = LoadResource(hInstance, hDlgTempl);
		DLGTEMPLATE* pDlgTempl = (DLGTEMPLATE*)LockResource(hResource);
		if (pDlgTempl == NULL)
			return FALSE;
		AtlGetDialogSize(pDlgTempl, &size);
		AtlPixelToHiMetric(&size, &size);
		return TRUE;
	}
//Implementation
	BOOL PreTranslateAccelerator(LPMSG pMsg, HRESULT& hRet)
	{
		hRet = S_OK;
		if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
		   (pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return FALSE;
		// find a direct child of the dialog from the window that has focus
		HWND hWndCtl = ::GetFocus();
		if (IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)
		{
			do
			{
				hWndCtl = ::GetParent(hWndCtl);
			}
			while (::GetParent(hWndCtl) != m_hWnd);
		}
		// give controls a chance to translate this message
		if (::SendMessage(hWndCtl, WM_FORWARDMSG, 0, (LPARAM)pMsg) == 1)
			return TRUE;

		// special handling for keyboard messages
		DWORD_PTR dwDlgCode = ::SendMessage(pMsg->hwnd, WM_GETDLGCODE, 0, 0L);
		switch(pMsg->message)
		{
		case WM_CHAR:
			if(dwDlgCode == 0)	// no dlgcode, possibly an ActiveX control
				return FALSE;	// let the container process this
			break;
		case WM_KEYDOWN:
			switch(LOWORD(pMsg->wParam))
			{
			case VK_TAB:
				// prevent tab from looping inside of our dialog
				if((dwDlgCode & DLGC_WANTTAB) == 0)
				{
					HWND hWndFirstOrLast = ::GetWindow(m_hWnd, GW_CHILD);
					if (::GetKeyState(VK_SHIFT) >= 0)  // not pressed
						hWndFirstOrLast = GetNextDlgTabItem(hWndFirstOrLast, TRUE);
					if (hWndFirstOrLast == hWndCtl)
						return FALSE;
				}
				break;
			case VK_LEFT:
			case VK_UP:
			case VK_RIGHT:
			case VK_DOWN:
				// prevent arrows from looping inside of our dialog
				if((dwDlgCode & DLGC_WANTARROWS) == 0)
				{
					HWND hWndFirstOrLast = ::GetWindow(m_hWnd, GW_CHILD);
					if (pMsg->wParam == VK_RIGHT || pMsg->wParam == VK_DOWN)	// going forward
						hWndFirstOrLast = GetNextDlgTabItem(hWndFirstOrLast, TRUE);
					if (hWndFirstOrLast == hWndCtl)
						return FALSE;
				}
				break;
			case VK_EXECUTE:
			case VK_RETURN:
			case VK_ESCAPE:
			case VK_CANCEL:
				// we don't want to handle these, let the container do it
				return FALSE;
			}
			break;
		}

		return IsDialogMessage(pMsg);
	}
	HRESULT IOleInPlaceObject_InPlaceDeactivate(void)
	{
		AdviseSinkMap(false); //unadvise
		return CComControl<T, CAxDialogImpl<T> >::IOleInPlaceObject_InPlaceDeactivate();
	}
	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
	{
		T* pT = static_cast<T*>(this);
		HWND h = pT->Create(hWndParent, rcPos);
		if (h != NULL)
			AdviseSinkMap(true);
		return h;
	}
	virtual HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		if(!m_bInPlaceActive)
		{
			HPEN hPen = (HPEN)::GetStockObject(BLACK_PEN);
			HBRUSH hBrush = (HBRUSH)::GetStockObject(GRAY_BRUSH);
			::SelectObject(di.hdcDraw, hPen);
			::SelectObject(di.hdcDraw, hBrush);
			::Rectangle(di.hdcDraw, di.prcBounds->left, di.prcBounds->top, di.prcBounds->right, di.prcBounds->bottom);
			::SetTextColor(di.hdcDraw, ::GetSysColor(COLOR_WINDOWTEXT));
			::SetBkMode(di.hdcDraw, TRANSPARENT);
			::DrawText(di.hdcDraw, _T("ATL Composite Control"), -1, (LPRECT)di.prcBounds, DT_CENTER | DT_SINGLELINE | DT_VCENTER);
		}
		return S_OK;
	}
	typedef CComControl< T, CAxDialogImpl< T > >	baseClass;
	BEGIN_MSG_MAP(CComCompositeControl< T >)
		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnDialogColor)
		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnDialogColor)
		MESSAGE_HANDLER(WM_SETFOCUS, baseClass::OnSetFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, baseClass::OnKillFocus)
		MESSAGE_HANDLER(WM_MOUSEACTIVATE, baseClass::OnMouseActivate)
	END_MSG_MAP()

	BEGIN_SINK_MAP(T)
	END_SINK_MAP()
};
#endif //_ATL_NO_HOSTING

// Forward declarations
//
template <class T> class IPersistStorageImpl;
template <class T> class IPersistPropertyBagImpl;

template <class T> class IOleControlImpl;
template <class T> class IRunnableObjectImpl;
template <class T> class IQuickActivateImpl;
template <class T> class IOleObjectImpl;
template <class T> class IPropertyPageImpl;
template <class T> class IPropertyPage2Impl;
template <class T> class IPerPropertyBrowsingImpl;
template <class T> class IViewObjectExImpl;
template <class T> class IOleWindowImpl;
template <class T> class IPointerInactiveImpl;
template <class T, class CDV> class IPropertyNotifySinkCP;
template <class T> class IBindStatusCallbackImpl;
template <class T> class CBindStatusCallback;


//////////////////////////////////////////////////////////////////////////////
// IOleControlImpl
template <class T>
class ATL_NO_VTABLE IOleControlImpl : public IOleControl
{
public:
	STDMETHOD(GetControlInfo)(LPCONTROLINFO /* pCI */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::GetControlInfo"));
	}
	STDMETHOD(OnMnemonic)(LPMSG /* pMsg */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::OnMnemonic"));
	}
	STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
	{
		dispid;
		ATLTRACE2(atlTraceControls,2,_T("IOleControlImpl::OnAmbientPropertyChange\n"));
		ATLTRACE2(atlTraceControls,2,_T(" -- DISPID = %d (%d)\n"), dispid);
		return S_OK;
	}
	STDMETHOD(FreezeEvents)(BOOL bFreeze)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleControlImpl::FreezeEvents\n"));
		if (bFreeze)
			pT->m_nFreezeEvents++;
		else
			pT->m_nFreezeEvents--;
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IQuickActivateImpl
template <class T>
class ATL_NO_VTABLE IQuickActivateImpl : public IQuickActivate
{
public:
	STDMETHOD(QuickActivate)(QACONTAINER *pQACont, QACONTROL *pQACtrl)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IQuickActivateImpl::QuickActivate\n"));
		return pT->IQuickActivate_QuickActivate(pQACont, pQACtrl);
	}
	STDMETHOD(SetContentExtent)(LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IQuickActivateImpl::SetContentExtent\n"));
		return pT->IOleObjectImpl<T>::SetExtent(DVASPECT_CONTENT, pSize);
	}
	STDMETHOD(GetContentExtent)(LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IQuickActivateImpl::GetContentExtent\n"));
		return pT->IOleObjectImpl<T>::GetExtent(DVASPECT_CONTENT, pSize);
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleObjectImpl
template <class T>
class ATL_NO_VTABLE IOleObjectImpl : public IOleObject
{
public:
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::SetClientSite\n"));
		return pT->IOleObject_SetClientSite(pClientSite);
	}
	STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetClientSite\n"));
		return pT->IOleObject_GetClientSite(ppClientSite);
	}
	STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::SetHostNames\n"));
		return S_OK;
	}
	STDMETHOD(Close)(DWORD dwSaveOption)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Close\n"));
		return pT->IOleObject_Close(dwSaveOption);
	}
	STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetMoniker"));
	}
	STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetMoniker"));
	}
	STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::InitFromData"));
	}
	STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetClipboardData"));
	}

	// Helpers for DoVerb - Over-rideable in user class
	HRESULT DoVerbPrimary(LPCRECT prcPosRect, HWND hwndParent)
	{
		T* pT = static_cast<T*>(this);
		BOOL bDesignMode = FALSE;
		CComVariant var;
		// if container doesn't support this property
		// don't allow design mode
		HRESULT hRes = pT->GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		if (SUCCEEDED(hRes) && var.vt == VT_BOOL && !var.boolVal)
			bDesignMode = TRUE;
		if (bDesignMode)
			return pT->DoVerbProperties(prcPosRect, hwndParent);
		else
			return pT->DoVerbInPlaceActivate(prcPosRect, hwndParent);
	}
	HRESULT DoVerbShow(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbShow();
		if (SUCCEEDED(hr))
		{
			hr = pT->InPlaceActivate(OLEIVERB_SHOW, prcPosRect);
			if (SUCCEEDED(hr))
				hr = pT->OnPostVerbShow();
		}
		return hr;
	}
	HRESULT DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbInPlaceActivate();
		if (SUCCEEDED(hr))
		{
			hr = pT->InPlaceActivate(OLEIVERB_INPLACEACTIVATE, prcPosRect);
			if (SUCCEEDED(hr))
				hr = pT->OnPostVerbInPlaceActivate();
			if (SUCCEEDED(hr))
				pT->FireViewChange();
		}
		return hr;
	}
	HRESULT DoVerbUIActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (!pT->m_bUIActive)
		{
			hr = pT->OnPreVerbUIActivate();
			if (SUCCEEDED(hr))
			{
				hr = pT->InPlaceActivate(OLEIVERB_UIACTIVATE, prcPosRect);
				if (SUCCEEDED(hr))
					hr = pT->OnPostVerbUIActivate();
			}
		}
		return hr;
	}
	HRESULT DoVerbHide(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbHide();
		if (SUCCEEDED(hr))
		{
			pT->UIDeactivate();
			if (pT->m_hWnd)
				pT->ShowWindow(SW_HIDE);
			hr = pT->OnPostVerbHide();
		}
		return hr;
	}
	HRESULT DoVerbOpen(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbOpen();
		if (SUCCEEDED(hr))
			hr = pT->OnPostVerbOpen();
		return hr;
	}
	HRESULT DoVerbDiscardUndo(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbDiscardUndo();
		if (SUCCEEDED(hr))
			hr = pT->OnPostVerbDiscardUndo();
		return hr;
	}
	STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* pMsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */,
									 HWND hwndParent, LPCRECT lprcPosRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::DoVerb(%d)\n"), iVerb);
		ATLASSERT(pT->m_spClientSite);

		HRESULT hr = E_NOTIMPL;
		switch (iVerb)
		{
		case OLEIVERB_PRIMARY:
			hr = pT->DoVerbPrimary(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_SHOW:
			hr = pT->DoVerbShow(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_INPLACEACTIVATE:
			hr = pT->DoVerbInPlaceActivate(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_UIACTIVATE:
			hr = pT->DoVerbUIActivate(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_HIDE:
			hr = pT->DoVerbHide(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_OPEN:
			hr = pT->DoVerbOpen(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_DISCARDUNDOSTATE:
			hr = pT->DoVerbDiscardUndo(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_PROPERTIES:
			hr = pT->DoVerbProperties(lprcPosRect, hwndParent);
		}
		return hr;
	}
	STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::EnumVerbs\n"));
		ATLASSERT(ppEnumOleVerb);
		if (!ppEnumOleVerb)
			return E_POINTER;
		return OleRegEnumVerbs(T::GetObjectCLSID(), ppEnumOleVerb);
	}
	STDMETHOD(Update)(void)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Update\n"));
		return S_OK;
	}
	STDMETHOD(IsUpToDate)(void)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::IsUpToDate\n"));
		return S_OK;
	}
	STDMETHOD(GetUserClassID)(CLSID *pClsid)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetUserClassID\n"));
		ATLASSERT(pClsid);
		if (!pClsid)
			return E_POINTER;
		*pClsid = T::GetObjectCLSID();
		return S_OK;
	}
	STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetUserType\n"));
		return OleRegGetUserType(T::GetObjectCLSID(), dwFormOfType, pszUserType);
	}
	STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::SetExtent\n"));
		return pT->IOleObject_SetExtent(dwDrawAspect, psizel);
	}
	STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetExtent\n"));
		if (dwDrawAspect != DVASPECT_CONTENT)
			return E_FAIL;
		if (psizel == NULL)
			return E_POINTER;
		*psizel = pT->m_sizeExtent;
		return S_OK;
	}
	STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Advise\n"));
		return pT->IOleObject_Advise(pAdvSink, pdwConnection);
	}
	STDMETHOD(Unadvise)(DWORD dwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Unadvise\n"));
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->Unadvise(dwConnection);
		return hRes;
	}
	STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::EnumAdvise\n"));
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->EnumAdvise(ppenumAdvise);
		return hRes;
	}
	STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetMiscStatus\n"));
		return OleRegGetMiscStatus(T::GetObjectCLSID(), dwAspect, pdwStatus);
	}
	STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetColorScheme"));
	}
// Implementation
public:
	HRESULT OnPreVerbShow() { return S_OK; }
	HRESULT OnPostVerbShow() { return S_OK; }
	HRESULT OnPreVerbInPlaceActivate() { return S_OK; }
	HRESULT OnPostVerbInPlaceActivate() { return S_OK; }
	HRESULT OnPreVerbUIActivate() { return S_OK; }
	HRESULT OnPostVerbUIActivate() { return S_OK; }
	HRESULT OnPreVerbHide() { return S_OK; }
	HRESULT OnPostVerbHide() { return S_OK; }
	HRESULT OnPreVerbOpen() { return S_OK; }
	HRESULT OnPostVerbOpen() { return S_OK; }
	HRESULT OnPreVerbDiscardUndo() { return S_OK; }
	HRESULT OnPostVerbDiscardUndo() { return S_OK; }
};

//local struct used for implementation
#pragma pack(push, 1)
struct _ATL_DLGTEMPLATEEX
{
	WORD dlgVer;
	WORD signature;
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	WORD cDlgItems;
	short x;
	short y;
	short cx;
	short cy;
};
#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// IPropertyPageImpl
template <class T>
class ATL_NO_VTABLE IPropertyPageImpl : public IPropertyPage
{

public:
	void SetDirty(BOOL bDirty)
	{
		T* pT = static_cast<T*>(this);
		if (pT->m_bDirty != bDirty)
		{
			pT->m_bDirty = bDirty;
			pT->m_pPageSite->OnStatusChange(bDirty ? PROPPAGESTATUS_DIRTY | PROPPAGESTATUS_VALIDATE : 0);
		}
	}

	IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		pT->m_pPageSite = NULL;
		pT->m_size.cx = 0;
		pT->m_size.cy = 0;
		pT->m_dwTitleID = 0;
		pT->m_dwHelpFileID = 0;
		pT->m_dwDocStringID = 0;
		pT->m_dwHelpContext = 0;
		pT->m_ppUnk = NULL;
		pT->m_nObjects = 0;
		pT->m_bDirty = FALSE;
		pT->m_hWnd = NULL;
	}

	~IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		if (pT->m_pPageSite != NULL)
			pT->m_pPageSite->Release();

		for (UINT i = 0; i < m_nObjects; i++)
			pT->m_ppUnk[i]->Release();

		delete[] pT->m_ppUnk;
	}

	// IPropertyPage
	//
	STDMETHOD(SetPageSite)(IPropertyPageSite *pPageSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::SetPageSite\n"));

		if (!pPageSite && pT->m_pPageSite)
		{
			pT->m_pPageSite->Release();
			pT->m_pPageSite = NULL;
			return S_OK;
		}

		if (!pPageSite && !pT->m_pPageSite)
			return S_OK;

		if (pPageSite && pT->m_pPageSite)
		{
			ATLTRACE2(atlTraceControls,2,_T("Error : setting page site again with non NULL value\n"));
			return E_UNEXPECTED;
		}

		pT->m_pPageSite = pPageSite;
		pT->m_pPageSite->AddRef();
		return S_OK;
	}
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT pRect, BOOL /* bModal */)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Activate\n"));

		if (pRect == NULL)
		{
			ATLTRACE2(atlTraceControls,2,_T("Error : Passed a NULL rect\n"));
			return E_POINTER;
		}

		pT->m_hWnd = pT->Create(hWndParent);
		Move(pRect);

		m_size.cx = pRect->right - pRect->left;
		m_size.cy = pRect->bottom - pRect->top;

		return S_OK;

	}
	STDMETHOD(Deactivate)( void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Deactivate\n"));

		if (pT->m_hWnd)
		{
			ATLTRACE2(atlTraceControls,2,_T("Destroying Dialog\n"));
			if (::IsWindow(pT->m_hWnd))
				pT->DestroyWindow();
			pT->m_hWnd = NULL;
		}

		return S_OK;

	}
	STDMETHOD(GetPageInfo)(PROPPAGEINFO *pPageInfo)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::GetPageInfo\n"));

		if (pPageInfo == NULL)
		{
			ATLTRACE2(atlTraceControls,2,_T("Error : PROPPAGEINFO passed == NULL\n"));
			return E_POINTER;
		}

		HRSRC hRsrc = FindResource(_Module.GetResourceInstance(),
								   MAKEINTRESOURCE(T::IDD), RT_DIALOG);
		if (hRsrc == NULL)
		{
			ATLTRACE2(atlTraceControls,2,_T("Could not find resource template\n"));
			return E_UNEXPECTED;
		}

		HGLOBAL hGlob = LoadResource(_Module.GetResourceInstance(), hRsrc);
		DLGTEMPLATE* pDlgTempl = (DLGTEMPLATE*)LockResource(hGlob);
		if (pDlgTempl == NULL)
		{
			ATLTRACE2(atlTraceControls,2,_T("Could not load resource template\n"));
			return E_UNEXPECTED;
		}
		AtlGetDialogSize(pDlgTempl, &m_size);

		pPageInfo->cb = sizeof(PROPPAGEINFO);
		pPageInfo->pszTitle = LoadStringHelper(pT->m_dwTitleID);
		pPageInfo->size = m_size;
		pPageInfo->pszHelpFile = LoadStringHelper(pT->m_dwHelpFileID);
		pPageInfo->pszDocString = LoadStringHelper(pT->m_dwDocStringID);
		pPageInfo->dwHelpContext = pT->m_dwHelpContext;

		return S_OK;
	}

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::SetObjects\n"));

		if (ppUnk == NULL)
			return E_POINTER;

		if (pT->m_ppUnk != NULL && pT->m_nObjects > 0)
		{
			for (UINT iObj = 0; iObj < pT->m_nObjects; iObj++)
				pT->m_ppUnk[iObj]->Release();

			delete [] pT->m_ppUnk;
		}

		pT->m_ppUnk = NULL;
		ATLTRY(pT->m_ppUnk = new IUnknown*[nObjects]);

		if (pT->m_ppUnk == NULL)
			return E_OUTOFMEMORY;

		for (UINT i = 0; i < nObjects; i++)
		{
			ppUnk[i]->AddRef();
			pT->m_ppUnk[i] = ppUnk[i];
		}

		pT->m_nObjects = nObjects;

		return S_OK;
	}
	STDMETHOD(Show)(UINT nCmdShow)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Show\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		ShowWindow(pT->m_hWnd, nCmdShow);
		return S_OK;
	}
	STDMETHOD(Move)(LPCRECT pRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Move\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		if (pRect == NULL)
			return E_POINTER;

		MoveWindow(pT->m_hWnd, pRect->left, pRect->top, pRect->right - pRect->left,
				 pRect->bottom - pRect->top, TRUE);

		return S_OK;

	}
	STDMETHOD(IsPageDirty)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::IsPageDirty\n"));
		return pT->m_bDirty ? S_OK : S_FALSE;
	}
	STDMETHOD(Apply)(void)
	{
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Apply\n"));
		return S_OK;
	}
	STDMETHOD(Help)(LPCOLESTR pszHelpDir)
	{
		T* pT = static_cast<T*>(this);
		USES_CONVERSION;

		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Help\n"));
		CComBSTR szFullFileName(pszHelpDir);
		LPOLESTR szFileName = LoadStringHelper(pT->m_dwHelpFileID);
		szFullFileName.Append(OLESTR("\\"));
		szFullFileName.Append(szFileName);
		CoTaskMemFree(szFileName);
		WinHelp(pT->m_hWnd, OLE2CT(szFullFileName), HELP_CONTEXTPOPUP, NULL);
		return S_OK;
	}
	STDMETHOD(TranslateAccelerator)(MSG *pMsg)
	{
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::TranslateAccelerator\n"));
		T* pT = static_cast<T*>(this);
		if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
			(pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return S_FALSE;

		return (IsDialogMessage(pT->m_hWnd, pMsg)) ? S_OK : S_FALSE;
	}

	IPropertyPageSite* m_pPageSite;
	IUnknown** m_ppUnk;
	ULONG m_nObjects;
	SIZE m_size;
	UINT m_dwTitleID;
	UINT m_dwHelpFileID;
	UINT m_dwDocStringID;
	DWORD m_dwHelpContext;
	BOOL m_bDirty;

//methods
public:

	BEGIN_MSG_MAP(IPropertyPageImpl<T>)
		MESSAGE_HANDLER(WM_STYLECHANGING, OnStyleChange)
	END_MSG_MAP()

	LRESULT OnStyleChange(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
	{
		if (wParam == GWL_EXSTYLE)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lParam;
			lpss->styleNew |= WS_EX_CONTROLPARENT;
			return 0;
		}
		return 1;
	}

	LPOLESTR LoadStringHelper(UINT idRes)
	{
		USES_CONVERSION;

		TCHAR szTemp[_MAX_PATH];
		LPOLESTR sz;
		sz = (LPOLESTR)CoTaskMemAlloc(_MAX_PATH*sizeof(OLECHAR));
		if (sz == NULL)
			return NULL;
		sz[0] = NULL;

		if (LoadString(_Module.GetResourceInstance(), idRes, szTemp, _MAX_PATH))
			ocscpy(sz, T2OLE(szTemp));
		else
		{
			ATLTRACE2(atlTraceControls,2,_T("Error : Failed to load string from res\n"));
		}

		return sz;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IPropertyPage2Impl
template <class T>
class ATL_NO_VTABLE IPropertyPage2Impl : public IPropertyPageImpl<T>
{
public:

	STDMETHOD(EditProperty)(DISPID dispID)
	{
		ATLTRACENOTIMPL(_T("IPropertyPage2Impl::EditProperty\n"));
	}
};



//////////////////////////////////////////////////////////////////////////////
// IPerPropertyBrowsingImpl
template <class T>
class ATL_NO_VTABLE IPerPropertyBrowsingImpl : public IPerPropertyBrowsing
{
public:
	STDMETHOD(GetDisplayString)(DISPID dispID,BSTR *pBstr)
	{
		ATLTRACE2(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::GetDisplayString\n"));
		T* pT = static_cast<T*>(this);
		*pBstr = NULL;
		CComVariant var;
		if (FAILED(CComDispatchDriver::GetProperty(pT, dispID, &var)))
			return S_FALSE;

		BSTR bstrTemp = var.bstrVal;
		if (var.vt != VT_BSTR)
		{
			CComVariant varDest;
			if (FAILED(::VariantChangeType(&varDest, &var, VARIANT_NOVALUEPROP, VT_BSTR)))
				return S_FALSE;
			bstrTemp = varDest.bstrVal;
		}
		*pBstr = SysAllocString(bstrTemp);
		if (*pBstr == NULL)
			return E_OUTOFMEMORY;
		return S_OK;
	}

	STDMETHOD(MapPropertyToPage)(DISPID dispID, CLSID *pClsid)
	{
		ATLTRACE2(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::MapPropertyToPage\n"));
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		ATLASSERT(pMap != NULL);
		for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
		{
			if (pMap[i].szDesc == NULL)
				continue;

			// reject data entry types
			if (pMap[i].dwSizeData != 0)
				continue;

			if (pMap[i].dispid == dispID)
			{
				ATLASSERT(pMap[i].pclsidPropPage != NULL);
				*pClsid = *(pMap[i].pclsidPropPage);
				return S_OK;
			}
		}
		*pClsid = CLSID_NULL;
		return E_INVALIDARG;
	}
	STDMETHOD(GetPredefinedStrings)(DISPID dispID, CALPOLESTR *pCaStringsOut,CADWORD *pCaCookiesOut)
	{
		dispID;
		ATLTRACE2(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::GetPredefinedStrings\n"));
		if (pCaStringsOut == NULL || pCaCookiesOut == NULL)
			return E_POINTER;

		pCaStringsOut->cElems = 0;
		pCaStringsOut->pElems = NULL;
		pCaCookiesOut->cElems = 0;
		pCaCookiesOut->pElems = NULL;
		return S_OK;
	}
	STDMETHOD(GetPredefinedValue)(DISPID /*dispID*/, DWORD /*dwCookie*/, VARIANT* /*pVarOut*/)
	{
		ATLTRACENOTIMPL(_T("IPerPropertyBrowsingImpl::GetPredefinedValue"));
	}
};

//////////////////////////////////////////////////////////////////////////////
// IViewObjectExImpl
template <class T>
class ATL_NO_VTABLE IViewObjectExImpl : public IViewObjectEx
{
public:
	STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
					DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
					LPCRECTL prcBounds, LPCRECTL prcWBounds,
					BOOL (__stdcall * /*pfnContinue*/)(DWORD_PTR dwContinue),
					DWORD_PTR /*dwContinue*/)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::Draw\n"));
		return pT->IViewObject_Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, hdcDraw,
			prcBounds, prcWBounds);
	}

	STDMETHOD(GetColorSet)(DWORD /* dwDrawAspect */,LONG /* lindex */, void* /* pvAspect */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, LOGPALETTE** /* ppColorSet */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetColorSet"));
	}
	STDMETHOD(Freeze)(DWORD /* dwDrawAspect */, LONG /* lindex */, void* /* pvAspect */,DWORD* /* pdwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Freeze"));
	}
	STDMETHOD(Unfreeze)(DWORD /* dwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Unfreeze"));
	}
	STDMETHOD(SetAdvise)(DWORD /* aspects */, DWORD /* advf */, IAdviseSink* pAdvSink)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::SetAdvise\n"));
		pT->m_spAdviseSink = pAdvSink;
		return S_OK;
	}
	STDMETHOD(GetAdvise)(DWORD* /* pAspects */, DWORD* /* pAdvf */, IAdviseSink** ppAdvSink)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetAdvise\n"));
		if (ppAdvSink != NULL)
		{
			*ppAdvSink = pT->m_spAdviseSink;
			if (pT->m_spAdviseSink)
				pT->m_spAdviseSink.p->AddRef();
		}
		return S_OK;
	}

	// IViewObject2
	//
	STDMETHOD(GetExtent)(DWORD /* dwDrawAspect */, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, LPSIZEL lpsizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetExtent\n"));
		*lpsizel = pT->m_sizeExtent;
		return S_OK;
	}

	// IViewObjectEx
	//
	STDMETHOD(GetRect)(DWORD /* dwAspect */, LPRECTL /* pRect */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetRect"));
	}

	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = pT->_GetViewStatus();
		return S_OK;
	}
	STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG /* lCloseHint */, DWORD *pHitResult)
	{
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::QueryHitPoint\n"));
		if (dwAspect == DVASPECT_CONTENT)
		{
			*pHitResult = PtInRect(pRectBounds, ptlLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		ATLTRACE2(atlTraceControls,2,_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG /* lCloseHint */, DWORD* pHitResult)
	{
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::QueryHitRect\n"));
		if (dwAspect == DVASPECT_CONTENT)
		{
			RECT rc;
			*pHitResult = UnionRect(&rc, pRectBounds, prcLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		ATLTRACE2(atlTraceControls,2,_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, DVEXTENTINFO* pExtentInfo , LPSIZEL psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetNaturalExtent\n"));
		HRESULT hRes = E_FAIL;
		if (pExtentInfo == NULL || psizel == NULL)
			hRes = E_POINTER;
		else if (dwAspect == DVASPECT_CONTENT)
		{
			if (pExtentInfo->dwExtentMode == DVEXTENT_CONTENT)
			{
				*psizel = pT->m_sizeNatural;
				hRes = S_OK;
			}
		}
		return hRes;
	}

public:
};

//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceObjectWindowlessImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceObjectWindowlessImpl : public IOleInPlaceObjectWindowless
{
public:
	// IOleWindow
	//

	// Change IOleInPlaceActiveObject::GetWindow as well
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceObject
	//
	STDMETHOD(InPlaceDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::InPlaceDeactivate\n"));
		return pT->IOleInPlaceObject_InPlaceDeactivate();
	}
	STDMETHOD(UIDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::UIDeactivate\n"));
		return pT->IOleInPlaceObject_UIDeactivate();
	}
	STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::SetObjectRects\n"));
		return pT->IOleInPlaceObject_SetObjectRects(prcPos, prcClip);
	}
	STDMETHOD(ReactivateAndUndo)(void)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ReactivateAndUndo"));
	}

	// IOleInPlaceObjectWindowless
	//
	STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::OnWindowMessage\n"));
		T* pT = static_cast<T*>(this);
		BOOL b = pT->ProcessWindowMessage(pT->m_hWnd, msg, wParam, lParam, *plResult);
		return b ? S_OK : S_FALSE;
	}

	STDMETHOD(GetDropTarget)(IDropTarget** /* ppDropTarget */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::GetDropTarget"));
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceActiveObjectImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceActiveObjectImpl : public IOleInPlaceActiveObject
{
public:
	// IOleWindow
	//

	// Change IOleInPlaceObjectWindowless::GetWindow as well
	STDMETHOD(GetWindow)(HWND *phwnd)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceActiveObjectImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceActiveObject
	//
	STDMETHOD(TranslateAccelerator)(LPMSG pMsg)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::TranslateAccelerator\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRet = S_OK;
		if (pT->PreTranslateAccelerator(pMsg, hRet))
			return hRet;
		CComPtr<IOleControlSite> spCtlSite;
		hRet = pT->InternalGetSite(IID_IOleControlSite, (void**)&spCtlSite);
		if (SUCCEEDED(hRet))
		{
			if (spCtlSite != NULL)
			{
				DWORD dwKeyMod = 0;
				if (::GetKeyState(VK_SHIFT) < 0)
					dwKeyMod += 1;	// KEYMOD_SHIFT
				if (::GetKeyState(VK_CONTROL) < 0)
					dwKeyMod += 2;	// KEYMOD_CONTROL
				if (::GetKeyState(VK_MENU) < 0)
					dwKeyMod += 4;	// KEYMOD_ALT
				hRet = spCtlSite->TranslateAccelerator(pMsg, dwKeyMod);
			}
			else
				hRet = S_FALSE;
		}
		return (hRet == S_OK) ? S_OK : S_FALSE;
	}
	STDMETHOD(OnFrameWindowActivate)(BOOL /* fActivate */)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::OnFrameWindowActivate\n"));
		return S_OK;
	}
	STDMETHOD(OnDocWindowActivate)(BOOL fActivate)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::OnDocWindowActivate\n"));
		T* pT = static_cast<T*>(this);
		if (fActivate == FALSE)
			pT->IOleInPlaceObject_UIDeactivate();
		return S_OK;
	}
	STDMETHOD(ResizeBorder)(LPCRECT /* prcBorder */, IOleInPlaceUIWindow* /* pUIWindow */, BOOL /* fFrameWindow */)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::ResizeBorder\n"));
		return S_OK;
	}
	STDMETHOD(EnableModeless)(BOOL /* fEnable */)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::EnableModeless\n"));
		return S_OK;
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPointerInactiveImpl
template <class T>
class ATL_NO_VTABLE IPointerInactiveImpl : public IPointerInactive
{
public:
	// IPointerInactive
	//
	STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::GetActivationPolicy"));
	}
	STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveMouseMove"));
	}
	STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveSetCursor"));
	}
};

//////////////////////////////////////////////////////////////////////////////
// IRunnableObjectImpl
template <class T>
class ATL_NO_VTABLE IRunnableObjectImpl : public IRunnableObject
{
public:
	// IRunnableObject
	//
	STDMETHOD(GetRunningClass)(LPCLSID lpClsid)
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::GetRunningClass\n"));
		*lpClsid = GUID_NULL;
		return E_UNEXPECTED;
	}
	STDMETHOD(Run)(LPBINDCTX)
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::Run\n"));
		return S_OK;
	}
	virtual BOOL STDMETHODCALLTYPE IsRunning()
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::IsRunning\n"));
		return TRUE;
	}
	STDMETHOD(LockRunning)(BOOL /*fLock*/, BOOL /*fLastUnlockCloses*/)
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::LockRunning\n"));
		return S_OK;
	}
	STDMETHOD(SetContainedObject)(BOOL /*fContained*/)
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::SetContainedObject\n"));
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IDataObjectImpl
template <class T>
class ATL_NO_VTABLE IDataObjectImpl : public IDataObject
{
public:
	STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
	{
		ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::GetData\n"));
		T* pT = (T*) this;
		return pT->IDataObject_GetData(pformatetcIn, pmedium);
	}
	STDMETHOD(GetDataHere)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetDataHere"));
	}
	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::QueryGetData"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetCanonicalFormatEtc"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::SetData"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::EnumFormatEtc"));
	}
	STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
		DWORD *pdwConnection)
	{
		ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::DAdvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = CreateDataAdviseHolder(&pT->m_spDataAdviseHolder);

		if (hr == S_OK)
			hr = pT->m_spDataAdviseHolder->Advise((IDataObject*)this, pformatetc, advf, pAdvSink, pdwConnection);

		return hr;
	}
	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
		ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::DUnadvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = OLE_E_NOCONNECTION;
		else
			hr = pT->m_spDataAdviseHolder->Unadvise(dwConnection);
		return hr;
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::EnumDAdvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = E_FAIL;
		if (pT->m_spDataAdviseHolder != NULL)
			hr = pT->m_spDataAdviseHolder->EnumAdvise(ppenumAdvise);
		return hr;
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPropertyNotifySinkCP
template <class T, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IPropertyNotifySinkCP :
	public IConnectionPointImpl<T, &IID_IPropertyNotifySink, CDV>
{
public:
	typedef CFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;
};


//////////////////////////////////////////////////////////////////////////////
// IObjectSafety
//
// 2nd template parameter is the supported safety e.g.
// INTERFACESAFE_FOR_UNTRUSTED_CALLER - safe for scripting
// INTERFACESAFE_FOR_UNTRUSTED_DATA   - safe for initialization from data

template <class T, DWORD dwSupportedSafety>
class ATL_NO_VTABLE IObjectSafetyImpl : public IObjectSafety
{
public:
	IObjectSafetyImpl()
	{
		m_dwCurrentSafety = 0;
	}

	STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
	{
		ATLTRACE2(atlTraceControls,2,_T("IObjectSafetyImpl2::GetInterfaceSafetyOptions\n"));
		T* pT = static_cast<T*>(this);
		if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
			return E_POINTER;
		
		HRESULT hr;
		IUnknown* pUnk;
		// Check if we support this interface
		hr = pT->GetUnknown()->QueryInterface(riid, (void**)&pUnk);
		if (SUCCEEDED(hr))
		{
			// We support this interface so set the safety options accordingly
			pUnk->Release();	// Release the interface we just acquired
			*pdwSupportedOptions = dwSupportedSafety;
			*pdwEnabledOptions   = m_dwCurrentSafety;
		}
		else
		{
			// We don't support this interface
			*pdwSupportedOptions = 0;
			*pdwEnabledOptions   = 0;
		}
		return hr;
	}
	STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
	{
		ATLTRACE2(atlTraceControls,2,_T("IObjectSafetyImpl2::SetInterfaceSafetyOptions\n"));
		T* pT = static_cast<T*>(this);
		IUnknown* pUnk;
		
		// Check if we support the interface and return E_NOINTEFACE if we don't
		if (FAILED(pT->GetUnknown()->QueryInterface(riid, (void**)&pUnk)))
			return E_NOINTERFACE;
		pUnk->Release();	// Release the interface we just acquired
		
		// If we are asked to set options we don't support then fail
		if (dwOptionSetMask & ~dwSupportedSafety)
			return E_FAIL;

		// Set the safety options we have been asked to
		m_dwCurrentSafety = m_dwCurrentSafety  & ~dwOptionSetMask | dwEnabledOptions;
		return S_OK;
	}
	DWORD m_dwCurrentSafety;
};

template <class T>
class ATL_NO_VTABLE IOleLinkImpl : public IOleLink
{
	STDMETHOD(SetUpdateOptions)(DWORD /* dwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetUpdateOptions"));
	}

	STDMETHOD(GetUpdateOptions)(DWORD* /* pdwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetUpdateOptions"));
	}

	STDMETHOD(SetSourceMoniker)(IMoniker* /* pmk */, REFCLSID /* rclsid */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceMoniker"));
	}

	STDMETHOD(GetSourceMoniker)(IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetSourceMoniker"));
	};

	STDMETHOD(SetSourceDisplayName)(LPCOLESTR /* pszStatusText */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceDisplayName"));
	}

	STDMETHOD(GetSourceDisplayName)(LPOLESTR *ppszDisplayName)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleLink::GetSourceDisplayName\n"));
		*ppszDisplayName = NULL;
		return E_FAIL;
	}

	STDMETHOD(BindToSource)(DWORD /* bindflags */, IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::BindToSource\n"));
	};

	STDMETHOD(BindIfRunning)()
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleLinkImpl::BindIfRunning\n"));
		return S_OK;
	};

	STDMETHOD(GetBoundSource)(IUnknown** /* ppunk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetBoundSource"));
	};

	STDMETHOD(UnbindSource)()
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::UnbindSource"));
	};

	STDMETHOD(Update)(IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::Update"));
	};
};

template <class T>
class ATL_NO_VTABLE CBindStatusCallback :
	public CComObjectRootEx<typename T::_ThreadModel::ThreadModelNoCS>,
	public IBindStatusCallback
{
	typedef void (T::*ATL_PDATAAVAILABLE)(CBindStatusCallback<T>* pbsc, BYTE* pBytes, DWORD dwSize);

public:

BEGIN_COM_MAP(CBindStatusCallback<T>)
	COM_INTERFACE_ENTRY(IBindStatusCallback)
END_COM_MAP()

	CBindStatusCallback()
	{
		m_pT = NULL;
		m_pFunc = NULL;
	}
	~CBindStatusCallback()
	{
		ATLTRACE2(atlTraceControls,2,_T("~CBindStatusCallback\n"));
	}

	STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnStartBinding\n"));
		m_spBinding = pBinding;
		return S_OK;
	}

	STDMETHOD(GetPriority)(LONG *pnPriority)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::GetPriority"));
		HRESULT hr = S_OK;
		if (pnPriority)
			*pnPriority = THREAD_PRIORITY_NORMAL;
		else
			hr = E_INVALIDARG;
		return S_OK;
	}

	STDMETHOD(OnLowResource)(DWORD reserved)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnLowResource"));
		return S_OK;
	}

	STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnProgress"));
		return S_OK;
	}

	STDMETHOD(OnStopBinding)(HRESULT hresult, LPCWSTR szError)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnStopBinding\n"));
		(m_pT->*m_pFunc)(this, NULL, 0);
		m_spBinding.Release();
		m_spBindCtx.Release();
		m_spMoniker.Release();
		return S_OK;
	}

	STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::GetBindInfo\n"));

		if (pbindInfo==NULL || pbindInfo->cbSize==0 || pgrfBINDF==NULL)
			return E_INVALIDARG;

		*pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE |
			BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE;

		ULONG cbSize = pbindInfo->cbSize;		// remember incoming cbSize
		memset(pbindInfo, 0, cbSize);			// zero out structure
		pbindInfo->cbSize = cbSize;				// restore cbSize
		pbindInfo->dwBindVerb = BINDVERB_GET;	// set verb
		return S_OK;
	}

	STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnDataAvailable\n"));
		HRESULT hr = S_OK;

		// Get the Stream passed
		if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
		{
			if (!m_spStream && pstgmed->tymed == TYMED_ISTREAM)
				m_spStream = pstgmed->pstm;
		}

		DWORD dwRead = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read
		DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull

		// If there is some data to be read then go ahead and read them
		if (m_spStream)
		{
			if (dwRead > 0)
			{
				BYTE* pBytes = NULL;
				ATLTRY(pBytes = new BYTE[dwRead + 1]);
				if (pBytes == NULL)
					return E_OUTOFMEMORY;
				hr = m_spStream->Read(pBytes, dwRead, &dwActuallyRead);
				if (SUCCEEDED(hr))
				{
					pBytes[dwActuallyRead] = 0;
					if (dwActuallyRead>0)
					{
						(m_pT->*m_pFunc)(this, pBytes, dwActuallyRead);
						m_dwTotalRead += dwActuallyRead;
					}
				}
				delete[] pBytes;
			}
		}

		if (BSCF_LASTDATANOTIFICATION & grfBSCF)
			m_spStream.Release();
		return hr;
	}

	STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown *punk)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnObjectAvailable"));
		return S_OK;
	}

	HRESULT _StartAsyncDownload(BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative)
	{
		m_dwTotalRead = 0;
		m_dwAvailableToRead = 0;
		HRESULT hr = S_OK;
		CComQIPtr<IServiceProvider, &IID_IServiceProvider> spServiceProvider(pUnkContainer);
		CComPtr<IBindHost>	spBindHost;
		CComPtr<IStream>	spStream;
		if (spServiceProvider)
			spServiceProvider->QueryService(SID_IBindHost, IID_IBindHost, (void**)&spBindHost);

		if (spBindHost == NULL)
		{
			if (bRelative)
				return E_NOINTERFACE;  // relative asked for, but no IBindHost
			hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			if (SUCCEEDED(hr))
				hr = CreateBindCtx(0, &m_spBindCtx);

			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, static_cast<IBindStatusCallback*>(this), 0, 0L);
			else
				m_spMoniker.Release();

			if (SUCCEEDED(hr))
				hr = m_spMoniker->BindToStorage(m_spBindCtx, 0, IID_IStream, (void**)&spStream);
		}
		else
		{
			hr = CreateBindCtx(0, &m_spBindCtx);
			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, static_cast<IBindStatusCallback*>(this), 0, 0L);

			if (SUCCEEDED(hr))
			{
				if (bRelative)
					hr = spBindHost->CreateMoniker(bstrURL, m_spBindCtx, &m_spMoniker, 0);
				else
					hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			}

			if (SUCCEEDED(hr))
			{
				hr = spBindHost->MonikerBindToStorage(m_spMoniker, m_spBindCtx, static_cast<IBindStatusCallback*>(this), IID_IStream, (void**)&spStream);
				ATLTRACE2(atlTraceControls,2,_T("Bound"));
			}
		}
		return hr;
	}

	HRESULT StartAsyncDownload(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
	{
		m_pT = pT;
		m_pFunc = pFunc;
		return  _StartAsyncDownload(bstrURL, pUnkContainer, bRelative);
	}

	static HRESULT Download(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
	{
		CComObject<CBindStatusCallback<T> > *pbsc;
		HRESULT hRes = CComObject<CBindStatusCallback<T> >::CreateInstance(&pbsc);
		if (FAILED(hRes))
			return hRes;
		return pbsc->StartAsyncDownload(pT, pFunc, bstrURL, pUnkContainer, bRelative);
	}

	CComPtr<IMoniker> m_spMoniker;
	CComPtr<IBindCtx> m_spBindCtx;
	CComPtr<IBinding> m_spBinding;
	CComPtr<IStream> m_spStream;
	T* m_pT;
	ATL_PDATAAVAILABLE m_pFunc;
	DWORD m_dwTotalRead;
	DWORD m_dwAvailableToRead;
};

#define IMPLEMENT_STOCKPROP(type, fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(type pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		pT->m_##pname = pname; \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		pT->SendOnDataChange(NULL); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(type* p##pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
        if (!p##pname) return E_POINTER; \
		T* pT = (T*) this; \
		*p##pname = pT->m_##pname; \
		return S_OK; \
	}

#define IMPLEMENT_BOOL_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(VARIANT_BOOL pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		pT->m_##pname = pname; \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		pT->SendOnDataChange(NULL); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(VARIANT_BOOL* p##pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
        if (!p##pname) return E_POINTER; \
		T* pT = (T*) this; \
		*p##pname = pT->m_##pname ? VARIANT_TRUE : VARIANT_FALSE; \
		return S_OK; \
	}

#define IMPLEMENT_BSTR_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(BSTR pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		if (*(&(pT->m_##pname)) != NULL) \
			SysFreeString(*(&(pT->m_##pname))); \
		*(&(pT->m_##pname)) = SysAllocString(pname); \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		pT->SendOnDataChange(NULL); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(BSTR* p##pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
        if (!p##pname) return E_POINTER; \
		T* pT = (T*) this; \
		*p##pname = SysAllocString(pT->m_##pname); \
		return S_OK; \
	}


template < class T, class InterfaceName, const IID* piid, const GUID* plibid>
class ATL_NO_VTABLE CStockPropImpl : public IDispatchImpl< InterfaceName, piid, plibid >
{
public:
	// Font
	HRESULT STDMETHODCALLTYPE put_Font(IFontDisp* pFont)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Font\n"));
        if (!ppFont) return E_POINTER;
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
			return S_FALSE;
		pT->m_pFont = 0;
		if (pFont)
		{
			CComQIPtr<IFont, &IID_IFont> p(pFont);
			if (p)
			{
				CComPtr<IFont> pFont;
				p->Clone(&pFont);
				if (pFont)
					pFont->QueryInterface(IID_IFontDisp, (void**) &pT->m_pFont);
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_FONT);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Font(IFontDisp* pFont)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::putref_Font\n"));
        if (!pFont) return E_POINTER;
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
			return S_FALSE;
		pT->m_pFont = pFont;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_FONT);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Font(IFontDisp** ppFont)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_Font\n"));
        if (!ppFont) return E_POINTER;
		T* pT = (T*) this;
		*ppFont = pT->m_pFont;
		if (*ppFont != NULL)
			(*ppFont)->AddRef();
		return S_OK;
	}
	// Picture
	HRESULT STDMETHODCALLTYPE put_Picture(IPictureDisp* pPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Picture\n"));
        if (!pPicture) return E_POINTER;
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
			return S_FALSE;
		pT->m_pPicture = 0;
		if (pPicture)
		{
			CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
			if (p)
			{
				ULARGE_INTEGER l;
				p->GetSizeMax(&l);
				HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
				if (hGlob)
				{
					CComPtr<IStream> spStream;
					CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
					if (spStream)
					{
						if (SUCCEEDED(p->Save(spStream, FALSE)))
						{
							LARGE_INTEGER l;
							l.QuadPart = 0;
							spStream->Seek(l, STREAM_SEEK_SET, NULL);
							OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pPicture);
						}
						spStream.Release();
					}
					GlobalFree(hGlob);
				}
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_PICTURE);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Picture(IPictureDisp* pPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::putref_Picture\n"));
        if (!pPicture) return E_POINTER;
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
			return S_FALSE;
		pT->m_pPicture = pPicture;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_PICTURE);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Picture(IPictureDisp** ppPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_Picture\n"));
        if (!ppPicture) return E_POINTER;
		T* pT = (T*) this;
		*ppPicture = pT->m_pPicture;
		if (*ppPicture != NULL)
			(*ppPicture)->AddRef();
		return S_OK;
	}
	// MouseIcon
	HRESULT STDMETHODCALLTYPE put_MouseIcon(IPictureDisp* pPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_MouseIcon\n"));
        if (!pPicture) return E_POINTER;
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
			return S_FALSE;
		pT->m_pMouseIcon = 0;
		if (pPicture)
		{
			CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
			if (p)
			{
				ULARGE_INTEGER l;
				p->GetSizeMax(&l);
				HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
				if (hGlob)
				{
					CComPtr<IStream> spStream;
					CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
					if (spStream)
					{
						if (SUCCEEDED(p->Save(spStream, FALSE)))
						{
							LARGE_INTEGER l;
							l.QuadPart = 0;
							spStream->Seek(l, STREAM_SEEK_SET, NULL);
							OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pMouseIcon);
						}
						spStream.Release();
					}
					GlobalFree(hGlob);
				}
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_MOUSEICON);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_MouseIcon(IPictureDisp* pPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::putref_MouseIcon\n"));
        if (!pPicture) return E_POINTER;
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
			return S_FALSE;
		pT->m_pMouseIcon = pPicture;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_MOUSEICON);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_MouseIcon(IPictureDisp** ppPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_MouseIcon\n"));
        if (!ppPicture) return E_POINTER;
		T* pT = (T*) this;
		*ppPicture = pT->m_pMouseIcon;
		if (*ppPicture != NULL)
			(*ppPicture)->AddRef();
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(OLE_COLOR, BackColor, clrBackColor, DISPID_BACKCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, BorderColor, clrBorderColor, DISPID_BORDERCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, FillColor, clrFillColor, DISPID_FILLCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, ForeColor, clrForeColor, DISPID_FORECOLOR)
	IMPLEMENT_BOOL_STOCKPROP(AutoSize, bAutoSize, DISPID_AUTOSIZE)
	IMPLEMENT_BOOL_STOCKPROP(Valid, bValid, DISPID_VALID)
	IMPLEMENT_BOOL_STOCKPROP(Enabled, bEnabled, DISPID_ENABLED)
	IMPLEMENT_BOOL_STOCKPROP(TabStop, bTabStop, DISPID_TABSTOP)
	IMPLEMENT_BOOL_STOCKPROP(BorderVisible, bBorderVisible, DISPID_BORDERVISIBLE)
	IMPLEMENT_BSTR_STOCKPROP(Text, bstrText, DISPID_TEXT)
	IMPLEMENT_BSTR_STOCKPROP(Caption, bstrCaption, DISPID_CAPTION)
	HRESULT STDMETHODCALLTYPE put_Window(long /*hWnd*/)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Window\n"));
		return E_FAIL;
	}
	HRESULT STDMETHODCALLTYPE get_Window(HWND* phWnd)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_Window\n"));
        if (!phWnd) return E_POINTER;
		T* pT = (T*) this;
		*phWnd = pT->m_hWnd;
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(LONG, BackStyle, nBackStyle, DISPID_BACKSTYLE)
	IMPLEMENT_STOCKPROP(LONG, BorderStyle, nBorderStyle, DISPID_BORDERSTYLE)
	IMPLEMENT_STOCKPROP(LONG, BorderWidth, nBorderWidth, DISPID_BORDERWIDTH)
	IMPLEMENT_STOCKPROP(LONG, DrawMode, nDrawMode, DISPID_DRAWMODE)
	IMPLEMENT_STOCKPROP(LONG, DrawStyle, nDrawStyle, DISPID_DRAWSTYLE)
	IMPLEMENT_STOCKPROP(LONG, DrawWidth, nDrawWidth, DISPID_DRAWWIDTH)
	IMPLEMENT_STOCKPROP(LONG, FillStyle, nFillStyle, DISPID_FILLSTYLE)
	IMPLEMENT_STOCKPROP(SHORT, Appearance, nAppearance, DISPID_APPEARANCE)
	IMPLEMENT_STOCKPROP(LONG, MousePointer, nMousePointer, DISPID_MOUSEPOINTER)
	IMPLEMENT_STOCKPROP(LONG, ReadyState, nReadyState, DISPID_READYSTATE)
};

#pragma pack(pop)

}; //namespace ATL

#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLCTL_IMPL
#endif
#endif

#endif // __ATLCTL_H__

#ifdef _ATLCTL_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif


//All exports go here


#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time 
#undef _ATLCTL_IMPL

#endif // _ATLCTL_IMPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\atl\atlcom.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.
#ifndef __ATLCOM_H__
#define __ATLCOM_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlcom.h requires atlbase.h to be included first
#endif

#pragma pack(push, _ATL_PACKING)

EXTERN_C const IID IID_ITargetFrame;

namespace ATL
{

#define CComConnectionPointContainerImpl IConnectionPointContainerImpl
#define CComISupportErrorInfoImpl ISupportErrorInfoImpl
#define CComProvideClassInfo2Impl IProvideClassInfoImpl
#define CComDualImpl IDispatchImpl

#ifdef _ATL_DEBUG_QI
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _ATL_DEBUG_QI

#ifdef _ATL_DEBUG_QI
#define _ATLDUMPIID(iid, name, hr) AtlDumpIID(iid, name, hr)
#else
#define _ATLDUMPIID(iid, name, hr) hr
#endif

#define _ATL_DEBUG_ADDREF_RELEASE_IMPL(className)\
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;\
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

#define ATL_LOCK() \
	ObjectLock objlock(this);

#define ATL_LOCKT() \
	T *pT = static_cast<T*>(this); \
	T::ObjectLock objlock(pT);

#define ATL_ROOT_LOCK() \
	ROOT *pROOT = static_cast<ROOT*>(this); \
	ROOT::ObjectLock objlock(pROOT);

/////////////////////////////////////////////////////////////////////////////
// AtlReportError

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, const IID& iid,
	HRESULT hRes, HINSTANCE hInst)
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), 0, NULL, iid, hRes, hInst);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), dwHelpID,
		lpszHelpFile, iid, hRes, hInst);
}

#ifndef OLE2ANSI
inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	DWORD dwHelpID, LPCSTR lpszHelpFile, const IID& iid, HRESULT hRes)
{
	ATLASSERT(lpszDesc != NULL);
	USES_CONVERSION;
	return AtlSetErrorInfo(clsid, A2COLE(lpszDesc), dwHelpID, A2CW(lpszHelpFile),
		iid, hRes, NULL);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	ATLASSERT(lpszDesc != NULL);
	USES_CONVERSION;
	return AtlSetErrorInfo(clsid, A2COLE(lpszDesc), 0, NULL, iid, hRes, NULL);
}
#endif

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	return AtlSetErrorInfo(clsid, lpszDesc, 0, NULL, iid, hRes, NULL);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes)
{
	return AtlSetErrorInfo(clsid, lpszDesc, dwHelpID, lpszHelpFile, iid, hRes, NULL);
}

//////////////////////////////////////////////////////////////////////////////
// IPersistImpl
template <class T>
class ATL_NO_VTABLE IPersistImpl : public IPersist
{
public:
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistImpl::GetClassID\n"));
		if (pClassID == NULL)
			return E_FAIL;
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// CComDispatchDriver / Specialization of CComQIPtr<IDispatch, IID_IDispatch>
class CComDispatchDriver
{
public:
	CComDispatchDriver()
	{
		p = NULL;
	}
	CComDispatchDriver(IDispatch* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComDispatchDriver(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(IID_IDispatch, (void **)&p);
	}
	~CComDispatchDriver() { if (p) p->Release(); }
	void Release() {if (p) p->Release(); p=NULL;}
	operator IDispatch*() {return p;}
	IDispatch& operator*() {ATLASSERT(p!=NULL); return *p; }
	IDispatch** operator&() {ATLASSERT(p==NULL); return &p; }
	IDispatch* operator->() {ATLASSERT(p!=NULL); return p; }
	IDispatch* operator=(IDispatch* lp){return (IDispatch*)AtlComPtrAssign((IUnknown**)&p, lp);}
	IDispatch* operator=(IUnknown* lp)
	{
		return (IDispatch*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IDispatch);
	}
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}

	HRESULT GetPropertyByName(LPCOLESTR lpsz, VARIANT* pVar)
	{
		ATLASSERT(p);
		ATLASSERT(pVar);
		DISPID dwDispID;
		HRESULT hr = GetIDOfName(lpsz, &dwDispID);
		if (SUCCEEDED(hr))
			hr = GetProperty(p, dwDispID, pVar);
		return hr;
	}
	HRESULT GetProperty(DISPID dwDispID, VARIANT* pVar)
	{
		ATLASSERT(p);
		return GetProperty(p, dwDispID, pVar);
	}
	HRESULT PutPropertyByName(LPCOLESTR lpsz, VARIANT* pVar)
	{
		ATLASSERT(p);
		ATLASSERT(pVar);
		DISPID dwDispID;
		HRESULT hr = GetIDOfName(lpsz, &dwDispID);
		if (SUCCEEDED(hr))
			hr = PutProperty(p, dwDispID, pVar);
		return hr;
	}
	HRESULT PutProperty(DISPID dwDispID, VARIANT* pVar)
	{
		ATLASSERT(p);
		return PutProperty(p, dwDispID, pVar);
	}
	HRESULT GetIDOfName(LPCOLESTR lpsz, DISPID* pdispid)
	{
		return p->GetIDsOfNames(IID_NULL, (LPOLESTR*)&lpsz, 1, LOCALE_USER_DEFAULT, pdispid);
	}
	// Invoke a method by DISPID with no parameters
	HRESULT Invoke0(DISPID dispid, VARIANT* pvarRet = NULL)
	{
		DISPPARAMS dispparams = { NULL, NULL, 0, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with no parameters
	HRESULT Invoke0(LPCOLESTR lpszName, VARIANT* pvarRet = NULL)
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = Invoke0(dispid, pvarRet);
		return hr;
	}
	// Invoke a method by DISPID with a single parameter
	HRESULT Invoke1(DISPID dispid, VARIANT* pvarParam1, VARIANT* pvarRet = NULL)
	{
		DISPPARAMS dispparams = { pvarParam1, NULL, 1, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with a single parameter
	HRESULT Invoke1(LPCOLESTR lpszName, VARIANT* pvarParam1, VARIANT* pvarRet = NULL)
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = Invoke1(dispid, pvarParam1, pvarRet);
		return hr;
	}
	// Invoke a method by DISPID with two parameters
	HRESULT Invoke2(DISPID dispid, VARIANT* pvarParam1, VARIANT* pvarParam2, VARIANT* pvarRet = NULL)
	{
        if(pvarParam1 == NULL || pvarParam2 == NULL)
                return E_INVALIDARG;
                        
		CComVariant varArgs[2] = { *pvarParam2, *pvarParam1 };
		DISPPARAMS dispparams = { &varArgs[0], NULL, 2, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with two parameters
	HRESULT Invoke2(LPCOLESTR lpszName, VARIANT* pvarParam1, VARIANT* pvarParam2, VARIANT* pvarRet = NULL)
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = Invoke2(dispid, pvarParam1, pvarParam2, pvarRet);
		return hr;
	}
	// Invoke a method by DISPID with N parameters
	HRESULT InvokeN(DISPID dispid, VARIANT* pvarParams, int nParams, VARIANT* pvarRet = NULL)
	{
		DISPPARAMS dispparams = { pvarParams, NULL, nParams, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with Nparameters
	HRESULT InvokeN(LPCOLESTR lpszName, VARIANT* pvarParams, int nParams, VARIANT* pvarRet = NULL)
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = InvokeN(dispid, pvarParams, nParams, pvarRet);
		return hr;
	}
	static HRESULT GetProperty(IDispatch* pDisp, DISPID dwDispID,
		VARIANT* pVar)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("CPropertyHelper::GetProperty\n"));
        ATLASSERT(pVar != NULL);
        if (pVar == NULL)
                return E_POINTER;
        
        if(pDisp == NULL)
                return E_INVALIDARG;
                        
		DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
		return pDisp->Invoke(dwDispID, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
				&dispparamsNoArgs, pVar, NULL, NULL);
	}

	static HRESULT PutProperty(IDispatch* pDisp, DISPID dwDispID,
		VARIANT* pVar)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("CPropertyHelper::PutProperty\n"));
        ATLASSERT(pVar != NULL);
        if (pVar == NULL)
                return E_POINTER;

        if(pDisp == NULL)
                return E_INVALIDARG;
                        
		DISPPARAMS dispparams = {NULL, NULL, 1, 1};
		dispparams.rgvarg = pVar;
		DISPID dispidPut = DISPID_PROPERTYPUT;
		dispparams.rgdispidNamedArgs = &dispidPut;

		if (pVar->vt == VT_UNKNOWN || pVar->vt == VT_DISPATCH || 
			(pVar->vt & VT_ARRAY) || (pVar->vt & VT_BYREF))
		{
			HRESULT hr = pDisp->Invoke(dwDispID, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUTREF,
				&dispparams, NULL, NULL, NULL);
			if (SUCCEEDED(hr))
				return hr;
		}

		return pDisp->Invoke(dwDispID, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT,
				&dispparams, NULL, NULL, NULL);
	}

	IDispatch* p;
};

//////////////////////////////////////////////////////////////////////////////
// CFakeFirePropNotifyEvent
class CFakeFirePropNotifyEvent
{
public:
	static HRESULT FireOnRequestEdit(IUnknown* /*pUnk*/, DISPID /*dispID*/)
	{
		return S_OK;
	}
	static HRESULT FireOnChanged(IUnknown* /*pUnk*/, DISPID /*dispID*/)
	{
		return S_OK;
	}
};
typedef CFakeFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;

//////////////////////////////////////////////////////////////////////////////
// ATL Persistence

struct ATL_PROPMAP_ENTRY
{
	LPCOLESTR szDesc;
	DISPID dispid;
	const CLSID* pclsidPropPage;
	const IID* piidDispatch;
	size_t dwOffsetData;
	DWORD dwSizeData;
	VARTYPE vt;
	const IID* piidUnknown;
};

// This one is DEPRECATED and is used for ATL 2.X controls
// it includes an implicit m_sizeExtent
#define BEGIN_PROPERTY_MAP(theClass) \
	typedef _ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \
	typedef theClass _PropMapClass; \
	static ATL_PROPMAP_ENTRY* GetPropertyMap()\
	{\
		static ATL_PROPMAP_ENTRY pPropMap[] = \
		{ \
			{OLESTR("_cx"), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, m_sizeExtent.cx), sizeof(long), VT_UI4, &IID_NULL}, \
			{OLESTR("_cy"), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, m_sizeExtent.cy), sizeof(long), VT_UI4, &IID_NULL},

class __declspec(uuid("2A6E293D-2595-11d3-B64C-00C04F79498E")) IChainPropMapFlagDummy {};

// This one can be used on any type of object, but does not
// include the implicit m_sizeExtent
#define BEGIN_PROP_MAP(theClass) \
	typedef _ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \
	typedef theClass _PropMapClass; \
	static ATL_PROPMAP_ENTRY* GetPropertyMap()\
	{\
		static ATL_PROPMAP_ENTRY pPropMap[] = \
		{

#define PROP_ENTRY(szDesc, dispid, clsid) \
		{OLESTR(szDesc), dispid, &clsid, &IID_IDispatch, 0, 0, 0, &IID_NULL},

#define PROP_ENTRY_EX(szDesc, dispid, clsid, iidDispatch) \
		{OLESTR(szDesc), dispid, &clsid, &iidDispatch, 0, 0, 0, &IID_NULL},

#define PROP_PAGE(clsid) \
		{NULL, NULL, &clsid, &IID_NULL, 0, 0, 0, &IID_NULL},

#define CHAIN_PROP_MAP(theChainClass) \
        {NULL, 0, reinterpret_cast<CLSID*>(&theChainClass::GetPropertyMap), \
            &__uuidof(IChainPropMapFlagDummy), offsetofclass(theChainClass, _PropMapClass), 0, VT_NULL, &IID_NULL},

#define PROP_DATA_ENTRY(szDesc, member, vt) \
		{OLESTR(szDesc), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, member), sizeof(((_PropMapClass*)0)->member), vt, &IID_NULL},

#define PROP_DATA_QI_ENTRY(szDesc, member, iid) \
		{OLESTR(szDesc), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, member), sizeof(((_PropMapClass*)0)->member), VT_UNKNOWN, &iid},

#define END_PROPERTY_MAP() \
			{NULL, 0, NULL, &IID_NULL, 0, 0, 0, &IID_NULL} \
		}; \
		return pPropMap; \
	}

#define END_PROP_MAP() \
			{NULL, 0, NULL, &IID_NULL, 0, 0, 0, &IID_NULL} \
		}; \
		return pPropMap; \
	}

#define MARK_DIRTY(T) \
	static_cast<T*>(this)->m_bRequiresSave = true;

#define CLEAR_DIRTY() \
	static_cast<T*>(this)->m_bRequiresSave = false;

#define IS_DIRTY(T) \
	(static_cast<T*>(this)->m_bRequiresSave)

#ifdef _ATL_DLL
ATLAPI AtlIPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk)
{
	ATLASSERT(pMap != NULL);
    if (pStm == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)
        return E_INVALIDARG;

	HRESULT hr = S_OK;
	DWORD dwVer;
	hr = pStm->Read(&dwVer, sizeof(DWORD), NULL);
	if (FAILED(hr))
		return hr;
	if (dwVer > _ATL_VER)
		return E_FAIL;

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (pMap[i].szDesc == NULL)
			continue;

		// check if raw data entry
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
			hr = pStm->Read(pData, pMap[i].dwSizeData, NULL);
			if (FAILED(hr))
				return hr;
			continue;
		}

		CComVariant var;

		hr = var.ReadFromStream(pStm);
		if (FAILED(hr))
			break;

		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				hr = E_FAIL;
				break;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			hr = E_FAIL;
			break;
		}
	}
	return hr;
}
#endif //_ATL_DLL

#ifdef _ATL_DLL
ATLAPI AtlIPersistStreamInit_Save(LPSTREAM pStm, BOOL fClearDirty, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistStreamInit_Save(LPSTREAM pStm,
	BOOL /* fClearDirty */, ATL_PROPMAP_ENTRY* pMap,
	void* pThis, IUnknown* pUnk)
{
	ATLASSERT(pMap != NULL);
    if (pStm == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)
            return E_INVALIDARG;
	DWORD dw = _ATL_VER;
	HRESULT hr = pStm->Write(&dw, sizeof(DWORD), NULL);
	if (FAILED(hr))
		return hr;

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (pMap[i].szDesc == NULL)
			continue;

		// check if raw data entry
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
			hr = pStm->Write(pData, pMap[i].dwSizeData, NULL);
			if (FAILED(hr))
				return hr;
			continue;
		}

		CComVariant var;
		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				hr = E_FAIL;
				break;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			hr = E_FAIL;
			break;
		}

		hr = var.WriteToStream(pStm);
		if (FAILED(hr))
			break;
	}
	return hr;
}
#endif //_ATL_DLL


#ifdef _ATL_DLL
ATLAPI AtlIPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk)
{
    if (pPropBag == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)
            return E_INVALIDARG;

	USES_CONVERSION;
	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
        // disable for map chaining
		//if (pMap[i].szDesc == NULL)
		//	continue;

		CComVariant var;

		// If raw entry skip it - we don't handle it for property bags just yet
        HRESULT hr;
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
            var.vt = pMap[i].vt;
			hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
            // undone: this code assumes that var.vt is the same after the read
            // as it was when it got passed in. i.e it assumes that the bag won't
            // ever change the type which is an unsafe assumption.
            // we need to do something if pmap[i].vt != var.vt
			if (SUCCEEDED(hr))
			{
				// check the type - we only deal with limited set
				switch (pMap[i].vt)
				{
				case VT_UI1:
				case VT_I1:
					*((BYTE*)pData) = var.bVal;
					break;
				case VT_BOOL:
					*((VARIANT_BOOL*)pData) = var.boolVal;
					break;
                case VT_I2:
				case VT_UI2:
					*((short*)pData) = var.iVal;
					break;
                case VT_I4:
				case VT_UI4:
				case VT_INT:
				case VT_UINT:
					*((long*)pData) = var.lVal;
					break;
			    case VT_UNKNOWN:
					if (var.punkVal != NULL)
						var.punkVal->QueryInterface(*(pMap[i].piidUnknown), (void **) pData);
					else
						*((BYTE*)pData) = NULL;
					break;
			    case VT_DISPATCH:
					if (var.punkVal != NULL)
						var.punkVal->QueryInterface(__uuidof(IDispatch), (void **) pData);
					else
						*((BYTE*)pData) = NULL;
					break;
				case VT_VECTOR | VT_UI1:
					*(reinterpret_cast<SAFEARRAY **>(pData)) = var.parray;
					break;
                case VT_BSTR:
				case VT_BSTR_BLOB: {
					*(reinterpret_cast<BSTR*>(pData)) = var.bstrVal;
                    var.bstrVal = NULL;
					break;
				}
                case VT_CLSID:
                    if (var.vt == VT_BSTR) {
                        HRESULT hr = CLSIDFromString(var.bstrVal, reinterpret_cast<CLSID *>(pData));
                        if (FAILED(hr)) {
                            _ASSERT(false);
                            memset(pData, 0, sizeof(CLSID));
                        }
                    } else {
                        memset(pData, 0, sizeof(CLSID));
                    }
                    break;
				}
			}
			continue;
		}

        if (*pMap[i].piidDispatch == __uuidof(IChainPropMapFlagDummy)) {
            ATL_PROPMAP_ENTRY* (*pGetFunc)() = 
                    reinterpret_cast<ATL_PROPMAP_ENTRY*(*)()>(pMap[i].pclsidPropPage);
            ATL_PROPMAP_ENTRY *p = (*pGetFunc)();
            if (!p) {
                return E_FAIL;
            }
            hr = AtlIPersistPropertyBag_Load(pPropBag, pErrorLog, p, 
				reinterpret_cast<void*>(pMap[i].dwOffsetData + (DWORD_PTR)pThis), pUnk);
            if (FAILED(hr)) {
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to Chain Property Bag idx = %d\n"), i);
                return hr;
            }
            continue;
        }
		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				return E_FAIL;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}

		hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
		if (FAILED(hr))
		{
			if (hr == E_INVALIDARG)
			{
                USES_CONVERSION;
                LPCTSTR lp = OLE2CT(pMap[i].szDesc);
                if(lp == NULL)
                        ATLTRACE2(atlTraceCOM, 0, _T("Property not in Bag\n"));
                else
                        ATLTRACE2(atlTraceCOM, 0, _T("Property %s not in Bag\n"), lp);
			}
			else
			{
				// Many containers return different ERROR values for Member not found
                USES_CONVERSION;
                LPCTSTR lp = OLE2CT(pMap[i].szDesc);
                if(lp == NULL)
                        ATLTRACE2(atlTraceCOM, 0, _T("Error attempting to read Property from PropertyBag \n"));
                else
                        ATLTRACE2(atlTraceCOM, 0, _T("Error attempting to read Property %s from PropertyBag \n"), lp);
			}
			continue;
		}

		if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}
	}
	return S_OK;
}
#endif //_ATL_DLL

#ifdef _ATL_DLL
ATLAPI AtlIPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistPropertyBag_Save(LPPROPERTYBAG pPropBag,
	BOOL fClearDirty, BOOL fSaveAllProperties,
	ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk)
{
	if (pPropBag == NULL)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("PropBag pointer passed in was invalid\n"));
		return E_POINTER;
	}
    if (pMap == NULL || pThis == NULL || pUnk == NULL)
            return E_INVALIDARG;
    
	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
    HRESULT hr;
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
        // disable for map chaining
        //if (pMap[i].szDesc == NULL)
		//	continue;

		CComVariant var;

		// If raw entry skip it - we don't handle it for property bags just yet
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
			// check the type - we only deal with limited set
			var.vt = pMap[i].vt;
			bool bTypeOK = false;
			switch (pMap[i].vt)
			{
			case VT_UI1:
			case VT_I1:
				var.bVal = *((BYTE*)pData);
				bTypeOK = true;
				break;
			case VT_BOOL:
				var.boolVal = *((VARIANT_BOOL*)pData);
				bTypeOK = true;
				break;
            case VT_I2:
			case VT_UI2:
				var.iVal = *((short*)pData);
				bTypeOK = true;
				break;
            case VT_I4:
			case VT_UI4:
			case VT_INT:
			case VT_UINT:
				var.lVal = *((long*)pData);
				bTypeOK = true;
				break;
			case VT_UNKNOWN:
                var.punkVal = *(reinterpret_cast<IUnknown **>(pData));
                if (var.punkVal) {
                    var.punkVal->AddRef();
                    bTypeOK = true;
                }
				break;
			case VT_DISPATCH:
                var.pdispVal = *(reinterpret_cast<IDispatch **>(pData));
                if (var.pdispVal) {
                    var.pdispVal->AddRef();
                    bTypeOK = true;
                }
				break;
			case VT_ARRAY | VT_UI1:
				var.parray = reinterpret_cast<SAFEARRAY *>(pData);
				bTypeOK = true;
				break;
            case VT_BSTR_BLOB:
			case VT_BSTR: {
				BSTR *pBS = reinterpret_cast<BSTR*>(pData);
				if (*pBS != NULL) {
					UINT len = ::SysStringLen(*pBS);
	                var.bstrVal = ::SysAllocStringLen(*pBS, len);
                    bTypeOK = true;
				} else {
					var.bstrVal = NULL;
				}
				break;
			}
            case VT_CLSID: {
                var.vt = VT_BSTR;
                CComBSTR b(*(reinterpret_cast<GUID *>(pData)));
                hr = b.CopyTo(&var.bstrVal);
                _ASSERT(SUCCEEDED(hr));
                bTypeOK = true;
                break;
            }
			}
			if (bTypeOK)
			{
				hr = pPropBag->Write(pMap[i].szDesc, &var);
				if (FAILED(hr))
					return hr;
			}
            if (var.vt == VT_BSTR_BLOB) {
                var.vt = VT_BSTR;
            }
			continue;
		}

        if (*pMap[i].piidDispatch == __uuidof(IChainPropMapFlagDummy)) {
            ATL_PROPMAP_ENTRY* (*pGetFunc)() = 
                    reinterpret_cast<ATL_PROPMAP_ENTRY*(*)()>(pMap[i].pclsidPropPage);
            ATL_PROPMAP_ENTRY *p = (*pGetFunc)();
            if (!p) {
                return E_FAIL;
            }
            hr = AtlIPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties,
                p, 
                reinterpret_cast<void*>(pMap[i].dwOffsetData + (DWORD_PTR)pThis), pUnk);
            if (FAILED(hr)) {
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to Chain Property Bag idx = %d\n"), i);
                return hr;
            }
            continue;
        }

		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				return E_FAIL;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}

		if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
		{
			if (var.punkVal == NULL)
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Warning skipping empty IUnknown in Save\n"));
				continue;
			}
		}

		HRESULT hr = pPropBag->Write(pMap[i].szDesc, &var);
		if (FAILED(hr))
			return hr;
	}
	return S_OK;
}
#endif //_ATL_DLL


//////////////////////////////////////////////////////////////////////////////
// IPersistStreamInitImpl
template <class T>
class ATL_NO_VTABLE IPersistStreamInitImpl : public IPersistStreamInit
{
public:
	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::GetClassID\n"));
        ATLASSERT(pClassID != NULL);
        if (pClassID == NULL)
                return E_POINTER;
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}

	// IPersistStream
	STDMETHOD(IsDirty)()
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::IsDirty\n"));
		T* pT = static_cast<T*>(this);
		return (pT->m_bRequiresSave) ? S_OK : S_FALSE;
	}
	STDMETHOD(Load)(LPSTREAM pStm)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		return pT->IPersistStreamInit_Load(pStm, T::GetPropertyMap());
	}
	STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::Save\n"));
		return pT->IPersistStreamInit_Save(pStm, fClearDirty, T::GetPropertyMap());
	}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* /* pcbSize */)
	{
		ATLTRACENOTIMPL(_T("IPersistStreamInitImpl::GetSizeMax"));
	}

	// IPersistStreamInit
	STDMETHOD(InitNew)()
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::InitNew\n"));
		return S_OK;
	}

	HRESULT IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr = AtlIPersistStreamInit_Load(pStm, pMap, pT, pT->GetUnknown());
		if (SUCCEEDED(hr))
			pT->m_bRequiresSave = FALSE;
		return hr;

	}
	HRESULT IPersistStreamInit_Save(LPSTREAM pStm, BOOL fClearDirty, ATL_PROPMAP_ENTRY* pMap)
	{
		T* pT = static_cast<T*>(this);
		return AtlIPersistStreamInit_Save(pStm, fClearDirty, pMap, pT, pT->GetUnknown());
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPersistStorageImpl
template <class T>
class ATL_NO_VTABLE IPersistStorageImpl : public IPersistStorage
{
public:
	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::GetClassID\n"));
        ATLASSERT(pClassID != NULL);
        if (pClassID == NULL)
                return E_POINTER;
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}

	// IPersistStorage
	STDMETHOD(IsDirty)(void)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::IsDirty\n"));
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->IsDirty() : E_FAIL;
	}
	STDMETHOD(InitNew)(IStorage*)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::InitNew\n"));
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->InitNew() : E_FAIL;
	}
	STDMETHOD(Load)(IStorage* pStorage)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::Load\n"));
        if (pStorage == NULL)
                return E_INVALIDARG;
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			hr = pStorage->OpenStream(OLESTR("Contents"), NULL,
				STGM_DIRECT | STGM_SHARE_EXCLUSIVE, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Load(spStream);
		}
		return hr;
	}
	STDMETHOD(Save)(IStorage* pStorage, BOOL fSameAsLoad)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::Save\n"));
        if (pStorage == NULL)
                return E_INVALIDARG;
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			static LPCOLESTR vszContents = OLESTR("Contents");
			hr = pStorage->CreateStream(vszContents,
				STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
				0, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Save(spStream, fSameAsLoad);
		}
		return hr;
	}
	STDMETHOD(SaveCompleted)(IStorage* /* pStorage */)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::SaveCompleted\n"));
		return S_OK;
	}
	STDMETHOD(HandsOffStorage)(void)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::HandsOffStorage\n"));
		return S_OK;
	}
private:
	IPersistStreamInit* IPSI_GetIPersistStreamInit();
};

template <class T>
IPersistStreamInit* IPersistStorageImpl<T>::IPSI_GetIPersistStreamInit()
{
	T* pT = static_cast<T*>(this);
	IPersistStreamInit* p;
	if (FAILED(pT->GetUnknown()->QueryInterface(IID_IPersistStreamInit, (void**)&p)))
		pT->_InternalQueryInterface(IID_IPersistStreamInit, (void**)&p);
	return p;
}


//////////////////////////////////////////////////////////////////////////////
// IPersistPropertyBagImpl
template <class T>
class ATL_NO_VTABLE IPersistPropertyBagImpl : public IPersistPropertyBag
{
public:
	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::GetClassID\n"));
        ATLASSERT(pClassID != NULL);
        if (pClassID == NULL)
                return E_POINTER;
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}

	// IPersistPropertyBag
	//
	STDMETHOD(InitNew)()
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::InitNew\n"));
		return S_OK;
	}
	STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		ATLASSERT(pMap != NULL);
		return pT->IPersistPropertyBag_Load(pPropBag, pErrorLog, pMap);
	}
	STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::Save\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		ATLASSERT(pMap != NULL);
		return pT->IPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap);
	}
	HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap)
	{
		ATL_LOCKT();
		HRESULT hr = AtlIPersistPropertyBag_Load(pPropBag, pErrorLog, pMap, pT, pT->GetUnknown());
		if (SUCCEEDED(hr)) {
			pT->m_bRequiresSave = FALSE;
		}
		return hr;
	}
	HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap)
	{
		ATL_LOCKT();
		HRESULT hr = AtlIPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap, pT, pT->GetUnknown());
		if (SUCCEEDED(hr) && fClearDirty) {
			pT->m_bRequiresSave = FALSE;
		}
		return hr;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CSecurityDescriptor
class CSecurityDescriptor
{
public:
        CSecurityDescriptor();
        ~CSecurityDescriptor();

public:
        HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD);
        HRESULT AttachObject(HANDLE hObject);
        HRESULT Initialize();
        HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);
        HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);
        HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);
        HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);
        HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask);
        HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask);
        HRESULT Revoke(LPCTSTR pszPrincipal);

        // utility functions
        // Any PSID you get from these functions should be free()ed
        static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL);
        static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);
        static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);
        static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = FALSE);
        static HRESULT CopyACL(PACL pDest, PACL pSrc);
        static HRESULT GetCurrentUserSID(PSID *ppSid);
        static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);
        static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
        static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
        static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

        operator PSECURITY_DESCRIPTOR()
        {
                return m_pSD;
        }

public:
        PSECURITY_DESCRIPTOR m_pSD;
        PSID m_pOwner;
        PSID m_pGroup;
        PACL m_pDACL;
        PACL m_pSACL;
};

inline CSecurityDescriptor::CSecurityDescriptor()
{
        m_pSD = NULL;
        m_pOwner = NULL;
        m_pGroup = NULL;
        m_pDACL = NULL;
        m_pSACL= NULL;
}

inline CSecurityDescriptor::~CSecurityDescriptor()
{
        if (m_pSD)
                delete m_pSD;
        if (m_pOwner)
                free(m_pOwner);
        if (m_pGroup)
                free(m_pGroup);
        if (m_pDACL)
                free(m_pDACL);
        if (m_pSACL)
                free(m_pSACL);
}

inline HRESULT CSecurityDescriptor::Initialize()
{
        if (m_pSD)
        {
                delete m_pSD;
                m_pSD = NULL;
        }
        if (m_pOwner)
        {
                free(m_pOwner);
                m_pOwner = NULL;
        }
        if (m_pGroup)
        {
                free(m_pGroup);
                m_pGroup = NULL;
        }
        if (m_pDACL)
        {
                free(m_pDACL);
                m_pDACL = NULL;
        }
        if (m_pSACL)
        {
                free(m_pSACL);
                m_pSACL = NULL;
        }

        ATLTRY(m_pSD = new SECURITY_DESCRIPTOR);
        if (m_pSD == NULL)
                return E_OUTOFMEMORY;

        if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                delete m_pSD;
                m_pSD = NULL;
                ATLASSERT(FALSE);
                return hr;
        }
        return S_OK;
}

inline HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
        PSID pUserSid = NULL;
        PSID pGroupSid = NULL;
        
        HRESULT hr = Initialize();
        if (FAILED(hr))
                return hr;
        hr = GetProcessSids(&pUserSid, &pGroupSid);
        if (SUCCEEDED(hr))
        {
                hr = SetOwner(pUserSid, bDefaulted);
                if (SUCCEEDED(hr))
                        hr = SetGroup(pGroupSid, bDefaulted);
        }
        if (pUserSid != NULL)
                free(pUserSid);
        if (pGroupSid != NULL)
                free(pGroupSid);

        if (FAILED(hr))
        {
                delete m_pSD;
                m_pSD = NULL;
                
                free(m_pOwner);
                m_pOwner = NULL;
                
                ATLASSERT(FALSE);                
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
        PSID pUserSid = NULL;
        PSID pGroupSid = NULL;
        
        HRESULT hr = Initialize();
        if (FAILED(hr))
                return hr;
        
        hr = GetThreadSids(&pUserSid, &pGroupSid);
        if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
                hr = GetProcessSids(&pUserSid, &pGroupSid);
        if (SUCCEEDED(hr))
        {
                hr = SetOwner(pUserSid, bDefaulted);
                if (SUCCEEDED(hr))
                        hr = SetGroup(pGroupSid, bDefaulted);
        }
        if (pUserSid != NULL)
                free(pUserSid);
        if (pGroupSid != NULL)
                free(pGroupSid);

        if (FAILED(hr))
        {
                delete m_pSD;
                m_pSD = NULL;
                
                free(m_pOwner);
                m_pOwner = NULL;
                
                ATLASSERT(FALSE);                
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
        ATLASSERT(m_pSD);

        // Mark the SD as having no owner
        if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                return hr;
        }

        if (m_pOwner)
        {
                free(m_pOwner);
                m_pOwner = NULL;
        }

        // If they asked for no owner don't do the copy
        if (pOwnerSid == NULL)
                return S_OK;

        if (!IsValidSid(pOwnerSid))
        {
                return E_INVALIDARG;
        }
        
        // Make a copy of the Sid for the return value
        DWORD dwSize = GetLengthSid(pOwnerSid);

        m_pOwner = (PSID) malloc(dwSize);
        if (m_pOwner == NULL)
                return E_OUTOFMEMORY;
        if (!CopySid(dwSize, m_pOwner, pOwnerSid))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pOwner);
                m_pOwner = NULL;
                return hr;
        }

        ATLASSERT(IsValidSid(m_pOwner));

        if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pOwner);
                m_pOwner = NULL;
                return hr;
        }

        return S_OK;
}

inline HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
        ATLASSERT(m_pSD);

        // Mark the SD as having no Group
        if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                return hr;
        }

        if (m_pGroup)
        {
                free(m_pGroup);
                m_pGroup = NULL;
        }

        // If they asked for no Group don't do the copy
        if (pGroupSid == NULL)
                return S_OK;

        if (!IsValidSid(pGroupSid))
        {
                return E_INVALIDARG;
        }
        
        // Make a copy of the Sid for the return value
        DWORD dwSize = GetLengthSid(pGroupSid);

        m_pGroup = (PSID) malloc(dwSize);
        if (m_pGroup == NULL)
                return E_OUTOFMEMORY;
        if (!CopySid(dwSize, m_pGroup, pGroupSid))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pGroup);
                m_pGroup = NULL;
                return hr;
        }

        ATLASSERT(IsValidSid(m_pGroup));

        if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pGroup);
                m_pGroup = NULL;
                return hr;
        }

        return S_OK;
}

inline HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
        if (SUCCEEDED(hr))
        {
                if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
                {
                        hr = AtlHresultFromLastError();
                }
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
        if (SUCCEEDED(hr))
        {
                if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
                {
                        hr = AtlHresultFromLastError();
                }
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
        HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
        if (SUCCEEDED(hr))
        {
                if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
                {
                        hr = AtlHresultFromLastError();
                }
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
        BOOL bRes;
        HRESULT hr;
        HANDLE hToken = NULL;
        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;
        bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
        if (!bRes)
        {
                // Couldn't open process token
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                return hr;
        }
        hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
        CloseHandle(hToken);
        return hr;
}

inline HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
        BOOL bRes;
        HRESULT hr;
        HANDLE hToken = NULL;
        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;
        bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
        if (!bRes)
        {
                // Couldn't open thread token
                hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
        }
        hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
        CloseHandle(hToken);
        return hr;
}

inline HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
        DWORD dwSize = 0;
        HRESULT hr = E_FAIL;
        DWORD dwErr;
        PTOKEN_USER ptkUser = NULL;
        PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;

        if (ppUserSid)
        {
                // Get length required for TokenUser by specifying buffer length of 0
                GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
                dwErr = GetLastError();
                if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                {
                        // Expected ERROR_INSUFFICIENT_BUFFER
                        ATLASSERT(FALSE);
                        hr = AtlHresultFromWin32(dwErr);
                        goto failed;
                }

                ptkUser = (TOKEN_USER*) malloc(dwSize);
                if (ptkUser == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                // Get Sid of process token.
                if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
                {
                        // Couldn't get user info
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        goto failed;
                }

                // Make a copy of the Sid for the return value
                dwSize = GetLengthSid(ptkUser->User.Sid);

                PSID pSid;
                pSid = (PSID) malloc(dwSize);
                if (pSid == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        free(pSid);
                        ATLASSERT(FALSE);
                        goto failed;
                }

                ATLASSERT(IsValidSid(pSid));
                *ppUserSid = pSid;
                free(ptkUser);
                ptkUser = NULL;
        }
        if (ppGroupSid)
        {
                // Get length required for TokenPrimaryGroup by specifying buffer length of 0
                GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
                dwErr = GetLastError();
                if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                {
                        // Expected ERROR_INSUFFICIENT_BUFFER
                        ATLASSERT(FALSE);
                        hr = AtlHresultFromWin32(dwErr);
                        goto failed;
                }

                ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize);
                if (ptkGroup == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                // Get Sid of process token.
                if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
                {
                        // Couldn't get user info
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        goto failed;
                }

                // Make a copy of the Sid for the return value
                dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

                PSID pSid;
                pSid = (PSID) malloc(dwSize);
                if (pSid == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        free(pSid);
                        ATLASSERT(FALSE);
                        goto failed;
                }

                ATLASSERT(IsValidSid(pSid));

                *ppGroupSid = pSid;
                free(ptkGroup);
                ptkGroup = NULL;
        }

        return S_OK;

failed:
        if (ptkUser)
                free(ptkUser);
        if (ptkGroup)
                free (ptkGroup);
        return hr;
}


inline HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
        HANDLE tkHandle;
        
        if (ppSid == NULL)
        {
                return E_POINTER;
        }

        if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
        {
                TOKEN_USER *tkUser;
                DWORD tkSize;
                DWORD sidLength;

                // Call to get size information for alloc
                GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
                DWORD dwErr = GetLastError();
                if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                {
                        // Expected ERROR_INSUFFICIENT_BUFFER
                        HRESULT hr = AtlHresultFromWin32(dwErr);
                        ATLASSERT(FALSE);                        
                        CloseHandle(tkHandle);
                        return hr;
                }                
                tkUser = (TOKEN_USER *) malloc(tkSize);
                if (tkUser == NULL)
                {
                        CloseHandle(tkHandle);
                        return E_OUTOFMEMORY;
                }

                // Now make the real call
                if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
                {
                        sidLength = GetLengthSid(tkUser->User.Sid);
                        *ppSid = (PSID) malloc(sidLength);
                        if (*ppSid == NULL)
                        {
                                CloseHandle(tkHandle);
                                free(tkUser);                                
                                return E_OUTOFMEMORY;
                        }
                        if (!CopySid(sidLength, *ppSid, tkUser->User.Sid))
                        {
                                HRESULT hr = AtlHresultFromWin32(dwErr);
                                CloseHandle(tkHandle);
                                free(tkUser);
                                free(*ppSid);
                                *ppSid = NULL;
                                return hr;
                        }

                        CloseHandle(tkHandle);
                        free(tkUser);
                        return S_OK;
                }
                else
                {
                        HRESULT hr = AtlHresultFromLastError();                
                        CloseHandle(tkHandle);
                        free(tkUser);
                        return hr;
                }
        }
        return HRESULT_FROM_WIN32(GetLastError());
}


inline HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
        LPTSTR pszRefDomain = NULL;
        DWORD dwDomainSize = 0;
        DWORD dwSidSize = 0;
        SID_NAME_USE snu;
        
        if (ppSid == NULL)
        {
                return E_POINTER;
        }
        if (pszPrincipal == NULL)
        {
                return E_INVALIDARG;
        }

        // Call to get size info for alloc
        LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

        DWORD dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                return HRESULT_FROM_WIN32(dwErr);

        ATLTRY(pszRefDomain = new TCHAR[dwDomainSize]);
        if (pszRefDomain == NULL)
                return E_OUTOFMEMORY;

        *ppSid = (PSID) malloc(dwSidSize);
        if (*ppSid != NULL)
        {
                if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
                {
                        HRESULT hr = AtlHresultFromLastError();                
                        free(*ppSid);
                        *ppSid = NULL;
                        delete[] pszRefDomain;
                        return hr;
                }
                delete[] pszRefDomain;
                return S_OK;
        }
        delete[] pszRefDomain;
        return E_OUTOFMEMORY;
}


inline HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
        PACL    pDACL = NULL;
        PACL    pSACL = NULL;
        BOOL    bDACLPresent, bSACLPresent;
        BOOL    bDefaulted;
        PSID    pUserSid;
        PSID    pGroupSid;
        
        if (pSelfRelativeSD == NULL ||!IsValidSecurityDescriptor(pSelfRelativeSD))
                return E_INVALIDARG;

        HRESULT hr = Initialize();
        if(FAILED(hr))
                return hr;

        // get the existing DACL.
        if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
                goto failed;

        if (bDACLPresent)
        {
                if (pDACL)
                {
                        // allocate new DACL.
                        m_pDACL = (PACL) malloc(pDACL->AclSize);
                        if (m_pDACL == NULL)
                        {
                                hr = E_OUTOFMEMORY;
                                goto failedMemory;
                        }

                        // initialize the DACL
                        if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
                                goto failed;

                        // copy the ACES
                        hr = CopyACL(m_pDACL, pDACL);
                        if (FAILED(hr))
                                goto failedMemory;

                        if (!IsValidAcl(m_pDACL))
                                goto failed;
                }

                // set the DACL
                if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
                        goto failed;
        }

        // get the existing SACL.
        if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
                goto failed;

        if (bSACLPresent)
        {
                if (pSACL)
                {
                        // allocate new SACL.
                        m_pSACL = (PACL) malloc(pSACL->AclSize);
                        if (m_pSACL == NULL)
                        {
                                hr = E_OUTOFMEMORY;
                                goto failedMemory;
                        }

                        // initialize the SACL
                        if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
                                goto failed;

                        // copy the ACES
                        hr = CopyACL(m_pSACL, pSACL);
                        if (FAILED(hr))
                                goto failedMemory;

                        if (!IsValidAcl(m_pSACL))
                                goto failed;
                }

                // set the SACL
                if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
                        goto failed;
        }

        if (!GetSecurityDescriptorOwner(pSelfRelativeSD, &pUserSid, &bDefaulted))
                goto failed;

        if (FAILED(SetOwner(pUserSid, bDefaulted)))
                goto failed;

        if (!GetSecurityDescriptorGroup(pSelfRelativeSD, &pGroupSid, &bDefaulted))
                goto failed;

        if (FAILED(SetGroup(pGroupSid, bDefaulted)))
                goto failed;

        if (!IsValidSecurityDescriptor(m_pSD))
        {
                hr = E_FAIL;
                goto failedMemory;
        }

        return S_OK;

failed:
        hr = AtlHresultFromLastError();

failedMemory:
        if (m_pDACL)
        {
                free(m_pDACL);
                m_pDACL = NULL;
        }
        if (m_pSACL)
        {
                free(m_pSACL);
                m_pSACL = NULL;
        }
        if (m_pSD)
        {
                free(m_pSD);
                m_pSD = NULL;
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
        HRESULT hr;
        DWORD dwSize = 0;
        PSECURITY_DESCRIPTOR pSD = NULL;

        GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

        DWORD dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                return HRESULT_FROM_WIN32(dwErr);

        pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize);
        if (pSD == NULL)
                return E_OUTOFMEMORY;

        if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                free(pSD);
                return hr;
        }

        hr = Attach(pSD);
        free(pSD);
        return hr;
}


inline HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        LPVOID pAce;
        ACE_HEADER *aceHeader;

        if (pDest == NULL)
                return E_POINTER;
        if (pSrc == NULL)
                return S_OK;
        
        if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
                return HRESULT_FROM_WIN32(GetLastError());
        
        // Copy all of the ACEs to the new ACL
        for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
        {
                if (!GetAce(pSrc, i, &pAce))
                        return HRESULT_FROM_WIN32(GetLastError());

                aceHeader = (ACE_HEADER *) pAce;

                if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
                        return HRESULT_FROM_WIN32(GetLastError());
        }

        return S_OK;
}

inline HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        int aclSize;
        PSID principalSID;
        PACL oldACL, newACL = NULL;
        
        if (ppAcl == NULL)
                return E_POINTER;
                
        if (pszPrincipal == NULL)
                return E_INVALIDARG;

        oldACL = *ppAcl;

        HRESULT hr = GetPrincipalSID(pszPrincipal, &principalSID);
        if (FAILED(hr))
                return hr;

        aclSizeInfo.AclBytesInUse = 0;
        if (*ppAcl != NULL && 
                !GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        {
                free(principalSID);        
                return AtlHresultFromLastError();
        }

        aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) +        // size of original ACL
                sizeof(ACCESS_DENIED_ACE) +                                         // size of ACE
                GetLengthSid(principalSID) -                                         // Actual size of SID
                sizeof(DWORD);                                                                        // subtract size of placeholder variable 
                                                                                                                // for SID in ACCESS_*_ACE structure

        newACL = (PACL) malloc(aclSize);
        if (newACL == NULL)
        {
                free(principalSID);        
                return E_OUTOFMEMORY;
        }

        if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
        {
                hr = AtlHresultFromLastError();
                free(newACL);
                free(principalSID);
                return hr;
        }

        if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
        {
                hr = AtlHresultFromLastError();
                free(newACL);
                free(principalSID);
                return hr;
        }

        hr = CopyACL(newACL, oldACL);
        if (FAILED(hr))
        {
                free(newACL);
                free(principalSID);
                return hr;
        }

        *ppAcl = newACL;

        if (oldACL != NULL)
                free(oldACL);
        free(principalSID);
        return S_OK;
}


inline HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        int aclSize;
        PSID principalSID;
        PACL oldACL, newACL = NULL;
        
        if (ppAcl == NULL)
                return E_POINTER;
                
        if (pszPrincipal == NULL)
                return E_INVALIDARG;

        oldACL = *ppAcl;

        HRESULT hr = GetPrincipalSID(pszPrincipal, &principalSID);
        if (FAILED(hr))
                return hr;

        aclSizeInfo.AclBytesInUse = 0;
        if (*ppAcl != NULL && 
                !GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
                return AtlHresultFromLastError();

        aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + // size of original ACL
                sizeof(ACCESS_ALLOWED_ACE) +                                         // size of ACE
                GetLengthSid(principalSID) -                                         // Actual size of SID
                sizeof(DWORD);                                                                        // subtract size of placeholder variable 
                                                                                                                // for SID in ACCESS_*_ACE structure

        newACL = (PACL) malloc(aclSize);
        if (newACL == NULL)
        {
                free(principalSID);        
                return E_OUTOFMEMORY;
        }

        if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
        {
                hr = AtlHresultFromLastError();
                free(newACL);
                free(principalSID);
                return hr;
        }

        if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
        {
                hr = AtlHresultFromLastError();
                free(newACL);
                free(principalSID);
                return hr;
        }

        hr = CopyACL(newACL, oldACL);
        if (FAILED(hr))
        {
                free(newACL);
                free(principalSID);
                return hr;
        }

        *ppAcl = newACL;

        if (oldACL != NULL)
                free(oldACL);
        free(principalSID);
        return S_OK;
}

inline HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
        if (pAcl == NULL || pszPrincipal == NULL)
                return E_INVALIDARG;

        PSID principalSID;
        HRESULT hr = GetPrincipalSID(pszPrincipal, &principalSID);
        if (FAILED(hr))
                return hr;

        ACL_SIZE_INFORMATION aclSizeInfo;
        if (!GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        {
                hr = AtlHresultFromLastError();
                aclSizeInfo.AceCount = 0;
        }
                
        for (ULONG i = aclSizeInfo.AceCount; i > 0; i--)
        {
                ULONG uIndex = i - 1;
                LPVOID ace;        
                if (!GetAce(pAcl, uIndex, &ace))
                {
                        hr = AtlHresultFromLastError();
                        break;
                }

                ACE_HEADER *aceHeader = (ACE_HEADER *) ace;

                if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
                {
                        ACCESS_ALLOWED_ACE *accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;
                        if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
                        {
                                DeleteAce(pAcl, uIndex);
                        }
                } 
                else if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
                {
                        ACCESS_DENIED_ACE *accessDeniedAce = (ACCESS_DENIED_ACE *) ace;
                        if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
                        {
                                DeleteAce(pAcl, uIndex);
                        }
                } 
                else if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
                {
                        SYSTEM_AUDIT_ACE *systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;
                        if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
                        {
                                DeleteAce(pAcl, uIndex);
                        }
                }
        }
        free(principalSID);
        return hr;
}

inline HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
        HRESULT hr;
        TOKEN_PRIVILEGES tpPrevious;
        TOKEN_PRIVILEGES tp;
        DWORD  cbPrevious = sizeof(TOKEN_PRIVILEGES);
        LUID   luid;
        HANDLE hTokenUsed;

        // if no token specified open process token
        if (hToken == 0)
        {
                if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hTokenUsed))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        return hr;
                }
        }
        else
                hTokenUsed = hToken;

        if (!LookupPrivilegeValue(NULL, privilege, &luid ))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                if (hToken == 0)
                        CloseHandle(hTokenUsed);
                return hr;
        }

        tp.PrivilegeCount = 1;
        tp.Privileges[0].Luid = luid;
        tp.Privileges[0].Attributes = 0;

        if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                if (hToken == 0)
                        CloseHandle(hTokenUsed);
                return hr;
        }

        tpPrevious.PrivilegeCount = 1;
        tpPrevious.Privileges[0].Luid = luid;

        if (bEnable)
                tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
        else
                tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

        if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                if (hToken == 0)
                        CloseHandle(hTokenUsed);
                return hr;
        }
        return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// COM Objects

#define DECLARE_PROTECT_FINAL_CONSTRUCT()\
	void InternalFinalConstructAddRef() {InternalAddRef();}\
	void InternalFinalConstructRelease() {InternalRelease();}

template <class T1>
class CComCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
        _ATL_VALIDATE_OUT_POINTER(ppv);
		HRESULT hRes = E_OUTOFMEMORY;
		T1* p = NULL;
		ATLTRY(p = new T1(pv))
		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};

template <class T1>
class CComInternalCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
        _ATL_VALIDATE_OUT_POINTER(ppv);
		HRESULT hRes = E_OUTOFMEMORY;
		T1* p = NULL;
		ATLTRY(p = new T1(pv))
		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->_InternalQueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};

template <HRESULT hr>
class CComFailCreator
{
public:
        static HRESULT WINAPI CreateInstance(void*, REFIID, LPVOID* ppv)
        {
                _ATL_VALIDATE_OUT_POINTER(ppv);
                return hr;
        }
};

template <class T1, class T2>
class CComCreator2
{
public:
        static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
        {
                // Assert Only. Validation done in functions called from here
                ATLASSERT(ppv != NULL && *ppv == NULL);
                return (pv == NULL) ? 
                        T1::CreateInstance(NULL, riid, ppv) : 
                        T2::CreateInstance(pv, riid, ppv);
        }
};

#define DECLARE_NOT_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComCreator< CComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DECLARE_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComCreator< CComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;
#define DECLARE_ONLY_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComFailCreator<E_FAIL>, CComCreator< CComAggObject< x > > > _CreatorClass;
#define DECLARE_POLY_AGGREGATABLE(x) public:\
	typedef CComCreator< CComPolyObject< x > > _CreatorClass;

struct _ATL_CREATORDATA
{
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator>
class _CComCreatorData
{
public:
	static _ATL_CREATORDATA data;
};

template <class Creator>
_ATL_CREATORDATA _CComCreatorData<Creator>::data = {Creator::CreateInstance};

struct _ATL_CACHEDATA
{
	DWORD dwOffsetVar;
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator, DWORD dwVar>
class _CComCacheData
{
public:
	static _ATL_CACHEDATA data;
};

template <class Creator, DWORD dwVar>
_ATL_CACHEDATA _CComCacheData<Creator, dwVar>::data = {dwVar, Creator::CreateInstance};

struct _ATL_CHAINDATA
{
	DWORD_PTR dwOffset;
	const _ATL_INTMAP_ENTRY* (WINAPI *pFunc)();
};

template <class base, class derived>
class _CComChainData
{
public:
	static _ATL_CHAINDATA data;
};

template <class base, class derived>
_ATL_CHAINDATA _CComChainData<base, derived>::data =
	{offsetofclass(base, derived), base::_GetEntries};

template <class T, const CLSID* pclsid>
class CComAggregateCreator
{
public:
        static HRESULT WINAPI CreateInstance(void* pv, REFIID/*riid*/, LPVOID* ppv)
        {
                // Real check will be made in the call to CoCreateInstance
                ATLASSERT(ppv != NULL && *ppv == NULL);

                ATLASSERT(pv != NULL);
                if (pv == NULL)
                        return E_INVALIDARG;
                
                T* p = (T*) pv;
                // Add the following line to your object if you get a message about
                // GetControllingUnknown() being undefined
                // DECLARE_GET_CONTROLLING_UNKNOWN()
                return CoCreateInstance(*pclsid, p->GetControllingUnknown(), CLSCTX_INPROC, IID_IUnknown, ppv);
        }
};

// this enables on-demand creation of ftm via autoaggregate macro
template <class T>
class CComFTMCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID/*riid*/, LPVOID* ppv)
	{
		ATLASSERT(*ppv == NULL);
		ATLASSERT(pv != NULL);
		T* p = (T*) pv;
		// Add the following line to your object if you get a message about
		// GetControllingUnknown() being undefined
		// DECLARE_GET_CONTROLLING_UNKNOWN()
		return CoCreateFreeThreadedMarshaler(p->GetControllingUnknown(), reinterpret_cast<LPUNKNOWN *>(ppv));
	}
};

#ifdef _ATL_DEBUG
#define DEBUG_QI_ENTRY(x) \
		{NULL, \
		(DWORD_PTR)_T(#x), \
		(_ATL_CREATORARGFUNC*)0},
#else
#define DEBUG_QI_ENTRY(x)
#endif //_ATL_DEBUG

#ifdef _ATL_DEBUG_INTERFACES
#define _ATL_DECLARE_GET_UNKNOWN(x)\
	IUnknown* GetUnknown() \
	{ \
		IUnknown* p; \
		_Module.AddNonAddRefThunk(_GetRawUnknown(), _T(#x), &p); \
		return p; \
	}
#else
#define _ATL_DECLARE_GET_UNKNOWN(x) IUnknown* GetUnknown() {return _GetRawUnknown();}
#endif

//If you get a message that FinalConstruct is ambiguous then you need to
// override it in your class and call each base class' version of this
#define BEGIN_COM_MAP(x) public: \
	typedef x _ComMapClass; \
	static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)\
	{\
		_ComMapClass* p = (_ComMapClass*)pv;\
		p->Lock();\
		HRESULT hRes = CComObjectRootBase::_Cache(pv, iid, ppvObject, dw);\
		p->Unlock();\
		return hRes;\
	}\
	IUnknown* _GetRawUnknown() \
	{ ATLASSERT(_GetEntries()[0].pFunc == _ATL_SIMPLEMAPENTRY); return (IUnknown*)((DWORD_PTR)this+_GetEntries()->dw); } \
	_ATL_DECLARE_GET_UNKNOWN(x)\
	HRESULT _InternalQueryInterface(REFIID iid, void** ppvObject) \
	{ return InternalQueryInterface(this, _GetEntries(), iid, ppvObject); } \
	const static _ATL_INTMAP_ENTRY* WINAPI _GetEntries() { \
	static const _ATL_INTMAP_ENTRY _entries[] = { DEBUG_QI_ENTRY(x)

#define DECLARE_GET_CONTROLLING_UNKNOWN() public:\
	virtual IUnknown* GetControllingUnknown() {return GetUnknown();}

#if !defined(_ATL_NO_UUIDOF)
#define _ATL_IIDOF(x) __uuidof(x)
#else
#define _ATL_IIDOF(x) IID_##x
#endif

#define COM_INTERFACE_ENTRY_BREAK(x)\
	{&_ATL_IIDOF(x), \
	NULL, \
	_Break},

#define COM_INTERFACE_ENTRY_NOINTERFACE(x)\
	{&_ATL_IIDOF(x), \
	NULL, \
	_NoInterface},

#define COM_INTERFACE_ENTRY(x)\
	{&_ATL_IIDOF(x), \
	offsetofclass(x, _ComMapClass), \
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_IID(iid, x)\
	{&iid,\
	offsetofclass(x, _ComMapClass),\
	_ATL_SIMPLEMAPENTRY},

// The impl macros are now obsolete
#define COM_INTERFACE_ENTRY_IMPL(x)\
	COM_INTERFACE_ENTRY_IID(_ATL_IIDOF(x), x##Impl<_ComMapClass>)

#define COM_INTERFACE_ENTRY_IMPL_IID(iid, x)\
	COM_INTERFACE_ENTRY_IID(iid, x##Impl<_ComMapClass>)
//

#define COM_INTERFACE_ENTRY2(x, x2)\
	{&_ATL_IIDOF(x),\
	(DWORD_PTR)((x*)(x2*)((_ComMapClass*)8))-8,\
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY2_IID(iid, x, x2)\
	{&iid,\
	(DWORD_PTR)((x*)(x2*)((_ComMapClass*)8))-8,\
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_FUNC(iid, dw, func)\
	{&iid, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_FUNC_BLIND(dw, func)\
	{NULL, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_TEAR_OFF(iid, x)\
	{&iid,\
	(DWORD_PTR)&_CComCreatorData<\
		CComInternalCreator< CComTearOffObject< x > >\
		>::data,\
	_Creator},

#define COM_INTERFACE_ENTRY_CACHED_TEAR_OFF(iid, x, punk)\
	{&iid,\
	(DWORD_PTR)&_CComCacheData<\
		CComCreator< CComCachedTearOffObject< x > >,\
		 offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AGGREGATE(iid, punk)\
	{&iid,\
	 offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AGGREGATE_BLIND(punk)\
	{NULL,\
	 offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE(iid, punk, clsid)\
	{&iid,\
	(DWORD_PTR)&_CComCacheData<\
		CComAggregateCreator<_ComMapClass, &clsid>,\
		offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND(punk, clsid)\
	{NULL,\
	(DWORD_PTR)&_CComCacheData<\
		CComAggregateCreator<_ComMapClass, &clsid>,\
		offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_CHAIN(classname)\
	{NULL,\
	(DWORD_PTR)&_CComChainData<classname, _ComMapClass>::data,\
	_Chain},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE_FTM(punk) \
	{&IID_IMarshal,\
	(DWORD_PTR)&_CComCacheData<CComFTMCreator<_ComMapClass>, offsetof(_ComMapClass, punk)>::data,\
	_Cache},

#ifdef _ATL_DEBUG
#define END_COM_MAP() {NULL, 0, 0}}; return &_entries[1];} \
	virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0; \
	virtual ULONG STDMETHODCALLTYPE Release( void) = 0; \
	STDMETHOD(QueryInterface)(REFIID, void**) = 0;
#else
#define END_COM_MAP() {NULL, 0, 0}}; return _entries;} \
	virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0; \
	virtual ULONG STDMETHODCALLTYPE Release( void) = 0; \
	STDMETHOD(QueryInterface)(REFIID, void**) = 0;
#endif // _ATL_DEBUG

#define END_COM_MAP_WITH_FTM() \
	COM_INTERFACE_ENTRY_AUTOAGGREGATE_FTM(punkFTM.p) \
	END_COM_MAP(); \
	CComPtr<IUnknown> punkFTM; \
	DECLARE_GET_CONTROLLING_UNKNOWN()	

#define BEGIN_CATEGORY_MAP(x)\
   static const struct _ATL_CATMAP_ENTRY* GetCategoryMap() {\
   static const struct _ATL_CATMAP_ENTRY pMap[] = {
#define IMPLEMENTED_CATEGORY( catid ) { _ATL_CATMAP_ENTRY_IMPLEMENTED, &catid },
#define REQUIRED_CATEGORY( catid ) { _ATL_CATMAP_ENTRY_REQUIRED, &catid },
#define END_CATEGORY_MAP()\
   { _ATL_CATMAP_ENTRY_END, NULL } };\
   return( pMap ); }

#define BEGIN_OBJECT_MAP(x) static _ATL_OBJMAP_ENTRY x[] = {
#define END_OBJECT_MAP()   {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}};
#define OBJECT_ENTRY(clsid, class) {&clsid, class::UpdateRegistry, class::_ClassFactoryCreatorClass::CreateInstance, class::_CreatorClass::CreateInstance, NULL, 0, class::GetObjectDescription, class::GetCategoryMap, class::ObjectMain },
#define OBJECT_ENTRY_NON_CREATEABLE(class) {&CLSID_NULL, class::UpdateRegistry, NULL, NULL, NULL, 0, NULL, class::GetCategoryMap, class::ObjectMain },

#define BEGIN_EXTERN_OBJECT_MAP(x) \
                            static _ATL_OBJMAP_ENTRY* x = NULL; \
                            static _ATL_OBJMAP_ENTRY NULL_OBJECT_ENTRY = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}; \
                            static _ATL_OBJMAP_ENTRY* _E##x [] = {
#define END_EXTERN_OBJECT_MAP()   &NULL_OBJECT_ENTRY }; 
#define DECLARE_EXTERN_OBJECT_ENTRY(classname) extern _ATL_OBJMAP_ENTRY classname##OBJMAP_ENTRY;
#define EXTERN_OBJECT_ENTRY(classname) &##classname##OBJMAP_ENTRY,
#define DEFINE_EXTERN_OBJECT_ENTRY(clsid, classname) \
   _ATL_OBJMAP_ENTRY classname##OBJMAP_ENTRY =    \
    {&clsid, classname::UpdateRegistry, classname::_ClassFactoryCreatorClass::CreateInstance, classname::_CreatorClass::CreateInstance, NULL, 0, classname::GetObjectDescription, classname::GetCategoryMap, classname::ObjectMain };

inline _ATL_OBJMAP_ENTRY* CreateObjectMapFromExternMap(_ATL_OBJMAP_ENTRY** p) {
    int i;
    for (i = 0; p[i]->pclsid != NULL; ++i);
    _ATL_OBJMAP_ENTRY* pRet = new _ATL_OBJMAP_ENTRY[i+1];
    for (i = 0; p[i]->pclsid != NULL; ++i) {
        memcpy(&pRet[i], p[i], sizeof(*pRet));
    }
    memcpy(&pRet[i], p[i], sizeof(*pRet));

    return pRet;
}

#define INTERNALIZE_OBJMAP(x) x = CreateObjectMapFromExternMap(_E##x);
#define DESTROY_OBJMAP(x) delete[] x;

#ifdef _ATL_DEBUG
extern HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);
#endif // _ATL_DEBUG


// the functions in this class don't need to be virtual because
// they are called from CComObject
class CComObjectRootBase
{
public:
	CComObjectRootBase()
	{
		m_dwRef = 0L;
	}
	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	// For library initialization only
	HRESULT _AtlFinalConstruct()
	{
		return S_OK;
	}
	void FinalRelease() {}
	void _AtlFinalRelease() {}

	//ObjectMain is called during Module::Init and Module::Term
	static void WINAPI ObjectMain(bool /* bStarting */) {}

	static HRESULT WINAPI InternalQueryInterface(void* pThis,
		const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
	{
		ATLASSERT(pThis != NULL);
		// First entry in the com map should be a simple map entry
		ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
	#if defined(_ATL_DEBUG_INTERFACES) || defined(_ATL_DEBUG_QI)
		LPCTSTR pszClassName = (LPCTSTR) pEntries[-1].dw;
	#endif // _ATL_DEBUG_INTERFACES
		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);
	#ifdef _ATL_DEBUG_INTERFACES
		_Module.AddThunk((IUnknown**)ppvObject, pszClassName, iid);
	#endif // _ATL_DEBUG_INTERFACES
		return _ATLDUMPIID(iid, pszClassName, hRes);
	}

//Outer funcs
	ULONG OuterAddRef()
	{
		return m_pOuterUnknown->AddRef();
	}
	ULONG OuterRelease()
	{
		return m_pOuterUnknown->Release();
	}
	HRESULT OuterQueryInterface(REFIID iid, void ** ppvObject)
	{
		return m_pOuterUnknown->QueryInterface(iid, ppvObject);
	}

	void SetVoid(void*) {}
	void InternalFinalConstructAddRef() {}
	void InternalFinalConstructRelease()
	{
		ATLASSERT(m_dwRef == 0);
	}
	// If this assert occurs, your object has probably been deleted
	// Try using DECLARE_PROTECT_FINAL_CONSTRUCT()


	static HRESULT WINAPI _Break(void* /* pv */, REFIID iid, void** /* ppvObject */, DWORD_PTR /* dw */)
	{
		iid;
		_ATLDUMPIID(iid, _T("Break due to QI for interface "), S_OK);
		DebugBreak();
		return S_FALSE;
	}
	static HRESULT WINAPI _NoInterface(void* /* pv */, REFIID /* iid */, void** /* ppvObject */, DWORD_PTR /* dw */)
	{
		return E_NOINTERFACE;
	}
	static HRESULT WINAPI _Creator(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
	{
		_ATL_CREATORDATA* pcd = (_ATL_CREATORDATA*)dw;
		return pcd->pFunc(pv, iid, ppvObject);
	}
	static HRESULT WINAPI _Delegate(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
	{
		HRESULT hRes = E_NOINTERFACE;
		IUnknown* p = *(IUnknown**)((DWORD_PTR)pv + dw);
		if (p != NULL)
			hRes = p->QueryInterface(iid, ppvObject);
		return hRes;
	}

	static HRESULT WINAPI _Chain(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
    {
		_ATL_CHAINDATA* pcd = (_ATL_CHAINDATA*)dw;
		void* p = (void*)((DWORD_PTR)pv + pcd->dwOffset);
		return InternalQueryInterface(p, pcd->pFunc(), iid, ppvObject);
    }

	static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
	{
		HRESULT hRes = E_NOINTERFACE;
		_ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)dw;
		IUnknown** pp = (IUnknown**)((DWORD_PTR)pv + pcd->dwOffsetVar);
		if (*pp == NULL)
			hRes = pcd->pFunc(pv, IID_IUnknown, (void**)pp);
		if (*pp != NULL)
			hRes = (*pp)->QueryInterface(iid, ppvObject);
		return hRes;
	}

	union
	{
		long m_dwRef;
		IUnknown* m_pOuterUnknown;
	};
};

//foward declaration
template <class ThreadModel>
class CComObjectRootEx;

template <class ThreadModel>
class CComObjectLockT
{
public:
	CComObjectLockT(CComObjectRootEx<ThreadModel>* p)
	{
		if (p)
			p->Lock();
		m_p = p;
	}

	~CComObjectLockT()
	{
		if (m_p)
			m_p->Unlock();
	}
	CComObjectRootEx<ThreadModel>* m_p;
};

template <> class CComObjectLockT<CComSingleThreadModel>;

template <class ThreadModel>
class CComObjectRootEx : public CComObjectRootBase
{
public:
	typedef ThreadModel _ThreadModel;
	typedef typename _ThreadModel::AutoCriticalSection _CritSec;
	typedef CComObjectLockT<_ThreadModel> ObjectLock;

	ULONG InternalAddRef()
	{
		ATLASSERT(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		ATLASSERT(m_dwRef > 0);
		return _ThreadModel::Decrement(&m_dwRef);
	}

	void Lock() {m_critsec.Lock();}
	void Unlock() {m_critsec.Unlock();}
private:
	_CritSec m_critsec;
};

template <>
class CComObjectRootEx<CComSingleThreadModel> : public CComObjectRootBase
{
public:
	typedef CComSingleThreadModel _ThreadModel;
	typedef _ThreadModel::AutoCriticalSection _CritSec;
	typedef CComObjectLockT<_ThreadModel> ObjectLock;

	ULONG InternalAddRef()
	{
		ATLASSERT(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		return _ThreadModel::Decrement(&m_dwRef);
	}

	void Lock() {}
	void Unlock() {}
};

template <>
class CComObjectLockT<CComSingleThreadModel>
{
public:
	CComObjectLockT(CComObjectRootEx<CComSingleThreadModel>*) {}
	~CComObjectLockT() {}
};

typedef CComObjectRootEx<CComObjectThreadModel> CComObjectRoot;

#if defined(_WINDLL) | defined(_USRDLL)
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectCached< cf > > _ClassFactoryCreatorClass;
#else
// don't let class factory refcount influence lock count
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectNoLock< cf > > _ClassFactoryCreatorClass;
#endif
#define DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(CComClassFactory)
#define DECLARE_CLASSFACTORY2(lic) DECLARE_CLASSFACTORY_EX(CComClassFactory2<lic>)
#define DECLARE_CLASSFACTORY_AUTO_THREAD() DECLARE_CLASSFACTORY_EX(CComClassFactoryAutoThread)
#define DECLARE_CLASSFACTORY_SINGLETON(obj) DECLARE_CLASSFACTORY_EX(CComClassFactorySingleton<obj>)

#define DECLARE_OBJECT_DESCRIPTION(x)\
	static LPCTSTR WINAPI GetObjectDescription()\
	{\
		return _T(x);\
	}

#define DECLARE_NO_REGISTRY()\
	static HRESULT WINAPI UpdateRegistry(BOOL /*bRegister*/)\
	{return S_OK;}

#define DECLARE_REGISTRY(class, pid, vpid, nid, flags)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
		return _Module.UpdateRegistryClass(GetObjectCLSID(), pid, vpid, nid,\
			flags, bRegister);\
	}

#define DECLARE_REGISTRY_RESOURCE(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResource(_T(#x), bRegister);\
	}

#define DECLARE_REGISTRY_RESOURCEID(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResource(x, bRegister);\
	}

//DECLARE_STATIC_* provided for backward compatibility
#ifdef _ATL_STATIC_REGISTRY
#define DECLARE_STATIC_REGISTRY_RESOURCE(x) DECLARE_REGISTRY_RESOURCE(x)
#define DECLARE_STATIC_REGISTRY_RESOURCEID(x) DECLARE_REGISTRY_RESOURCEID(x)
#endif //_ATL_STATIC_REGISTRY

template<class Base> class CComObject; // fwd decl

template <class Owner, class ThreadModel = CComObjectThreadModel>
class CComTearOffObjectBase : public CComObjectRootEx<ThreadModel>
{
public:
	typedef Owner _OwnerClass;
	CComObject<Owner>* m_pOwner;
	CComTearOffObjectBase() {m_pOwner = NULL;}
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObject : public Base
{
public:
	typedef Base _BaseClass;
	CComObject(void* = NULL)
	{
		_Module.Lock();
	}
	// Set refcount to 1 to protect destruction
	~CComObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
		_Module.Unlock();
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}

	static HRESULT WINAPI CreateInstance(CComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI CComObject<Base>::CreateInstance(CComObject<Base>** pp)
{
    _ATL_VALIDATE_OUT_POINTER(pp);
        
	HRESULT hRes = E_OUTOFMEMORY;
	CComObject<Base>* p = NULL;
	ATLTRY(p = new CComObject<Base>())
	if (p != NULL)
	{
		p->SetVoid(NULL);
		p->InternalFinalConstructAddRef();
		hRes = p->FinalConstruct();
		p->InternalFinalConstructRelease();
		if (hRes != S_OK)
		{
			delete p;
			p = NULL;
		}
	}
	*pp = p;
	return hRes;
}

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
// CComObjectCached is used primarily for class factories in DLL's
// but it is useful anytime you want to cache an object
template <class Base>
class CComObjectCached : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectCached(void* = NULL){}
	// Set refcount to 1 to protect destruction
	~CComObjectCached()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)()
	{
		m_csCached.Lock();
		ULONG l = InternalAddRef();
		if (m_dwRef == 2)
			_Module.Lock();
		m_csCached.Unlock();
		return l;
	}
	STDMETHOD_(ULONG, Release)()
	{
		m_csCached.Lock();
		InternalRelease();
		ULONG l = m_dwRef;
		m_csCached.Unlock();
		if (l == 0)
			delete this;
		else if (l == 1)
			_Module.Unlock();
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	CComGlobalsThreadModel::AutoCriticalSection m_csCached;
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObjectNoLock : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectNoLock(void* = NULL){}
	// Set refcount to 1 to protect destruction
	~CComObjectNoLock()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}

	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectGlobal : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectGlobal(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
	~CComObjectGlobal()
	{
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}

	STDMETHOD_(ULONG, AddRef)() {return _Module.Lock();}
	STDMETHOD_(ULONG, Release)(){return _Module.Unlock();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	HRESULT m_hResFinalConstruct;
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectStack : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectStack(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
	~CComObjectStack()
	{
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}


	STDMETHOD_(ULONG, AddRef)() {ATLASSERT(FALSE);return 0;}
	STDMETHOD_(ULONG, Release)(){ATLASSERT(FALSE);return 0;}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{ATLASSERT(FALSE);return E_NOINTERFACE;}
	HRESULT m_hResFinalConstruct;
};

template <class Base> //Base must be derived from CComObjectRoot
class CComContainedObject : public Base
{
public:
	typedef Base _BaseClass;
	CComContainedObject(void* pv) {m_pOuterUnknown = (IUnknown*)pv;}
#ifdef _ATL_DEBUG_INTERFACES
	~CComContainedObject()
	{
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
		_Module.DeleteNonAddRefThunk(m_pOuterUnknown);
	}
#endif

	STDMETHOD_(ULONG, AddRef)() {return OuterAddRef();}
	STDMETHOD_(ULONG, Release)() {return OuterRelease();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hr = OuterQueryInterface(iid, ppvObject);
		if (FAILED(hr) && _GetRawUnknown() != m_pOuterUnknown)
			hr = _InternalQueryInterface(iid, ppvObject);
		return hr;
	}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	//GetControllingUnknown may be virtual if the Base class has declared
	//DECLARE_GET_CONTROLLING_UNKNOWN()
	IUnknown* GetControllingUnknown()
	{
#ifdef _ATL_DEBUG_INTERFACES
		IUnknown* p;
		_Module.AddNonAddRefThunk(m_pOuterUnknown, _T("CComContainedObject"), &p);
		return p;
#else
		return m_pOuterUnknown;
#endif
	}
};

//contained is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class contained>
class CComAggObject :
	public IUnknown,
	public CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS >
{
public:
	typedef contained _BaseClass;
	CComAggObject(void* pv) : m_contained(pv)
	{
		_Module.Lock();
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		return m_contained.FinalConstruct();
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to 1 to protect destruction
	~CComAggObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(this);
#endif
		_Module.Unlock();
	}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			if (ppvObject == NULL)
				return E_POINTER;
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_Module.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	static HRESULT WINAPI CreateInstance(LPUNKNOWN pUnkOuter, CComAggObject<contained>** pp)
	{
        _ATL_VALIDATE_OUT_POINTER(pp);
                        
		HRESULT hRes = E_OUTOFMEMORY;
		CComAggObject<contained>* p = NULL;
		ATLTRY(p = new CComAggObject<contained>(pUnkOuter))
		if (p != NULL)
		{
			p->SetVoid(NULL);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes != S_OK)
			{
				delete p;
				p = NULL;
			}
		}
		*pp = p;
		return hRes;
	}

	CComContainedObject<contained> m_contained;
};

///////////////////////////////////////////////////////////////////////////////
// CComPolyObject can be either aggregated or not aggregated

template <class contained>
class CComPolyObject :
	public IUnknown,
	public CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS >
{
public:
	typedef contained _BaseClass;
	CComPolyObject(void* pv) : m_contained(pv ? pv : this)
	{
		_Module.Lock();
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		InternalAddRef();
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		HRESULT hr = m_contained.FinalConstruct();
		InternalRelease();
		return hr;
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to 1 to protect destruction
	~CComPolyObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(this);
#endif
		_Module.Unlock();
	}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {
                if (ppvObject == NULL)
                    return E_POINTER;
                *ppvObject = NULL;

                HRESULT hRes = S_OK;
                if (InlineIsEqualUnknown(iid))
                {
                        *ppvObject = (void*)(IUnknown*)this;
                        AddRef();
#ifdef _ATL_DEBUG_INTERFACES
                        _Module.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
                }
                else
                        hRes = m_contained._InternalQueryInterface(iid, ppvObject);
                return hRes;
        }
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	static HRESULT WINAPI CreateInstance(LPUNKNOWN pUnkOuter, CComPolyObject<contained>** pp)
	{
        _ATL_VALIDATE_OUT_POINTER(pp);

		HRESULT hRes = E_OUTOFMEMORY;
		CComPolyObject<contained>* p = NULL;
		ATLTRY(p = new CComPolyObject<contained>(pUnkOuter))
		if (p != NULL)
		{
			p->SetVoid(NULL);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes != S_OK)
			{
				delete p;
				p = NULL;
			}
		}
		*pp = p;
		return hRes;
	}

	CComContainedObject<contained> m_contained;
};

template <class Base>
class CComTearOffObject : public Base
{
public:
	CComTearOffObject(void* pv)
	{
		ATLASSERT(m_pOwner == NULL);
		m_pOwner = reinterpret_cast<CComObject<Base::_OwnerClass>*>(pv);
		m_pOwner->AddRef();
	}
	// Set refcount to 1 to protect destruction
	~CComTearOffObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
		m_pOwner->Release();
	}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		return m_pOwner->QueryInterface(iid, ppvObject);
	}
};

template <class contained>
class CComCachedTearOffObject :
	public IUnknown,
	public CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS>
{
public:
	typedef contained _BaseClass;
	CComCachedTearOffObject(void* pv) :
		m_contained(((contained::_OwnerClass*)pv)->GetControllingUnknown())
	{
		ATLASSERT(m_contained.m_pOwner == NULL);
		m_contained.m_pOwner = reinterpret_cast<CComObject<contained::_OwnerClass>*>(pv);
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		return m_contained.FinalConstruct();
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to 1 to protect destruction
	~CComCachedTearOffObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(this);
#endif
	}


	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			if (ppvObject == NULL)
				return E_POINTER;
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_Module.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	CComContainedObject<contained> m_contained;
};

class CComClassFactory :
	public IClassFactory,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
	BEGIN_COM_MAP(CComClassFactory)
		COM_INTERFACE_ENTRY(IClassFactory)
	END_COM_MAP()

	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
	{
		ATLASSERT(m_pfnCreateInstance != NULL);
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// can't ask for anything other than IUnknown when aggregating
			
			if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("CComClassFactory: asked for non IUnknown interface while creating an aggregated object"));
				hRes = CLASS_E_NOAGGREGATION;
			}
			else
				hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
		}
		return hRes;
	}

	STDMETHOD(LockServer)(BOOL fLock)
	{
		if (fLock)
			_Module.Lock();
		else
			_Module.Unlock();
		return S_OK;
	}
	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

template <class license>
class CComClassFactory2 : 
	public IClassFactory2,
	public CComObjectRootEx<CComGlobalsThreadModel>,
	public license
{
public:
	typedef license _LicenseClass;
	typedef CComClassFactory2<license> _ComMapClass;
BEGIN_COM_MAP(CComClassFactory2<license>)
	COM_INTERFACE_ENTRY(IClassFactory)
	COM_INTERFACE_ENTRY(IClassFactory2)
END_COM_MAP()
	// IClassFactory
	STDMETHOD(LockServer)(BOOL fLock)
	{
		if (fLock)
			_Module.Lock();
		else
			_Module.Unlock();
		return S_OK;
	}
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
		REFIID riid, void** ppvObj)
	{
		ATLASSERT(m_pfnCreateInstance != NULL);
		if (ppvObj == NULL)
			return E_POINTER;
		*ppvObj = NULL;
		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;

		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return CLASS_E_NOAGGREGATION;
		else
			return m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
	}
	// IClassFactory2
	STDMETHOD(CreateInstanceLic)(IUnknown* pUnkOuter, IUnknown* pUnkReserved,
				REFIID riid, BSTR bstrKey, void** ppvObject)
	{
		ATLASSERT(m_pfnCreateInstance != NULL);
		if (ppvObject == NULL)
			return E_POINTER;
		*ppvObject = NULL;
		if ( ((bstrKey != NULL) && !VerifyLicenseKey(bstrKey)) ||
			 ((bstrKey == NULL) && !IsLicenseValid()) )
			return CLASS_E_NOTLICENSED;
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return CLASS_E_NOAGGREGATION;
		else
			return m_pfnCreateInstance(pUnkOuter, riid, ppvObject);
	}
	STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR* pbstrKey)
	{
		if (pbstrKey == NULL)
			return E_POINTER;
		*pbstrKey = NULL;

		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;
		return GetLicenseKey(dwReserved,pbstrKey) ? S_OK : E_FAIL;
	}
	STDMETHOD(GetLicInfo)(LICINFO* pLicInfo)
	{
		if (pLicInfo == NULL)
			return E_POINTER;
		pLicInfo->cbLicInfo = sizeof(LICINFO);
		pLicInfo->fLicVerified = IsLicenseValid();
		BSTR bstr = NULL;
		pLicInfo->fRuntimeKeyAvail = GetLicenseKey(0,&bstr);
		::SysFreeString(bstr);
		return S_OK;
	}
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling class factory

class CComClassFactoryAutoThread :
	public IClassFactory,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
	BEGIN_COM_MAP(CComClassFactoryAutoThread)
		COM_INTERFACE_ENTRY(IClassFactory)
	END_COM_MAP()

	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter,
		REFIID riid, void** ppvObj)
	{
		ATLASSERT(m_pfnCreateInstance != NULL);
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// cannot aggregate across apartments
			ATLASSERT(pUnkOuter == NULL);
			if (pUnkOuter != NULL)
				hRes = CLASS_E_NOAGGREGATION;
			else
				hRes = _Module.CreateInstance(m_pfnCreateInstance, riid, ppvObj);
		}
		return hRes;
	}
	STDMETHODIMP LockServer(BOOL fLock)
	{
		if (fLock)
			_Module.Lock();
		else
			_Module.Unlock();
		return S_OK;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Singleton Class Factory
template <class T>
class CComClassFactorySingleton : public CComClassFactory
{
public:
	void FinalRelease()
	{
		CoDisconnectObject(m_Obj.GetUnknown(), 0);
	}

	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
	{
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// aggregation is not supported in Singletons
			ATLASSERT(pUnkOuter == NULL);
			if (pUnkOuter != NULL)
				hRes = CLASS_E_NOAGGREGATION;
			else
			{
				if (m_Obj.m_hResFinalConstruct != S_OK)
					hRes = m_Obj.m_hResFinalConstruct;
				else
					hRes = m_Obj.QueryInterface(riid, ppvObj);
			}
		}
		return hRes;
	}
	CComObjectGlobal<T> m_Obj;
};

template <class T, const CLSID* pclsid = &CLSID_NULL>
class CComCoClass
{
public:
	DECLARE_CLASSFACTORY()
	DECLARE_AGGREGATABLE(T)
	typedef T _CoClass;
	static const CLSID& WINAPI GetObjectCLSID() {return *pclsid;}
	static LPCTSTR WINAPI GetObjectDescription() {return NULL;}
	static const struct _ATL_CATMAP_ENTRY* GetCategoryMap() {return NULL;};
	static HRESULT WINAPI Error(LPCOLESTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
	}
	static HRESULT WINAPI Error(LPCOLESTR lpszDesc, DWORD dwHelpID,
		LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID, lpszHelpFile,
			iid, hRes);
	}
	static HRESULT WINAPI Error(UINT nID, const IID& iid = GUID_NULL,
		HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance())
	{
		return AtlReportError(GetObjectCLSID(), nID, iid, hRes, hInst);
	}


    //
    	static HRESULT WINAPI Error(DWORD nID, const IID& iid,
		HRESULT hRes, ...)
	{
        HINSTANCE hInst = _Module.GetResourceInstance();
        va_list arguments;
        va_start(arguments, hRes);
        return AtlSetErrorInfo(GetObjectCLSID(), nID, iid, hRes, hInst, &arguments);
	}
    	static HRESULT WINAPI Error(DWORD nID, const IID& iid,
		HRESULT hRes, HINSTANCE hInst, ...)
	{ 
        va_list arguments;
        va_start(arguments, hInst);
        return AtlSetErrorInfo(GetObjectCLSID(), nID, iid, hRes, hInst, &arguments);
	}

    //


	static HRESULT WINAPI Error(UINT nID, DWORD dwHelpID,
		LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL,
		HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance())
	{
		return AtlReportError(GetObjectCLSID(), nID, dwHelpID, lpszHelpFile,
			iid, hRes, hInst);
	}
#ifndef OLE2ANSI
	static HRESULT WINAPI Error(LPCSTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
	}
	static HRESULT WINAPI Error(LPCSTR lpszDesc, DWORD dwHelpID,
		LPCSTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID,
			lpszHelpFile, iid, hRes);
	}
#endif
	template <class Q>
	static HRESULT CreateInstance(IUnknown* punkOuter, Q** pp)
	{
		return T::_CreatorClass::CreateInstance(punkOuter, __uuidof(Q), (void**) pp);
	}
	template <class Q>
	static HRESULT CreateInstance(Q** pp)
	{
		return T::_CreatorClass::CreateInstance(NULL, __uuidof(Q), (void**) pp);
	}
};

// ATL doesn't support multiple LCID's at the same time
// Whatever LCID is queried for first is the one that is used.
class CComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wMajor;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;
	struct stringdispid
	{
		CComBSTR bstr;
		int nLen;
		DISPID id;
        stringdispid() : nLen(0), id(DISPID_UNKNOWN){}
    };
	stringdispid* m_pMap;
	int m_nCount;

public:
	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
        _ATL_VALIDATE_OUT_POINTER(ppInfo);
                
		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		*ppInfo = m_pInfo;
		if (m_pInfo != NULL)
		{
			m_pInfo->AddRef();
			hr = S_OK;
		}
		return hr;
	}
        HRESULT GetTI(LCID lcid);
        HRESULT EnsureTI(LCID lcid)
        {
                HRESULT hr = S_OK;
                if (m_pInfo == NULL || m_pMap == NULL)
                        hr = GetTI(lcid);
                return hr;
        }

        // This function is called by the module on exit
        // It is registered through _Module.AddTermFunc()
        static void __stdcall Cleanup(DWORD_PTR dw)
        {
                ATLASSERT(dw != 0);
                if (dw == 0)
                        return;
                        
                CComTypeInfoHolder* p = (CComTypeInfoHolder*) dw;
                if (p->m_pInfo != NULL)
                        p->m_pInfo->Release();
                p->m_pInfo = NULL;
                delete [] p->m_pMap;
                p->m_pMap = NULL;
        }

        HRESULT GetTypeInfo(UINT /* itinfo */, LCID lcid, ITypeInfo** pptinfo)
        {
                return GetTI(lcid, pptinfo);
        }
        HRESULT GetIDsOfNames(REFIID /* riid */, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid)
        {
                HRESULT hRes = EnsureTI(lcid);
                if (m_pInfo != NULL)
                {
                        if (m_pMap != NULL)
                        {
                                for (int i=0; i<(int)cNames; i++)
                                {
                                        int n = ocslen(rgszNames[i]);
                                        int j;
                                        for (j=m_nCount-1; j>=0; j--)
                                        {
                                                if ((n == m_pMap[j].nLen) &&
                                                        (memcmp(m_pMap[j].bstr, rgszNames[i], m_pMap[j].nLen * sizeof(OLECHAR)) == 0))
                                                {
                                                        rgdispid[i] = m_pMap[j].id;
                                                        break;
                                                }
                                        }
                                        if (j < 0)
                                        {
                                                hRes = m_pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
                                                // got IDs for ALL the requested names or FAILED
                                                break;
                                        }
                                }
                        }
                        else
                        {
                                hRes = m_pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
                        }
                }
                return hRes;
        }

        HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID /* riid */,
                LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo, UINT* puArgErr)
        {
                HRESULT hRes = EnsureTI(lcid);
                if (m_pInfo != NULL)
                        hRes = m_pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
                return hRes;
        }

        HRESULT LoadNameCache(ITypeInfo* pTypeInfo)
        {
                ATLASSERT(m_pMap == NULL);
                TYPEATTR* pta;
                HRESULT hr = pTypeInfo->GetTypeAttr(&pta);
                if (SUCCEEDED(hr))
                {
                        m_nCount = pta->cFuncs;
                        
                        stringdispid* pMap = NULL;
                        if (m_nCount != 0)
                                ATLTRY(pMap = new stringdispid[m_nCount]);
                        if (m_nCount != 0 && pMap == NULL)
                        {
                                m_nCount = 0;
                                return E_OUTOFMEMORY;
                        }
                        for (int i=0; i<m_nCount; i++)
                        {
                                FUNCDESC* pfd;
                                hr = pTypeInfo->GetFuncDesc(i, &pfd);
                                if (SUCCEEDED(hr))
                                {
                                        CComBSTR bstrName;
                                        hr = pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL);
                                        if (SUCCEEDED(hr))
                                        {
                                                pMap[i].bstr.Attach(bstrName.Detach());
                                                pMap[i].nLen = SysStringLen(pMap[i].bstr);
                                                pMap[i].id = pfd->memid;
                                        }
                                        else
                                        {
                                                delete [] m_pMap;
                                                m_pMap = NULL;
                                                m_nCount = 0;
                                                pTypeInfo->ReleaseFuncDesc(pfd);
                                                break;
                                        }
                                        pTypeInfo->ReleaseFuncDesc(pfd);
                                }
                                else
                                {
                                        delete [] m_pMap;
                                        m_pMap = NULL;
                                        m_nCount = 0;
                                        break;
                                }
                        }
                        m_pMap = pMap;                        
                        pTypeInfo->ReleaseTypeAttr(pta);
                }
                return hr;
        }
};

inline HRESULT CComTypeInfoHolder::GetTI(LCID lcid)
{
        //If this assert occurs then most likely didn't initialize properly
        ATLASSERT(m_plibid != NULL && m_pguid != NULL);
        ATLASSERT(!InlineIsEqualGUID(*m_plibid, GUID_NULL) && "Did you forget to pass the LIBID to CComModule::Init?");

        if (m_pInfo != NULL && m_pMap != NULL)
                return S_OK;
        HRESULT hRes = S_OK;
        EnterCriticalSection(&_Module.m_csTypeInfoHolder);
        if (m_pInfo == NULL)
        {
                ITypeLib* pTypeLib;
                hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
                if (SUCCEEDED(hRes))
                {
                        CComPtr<ITypeInfo> spTypeInfo;
                        hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);
                        if (SUCCEEDED(hRes))
                        {
                                CComPtr<ITypeInfo> spInfo(spTypeInfo);
                                CComPtr<ITypeInfo2> spTypeInfo2;
                                if (SUCCEEDED(spTypeInfo->QueryInterface(&spTypeInfo2)))
                                        spInfo = spTypeInfo2;

                                m_pInfo = spInfo.Detach();
                                _Module.AddTermFunc(Cleanup, (DWORD_PTR)this);
                        }
                        pTypeLib->Release();
                }
        }
        if (m_pInfo != NULL && m_pMap == NULL)
        {
                LoadNameCache(m_pInfo);
        }
        LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
        return hRes;
}

//////////////////////////////////////////////////////////////////////////////
// IObjectWithSite
//
template <class T>
class ATL_NO_VTABLE IObjectWithSiteImpl : public IObjectWithSite
{
public:
	STDMETHOD(SetSite)(IUnknown *pUnkSite)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IObjectWithSiteImpl::SetSite\n"));
		T* pT = static_cast<T*>(this);
		pT->m_spUnkSite = pUnkSite;
		return S_OK;
	}
	STDMETHOD(GetSite)(REFIID riid, void **ppvSite)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IObjectWithSiteImpl::GetSite\n"));
		T* pT = static_cast<T*>(this);
		ATLASSERT(ppvSite);
		HRESULT hRes = E_POINTER;
		if (ppvSite != NULL)
		{
			if (pT->m_spUnkSite)
				hRes = pT->m_spUnkSite->QueryInterface(riid, ppvSite);
			else
			{
				*ppvSite = NULL;
				hRes = E_FAIL;
			}
		}
		return hRes;
	}

	HRESULT SetChildSite(IUnknown* punkChild)
	{
		if (punkChild == NULL)
			return E_POINTER;

		HRESULT hr;
		CComPtr<IObjectWithSite> spChildSite;
		hr = punkChild->QueryInterface(IID_IObjectWithSite, (void**)&spChildSite);
		if (SUCCEEDED(hr))
			hr = spChildSite->SetSite((IUnknown*)this);

		return hr;
	}

	static HRESULT SetChildSite(IUnknown* punkChild, IUnknown* punkParent)
	{
		return AtlSetChildSite(punkChild, punkParent);
	}

	CComPtr<IUnknown> m_spUnkSite;
};

//////////////////////////////////////////////////////////////////////////////
// IServiceProvider
//
template <class T>
class ATL_NO_VTABLE IServiceProviderImpl : public IServiceProvider
{
public:
	STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void** ppvObject)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IServiceProviderImpl::QueryService\n"));
        _ATL_VALIDATE_OUT_POINTER(ppvObject);
		T* pT = static_cast<T*>(this);
		return pT->_InternalQueryService(guidService, riid, ppvObject);
	}
};

#define BEGIN_SERVICE_MAP(x) public: \
	HRESULT _InternalQueryService(REFGUID guidService, REFIID riid, void** ppvObject) \
	{

#define SERVICE_ENTRY(x) \
		if (InlineIsEqualGUID(guidService, x)) \
			return QueryInterface(riid, ppvObject);

#define SERVICE_ENTRY_CHAIN(x) \
		CComQIPtr<IServiceProvider, &IID_IServiceProvider> spProvider(x); \
		if (spProvider != NULL) \
			return spProvider->QueryService(guidService, riid, ppvObject);

#define END_SERVICE_MAP() \
		return E_NOINTERFACE; \
	}


/////////////////////////////////////////////////////////////////////////////
// IDispEventImpl

#ifdef _ATL_DLL
ATLAPI AtlGetObjectSourceInterface(IUnknown* punkObj, GUID* plibid, IID* piid, unsigned short* pdwMajor, unsigned short* pdwMinor);
#else
ATLINLINE ATLAPI AtlGetObjectSourceInterface(IUnknown* punkObj, GUID* plibid, IID* piid, unsigned short* pdwMajor, unsigned short* pdwMinor)
{
    if (plibid == NULL || piid == NULL || pdwMajor == NULL || pdwMinor == NULL)
            return E_POINTER;
            
    *plibid = GUID_NULL;
    *piid = IID_NULL;
    *pdwMajor = 0;
    *pdwMinor = 0;
    
	HRESULT hr = E_FAIL;
	if (punkObj != NULL)
	{
		CComPtr<IDispatch> spDispatch;
		hr = punkObj->QueryInterface(IID_IDispatch, (void**)&spDispatch);
		if (SUCCEEDED(hr))
		{
			CComPtr<ITypeInfo> spTypeInfo;
			hr = spDispatch->GetTypeInfo(0, 0, &spTypeInfo);
			if (SUCCEEDED(hr))
			{
				CComPtr<ITypeLib> spTypeLib;
				hr = spTypeInfo->GetContainingTypeLib(&spTypeLib, 0);
				if (SUCCEEDED(hr))
				{
					TLIBATTR* plibAttr;
					hr = spTypeLib->GetLibAttr(&plibAttr);
					if (SUCCEEDED(hr))
					{
						memcpy(plibid, &plibAttr->guid, sizeof(GUID));
						*pdwMajor = plibAttr->wMajorVerNum;
						*pdwMinor = plibAttr->wMinorVerNum;
						spTypeLib->ReleaseTLibAttr(plibAttr);
						// First see if the object is willing to tell us about the
						// default source interface via IProvideClassInfo2
						CComPtr<IProvideClassInfo2> spInfo;
						hr = punkObj->QueryInterface(IID_IProvideClassInfo2, (void**)&spInfo);
						if (SUCCEEDED(hr) && spInfo != NULL)
							hr = spInfo->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, piid);
						else
						{
							// No, we have to go hunt for it
							CComPtr<ITypeInfo> spInfoCoClass;
							// If we have a clsid, use that
							// Otherwise, try to locate the clsid from IPersist
							CComPtr<IPersist> spPersist;
							CLSID clsid;
							hr = punkObj->QueryInterface(IID_IPersist, (void**)&spPersist);
							if (SUCCEEDED(hr))
							{
								hr = spPersist->GetClassID(&clsid);
								if (SUCCEEDED(hr))
								{
									hr = spTypeLib->GetTypeInfoOfGuid(clsid, &spInfoCoClass);
									if (SUCCEEDED(hr))
									{
										TYPEATTR* pAttr=NULL;
										spInfoCoClass->GetTypeAttr(&pAttr);
										if (pAttr != NULL)
										{
											HREFTYPE hRef;
											for (int i = 0; i < pAttr->cImplTypes; i++)
											{
												int nType;
												hr = spInfoCoClass->GetImplTypeFlags(i, &nType);
												if (SUCCEEDED(hr))
												{
													if (nType == (IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE))
													{
														// we found it
														hr = spInfoCoClass->GetRefTypeOfImplType(i, &hRef);
														if (SUCCEEDED(hr))
														{
															CComPtr<ITypeInfo> spInfo;
															hr = spInfoCoClass->GetRefTypeInfo(hRef, &spInfo);
															if (SUCCEEDED(hr))
															{
																TYPEATTR* pAttrIF;
																spInfo->GetTypeAttr(&pAttrIF);
																if (pAttrIF != NULL)
																{
																	memcpy(piid, &pAttrIF->guid, sizeof(GUID));
															        spInfo->ReleaseTypeAttr(pAttrIF);
																}
															}
														}
														break;
													}
												}
											}
											spInfoCoClass->ReleaseTypeAttr(pAttr);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return hr;
}
#endif // _ATL_DLL

#if defined(_M_IA64)
template <class T>
class CComStdCallThunk
{
public:
        typedef void (__stdcall T::*TMFP)();
        void* pVtable;
        void* pFunc;
        _stdcallthunk thunk;
        void Init(TMFP dw, void* pThis)
        {
                pVtable = &pFunc;
                pFunc = &thunk;         
                union {
                        DWORD_PTR dwFunc;
                        TMFP pfn;
                } pfn;
                pfn.pfn = dw;
                thunk.Init(pfn.dwFunc, pThis);
        }
};
#elif defined(_M_AMD64) || defined(_M_IX86)
template <class T>
class CComStdCallThunk
{
public:
        typedef void (__stdcall T::*TMFP)();
        void *pVTable;
        void *pThis;
        TMFP pfn;
        void (__stdcall *pfnHelper)();

        
        void Init(TMFP pf, void *p);
};

#if defined(_M_AMD64)
#pragma comment(lib, "atlamd64.lib")
extern "C" void CComStdCallThunkHelper(void);
#else

inline void __declspec(naked) __stdcall CComStdCallThunkHelper()
{
        __asm
        {
                mov eax, [esp+4];       // get pThunk
                mov edx, [eax+4];       // get the pThunk->pThis
                mov [esp+4], edx;       // replace pThunk with pThis
                mov eax, [eax+8];       // get pThunk->pfn
                jmp eax;                // jump pfn
        };
}
#endif

template <class T>
void CComStdCallThunk<T>::Init(TMFP pf, void *p)
{
        pfnHelper = CComStdCallThunkHelper;
        pVTable = &pfnHelper;
        pThis = p;
        pfn = pf;
}

#else
#error "No Target Architecture"
#endif // _M_IX86

#ifndef _ATL_MAX_VARTYPES
#define _ATL_MAX_VARTYPES 8
#endif

struct _ATL_FUNC_INFO
{
	CALLCONV cc;
	VARTYPE vtReturn;
	SHORT nParams;
	VARTYPE pVarTypes[_ATL_MAX_VARTYPES];
};

class ATL_NO_VTABLE _IDispEvent
{
public:
	_IDispEvent() {m_dwEventCookie = 0xFEFEFEFE;}
	//this method needs a different name than QueryInterface
	STDMETHOD(_LocDEQueryInterface)(REFIID riid, void ** ppvObject) = 0;
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
	GUID m_libid; // used for dynamic case
	IID m_iid; // used for dynamic case
    unsigned short m_wMajorVerNum;    // Major version number. used for dynamic case
    unsigned short m_wMinorVerNum;    // Minor version number. used for dynamic case
	DWORD m_dwEventCookie;
	HRESULT DispEventAdvise(IUnknown* pUnk, const IID* piid)
	{
		ATLASSERT(m_dwEventCookie == 0xFEFEFEFE);
		return AtlAdvise(pUnk, (IUnknown*)this, *piid, &m_dwEventCookie);
	}
	HRESULT DispEventUnadvise(IUnknown* pUnk, const IID* piid)
	{
		HRESULT hr = AtlUnadvise(pUnk, *piid, m_dwEventCookie);
		m_dwEventCookie = 0xFEFEFEFE;
		return hr;
	}
};

template <UINT nID, const IID* piid>
class ATL_NO_VTABLE _IDispEventLocator : public _IDispEvent
{
public:
};

template <UINT nID, class T, const IID* pdiid>
class ATL_NO_VTABLE IDispEventSimpleImpl : public _IDispEventLocator<nID, pdiid>
{
public:
        STDMETHOD(_LocDEQueryInterface)(REFIID riid, void ** ppvObject)
        {
                _ATL_VALIDATE_OUT_POINTER(ppvObject);
                
                if (InlineIsEqualGUID(riid, *pdiid) || 
                        InlineIsEqualUnknown(riid) ||
                        InlineIsEqualGUID(riid, IID_IDispatch) ||
                        InlineIsEqualGUID(riid, m_iid))
                {
                        *ppvObject = this;
                        AddRef();
#ifdef _ATL_DEBUG_INTERFACES
                        _Module.AddThunk((IUnknown**)ppvObject, _T("IDispEventImpl"), riid);
#endif // _ATL_DEBUG_INTERFACES
                        return S_OK;
                }
                else
                        return E_NOINTERFACE;
        }

	// These are here only to support use in non-COM objects	
	virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return 1;
	}
	virtual ULONG STDMETHODCALLTYPE Release()
	{
		return 1;
	}

	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{return E_NOTIMPL;}

	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{return E_NOTIMPL;}

	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{return E_NOTIMPL;}

        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                LCID lcid, WORD /*wFlags*/, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* /*pexcepinfo*/, UINT* /*puArgErr*/)
        {
                T* pT = static_cast<T*>(this);
                const _ATL_EVENT_ENTRY<T>* pMap = T::_GetSinkMap();
                const _ATL_EVENT_ENTRY<T>* pFound = NULL;
                void (__stdcall T::*pEvent)() = NULL;
                while (pMap->piid != NULL)
                {
                        if ((pMap->nControlID == nID) && (pMap->dispid == dispidMember) &&
                                (pMap->piid == pdiid)) //comparing pointers here should be adequate
                        {
                                pFound = pMap;
                                break;
                        }
                        pMap++;
                }
                if (pFound == NULL)
                        return S_OK;
                
                _ATL_FUNC_INFO info;
                _ATL_FUNC_INFO* pInfo;
                if (pFound->pInfo != NULL)
                        pInfo = pFound->pInfo;
                else
                {
                        pInfo = &info;
                        HRESULT hr = GetFuncInfoFromId(*pdiid, dispidMember, lcid, info);
                        if (FAILED(hr))
                                return S_OK;
                }
                return InvokeFromFuncInfo(pFound->pfn, *pInfo, pdispparams, pvarResult);
        }

        //Helper for invoking the event
        HRESULT InvokeFromFuncInfo(void (__stdcall T::*pEvent)(), _ATL_FUNC_INFO& info, DISPPARAMS* pdispparams, VARIANT* pvarResult)
        {
                T* pT = static_cast<T*>(this);
                // If this assert occurs, then add a #define _ATL_MAX_VARTYPES nnnn
                // before including atlcom.h
                ATLASSERT(info.nParams <= _ATL_MAX_VARTYPES);
                if (info.nParams > _ATL_MAX_VARTYPES)
                {
                        return E_FAIL;
                }
                VARIANTARG* rgVarArgs[_ATL_MAX_VARTYPES];
                VARIANTARG** pVarArgs = info.nParams ? rgVarArgs : 0;

                for (int i=0; i<info.nParams; i++)
                        pVarArgs[i] = &pdispparams->rgvarg[info.nParams - i - 1];

                CComStdCallThunk<T> thunk;
                thunk.Init(pEvent, pT);
                CComVariant tmpResult;
                if (pvarResult == NULL)
                        pvarResult = &tmpResult;

                HRESULT hr = DispCallFunc(
                        &thunk,
                        0,
                        info.cc,
                        info.vtReturn,
                        info.nParams,
                        info.pVarTypes,
                        pVarArgs,
                        pvarResult);
                ATLASSERT(SUCCEEDED(hr));
                return hr;
        }

	//Helper for finding the function index for a DISPID
	virtual HRESULT GetFuncInfoFromId(const IID& iid, DISPID dispidMember, LCID lcid, _ATL_FUNC_INFO& info)
	{
		return E_NOTIMPL;
	}
    //Helpers for sinking events on random IUnknown*
    HRESULT DispEventAdvise(IUnknown* pUnk, const IID* piid)
    {
            ATLASSERT(m_dwEventCookie == 0xFEFEFEFE);
            if (m_dwEventCookie != 0xFEFEFEFE)
                    return E_UNEXPECTED;
            return AtlAdvise(pUnk, (IUnknown*)this, *piid, &m_dwEventCookie);
    }
	HRESULT DispEventUnadvise(IUnknown* pUnk, const IID* piid)
	{
		HRESULT hr = AtlUnadvise(pUnk, *piid, m_dwEventCookie);
		m_dwEventCookie = 0xFEFEFEFE;
		return hr;
	}
	HRESULT DispEventAdvise(IUnknown* pUnk)
	{
		return _IDispEvent::DispEventAdvise(pUnk, pdiid);
	}
	HRESULT DispEventUnadvise(IUnknown* pUnk)
	{
		return _IDispEvent::DispEventUnadvise(pUnk, pdiid);
	}
};

//Helper for advising connections points from a sink map
template <class T>
inline HRESULT AtlAdviseSinkMap(T* pT, bool bAdvise)
{
	ATLASSERT(::IsWindow(pT->m_hWnd));
	const _ATL_EVENT_ENTRY<T>* pEntries = T::_GetSinkMap();
	if (pEntries == NULL)
		return S_OK;
	HRESULT hr = S_OK;
	while (pEntries->piid != NULL)
	{
        _IDispEvent* pDE = (_IDispEvent*)((DWORD_PTR)pT+pEntries->nOffset);
		bool bNotAdvised = pDE->m_dwEventCookie == 0xFEFEFEFE;
		if (bAdvise ^ bNotAdvised)
		{
			pEntries++;
			continue;
		}
		hr = E_FAIL;
		HWND h = pT->GetDlgItem(pEntries->nControlID);
		ATLASSERT(h != NULL);
		if (h != NULL)
		{
			CComPtr<IUnknown> spUnk;
			AtlAxGetControl(h, &spUnk);
			ATLASSERT(spUnk != NULL);
			if (spUnk != NULL)
			{
				if (bAdvise)
				{
					if (!InlineIsEqualGUID(IID_NULL, *pEntries->piid))
						hr = pDE->DispEventAdvise(spUnk, pEntries->piid);
					else
					{
						AtlGetObjectSourceInterface(spUnk, &pDE->m_libid, &pDE->m_iid, &pDE->m_wMajorVerNum, &pDE->m_wMinorVerNum);
						hr = pDE->DispEventAdvise(spUnk, &pDE->m_iid);
					}
				}
				else
				{
					if (!InlineIsEqualGUID(IID_NULL, *pEntries->piid))
						hr = pDE->DispEventUnadvise(spUnk, pEntries->piid);
					else
						hr = pDE->DispEventUnadvise(spUnk, &pDE->m_iid);
				}
				ATLASSERT(hr == S_OK);
			}
		}
		if (FAILED(hr))
			break;
		pEntries++;
	}
	return hr;
}

template <UINT nID, class T, const IID* pdiid = &IID_NULL, const GUID* plibid = &GUID_NULL, 
	WORD wMajor = 0, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDispEventImpl : public IDispEventSimpleImpl<nID, T, pdiid>
{
public:
	typedef tihclass _tihclass;

	IDispEventImpl()
	{
		m_libid = *plibid;
		m_iid = *pdiid;
		m_wMajorVerNum = wMajor;
		m_wMinorVerNum = wMinor;
	}

    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {if( pctinfo == NULL ) return E_INVALIDARG; *pctinfo = 1; return S_OK;}

	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{return _tih.GetTypeInfo(itinfo, lcid, pptinfo);}

	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

	//Helper for finding the function index for a DISPID
	HRESULT GetFuncInfoFromId(const IID& /*iid*/, DISPID dispidMember, LCID lcid, _ATL_FUNC_INFO& info)
	{
		CComPtr<ITypeInfo> spTypeInfo;
		if (InlineIsEqualGUID(*_tih.m_plibid, GUID_NULL))
		{
			_tih.m_plibid = &m_libid;
			_tih.m_pguid = &m_iid;
			_tih.m_wMajor = m_wMajorVerNum;
			_tih.m_wMinor = m_wMinorVerNum;
		}
		HRESULT hr = _tih.GetTI(lcid, &spTypeInfo);
		if (FAILED(hr))
			return hr;
		CComQIPtr<ITypeInfo2, &IID_ITypeInfo2> spTypeInfo2 = spTypeInfo;
		FUNCDESC* pFuncDesc = NULL;
		if (spTypeInfo2 != NULL)
		{
			UINT nIndex;
			hr = spTypeInfo2->GetFuncIndexOfMemId(dispidMember, INVOKE_FUNC, &nIndex);
			if (FAILED(hr))
				return hr;
			hr = spTypeInfo->GetFuncDesc(nIndex, &pFuncDesc);
			if (FAILED(hr))
				return hr;
		}
		else // search for funcdesc
		{
			TYPEATTR* pAttr;
			hr = spTypeInfo->GetTypeAttr(&pAttr);
			if (FAILED(hr))
				return hr;
			for (int i=0;i<pAttr->cFuncs;i++)
			{
				hr = spTypeInfo->GetFuncDesc(i, &pFuncDesc);
				if (FAILED(hr))
					return hr;
				if (pFuncDesc->memid == dispidMember)
					break;
				spTypeInfo->ReleaseFuncDesc(pFuncDesc);
				pFuncDesc = NULL;
			}
			spTypeInfo->ReleaseTypeAttr(pAttr);
			if (pFuncDesc == NULL)
				return E_FAIL;
		}

		// If this assert occurs, then add a #define _ATL_MAX_VARTYPES nnnn
		// before including atlcom.h
		ATLASSERT(pFuncDesc->cParams <= _ATL_MAX_VARTYPES);
		if (pFuncDesc->cParams > _ATL_MAX_VARTYPES)
			return E_FAIL;

		for (int i=0; i<pFuncDesc->cParams; i++)
		{
            info.pVarTypes[i] = pFuncDesc->lprgelemdescParam[i].tdesc.vt;
            if (info.pVarTypes[i] == VT_PTR)
                    info.pVarTypes[i] = pFuncDesc->lprgelemdescParam[i].tdesc.lptdesc->vt | VT_BYREF;
            if (info.pVarTypes[i] == VT_USERDEFINED)
                    info.pVarTypes[i] = GetUserDefinedType(spTypeInfo,pFuncDesc->lprgelemdescParam[i].tdesc.hreftype);
		}

		VARTYPE vtReturn = pFuncDesc->elemdescFunc.tdesc.vt;
		switch(vtReturn)
		{
		case VT_INT:
			vtReturn = VT_I4;
			break;
		case VT_UINT:
			vtReturn = VT_UI4;
			break;
		case VT_VOID:
			vtReturn = VT_EMPTY; // this is how DispCallFunc() represents void
			break;
		case VT_HRESULT:
			vtReturn = VT_ERROR;
			break;
		}
		info.vtReturn = vtReturn;
		info.cc = pFuncDesc->callconv;
		info.nParams = pFuncDesc->cParams;
		spTypeInfo->ReleaseFuncDesc(pFuncDesc);
		return S_OK;
	}
	VARTYPE GetUserDefinedType(ITypeInfo *pTI, HREFTYPE hrt)
	{
		CComPtr<ITypeInfo> spTypeInfo;
		VARTYPE vt = VT_USERDEFINED;
		HRESULT hr = E_FAIL;
		hr = pTI->GetRefTypeInfo(hrt, &spTypeInfo);
		if(FAILED(hr))
			return vt;
		TYPEATTR *pta=NULL;

		spTypeInfo->GetTypeAttr(&pta);
		if(pta && pta->typekind == TKIND_ALIAS)
		{
			if (pta->tdescAlias.vt == VT_USERDEFINED)
				GetUserDefinedType(spTypeInfo,pta->tdescAlias.hreftype);
			else
				vt = pta->tdescAlias.vt;
		}
	
		if(pta)
			spTypeInfo->ReleaseTypeAttr(pta);
		return vt;

	}
protected:
	static _tihclass _tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{return _tih.GetTI(lcid, ppInfo);}
};


template <UINT nID, class T, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IDispEventImpl<nID, T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
IDispEventImpl<nID, T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
	{piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0};

template <class T>
struct _ATL_EVENT_ENTRY
{
	UINT nControlID;			//ID identifying object instance
	const IID* piid;			//dispinterface IID
	INT_PTR nOffset;				//offset of dispinterface from this pointer
	DISPID dispid;				//DISPID of method/property
	void (__stdcall T::*pfn)();	//method to invoke
	_ATL_FUNC_INFO* pInfo;
};



//Sink map is used to set up event handling
#define BEGIN_SINK_MAP(_class)\
	static const _ATL_EVENT_ENTRY<_class>* _GetSinkMap()\
	{\
		typedef _class _atl_event_classtype;\
		static const _ATL_EVENT_ENTRY<_class> map[] = {


#define SINK_ENTRY_INFO(id, iid, dispid, fn, info) {id, &iid, (INT_PTR)(static_cast<_IDispEventLocator<id, &iid>*>((_atl_event_classtype*)8))-8, dispid, (void (__stdcall _atl_event_classtype::*)())fn, info},
#define SINK_ENTRY_EX(id, iid, dispid, fn) SINK_ENTRY_INFO(id, iid, dispid, fn, NULL)
#define SINK_ENTRY(id, dispid, fn) SINK_ENTRY_EX(id, IID_NULL, dispid, fn)
#define END_SINK_MAP() {0, NULL, 0, 0, NULL, NULL} }; return map;}

/////////////////////////////////////////////////////////////////////////////
// IDispatchImpl

template <class T, const IID* piid, const GUID* plibid = &CComModule::m_libid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDispatchImpl : public T
{
public:
	typedef tihclass _tihclass;
// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{
        if( pctinfo == NULL ) 
                return E_INVALIDARG; 
		*pctinfo = 1;
		return S_OK;
	}
	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(itinfo, lcid, pptinfo);
	}
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{
		return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
	}
	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
		return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
		wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
	}
protected:
	static _tihclass _tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
		return _tih.GetTI(lcid, ppInfo);
	}
};

template <class T, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
{piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// IProvideClassInfoImpl
template <const CLSID* pcoclsid, const GUID* plibid = &CComModule::m_libid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IProvideClassInfoImpl : public IProvideClassInfo
{
public:
	typedef tihclass _tihclass;

	STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
	}

protected:
	static _tihclass _tih;
};

template <const CLSID* pcoclsid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IProvideClassInfoImpl<pcoclsid, plibid, wMajor, wMinor, tihclass>::_tihclass
IProvideClassInfoImpl<pcoclsid, plibid, wMajor, wMinor, tihclass>::_tih =
{pcoclsid,plibid, wMajor, wMinor, NULL, 0, NULL, 0};

/////////////////////////////////////////////////////////////////////////////
// IProvideClassInfo2Impl
template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid = &CComModule::m_libid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IProvideClassInfo2Impl : public IProvideClassInfo2
{
public:
	typedef tihclass _tihclass;

	STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
	}
	STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID* pGUID)
	{
		if (pGUID == NULL)
			return E_POINTER;

		if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID && psrcid)
		{
			*pGUID = *psrcid;
			return S_OK;
		}
		*pGUID = GUID_NULL;
		return E_FAIL;
	}

protected:
	static _tihclass _tih;
};


template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tihclass
IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tih =
{pcoclsid,plibid, wMajor, wMinor, NULL, 0, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfoImpl

template <const IID* piid>
class ATL_NO_VTABLE ISupportErrorInfoImpl : public ISupportErrorInfo
{
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{
		return (InlineIsEqualGUID(riid,*piid)) ? S_OK : S_FALSE;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CComEnumImpl

// These _CopyXXX classes are used with enumerators in order to control
// how enumerated items are initialized, copied, and deleted

// Default is shallow copy with no special init or cleanup
template <class T>
class _Copy
{
public:
	static HRESULT copy(T* p1, T* p2) {memcpy(p1, p2, sizeof(T)); return S_OK;}
	static void init(T*) {}
	static void destroy(T*) {}
};

template<>
class _Copy<VARIANT>
{
public:
	static HRESULT copy(VARIANT* p1, VARIANT* p2) {return VariantCopy(p1, p2);}
	static void init(VARIANT* p) {p->vt = VT_EMPTY;}
	static void destroy(VARIANT* p) {VariantClear(p);}
};

template<>
class _Copy<LPOLESTR>
{
public:
	static HRESULT copy(LPOLESTR* p1, LPOLESTR* p2)
	{
		HRESULT hr = S_OK;
		(*p1) = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(*p2)+1));
		if (*p1 == NULL)
			hr = E_OUTOFMEMORY;
		else
			ocscpy(*p1,*p2);
		return hr;
	}
	static void init(LPOLESTR* p) {*p = NULL;}
	static void destroy(LPOLESTR* p) { CoTaskMemFree(*p);}
};

template<>
class _Copy<OLEVERB>
{
public:
	static HRESULT copy(OLEVERB* p1, OLEVERB* p2)
	{
		HRESULT hr = S_OK;
		*p1 = *p2;
		if (p2->lpszVerbName == NULL)
			return S_OK;
		p1->lpszVerbName = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(p2->lpszVerbName)+1));
		if (p1->lpszVerbName == NULL)
			hr = E_OUTOFMEMORY;
		else
			ocscpy(p1->lpszVerbName,p2->lpszVerbName);
		return hr;
	}
	static void init(OLEVERB* p) { p->lpszVerbName = NULL;}
	static void destroy(OLEVERB* p) { if (p->lpszVerbName) CoTaskMemFree(p->lpszVerbName);}
};

template<>
class _Copy<CONNECTDATA>
{
public:
	static HRESULT copy(CONNECTDATA* p1, CONNECTDATA* p2)
	{
		*p1 = *p2;
		if (p1->pUnk)
			p1->pUnk->AddRef();
		return S_OK;
	}
	static void init(CONNECTDATA* ) {}
	static void destroy(CONNECTDATA* p) {if (p->pUnk) p->pUnk->Release();}
};

template <class T>
class _CopyInterface
{
public:
	static HRESULT copy(T** p1, T** p2)
	{
		*p1 = *p2;
		if (*p1)
			(*p1)->AddRef();
		return S_OK;
	}
	static void init(T** ) {}
	static void destroy(T** p) {if (*p) (*p)->Release();}
};

template<class T>
class ATL_NO_VTABLE CComIEnum : public IUnknown
{
public:
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched) = 0;
	STDMETHOD(Skip)(ULONG celt) = 0;
	STDMETHOD(Reset)(void) = 0;
	STDMETHOD(Clone)(CComIEnum<T>** ppEnum) = 0;
};


enum CComEnumFlags
{
	//see FlagBits in CComEnumImpl
	AtlFlagNoCopy = 0,
	AtlFlagTakeOwnership = 2,
	AtlFlagCopy = 3 // copy implies ownership
};

template <class Base, const IID* piid, class T, class Copy, class ROOT>
class ATL_NO_VTABLE CComEnumImpl : public Base
{
public:
	CComEnumImpl() {m_begin = m_end = m_iter = NULL; m_dwFlags = 0;}
	~CComEnumImpl();
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)(void){ATL_ROOT_LOCK(); m_iter = m_begin;return S_OK;}
	STDMETHOD(Clone)(Base** ppEnum);
	HRESULT Init(T* begin, T* end, IUnknown* pUnk,
		CComEnumFlags flags = AtlFlagNoCopy);
	CComPtr<IUnknown> m_spUnk;
	T* m_begin;
	T* m_end;
	T* m_iter;
	DWORD m_dwFlags;
protected:
	enum FlagBits
	{
		BitCopy=1,
		BitOwn=2
	};
};

template <class Base, const IID* piid, class T, class Copy, class ROOT>
CComEnumImpl<Base, piid, T, Copy, ROOT>::~CComEnumImpl()
{
	if (m_dwFlags & BitOwn)
	{
		for (T* p = m_begin; p != m_end; p++)
			Copy::destroy(p);
		delete [] m_begin;
	}
}

template <class Base, const IID* piid, class T, class Copy, class ROOT>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy, ROOT>::Next(ULONG celt, T* rgelt,
	ULONG* pceltFetched)
{
	ATL_ROOT_LOCK();
    if ((celt == 0) && (rgelt == NULL) && (NULL != pceltFetched))
    {
        // Return the number of remaining elements
        *pceltFetched = (ULONG)(m_end - m_iter);
        return S_OK;
    }
	if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
		return E_POINTER;
	if (m_begin == NULL || m_end == NULL || m_iter == NULL)
		return E_FAIL;
	ULONG nRem = (ULONG)(m_end - m_iter);
	HRESULT hRes = S_OK;
	if (nRem < celt)
		hRes = S_FALSE;
	ULONG nMin = min(celt, nRem);
	if (pceltFetched != NULL)
		*pceltFetched = nMin;
	T* pelt = rgelt;
	while(nMin--)
	{
		HRESULT hr = Copy::copy(pelt, m_iter);
		if (FAILED(hr))
		{
			while (rgelt < pelt)
				Copy::destroy(rgelt++);
			if (pceltFetched != NULL)
				*pceltFetched = 0;
			return hr;
		}
		pelt++;
		m_iter++;
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy, class ROOT>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy, ROOT>::Skip(ULONG celt)
{
	ATL_ROOT_LOCK();
    m_iter += celt;
    if (m_iter >= m_end)
	{
        m_iter = m_end;
        return S_FALSE;
    }
    if (m_iter < m_begin)
	{	
        m_iter = m_begin;
        return S_FALSE;
    }
    return S_OK;
}

template <class Base, const IID* piid, class T, class Copy, class ROOT>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy, ROOT>::Clone(Base** ppEnum)
{
	ATL_ROOT_LOCK();
	typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
	HRESULT hRes = E_POINTER;
	if (ppEnum != NULL)
	{
		*ppEnum = NULL;
		_class* p;
		hRes = _class::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{
			// If the data is a copy then we need to keep "this" object around
			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitCopy) ? this : m_spUnk);
			if (SUCCEEDED(hRes))
			{
				p->m_iter = m_iter;
				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
			}
			if (FAILED(hRes))
				delete p;
		}
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy, class ROOT>
HRESULT CComEnumImpl<Base, piid, T, Copy, ROOT>::Init(T* begin, T* end, IUnknown* pUnk,
	CComEnumFlags flags)
{
	ATL_ROOT_LOCK();
	if (flags == AtlFlagCopy)
	{
		ATLASSERT(m_begin == NULL); //Init called twice?
		ATLTRY(m_begin = new T[ULONG(end-begin)])
		m_iter = m_begin;
		if (m_begin == NULL)
			return E_OUTOFMEMORY;
		for (T* i=begin; i != end; i++)
		{
			Copy::init(m_iter);
			HRESULT hr = Copy::copy(m_iter, i);
			if (FAILED(hr))
			{
				T* p = m_begin;
				while (p < m_iter)
					Copy::destroy(p++);
				delete [] m_begin;
				m_begin = m_end = m_iter = NULL;
				return hr;
			}
			m_iter++;
		}
		m_end = m_begin + (end-begin);
	}
	else
	{
		m_begin = begin;
		m_end = end;
	}
	m_spUnk = pUnk;
	m_iter = m_begin;
	m_dwFlags = flags;
	return S_OK;
}

template <class Base, const IID* piid, class T, class Copy, class ThreadModel = CComObjectThreadModel>
class ATL_NO_VTABLE CComEnum :
	public CComEnumImpl<Base, piid, T, Copy, CComEnum<Base, piid, T, Copy, ThreadModel> >,
	public CComObjectRootEx< ThreadModel >
{
public:
	typedef CComEnum<Base, piid, T, Copy, ThreadModel > _CComEnum;
	typedef CComEnumImpl<Base, piid, T, Copy, _CComEnum > _CComEnumBase;
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
	END_COM_MAP()
};

template <class Base, const IID* piid, class T, class Copy, class CollType, class ROOT>
class ATL_NO_VTABLE IEnumOnSTLImpl : public Base
{
public:
	HRESULT Init(IUnknown *pUnkForRelease, CollType& collection)
	{
		ATL_ROOT_LOCK();
		m_spUnk = pUnkForRelease;
		m_pcollection = &collection;
		m_iter = m_pcollection->begin();
		return S_OK;
	}
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)(void)
	{
		ATL_ROOT_LOCK();
		if (m_pcollection == NULL)
			return E_FAIL;
		m_iter = m_pcollection->begin();
		return S_OK;
	}
	STDMETHOD(Clone)(Base** ppEnum);
//Data
	CComPtr<IUnknown> m_spUnk;
	CollType* m_pcollection;
	typename CollType::iterator m_iter;
};

template <class Base, const IID* piid, class T, class Copy, class CollType, class ROOT>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType, ROOT>::Next(ULONG celt, T* rgelt,
	ULONG* pceltFetched)
{
	if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
		return E_POINTER;
    if (pceltFetched != NULL)
            *pceltFetched = 0;
	ATL_ROOT_LOCK();
	if (m_pcollection == NULL)
		return E_FAIL;

	ULONG nActual = 0;
	HRESULT hr = S_OK;
	T* pelt = rgelt;
	while (SUCCEEDED(hr) && m_iter != m_pcollection->end() && nActual < celt)
	{
		hr = Copy::copy(pelt, &*m_iter);
		if (FAILED(hr))
		{
			while (rgelt < pelt)
				Copy::destroy(rgelt++);
			nActual = 0;
		}
		else
		{
			pelt++;
			m_iter++;
			nActual++;
		}
	}
    if (SUCCEEDED(hr))
    {
            if (pceltFetched)
                    *pceltFetched = nActual;
            if (nActual < celt)
                    hr = S_FALSE;
    }                        
	return hr;
}

template <class Base, const IID* piid, class T, class Copy, class CollType, class ROOT>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType, ROOT>::Skip(ULONG celt)
{
	HRESULT hr = S_OK;
	ATL_ROOT_LOCK();
	while (celt--)
	{
		if (m_iter != m_pcollection->end())
			m_iter++;
		else
		{
			hr = S_FALSE;
			break;
		}
	}
	return hr;
}

template <class Base, const IID* piid, class T, class Copy, class CollType, class ROOT>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType, ROOT>::Clone(Base** ppEnum)
{
	typedef CComObject<ROOT> _class;
	HRESULT hRes = E_POINTER;
	if (ppEnum != NULL)
	{
		*ppEnum = NULL;
		_class* p;
		hRes = _class::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{
			hRes = p->Init(m_spUnk, *m_pcollection);
			if (SUCCEEDED(hRes))
			{
				ATL_ROOT_LOCK();
				p->m_iter = m_iter;
				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
			}
			if (FAILED(hRes))
				delete p;
		}
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy, class CollType, class ThreadModel = CComObjectThreadModel>
class ATL_NO_VTABLE CComEnumOnSTL :
	public IEnumOnSTLImpl<Base, piid, T, Copy, CollType, CComEnumOnSTL<Base, piid, T, Copy, CollType, ThreadModel> >,
	public CComObjectRootEx< ThreadModel >
{
public:
	typedef CComEnumOnSTL<Base, piid, T, Copy, CollType, ThreadModel > _CComEnum;
	typedef IEnumOnSTLImpl<Base, piid, T, Copy, CollType, _CComEnum > _CComEnumBase;
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
	END_COM_MAP()
};

template <class T, class CollType, class ItemType, class CopyItem, class EnumType>
class ICollectionOnSTLImpl : public T
{
public:
	STDMETHOD(get_Count)(long* pcount)
	{
		if (pcount == NULL)
			return E_POINTER;
		ATL_LOCK();
		*pcount = m_coll.size();
		return S_OK;
	}
	STDMETHOD(get_Item)(long Index, ItemType* pvar)
	{
		//Index is 1-based
		if (pvar == NULL)
			return E_POINTER;
        if (Index < 1)
                return E_INVALIDARG;                        
		HRESULT hr = E_FAIL;
		Index--;
		ATL_LOCK();
		CollType::iterator iter = m_coll.begin();
		while (iter != m_coll.end() && Index > 0)
		{
			iter++;
			Index--;
		}
		if (iter != m_coll.end())
			hr = CopyItem::copy(pvar, &*iter);
		return hr;
	}
	STDMETHOD(get__NewEnum)(IUnknown** ppUnk)
	{
		if (ppUnk == NULL)
			return E_POINTER;
		*ppUnk = NULL;
		HRESULT hRes = S_OK;
		CComObject<EnumType>* p;
		hRes = CComObject<EnumType>::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{
			ATL_LOCK();
			hRes = p->Init(this, m_coll);
			if (hRes == S_OK)
				hRes = p->QueryInterface(IID_IUnknown, (void**)ppUnk);
		}
		if (hRes != S_OK)
			delete p;
		return hRes;
	}
	CollType m_coll;
};

//////////////////////////////////////////////////////////////////////////////
// ISpecifyPropertyPagesImpl
template <class T>
class ATL_NO_VTABLE ISpecifyPropertyPagesImpl : public ISpecifyPropertyPages
{
public:
	// ISpecifyPropertyPages
	//
	STDMETHOD(GetPages)(CAUUID* pPages)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("ISpecifyPropertyPagesImpl::GetPages\n"));
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		return GetPagesHelper(pPages, pMap);
	}
protected:
        HRESULT GetPagesHelper(CAUUID* pPages, ATL_PROPMAP_ENTRY* pMap)
        {
                if (pPages == NULL)
                        return E_POINTER;

                ATLASSERT(pMap != NULL);
                if (pMap == NULL)
                        return E_POINTER;

                int nCnt = 0;
                int i;
                // Get count of unique pages to alloc the array
                for (i = 0; pMap[i].pclsidPropPage != NULL; i++)
                {
                        // only allow non data entry types
                        if (pMap[i].vt == 0)
                        {
                                // Does this property have a page?  CLSID_NULL means it does not
                                if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
                                        nCnt++;
                        }
                }
                pPages->pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID)*nCnt);
                if (pPages->pElems == NULL)
                        return E_OUTOFMEMORY;
                // reset count of items we have added to the array
                nCnt = 0;
                for (i = 0; pMap[i].pclsidPropPage != NULL; i++)
                {
                        // only allow non data entry types
                        if (pMap[i].vt == 0)
                        {
                                // Does this property have a page?  CLSID_NULL means it does not
                                if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
                                {
                                        BOOL bFound = FALSE;
                                        // Search through array we are building up to see
                                        // if it is already in there
                                        for (int j=0; j<nCnt; j++)
                                        {
                                                if (InlineIsEqualGUID(*(pMap[i].pclsidPropPage), pPages->pElems[j]))
                                                {
                                                        // It's already there, so no need to add it again
                                                        bFound = TRUE;
                                                        break;
                                                }
                                        }
                                        // If we didn't find it in there then add it
                                        if (!bFound)
                                                pPages->pElems[nCnt++] = *pMap[i].pclsidPropPage;
                                }
                        }
                }
                pPages->cElems = nCnt;
                return S_OK;
        }

};

#ifndef _ATL_NO_CONNECTION_POINTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

struct _ATL_CONNMAP_ENTRY
{
	DWORD_PTR dwOffset;
};


// We want the offset of the connection point relative to the connection
// point container base class
#define BEGIN_CONNECTION_POINT_MAP(x)\
	typedef x _atl_conn_classtype;\
	static const _ATL_CONNMAP_ENTRY* GetConnMap(int* pnEntries) {\
	static const _ATL_CONNMAP_ENTRY _entries[] = {
// CONNECTION_POINT_ENTRY computes the offset of the connection point to the
// IConnectionPointContainer interface
#define CONNECTION_POINT_ENTRY(iid){offsetofclass(_ICPLocator<&iid>, _atl_conn_classtype)-\
	offsetofclass(IConnectionPointContainerImpl<_atl_conn_classtype>, _atl_conn_classtype)},
#define END_CONNECTION_POINT_MAP() {(DWORD_PTR)-1} }; \
	if (pnEntries) *pnEntries = sizeof(_entries)/sizeof(_ATL_CONNMAP_ENTRY) - 1; \
	return _entries;}


#ifndef _DEFAULT_VECTORLENGTH
#define _DEFAULT_VECTORLENGTH 4
#endif

template <unsigned int nMaxSize>
class CComUnkArray
{
public:
	CComUnkArray()
	{
		memset(m_arr, 0, sizeof(IUnknown*)*nMaxSize);
	}
	DWORD Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	DWORD WINAPI GetCookie(IUnknown** pp)
	{
		ULONG iIndex;

		iIndex = ULONG(pp-begin());
		return( iIndex+1 );
	}
	IUnknown* WINAPI GetUnknown(DWORD dwCookie)
	{
		if( dwCookie == 0 )
		{
			return NULL;
		}
		
		ULONG iIndex;
		iIndex = dwCookie-1;
		return( begin()[iIndex] );
	}
	IUnknown** begin()
	{
		return &m_arr[0];
	}
	IUnknown** end()
	{
		return &m_arr[nMaxSize];
	}
protected:
	IUnknown* m_arr[nMaxSize];
};

template <unsigned int nMaxSize>
inline DWORD CComUnkArray<nMaxSize>::Add(IUnknown* pUnk)
{
	for (IUnknown** pp = begin();pp<end();pp++)
	{
		if (*pp == NULL)
		{
			*pp = pUnk;
			return (DWORD)((pp-begin())+1); // return cookie
		}
	}
	// If this fires then you need a larger array
	ATLASSERT(0);
	return 0;
}

template <unsigned int nMaxSize>
inline BOOL CComUnkArray<nMaxSize>::Remove(DWORD dwCookie)
{
	ULONG iIndex;

	iIndex = dwCookie-1;
	if (iIndex >= nMaxSize)
	{
		return FALSE;
	}

	begin()[iIndex] = NULL;

	return TRUE;
}

template<>
class CComUnkArray<1>
{
public:
	CComUnkArray()
	{
		m_arr[0] = NULL;
	}
	DWORD Add(IUnknown* pUnk)
	{
		if (m_arr[0] != NULL)
		{
			// If this fires then you need a larger array
			ATLASSERT(0);
			return 0;
		}
		m_arr[0] = pUnk;
		return 1;
	}
	BOOL Remove(DWORD dwCookie)
	{
		if (dwCookie != 1)
			return FALSE;
		m_arr[0] = NULL;
		return TRUE;
	}
	DWORD WINAPI GetCookie(IUnknown** /*pp*/)
	{
		return 1;
	}
	IUnknown* WINAPI GetUnknown(DWORD dwCookie)
	{
		if (dwCookie != 1)
		{
			return NULL;
		}

		return *begin();
	}
	IUnknown** begin()
	{
		return &m_arr[0];
	}
	IUnknown** end()
	{
		return (&m_arr[0])+1;
	}
protected:
	IUnknown* m_arr[1];
};

class CComDynamicUnkArray
{
public:
	CComDynamicUnkArray()
	{
		m_nSize = 0;
		m_ppUnk = NULL;
	}

	~CComDynamicUnkArray()
	{
		if (m_nSize > 1)
			free(m_ppUnk);
	}
	DWORD Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	DWORD WINAPI GetCookie(IUnknown** pp)
	{
		ULONG iIndex;
		iIndex = ULONG(pp-begin());
		return iIndex+1;
	}
	IUnknown* WINAPI GetUnknown(DWORD dwCookie)
	{
		ULONG iIndex;

		if (dwCookie == 0)
			return NULL;

		iIndex = dwCookie-1;
		return begin()[iIndex];
	}
	IUnknown** begin()
	{
		return (m_nSize < 2) ? &m_pUnk : m_ppUnk;
	}
	IUnknown** end()
	{
		return (m_nSize < 2) ? (&m_pUnk)+m_nSize : &m_ppUnk[m_nSize];
	}

	IUnknown* GetAt(int nIndex)
	{
		if (nIndex < 0 || nIndex >= m_nSize)
			return NULL;

		return (m_nSize < 2) ? m_pUnk : m_ppUnk[nIndex];
	}
	int GetSize() const
	{
		return m_nSize;
	}

	void clear()
	{
		if (m_nSize > 1)
			free(m_ppUnk);
		m_nSize = 0;
	}
protected:
	union
	{
		IUnknown** m_ppUnk;
		IUnknown* m_pUnk;
	};
	int m_nSize;
};

inline DWORD CComDynamicUnkArray::Add(IUnknown* pUnk)
{
	ULONG iIndex;

	IUnknown** pp = NULL;
	if (m_nSize == 0) // no connections
	{
		m_pUnk = pUnk;
		m_nSize = 1;
		return 1;
	}
	else if (m_nSize == 1)
	{
		//create array
		pp = (IUnknown**)malloc(sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);
		if (pp == NULL)
			return 0;
		memset(pp, 0, sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);
		*pp = m_pUnk;
		m_ppUnk = pp;
		m_nSize = _DEFAULT_VECTORLENGTH;
	}
	for (pp = begin();pp<end();pp++)
	{
		if (*pp == NULL)
		{
			*pp = pUnk;
			iIndex = ULONG(pp-begin());
			return iIndex+1;
		}
	}
	int nAlloc = m_nSize*2;
	pp = (IUnknown**)realloc(m_ppUnk, sizeof(IUnknown*)*nAlloc);
	if (pp == NULL)
		return 0;
	m_ppUnk = pp;
	memset(&m_ppUnk[m_nSize], 0, sizeof(IUnknown*)*m_nSize);
	m_ppUnk[m_nSize] = pUnk;
	iIndex = m_nSize;
	m_nSize = nAlloc;
	return iIndex+1;
}

inline BOOL CComDynamicUnkArray::Remove(DWORD dwCookie)
{
	ULONG iIndex;
	if (dwCookie == NULL)
		return FALSE;
	if (m_nSize == 0)
		return FALSE;
	iIndex = dwCookie-1;
	if (iIndex >= (ULONG)m_nSize)
		return FALSE;
	if (m_nSize == 1)
	{
		m_nSize = 0;
		return TRUE;
	}
	begin()[iIndex] = NULL;

	return TRUE;
}


template <const IID* piid>
class ATL_NO_VTABLE _ICPLocator
{
public:
	//this method needs a different name than QueryInterface
	STDMETHOD(_LocCPQueryInterface)(REFIID riid, void ** ppvObject) = 0;
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;\
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
};

template <class T, const IID* piid, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IConnectionPointImpl : public _ICPLocator<piid>
{
public:
	typedef CComEnum<IEnumConnections, &IID_IEnumConnections, CONNECTDATA,
		_Copy<CONNECTDATA> > CComEnumConnections;
	typedef CDV _CDV;
	~IConnectionPointImpl();
        STDMETHOD(_LocCPQueryInterface)(REFIID riid, void ** ppvObject)
        {
                _ATL_VALIDATE_OUT_POINTER(ppvObject);
                
                if (InlineIsEqualGUID(riid, IID_IConnectionPoint) || InlineIsEqualUnknown(riid))
                {
                        *ppvObject = this;
                        AddRef();
#ifdef _ATL_DEBUG_INTERFACES
                        _Module.AddThunk((IUnknown**)ppvObject, _T("IConnectionPointImpl"), riid);
#endif // _ATL_DEBUG_INTERFACES
                        return S_OK;
                }
                else
                        return E_NOINTERFACE;
        }

	STDMETHOD(GetConnectionInterface)(IID* piid2)
	{
		if (piid2 == NULL)
			return E_POINTER;
		*piid2 = *piid;
		return S_OK;
	}
	STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer** ppCPC)
	{
		T* pT = static_cast<T*>(this);
		// No need to check ppCPC for NULL since QI will do that for us
		return pT->QueryInterface(IID_IConnectionPointContainer, (void**)ppCPC);
	}
	STDMETHOD(Advise)(IUnknown* pUnkSink, DWORD* pdwCookie);
	STDMETHOD(Unadvise)(DWORD dwCookie);
	STDMETHOD(EnumConnections)(IEnumConnections** ppEnum);
	CDV m_vec;
};

template <class T, const IID* piid, class CDV>
IConnectionPointImpl<T, piid, CDV>::~IConnectionPointImpl()
{
	IUnknown** pp = m_vec.begin();
	while (pp < m_vec.end())
	{
		if (*pp != NULL)
			(*pp)->Release();
		pp++;
	}
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::Advise(IUnknown* pUnkSink,
	DWORD* pdwCookie)
{
	T* pT = static_cast<T*>(this);
	IUnknown* p;
	HRESULT hRes = S_OK;
	if (pUnkSink == NULL || pdwCookie == NULL)
		return E_POINTER;
    *pdwCookie = 0;
	IID iid;
	GetConnectionInterface(&iid);
	hRes = pUnkSink->QueryInterface(iid, (void**)&p);
	if (SUCCEEDED(hRes))
	{
		pT->Lock();
		*pdwCookie = m_vec.Add(p);
		hRes = (*pdwCookie != NULL) ? S_OK : CONNECT_E_ADVISELIMIT;
		pT->Unlock();
		if (hRes != S_OK)
			p->Release();
	}
	else if (hRes == E_NOINTERFACE)
		hRes = CONNECT_E_CANNOTCONNECT;
	if (FAILED(hRes))
		*pdwCookie = 0;
	return hRes;
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::Unadvise(DWORD dwCookie)
{
	T* pT = static_cast<T*>(this);
	pT->Lock();
	IUnknown* p = m_vec.GetUnknown(dwCookie);
	HRESULT hRes = m_vec.Remove(dwCookie) ? S_OK : CONNECT_E_NOCONNECTION;
	pT->Unlock();
	if (hRes == S_OK && p != NULL)
		p->Release();
	return hRes;
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::EnumConnections(
	IEnumConnections** ppEnum)
{
	if (ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;
	CComObject<CComEnumConnections>* pEnum = NULL;
	ATLTRY(pEnum = new CComObject<CComEnumConnections>)
	if (pEnum == NULL)
		return E_OUTOFMEMORY;
	T* pT = static_cast<T*>(this);
	pT->Lock();
	CONNECTDATA* pcd = NULL;
	ATLTRY(pcd = new CONNECTDATA[ULONG(m_vec.end()-m_vec.begin())])
	if (pcd == NULL)
	{
		delete pEnum;
		pT->Unlock();
		return E_OUTOFMEMORY;
	}
	CONNECTDATA* pend = pcd;
	// Copy the valid CONNECTDATA's
	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)
	{
		if (*pp != NULL)
		{
			(*pp)->AddRef();
			pend->pUnk = *pp;
			pend->dwCookie = m_vec.GetCookie(pp);
			pend++;
		}
	}
	// don't copy the data, but transfer ownership to it
	pEnum->Init(pcd, pend, NULL, AtlFlagTakeOwnership);
	pT->Unlock();
	HRESULT hRes = pEnum->_InternalQueryInterface(IID_IEnumConnections, (void**)ppEnum);
	if (FAILED(hRes))
		delete pEnum;
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IConnectionPointContainerImpl

template <class T>
class ATL_NO_VTABLE IConnectionPointContainerImpl : public IConnectionPointContainer
{
	typedef CComEnum<IEnumConnectionPoints,
		&IID_IEnumConnectionPoints, IConnectionPoint*,
		_CopyInterface<IConnectionPoint> >
		CComEnumConnectionPoints;
public:
	STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints** ppEnum)
	{
		if (ppEnum == NULL)
			return E_POINTER;
		*ppEnum = NULL;
		CComEnumConnectionPoints* pEnum = NULL;
		ATLTRY(pEnum = new CComObject<CComEnumConnectionPoints>)
		if (pEnum == NULL)
			return E_OUTOFMEMORY;

		int nCPCount;
		const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(&nCPCount);

		// allocate an initialize a vector of connection point object pointers
		IConnectionPoint** ppCP = (IConnectionPoint**)alloca(sizeof(IConnectionPoint*)*nCPCount);

		int i = 0;
		while (pEntry->dwOffset != (DWORD_PTR)-1)
		{
			ppCP[i++] = (IConnectionPoint*)((INT_PTR)this+pEntry->dwOffset);
			pEntry++;
		}

		// copy the pointers: they will AddRef this object
		HRESULT hRes = pEnum->Init((IConnectionPoint**)&ppCP[0],
			(IConnectionPoint**)&ppCP[nCPCount],
			reinterpret_cast<IConnectionPointContainer*>(this), AtlFlagCopy);
		if (FAILED(hRes))
		{
			delete pEnum;
			return hRes;
		}
		hRes = pEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum);
		if (FAILED(hRes))
			delete pEnum;
		return hRes;
	}
	STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint** ppCP)
	{
		if (ppCP == NULL)
			return E_POINTER;
		*ppCP = NULL;
		HRESULT hRes = CONNECT_E_NOCONNECTION;
		const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(NULL);
		IID iid;
		while (pEntry->dwOffset != (DWORD_PTR)-1)
		{
			IConnectionPoint* pCP =
				(IConnectionPoint*)((INT_PTR)this+pEntry->dwOffset);
			if (SUCCEEDED(pCP->GetConnectionInterface(&iid)) &&
				InlineIsEqualGUID(riid, iid))
			{
				*ppCP = pCP;
				pCP->AddRef();
				hRes = S_OK;
				break;
			}
			pEntry++;
		}
		return hRes;
	}
};


#endif //!_ATL_NO_CONNECTION_POINTS

#pragma pack(pop)

/////////////////////////////////////////////////////////////////////////////
// CComAutoThreadModule

template <class ThreadAllocator>
inline HRESULT CComAutoThreadModule<ThreadAllocator>::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid, int nThreads)
{
	m_nThreads = nThreads;
	m_pApartments = NULL;
	ATLTRY(m_pApartments = new CComApartment[m_nThreads]);
	ATLASSERT(m_pApartments != NULL);
	if(m_pApartments == NULL)
		return E_OUTOFMEMORY;
    for (int i = 0; i < nThreads; i++)
    {
            m_pApartments[i].m_hThread = CreateThread(NULL, 0, CComApartment::_Apartment, (void*)&m_pApartments[i], 0, &m_pApartments[i].m_dwThreadID);
            if(m_pApartments[i].m_hThread == NULL)
                    return AtlHresultFromLastError();
    }
	CComApartment::ATL_CREATE_OBJECT = RegisterWindowMessage(_T("ATL_CREATE_OBJECT"));
	return CComModule::Init(p, h, plibid);
}

template <class ThreadAllocator>
inline LONG CComAutoThreadModule<ThreadAllocator>::Lock()
{
	LONG l = CComModule::Lock();
	DWORD dwThreadID = GetCurrentThreadId();
	for (int i=0; i < m_nThreads; i++)
	{
		if (m_pApartments[i].m_dwThreadID == dwThreadID)
		{
			m_pApartments[i].Lock();
			break;
		}
	}
	return l;
}

template <class ThreadAllocator>
inline LONG CComAutoThreadModule<ThreadAllocator>::Unlock()
{
	LONG l = CComModule::Unlock();
	DWORD dwThreadID = GetCurrentThreadId();
	for (int i=0; i < m_nThreads; i++)
	{
		if (m_pApartments[i].m_dwThreadID == dwThreadID)
		{
			m_pApartments[i].Unlock();
			break;
		}
	}
	return l;
}

template <class ThreadAllocator>
HRESULT CComAutoThreadModule<ThreadAllocator>::CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj)
{
        _ATL_CREATORFUNC* pFunc = (_ATL_CREATORFUNC*) pfnCreateInstance;
        _AtlAptCreateObjData data;
        data.pfnCreateInstance = pFunc;
        data.piid = &riid;
        data.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        data.hRes = S_OK;
        int nThread = m_Allocator.GetThread(m_pApartments, m_nThreads);
        
        int nIterations = 0;
        while(::PostThreadMessage(m_pApartments[nThread].m_dwThreadID, CComApartment::ATL_CREATE_OBJECT, 0, (LPARAM)&data) == 0
                        && ++ nIterations < 100)
        {
                Sleep(100);
        }
        
        if (nIterations < 100)
        {
                AtlWaitWithMessageLoop(data.hEvent);
        }
        else
        {
                data.hRes = AtlHresultFromLastError();
        }
        
        CloseHandle(data.hEvent);
        if (SUCCEEDED(data.hRes))
                data.hRes = CoGetInterfaceAndReleaseStream(data.pStream, riid, ppvObj);
        return data.hRes;
}

template <class ThreadAllocator>
CComAutoThreadModule<ThreadAllocator>::~CComAutoThreadModule()
{
	for (int i=0; i < m_nThreads; i++)
	{
		::PostThreadMessage(m_pApartments[i].m_dwThreadID, WM_QUIT, 0, 0);
		::WaitForSingleObject(m_pApartments[i].m_hThread, INFINITE);
        ::CloseHandle(m_pApartments[i].m_hThread);
	}
	delete[] m_pApartments;
}

}; //namespace ATL

#endif // __ATLCOM_H__
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\atl\atltmp.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// atltmp.h - temporary location for these classes

#ifndef __ATLTMP_H__
#define __ATLTMP_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atltmp.h requires atlbase.h to be included first
#endif


#pragma once

#ifndef _ATL_TMP_NO_CSTRING
#include <limits.h>
#include <stdio.h>
#endif //!_ATL_TMP_NO_CSTRING

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CSize;
class CPoint;
class CRect;
#ifndef _ATL_TMP_NO_CSTRING
class CString;
#endif //!_ATL_TMP_NO_CSTRING

/////////////////////////////////////////////////////////////////////////////
// CSize - An extent, similar to Windows SIZE structure.

class CSize : public tagSIZE
{
public:
// Constructors
	CSize();
	CSize(int initCX, int initCY);
	CSize(SIZE initSize);
	CSize(POINT initPt);
	CSize(DWORD dwSize);

// Operations
	BOOL operator==(SIZE size) const;
	BOOL operator!=(SIZE size) const;
	void operator+=(SIZE size);
	void operator-=(SIZE size);
    bool operator!() { return !cx && !cy; }


// Operators returning CSize values
	CSize operator+(SIZE size) const;
	CSize operator-(SIZE size) const;
	CSize operator-() const;

// Operators returning CPoint values
	CPoint operator+(POINT point) const;
	CPoint operator-(POINT point) const;

// Operators returning CRect values
	CRect operator+(const RECT* lpRect) const;
	CRect operator-(const RECT* lpRect) const;
};

/////////////////////////////////////////////////////////////////////////////
// CPoint - A 2-D point, similar to Windows POINT structure.

class CPoint : public tagPOINT
{
public:
// Constructors
    CPoint() {
        x = 0;
        y = 0;
    }
	CPoint(int initX, int initY);
	CPoint(POINT initPt);
	CPoint(SIZE initSize);
	CPoint(DWORD dwPoint);

// Operations
	void Offset(int xOffset, int yOffset);
	void Offset(POINT point);
	void Offset(SIZE size);
	BOOL operator==(POINT point) const;
	BOOL operator!=(POINT point) const;
	void operator+=(SIZE size);
	void operator-=(SIZE size);
	void operator+=(POINT point);
	void operator-=(POINT point);
    bool operator!() { return !x && !y; }

// Operators returning CPoint values
	CPoint operator+(SIZE size) const;
	CPoint operator-(SIZE size) const;
	CPoint operator-() const;
	CPoint operator+(POINT point) const;

// Operators returning CSize values
	CSize operator-(POINT point) const;

// Operators returning CRect values
	CRect operator+(const RECT* lpRect) const;
	CRect operator-(const RECT* lpRect) const;
};

/////////////////////////////////////////////////////////////////////////////
// CRect - A 2-D rectangle, similar to Windows RECT structure.

//typedef const RECT* LPCRECT;    // pointer to read/only RECT

class CRect : public tagRECT
{
public:
// Constructors
    CRect() {
        left = 0;
        top = 0;
        right = 0;
        bottom = 0;
    }
	CRect(int l, int t, int r, int b);
	CRect(const RECT& srcRect);
	CRect(LPCRECT lpSrcRect);
	CRect(POINT point, SIZE size);
	CRect(POINT topLeft, POINT bottomRight);

// Attributes (in addition to RECT members)
	int Width() const;
	int Height() const;
	CSize Size() const;
	CPoint& TopLeft();
	CPoint& BottomRight();
	const CPoint& TopLeft() const;
	const CPoint& BottomRight() const;
	CPoint CenterPoint() const;

	// convert between CRect and LPRECT/LPCRECT (no need for &)
	operator LPRECT();
	operator LPCRECT() const;

	BOOL IsRectEmpty() const;
	BOOL IsRectNull() const;
	BOOL PtInRect(POINT point) const;

// Operations
	void SetRect(int x1, int y1, int x2, int y2);
	void SetRect(POINT topLeft, POINT bottomRight);
	void SetRectEmpty();
	void CopyRect(LPCRECT lpSrcRect);
	BOOL EqualRect(LPCRECT lpRect) const;

	void InflateRect(int x, int y);
	void InflateRect(SIZE size);
	void InflateRect(LPCRECT lpRect);
	void InflateRect(int l, int t, int r, int b);
	void DeflateRect(int x, int y);
	void DeflateRect(SIZE size);
	void DeflateRect(LPCRECT lpRect);
	void DeflateRect(int l, int t, int r, int b);

	void OffsetRect(int x, int y);
	void OffsetRect(SIZE size);
	void OffsetRect(POINT point);
	void NormalizeRect();

	// operations that fill '*this' with result
	BOOL IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2);
	BOOL IntersectRect(LPCRECT lpRect2);  // use this for rect1
	BOOL UnionRect(LPCRECT lpRect1, LPCRECT lpRect2);
	BOOL SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2);

// Additional Operations
	void operator=(const RECT& srcRect);
	BOOL operator==(const RECT& rect) const;
	BOOL operator!=(const RECT& rect) const;
    bool operator!() { return !left && !top && !right && !bottom; }
	void operator+=(POINT point);
	void operator+=(SIZE size);
	void operator+=(LPCRECT lpRect);
	void operator-=(POINT point);
	void operator-=(SIZE size);
	void operator-=(LPCRECT lpRect);
	void operator&=(const RECT& rect);
	void operator|=(const RECT& rect);

// Operators returning CRect values
	CRect operator+(POINT point) const;
	CRect operator-(POINT point) const;
	CRect operator+(LPCRECT lpRect) const;
	CRect operator+(SIZE size) const;
	CRect operator-(SIZE size) const;
	CRect operator-(LPCRECT lpRect) const;
	CRect operator&(const RECT& rect2) const;
	CRect operator|(const RECT& rect2) const;
	CRect MulDiv(int nMultiplier, int nDivisor) const;
};

/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _ATL_TMP_NO_CSTRING

#ifndef _OLEAUTO_H_
#ifdef OLE2ANSI
	typedef LPSTR BSTR;
#else
	typedef LPWSTR BSTR; // must (semantically) match typedef in oleauto.h
#endif
#endif

int __stdcall AfxLoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf);

struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(TCHAR ch, int nRepeat = 1);
	CString(LPCSTR lpsz);
	CString(LPCWSTR lpsz);
	CString(LPCTSTR lpch, int nLength);
	CString(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	const CString& operator=(LPCSTR lpsz);
	const CString& operator=(LPCWSTR lpsz);
	const CString& operator=(const unsigned char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator+=(char ch);
#endif
	const CString& operator+=(LPCTSTR lpsz);

	friend CString __stdcall operator+(const CString& string1, const CString& string2);
	friend CString __stdcall operator+(const CString& string, TCHAR ch);
	friend CString __stdcall operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString __stdcall operator+(const CString& string, char ch);
	friend CString __stdcall operator+(char ch, const CString& string);
#endif
	friend CString __stdcall operator+(const CString& string, LPCTSTR lpsz);
	friend CString __stdcall operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void __cdecl Format(LPCTSTR lpszFormat, ...);
	void __cdecl Format(UINT nFormatID, ...);

	// formatting for localization (uses FormatMessage API)
	BOOL __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
	BOOL __cdecl FormatMessage(UINT nFormatID, ...);

	// Windows support
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif

#ifndef _ATL_NO_COM
	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;
#endif //!_ATL_NO_COM

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	BOOL AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	BOOL AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool __stdcall operator==(const CString& s1, const CString& s2);
bool __stdcall operator==(const CString& s1, LPCTSTR s2);
bool __stdcall operator==(LPCTSTR s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, LPCTSTR s2);
bool __stdcall operator!=(LPCTSTR s1, const CString& s2);
bool __stdcall operator<(const CString& s1, const CString& s2);
bool __stdcall operator<(const CString& s1, LPCTSTR s2);
bool __stdcall operator<(LPCTSTR s1, const CString& s2);
bool __stdcall operator>(const CString& s1, const CString& s2);
bool __stdcall operator>(const CString& s1, LPCTSTR s2);
bool __stdcall operator>(LPCTSTR s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, LPCTSTR s2);
bool __stdcall operator<=(LPCTSTR s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, LPCTSTR s2);
bool __stdcall operator>=(LPCTSTR s1, const CString& s2);

// conversion helpers
int __cdecl _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int __cdecl _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals

// afxChNil is left for backward compatibility
_declspec(selectany) TCHAR afxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
_declspec(selectany) int rgInitData[] = { -1, 0, 0, 0 };
_declspec(selectany) CStringData* afxDataNil = (CStringData*)&rgInitData;
_declspec(selectany) LPCTSTR afxPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));

inline const CString& __stdcall AfxGetEmptyString()
	{ return *(CString*)&afxPchNil; }
#define afxEmptyString AfxGetEmptyString()

#endif //!_ATL_TMP_NO_CSTRING

/////////////////////////////////////////////////////////////////////////////
// Implementation

// CSize
inline CSize::CSize() {
    cx = 0;
    cy = 0;
}
inline CSize::CSize(int initCX, int initCY)
	{ cx = initCX; cy = initCY; }
inline CSize::CSize(SIZE initSize)
	{ *(SIZE*)this = initSize; }
inline CSize::CSize(POINT initPt)
	{ *(POINT*)this = initPt; }
inline CSize::CSize(DWORD dwSize)
	{
		cx = (short)LOWORD(dwSize);
		cy = (short)HIWORD(dwSize);
	}
inline BOOL CSize::operator==(SIZE size) const
	{ return (cx == size.cx && cy == size.cy); }
inline BOOL CSize::operator!=(SIZE size) const
	{ return (cx != size.cx || cy != size.cy); }
inline void CSize::operator+=(SIZE size)
	{ cx += size.cx; cy += size.cy; }
inline void CSize::operator-=(SIZE size)
	{ cx -= size.cx; cy -= size.cy; }
inline CSize CSize::operator+(SIZE size) const
	{ return CSize(cx + size.cx, cy + size.cy); }
inline CSize CSize::operator-(SIZE size) const
	{ return CSize(cx - size.cx, cy - size.cy); }
inline CSize CSize::operator-() const
	{ return CSize(-cx, -cy); }
inline CPoint CSize::operator+(POINT point) const
	{ return CPoint(cx + point.x, cy + point.y); }
inline CPoint CSize::operator-(POINT point) const
	{ return CPoint(cx - point.x, cy - point.y); }
inline CRect CSize::operator+(const RECT* lpRect) const
	{ return CRect(lpRect) + *this; }
inline CRect CSize::operator-(const RECT* lpRect) const
	{ return CRect(lpRect) - *this; }

// CPoint
inline CPoint::CPoint(int initX, int initY)
	{ x = initX; y = initY; }
inline CPoint::CPoint(POINT initPt)
	{ *(POINT*)this = initPt; }
inline CPoint::CPoint(SIZE initSize)
	{ *(SIZE*)this = initSize; }
inline CPoint::CPoint(DWORD dwPoint)
	{
		x = (short)LOWORD(dwPoint);
		y = (short)HIWORD(dwPoint);
	}
inline void CPoint::Offset(int xOffset, int yOffset)
	{ x += xOffset; y += yOffset; }
inline void CPoint::Offset(POINT point)
	{ x += point.x; y += point.y; }
inline void CPoint::Offset(SIZE size)
	{ x += size.cx; y += size.cy; }
inline BOOL CPoint::operator==(POINT point) const
	{ return (x == point.x && y == point.y); }
inline BOOL CPoint::operator!=(POINT point) const
	{ return (x != point.x || y != point.y); }
inline void CPoint::operator+=(SIZE size)
	{ x += size.cx; y += size.cy; }
inline void CPoint::operator-=(SIZE size)
	{ x -= size.cx; y -= size.cy; }
inline void CPoint::operator+=(POINT point)
	{ x += point.x; y += point.y; }
inline void CPoint::operator-=(POINT point)
	{ x -= point.x; y -= point.y; }
inline CPoint CPoint::operator+(SIZE size) const
	{ return CPoint(x + size.cx, y + size.cy); }
inline CPoint CPoint::operator-(SIZE size) const
	{ return CPoint(x - size.cx, y - size.cy); }
inline CPoint CPoint::operator-() const
	{ return CPoint(-x, -y); }
inline CPoint CPoint::operator+(POINT point) const
	{ return CPoint(x + point.x, y + point.y); }
inline CSize CPoint::operator-(POINT point) const
	{ return CSize(x - point.x, y - point.y); }
inline CRect CPoint::operator+(const RECT* lpRect) const
	{ return CRect(lpRect) + *this; }
inline CRect CPoint::operator-(const RECT* lpRect) const
	{ return CRect(lpRect) - *this; }

// CRect
inline CRect::CRect(int l, int t, int r, int b)
	{ left = l; top = t; right = r; bottom = b; }
inline CRect::CRect(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
inline CRect::CRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
inline CRect::CRect(POINT point, SIZE size)
	{ right = (left = point.x) + size.cx; bottom = (top = point.y) + size.cy; }
inline CRect::CRect(POINT topLeft, POINT bottomRight)
	{ left = topLeft.x; top = topLeft.y;
		right = bottomRight.x; bottom = bottomRight.y; }
inline int CRect::Width() const
	{ return right - left; }
inline int CRect::Height() const
	{ return bottom - top; }
inline CSize CRect::Size() const
	{ return CSize(right - left, bottom - top); }
inline CPoint& CRect::TopLeft()
	{ return *((CPoint*)this); }
inline CPoint& CRect::BottomRight()
	{ return *((CPoint*)this+1); }
inline const CPoint& CRect::TopLeft() const
	{ return *((CPoint*)this); }
inline const CPoint& CRect::BottomRight() const
	{ return *((CPoint*)this+1); }
inline CPoint CRect::CenterPoint() const
	{ return CPoint((left+right)/2, (top+bottom)/2); }
inline CRect::operator LPRECT()
	{ return this; }
inline CRect::operator LPCRECT() const
	{ return this; }
inline BOOL CRect::IsRectEmpty() const
	{ return ::IsRectEmpty(this); }
inline BOOL CRect::IsRectNull() const
	{ return (left == 0 && right == 0 && top == 0 && bottom == 0); }
inline BOOL CRect::PtInRect(POINT point) const
	{ return ::PtInRect(this, point); }
inline void CRect::SetRect(int x1, int y1, int x2, int y2)
	{ ::SetRect(this, x1, y1, x2, y2); }
inline void CRect::SetRect(POINT topLeft, POINT bottomRight)
	{ ::SetRect(this, topLeft.x, topLeft.y, bottomRight.x, bottomRight.y); }
inline void CRect::SetRectEmpty()
	{ ::SetRectEmpty(this); }
inline void CRect::CopyRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
inline BOOL CRect::EqualRect(LPCRECT lpRect) const
	{ return ::EqualRect(this, lpRect); }
inline void CRect::InflateRect(int x, int y)
	{ ::InflateRect(this, x, y); }
inline void CRect::InflateRect(SIZE size)
	{ ::InflateRect(this, size.cx, size.cy); }
inline void CRect::DeflateRect(int x, int y)
	{ ::InflateRect(this, -x, -y); }
inline void CRect::DeflateRect(SIZE size)
	{ ::InflateRect(this, -size.cx, -size.cy); }
inline void CRect::OffsetRect(int x, int y)
	{ ::OffsetRect(this, x, y); }
inline void CRect::OffsetRect(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
inline void CRect::OffsetRect(SIZE size)
	{ ::OffsetRect(this, size.cx, size.cy); }
inline BOOL CRect::IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::IntersectRect(this, lpRect1, lpRect2);}
inline BOOL CRect::IntersectRect(LPCRECT lpRect2)
	{ return ::IntersectRect(this, this, lpRect2);}
inline BOOL CRect::UnionRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::UnionRect(this, lpRect1, lpRect2); }
inline void CRect::operator=(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
inline BOOL CRect::operator==(const RECT& rect) const
	{ return ::EqualRect(this, &rect); }
inline BOOL CRect::operator!=(const RECT& rect) const
	{ return !::EqualRect(this, &rect); }
inline void CRect::operator+=(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
inline void CRect::operator+=(SIZE size)
	{ ::OffsetRect(this, size.cx, size.cy); }
inline void CRect::operator+=(LPCRECT lpRect)
	{ InflateRect(lpRect); }
inline void CRect::operator-=(POINT point)
	{ ::OffsetRect(this, -point.x, -point.y); }
inline void CRect::operator-=(SIZE size)
	{ ::OffsetRect(this, -size.cx, -size.cy); }
inline void CRect::operator-=(LPCRECT lpRect)
	{ DeflateRect(lpRect); }
inline void CRect::operator&=(const RECT& rect)
	{ ::IntersectRect(this, this, &rect); }
inline void CRect::operator|=(const RECT& rect)
	{ ::UnionRect(this, this, &rect); }
inline CRect CRect::operator+(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, pt.x, pt.y); return rect; }
inline CRect CRect::operator-(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, -pt.x, -pt.y); return rect; }
inline CRect CRect::operator+(SIZE size) const
	{ CRect rect(*this); ::OffsetRect(&rect, size.cx, size.cy); return rect; }
inline CRect CRect::operator-(SIZE size) const
	{ CRect rect(*this); ::OffsetRect(&rect, -size.cx, -size.cy); return rect; }
inline CRect CRect::operator+(LPCRECT lpRect) const
	{ CRect rect(this); rect.InflateRect(lpRect); return rect; }
inline CRect CRect::operator-(LPCRECT lpRect) const
	{ CRect rect(this); rect.DeflateRect(lpRect); return rect; }
inline CRect CRect::operator&(const RECT& rect2) const
	{ CRect rect; ::IntersectRect(&rect, this, &rect2);
		return rect; }
inline CRect CRect::operator|(const RECT& rect2) const
	{ CRect rect; ::UnionRect(&rect, this, &rect2);
		return rect; }
inline BOOL CRect::SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2)
	{ return ::SubtractRect(this, lpRectSrc1, lpRectSrc2); }

inline void CRect::NormalizeRect()
{
	int nTemp;
	if (left > right)
	{
		nTemp = left;
		left = right;
		right = nTemp;
	}
	if (top > bottom)
	{
		nTemp = top;
		top = bottom;
		bottom = nTemp;
	}
}

inline void CRect::InflateRect(LPCRECT lpRect)
{
	left -= lpRect->left;
	top -= lpRect->top;
	right += lpRect->right;
	bottom += lpRect->bottom;
}

inline void CRect::InflateRect(int l, int t, int r, int b)
{
	left -= l;
	top -= t;
	right += r;
	bottom += b;
}

inline void CRect::DeflateRect(LPCRECT lpRect)
{
	left += lpRect->left;
	top += lpRect->top;
	right -= lpRect->right;
	bottom -= lpRect->bottom;
}

inline void CRect::DeflateRect(int l, int t, int r, int b)
{
	left += l;
	top += t;
	right -= r;
	bottom -= b;
}

inline CRect CRect::MulDiv(int nMultiplier, int nDivisor) const
{
	return CRect(
		::MulDiv(left, nMultiplier, nDivisor),
		::MulDiv(top, nMultiplier, nDivisor),
		::MulDiv(right, nMultiplier, nDivisor),
		::MulDiv(bottom, nMultiplier, nDivisor));
}


#ifndef _ATL_TMP_NO_CSTRING

// CString
inline CStringData* CString::GetData() const
	{ ATLASSERT(m_pchData != NULL); return ((CStringData*)m_pchData)-1; }
inline void CString::Init()
	{ m_pchData = afxEmptyString.m_pchData; }
inline CString::CString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
inline const CString& CString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
inline const CString& CString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
inline const CString& CString::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
inline CString __stdcall operator+(const CString& string, char ch)
	{ return string + (TCHAR)ch; }
inline CString __stdcall operator+(char ch, const CString& string)
	{ return (TCHAR)ch + string; }
#endif

inline int CString::GetLength() const
	{ return GetData()->nDataLength; }
inline int CString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
inline BOOL CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
inline CString::operator LPCTSTR() const
	{ return m_pchData; }
inline int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
inline int CString::Compare(LPCTSTR lpsz) const
	{ return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CString::Collate(LPCTSTR lpsz) const
	{ return _tcscoll(m_pchData, lpsz); }   // locale sensitive

inline TCHAR CString::GetAt(int nIndex) const
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline bool __stdcall operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }
inline bool __stdcall operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }
inline bool __stdcall operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
inline bool __stdcall operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
inline bool __stdcall operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
inline bool __stdcall operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

inline BOOL __stdcall AfxIsValidString(LPCWSTR lpsz, int nLength)
{
	if(lpsz == NULL)
		return FALSE;
	return !::IsBadStringPtrW(lpsz, nLength);
}

inline BOOL __stdcall AfxIsValidString(LPCSTR lpsz, int nLength)
{
	if(lpsz == NULL)
		return FALSE;
	return !::IsBadStringPtrA(lpsz, nLength);
}

inline BOOL __stdcall AfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite = TRUE)
{
	// simple version using Win-32 APIs for pointer validation.
	return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
		(!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

inline CString::CString()
{
	Init();
}

inline CString::CString(const CString& stringSrc)
{
	ATLASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ATLASSERT(stringSrc.GetData() != afxDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

inline BOOL CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ATLASSERT(nLen >= 0);
	ATLASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CStringData* pData = NULL;
		ATLTRY(pData = (CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)]);
		if(pData == NULL)
			return FALSE;

		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		pData->nAllocLength = nLen;
		m_pchData = pData->data();
	}

	return TRUE;
}

inline void CString::Release()
{
	if (GetData() != afxDataNil)
	{
		ATLASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
		Init();
	}
}

inline void PASCAL CString::Release(CStringData* pData)
{
	if (pData != afxDataNil)
	{
		ATLASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			delete[] (BYTE*)pData;
	}
}

inline void CString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &afxChNil;
	ATLASSERT(GetData()->nDataLength == 0);
	ATLASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

inline void CString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CStringData* pData = GetData();
		Release();
		if(AllocBuffer(pData->nDataLength))
			memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ATLASSERT(GetData()->nRefs <= 1);
}

inline BOOL CString::AllocBeforeWrite(int nLen)
{
	BOOL bRet = TRUE;
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		bRet = AllocBuffer(nLen);
	}
	ATLASSERT(GetData()->nRefs <= 1);
	return bRet;
}

inline CString::~CString()
//  free any attached data
{
	if (GetData() != afxDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
	}
}

inline void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		if(dest.AllocBuffer(nNewLen))
			memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

inline CString::CString(LPCTSTR lpsz)
{
	Init();
	if (lpsz != NULL && HIWORD(lpsz) == NULL)
	{
		UINT nID = LOWORD((DWORD_PTR)lpsz);
		if (!LoadString(nID))
#if (_ATL_VER >= 0x0300)
			ATLTRACE2(atlTraceGeneral, 0, _T("Warning: implicit LoadString(%u) in CString failed\n"), nID);
#else
			ATLTRACE2(atlTraceGeneral, 0, _T("Warning: implicit LoadString in CString failed\n"));
#endif //(_ATL_VER >= 0x0300)
	}
	else
	{
		int nLen = SafeStrlen(lpsz);
		if (nLen != 0)
		{
			if(AllocBuffer(nLen))
				memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
		}
	}
}

#ifdef _UNICODE
inline CString::CString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen))
		{
			_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
			ReleaseBuffer();
		}
	}
}
#else //_UNICODE
inline CString::CString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen*2))
		{
			_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
			ReleaseBuffer();
		}
	}
}
#endif //!_UNICODE

// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

inline void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	if(AllocBeforeWrite(nSrcLen))
	{
		memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength = nSrcLen;
		m_pchData[nSrcLen] = '\0';
	}
}

inline const CString& CString::operator=(const CString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ATLASSERT(stringSrc.GetData() != afxDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

inline const CString& CString::operator=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

#ifdef _UNICODE
inline const CString& CString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen))
	{
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
	return *this;
}
#else //!_UNICODE
inline const CString& CString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen*2))
	{
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
	return *this;
}
#endif  //!_UNICODE

// Concatenation
// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

inline void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		if(AllocBuffer(nNewLen))
		{
			memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
			memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
		}
	}
}

inline CString __stdcall operator+(const CString& string1, const CString& string2)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

inline CString __stdcall operator+(const CString& string, LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CString::SafeStrlen(lpsz), lpsz);
	return s;
}

inline CString __stdcall operator+(LPCTSTR lpsz, const CString& string)
{
	ATLASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

inline void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ATLASSERT(pOldData != NULL);
		CString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

inline const CString& CString::operator+=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

inline const CString& CString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

inline const CString& CString::operator+=(const CString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

inline LPTSTR CString::GetBuffer(int nMinBufLength)
{
	ATLASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		if(AllocBuffer(nMinBufLength))
		{
			memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
			GetData()->nDataLength = nOldLen;
			CString::Release(pOldData);
		}
	}
	ATLASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ATLASSERT(m_pchData != NULL);
	return m_pchData;
}

inline void CString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ATLASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

inline LPTSTR CString::GetBufferSetLength(int nNewLength)
{
	ATLASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

inline void CString::FreeExtra()
{
	ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CStringData* pOldData = GetData();
		if(AllocBuffer(GetData()->nDataLength))
		{
			memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
			ATLASSERT(m_pchData[GetData()->nDataLength] == '\0');
			CString::Release(pOldData);
		}
	}
	ATLASSERT(GetData() != NULL);
}

inline LPTSTR CString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

inline void CString::UnlockBuffer()
{
	ATLASSERT(GetData()->nRefs == -1);
	if (GetData() != afxDataNil)
		GetData()->nRefs = 1;
}

inline int CString::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ATLASSERT(AfxIsValidString(lpszCharSet, FALSE));
	LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline void CString::MakeUpper()
{
	CopyBeforeWrite();
	_tcsupr(m_pchData);
}

inline void CString::MakeLower()
{
	CopyBeforeWrite();
	_tcslwr(m_pchData);
}

inline void CString::MakeReverse()
{
	CopyBeforeWrite();
	_tcsrev(m_pchData);
}

inline void CString::SetAt(int nIndex, TCHAR ch)
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
inline void CString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
inline void CString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

// CString conversion helpers (these use the current system locale)

inline int __cdecl _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, count, NULL, NULL);
	ATLASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

inline int __cdecl _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, count);
	ATLASSERT(wcstr == NULL || result <= (int)count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}

inline CString::CString(TCHAR ch, int nLength)
{
	ATLASSERT(!_istlead(ch));    // can't create a lead byte string
	Init();
	if (nLength >= 1)
	{
		if(AllocBuffer(nLength))
		{
#ifdef _UNICODE
			for (int i = 0; i < nLength; i++)
				m_pchData[i] = ch;
#else
			memset(m_pchData, ch, nLength);
#endif
		}
	}
}

inline CString::CString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		ATLASSERT(AfxIsValidAddress(lpch, nLength, FALSE));
		if(AllocBuffer(nLength))
			memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

inline const CString& CString::operator=(TCHAR ch)
{
	ATLASSERT(!_istlead(ch));    // can't set single lead byte
	AssignCopy(1, &ch);
	return *this;
}

inline CString __stdcall operator+(const CString& string1, TCHAR ch)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

inline CString __stdcall operator+(TCHAR ch, const CString& string)
{
	CString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

inline CString CString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

inline CString CString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

inline CString CString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

inline CString CString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
inline CString CString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(AfxIsValidString(lpszCharSet, FALSE));
	return Left(_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
inline CString CString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(AfxIsValidString(lpszCharSet, FALSE));
	return Left(_tcscspn(m_pchData, lpszCharSet));
}

inline int CString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
inline int CString::Find(LPCTSTR lpszSub) const
{
	ATLASSERT(AfxIsValidString(lpszSub, FALSE));

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

#define TCHAR_ARG   TCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    char

struct _AFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };

#if defined(_X86_)
	#define DOUBLE_ARG  _AFX_DOUBLE
#else
	#define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

inline void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ATLASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	int nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
		{
			nMaxLen += _tclen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
				;
		}
		ATLASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = _tcsinc(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = _tcsinc(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
					;
			}
			ATLASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		switch (*lpsz)
		{
		// modifiers that affect size
		case 'h':
			nModifier = FORCE_ANSI;
			lpsz = _tcsinc(lpsz);
			break;
		case 'l':
			nModifier = FORCE_UNICODE;
			lpsz = _tcsinc(lpsz);
			break;

		// modifiers that do not affect size
		case 'F':
		case 'N':
		case 'L':
			lpsz = _tcsinc(lpsz);
			break;
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
		{
			LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6;  // "(null)"
			else
			{
			   nItemLen = lstrlen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 'S':
		{
#ifndef _UNICODE
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6;  // "(null)"
			else
			{
			   nItemLen = wcslen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
#else
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = lstrlenA(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
#endif
			break;
		}

		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
		{
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = lstrlenA(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
		{
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = wcslen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			nItemLen = max(nItemLen, nWidth);
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'e':
			case 'f':
			case 'g':
			case 'G':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ATLASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(nMaxLen);
	int nRet = _vstprintf(m_pchData, lpszFormat, argListSave);
	nRet;	// ref
	ATLASSERT(nRet <= GetAllocLength());
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
inline void __cdecl CString::Format(LPCTSTR lpszFormat, ...)
{
	ATLASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

inline void __cdecl CString::Format(UINT nFormatID, ...)
{
	CString strFormat;
	BOOL bRet = strFormat.LoadString(nFormatID);
	bRet;	// ref
	ATLASSERT(bRet != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}

// formatting (using FormatMessage style formatting)
inline BOOL __cdecl CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, lpszFormat);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
		lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free the temporary
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline BOOL __cdecl CString::FormatMessage(UINT nFormatID, ...)
{
	// get format string from string table
	CString strFormat;
	BOOL bRetTmp = strFormat.LoadString(nFormatID);
	bRetTmp;	// ref
	ATLASSERT(bRetTmp != 0);

	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, nFormatID);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		strFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
		lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free lpszTemp
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline void CString::TrimRight()
{
	CopyBeforeWrite();

	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(DWORD_PTR)(lpszLast - m_pchData);
	}
}

inline void CString::TrimLeft()
{
	CopyBeforeWrite();

	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	// fix up data and length
	int nDataLength = GetData()->nDataLength - (int)(DWORD_PTR)(lpsz - m_pchData);
	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
	GetData()->nDataLength = nDataLength;
}

#ifdef _UNICODE
#define CHAR_FUDGE 1    // one TCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

inline BOOL CString::LoadString(UINT nID)
{
	// try fixed buffer first (to avoid wasting space in the heap)
	TCHAR szTemp[256];
	int nCount =  sizeof(szTemp) / sizeof(szTemp[0]);
	int nLen = AfxLoadString(nID, szTemp, nCount);
	if (nCount - nLen > CHAR_FUDGE)
	{
		*this = szTemp;
		return nLen > 0;
	}

	// try buffer size of 512, then larger size until entire string is retrieved
	int nSize = 256;
	do
	{
		nSize += 256;
		nLen = AfxLoadString(nID, GetBuffer(nSize-1), nSize);
	} while (nSize - nLen <= CHAR_FUDGE);
	ReleaseBuffer();

	return nLen > 0;
}

inline int __stdcall AfxLoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
{
	ATLASSERT(AfxIsValidAddress(lpszBuf, nMaxBuf*sizeof(TCHAR)));
#ifdef _DEBUG
	// LoadString without annoying warning from the Debug kernel if the
	//  segment containing the string is not present
	if (::FindResource(_Module.GetResourceInstance(),
	   MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
	{
		lpszBuf[0] = '\0';
		return 0; // not found
	}
#endif //_DEBUG
	int nLen = ::LoadString(_Module.GetResourceInstance(), nID, lpszBuf, nMaxBuf);
	if (nLen == 0)
		lpszBuf[0] = '\0';
	return nLen;
}

#ifndef _ATL_NO_COM
inline BSTR CString::AllocSysString() const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
	BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
#else
	int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
		GetData()->nDataLength, NULL, NULL);
	BSTR bstr = ::SysAllocStringLen(NULL, nLen);
	if(bstr != NULL)
		MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, bstr, nLen);
#endif
	return bstr;
}

inline BSTR CString::SetSysString(BSTR* pbstr) const
{
	ATLASSERT(AfxIsValidAddress(pbstr, sizeof(BSTR)));

#if defined(_UNICODE) || defined(OLE2ANSI)
	::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength);
#else
	int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
		GetData()->nDataLength, NULL, NULL);
	if(::SysReAllocStringLen(pbstr, NULL, nLen))
		MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, *pbstr, nLen);
#endif
	ATLASSERT(*pbstr != NULL);
	return *pbstr;
}
#endif //!_ATL_NO_COM

#endif //!_ATL_TMP_NO_CSTRING

}; //namespace ATL

#endif // __ATLTMP_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\atl\statreg.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __STATREG_H
#define __STATREG_H

#define E_ATL_REGISTRAR_DESC              0x0201
#define E_ATL_NOT_IN_MAP                  0x0202
#define E_ATL_UNEXPECTED_EOS              0x0203
#define E_ATL_VALUE_SET_FAILED            0x0204
#define E_ATL_RECURSE_DELETE_FAILED       0x0205
#define E_ATL_EXPECTING_EQUAL             0x0206
#define E_ATL_CREATE_KEY_FAILED           0x0207
#define E_ATL_DELETE_KEY_FAILED           0x0208
#define E_ATL_OPEN_KEY_FAILED             0x0209
#define E_ATL_CLOSE_KEY_FAILED            0x020A
#define E_ATL_UNABLE_TO_COERCE            0x020B
#define E_ATL_BAD_HKEY                    0x020C
#define E_ATL_MISSING_OPENKEY_TOKEN       0x020D
#define E_ATL_CONVERT_FAILED              0x020E
#define E_ATL_TYPE_NOT_SUPPORTED          0x020F
#define E_ATL_COULD_NOT_CONCAT            0x0210
#define E_ATL_COMPOUND_KEY                0x0211
#define E_ATL_INVALID_MAPKEY              0x0212
#define E_ATL_UNSUPPORTED_VT              0x0213
#define E_ATL_VALUE_GET_FAILED            0x0214
#define E_ATL_VALUE_TOO_LARGE             0x0215
#define E_ATL_MISSING_VALUE_DELIMETER     0x0216
#define E_ATL_DATA_NOT_BYTE_ALIGNED       0x0217

namespace ATL
{
const TCHAR  chDirSep            = _T('\\');
const TCHAR  chRightBracket      = _T('}');
const TCHAR  chLeftBracket       = _T('{');
const TCHAR  chQuote             = _T('\'');
const TCHAR  chEquals            = _T('=');
const LPCTSTR  szStringVal       = _T("S");
const LPCTSTR  szDwordVal        = _T("D");
const LPCTSTR  szBinaryVal       = _T("B");
const LPCTSTR  szValToken        = _T("Val");
const LPCTSTR  szForceRemove     = _T("ForceRemove");
const LPCTSTR  szNoRemove        = _T("NoRemove");
const LPCTSTR  szDelete          = _T("Delete");

class CExpansionVector
{
public:
	//Declare EXPANDER struct.  Only used locally.
	struct EXPANDER
	{
		LPOLESTR    szKey;
		LPOLESTR    szValue;
	};

	CExpansionVector()
	{
		m_cEls = 0;
		m_nSize=10;
		m_p = (EXPANDER**)malloc(m_nSize*sizeof(EXPANDER*));
	}
	~CExpansionVector()
	{
		 free(m_p);
	}
	HRESULT Add(LPCOLESTR lpszKey, LPCOLESTR lpszValue)
	{
		USES_CONVERSION;
		HRESULT hr = S_OK;

		EXPANDER* pExpand = NULL;
		ATLTRY(pExpand = new EXPANDER);
		if (pExpand == NULL)
			return E_OUTOFMEMORY;

		DWORD cbKey = (ocslen(lpszKey)+1)*sizeof(OLECHAR);
		DWORD cbValue = (ocslen(lpszValue)+1)*sizeof(OLECHAR);
		pExpand->szKey = (LPOLESTR)CoTaskMemAlloc(cbKey);
		pExpand->szValue = (LPOLESTR)CoTaskMemAlloc(cbValue);
		if (pExpand->szKey == NULL || pExpand->szValue == NULL)
		{
			CoTaskMemFree(pExpand->szKey);
			CoTaskMemFree(pExpand->szValue);
			delete pExpand;
			return E_OUTOFMEMORY;
		}
		memcpy(pExpand->szKey, lpszKey, cbKey);
		memcpy(pExpand->szValue, lpszValue, cbValue);

      EXPANDER** p;
		if (m_cEls == m_nSize)
		{
			m_nSize*=2;
			p = (EXPANDER**)realloc(m_p, m_nSize*sizeof(EXPANDER*));
         if (p == NULL)
         {
            CoTaskMemFree(pExpand->szKey);
            CoTaskMemFree(pExpand->szValue);
            hr = E_OUTOFMEMORY;
         }
         else
            m_p = p;
		}

      if (SUCCEEDED(hr))
      {
         ATLASSERT(m_p != NULL);
		   m_p[m_cEls] = pExpand;
		   m_cEls++;
      }

		return hr;

	}
	LPCOLESTR Find(LPTSTR lpszKey)
	{
		USES_CONVERSION;
		for (int iExpand = 0; iExpand < m_cEls; iExpand++)
		{
			if (!lstrcmpi(OLE2T(m_p[iExpand]->szKey), lpszKey)) //are equal
				return m_p[iExpand]->szValue;
		}
		return NULL;
	}
	HRESULT ClearReplacements()
	{
		for (int iExpand = 0; iExpand < m_cEls; iExpand++)
		{
			EXPANDER* pExp = m_p[iExpand];
			CoTaskMemFree(pExp->szValue);
			CoTaskMemFree(pExp->szKey);
			delete pExp;
		}
		m_cEls = 0;
		return S_OK;
	}

private:
	EXPANDER** m_p;
	int m_cEls;
	int m_nSize;
};

class CRegObject;

class CRegParser
{
public:
	CRegParser(CRegObject* pRegObj);

	HRESULT  PreProcessBuffer(LPCTSTR lpszReg, LPTSTR* ppszReg);
	HRESULT  RegisterBuffer(LPTSTR szReg, BOOL bRegister);

protected:

	void    SkipWhiteSpace();
	HRESULT NextToken(LPTSTR szToken);
	HRESULT AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken);
	BOOL    CanForceRemoveKey(LPCTSTR szKey);
	BOOL    HasSubKeys(HKEY hkey);
	BOOL    HasValues(HKEY hkey);
	HRESULT RegisterSubkeys(LPTSTR szToken, HKEY hkParent, BOOL bRegister, BOOL bInRecovery = FALSE);
	BOOL    IsSpace(TCHAR ch);
	LPTSTR  m_pchCur;

	CRegObject*     m_pRegObj;

	HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}
	HRESULT HandleReplacements(LPTSTR& szToken);
	HRESULT SkipAssignment(LPTSTR szToken);

	BOOL    EndOfVar() { return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur); }
	static LPCTSTR StrChr(LPCTSTR lpsz, TCHAR ch);
	static HKEY HKeyFromString(LPTSTR szToken);
	static BYTE ChToByte(const TCHAR ch);
	static BOOL VTFromRegType(LPCTSTR szValueType, VARTYPE& vt);
	static LPCTSTR rgszNeverDelete[];
	static const int cbNeverDelete;
	static const int MAX_VALUE;
	static const int MAX_TYPE;
	class CParseBuffer
	{
	public:
		int nPos;
		int nSize;
		LPTSTR p;
		CParseBuffer(int nInitial)
		{
			nPos = 0;
			nSize = nInitial;
			p = (LPTSTR) CoTaskMemAlloc(nSize*sizeof(TCHAR));
		}
		~CParseBuffer()
		{
			CoTaskMemFree(p);
		}
		BOOL AddChar(const TCHAR* pch)
		{
			if (nPos == nSize) // realloc
			{
            LPTSTR pNew;
				nSize *= 2;
				pNew = (LPTSTR) CoTaskMemRealloc(p, nSize*sizeof(TCHAR));
            if (pNew == NULL)
               return FALSE;
            p = pNew;
			}
			p[nPos++] = *pch;
#ifndef _UNICODE
			if (IsDBCSLeadByte(*pch))
				p[nPos++] = *(pch + 1);
#endif
			return TRUE;
		}
		BOOL AddString(LPCOLESTR lpsz)
		{
			USES_CONVERSION;
			LPCTSTR lpszT = OLE2CT(lpsz);
			while (*lpszT)
			{
				AddChar(lpszT);
				lpszT++;
			}
			return TRUE;
		}
		LPTSTR Detach()
		{
			LPTSTR lp = p;
			p = NULL;
			return lp;
		}

	};
};

#if defined(_ATL_DLL) | defined(_ATL_DLL_IMPL)
class ATL_NO_VTABLE CRegObject
 : public IRegistrar
#else
class CRegObject
#endif
{
public:

	~CRegObject(){ClearReplacements();}
	HRESULT FinalConstruct() {return S_OK;}
	void FinalRelease() {}


	// Map based methods
	HRESULT STDMETHODCALLTYPE AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem);
	HRESULT STDMETHODCALLTYPE ClearReplacements();
	LPCOLESTR StrFromMap(LPTSTR lpszKey);

	// Register via a given mechanism
	HRESULT STDMETHODCALLTYPE ResourceRegister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceRegisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE FileRegister(LPCOLESTR bstrFileName)
	{
		return CommonFileRegister(bstrFileName, TRUE);
	}

	HRESULT STDMETHODCALLTYPE FileUnregister(LPCOLESTR bstrFileName)
	{
		return CommonFileRegister(bstrFileName, FALSE);
	}

	HRESULT STDMETHODCALLTYPE StringRegister(LPCOLESTR bstrData)
	{
		return RegisterWithString(bstrData, TRUE);
	}

	HRESULT STDMETHODCALLTYPE StringUnregister(LPCOLESTR bstrData)
	{
		return RegisterWithString(bstrData, FALSE);
	}

protected:

	HRESULT CommonFileRegister(LPCOLESTR pszFileName, BOOL bRegister);
	HRESULT RegisterFromResource(LPCOLESTR pszFileName, LPCTSTR pszID, LPCTSTR pszType, BOOL bRegister);
	HRESULT RegisterWithString(LPCOLESTR pszData, BOOL bRegister);

	static HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}

	CExpansionVector                                m_RepMap;
    // NOTE: the original atl source code used CComObjectThreadModel, but if you're linking together 
    // multiple objects with different threading models then this breaks because the different models see different 
    // initialization sizes for the ctor.  since registration doesn't happen that often, we're just going to take
    // the microscopic perf hit of always assuming multithread and really grabbing a real critsec.  the alternative
    // would be to templatize all the CRegXXX classes with a threading model parameter.  but, its not worth doing that much work
    // for such a low use frequency component.
    CComMultiThreadModel::AutoCriticalSection      m_csMap;
};

inline HRESULT STDMETHODCALLTYPE CRegObject::AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem)
{
	m_csMap.Lock();
	HRESULT hr = m_RepMap.Add(lpszKey, lpszItem);
	m_csMap.Unlock();
	return hr;
}

inline HRESULT CRegObject::RegisterFromResource(LPCOLESTR bstrFileName, LPCTSTR szID,
										 LPCTSTR szType, BOOL bRegister)
{
	USES_CONVERSION;

	HRESULT     hr;
	CRegParser  parser(this);
	HINSTANCE   hInstResDll;
	HRSRC       hrscReg;
	HGLOBAL     hReg;
	DWORD       dwSize;
	LPSTR       szRegA;
	LPTSTR      szReg;

	hInstResDll = LoadLibraryEx(OLE2CT(bstrFileName), NULL, LOAD_LIBRARY_AS_DATAFILE);

	if (NULL == hInstResDll)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to LoadLibrary on %s\n"), OLE2CT(bstrFileName));
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	hrscReg = FindResource((HMODULE)hInstResDll, szID, szType);

	if (NULL == hrscReg)
	{
		if (DWORD_PTR(szID) <= 0xffff)
			ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to FindResource on ID:%d TYPE:%s\n"),
			(DWORD)(DWORD_PTR)szID, szType);
		else
			ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to FindResource on ID:%s TYPE:%s\n"),
			szID, szType);
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	hReg = LoadResource((HMODULE)hInstResDll, hrscReg);

	if (NULL == hReg)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to LoadResource \n"));
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg);
	szRegA = (LPSTR)hReg;
	if (szRegA[dwSize] != NULL)
	{
		szRegA = (LPSTR)_alloca(dwSize+1);
		memcpy(szRegA, (void*)hReg, dwSize+1);
		szRegA[dwSize] = NULL;
	}

	szReg = A2T(szRegA);

	hr = parser.RegisterBuffer(szReg, bRegister);

ReturnHR:

	if (NULL != hInstResDll)
		FreeLibrary((HMODULE)hInstResDll);
	return hr;
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;
	return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), FALSE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;

	return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), FALSE);
}

inline HRESULT CRegObject::RegisterWithString(LPCOLESTR bstrData, BOOL bRegister)
{
	USES_CONVERSION;
	CRegParser  parser(this);


	LPCTSTR szReg = OLE2CT(bstrData);

	HRESULT hr = parser.RegisterBuffer((LPTSTR)szReg, bRegister);

	return hr;
}

inline HRESULT CRegObject::ClearReplacements()
{
	m_csMap.Lock();
	HRESULT hr = m_RepMap.ClearReplacements();
	m_csMap.Unlock();
	return hr;
}


inline LPCOLESTR CRegObject::StrFromMap(LPTSTR lpszKey)
{
	m_csMap.Lock();
	LPCOLESTR lpsz = m_RepMap.Find(lpszKey);
	if (lpsz == NULL) // not found!!
		ATLTRACE2(atlTraceRegistrar, 0, _T("Map Entry not found\n"));
	m_csMap.Unlock();
	return lpsz;
}

inline HRESULT CRegObject::CommonFileRegister(LPCOLESTR bstrFileName, BOOL bRegister)
{
	USES_CONVERSION;

	CRegParser  parser(this);

	HANDLE hFile = CreateFile(OLE2CT(bstrFileName), GENERIC_READ, 0, NULL,
							  OPEN_EXISTING,
							  FILE_ATTRIBUTE_READONLY,
							  NULL);
	if (INVALID_HANDLE_VALUE == hFile)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to CreateFile on %s\n"), OLE2CT(bstrFileName));
		return HRESULT_FROM_WIN32(GetLastError());
	}

	HRESULT hRes = S_OK;
	DWORD cbRead;
	DWORD cbFile = GetFileSize(hFile, NULL); // No HiOrder DWORD required
	char* szReg = (char*)_alloca(cbFile + 1);
	if (ReadFile(hFile, szReg, cbFile, &cbRead, NULL) == 0)
	{
		ATLTRACE2(atlTraceRegistrar, 0, "Read Failed on file%s\n", OLE2CT(bstrFileName));
		hRes =  HRESULT_FROM_WIN32(GetLastError());
	}
	if (SUCCEEDED(hRes))
	{
		szReg[cbRead] = NULL;
		LPTSTR szConverted = A2T(szReg);
		hRes = parser.RegisterBuffer(szConverted, bRegister);
	}
	CloseHandle(hFile);
	return hRes;
}

__declspec(selectany) LPCTSTR CRegParser::rgszNeverDelete[] = //Component Catagories
{
	_T("CLSID"), _T("TYPELIB")
};

__declspec(selectany) const int CRegParser::cbNeverDelete = sizeof(rgszNeverDelete) / sizeof(LPCTSTR*);
__declspec(selectany) const int CRegParser::MAX_VALUE=4096;
__declspec(selectany) const int CRegParser::MAX_TYPE=MAX_VALUE;


inline BOOL CRegParser::VTFromRegType(LPCTSTR szValueType, VARTYPE& vt)
{
	struct typemap
	{
		LPCTSTR lpsz;
		VARTYPE vt;
	};
	static const typemap map[] = {
		{szStringVal, VT_BSTR},
		{szDwordVal,  VT_UI4},
		{szBinaryVal, VT_UI1}
	};

	for (int i=0;i<sizeof(map)/sizeof(typemap);i++)
	{
		if (!lstrcmpi(szValueType, map[i].lpsz))
		{
			vt = map[i].vt;
			return TRUE;
		}
	}

	return FALSE;

}

inline BYTE CRegParser::ChToByte(const TCHAR ch)
{
	switch (ch)
	{
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
				return (BYTE) (ch - '0');
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
				return (BYTE) (10 + (ch - 'A'));
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
				return (BYTE) (10 + (ch - 'a'));
		default:
				ATLASSERT(FALSE);
				ATLTRACE2(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);
				return 0;
	}
}

inline HKEY CRegParser::HKeyFromString(LPTSTR szToken)
{
	struct keymap
	{
		LPCTSTR lpsz;
		HKEY hkey;
	};
	static const keymap map[] = {
		{_T("HKCR"), HKEY_CLASSES_ROOT},
		{_T("HKCU"), HKEY_CURRENT_USER},
		{_T("HKLM"), HKEY_LOCAL_MACHINE},
		{_T("HKU"),  HKEY_USERS},
		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
		{_T("HKDD"), HKEY_DYN_DATA},
		{_T("HKCC"), HKEY_CURRENT_CONFIG},
		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
		{_T("HKEY_USERS"), HKEY_USERS},
		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
	};

	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)
	{
		if (!lstrcmpi(szToken, map[i].lpsz))
			return map[i].hkey;
	}
	return NULL;
}

inline LPCTSTR CRegParser::StrChr(LPCTSTR lpsz, TCHAR ch)
{
	LPCTSTR p = NULL;
	while (*lpsz)
	{
		if (*lpsz == ch)
		{
			p = lpsz;
			break;
		}
		lpsz = CharNext(lpsz);
	}
	return p;
}

inline CRegParser::CRegParser(CRegObject* pRegObj)
{
	m_pRegObj           = pRegObj;
	m_pchCur            = NULL;
}

inline BOOL CRegParser::IsSpace(TCHAR ch)
{
	switch (ch)
	{
		case _T(' '):
		case _T('\t'):
		case _T('\r'):
		case _T('\n'):
				return TRUE;
	}

	return FALSE;
}

inline void CRegParser::SkipWhiteSpace()
{
	while(IsSpace(*m_pchCur))
		m_pchCur = CharNext(m_pchCur);
}

inline HRESULT CRegParser::NextToken(LPTSTR szToken)
{
	USES_CONVERSION;

	SkipWhiteSpace();

	// NextToken cannot be called at EOS
	if (NULL == *m_pchCur)
		return GenerateError(E_ATL_UNEXPECTED_EOS);

	// handle quoted value / key
	if (chQuote == *m_pchCur)
	{
		LPCTSTR szOrig = szToken;

		m_pchCur = CharNext(m_pchCur);

		while (NULL != *m_pchCur && !EndOfVar())
		{
			if (chQuote == *m_pchCur) // If it is a quote that means we must skip it
				m_pchCur = CharNext(m_pchCur);

			LPTSTR pchPrev = m_pchCur;
			m_pchCur = CharNext(m_pchCur);

			if (szToken + sizeof(WORD) >= MAX_VALUE + szOrig)
				return GenerateError(E_ATL_VALUE_TOO_LARGE);
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		if (NULL == *m_pchCur)
		{
			ATLTRACE2(atlTraceRegistrar, 0, _T("NextToken : Unexpected End of File\n"));
			return GenerateError(E_ATL_UNEXPECTED_EOS);
		}

		*szToken = NULL;
		m_pchCur = CharNext(m_pchCur);
	}

	else
	{   // Handle non-quoted ie parse up till first "White Space"
		while (NULL != *m_pchCur && !IsSpace(*m_pchCur))
		{
			LPTSTR pchPrev = m_pchCur;
			m_pchCur = CharNext(m_pchCur);
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		*szToken = NULL;
	}
	return S_OK;
}

inline HRESULT CRegParser::AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken)
{
	USES_CONVERSION;
	HRESULT hr;

	TCHAR       szTypeToken[MAX_TYPE];
	VARTYPE     vt;
	LONG        lRes = ERROR_SUCCESS;
	UINT        nIDRes = 0;

	if (FAILED(hr = NextToken(szTypeToken)))
		return hr;
	if (!VTFromRegType(szTypeToken, vt))
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("%s Type not supported\n"), szTypeToken);
		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);
	}

	TCHAR szValue[MAX_VALUE];
	SkipWhiteSpace();
	if (FAILED(hr = NextToken(szValue)))
		return hr;
	ULONG ulVal;

	switch (vt)
	{
	case VT_BSTR:
		lRes = rkParent.SetValue(szValue, szValueName);
		ATLTRACE2(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName);
		break;
	case VT_UI4:
#ifdef _WIN64
		ATLASSERT(FALSE);
      ulVal = 0;
#pragma message( "Still need VarUI4FromStr()." )
#else
		VarUI4FromStr(T2OLE(szValue), 0, 0, &ulVal);
#endif
		lRes = rkParent.SetValue(ulVal, szValueName);
		ATLTRACE2(atlTraceRegistrar, 2, _T("Setting Value %d at %s\n"), ulVal, !szValueName ? _T("default") : szValueName);
		break;
	case VT_UI1:
		{
			int cbValue = lstrlen(szValue);
			if (cbValue & 0x00000001)
			{
				ATLTRACE2(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));
				return E_FAIL;
			}
			int cbValDiv2 = cbValue/2;
			BYTE* rgBinary = (BYTE*)_alloca(cbValDiv2*sizeof(BYTE));
			memset(rgBinary, 0, cbValDiv2);
			if (rgBinary == NULL)
				return E_FAIL;
			for (int irg = 0; irg < cbValue; irg++)
				rgBinary[(irg/2)] |= (ChToByte(szValue[irg])) << (4*(1 - (irg & 0x00000001)));
			lRes = RegSetValueEx(rkParent, szValueName, 0, REG_BINARY, rgBinary, cbValDiv2);
			break;
		}
	}

	if (ERROR_SUCCESS != lRes)
	{
		nIDRes = E_ATL_VALUE_SET_FAILED;
		hr = HRESULT_FROM_WIN32(lRes);
	}

	if (FAILED(hr = NextToken(szToken)))
		return hr;

	return S_OK;
}

inline BOOL CRegParser::CanForceRemoveKey(LPCTSTR szKey)
{
	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)
		if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel]))
			 return FALSE;                       // We cannot delete it

	return TRUE;
}

inline BOOL CRegParser::HasSubKeys(HKEY hkey)
{
	DWORD       cbSubKeys = 0;

	if (FAILED(RegQueryInfoKey(hkey, NULL, NULL, NULL,
							   &cbSubKeys, NULL, NULL,
							   NULL, NULL, NULL, NULL, NULL)))
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Should not be here!!\n"));
		ATLASSERT(FALSE);
		return FALSE;
	}

	return cbSubKeys > 0;
}

inline BOOL CRegParser::HasValues(HKEY hkey)
{
	DWORD       cbValues = 0;

	LONG lResult = RegQueryInfoKey(hkey, NULL, NULL, NULL,
								  NULL, NULL, NULL,
								  &cbValues, NULL, NULL, NULL, NULL);
	if (ERROR_SUCCESS != lResult)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("RegQueryInfoKey Failed "));
		ATLASSERT(FALSE);
		return FALSE;
	}

	if (1 == cbValues)
	{
		DWORD cbMaxName= MAX_VALUE;
		TCHAR szValueName[MAX_VALUE];
		// Check to see if the Value is default or named
		lResult = RegEnumValue(hkey, 0, szValueName, &cbMaxName, NULL, NULL, NULL, NULL);
		if (ERROR_SUCCESS == lResult && (szValueName[0] != NULL))
			return TRUE; // Named Value means we have a value
		return FALSE;
	}

	return cbValues > 0; // More than 1 means we have a non-default value
}

inline HRESULT CRegParser::SkipAssignment(LPTSTR szToken)
{
	HRESULT hr;
	TCHAR szValue[MAX_VALUE];

	if (*szToken == chEquals)
	{
		if (FAILED(hr = NextToken(szToken)))
			return hr;
		// Skip assignment
		SkipWhiteSpace();
		if (FAILED(hr = NextToken(szValue)))
			return hr;
		if (FAILED(hr = NextToken(szToken)))
			return hr;
	}

	return S_OK;
}

inline HRESULT CRegParser::PreProcessBuffer(LPCTSTR lpszReg, LPTSTR* ppszReg)
{
	USES_CONVERSION;
	ATLASSERT(lpszReg != NULL);
	ATLASSERT(ppszReg != NULL);
	*ppszReg = NULL;
	int nSize = lstrlen(lpszReg)*2;
	CParseBuffer pb(nSize);
	if (pb.p == NULL)
		return E_OUTOFMEMORY;
	LPCTSTR pchCur = lpszReg;
	HRESULT hr = S_OK;

	while (*pchCur != NULL) // look for end
	{
		if (*pchCur == _T('%'))
		{
			pchCur = CharNext(pchCur);
			if (*pchCur == _T('%'))
				pb.AddChar(pchCur);
			else
			{
				LPCTSTR lpszNext = StrChr(pchCur, _T('%'));
				if (lpszNext == NULL)
				{
					ATLTRACE2(atlTraceRegistrar, 0, _T("Error no closing % found\n"));
					hr = GenerateError(E_ATL_UNEXPECTED_EOS);
					break;
				}
				int nLength = int(lpszNext - pchCur);
				if (nLength > 31)
				{
					hr = E_FAIL;
					break;
				}
				TCHAR buf[32];
				lstrcpyn(buf, pchCur, nLength+1);
				LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);
				if (lpszVar == NULL)
				{
					hr = GenerateError(E_ATL_NOT_IN_MAP);
					break;
				}
				pb.AddString(lpszVar);
				while (pchCur != lpszNext)
					pchCur = CharNext(pchCur);
			}
		}
		else
			pb.AddChar(pchCur);
		pchCur = CharNext(pchCur);
	}
	pb.AddChar(pchCur);
	if (SUCCEEDED(hr))
		*ppszReg = pb.Detach();
	return hr;
}

inline HRESULT CRegParser::RegisterBuffer(LPTSTR szBuffer, BOOL bRegister)
{
	TCHAR   szToken[MAX_VALUE];
	HRESULT hr = S_OK;

	LPTSTR szReg;
	hr = PreProcessBuffer(szBuffer, &szReg);
	if (FAILED(hr))
		return hr;

#if defined(_DEBUG) && defined(DEBUG_REGISTRATION)
	OutputDebugString(szReg); //would call ATLTRACE but szReg is > 512 bytes
	OutputDebugString(_T("\n"));
#endif //_DEBUG

	m_pchCur = szReg;

	// Preprocess szReg

	while (NULL != *m_pchCur)
	{
		if (FAILED(hr = NextToken(szToken)))
			break;
		HKEY hkBase;
		if ((hkBase = HKeyFromString(szToken)) == NULL)
		{
			ATLTRACE2(atlTraceRegistrar, 0, _T("HKeyFromString failed on %s\n"), szToken);
			hr = GenerateError(E_ATL_BAD_HKEY);
			break;
		}

		if (FAILED(hr = NextToken(szToken)))
			break;

		if (chLeftBracket != *szToken)
		{
			ATLTRACE2(atlTraceRegistrar, 0, _T("Syntax error, expecting a {, found a %s\n"), szToken);
			hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);
			break;
		}
		if (bRegister)
		{
			LPTSTR szRegAtRegister = m_pchCur;
			hr = RegisterSubkeys(szToken, hkBase, bRegister);
			if (FAILED(hr))
			{
				ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to register, cleaning up!\n"));
				m_pchCur = szRegAtRegister;
				RegisterSubkeys(szToken, hkBase, FALSE);
				break;
			}
		}
		else
		{
			if (FAILED(hr = RegisterSubkeys(szToken, hkBase, bRegister)))
				break;
		}

		SkipWhiteSpace();
	}
	CoTaskMemFree(szReg);
	return hr;
}

inline HRESULT CRegParser::RegisterSubkeys(LPTSTR szToken, HKEY hkParent, BOOL bRegister, BOOL bRecover)
{
	CRegKey keyCur;
	LONG    lRes;
	LPTSTR  szKey = NULL;
	BOOL    bDelete = TRUE;
	BOOL    bInRecovery = bRecover;
	HRESULT hr = S_OK;

	ATLTRACE2(atlTraceRegistrar, 2, _T("Num Els = %d\n"), cbNeverDelete);
	if (FAILED(hr = NextToken(szToken)))
		return hr;


	while (*szToken != chRightBracket) // Continue till we see a }
	{
		BOOL bTokenDelete = !lstrcmpi(szToken, szDelete);

		if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete)
		{
			if (FAILED(hr = NextToken(szToken)))
				break;

			if (bRegister)
			{
				CRegKey rkForceRemove;

				if (StrChr(szToken, chDirSep) != NULL)
					return GenerateError(E_ATL_COMPOUND_KEY);

				if (CanForceRemoveKey(szToken))
				{
					rkForceRemove.Attach(hkParent);
					rkForceRemove.RecurseDeleteKey(szToken);
					rkForceRemove.Detach();
				}
				if (bTokenDelete)
				{
					if (FAILED(hr = NextToken(szToken)))
						break;
					if (FAILED(hr = SkipAssignment(szToken)))
						break;
					goto EndCheck;
				}
			}

		}

		if (!lstrcmpi(szToken, szNoRemove))
		{
			bDelete = FALSE;    // set even for register
			if (FAILED(hr = NextToken(szToken)))
				break;
		}

		if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent
		{
			TCHAR  szValueName[_MAX_PATH];

			if (FAILED(hr = NextToken(szValueName)))
				break;
			if (FAILED(hr = NextToken(szToken)))
				break;


			if (*szToken != chEquals)
				return GenerateError(E_ATL_EXPECTING_EQUAL);

			if (bRegister)
			{
				CRegKey rk;

				rk.Attach(hkParent);
				hr = AddValue(rk, szValueName, szToken);
				rk.Detach();

				if (FAILED(hr))
					return hr;

				goto EndCheck;
			}
			else
			{
				if (!bRecover)
				{
					ATLTRACE2(atlTraceRegistrar, 1, _T("Deleting %s\n"), szValueName);
					CRegKey rkParent;
					rkParent.Attach(hkParent);
					rkParent.DeleteValue(szValueName);
					rkParent.Detach();
				}

				if (FAILED(hr = SkipAssignment(szToken)))
					break;
				continue;  // can never have a subkey
			}
		}

		if (StrChr(szToken, chDirSep) != NULL)
			return GenerateError(E_ATL_COMPOUND_KEY);

		if (bRegister)
		{
			lRes = keyCur.Open(hkParent, szToken, KEY_ALL_ACCESS);
			if (ERROR_SUCCESS != lRes)
			{
				// Failed all access try read only
				lRes = keyCur.Open(hkParent, szToken, KEY_READ);
				if (ERROR_SUCCESS != lRes)
				{
					// Finally try creating it
					ATLTRACE2(atlTraceRegistrar, 2, _T("Creating key %s\n"), szToken);
					lRes = keyCur.Create(hkParent, szToken);
					if (ERROR_SUCCESS != lRes)
						return GenerateError(E_ATL_CREATE_KEY_FAILED);
				}
			}

			if (FAILED(hr = NextToken(szToken)))
				break;


			if (*szToken == chEquals)
			{
				if (FAILED(hr = AddValue(keyCur, NULL, szToken))) // NULL == default
					break;
			}
		}
		else
		{
			if (!bRecover && keyCur.Open(hkParent, szToken, KEY_READ) != ERROR_SUCCESS)
				bRecover = TRUE;

			// TRACE out Key open status and if in recovery mode
#ifdef _DEBUG
			if (!bRecover)
				ATLTRACE2(atlTraceRegistrar, 1, _T("Opened Key %s\n"), szToken);
			else
				ATLTRACE2(atlTraceRegistrar, 0, _T("Ignoring Open key on %s : In Recovery mode\n"), szToken);
#endif //_DEBUG

			// Remember Subkey
			if (szKey == NULL)
				szKey = (LPTSTR)_alloca(sizeof(TCHAR)*_MAX_PATH);
			lstrcpyn(szKey, szToken, _MAX_PATH);

			// If in recovery mode

			if (bRecover || HasSubKeys(keyCur) || HasValues(keyCur))
			{
				if (FAILED(hr = NextToken(szToken)))
					break;
				if (FAILED(hr = SkipAssignment(szToken)))
					break;


				if (*szToken == chLeftBracket)
				{
					if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, bRecover)))
						break;
					if (bRecover) // Turn off recovery if we are done
					{
						bRecover = bInRecovery;
						ATLTRACE2(atlTraceRegistrar, 0, _T("Ending Recovery Mode\n"));
						if (FAILED(hr = NextToken(szToken)))
							break;
						if (FAILED(hr = SkipAssignment(szToken)))
							break;
						continue;
					}
				}

				if (!bRecover && HasSubKeys(keyCur))
				{
					// See if the KEY is in the NeverDelete list and if so, don't
					if (CanForceRemoveKey(szKey))
					{
						ATLTRACE2(atlTraceRegistrar, 0, _T("Deleting non-empty subkey %s by force\n"), szKey);
						keyCur.RecurseDeleteKey(szKey);
					}
					if (FAILED(hr = NextToken(szToken)))
						break;
					continue;
				}

				if (bRecover)
					continue;
			}

			if (!bRecover && keyCur.Close() != ERROR_SUCCESS)
			   return GenerateError(E_ATL_CLOSE_KEY_FAILED);

			if (!bRecover && bDelete)
			{
				ATLTRACE2(atlTraceRegistrar, 0, _T("Deleting Key %s\n"), szKey);
				CRegKey rkParent;
				rkParent.Attach(hkParent);
				rkParent.DeleteSubKey(szKey);
				rkParent.Detach();
			}

			if (FAILED(hr = NextToken(szToken)))
				break;
			if (FAILED(hr = SkipAssignment(szToken)))
				break;
		}

EndCheck:

		if (bRegister)
		{
			if (*szToken == chLeftBracket && lstrlen(szToken) == 1)
			{
				if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, FALSE)))
					break;
				if (FAILED(hr = NextToken(szToken)))
					break;
			}
		}
	}

	return hr;
}

}; //namespace ATL

#endif //__STATREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\ana2enc.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing analog capture to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef ANA2ENC_H
#define ANA2ENC_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols
#include <objectwithsiteimplsec.h>
#include "dsextend.h"

/////////////////////////////////////////////////////////////////////////////
// CAna2EncComp
class ATL_NO_VTABLE __declspec(uuid("28953661-0231-41db-8986-21FF4388EE9B")) CAna2EncComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAna2EncComp, &__uuidof(CAna2EncComp)>,
    public IObjectWithSiteImplSec<CAna2EncComp>,
	public IMSVidCompositionSegmentImpl<CAna2EncComp>
{
public:
    CAna2EncComp() {}
    virtual ~CAna2EncComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_ANA2ENCCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CAna2EncComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CAna2EncComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()

public:

	PQCreateDevEnum m_pSystemEnum;

	//////////////

// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            TRACELM(TRACE_ERROR, "CVidCtl::Ana2Enc() Compose");
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
			if (upstream == downstream) {
		 	    return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(IMSVidCompositionSegment), E_INVALIDARG);
			}
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty up segment");
		 	    return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
		 	    return NOERROR;
            }
            // do the list backwards
            DSFilterList upF;
            for(VWGraphSegment::iterator upStart = up.begin(); upStart != up.end(); ++upStart){
                upF.push_back(*upStart);
            }

            for (DSFilterList::reverse_iterator iStart = upF.rbegin(); iStart != upF.rend(); ++iStart) {
                ASSERT((*iStart).GetGraph() == m_pGraph);
				for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++iStop) {
					ASSERT((*iStop).GetGraph() == m_pGraph);
					DSFilter pStart(*iStart);
					DSFilter pStop(*iStop);
					HRESULT hr = m_pGraph.Connect(pStart, pStop, m_Filters, 0x10);
                    if (SUCCEEDED(hr)) {
						m_Segments.push_back(up);
						m_Segments.push_back(down);
						m_pDown = m_Segments.end();
						--m_pDown;
						m_pUp = m_pDown;
						--m_pUp;
						m_fComposed = true;
						return NOERROR;
					}
				}
			}
            TRACELM(TRACE_ERROR, "CComposition::Compose() compose didn't connect anything");
	 	    return Error(IDS_CANT_COMPOSE, __uuidof(IMSVidCompositionSegment), E_FAIL);
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // ANA2ENC_H
// end of file - ANA2ENC.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\ana2xds.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing analog capture to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef ANA2XDS_H
#define ANA2XDS_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols
#include <objectwithsiteimplsec.h>
#include "dsextend.h"

/////////////////////////////////////////////////////////////////////////////
// CAna2XDSComp
class ATL_NO_VTABLE __declspec(uuid("3540D440-5B1D-49cb-821A-E84B8CF065A7")) CAna2XDSComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAna2XDSComp, &__uuidof(CAna2XDSComp)>,
    public IObjectWithSiteImplSec<CAna2XDSComp>,
	public IMSVidCompositionSegmentImpl<CAna2XDSComp>
{
public:
    CAna2XDSComp() {}
    virtual ~CAna2XDSComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_ANA2XDSCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CAna2XDSComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CAna2XDSComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()

public:

	PQCreateDevEnum m_pSystemEnum;

	//////////////

// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        TRACELM(TRACE_ERROR, "CVidCtl::Ana2XDS() Compose");
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {

#if 0
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CAna2XDSComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CAna2XDSComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }

            VWGraphSegment::iterator iCap;
            for(iCap = up.begin(); iCap != up.end(); ++iCap){
                if(IsAnalogVideoCapture(*iCap)){
                    break;
                }   
            }
            if (iCap == up.end()) {
                TRACELM(TRACE_ERROR, "CAna2XDSComp::Compose() upstream segment has no capture filter");
                return E_FAIL;
            }
            ASSERT((*iCap).GetGraph() == m_pGraph);
            DSFilter::iterator iVbi;
            for(iVbi = (*iCap).begin(); iVbi != (*iCap).end(); ++iVbi){
                if((*iVbi).HasCategory(PIN_CATEGORY_VBI)){
                    break;
                }
            }

            if(iVbi == (*iCap).end()){
                TRACELM(TRACE_ERROR, "CAna2XDSComp::Compose() capture filter has no vbi");
                return E_FAIL;
            }

            HRESULT hr = S_OK;
            DSFilterList intermediates;
            for(VWGraphSegment::iterator pXDS = down.begin(); pXDS != down.end(); ++pXDS){
                hr = (*iVbi).IntelligentConnect((*pXDS), intermediates);
                if(FAILED(hr)){
                    continue;
                }
                else{
                    break;
                }
            }

            if(FAILED(hr)){
                TRACELM(TRACE_ERROR, "CAna2XDSComp::Compose() can't connect vbi to xds");
                return hr;
            }
            m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
			return NOERROR;
#else
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
			if (upstream == downstream) {
		 	    return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(IMSVidCompositionSegment), E_INVALIDARG);
			}
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty up segment");
		 	    return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
		 	    return NOERROR;
            }
            // do the list backwards
            DSFilterList upF;
            for(VWGraphSegment::iterator upStart = up.begin(); upStart != up.end(); ++upStart){
                upF.push_back(*upStart);
            }

            for (DSFilterList::reverse_iterator iStart = upF.rbegin(); iStart != upF.rend(); ++iStart) {
                ASSERT((*iStart).GetGraph() == m_pGraph);
				for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++iStop) {
					ASSERT((*iStop).GetGraph() == m_pGraph);
					DSFilter pStart(*iStart);
					DSFilter pStop(*iStop);
//					HRESULT hr = m_pGraph.Connect(pStart, pStop, m_Filters);
					HRESULT hr = m_pGraph.Connect(pStop, pStart, m_Filters, 0, UPSTREAM);
                    if (SUCCEEDED(hr)) {
						m_Segments.push_back(up);
						m_Segments.push_back(down);
						m_pDown = m_Segments.end();
						--m_pDown;
						m_pUp = m_pDown;
						--m_pUp;
						m_fComposed = true;
						return NOERROR;
					}
				}
			}
            TRACELM(TRACE_ERROR, "CComposition::Compose() compose didn't connect anything");
	 	    return Error(IDS_CANT_COMPOSE, __uuidof(IMSVidCompositionSegment), E_FAIL);
#endif
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // Ana2XDS_H
// end of file - Ana2XDS.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\analogtvcp.h ===
// Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.
#ifndef _MSVIDANALOGTUNERCP_H_
#define _MSVIDANALOGTUNERCP_H_

template <class T>
class CProxy_IMSVidAnalogTuner : public CProxy_Tuner<T, &IID_IMSVidAnalogTunerEvent, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:

// TODO: add fileplayback specific events here	
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\anadata.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing analog capture to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef ANADATA_H
#define ANADATA_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols
#include <objectwithsiteimplsec.h>

/////////////////////////////////////////////////////////////////////////////
// CAnaDataComp
class ATL_NO_VTABLE __declspec(uuid("C5702CD6-9B79-11d3-B654-00C04F79498E")) CAnaDataComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAnaDataComp, &__uuidof(CAnaDataComp)>,
    public IObjectWithSiteImplSec<CAnaDataComp>,
	public IMSVidCompositionSegmentImpl<CAnaDataComp>
{
public:
    CAnaDataComp() {}
    virtual ~CAnaDataComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_ANADATACOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CAnaDataComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CAnaDataComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()

public:

	PQCreateDevEnum m_pSystemEnum;

	//////////////
	HRESULT ConnectCodecPin(DSPin& pCodecPin, DSFilter& pCap, DSFilter& pIPSink) {
		// if this fails we just skip the pin not the whole filter so we don't need
		// to check the return code from the connect
		if (pCodecPin.IsInput()) {
			pCodecPin.IntelligentConnect(pCap, m_Filters, 0, UPSTREAM);
		} else {
            pCodecPin.IntelligentConnect(pIPSink, m_Filters, DSGraph::ATTEMPT_MERIT_DO_NOT_USE);
		}
		return NOERROR;
	}

	//////////////
	HRESULT AddCodec(const DSFilterMoniker& pCodecMkr, DSFilter& pCap, DSFilter& pIPSink) {
		DSFilter pCodec = m_pGraph.AddMoniker(pCodecMkr);
		if (!pCodec) {
            // this can happen if a codec is uninstalled or the driver file is removed
            // but the registry doesn't get cleaned up.
            // also can happen on an upgrade if a codec has been removed from the product.
            TRACELSM(TRACE_ERROR, (dbgDump << "CAnaDataComp::AddCodec() can't add mkr" << pCodecMkr), "");
            return S_FALSE;
		}
		m_Filters.push_back(pCodec);
		//connect all input pins including hw slicing support
		std::for_each(pCodec.begin(),
					  pCodec.end(),
					  bndr_obj_2_3<arity3pmf<CAnaDataComp, DSPin&, DSFilter&, DSFilter&, HRESULT> >(
						  *this, 
						  arity3pmf<CAnaDataComp, 
									DSPin&, 
									DSFilter&, 
									DSFilter&, 
									HRESULT>(&CAnaDataComp::ConnectCodecPin), 
						  pCap, 
						  pIPSink
					 ));

		return NOERROR;
	}

	//////////////
	HRESULT CapturePinPrep(DSPin& pCapPin, DSFilter& pMSTee, DSFilter& pVPM) {
		if (pCapPin.GetConnection() || pCapPin.GetDirection() == PINDIR_INPUT) {
			return NOERROR;  // skip connected pins
		}
		HRESULT hr;
		DSPin targ;
		if (pCapPin.HasCategory(PIN_CATEGORY_VBI)) {
			if (!pMSTee) {
				DSDevices teelist(m_pSystemEnum, KSCATEGORY_SPLITTER);
				pMSTee = m_pGraph.AddMoniker(*(teelist.begin()));
				if (!pMSTee) {
					TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() can't add mstee moniker to graph");
					THROWCOM(E_UNEXPECTED);
				}
			}
			targ = pMSTee.FirstPin(PINDIR_INPUT);
		    ASSERT(targ);
		    hr = pCapPin.Connect(targ);
		    if (FAILED(hr)) {
			    TRACELSM(TRACE_ERROR, (dbgDump << "CAnaDataComp::CapturePinPrep() can't connect " << pCapPin << " " << pCapPin.GetFilter() << " to " << targ << " " << targ.GetFilter() << " hr = " << std::hex << hr), "");
			    THROWCOM(E_UNEXPECTED);
		    }
		} else if (pCapPin.HasCategory(PIN_CATEGORY_VIDEOPORT_VBI)) {
			// hook up vbi surf to pincat_vpvbi
			if (!pVPM) {
				CString csName(_T("VideoPort Manager"));
				pVPM = m_pGraph.AddFilter(CLSID_VideoPortManager, csName);
				if (!pVPM) {
					TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() can't create vbisurf");
					THROWCOM(E_UNEXPECTED);
				}
			}
            DSFilterList intermediates;
		    hr = pCapPin.IntelligentConnect(pVPM, intermediates);
		    if (FAILED(hr)) {
			    TRACELSM(TRACE_ERROR, (dbgDump << "CAnaDataComp::CapturePinPrep() can't connect " << pCapPin << " " << pCapPin.GetFilter() << " to " << targ << " " << targ.GetFilter() << " hr = " << std::hex << hr), "");
			    THROWCOM(E_UNEXPECTED);
		    }
	        m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
		}
		return NOERROR;
	}

// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
            VWGraphSegment::iterator iCap = std::find_if(up.begin(),
                                                         up.end(),
                                                         arity1_pointer(&IsAnalogVideoCapture));
            if (iCap == up.end()) {
                TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() upstream segment has no capture filter");
                return E_FAIL;
            }
            ASSERT((*iCap).GetGraph() == m_pGraph);

            VWGraphSegment::iterator iIPSink = std::find_if(down.begin(),
															down.end(),
															arity1_pointer(&IsIPSink));
            if (iIPSink == down.end()) {
                TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() downstream segment has no ip sink filter");
                return E_FAIL;
            }
			if (!m_pSystemEnum) {
				HRESULT hr = m_pSystemEnum.CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
				if (FAILED(hr)) {
					return E_UNEXPECTED;
				}
			}
			DSFilter ipsink(*iIPSink);
            ASSERT(!!ipsink);
            ASSERT(ipsink.GetGraph() == m_pGraph);
            PQVidCtl pqCtl;
			HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
			if(FAILED(hr)){
				return hr;
			}
            CComQIPtr<IMSVidVideoRenderer> spVidVid;
            hr = pqCtl->get_VideoRendererActive(&spVidVid);
            if(FAILED(hr)){
                return hr;
            }
            DSFilter vpm;
            bool fVPMalreadyloaded = false;
            if(spVidVid){
                for (DSGraph::iterator i = m_pGraph.begin(); i != m_pGraph.end(); ++i) {
                    DSFilter f(*i);
                    if (IsVPM(f)) {
                        vpm = f;
                        fVPMalreadyloaded = true;
                        break;
                    }
                }
            }
            DSFilter mstee;
#if 0
			std::for_each((*iCap).begin(), 
						  (*iCap).end(), 
						  bndr_obj_2_3<arity3pmf<CAnaDataComp, DSPin&, DSFilter&, DSFilter&, HRESULT> >(
							  *this, 
							  arity3pmf<CAnaDataComp, 
										DSPin&, 
										DSFilter&, 
										DSFilter&, 
										HRESULT>(&CAnaDataComp::CapturePinPrep), 
							  mstee, 
							  vpm
						  ));
#else
            DSFilter::iterator i2;
            for (i2 = (*iCap).begin(); i2 != (*iCap).end(); ++i2) {
                CapturePinPrep(*i2, mstee, vpm);
            }
#endif
			if (!mstee) {
				TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() no vbi pins on capture filter");
				return Error(IDS_E_NOVBI, __uuidof(CAnaCapComp), E_FAIL);
			}
            if (vpm && !fVPMalreadyloaded) {
                m_Filters.push_back(vpm);
            }
            m_Filters.push_back(mstee);
            //m_Filters.push_back(ipsink);

			// create codec enumerator
			DSDevices codeclist(m_pSystemEnum, KSCATEGORY_VBICODEC);
			std::for_each(codeclist.begin(), 
						  codeclist.end(), 
						  bndr_obj_2_3<arity3pmf<CAnaDataComp, const DSFilterMoniker&, DSFilter&, DSFilter&, HRESULT> >(
							  *this, 
							  arity3pmf<CAnaDataComp, 
										const DSFilterMoniker&, 
										DSFilter&, 
										DSFilter&, 
										HRESULT>(&CAnaDataComp::AddCodec), 
							  (*iCap), 
							  ipsink
						  ));
			return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // ANADATA_H
// end of file - anadata.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\atscchanneltunerequest.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCChannelTuneRequest.cpp : Implementation of CATSCChannelTuneRequest
// Copyright (c) Microsoft Corporation 1999.

#include "stdafx.h"
#include "Tuner.h"
#include "ATSCChannelTuneRequest.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ATSCChannelTuneRequest, CATSCChannelTuneRequest)

/////////////////////////////////////////////////////////////////////////////
// CATSCChannelTuneRequest

STDMETHODIMP CATSCChannelTuneRequest::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATSCChannelTuneRequest
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\anacap.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing analog capture to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef ANACAP_H
#define ANACAP_H

#pragma once
#include <uuids.h>
#include "bdamedia.h"
#include "MSVidTVTuner.h"
#include "resource.h"       // main symbols
#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include "devices.h"


/////////////////////////////////////////////////////////////////////////////
// CAnaCapComp
class ATL_NO_VTABLE __declspec(uuid("E18AF75A-08AF-11d3-B64A-00C04F79498E")) CAnaCapComp : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAnaCapComp, &__uuidof(CAnaCapComp)>,
    public IObjectWithSiteImplSec<CAnaCapComp>,
    public IMSVidCompositionSegmentImpl<CAnaCapComp>
{
public:
    CAnaCapComp() {}
    virtual ~CAnaCapComp() {}

    REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_ANACAPCOMP_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CAnaCapComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CAnaCapComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()

    // IMSVidComposition
public:
    // IMSVidGraphSegment
    // IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
    {
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose()");
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }

            VWGraphSegment::iterator iOv;
            for (iOv = down.begin(); iOv != down.end(); ++iOv) {
                if (IsVideoRenderer(*iOv)) {
                    break;
                }
            }

            if (iOv == down.end()) {
                TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() downstream segment has no ov mixer filter");
                return E_FAIL;
            }

            TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() found vr");

            ASSERT((*iOv).GetGraph() == m_pGraph);
            DSFilter pOv(*iOv);

            CComQIPtr<IMSVidAnalogTuner> qiITV(upstream);
            CMSVidTVTuner* qiTV;
            qiTV = static_cast<CMSVidTVTuner*>(qiITV.p);
            DSPin pVidPin;
            VWGraphSegment::iterator iCap;
            for (iCap = up.begin(); iCap != up.end(); ++iCap) {
                if (IsAnalogVideoCapture(*iCap)) {
                    break;
                }
            }
            if (iCap == up.end()) {
                TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() upstream segment has no capture filter");
                return E_FAIL;
            }
            ASSERT((*iCap).GetGraph() == m_pGraph);
            TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() found capture filter");

            DSFilter pCap(*iCap);

            DSFilter::iterator iCapPin;
            DSPin pCapPin;
            DSPin pVPMPin;
            DSPin pPrePin;
            for (iCapPin = pCap.begin(); iCapPin != pCap.end(); ++iCapPin) {
                if (IsAnalogVideoCaptureViewingPin(*iCapPin)) {
                    if((*iCapPin).HasCategory(PIN_CATEGORY_VIDEOPORT)){
                        _ASSERT(pVPMPin == NULL);
                        pVPMPin = (*iCapPin);
                        continue;
                    }
                    else{
                        _ASSERT(pCapPin == NULL);
                        pCapPin = (*iCapPin);
                        continue;
                    }
                }
                if (IsAnalogVideoCapturePreviewPin(*iCapPin)) {
                    _ASSERT(pPrePin == NULL);
                    pPrePin = (*iCapPin);
                    continue;
                }
            }
            if (!pCapPin && !pPrePin && !pVPMPin) {  

                TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() no video pin on capture");
                bool fDeMux = false;

                // See if this is an error or not
                PQVidCtl pqCtl;
                if(!!m_pContainer){
                    HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
                    if(FAILED(hr)){
                        return hr;
                    }

                    PQFeatures fa;
                    hr = pqCtl->get_FeaturesActive(&fa);
                    if(FAILED(hr)){
                        return hr;
                    }

                    CFeatures* pC = static_cast<CFeatures *>(fa.p);
                    DeviceCollection::iterator i;
                    for(i = pC->m_Devices.begin(); i != pC->m_Devices.end(); ++i){
                        if(VWGraphSegment(*i).ClassID() == CLSID_MSVidEncoder){
                            break;
                        }
                    }

                    if(i != pC->m_Devices.end()){
                        fDeMux = true;
                    }
                }
                if (fDeMux){
                    TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() no viewing or previewing pin found but encoder active");
                    return NOERROR;
                }
                else{
                    TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() no viewing or previewing pin found");
                    return E_FAIL;
                }
            }

            TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() found viewing or previewing pin");

            // this is an intelligent connect so that we can bring in xforms
            // for example certain usb tuners want to have media type jpg not yuv which
            // means we need a jpg/yuv xform between capture and render
            // this will also bring in the vpm if necessary
            HRESULT hr = E_FAIL;
            DSFilterList intermediates;
            if(pVPMPin){
                DSFilter vpm;
                bool fVPMalreadyloaded = false;

                for (DSGraph::iterator i = m_pGraph.begin(); i != m_pGraph.end(); ++i) {
                    DSFilter f(*i);
                    if (IsVPM(f)) {
                        vpm = f;
                        fVPMalreadyloaded = true;
                        break;
                    }
                }

                if (!fVPMalreadyloaded) {
                    HRESULT hr = vpm.CoCreateInstance(CLSID_VideoPortManager);
                    if (FAILED(hr)) {
                        TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() can't create vpm");
                        return E_UNEXPECTED;
                    }
                    CString csName;
                    hr = m_pGraph.AddFilter(vpm, csName);
                    if (FAILED(hr)) {
                        TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() can't insert vpm in graph");
                        return E_UNEXPECTED;
                    }
                }

                if (vpm && !fVPMalreadyloaded) {
                    m_Filters.push_back(vpm);
                }
                DSFilter::iterator iVPVBI;
                for (iVPVBI = pCap.begin(); iVPVBI != pCap.end(); ++iVPVBI) {
                    DSPin pVPVBI(*iVPVBI);
                    if (pVPVBI.HasCategory(PIN_CATEGORY_VIDEOPORT_VBI)) {
                        HRESULT hr = pVPVBI.IntelligentConnect(vpm, m_Filters);
                        if (SUCCEEDED(hr)) {
                            break;
                        }
                    }
                }

                hr = pVPMPin.IntelligentConnect(pOv, intermediates);
                if(FAILED(hr)){
                    return Error(IDS_CANT_CONNECT_CAP_VR, __uuidof(IMSVidCtl), E_UNEXPECTED);
                }
            }
            else if(pCapPin){
                hr = pCapPin.IntelligentConnect(pOv, intermediates);
            }

            if(FAILED(hr)){
                if(pPrePin){
                    hr = pPrePin.IntelligentConnect(pOv, intermediates);
                }
            }

            if (FAILED(hr)) {
                return Error(IDS_CANT_CONNECT_CAP_VR, __uuidof(IMSVidCtl), E_UNEXPECTED);
            }
            m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());

            TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() SUCCEEDED");
            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            HRESULT hr = e;
            TRACELSM(TRACE_ERROR, (dbgDump << "CAnaCapComp::Compose() exception = " << hexdump(hr)), "");
            return e;
        } catch (...) {
            TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() exception ... ");
            return E_UNEXPECTED;
        }
    }
};

#endif // ANACAP_H
// end of file - anacap.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\atscchanneltunerequest.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCChannelTuneRequest.h : Declaration of the CATSCChannelTuneRequest
// Copyright (c) Microsoft Corporation 1999.

#ifndef __ATSCCHANNELTUNEREQUEST_H_
#define __ATSCCHANNELTUNEREQUEST_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "atscchanneltunerequestimpl.h"

typedef CComQIPtr<IATSCChannelTuneRequest> PQATSCChannelTuneRequest;

/////////////////////////////////////////////////////////////////////////////
// CATSCChannelTuneRequest
class ATL_NO_VTABLE CATSCChannelTuneRequest : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IATSCChannelTuneRequestImpl<CATSCChannelTuneRequest>,
	public CComCoClass<CATSCChannelTuneRequest, &CLSID_ATSCChannelTuneRequest>,
    public IObjectWithSiteImplSec<CATSCChannelTuneRequest>,
	public ISupportErrorInfo
{
public:

	CATSCChannelTuneRequest() {}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_ATSCCHANNELTUNEREQUEST_PROGID, 
						   IDS_REG_ATSCCHANNELTUNEREQUEST_DESC,
						   LIBID_TunerLib,
						   CLSID_ATSCChannelTuneRequest, tvBoth);

BEGIN_COM_MAP(CATSCChannelTuneRequest)
	COM_INTERFACE_ENTRY(IATSCChannelTuneRequest)
	COM_INTERFACE_ENTRY(IChannelTuneRequest)
	COM_INTERFACE_ENTRY(ITuneRequest)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP_WITH_FTM()

BEGIN_CATEGORY_MAP(CATSCChannelTuneRequest)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
    IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    typedef IATSCChannelTuneRequestImpl<CATSCChannelTuneRequest> basetype;
    BEGIN_PROP_MAP(CATSCChannelTuneRequest)
        CHAIN_PROP_MAP(basetype)
    END_PROP_MAP()


};

#endif //__ATSCCHANNELTUNEREQUEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\analogradiots.h ===
/////////////////////////////////////////////////////////////////////////////////////
// AnalogRadioTS.h : Declaration of the CAnalogRadioTS
// Copyright (c) Microsoft Corporation 1999.

#ifndef __ANALOGRADIOTS_H_
#define __ANALOGRADIOTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "analogradiotsimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CAnalogRadioTS
class ATL_NO_VTABLE __declspec(uuid("8A674B4C-1F63-11d3-B64C-00C04F79498E")) CAnalogRadioTS : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAnalogRadioTS, &__uuidof(CAnalogRadioTS)>,
    public IObjectWithSiteImplSec<CAnalogRadioTS>,
	public IAnalogRadioTSImpl<CAnalogRadioTS>
{
public:
    CAnalogRadioTS() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_ANALOGRADIOTS_PROGID, 
						   IDS_REG_ANALOGRADIOTS_DESC,
						   LIBID_TunerLib,
						   __uuidof(CAnalogRadioTS), tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAnalogRadioTS)
    COM_INTERFACE_ENTRY(IAnalogRadioTuningSpace)
    COM_INTERFACE_ENTRY(ITuningSpace)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP_WITH_FTM()

BEGIN_CATEGORY_MAP(CAnalogRadioTS)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
    IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CAnalogRadioTS)
        CHAIN_PROP_MAP(IAnalogRadioTSImpl<CAnalogRadioTS>)
    END_PROPERTY_MAP()

};

typedef CComQIPtr<IAnalogRadioTuningSpace> PQAnalogRadioTS;

#endif //__ANALOGRADIOTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\anasin.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing ANAlog capture to sbe SINk
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef ANASIN_H
#define ANASIN_H

#pragma once
#include "stdafx.h"
#include <uuids.h>
#include "bdamedia.h"
#include "MSVidTVTuner.h"
#include "MSVidSBESink.h"
#include "encdec.h"
#include "resource.h"       // main symbols
#include <objectwithsiteimplsec.h>
#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>



/////////////////////////////////////////////////////////////////////////////
// CAnaSinComp
class ATL_NO_VTABLE __declspec(uuid("9F50E8B1-9530-4ddc-825E-1AF81D47AED6")) CAnaSinComp : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAnaSinComp, &__uuidof(CAnaSinComp)>,
    public IObjectWithSiteImplSec<CAnaSinComp>,
    public IMSVidCompositionSegmentImpl<CAnaSinComp>
{
public:
    CAnaSinComp() {}
    virtual ~CAnaSinComp() {}
    
    REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_ANASINCOMP_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CAnaSinComp));
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()
        
        BEGIN_COM_MAP(CAnaSinComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
        END_COM_MAP()
        
        // IMSVidComposition
public:
    // IMSVidGraphSegment
    // IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
    {
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose()");
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
#if 0
            VWGraphSegment::iterator iOv = std::find_if(down.begin(),
                down.end(),
                arity1_pointer(&IsVideoRenderer));
#endif            
            CMSVidStreamBufferSink* ds = (CMSVidStreamBufferSink*)downstream;
            DSFilter pSink(ds->m_Filters[0]);
            
            CComQIPtr<IMSVidAnalogTuner> qiITV(upstream);
            CMSVidTVTuner* qiTV;
            qiTV = static_cast<CMSVidTVTuner*>(qiITV.p);
            DSPin pVidPin;
            DSPin pAudPin;
#if 0
            if(!!qiTV && qiTV->m_iDeMux > 0){
                CString csName;
                // render demux out to vr
                DSFilter pDeMux = qiTV->m_Filters[qiTV->m_iDeMux];
                DSFilter::iterator iVidPin;
                DSMediaType mtVideo(MEDIATYPE_Video, MEDIASUBTYPE_MPEG2_VIDEO, FORMAT_MPEG2Video);
                DSMediaType mtAudio(MEDIATYPE_Audio, MEDIASUBTYPE_MPEG1Payload, FORMAT_WaveFormatEx);
                for (iVidPin = pDeMux.begin(); iVidPin != pDeMux.end(); ++iVidPin) {
                    DSPin::iterator j;
                    for(j = (*iVidPin).begin(); j != (*iVidPin).end(); ++j){
                        DSMediaType pinType(*j);
                        if (pinType == mtVideo){
                            CComPtr<IUnknown> spMpeg2Analyze(CLSID_Mpeg2VideoStreamAnalyzer, NULL, CLSCTX_INPROC_SERVER);
                            if (!spMpeg2Analyze) {
                                //TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidStreamBufferSink::Build() can't load Stream Buffer Sink");
                                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
                            }
                            DSFilter vr(spMpeg2Analyze);
                            if (!vr) {
                                ASSERT(false);
                                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
                            }
                            m_Filters.push_back(vr);
                            csName = _T("Mpeg2 Analysis");
                            m_pGraph.AddFilter(vr, csName);
                            DSFilter::iterator a;
                            for(a = vr.begin(); a != vr.end(); ++a){
                                HRESULT hr = (*a).Connect(*iVidPin);
                                if(FAILED(hr)){
                                    continue;
                                }
                                else{
                                    break;
                                }
                            }
                            if(a == vr.end()){
                                return E_FAIL;
                            }
                            for(a = vr.begin(); a != vr.end(); ++a){
                                if((*a).GetDirection() == PINDIR_OUTPUT){
                                   pVidPin = (*a); 
                                }
                            }
                            if(!pVidPin){
                                return E_FAIL;
                            }
                        }
                        if(pinType == mtAudio){
                            pAudPin = (*iVidPin);
                        }
                    }
                    if(!!pVidPin && !!pAudPin){
                        break;
                    }
                }

                if(!pVidPin || !pAudPin){
                    TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't find video and/or audio pin on demux");
                    return E_UNEXPECTED;  
                }

                DSFilterList intermediates;
                CComBSTR encString(L"{C4C4C4F1-0049-4E2B-98FB-9537F6CE516D}");
                GUID2 encdecGuid (encString);
                HRESULT hr = S_OK;

                // Create and add to graph the Video Tagger Filter                
                CComPtr<IUnknown> spEncTagV(encdecGuid, NULL, CLSCTX_INPROC_SERVER);
                if (!spEncTagV) {
                    TRACELM(TRACE_ERROR, "CMSVidStreamBufferSink::Build() can't load Tagger filter");
                    return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
                }

                DSFilter vrV(spEncTagV);
                if (!vrV) {
                    ASSERT(false);
                    return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
                }

                m_Filters.push_back(vrV);
                csName = _T("Video Encoder Tagger Filter");
                m_pGraph.AddFilter(vrV, csName);
                
                // Connect video pin to Tagger
                hr = pVidPin.IntelligentConnect(vrV, intermediates);
                if(FAILED(hr)){
                    TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect audio pin to Audio Tagger");
                    return E_UNEXPECTED;  
                }
                
                // Connect Tagger to Sink
                DSFilter::iterator fil, vP;
                hr = E_FAIL;
                for(vP = vrV.begin(); vP != vrV.end(); ++ vP){
                    if((*vP).GetDirection() == PINDIR_OUTPUT){
                        break;   
                    }
                }
                if(vP == vrV.end()){
                    return E_UNEXPECTED;
                }
                for(fil = pSink.begin(); fil != pSink.end() && FAILED(hr); ++fil){
                    hr = (*vP).Connect((*fil));
                }
                if(FAILED(hr)){

                    TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Video Tagger to Sink");
                    return E_UNEXPECTED;  
                }

                // Create and add to graph the Audio Tagger Filter 
                CComPtr<IUnknown> spEncTagA(encdecGuid, NULL, CLSCTX_INPROC_SERVER);
                if (!spEncTagA) {
                    TRACELM(TRACE_ERROR, "CMSVidStreamBufferSink::Build() can't load Tagger filter");
                    return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
                }

                DSFilter vrA(spEncTagA);
                if (!vrA) {
                    ASSERT(false);
                    return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
                }

                m_Filters.push_back(vrA);
                csName = _T("Audio Encoder Tagger Filter");
                m_pGraph.AddFilter(vrA, csName);

                // Connect audio pin to the Tagger
                hr = pAudPin.IntelligentConnect(vrA, intermediates);
                if(FAILED(hr)){
                    TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect audio pin to Audio Tagger");
                    return E_UNEXPECTED;  
                }
               
                // Connect Tagger to Sink
                hr = E_FAIL;
                for(vP = vrA.begin(); vP != vrA.end(); ++ vP){
                    if((*vP).GetDirection() == PINDIR_OUTPUT){
                        break;   
                    }
                }
                if(vP == vrA.end()){
                    return E_UNEXPECTED;
                }
                for(fil = pSink.begin(); fil != pSink.end() && FAILED(hr); ++fil){
                    hr = (*vP).Connect((*fil));
                }
                if(FAILED(hr)){

                    TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Video Tagger to Sink");
                    return E_UNEXPECTED;  
                }
                /*                
                hr = m_pGraph.Connect(vrA, pSink, intermediates);
                if(FAILED(hr)){
                    TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Audio Tagger to Sink");
                    return E_UNEXPECTED;  
                }
                */

                ASSERT(intermediates.begin() == intermediates.end());
                m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());

            }
            else{
#endif
                return S_OK;
#if 0
            }
#endif
            TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() SUCCEEDED");
            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            HRESULT hr = e;
            TRACELSM(TRACE_ERROR, (dbgDump << "CAnaSinComp::Compose() exception = " << hexdump(hr)), "");
            return e;
        } catch (...) {
            TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() exception ... ");
            return E_UNEXPECTED;
        }
    }
};

#endif // AnaSin_H
// end of file - AnaSin.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\analogtvts.h ===
/////////////////////////////////////////////////////////////////////////////////////
// AnalogTVTS.h : Declaration of the CAnalogTVTS
// Copyright (c) Microsoft Corporation 1999.

#ifndef __ANALOGTVTS_H_
#define __ANALOGTVTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "analogtvtsimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CAnalogTVTS
class ATL_NO_VTABLE __declspec(uuid("8A674B4D-1F63-11d3-B64C-00C04F79498E")) CAnalogTVTS : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAnalogTVTS, &__uuidof(CAnalogTVTS)>,
    public IObjectWithSiteImplSec<CAnalogTVTS>,
	public IAnalogTVTSImpl<CAnalogTVTS>
{
public:
    CAnalogTVTS() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_ANALOGTVTS_PROGID, 
						   IDS_REG_ANALOGTVTS_DESC,
						   LIBID_TunerLib,
						   __uuidof(CAnalogTVTS), tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAnalogTVTS)
    COM_INTERFACE_ENTRY(IAnalogTVTuningSpace)
    COM_INTERFACE_ENTRY(ITuningSpace)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP_WITH_FTM()

BEGIN_CATEGORY_MAP(CAnalogTVTS)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
    IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CAnalogTVTS)
        CHAIN_PROP_MAP(IAnalogTVTSImpl<CAnalogTVTS>)
    END_PROPERTY_MAP()

};

typedef CComQIPtr<IAnalogTVTuningSpace> PQAnalogTVTS;

#endif //__ANALOGTVTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\atsclocator.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCLocator.cpp : Implementation of CATSCLocator
// Copyright (c) Microsoft Corporation 1999-2000.

#include "stdafx.h"
#include "Tuner.h"
#include "ATSCLocator.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ATSCLocator, CATSCLocator)

/////////////////////////////////////////////////////////////////////////////
// CATSCLocator

STDMETHODIMP CATSCLocator::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATSCLocator
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\atsclocator.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCLocator.h : Declaration of the CATSCLocator
// Copyright (c) Microsoft Corporation 2000.

#ifndef __ATSCLOCATOR_H_
#define __ATSCLOCATOR_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "ATSClocatorimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CATSCLocator
class ATL_NO_VTABLE __declspec(uuid("8872FF1B-98FA-4d7a-8D93-C9F1055F85BB"))CATSCLocator : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATSCLocator, &CLSID_ATSCLocator>,
    public IObjectWithSiteImplSec<CATSCLocator>,
	public IATSCLocatorImpl<CATSCLocator>,
	public ISupportErrorInfo
{
public:
    CATSCLocator() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_ATSCLOCATOR_PROGID, 
						   IDS_REG_ATSCLOCATOR_DESC,
						   LIBID_TunerLib,
						   CLSID_ATSCLocator, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATSCLocator)
	COM_INTERFACE_ENTRY(IATSCLocator)
	COM_INTERFACE_ENTRY(ILocator)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CATSCLocator)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()


public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CATSCLocator)
        CHAIN_PROP_MAP(IATSCLocatorImpl<CATSCLocator>)
    END_PROPERTY_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

typedef CComQIPtr<IATSCLocator> PQATSCLocator;

#endif //__ATSCLOCATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\atscts.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCTS.h : Declaration of the CATSCTS
// Copyright (c) Microsoft Corporation 1999.

#ifndef __ATSCTS_H_
#define __ATSCTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "ATSCtsimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CATSCTS
class ATL_NO_VTABLE __declspec(uuid("A2E30750-6C3D-11d3-B653-00C04F79498E")) CATSCTS : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATSCTS, &__uuidof(CATSCTS)>,
    public IObjectWithSiteImplSec<CATSCTS>,
	public IATSCTSImpl<CATSCTS>
{
public:
    CATSCTS() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_ATSCTUNINGSPACE_PROGID, 
						   IDS_REG_ATSCTUNINGSPACE_DESC,
						   LIBID_TunerLib,
						   __uuidof(CATSCTS), tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATSCTS)
    COM_INTERFACE_ENTRY(IATSCTuningSpace)
    COM_INTERFACE_ENTRY(IAnalogTVTuningSpace)
    COM_INTERFACE_ENTRY(ITuningSpace)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMPEG2TuneRequestSupport)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CATSCTS)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()


public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CATSCTS)
        CHAIN_PROP_MAP(IATSCTSImpl<CATSCTS>)
    END_PROPERTY_MAP()

};

typedef CComQIPtr<IATSCTuningSpace> PQATSCTS;

#endif //__ATSCTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\auxiliaryints.h ===
/////////////////////////////////////////////////////////////////////////////////////
// AnalogRadioTS.h : Declaration of the CAuxInTS
// Copyright (c) Microsoft Corporation 1999.

#ifndef __AUXINTS_H_
#define __AUXINTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "AuxIntsimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CAuxInTS
class ATL_NO_VTABLE __declspec(uuid("F9769A06-7ACA-4e39-9CFB-97BB35F0E77E")) CAuxInTS : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAuxInTS, &__uuidof(CAuxInTS)>,
    public IObjectWithSiteImplSec<CAuxInTS>,
	public IAuxInTSImpl<CAuxInTS>
{
public:
    CAuxInTS() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_AUXINTS_PROGID, 
						   IDS_REG_AUXINTS_DESC,
						   LIBID_TunerLib,
						   __uuidof(CAuxInTS), tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAuxInTS)
    COM_INTERFACE_ENTRY(IAuxInTuningSpace)
    COM_INTERFACE_ENTRY(ITuningSpace)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP_WITH_FTM()

BEGIN_CATEGORY_MAP(CAuxInTS)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
    IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CAuxInTS)
        CHAIN_PROP_MAP(IAuxInTSImpl<CAuxInTS>)
    END_PROPERTY_MAP()

};

typedef CComQIPtr<IAuxInTuningSpace> PQAuxInTS;

#endif //__AUXINTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\atsccomponenttype.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCComponentType.h : Declaration of the CATSCComponentType
// Copyright (c) Microsoft Corporation 1999.

#ifndef __ATSCCOMPONENTTYPE_H_
#define __ATSCCOMPONENTTYPE_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "ATSCcomponenttypeimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CATSCComponentType
class ATL_NO_VTABLE __declspec(uuid("A8DCF3D5-0780-4ef4-8A83-2CFFAACB8ACE")) CATSCComponentType : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATSCComponentType, &CLSID_ATSCComponentType>,
    public IObjectWithSiteImplSec<CATSCComponentType>,
	public IATSCComponentTypeImpl<CATSCComponentType>
{
public:
	CATSCComponentType()
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_ATSCCOMPONENTTYPE_PROGID, 
						   IDS_REG_ATSCCOMPONENTTYPE_DESC,
						   LIBID_TunerLib,
						   CLSID_ATSCComponentType, tvBoth);

DECLARE_NOT_AGGREGATABLE(CATSCComponentType)

DECLARE_PROTECT_FINAL_CONSTRUCT()

public:
    bool m_bRequiresSave;
    typedef IATSCComponentTypeImpl<CATSCComponentType> basetype;
    BEGIN_PROP_MAP(CATSCComponentType)
        CHAIN_PROP_MAP(basetype)
    END_PROPERTY_MAP()

    BEGIN_COM_MAP(CATSCComponentType)
	    COM_INTERFACE_ENTRY(IATSCComponentType)
		COM_INTERFACE_ENTRY(IMPEG2ComponentType)
	    COM_INTERFACE_ENTRY(IComponentType)
        COM_INTERFACE_ENTRY(IObjectWithSite)
	    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    	COM_INTERFACE_ENTRY(IPersist)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CATSCComponentType)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()


};

typedef CComQIPtr<IATSCComponentType> PQATSCComponentType;

#endif //__ATSCCOMPONENTTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\bcastevent.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// bcastevent.cpp : Implementation of CBroadcastEventService
// Copyright (c) Microsoft Corporation 2001.

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "bcastevent.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_BroadcastEventService, CBroadcastEventService)

namespace BDATuningModel {

bool CReflectionThread::GetNextEvent(GUID& g) {
	CAutoLock lock(&m_WorkerLock);
    if (!m_FiringQ.size()) {
        return false;
    }
    g = m_FiringQ.front();
    m_FiringQ.pop();
    return true;
}

void CReflectionThread::GetAdviseList(AdviseList& l) {
	CAutoLock lock(&m_WorkerLock);
    AdviseList::iterator i;
    for (i = m_AdviseList.begin(); i != m_AdviseList.end(); ++i) {
        l.push_back(*i);
    }
    ASSERT(m_AdviseList.size() == l.size());
//    TRACELSM(TRACE_DEBUG, (dbgDump << "CReflectionThread::GetAdviseList() m_al = " << m_AdviseList.size() << " l = " << l.size()), "");
    return;
}

HRESULT CReflectionThread::Fire(PQGIT& pGIT) {
    GUID g;
    AdviseList l;
    GetAdviseList(l);
    while (GetNextEvent(g)) {
        for (AdviseList::iterator i = l.begin(); i != l.end(); ++i) {
            PQBroadcastEvent e;
            HRESULT hr = pGIT->GetInterfaceFromGlobal(*i, IID_IBroadcastEvent, reinterpret_cast<LPVOID*>(&e));
            if (SUCCEEDED(hr) && e) {
                e->Fire(g);
            }
        }
    }
    
	return NOERROR;
}

HRESULT CReflectionThread::Advise(PUnknown& p, DWORD *pdwCookie) {
    if (!m_pGIT) {
        HRESULT hr = m_pGIT.CoCreateInstance(CLSID_StdGlobalInterfaceTable, 0, CLSCTX_INPROC_SERVER);
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CReflectionThread::Advise() can't create GIT.  hr = " << hr), "");
			return hr;
		}
    }
    ASSERT(m_pGIT);
    HRESULT hr = m_pGIT->RegisterInterfaceInGlobal(p, IID_IBroadcastEvent, pdwCookie);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CReflectionThread::Advise() can't register interface. hr = " << hr), "");
		return hr;
	}
	CAutoLock lock(&m_WorkerLock);
    m_AdviseList.push_back(*pdwCookie);    

    return NOERROR;
}

HRESULT CReflectionThread::Unadvise(DWORD dwCookie) {
    if (!m_pGIT) {
        // if no GIT yet, then they can't have advised yet
        return E_INVALIDARG; 
    }
	CAutoLock lock(&m_WorkerLock);
    AdviseList::iterator i = std::find(m_AdviseList.begin(), m_AdviseList.end(), dwCookie);
    if (i == m_AdviseList.end()) {
        return E_INVALIDARG;
    }
    m_AdviseList.erase(i);
    ASSERT(m_pGIT);
    HRESULT hr = m_pGIT->RevokeInterfaceFromGlobal(dwCookie);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CReflectionThread::Advise() can't register interface. hr = " << hr), "");
		return hr;
	}

    return NOERROR;
}

}; // namespace

#endif //TUNING_MODEL_ONLY

// end of file - tuningspacecontainer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\bdatuner.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidBDATuner.cpp : Implementation of CMSVidBDATuner
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "MSVidCtl.h"
#include "BDATuner.h"


DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidBDATunerDevice, CMSVidBDATuner)

/////////////////////////////////////////////////////////////////////////////
// CMSVidBDATuner

STDMETHODIMP CMSVidBDATuner::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidTuner,
		&__uuidof(CMSVidBDATuner)
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CMSVidBDATuner::Unload(void) {
    BroadcastUnadvise();
    IMSVidGraphSegmentImpl<CMSVidBDATuner, MSVidSEG_SOURCE, &KSCATEGORY_BDA_RECEIVER_COMPONENT>::Unload();
    m_iNetworkProvider = -1;
    m_iTIF = -1;
	return NOERROR;
}

HRESULT CMSVidBDATuner::UpdateTR(TNTuneRequest &tr) {
	PQBDATuner pt(m_Filters[m_iNetworkProvider]);
	return pt->get_TuneRequest(&tr);
}

HRESULT CMSVidBDATuner::DoTune(TNTuneRequest &tr) {
	if (m_iNetworkProvider == -1) {
		return S_FALSE;
	}
	PQBDATuner pt(m_Filters[m_iNetworkProvider]);
	if (!pt) {
		return Error(IDS_INVALID_TR, __uuidof(CMSVidBDATuner), DISP_E_TYPEMISMATCH);
	}
	return pt->put_TuneRequest(tr);
}

HRESULT CMSVidBDATuner::put_Container(IMSVidGraphSegmentContainer *pCtl)	{
    if (!m_fInit) {
	 	return Error(IDS_OBJ_NO_INIT, __uuidof(CMSVidBDATuner), CO_E_NOTINITIALIZED);
    }
    try {
        if (!pCtl) {
            return Unload();
        }
        if (m_pContainer) {
			if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
				return Error(IDS_OBJ_ALREADY_INIT, __uuidof(CMSVidBDATuner), CO_E_ALREADYINITIALIZED);
			} else {
				return NO_ERROR;
			}
        }
        // DON'T addref the container.  we're guaranteed nested lifetimes
        // and an addref creates circular refcounts so we never unload.
        m_pContainer.p = pCtl;
        m_pGraph = m_pContainer.GetGraph();

        if (!m_pCurrentTR) {
            // if we don't have a tune request we can't tell what NP we need.
		 	return Error(IDS_NO_NP, __uuidof(CMSVidBDATuner), E_FAIL);
        }
		// bring in the right network provider
        if (!m_pSystemEnum) {
            m_pSystemEnum = PQCreateDevEnum(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
        }
        DSDevices pnpenum(m_pSystemEnum, KSCATEGORY_BDA_NETWORK_PROVIDER);
		if (!pnpenum) {
		    TRACELM(TRACE_ERROR, "CMSVidBDATuner::put_Container() can't create network provider category enumerator");
		 	return Error(IDS_NO_NP_CAT, __uuidof(CMSVidBDATuner), E_FAIL);
		}
        DSDevices::iterator i = pnpenum.begin();
        DSFilter np;
        for (;i != pnpenum.end(); ++i) {
			np = m_pGraph.AddMoniker(*i);
			if (!np) {
                continue;
			}
            PQTuner pt(np);
            if (pt) {
                HRESULT hr = pt->put_TuningSpace(m_pCurrentTR.TuningSpace());
                if (SUCCEEDED(hr)) {
                    hr = pt->put_TuneRequest(m_pCurrentTR);
                    if (SUCCEEDED(hr)) {
                        break;
                    }
                }
            }
            bool rc = m_pGraph.RemoveFilter(np);
            if (!rc) {
                return E_UNEXPECTED;
            }
        }
        if (i == pnpenum.end()) {
		    TRACELM(TRACE_ERROR, "CMSVidBDATuner::put_Container() can't load network provider");
		 	return Error(IDS_NO_NP, __uuidof(CMSVidBDATuner), E_FAIL);
        }
        _ASSERT(!!np);
		m_Filters.push_back(np);
		m_iNetworkProvider = m_Filters.size() - 1;
        TRACELM(TRACE_DETAIL, "CMSVidBDATuner::put_Container() attempting to load tuners from KSCATEGORY_BDA_NETWORK_TUNER");
        HRESULT hr = LoadTunerSection(np, KSCATEGORY_BDA_NETWORK_TUNER);
        if (FAILED(hr)) {
            TRACELM(TRACE_DETAIL, "CMSVidBDATuner::put_Container() attempting to load tuners from KSCATEGORY_BDA_RECEIVER_COMPONENT");
            hr = LoadTunerSection(np, KSCATEGORY_BDA_RECEIVER_COMPONENT);
            if (FAILED(hr)) {
                m_Filters.clear();
                m_iNetworkProvider = -1;
                return hr;
            }
        }
        hr = BroadcastAdvise();
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CMSVidTVTuner::put_Container() can't advise for broadcast events");
            return E_UNEXPECTED;
        }
		return NOERROR;
    } catch (ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
	return NOERROR;
}

HRESULT CMSVidBDATuner::LoadTunerSection(DSFilter& np, const GUID& kscategory) {
        TRACELM(TRACE_DETAIL, "CMSVidBDATuner::LoadTunerSection()");
        DSFilter tuner;
		DSFilterList added;
        DSDevices ptunerenum(m_pSystemEnum, kscategory);
        DSDevices::iterator i = ptunerenum.begin();
        for (; i != ptunerenum.end(); ++i) {
			tuner = m_pGraph.AddMoniker(*i);
			if (!tuner) {
				continue;
			}
			// connect np to decode
			HRESULT hr = m_pGraph.Connect(np, tuner, added);
            if (FAILED(hr)) {
                bool rc = m_pGraph.RemoveFilter(tuner);
                if (!rc) {
                    return E_UNEXPECTED;
                }
                continue;
            }
			m_Filters.insert(m_Filters.end(), added.begin(), added.end());
			added.clear();

			// bring in the all right tifs
			DSDevices ptife(m_pSystemEnum, KSCATEGORY_BDA_TRANSPORT_INFORMATION);
            DSDevices::iterator itif = ptife.begin();
            DSFilter tif;
            int cTIFsAdded = 0;
            for (;itif != ptife.end(); ++itif) {
			    tif = m_pGraph.AddMoniker(*itif);
			    if (!tif) {
                    continue;
			    }
			    // connect np to tif
			    hr = m_pGraph.Connect(np, tif, added);
			    if (FAILED(hr)) {
        		    TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidBDATuner::LoadTunerSection() can't connect network provider to transport information filter, trying next tif " << hr), "");
                    bool rc = m_pGraph.RemoveFilter(tif);
                    if (!rc) {
                        return E_UNEXPECTED;
                    }
                } else {
                    ++cTIFsAdded;
			        m_Filters.push_back(tif);
			        m_iTIF = m_Filters.size() - 1;
			        m_Filters.insert(m_Filters.end(), added.begin(), added.end());
			        added.clear();
                }
            }
            if (cTIFsAdded) {
                break;
            }
            // no tifs found for this "tuner", try the next one
            bool rc = m_pGraph.RemoveFilter(tuner);
            if (!rc) {
                return E_UNEXPECTED;
            }
        }
        if ( i == ptunerenum.end()) {
		    TRACELM(TRACE_ERROR, "CMSVidBDATuner::LoadTunerSection() can't connect network provider to any transport information filters.");
		 	return Error(IDS_CANT_CONNECT_NP_TIF, __uuidof(CMSVidBDATuner), E_FAIL);
        }

		m_Filters.push_back(tuner);
		m_iTuner = m_Filters.size() - 1;
        return NOERROR;
}

HRESULT CMSVidBDATuner::Fire(GUID gEventID) {
	TRACELM(TRACE_DETAIL, "CMSVidBDATuner::Fire()");
    if (gEventID == EVENTID_TuningChanged) {
        Fire_OnTuneChanged(this);
    }
    return NOERROR;
}



#endif //TUNING_MODEL_ONLY

// end of file - MSVidBDATuner.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\bcastevent.h ===
/////////////////////////////////////////////////////////////////////////////////////
// BroadcastEventService.h : Declaration of the CBroadcastEventService
// Copyright (c) Microsoft Corporation 2001.

#ifndef __BROADCASTEVENTSERVICE_H_
#define __BROADCASTEVENTSERVICE_H_

#pragma once

#include <queue>
#include "w32extend.h"
#include "regexthread.h"
#include <objectwithsiteimplsec.h>
#include "tuner.h"

namespace BDATuningModel {

typedef CComQIPtr<IBroadcastEvent> PQBroadcastEvent;
typedef std::list<DWORD> AdviseList;
typedef std::queue<GUID> EventQ;

class CReflectionThread : public CBaseThread {
public:
	typedef enum OP {
		RETHREAD_NOREQUEST,
		RETHREAD_FIRE,
		RETHREAD_EXIT,
	} OP;
	
private:	
	virtual DWORD ThreadProc(void) {
        PQGIT pGIT(CLSID_StdGlobalInterfaceTable, 0, CLSCTX_INPROC_SERVER);
        if (!pGIT) {
            TRACELM(TRACE_ERROR, "CReflectionThread::ThreadProc() can't create GIT");
			return 1;
		}
		for (;;) {
			OP req = GetRequest();
			switch (req) {
			case RETHREAD_FIRE: {
				Fire(pGIT);
				break;
			} case RETHREAD_EXIT:
				goto exit_thread;
			};
		};
exit_thread:
		return 0;
	}

	OP GetRequest() {
        HANDLE h[2];
        h[0] = m_EventSend;
        h[1] = m_EventTerminate;
		for (;;) {
			DWORD rc = MsgWaitForMultipleObjectsEx(2, h, INFINITE, QS_ALLEVENTS, 0);
			if (rc == WAIT_OBJECT_0) {
				m_EventSend.Reset();
				return RETHREAD_FIRE;
			} else if (rc == WAIT_OBJECT_0 + 1) {
                return RETHREAD_EXIT;
			} else {
				// pump messages so com runs
				MSG msg;
				while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}
			}

		}
	}

	HRESULT Fire(PQGIT& pGIT);
    bool GetNextEvent(GUID& g);
    void GetAdviseList(AdviseList& l);

	PQGIT m_pGIT;
	DWORD m_dwCookie;
    EventQ m_FiringQ;
    CAMEvent m_EventTerminate;
    AdviseList m_AdviseList;

public:
	CReflectionThread() : 
		CBaseThread(COINIT_APARTMENTTHREADED),
	    m_dwCookie(0)
			{}
	~CReflectionThread() {
		m_EventTerminate.Set();
		Close();
	}

    HRESULT PostFire(GUID& g) {
		CAutoLock lock(&m_WorkerLock);
        m_FiringQ.push(g);
        // signal the worker thread
        m_EventSend.Set();

        return NOERROR;
    }
    HRESULT Advise(PUnknown& p, DWORD* pdwCookie);
    HRESULT Unadvise(DWORD dwCookie);
};  // class CReflectionThread


/////////////////////////////////////////////////////////////////////////////
// CBroadcastEventService
class ATL_NO_VTABLE CBroadcastEventService : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CBroadcastEventService, &CLSID_BroadcastEventService>,
    public IObjectWithSiteImplSec<CBroadcastEventService>,
	public IBroadcastEvent, 
    public IConnectionPoint {

public:
    CBroadcastEventService() {
        m_pRT = new CReflectionThread;
		if (!m_pRT->Create()) {
			THROWCOM(E_UNEXPECTED);
		}
	}
    virtual ~CBroadcastEventService() {
		if (m_pRT) {
			delete m_pRT;
			m_pRT = NULL;
		}
	}

REGISTER_NONAUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
					                  IDS_REG_TUNINGSPACECONTAINER_DESC,
						              LIBID_TunerLib,
						              CLSID_BroadcastEventService, tvBoth);

DECLARE_NOT_AGGREGATABLE(CBroadcastEventService)

BEGIN_COM_MAP(CBroadcastEventService)
	COM_INTERFACE_ENTRY(IBroadcastEvent)
	COM_INTERFACE_ENTRY(IConnectionPoint)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

public:
// IConnectionPointContainer

// IBroadcastEventService
    STDMETHOD(Fire)(/*[in]*/ GUID EventID) {
        try {
            return m_pRT->PostFire(EventID);
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(Advise)(LPUNKNOWN pUnk, LPDWORD pdwCookie) {
        if (!pUnk || !pdwCookie) {
            return E_POINTER;
        }
        try {
            return m_pRT->Advise(PUnknown(pUnk), pdwCookie);
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(Unadvise)(DWORD dwCookie) {
        try {
            return m_pRT->Unadvise(dwCookie);
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(EnumConnections)(IEnumConnections **ppEnum) {
        return E_NOTIMPL;
    }

    STDMETHOD(GetConnectionInterface)(IID* pIID) {
        if (!pIID) {
            return E_POINTER;
        }
        try {
            memcpy(pIID, &IID_IBroadcastEvent, sizeof(*pIID));
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer** pContainer) {
        return E_NOTIMPL;
    }

protected:
	CReflectionThread *m_pRT; // <non-shared> worker thread
};

    

};


 
#endif //__BROADCASTEVENTSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\bdatuner.h ===
//==========================================================================;
// MSVidBDATuner.h : Declaration of the CMSVidBDATuner
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __MSVidBDATUNER_H_
#define __MSVidBDATUNER_H_

#include <algorithm>
#include <tchar.h>
#include <bdamedia.h>
#include <objectwithsiteimplsec.h>
#include "bcasteventimpl.h"
#include "segimpl.h"
#include "tunerimpl.h"

#include "seg.h"

typedef CComQIPtr<ITuner> PQTuner;

/////////////////////////////////////////////////////////////////////////////
// CMSVidBDATuner
class ATL_NO_VTABLE __declspec(uuid("A2E3074E-6C3D-11d3-B653-00C04F79498E")) CMSVidBDATuner : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidBDATuner, &__uuidof(CMSVidBDATuner)>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CMSVidBDATuner>,
    public CProxy_Tuner<CMSVidBDATuner>,
    public IBroadcastEventImpl<CMSVidBDATuner>,
    public IObjectWithSiteImplSec<CMSVidBDATuner>,
	public IMSVidGraphSegmentImpl<CMSVidBDATuner, MSVidSEG_SOURCE, &KSCATEGORY_BDA_RECEIVER_COMPONENT>,
    public IMSVidTunerImpl<CMSVidBDATuner, &LIBID_MSVidCtlLib, &KSCATEGORY_BDA_RECEIVER_COMPONENT, IMSVidTuner>,
    public IProvideClassInfo2Impl<&CLSID_MSVidBDATunerDevice, &IID_IMSVidTunerEvent, &LIBID_MSVidCtlLib>
{
public:
    CMSVidBDATuner() : m_iNetworkProvider(-1), m_iTuner(-1), m_iTIF(-1)  {
	}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_BDATUNER_PROGID, 
						   IDS_REG_BDATUNER_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidBDATuner));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidBDATuner)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidTuner)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMSVidDevice)
	COM_INTERFACE_ENTRY(IMSVidInputDevice)
	COM_INTERFACE_ENTRY(IMSVidVideoInputDevice)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IBroadcastEvent)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CMSVidBDATuner)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSVidBDATuner)
	CONNECTION_POINT_ENTRY(IID_IMSVidTunerEvent)    
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    PQCreateDevEnum m_pSystemEnum;
    int m_iNetworkProvider;
    int m_iTuner;
    int m_iTIF;

	virtual HRESULT DoTune(TNTuneRequest &ctr);
	virtual HRESULT UpdateTR(TNTuneRequest& pTR);

    HRESULT Unload(void);

    HRESULT LoadTunerSection(DSFilter& np, const GUID& kscategory);

// IMSVidGraphSegment
	STDMETHOD(put_Init)(IUnknown *pDeviceMoniker)
	{
        if (!pDeviceMoniker) {
            return E_POINTER;
        }

        HRESULT hr = IMSVidGraphSegmentImpl<CMSVidBDATuner, MSVidSEG_SOURCE, &KSCATEGORY_BDA_RECEIVER_COMPONENT>::put_Init(pDeviceMoniker);
        if (FAILED(hr)) {
            return hr;
        }
        if (!m_pDev) {
            m_fInit = false;
            return E_NOINTERFACE;
        }
		return NOERROR;
	}
    STDMETHOD(Build)() {
        // undone: should we tune here?
        return NOERROR;
    }

    STDMETHOD(PreRun)() {
		if (m_pCurrentTR) {
			return DoTune(m_pCurrentTR);
		}
		// undone: do any np initialization.

        return NOERROR;
    }

	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl);

    // IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(CMSVidBDATuner), CO_E_NOTINITIALIZED);
        }
        try {
            return GetName(((m_iNetworkProvider > -1) ? (m_Filters[m_iNetworkProvider]) : DSFilter()), m_pDev, CComBSTR(_T("BDA NetworkProvider"))).CopyTo(Name);
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
	}
    // IBroadcastEvent
    STDMETHOD(Fire)(GUID gEventID);
};
#endif //__MSVidBDATUNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\channeltunerequest.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// ChannelTuneRequest.cpp : Implementation of CChannelTuneRequest
// Copyright (c) Microsoft Corporation 1999.

#include "stdafx.h"
#include "Tuner.h"
#include "ChannelTuneRequest.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ChannelTuneRequest, CChannelTuneRequest)

/////////////////////////////////////////////////////////////////////////////
// CChannelTuneRequest

STDMETHODIMP CChannelTuneRequest::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IChannelTuneRequest
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\channeltunerequest.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ChannelTuneRequest.h : Declaration of the CChannelTuneRequest
// Copyright (c) Microsoft Corporation 1999.

#ifndef __CHANNELTUNEREQUEST_H_
#define __CHANNELTUNEREQUEST_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "channeltunerequestimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CChannelTuneRequest
class ATL_NO_VTABLE CChannelTuneRequest : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IChannelTuneRequestImpl<CChannelTuneRequest>,
    public IObjectWithSiteImplSec<CChannelTuneRequest>,
	public CComCoClass<CChannelTuneRequest, &CLSID_ChannelTuneRequest>,
	public ISupportErrorInfo
{
public:

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_CHANNELTUNEREQUEST_PROGID, 
						   IDS_REG_CHANNELTUNEREQUEST_DESC,
						   LIBID_TunerLib,
						   CLSID_ChannelTuneRequest, tvBoth);

BEGIN_COM_MAP(CChannelTuneRequest)
	COM_INTERFACE_ENTRY(IChannelTuneRequest)
	COM_INTERFACE_ENTRY(ITuneRequest)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CChannelTuneRequest)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    typedef IChannelTuneRequestImpl<CChannelTuneRequest> basetype;
    BEGIN_PROP_MAP(CChannelTuneRequest)
        CHAIN_PROP_MAP(basetype)
    END_PROP_MAP()


};

#endif //__CHANNELTUNEREQUEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\closedcaptioning.h ===
//==========================================================================;
// MSVidClosedCaptioning.h : Declaration of the CMSVidClosedCaptioning
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __MSVidClosedCaptioning_H_
#define __MSVidClosedCaptioning_H_

#include <algorithm>
#include <tchar.h>
#include "segimpl.h"
#include "CC2impl.h"
#include <objectwithsiteimplsec.h>

#include "seg.h"

typedef CComQIPtr<ITuner> PQMSVidClosedCaptioning;

/////////////////////////////////////////////////////////////////////////////
// CMSVidClosedCaptioning
class ATL_NO_VTABLE __declspec(uuid("7F9CB14D-48E4-43b6-9346-1AEBC39C64D3")) CClosedCaptioning : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CClosedCaptioning, &__uuidof(CClosedCaptioning)>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CClosedCaptioning>,
    public IObjectWithSiteImplSec<CClosedCaptioning>,
	public IMSVidGraphSegmentImpl<CClosedCaptioning, MSVidSEG_XFORM, &GUID_NULL>,
    public IMSVidClosedCaptioningImpl2<CClosedCaptioning, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidClosedCaptioning2>
{
public:

	typedef IMSVidClosedCaptioningImpl2<CClosedCaptioning, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidClosedCaptioning2> ccimplbase;
    CClosedCaptioning() : m_iL21(-1) {
	}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_CLOSEDCAPTIONING_PROGID, 
						   IDS_REG_CLOSEDCAPTIONING_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CClosedCaptioning));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CClosedCaptioning)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidClosedCaptioning)
    COM_INTERFACE_ENTRY(IMSVidClosedCaptioning2)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMSVidFeature)
	COM_INTERFACE_ENTRY(IMSVidDevice)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CClosedCaptioning)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CClosedCaptioning)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    int m_iL21;

    HRESULT Unload(void) {
        IMSVidGraphSegmentImpl<CClosedCaptioning, MSVidSEG_XFORM, &GUID_NULL>::Unload();
        m_iL21 = -1;
		return NOERROR;
	}

	HRESULT SetFilterState() {
		if (m_iL21 < 0) {
			return NOERROR;
		} 
		PQLine21Decoder pl21(m_Filters[m_iL21]);
		if (!pl21) {
			return NOERROR;
		}

        return pl21->SetServiceState(m_fCCEnable ? AM_L21_CCSTATE_On : AM_L21_CCSTATE_Off);
	}
// IMSVidGraphSegment
    STDMETHOD(Build)() {
        return NOERROR;
    }

    STDMETHOD(PreRun)() {
        return NOERROR;
    }

    STDMETHOD(Decompose)(){
        // The Line21 Decoder was not being disconnected from the vmr
        // This code disconnects all of the filters in this segment
	if(m_pGraph){
		for (DSFilterList::iterator i = m_Filters.begin(); i != m_Filters.end(); ++i) {
        		m_pGraph.DisconnectFilter(*i, false, false);
    		}
	}
	return S_OK;
    }

    STDMETHOD(PostRun)() {
        return SetFilterState();
    }

	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl)
	{
        if (!m_fInit) {
            return CO_E_NOTINITIALIZED;
        }
        try {
            if (!pCtl) {
                return Unload();
            }
            if (m_pContainer) {
				if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
					return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidClosedCaptioning2), CO_E_ALREADYINITIALIZED);
				} else {
					return NO_ERROR;
				}
            }
            // DON'T addref the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            m_pContainer.p = pCtl;
            m_pGraph = m_pContainer.GetGraph();

			// bring in the right network provider
			PQLine21Decoder l21(CLSID_Line21Decoder2, NULL, CLSCTX_INPROC_SERVER);
			if (!l21) {
		        TRACELM(TRACE_ERROR, "CMSVidClosedCaptioning::put_Container() can't load line 21 decoder");
				return E_FAIL;
			}
			DSFilter f(l21);
			if (!f) {
				return E_UNEXPECTED;
			}
			CString csName(_T("Line 21 Decoder"));
			HRESULT hr = m_pGraph.AddFilter(f, csName);
			if (FAILED(hr)) {
				return hr;
			}
			m_Filters.push_back(f);
			m_iL21 = m_Filters.size() - 1;
			return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}

    STDMETHOD(put_Enable)(VARIANT_BOOL fEnable) {
        HRESULT hr = ccimplbase::put_Enable(fEnable);
		if (FAILED(hr)) {
			return hr;
		}
		return SetFilterState();
    }

    // IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name)
	{
        if (!m_fInit) {
            return CO_E_NOTINITIALIZED;
        }
        try {
            return GetName(((m_iL21 > -1) ? (m_Filters[m_iL21]) : DSFilter()), m_pDev, CComBSTR(_T("Line 21 Decoder"))).CopyTo(Name);
        } catch(...) {
            return E_POINTER;
        }
	}
    STDMETHOD(put_Service)(MSVidCCService ccServ) {
		if (m_iL21 < 0) {
			return Error(IDS_INVALID_STATE, __uuidof(IMSVidClosedCaptioning2), CO_E_NOTINITIALIZED);
		}
        
		PQLine21Decoder pl21(m_Filters[m_iL21]);
		if (!pl21) {
			return E_UNEXPECTED;
		}

        AM_LINE21_CCSERVICE amServ = static_cast<AM_LINE21_CCSERVICE>(ccServ);
        HRESULT hr = pl21->SetCurrentService(amServ);
        if(FAILED(hr)){
            return hr;
        }
        
        return S_OK;
    }

    STDMETHOD(get_Service)(MSVidCCService *ccServ) {
        if (!ccServ) {
            return E_POINTER;
        }

		PQLine21Decoder pl21(m_Filters[m_iL21]);
		if (!pl21) {
			return E_UNEXPECTED;
		}

        AM_LINE21_CCSERVICE amServ;
        HRESULT hr = pl21->GetCurrentService(&amServ);
        if(FAILED(hr)){
            return hr;
        }
        *ccServ = static_cast<MSVidCCService>(amServ);
        
        return S_OK;
    }


};

STDMETHODIMP CClosedCaptioning::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidClosedCaptioning2
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

#endif //__MSVidClosedCaptioning_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\cmseventbinder.cpp ===
// CMSEventBinder.cpp : Implementation of CMSEventBinder
#include "stdafx.h"
#include "MSVidCtl.h"
#include "CMSEventBinder.h"
#include <dispex.h>

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSEventBinder, CMSEventBinder)

/////////////////////////////////////////////////////////////////////////////
// CMSEventBinder

/**********************************************************************
// Function: CMSEventBinder                           
/**********************************************************************/
STDMETHODIMP CMSEventBinder::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSEventBinder,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
/**********************************************************************/
// Function: CleanupConnection
// Description: Unadvises if necessary
/**********************************************************************/
HRESULT CMSEventBinder::CleanupConnection()
{
    HRESULT hr = E_FAIL;
    try{
        // While the map is not empty
        while(!m_CancelMap.empty()){
            // See if it is bound to an event or an empty map
            CMSEventHandler* p(static_cast<CMSEventHandler *>((*m_CancelMap.begin()).second.p));
            // If it is not an empty map cancel the eventbinding
            if (p) {
                p->Cancel((*m_CancelMap.begin()).first);
            }
            // Delete the mapping
            m_CancelMap.erase(m_CancelMap.begin());
        }
        hr = S_OK;
    }
    catch(...){
        return Error(IDS_CANT_RELEASE_MAP, __uuidof(IMSEventBinder), E_FAIL);
    }

    return hr;
}/* end of function CleanupConnection */
/**********************************************************************/
// Function: Unbind
// Description: Unbinds an event on an object
/**********************************************************************/
STDMETHODIMP CMSEventBinder::Unbind(DWORD CancelCookie){
    HRESULT hr = E_FAIL;
    try{
        CMSEventHandler* p_Event(static_cast<CMSEventHandler *>((m_CancelMap[CancelCookie]).p));
        if(!p_Event){
            return Error(IDS_CANT_UNBIND, __uuidof(IMSEventBinder), E_FAIL);
        }
        hr = p_Event->Cancel(CancelCookie);
        if(SUCCEEDED(hr)){
            if(!m_CancelMap.erase(CancelCookie)){
                return Error(IDS_CANT_UNBIND, __uuidof(IMSEventBinder), E_FAIL);
            }   
        }
    }catch(...){
        return Error(IDS_CANT_UNBIND, __uuidof(IMSEventBinder), E_FAIL);
    }
    return hr;
}
/**********************************************************************/
// Function: Bind
// Description: Binds a function to an event on an object
/**********************************************************************/
STDMETHODIMP CMSEventBinder::Bind(LPDISPATCH inPEventObject, BSTR EventName, BSTR EventHandler, LONG *CancelID)
{
    try{
        HRESULT hr = E_FAIL;

        // query eventobject to see if its the dhtml object wrapper rather than the real object
        // if so, get its "object" property automatically here to save foolish script programmers from hard to find errors.
        CComQIPtr<IDispatch> pEventObject(inPEventObject);
        CComQIPtr<IHTMLObjectElement> IHOEle(inPEventObject);
        if(IHOEle){
            pEventObject.Release();
            hr = IHOEle->get_object(&pEventObject);
            if(FAILED(hr)){
                return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
            }
        }
        
        // Get client site
        CComQIPtr<IOleClientSite> pSite(m_pSite);
        if (!pSite) {
            return Error(IDS_EVENT_HTM_SITE, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get container
        CComQIPtr<IOleContainer> pContainer;
        hr = pSite->GetContainer(&pContainer);
        if(FAILED(hr)){
            return Error(IDS_EVENT_HTM_SITE, __uuidof(IMSEventBinder), E_FAIL);
        }

        // Get the IHTMLDocumet2 for the container/site
        CComQIPtr<IHTMLDocument2> IHDoc(pContainer);
        if (!IHDoc) {
            return Error(IDS_EVENT_HTM_SITE, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get the script which is some object that is not the script engine
        CComQIPtr<IDispatch> IDispSite;
        hr = IHDoc->get_Script(&IDispSite);
        if(FAILED(hr)){
            return Error(IDS_EVENT_HTM_SITE, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get the function that will be the event handler
        DISPID dispidScriptHandler = -1;
        hr = IDispSite->GetIDsOfNames(IID_NULL, &EventHandler, 1, LOCALE_SYSTEM_DEFAULT, &dispidScriptHandler);
        if(FAILED(hr)){
            return Error(IDS_EVENT_HTM_SITE, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get info about the object/interface on which the event exsists
        CComQIPtr<IProvideClassInfo2> IPCInfo(pEventObject);
        if(!IPCInfo){
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get the guid of the object/interface
        GUID gEventObject;
        hr = IPCInfo->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, &gEventObject);
        if(FAILED(hr)){
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get type info about the interface/object
        CComQIPtr<ITypeInfo> ITInfo;
        hr = IPCInfo->GetClassInfo(&ITInfo);
        if(FAILED(hr)){
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get the Type lib
        CComQIPtr<ITypeLib> ITLib(ITInfo);
        unsigned int uNit;
        hr = ITInfo->GetContainingTypeLib(&ITLib, &uNit);
        if(FAILED(hr)){
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        ITInfo.Release();
        
        // Get info about the object/interface's base class
        hr = ITLib->GetTypeInfoOfGuid(gEventObject, &ITInfo);
        if(FAILED(hr)){
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get the ID of the event
        MEMBERID dispidEvent = 0;
        hr = ITInfo->GetIDsOfNames(&EventName, 1, &dispidEvent);
        if(FAILED(hr)){
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }

        //Create and store the event Handler 
        CMSEventHandler* pH;
        pH = new CMSEventHandler(dispidScriptHandler, dispidEvent, gEventObject, IDispSite);
        if(!pH){
            return Error(IDS_CANT_GET_EVENTHANDLER, __uuidof(IMSEventBinder), E_FAIL);
        }

        // Get Connection Point Container
        CComQIPtr<IConnectionPointContainer> ICPCon(pEventObject);
        if(!ICPCon){
            delete pH;
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }

        // Find the connection point
        CComQIPtr<IConnectionPoint> ICPo;
        hr = ICPCon->FindConnectionPoint(gEventObject, &ICPo);
        if(FAILED(hr)){
            delete pH;
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }

        // Set the event
        DWORD tempCookie;
        PQDispatch pdisp(pH);  // we have now addref'd and assoc'd ph with a smart pointer, no more deletes necessary
        hr = ICPo->Advise(pdisp, &tempCookie);
        pH->setCookie(tempCookie);
        if(FAILED(hr)){
            return Error(IDS_CANT_SET_ADVISE, __uuidof(IMSEventBinder), E_FAIL);
        }

        // Store all of the needed info
        pH->cancelPoint = ICPo;
        *CancelID = pH->getCookie();
        m_CancelMap[pH->getCookie()] = pH;
    }
    catch(HRESULT){
        return Error(IDS_CANT_SET_ADVISE, __uuidof(IMSEventBinder), E_FAIL);
    }
    catch(...){
        return Error(IDS_CANT_SET_ADVISE, __uuidof(IMSEventBinder), E_UNEXPECTED);
    }
    // call used to leave a funtion and "return" the value that is the paramater to the calling function
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\componenttype.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ComponentType.h : Declaration of the CComponentType
// Copyright (c) Microsoft Corporation 1999.

#ifndef __COMPONENTTYPE_H_
#define __COMPONENTTYPE_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "componenttypeimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CComponentType
class ATL_NO_VTABLE __declspec(uuid("823535A0-0318-11d3-9D8E-00C04F72D980")) CComponentType : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CComponentType, &CLSID_ComponentType>,
    public IObjectWithSiteImplSec<CComponentType>,
    public IComponentTypeImpl<CComponentType>
{
public:
    CComponentType() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_COMPONENTTYPE_PROGID, 
						   IDS_REG_COMPONENTTYPE_DESC,
						   LIBID_TunerLib,
						   CLSID_ComponentType, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CComponentType)
	COM_INTERFACE_ENTRY(IComponentType)	
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CComponentType)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

bool m_bRequiresSave;
BEGIN_PROP_MAP(CComponentType)
    CHAIN_PROP_MAP(IComponentTypeImpl<CComponentType>)
END_PROPERTY_MAP()


};

typedef CComQIPtr<IComponentType> PQComponentType;

#endif //__COMPONENTTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\component.h ===
/////////////////////////////////////////////////////////////////////////////////////
// Component.h : Declaration of the CComponent
// Copyright (c) Microsoft Corporation 1999.

#ifndef __COMPONENT_H_
#define __COMPONENT_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "componentimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CComponent
class ATL_NO_VTABLE CComponent : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CComponent, &CLSID_Component>,
    public IObjectWithSiteImplSec<CComponent>,
	public IComponentImpl<CComponent>
{
public:
    CComponent() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_COMPONENT_PROGID, 
						   IDS_REG_COMPONENT_DESC,
						   LIBID_TunerLib,
						   CLSID_Component, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CComponent)
	COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CComponent)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()


public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CComponent)
        CHAIN_PROP_MAP(IComponentImpl<CComponent>)
    END_PROPERTY_MAP()


};

typedef CComQIPtr<IComponent> PQComponent;

#endif //__COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\components.h ===
/////////////////////////////////////////////////////////////////////////////////////
// Components.h : Declaration of the CComponents
// Copyright (c) Microsoft Corporation 1999.

#ifndef __COMPONENTS_H_
#define __COMPONENTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "component.h"

typedef std::vector<PQComponent, stl_smart_ptr_allocator<PQComponent> > ComponentList;

/////////////////////////////////////////////////////////////////////////////
// CComponent
class ATL_NO_VTABLE CComponents : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public IObjectWithSiteImplSec<CComponents>,
	public IDispatchImpl<IComponents, &IID_IComponents, &LIBID_TunerLib>
{
public:
	CComponents()
	{
	}

DECLARE_NOT_AGGREGATABLE(CComponents)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CComponents)
	COM_INTERFACE_ENTRY(IComponents)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()
public:
    ComponentList m_Components;

// IComponents
public:
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IEnumVARIANT* *pVal);
	STDMETHOD(EnumComponents)(/*[out, retval]*/ IEnumComponents** pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT varIndex, /*[out, retval]*/ IComponent **ppComponent);
    STDMETHOD(Add)(/*[in]*/ IComponent *pComponent, VARIANT *pNewIndex);
    STDMETHOD(Remove)(VARIANT varIndex);
    STDMETHOD(Clone)(IComponents **ppNewList);
};

typedef CComQIPtr<IComponents> PQComponents;

class CopyComponentToVARIANT {
public:
    static HRESULT copy(VARIANT *pv, IComponent** p) {
        VariantClear(pv);
        pv->vt = VT_UNKNOWN;
        pv->punkVal = *p;
        pv->punkVal->AddRef();
        return NOERROR;
    }
    static void init(VARIANT *v) { VariantInit(v); }
    static void destroy(VARIANT *v) { VariantClear(v); }
};

typedef CComObject<CComEnumOnSTL<IEnumVARIANT, &__uuidof(IEnumVARIANT), 
                                 VARIANT, 
                                 CopyComponentToVARIANT, 
                                 ComponentList, 
								 CComMultiThreadModel> > ComponentEnumerator_t;

typedef CComObject<CComEnumOnSTL<IEnumComponents, &__uuidof(IEnumComponents), 
                                 IComponent *, 
                                 _CopyInterface<IComponent>, 
                                 ComponentList, 
								 CComMultiThreadModel> > ComponentBaseEnumerator_t;


#endif //__COMPONENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\components.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// Components.cpp : Implementation of CComponents
// Copyright (c) Microsoft Corporation 1999.

#include "stdafx.h"
#include <Tuner.h>
#include "Components.h"
#include "MPEG2Component.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_Component, CComponent)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MPEG2Component, CMPEG2Component)

/////////////////////////////////////////////////////////////////////////////
// CComponents


STDMETHODIMP CComponents::get_Count(long *pVal)
{
    try {
        if (!pVal) {
            return E_POINTER;
        }
		ATL_LOCK();
	    *pVal = m_Components.size();
    } catch (...) {
        return E_POINTER;
    }

	return NOERROR;
}

STDMETHODIMP CComponents::get__NewEnum(IEnumVARIANT **ppVal)
{
    try {
        if (ppVal == NULL)
	        return E_POINTER;

        ComponentEnumerator_t* p;

        *ppVal = NULL;

        HRESULT hr = ComponentEnumerator_t::CreateInstance(&p);
        if (FAILED(hr) || !p) {
            return E_OUTOFMEMORY;
        }
		ATL_LOCK();
	    hr = p->Init(GetUnknown(), m_Components);
        if (FAILED(hr)) {
            delete p;
            return hr;
        }
		hr = p->QueryInterface(__uuidof(IEnumVARIANT), (void**)ppVal);
        if (FAILED(hr)) {
            delete p;
            return hr;
        }
        return NOERROR;
    } catch(...) {
        return E_POINTER;
    }
}

STDMETHODIMP CComponents::EnumComponents(IEnumComponents** pVal)
{
    ComponentBaseEnumerator_t *pe = NULL;
    ComponentBaseEnumerator_t::CreateInstance(&pe);
    pe->Init(static_cast<IComponents*>(this), m_Components);
    HRESULT hr = pe->QueryInterface(pVal);
    if (FAILED(hr)) {
        delete pe;
    }
	return hr;
}

STDMETHODIMP CComponents::get_Item(VARIANT varIndex, IComponent **ppComponent)
{
    try {
        if (!ppComponent) {
            return E_POINTER;
        }

	    int idx;
	    CComVariant vidx;
		if (FAILED(vidx.ChangeType(VT_I4, &varIndex))) {
            return E_INVALIDARG;
        }
		idx = vidx.lVal;
		if (idx >= m_Components.size()) {
			return E_INVALIDARG;
		}
	    *ppComponent = *(m_Components.begin() + idx);
        (*ppComponent)->AddRef();
    } catch (...) {
        return E_POINTER;
    }

	return NOERROR;
}

STDMETHODIMP CComponents::Add(IComponent *pComponent, VARIANT *pNewIndex)
{
    try {
        if (!pComponent) {
            return E_POINTER;
        }
        PQComponent p(pComponent);
        m_Components.push_back(p);
        if (pNewIndex) {
            VariantClear(pNewIndex);
            pNewIndex->vt = VT_UI4;
            pNewIndex->ulVal = m_Components.end() - m_Components.begin() - 1;
        }
    } catch (...) {
        return E_POINTER;
    }

	return NOERROR;
}

STDMETHODIMP CComponents::Remove(VARIANT varIndex)
{
    try {
	    int idx;
	    CComVariant vidx;
		if (FAILED(vidx.ChangeType(VT_I4, &varIndex))) {
            return E_INVALIDARG;
        }
		idx = vidx.lVal;
		if (idx >= m_Components.size()) {
			return E_INVALIDARG;
		}
	    m_Components.erase(m_Components.begin() + idx);
    } catch (...) {
        return E_UNEXPECTED;
    }

	return NOERROR;
}

STDMETHODIMP CComponents::Clone(IComponents **ppNewList)
{
    try {
		if (!ppNewList) {
			return E_POINTER;
		}
		CComponents* pCs = new CComObject<CComponents>;
		if (!pCs) {
			return E_OUTOFMEMORY;
		}
		ComponentList::iterator i;
		for (i = m_Components.begin(); i != m_Components.end(); ++i) {
			PQComponent p;
			HRESULT hr = (*i)->Clone(&p);
			if (FAILED(hr)) {
                pCs->Release();
				return hr;
			}
			pCs->m_Components.push_back(p);			
		}
		pCs->AddRef();
		*ppNewList = pCs;
		return NOERROR;
    } catch (...) {
        return E_UNEXPECTED;
    }

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\componenttypes.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ComponentTypes.h : Declaration of the CComponentTypes
// Copyright (c) Microsoft Corporation 1999.

#ifndef __COMPONENTTYPES_H_
#define __COMPONENTTYPES_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "componenttype.h"

typedef std::vector<PQComponentType, stl_smart_ptr_allocator<PQComponentType> > ComponentTypeList;
typedef CComQIPtr<IPersist> PQPersist;
/////////////////////////////////////////////////////////////////////////////
// CComponentTypes
class ATL_NO_VTABLE CComponentTypes : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CComponentTypes, &CLSID_ComponentTypes>,
    public IObjectWithSiteImplSec<CComponentTypes>,
	public IDispatchImpl<IComponentTypes, &IID_IComponentTypes, &LIBID_TunerLib>,
    public IPersistPropertyBag2
{
public:
	CComponentTypes()
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_COMPONENTTYPES_PROGID, 
						   IDS_REG_COMPONENTTYPES_DESC,
						   LIBID_TunerLib,
						   CLSID_ComponentTypes, tvBoth);

DECLARE_NOT_AGGREGATABLE(CComponentTypes)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CComponentTypes)
	COM_INTERFACE_ENTRY(IComponentTypes)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CComponentTypes)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pclsid) {
        try {
            if (!pclsid) {
                return E_POINTER;
            }
            *pclsid = CLSID_ComponentTypes;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
// IPersistPropertyBag
public:
    bool m_bRequiresSave;

    STDMETHOD(InitNew)() {
        try {
			ATL_LOCK();
            m_ComponentTypes.clear();
            return NOERROR;
        } catch (...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(IsDirty)() {
        return m_bRequiresSave ? S_OK : S_FALSE;
    }
    STDMETHOD(Load)(IPropertyBag2 *pBag2, IErrorLog *pErrLog);
    STDMETHOD(Save)(IPropertyBag2 *pBag2, BOOL fClearDirty, BOOL fSaveAllProperties);

// IComponentTypes
public:
    ComponentTypeList m_ComponentTypes;

	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IEnumVARIANT** pVal);
	STDMETHOD(EnumComponentTypes)(/*[out, retval]*/ IEnumComponentTypes** pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT varIndex, /*[out, retval]*/ IComponentType** ppComponentType);
    STDMETHOD(put_Item)(/*[in]*/ VARIANT varIndex, /*[in]*/ IComponentType* ppComponentType);
    STDMETHOD(Add)(/*[in]*/ IComponentType *pComponentType, /*[out, retval]*/ VARIANT *pNewIndex);
    STDMETHOD(Remove)(VARIANT varIndex);
    STDMETHOD(Clone)(IComponentTypes **ppNewList);

};

typedef CComQIPtr<IComponentTypes> PQComponentTypes;

class CopyComponentTypeToVARIANT {
public:
    static HRESULT copy(VARIANT *pv, IComponentType*const*const p) {
        VariantClear(pv);
        pv->vt = VT_DISPATCH;
        pv->pdispVal = *p;
        pv->pdispVal->AddRef();
        return NOERROR;
    }
    static void init(VARIANT *v) { VariantInit(v); }
    static void destroy(VARIANT *v) { VariantClear(v); }
};

typedef CComObject<CComEnumOnSTL<IEnumVARIANT, &__uuidof(IEnumVARIANT), 
                                 VARIANT, 
                                 CopyComponentTypeToVARIANT, 
                                 ComponentTypeList, 
								 CComMultiThreadModel> > ComponentTypeScriptEnumerator_t;

typedef CComObject<CComEnumOnSTL<IEnumComponentTypes, &__uuidof(IEnumComponentTypes), 
                                 IComponentType *, 
                                 _CopyInterface<IComponentType>, 
                                 ComponentTypeList, 
								 CComMultiThreadModel> > ComponentTypeBaseEnumerator_t;



#endif //__COMPONENTTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\composition.cpp ===
// Composition.cpp : Implementation of CComposition
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1998-2000.
//
//--------------------------------------------------------------------------;
//
// Devices.cpp : Implementation of CDevices
//


#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY
#include "MSVidCtl.h"
#include "Composition.h"
#include "anacap.h"
#include "anadata.h"
#include "anasin.h"
#include "WebDVDComp.h"
#include "WebDVDARComp.h"
#include "mp2cc.h"
#include "mp2sin.h"
#include "fp2vr.h"
#include "fp2ar.h"
#include "dat2xds.h"
#include "dat2sin.h"
#include "enc2sin.h"
#include "encdec.h"
#include "ana2xds.h"
#include "ana2enc.h"
#include "sbes2cc.h"
#include "sbes2vmr.h"


DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidGenericComposite, CComposition)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAnalogCaptureToOverlayMixer, CAnaCapComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAnalogCaptureToDataServices, CAnaDataComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidWebDVDToVideoRenderer, CWebDVDComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidMPEG2DecoderToClosedCaptioning, CMP2CCComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAnalogCaptureToStreamBufferSink, CAnaSinComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidDigitalCaptureToStreamBufferSink, CMP2SinComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidFilePlaybackToVideoRenderer, CFP2VRComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidFilePlaybackToAudioRenderer, CFP2ARComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidWebDVDToAudioRenderer, CWebDVDARComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidDataServicesToXDS, CDat2XDSComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidDataServicesToStreamBufferSink, CDat2SinComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidEncoderToStreamBufferSink, CEnc2SinComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAnalogCaptureToXDS, CAna2XDSComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAnalogTVToEncoder, CAna2EncComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidSBESourceToCC, CSbeS2CCComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidStreamBufferSourceToVideoRenderer, CSbeS2VmrComp)
/////////////////////////////////////////////////////////////////////////////
// CComposition

#endif //TUNING_MODEL_ONLY

// end of file - composition.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\componenttypes.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// ComponentTypes.cpp : Implementation of CComponentTypes
// Copyright (c) Microsoft Corporation 1999.

#include "stdafx.h"
#include "Tuner.h"
#include "ComponentTypes.h"
#include "ComponentType.h"
#include "LanguageComponentType.h"
#include "MPEG2ComponentType.h"
#include "ATSCComponentType.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ComponentTypes, CComponentTypes)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ComponentType, CComponentType)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_LanguageComponentType, CLanguageComponentType)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MPEG2ComponentType, CMPEG2ComponentType)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ATSCComponentType, CATSCComponentType)

/////////////////////////////////////////////////////////////////////////////
// CComponentTypes
STDMETHODIMP CComponentTypes::Load(IPropertyBag2 *pBag2, IErrorLog *pErrLog) {
    try {
        ULONG count;
        HRESULT hr = pBag2->CountProperties(&count);
        if (FAILED(hr)) {
            return hr;
        }
		// undone: should this be on the heap not the stack?
        PROPBAG2 *props = reinterpret_cast<PROPBAG2 *>(_alloca(sizeof(PROPBAG2) * count));
        if (!props) {
            return E_OUTOFMEMORY;
        }
        ULONG readcount = 0;
        hr = pBag2->GetPropertyInfo(0, count, props, &readcount);
        if (FAILED(hr)) {
            return hr;
        }
        if (count != readcount) {
            return E_UNEXPECTED;
        }
        HRESULT *phr = reinterpret_cast<HRESULT *>(_alloca(sizeof(HRESULT) * readcount));
        if (!phr) {
            return E_OUTOFMEMORY;
        }
        VARIANT *pv = new VARIANT[readcount];
        if (!pv) {
            return E_OUTOFMEMORY;
        }
        // readcount is set from GetPropertyInfo
        // pv is an array of variants readcount in length
        memset(pv, 0, sizeof(VARIANT) * readcount);
        hr = pBag2->Read(readcount, props, pErrLog, pv, phr);
        if (FAILED(hr)) {
            delete[] pv;
            return hr;
        }
		ATL_LOCK();
        for (count = 0; count < readcount; ++count) {
            int idx = _wtoi(props[count].pstrName);
            switch(props[count].vt) {
            case VT_UNKNOWN:
                if (idx >= m_ComponentTypes.size()) {
                    m_ComponentTypes.reserve(idx + 1);
                    m_ComponentTypes.insert(m_ComponentTypes.end(), (idx - m_ComponentTypes.size()) + 1, PQComponentType());
                }
                m_ComponentTypes[idx] = pv[count].punkVal;
                break;
            case VT_DISPATCH:
                if (idx >= m_ComponentTypes.size()) {
                    m_ComponentTypes.reserve(idx + 1);
                    m_ComponentTypes.insert(m_ComponentTypes.end(), (idx - m_ComponentTypes.size()) + 1, PQComponentType());
                }
                m_ComponentTypes[idx] = pv[count].pdispVal;
                break;
            case VT_CLSID:
            case VT_BSTR:
                break; // ignore clsids
            default:
                _ASSERT(FALSE);
            }
            VariantClear(&pv[count]);
        }
        delete[] pv;
        return NOERROR;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CComponentTypes::Save(IPropertyBag2 *pBag2, BOOL fClearDirty, BOOL fSaveAllProperties) {
    try {
        if (!m_bRequiresSave) {
            return NOERROR;
        }
        int propsize = sizeof(PROPBAG2) * m_ComponentTypes.size();
        PROPBAG2 *props = new PROPBAG2[m_ComponentTypes.size()];
        if (!props) {
            return E_OUTOFMEMORY;
        }
        // props points to memory _alloca'd propsize in length
        memset(props, 0, propsize);
        VARIANT *pv = new VARIANT[m_ComponentTypes.size()];
        if (!pv) {
            delete[] props;
            return E_OUTOFMEMORY;
        }
        int ctidx = 0;
        int propidx = 0;
        for (int i = 0; i < m_ComponentTypes.size(); ++i) {
            PQPersist pct(m_ComponentTypes[ctidx++]);
            if (!pct) continue;
            pv[i].vt = VT_UNKNOWN;
            pv[i].punkVal = pct;  // guaranteed nested lifetime(m_components isn't going away) thus no addref needed
            props[i].dwType = PROPBAG2_TYPE_OBJECT;
            props[i].vt = VT_UNKNOWN;
            HRESULT hr = pct->GetClassID(&(props[i].clsid));
            if (FAILED(hr)) {
                _ASSERT(false);
                --i; // reuse this slot and keep going
                continue;
            }
			USES_CONVERSION;
            const long idlen = sizeof(long) * 3 /* max digits per byte*/ + 1;
            props[i].pstrName = new OLECHAR[idlen + 1];
            _itow(i, props[i].pstrName, 10);
            ++propidx;
        }
        HRESULT hr = NOERROR; 
        hr = pBag2->Write(propidx, props, pv);
        if (SUCCEEDED(hr)) {
            m_bRequiresSave = false;
        }
        for (i = 0; i < propidx; ++i) {
            delete props[i].pstrName;
        }
        delete[] props;
        delete[] pv;
        return hr;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CComponentTypes::get_Count(long *pVal)
{
    try {
        if (!pVal) {
            return E_POINTER;
        }
	    *pVal = m_ComponentTypes.size();
    } catch (...) {
        return E_POINTER;
    }

	return NOERROR;
}

STDMETHODIMP CComponentTypes::get__NewEnum(IEnumVARIANT** ppVal)
{
    try {
        if (ppVal == NULL)
	        return E_POINTER;

        ComponentTypeScriptEnumerator_t* p;

        *ppVal = NULL;

        HRESULT hr = ComponentTypeScriptEnumerator_t::CreateInstance(&p);
        if (FAILED(hr) || !p) {
            return E_OUTOFMEMORY;
        }
	    hr = p->Init(GetUnknown(), m_ComponentTypes);
        if (FAILED(hr)) {
            delete p;
            return hr;
        }
		hr = p->QueryInterface(__uuidof(IEnumVARIANT), (void**)ppVal);
        if (FAILED(hr)) {
            delete p;
            return hr;
        }
        return NOERROR;
    } catch(...) {
        return E_POINTER;
    }
}

STDMETHODIMP CComponentTypes::EnumComponentTypes(IEnumComponentTypes** pVal)
{
    ComponentTypeBaseEnumerator_t *pe = NULL;
    ComponentTypeBaseEnumerator_t::CreateInstance(&pe);
    pe->Init(static_cast<IComponentTypes*>(this), m_ComponentTypes);
    HRESULT hr = pe->QueryInterface(pVal);
    if (FAILED(hr)) {
        delete pe;
    }
	return hr;
}

STDMETHODIMP CComponentTypes::get_Item(VARIANT varIndex, IComponentType **ppComponentType)
{
    try {
        if (!ppComponentType) {
            return E_POINTER;
        }

	    int idx;
	    CComVariant vidx;
		if (FAILED(vidx.ChangeType(VT_I4, &varIndex))) {
            return E_INVALIDARG;
		}
    	idx = vidx.lVal;
		if (idx >= m_ComponentTypes.size()) {
			return E_INVALIDARG;
		}
	    (*(m_ComponentTypes.begin() + idx)).CopyTo(ppComponentType);
    } catch (...) {
        return E_POINTER;
    }

	return NOERROR;
}

STDMETHODIMP CComponentTypes::put_Item(VARIANT varIndex, IComponentType *pComponentType) {
    try {
	    int idx;
	    CComVariant vidx;
		if (FAILED(vidx.ChangeType(VT_I4, &varIndex))) {
            return E_INVALIDARG;
		}
		idx = vidx.lVal;
        PQComponentType p(pComponentType);
		if (idx >= m_ComponentTypes.size() || !p) {
			return E_INVALIDARG;
		}
        m_ComponentTypes[idx] = p;
        return NOERROR;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CComponentTypes::Add(IComponentType *pComponentType, VARIANT *pNewIndex)
{
    try {
        if (!pComponentType) {
            return E_POINTER;
        }
        PQComponentType p(pComponentType);
        m_ComponentTypes.push_back(p);
        if (pNewIndex) {
            VariantClear(pNewIndex);
            pNewIndex->vt = VT_UI4;
            pNewIndex->ulVal = m_ComponentTypes.end() - m_ComponentTypes.begin() - 1;
        }
        m_bRequiresSave = true;
    } catch (...) {
        return E_POINTER;
    }

	return NOERROR;
}

STDMETHODIMP CComponentTypes::Remove(VARIANT varIndex)
{
    try {
	    int idx;
	    CComVariant vidx;
		if (FAILED(vidx.ChangeType(VT_I4, &varIndex))) {
            return E_INVALIDARG;
        }
		idx = vidx.lVal;
		if (idx >= m_ComponentTypes.size()) {
			return E_INVALIDARG;
		}
	    m_ComponentTypes.erase(m_ComponentTypes.begin() + idx);
        m_bRequiresSave = true;
    } catch (...) {
        return E_UNEXPECTED;
    }

	return NOERROR;
}

STDMETHODIMP CComponentTypes::Clone(IComponentTypes **ppNewList)
{
    try {
		if (!ppNewList) {
			return E_POINTER;
		}
		CComponentTypes* pCs = new CComObject<CComponentTypes>;
		if (!pCs) {
			return E_OUTOFMEMORY;
		}
		ComponentTypeList::iterator i;
		for (i = m_ComponentTypes.begin(); i != m_ComponentTypes.end(); ++i) {
			PQComponentType p;
			HRESULT hr = (*i)->Clone(&p);
			if (FAILED(hr)) {
                pCs->Release();
				return hr;
			}
			pCs->m_ComponentTypes.push_back(p);			
		}
		pCs->AddRef();
        pCs->m_bRequiresSave = true;
		*ppNewList = pCs;
		return NOERROR;
    } catch (...) {
        return E_UNEXPECTED;
    }

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\cmseventbinder.h ===
// CMSEventBinder.h : Declaration of the CMSEventBinder

#ifndef __MSEVENTBINDER_H_
#define __MSEVENTBINDER_H_

#include <map>
#include <Mshtml.h>
#include <activscp.h>
#include <Atlctl.h>
#include <Exdisp.h>
#include <objectwithsiteimplsec.h>
#include "segimpl.h"
#include "seg.h"
#include "resource.h"       // main symbols
#include "mslcid.h"

typedef CComQIPtr<IActiveScriptSite> PQIASSite;
typedef CComQIPtr<IActiveScript> PQIAScript;
/////////////////////////////////////////////////////
    
    
class __declspec(uuid("FCBF24F7-FB97-4fa3-B57E-97BCB5AF1D26")) ATL_NO_VTABLE CMSEventHandlerBase:
    public CComObjectRootEx<CComSingleThreadModel>,
    public IObjectWithSiteImplSec<CMSEventHandlerBase>,
    public IDispatchImpl<IDispatch, &IID_IDispatch>
    {
        BEGIN_COM_MAP(CMSEventHandlerBase)
            COM_INTERFACE_ENTRY(IDispatch)    
            COM_INTERFACE_ENTRY(IObjectWithSite)
        END_COM_MAP()
protected:
        CMSEventHandlerBase(){}

        // Cookie for canceling the advise
        DWORD cancelCookie;
public:
        virtual ~CMSEventHandlerBase(){
            if(cancelCookie!=-1){
                Cancel(cancelCookie);
            }
        }
        // Id of the handler function
        DISPID ID_handler;
        
        // The DISPID of the event 
        DISPID ID_event;

        // GUID of the Interface whose event we want to know about
        GUID gEventInf;
        
        // Connection Point that the advise is on
        CComQIPtr<IConnectionPoint> cancelPoint;
        
        // IDispatch where the handler function is from
        CComQIPtr<IDispatch> pDScript;

        // Override invoke to throw events on up
        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
            EXCEPINFO* pexcepinfo, UINT* puArgErr){
            if(dispidMember == ID_event) {
                return pDScript->Invoke(ID_handler, riid, 
                    lcid, wFlags, pdispparams, pvarResult, 
                    pexcepinfo, puArgErr);
            } else {
                return E_NOTIMPL;
            }
        }

        // Unadvise
        STDMETHOD(Cancel)(DWORD dwCancel){
            HRESULT hr = E_INVALIDARG;
            if(dwCancel == cancelCookie && cancelCookie != -1){
                hr = cancelPoint->Unadvise(dwCancel);
                if (SUCCEEDED(hr)){
                    cancelPoint.Release();
                    pDScript.Release();
                    cancelCookie = -1;
                }
            }
            return hr;
        }
        DWORD getCookie(){
            return cancelCookie;
        }
        STDMETHOD(setCookie)(DWORD newValue){
            HRESULT hr = E_FAIL;
            if(cancelCookie==-1){
                cancelCookie = newValue;
                hr = S_OK;
            }
            return hr;
        }
    };
    
class __declspec(uuid("C092B145-B318-41a7-B890-C77C5DA41CFD")) CMSEventHandler : 
    public CComObject<CMSEventHandlerBase>
    {
    public:
            
        typedef CComObject<CMSEventHandlerBase> base;
        CMSEventHandler(DISPID handler, DISPID event, GUID gInf, IDispatch* IDispSite){
            ID_handler = handler;
            ID_event = event;
            gEventInf = gInf;
            pDScript = IDispSite;
            cancelCookie = -1;
        
        }
        STDMETHOD(QueryInterface) (REFIID iid, void **pp) {
            try {
                if (iid == gEventInf) {
                    CComQIPtr<IDispatch> pdispRet(static_cast<IDispatch *>(this));
                    pdispRet.CopyTo(pp);
                    pdispRet.Release();
                    return NOERROR;
                }
                return base::QueryInterface(iid, pp);
            } catch(...) {
                return E_NOINTERFACE;
            }
        }
        virtual ~CMSEventHandler() {            
            if(cancelCookie!=-1){
                Cancel(cancelCookie);
            }
        }
        
        
    };
    
    typedef std::map<DWORD, CComQIPtr<IDispatch> > CancelMap;

/////////////////////////////////////////////////////////////////////////////
// CMSEventBinder
class ATL_NO_VTABLE __declspec(uuid("577FAA18-4518-445E-8F70-1473F8CF4BA4")) CMSEventBinder : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSEventBinder, &__uuidof(CMSEventBinder)>,
    public IObjectWithSiteImplSec<CMSEventBinder>,
    public ISupportErrorInfo,
    public IObjectSafetyImpl<CMSEventBinder, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
    public IProvideClassInfo2Impl<&CLSID_MSEventBinder, &IID_IMSEventBinder, &LIBID_MSVidCtlLib>,
	public IDispatchImpl<IMSEventBinder, &IID_IMSEventBinder, &LIBID_MSVidCtlLib>
{
public:
    CMSEventBinder(){}	
    virtual ~CMSEventBinder(){
        CleanupConnection();
    }

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
                           IDS_REG_MSEVENTBINDER_PROGID,
						   IDS_REG_MSEVENTBINDER_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSEventBinder));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSEventBinder)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMSEventBinder)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2) 
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

// IMSEventBinder
public:
    // ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    STDMETHOD(Bind)(LPDISPATCH pEventObject, BSTR EventName, BSTR EventHandler, LONG *CancelCookie);
    STDMETHOD(Unbind)(DWORD CancelCookie);

protected:
    HRESULT CleanupConnection();

private:
    CancelMap m_CancelMap; // map of cookies to CMSEventHandlers
};


#endif //__MSEVENTBINDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\createregbag.h ===
// CreateRegBag.h : Declaration of the CCreateRegBag

#ifndef __CREATEREGBAG_H_
#define __CREATEREGBAG_H_

#include <comcat.h>
#include <objsafe.h>
#include <propertybag2impl.h>
#include <objectwithsiteimplsec.h>
#include <throw.h>

/////////////////////////////////////////////////////////////////////////////
// CRegBagBase
class ATL_NO_VTABLE CRegBagBase : public CComObjectRootEx<CComMultiThreadModel>,
    public IPropertyBag,
	public IPropertyBag2Impl<CRegBagBase>,
    public IObjectWithSiteImplSec<CRegBagBase>
{

    BEGIN_COM_MAP(CRegBagBase)
	    COM_INTERFACE_ENTRY(IPropertyBag2)
        COM_INTERFACE_ENTRY(IPropertyBag)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP_WITH_FTM()

	CRegBagBase() {}

    virtual ~CRegBagBase() {}

// IPropertyBag
    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT *pVar);
    
protected:
    // internal utility functions
    HRESULT DeleteSubKey(CRegKey& hk, LPCOLESTR pszPropName);
    HRESULT DeleteValue(CRegKey& hk, LPCOLESTR pszPropName);
    HRESULT SaveObject(CRegKey& hk, LPCOLESTR pszPropName, VARIANT* pV);
    HRESULT RegConvertToVARIANT(VARIANT *pVar, DWORD dwType, LPBYTE pbData, DWORD cbSize);

    CRegKey m_hk;
};

/////////////////////////////////////////////////////////////////////////////
// CRegBag
class CRegBag : 
	public CComObject<CRegBagBase>
{
public:
    CRegBag(HKEY hk, LPCTSTR subkey, DWORD ulOptions, REGSAM samDesired) {
        DWORD rc = m_hk.Open(hk, subkey, samDesired, ulOptions);
        if (rc != ERROR_SUCCESS) {
            THROWCOM(HRESULT_FROM_WIN32(rc));
        }
    }
    virtual ~CRegBag() {}
// IPropertyBag2
	STDMETHOD(CountProperties)(ULONG * pcProperties);
	STDMETHOD(GetPropertyInfo)(ULONG iProperty, ULONG cProperties, PROPBAG2 * pPropBag, ULONG * pcProperties);
	STDMETHOD(LoadObject)(LPCOLESTR pstrName, ULONG dwHint, IUnknown * pUnkObject, IErrorLog * pErrLog);
};


template<class BAGTYPE, class PERSISTTYPE> HRESULT LoadPersistedObject(PERSISTTYPE pPersistObj, 
																	   CLSID& clsid, 
																	   VARIANT* pVar, 
																	   HKEY hk, 
																	   LPCOLESTR pszPropName, 
																	   IErrorLog *pErrorLog) {
    ASSERT(pVar && hk && pszPropName);
    HRESULT hr = NOERROR;
    if (!pPersistObj && ((pVar->vt == VT_UNKNOWN) ? pVar->punkVal : pVar->pdispVal)) {
        // got passed an object to initialize and the object doesn't support persist
        return E_NOINTERFACE;
    } else if (!pPersistObj) {
        hr = pPersistObj.CoCreateInstance(clsid);
        if (FAILED(hr)) {
            // we ignore subkeys if they don't look like objects
            // but if they have a default value that successfully converts to a guid
            // and if that object can't be created then its an error
            return hr;
        }
        hr = pPersistObj->InitNew();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            return hr;
        }
        ASSERT(pVar->vt == VT_UNKNOWN || pVar->vt == VT_DISPATCH);
        switch(pVar->vt) {
        case VT_DISPATCH:
            pVar->pdispVal = PQDispatch(pPersistObj);
            if (pVar->pdispVal) {
                pVar->pdispVal->AddRef();
                break;
            } else {
                pVar->vt = VT_UNKNOWN;
            }
            // fall thru
        case VT_UNKNOWN:
            pVar->punkVal = pPersistObj;
            (pVar->punkVal)->AddRef();
        }
    }
    USES_CONVERSION;
    BAGTYPE pBag(new CRegBag(hk, OLE2CT(pszPropName), 0, KEY_READ));
    if (!pBag) {
        return E_OUTOFMEMORY;
    }
    hr = pPersistObj->Load(pBag, pErrorLog);

    return hr;
};

/////////////////////////////////////////////////////////////////////////////
// CCreateRegBag
class ATL_NO_VTABLE CCreateRegBag : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CCreateRegBag, &CLSID_CreatePropBagOnRegKey>,
    public IObjectWithSiteImplSec<CCreateRegBag>,
	public ICreatePropBagOnRegKey
{
public:
	CCreateRegBag()
	{
	}

REGISTER_NONAUTOMATION_OBJECT_WITH_TM(IDS_PROJNAME, 
						   IDS_REG_CREATEREGBAG_DESC,
						   LIBID_MSVidCtlLib,
						   CLSID_CreatePropBagOnRegKey, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCreateRegBag)
	COM_INTERFACE_ENTRY(ICreatePropBagOnRegKey)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

BEGIN_CATEGORY_MAP(CVidCtl)
    IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

// ICreateRegBag
public:
// ICreatePropBagOnRegKey
	STDMETHOD(Create)(HKEY hkey, LPCOLESTR subkey, DWORD options, DWORD sam, REFIID iid, LPVOID* ppBag);
};

#endif //__CREATEREGBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\dat2sin.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing analog capture to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef DAT2SIN_H
#define DAT2SIN_H

#pragma once
#include <uuids.h>
#include "bdamedia.h"
#include "MSVidTVTuner.h"
#include "resource.h"       // main symbols
#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include <ksmedia.h>
#include "enc2sin.h"

typedef struct

{ 
    KSPROPERTY                               m_ksThingy;
    VBICODECFILTERING_CC_SUBSTREAMS          ccSubStreamMask;
} KSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS;


/////////////////////////////////////////////////////////////////////////////
// CDat2SinComp
class ATL_NO_VTABLE __declspec(uuid("38F03426-E83B-4e68-B65B-DCAE73304838")) CDat2SinComp : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDat2SinComp, &__uuidof(CDat2SinComp)>,
    public IObjectWithSiteImplSec<CDat2SinComp>,
    public IMSVidCompositionSegmentImpl<CDat2SinComp>
{
private:
    DSFilterList m_pEncFilters;
public:
    CDat2SinComp() {}
    virtual ~CDat2SinComp() {}

    REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_DAT2SINCOMP_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CDat2SinComp));
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()
        
        BEGIN_COM_MAP(CDat2SinComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
        END_COM_MAP()
        
        // IMSVidComposition
public:
    // IMSVidGraphSegment
    // IMSVidCompositionSegment  
    STDMETHOD(CheckEncFilters)(){
        int j = 0;
        for(DSFilterList::iterator i = m_pEncFilters.begin(); i != m_pEncFilters.end(); ++i){
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters checking filter " << j);
            CComQIPtr<IETFilterConfig> spETConfig;
            CComPtr<IUnknown> spUnkSecChan;
            spETConfig = (*i);
            if(!spETConfig){
                TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters filter " << j << " could not get et filter config interface");
                return E_NOINTERFACE;
            }            
            HRESULT hr = spETConfig->GetSecureChannelObject(&spUnkSecChan);   
            hr = CheckIfSecureClient(spUnkSecChan);
            if(FAILED(hr)){
                TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters filter " << j << " Failed");
                return E_FAIL;
            }
            ++j;
        }
        TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters no failures");
        return NOERROR;
    }

    STDMETHOD(PreRun)(){
        return CheckEncFilters();
    }
    STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl) {
        try {
            if (!pCtl) {
                m_pEncFilters.clear();
                return Unload();
            }
            if (m_pContainer) {
				if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
					//undone: support moving to different graph
					return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidGraphSegment), CO_E_ALREADYINITIALIZED);
				} else {
					return NO_ERROR;
				}
            }
            // DON'T addref the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            m_pContainer.p = pCtl;
            m_pGraph = m_pContainer.GetGraph();
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}
    STDMETHOD(SetSubstreamChannel)(IPin * pPinCCDecoder, DWORD dwSubStreamChannels){
        HRESULT hr;
        if(!(dwSubStreamChannels & 
            (KS_CC_SUBSTREAM_ODD | KS_CC_SUBSTREAM_EVEN |
            KS_CC_SUBSTREAM_SERVICE_CC1 | KS_CC_SUBSTREAM_SERVICE_CC2 |
            KS_CC_SUBSTREAM_SERVICE_CC3   | KS_CC_SUBSTREAM_SERVICE_CC4 |
            KS_CC_SUBSTREAM_SERVICE_T1    | KS_CC_SUBSTREAM_SERVICE_T2 |
            KS_CC_SUBSTREAM_SERVICE_T3    | KS_CC_SUBSTREAM_SERVICE_T4 |
            KS_CC_SUBSTREAM_SERVICE_XDS))){
            return E_INVALIDARG;
        }
        
        
        try {
            IKsPropertySet *pksPSet = NULL;
            
            hr = pPinCCDecoder->QueryInterface(IID_IKsPropertySet, (void **) &pksPSet);
            
            if(SUCCEEDED(hr)){
                DWORD rgdwData[20];
                DWORD cbMax = sizeof(rgdwData);
                DWORD cbData;
                
                hr = pksPSet->Get(KSPROPSETID_VBICodecFiltering,
                    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
                    NULL, 0, 
                    (BYTE *) rgdwData, cbMax, &cbData); 
                
                if(SUCCEEDED(hr)){
                    KSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS ksThing = {0};
                    
                    ksThing.ccSubStreamMask.SubstreamMask = dwSubStreamChannels;
                    
                    // ring3 to ring0 propset call
                    hr = pksPSet->Set(KSPROPSETID_VBICodecFiltering,
                        KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,                           
                        &ksThing.ccSubStreamMask, 
                        sizeof(ksThing) - sizeof(KSPROPERTY), 
                        &ksThing, 
                        sizeof(ksThing));
                }
                
                pksPSet->Release();            
                
            }
            
        } catch (HRESULT hrCatch) {
            // bad things happend  
            hr = hrCatch;
        } catch (...) {
            // Threw Badly - Giving Up"
            hr = E_FAIL;
        }
        return hr;
        
    }


    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
    {
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (upstream == downstream) {
                return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(IMSVidCompositionSegment), E_INVALIDARG);
            }
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty up segment");
                return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
                return NOERROR;
            }
            // Making sure that only the cc pin is rendered to the sink and that the encrypter is added
            CMSVidStreamBufferSink* ds = (CMSVidStreamBufferSink*)downstream;
            DSFilter pSink(ds->m_Filters[0]);
            DSGraph::iterator gFilter; 
            DSFilter::iterator fPin;
            DSPin::iterator pMedia;
            DSPin ccPin;
            DSMediaType mtL21(MEDIATYPE_AUXLine21Data, MEDIASUBTYPE_Line21_BytePair);
            for(gFilter = m_pGraph.begin(); gFilter != m_pGraph.end() && !ccPin; ++gFilter){
                for(fPin = (*gFilter).begin(); fPin != (*gFilter).end() && !ccPin; ++fPin){
                    for(pMedia = (*fPin).begin(); pMedia != (*fPin).end() && !ccPin; ++pMedia){
                        if((*pMedia) == mtL21){
                            if(!(*fPin).IsConnected() && (*fPin).GetDirection() == PINDIR_OUTPUT){
                                ccPin = *fPin;
                            }
                        }
                    }
                }
            }
            if(!ccPin){
                return E_FAIL;
            }
            HRESULT hr = E_FAIL;
            DSFilterList intermediates;
#if ENCRYPT_NEEDED
            CComBSTR encString(L"{C4C4C4F1-0049-4E2B-98FB-9537F6CE516D}");
            GUID2 encdecGuid (encString);
            CComPtr<IUnknown> spEncTagFilter(encdecGuid, NULL, CLSCTX_INPROC_SERVER);
            if (!spEncTagFilter) {
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSink::Build() can't load Tagger filter");
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
            }
            
            DSFilter ETFilter(spEncTagFilter);
            if (!ETFilter) {
                ASSERT(false);
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
            }
            
            m_Filters.push_back(ETFilter);
            m_pEncFilters.push_back(ETFilter);
            CString csName = _T("CC Encoder Tagger Filter");
            m_pGraph.AddFilter(ETFilter, csName);
            
            // Connect cc pin to the Tagger
            hr = ccPin.IntelligentConnect(ETFilter, intermediates);
            if(FAILED(hr)){
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect audio pin to CC Tagger");
                return E_UNEXPECTED;  
            }

            ASSERT(intermediates.begin() == intermediates.end());
            m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());

            hr = E_FAIL;
            DSFilter::iterator ETPin;
            for(ETPin = ETFilter.begin(); ETPin != ETFilter.end(); ++ETPin){
                if((*ETPin).GetDirection() == PINDIR_OUTPUT && !(*ETPin).IsConnected()){
                    break;
                }
            }   
            if(ETPin == ETFilter.end()){
                return E_UNEXPECTED;
            }
            for(fPin = pSink.begin(); fPin != pSink.end() && FAILED(hr); ++fPin){
                if((*fPin).GetDirection() == PINDIR_INPUT && !(*fPin).IsConnected()){
                    hr = (*ETPin).Connect((*fPin));
                }
            }

            if(FAILED(hr)){
                return hr;
            }
            else{
                ASSERT(intermediates.begin() == intermediates.end());
                m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
            }
            
#else
            for(fPin = pSink.begin(); fPin != pSink.end() && FAILED(hr); ++fPin){
                if((*fPin).GetDirection() == PINDIR_INPUT && !(*fPin).IsConnected()){
                    hr = ccPin.Connect((*fPin));
                }
            }

            if(FAILED(hr)){
                return hr;
            }
            

#endif
            // BUG in the cc codec makes it so we have to set the feilds as such
//            hr = SetSubstreamChannel(ccPin, KS_CC_SUBSTREAM_EVEN|KS_CC_SUBSTREAM_ODD);
            ASSERT(SUCCEEDED(hr));
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
        
    }
    

};

#endif // Dat2Sin_H
// end of file - Dat2Sin.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\dat2xds.h ===
//==========================================================================;
//
// dat2xds.h : Declaration of the custom composition class for gluing sbe source to vmr
// TODO: Need to update header file and change classids
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef DAT2XDS_H
#define DAT2XDS_H

#pragma once
#include <uuids.h>
#include "bdamedia.h"
#include "MSVidEncoder.h"
#include "resource.h"       // main symbols
#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>



/////////////////////////////////////////////////////////////////////////////
// CDat2XDSComp
class ATL_NO_VTABLE __declspec(uuid("0429EC6E-1144-4bed-B88B-2FB9899A4A3D")) CDat2XDSComp : 
public CComObjectRootEx<CComSingleThreadModel>,
public CComCoClass<CDat2XDSComp, &__uuidof(CDat2XDSComp)>,
public IObjectWithSiteImplSec<CDat2XDSComp>,
public IMSVidCompositionSegmentImpl<CDat2XDSComp>
{
public:
    CDat2XDSComp() {}
    virtual ~CDat2XDSComp() {}
    
    REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_DAT2XDSCOMP_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CDat2XDSComp));
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()
        
        BEGIN_COM_MAP(CDat2XDSComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
        END_COM_MAP()
        
        // IMSVidComposition
public:
    // IMSVidGraphSegment
    // IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
    {
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (upstream == downstream) {
                return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(IMSVidCompositionSegment), E_INVALIDARG);
            }
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty up segment");
                return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
                return NOERROR;
            }
            bool vidFound = false;
            // VMR has a bug so we need to connect the video before the cc or no cc will be displayed
            DSMediaType mtVideo(MEDIATYPE_Video, MEDIASUBTYPE_MPEG2_VIDEO, FORMAT_MPEG2Video);
            for (VWGraphSegment::iterator iStart = up.begin(); iStart != up.end(); ++iStart) {
                ASSERT((*iStart).GetGraph() == m_pGraph);
                if(!vidFound){
                    for(DSFilter::iterator i = (*iStart).begin(); i != (*iStart).end(); ++i){
                        if((*i).GetDirection() == DOWNSTREAM){
                            for(DSPin::iterator p = (*i).begin(); p != (*i).end(); ++p){ 
                                if((*p) == mtVideo){
                                    for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++ iStop) {
                                        ASSERT((*iStop).GetGraph() == m_pGraph);
                                        DSFilter pStop(*iStop);
                                        (*i).IntelligentConnect(pStop, m_Filters);
                                    }
                                    vidFound = true;
                                    iStart = up.begin();
                                }
                            }
                        }
                    }
                }
                else{
                    for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++ iStop) {
                        ASSERT((*iStop).GetGraph() == m_pGraph);
                        DSFilter pStart(*iStart);
                        DSFilter pStop(*iStop);
                        HRESULT hr = m_pGraph.Connect(pStart, pStop, m_Filters);
                        if (SUCCEEDED(hr)) {
                            m_Segments.push_back(up);
                            m_Segments.push_back(down);
                            m_pDown = m_Segments.end();
                            --m_pDown;
                            m_pUp = m_pDown;
                            --m_pUp;
                            m_fComposed = true;
                            return NOERROR;
                        }
                    }
                }
            }
            TRACELM(TRACE_ERROR, "CComposition::Compose() compose didn't connect anything");
            return VFW_E_NO_DECOMPRESSOR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
        
    }

    
};

#endif // Dat2XDS_H
// end of file - Dat2XDS.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\devices.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1998-2000.
//
//--------------------------------------------------------------------------;
//
// Devices.cpp : Implementation of CDevices
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "Devices.h"

static DWORD dwFetch;

// note: the compiler is generating but never calling the code to construct these initializers so the pointers
// are staying null.  we work around this by providing a function which dynamically allocating them on the heap 
// and calling it in our dllmain.

typedef enumerator_iterator<PQEnumVARIANT, CComVariant, IEnumVARIANT, VARIANT, std::allocator<VARIANT>::difference_type > EnumVARIANTIterator;
std_arity0pmf<IEnumVARIANT, HRESULT> * EnumVARIANTIterator::Reset = NULL;
std_arity1pmf<IEnumVARIANT, VARIANT *, HRESULT> * EnumVARIANTIterator::Next = NULL;

#define DECLAREPMFS(coll) \
	std_arity1pmf<IMSVid##coll, IEnumVARIANT **, HRESULT> * VW##coll::Fetch = NULL

#define INITPMFS(coll) \
	VW##coll::Fetch = new std_arity1pmf<IMSVid##coll, IEnumVARIANT **, HRESULT>(&IMSVid##coll::get__NewEnum)

#define DELETEPMFS(coll) \
    delete VW##coll::Fetch

DECLAREPMFS(InputDevices);
DECLAREPMFS(OutputDevices);
DECLAREPMFS(VideoRendererDevices);
DECLAREPMFS(AudioRendererDevices);
DECLAREPMFS(Features);

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidInputDevices, CInputDevices)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidOutputDevices, COutputDevices)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidVideoRendererDevices, CVideoRendererDevices)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAudioRendererDevices, CAudioRendererDevices)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidFeatures, CFeatures)

// work around compiler bug as per above description
void CtorStaticVWDevicesFwdSeqPMFs(void) {


	INITPMFS(InputDevices);
	INITPMFS(OutputDevices);
	INITPMFS(VideoRendererDevices);
	INITPMFS(AudioRendererDevices);
	INITPMFS(Features);

	EnumVARIANTIterator::Reset = new std_arity0pmf<IEnumVARIANT, HRESULT>(&IEnumVARIANT::Reset);
	EnumVARIANTIterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumVARIANT, ULONG, VARIANT*, ULONG *, HRESULT> >(std_arity3_member(&IEnumVARIANT::Next), 1, &dwFetch);
}

// work around compiler bug as per above description
void DtorStaticVWDevicesFwdSeqPMFs(void) {

	DELETEPMFS(InputDevices);
	DELETEPMFS(OutputDevices);
	DELETEPMFS(VideoRendererDevices);
	DELETEPMFS(AudioRendererDevices);
	DELETEPMFS(Features);

	delete EnumVARIANTIterator::Reset;
	delete EnumVARIANTIterator::Next;
}



/////////////////////////////////////////////////////////////////////////////
// CDevEnum

#endif //TUNING_MODEL_ONLY

// end of file - devices.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\composition.h ===
//==========================================================================;
//
// Composition.h : Declaration of the CComposition class
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef __COMPOSITION_H_
#define __COMPOSITION_H_

#include <winerror.h>
#include <algorithm>
#include <objectwithsiteimplsec.h>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CComposition
class ATL_NO_VTABLE __declspec(uuid("2764BCE5-CC39-11D2-B639-00C04F79498E")) CComposition : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CComposition, &__uuidof(CComposition)>,
    public IObjectWithSiteImplSec<CComposition>,
	public IMSVidCompositionSegmentImpl<CComposition>
{
public:
    CComposition() {}
    virtual ~CComposition() {}

REGISTER_NONAUTOMATION_OBJECT_WITH_TM(IDS_PROJNAME, 
						   IDS_REG_COMPOSITION_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CComposition), tvBoth);

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CComposition)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP_WITH_FTM()

// IMSVidComposition
public:
// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        if (m_fComposed) {
	 	    return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
			if (upstream == downstream) {
		 	    return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(IMSVidCompositionSegment), E_INVALIDARG);
			}
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty up segment");
		 	    return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
		 	    return NOERROR;
            }
			for (VWGraphSegment::iterator iStart = up.begin(); iStart != up.end(); ++iStart) {
				ASSERT((*iStart).GetGraph() == m_pGraph);
				for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++ iStop) {
					ASSERT((*iStop).GetGraph() == m_pGraph);
					DSFilter pStart(*iStart);
					DSFilter pStop(*iStop);
					HRESULT hr = m_pGraph.Connect(pStart, pStop, m_Filters);
					if (SUCCEEDED(hr)) {
						m_Segments.push_back(up);
						m_Segments.push_back(down);
						m_pDown = m_Segments.end();
						--m_pDown;
						m_pUp = m_pDown;
						--m_pUp;
						m_fComposed = true;
						return NOERROR;
					}
				}
			}
            TRACELM(TRACE_ERROR, "CComposition::Compose() compose didn't connect anything");
            //	 	    return Error(IDS_CANT_COMPOSE, __uuidof(IMSVidCompositionSegment), E_FAIL);
            // bda tuner input doesn't compose with anything in CC.  rather, line 21 decoder is 
            // picked up when bda tuner is connected with video renderer.
            // But we do need to know that some cases fail such as dvd to vmr
            // so in those cases we return s_false
            return S_FALSE;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif //__COMPOSITION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\createregbag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// CreateRegBag.cpp : Implementation of CCreateRegBag
// Copyright (c) Microsoft Corporation 1999.
//
// some code copied from DShow device moniker devmon.cpp
//

#include "stdafx.h"
#include "Regbag.h"
#include "CreateRegBag.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_CreatePropBagOnRegKey, CCreateRegBag)

// REV2: support for more data types 
// REG_MULTI_SZ could be supported via VT_BSTR | VT_ARRAY
// REG_BINARY blobs could be vt_unknown that's an istream
// subkeys could be vt_unknown that's an IPropertyBag2 if default val isn't clsid
// 

/////////////////////////////////////////////////////////////////////////////
// CCreateRegBag

HRESULT CRegBagBase::DeleteSubKey(CRegKey& hk, LPCOLESTR pszPropName) {
    // the registry will allow a peer subkey and value to have the same name
    // this doesn't match property bag semantics. so we force this to never occur.
    // after we write a primitive value then we check for a subkey of the
    // same name and recursively delete it if it exists.  from the property bag
    // perspective this amounts to changing the type of the property by writing
    // a new type to the same name.
    // however, if pszpropname is empty(the default value) the current key will
    // get deleted which we don't want

    ASSERT(hk.m_hKey != NULL && pszPropName);

    if (!wcslen(pszPropName)) {
        return NOERROR;
    }

    USES_CONVERSION;
    DWORD hr = hk.RecurseDeleteKey(OLE2CT(pszPropName));
    switch (hr) {
    case ERROR_BADKEY:
    case ERROR_CANTOPEN:
    case ERROR_KEY_DELETED:
    case ERROR_FILE_NOT_FOUND:
        return S_FALSE;
    default:
        return HRESULT_FROM_WIN32(hr);
    }
}


HRESULT CRegBagBase::DeleteValue(CRegKey& hk, LPCOLESTR pszPropName) {
    ASSERT(hk.m_hKey && pszPropName);
    // this is the inverse of delete duplicate key name

    USES_CONVERSION;
    DWORD hr = hk.DeleteValue(OLE2CT(pszPropName));
    switch (hr) {
    case ERROR_FILE_NOT_FOUND:
#if 0
    ??? what else does reg return for missing value
    case ??? missing value
#endif
        return S_FALSE;
    default:
        return HRESULT_FROM_WIN32(hr);
    }
}


HRESULT CRegBagBase::RegConvertToVARIANT(VARIANT *pVar, DWORD dwType, LPBYTE pbData, DWORD cbSize) {
    ASSERT(pVar && pbData);
    USES_CONVERSION;
    switch (dwType) {
    case REG_DWORD:
        if (pVar->vt != VT_UI4) {
            HRESULT hr = VariantChangeType(pVar, pVar, 0, VT_UI4);
            if (FAILED(hr)) {
                return E_INVALIDARG;
            }
        }
        ASSERT(pVar->vt == VT_UI4);
        ASSERT(pbData);
        pVar->ulVal = *(reinterpret_cast<ULONG *>(pbData));
        break;
    case REG_QWORD:
        if (pVar->vt != VT_UI8) {
            HRESULT hr = VariantChangeType(pVar, pVar, 0, VT_UI8);
            if (FAILED(hr)) {
                return E_INVALIDARG;
            }
        }
        ASSERT(pVar->vt == VT_UI8);
        ASSERT(pbData);
        pVar->ullVal = *(reinterpret_cast<ULONGLONG *>(pbData));
        break;
    case REG_SZ:
        switch(pVar->vt) {
        case VT_EMPTY:
        case VT_NULL:
            pVar->vt = VT_BSTR;
            pVar->bstrVal = NULL;
            break;
        case VT_BSTR:
            break;
        default:
            HRESULT hr = VariantChangeType(pVar, pVar, 0, VT_BSTR);
            if (FAILED(hr)) {
                return E_INVALIDARG;
            }
        }
        ASSERT(pVar->vt == VT_BSTR);
        if (pVar->bstrVal) {
            ::SysFreeString(pVar->bstrVal);
        }
        if (cbSize) {
            ASSERT(pbData);
            pVar->bstrVal = ::SysAllocString(T2OLE(LPTSTR(pbData)));
        } else {
            pVar->bstrVal = NULL;  // empty string
        }
        break;
	case REG_MULTI_SZ:
		switch(pVar->vt) {
		case VT_EMPTY:
		case VT_NULL:
			pVar->vt = VT_BSTR_BLOB;
			break;
		case VT_VECTOR | VT_BSTR:
		case VT_BSTR:
			if (pVar->bstrVal) {
				::SysFreeString(pVar->bstrVal);
			}
			pVar->vt = VT_BSTR_BLOB;
			break;
		default:
            pVar->vt = VT_BSTR_BLOB;
		}
        if (cbSize) {
		    pVar->bstrVal = ::SysAllocStringByteLen(NULL, cbSize);
		    if (!pVar->bstrVal) {
			    return E_OUTOFMEMORY;
		    }
            if (pbData) {
		        memcpy(pVar->bstrVal, pbData, cbSize);
            }
        } 
		break;

    default: // binary
		switch (pVar->vt) {
        case VT_BSTR_BLOB:
		case VT_BSTR:
			if (pVar->bstrVal) {
				::SysFreeString(pVar->bstrVal);
			}
			pVar->bstrVal = ::SysAllocStringByteLen(NULL, cbSize);
			if (!pVar->bstrVal) {
				return E_OUTOFMEMORY;
			}
            if (pbData) {
    			memcpy(pVar->bstrVal, pbData, cbSize);
            }
            break;
		default:
			if (pVar->vt != (VT_UI1 | VT_ARRAY)) {
				HRESULT hr = VariantChangeType(pVar, pVar, 0, VT_UI1 | VT_ARRAY);
				if (FAILED(hr)) {
					return E_INVALIDARG;
				}
			}
			ASSERT(pVar->vt == (VT_UI1 | VT_ARRAY));
			SAFEARRAY * psa = NULL;
            if (cbSize) {
                ASSERT(pbData);
			    SAFEARRAYBOUND rgsabound[1];
			    rgsabound[0].lLbound = 0;
			    rgsabound[0].cElements = cbSize;
			    psa = SafeArrayCreate(VT_UI1, 1, rgsabound);
			    if(!psa) {
				    return E_OUTOFMEMORY;
			    }
			    BYTE *pbArray;
			    HRESULT hr = SafeArrayAccessData(psa, reinterpret_cast<LPVOID *>(&pbArray));
			    if (hr != S_OK) {
				    return E_FAIL;
			    }
			    memcpy(pbArray, pbData, cbSize);
			    hr = SafeArrayUnaccessData(psa);
			    if (hr != S_OK) {
				    return E_FAIL;
			    }
            }
			pVar->parray = psa;
		}
    }
    return NOERROR;
}

HRESULT CRegBagBase::SaveObject(CRegKey& hk, LPCOLESTR pszPropName, VARIANT* pV) {
    ASSERT(hk.m_hKey && pszPropName && pV);
    if (pV->vt != VT_UNKNOWN) {
        return E_UNEXPECTED;
    }
    HRESULT hr = NOERROR;
    USES_CONVERSION;
    if (!pV->punkVal) {
        hk.DeleteValue(OLE2CT(pszPropName));
        hk.RecurseDeleteKey(OLE2CT(pszPropName));
    } else {
        PQPersistPropertyBag2 p2(pV->punkVal);
        if (p2) {
                CRegKey sk;
                DWORD rc = sk.Create(m_hk, OLE2CT(pszPropName), NULL, 0, KEY_READ | KEY_WRITE, NULL, NULL);
                if (rc != ERROR_SUCCESS) {
                    return HRESULT_FROM_WIN32(rc);
                }
                CLSID cl;
                hr = p2->GetClassID(&cl);
                if (FAILED(hr)) {
                    return E_UNEXPECTED;
                }
                OLECHAR szClsid[64];
                rc = StringFromGUID2(cl, szClsid, sizeof(szClsid)/sizeof(OLECHAR));
                if (!rc) {
                    return E_UNEXPECTED;
                }
                rc = RegSetValue(sk, NULL, REG_SZ, OLE2T(szClsid), _tcslen(OLE2T(szClsid)) * sizeof(TCHAR));
                if (rc != ERROR_SUCCESS) {
                    return HRESULT_FROM_WIN32(rc);
                }
                try {
                    PQPropertyBag2 pBag2(new CRegBag(sk, NULL, 0, KEY_READ | KEY_WRITE));
                    if (pBag2) {
                        hr = p2->Save(pBag2, false, true);
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                } CATCHCOM();
        } else {
            PQPersistPropertyBag p(pV->punkVal);
            if (p) {
                CRegKey sk;
                DWORD rc = sk.Create(m_hk, OLE2CT(pszPropName), NULL, 0, KEY_READ | KEY_WRITE, NULL, NULL);
                if (rc != ERROR_SUCCESS) {
                    return HRESULT_FROM_WIN32(rc);
                }
                CLSID cl;
                hr = p->GetClassID(&cl);
                if (FAILED(hr)) {
                    return E_UNEXPECTED;
                }
                OLECHAR szClsid[64];
                rc = StringFromGUID2(cl, szClsid, sizeof(szClsid)/sizeof(OLECHAR));
                if (!rc) {
                    return E_UNEXPECTED;
                }
                rc = RegSetValue(sk, NULL, REG_SZ, OLE2T(szClsid), _tcslen(OLE2T(szClsid)) * sizeof(TCHAR));
                if (rc != ERROR_SUCCESS) {
                    return HRESULT_FROM_WIN32(rc);
                }
                try {
                    PQPropertyBag pBag(new CRegBag(sk, NULL, 0, KEY_READ | KEY_WRITE));
                    if (pBag) {
                        hr = p->Save(pBag, false, true);
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                } CATCHCOM();
            }
        }
        // rev2: support other persistence interfaces, esp stream via shopenregstream()
    }

    return hr;
}

// IPropertyBag
STDMETHODIMP CRegBagBase::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) {
    if (!pszPropName || !pVar) {
        return E_POINTER;
    }
	ATL_LOCK();
    DWORD dwType, cbSize = 64;
    BYTE data[64];
    LPBYTE pbData = data;
    USES_CONVERSION;
    HRESULT hr = RegQueryValueEx(m_hk, OLE2CT(pszPropName), NULL, &dwType, pbData, &cbSize);
    if (hr == ERROR_SUCCESS) {
        return RegConvertToVARIANT(pVar, dwType, pbData, cbSize);
    } else if (hr == ERROR_MORE_DATA) {
        cbSize += sizeof(TCHAR);
        pbData = new BYTE[cbSize];
        hr = RegQueryValueEx(m_hk, OLE2CT(pszPropName), NULL, &dwType, pbData, &cbSize);
        if (hr == ERROR_SUCCESS) {
            hr = RegConvertToVARIANT(pVar, dwType, pbData, cbSize);
            delete[] pbData;
            return hr;
        }
        delete[] pbData;
    }     
    // must be a key, so try the object
    CRegKey sk;
    hr = sk.Open(m_hk, OLE2CT(pszPropName), KEY_READ);
    if (hr != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(hr);
    }
    TCHAR pszclsid[80 * sizeof(TCHAR)];
    LONG dwSize = sizeof(pszclsid);
    hr = RegQueryValue(sk, NULL, pszclsid, &dwSize);
    if (hr != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(hr);
    }
    GUID clsid;
    hr = CLSIDFromString(T2OLE(pszclsid), &clsid);
    if (FAILED(hr)) {
        return E_FAIL;
    }
    switch (pVar->vt) {
    case VT_EMPTY:
    case VT_NULL:
        //DISPATCH is preferred if object supports it.  if not we'll convert back 
        // to unknown down below.
        pVar->vt = VT_DISPATCH;  
        pVar->pdispVal = NULL;
        break;
    case VT_DISPATCH:
    case VT_UNKNOWN:
        break;
    default:
        hr = VariantChangeType(pVar, pVar, 0, VT_DISPATCH);
        if (FAILED(hr)) {
            hr = VariantChangeType(pVar, pVar, 0, VT_UNKNOWN);
            if (FAILED(hr)) {
                return E_INVALIDARG;
            }
        }
    }
    PQPersistPropertyBag pPersistObj(((pVar->vt == VT_UNKNOWN) ? pVar->punkVal : pVar->pdispVal));
    hr = LoadPersistedObject<PQPropertyBag, PQPersistPropertyBag> (pPersistObj, clsid, pVar, m_hk, pszPropName, pErrorLog);
    if (FAILED(hr)) {
        PQPersistPropertyBag2 pPersistObj2(((pVar->vt == VT_UNKNOWN) ? pVar->punkVal : pVar->pdispVal));
        hr = LoadPersistedObject<PQPropertyBag2, PQPersistPropertyBag2> (pPersistObj2, clsid, pVar, m_hk, pszPropName, pErrorLog);
    }
    return hr;
}

STDMETHODIMP CRegBagBase::Write(LPCOLESTR pszPropName, VARIANT *pVar) {
    if (!pszPropName || !pVar) {
        return E_POINTER;
    }
	ATL_LOCK();

    HRESULT hrc;
    if (pVar->vt & VT_BYREF) {
        hrc = VariantChangeType(pVar, pVar, 0, pVar->vt & ~VT_BYREF);
        if (FAILED(hrc)) {
            return E_INVALIDARG;
        }
    }
    USES_CONVERSION;
    hrc = NOERROR;
    switch(pVar->vt) {
    case VT_I1: //fall thru
    case VT_I2: //fall thru
    case VT_I4: //fall thru
    case VT_UI1: //fall thru
    case VT_UI2: //change type and fall thru
    case VT_INT: //change type and fall thru
    case VT_UINT: //change type and fall thru
	case VT_BOOL: //change type and fall thru
        hrc = VariantChangeType(pVar, pVar, 0, VT_UI4);
        if (FAILED(hrc)) {
            return E_INVALIDARG;
        }
    case VT_UI4:  //REG_DWORD
        hrc = RegSetValueEx(
            m_hk, 
            OLE2CT(pszPropName),
            0,            // dwReserved
            REG_DWORD,
            reinterpret_cast<LPBYTE>(&pVar->ulVal),
            sizeof(pVar->ulVal));
        if (hrc != ERROR_SUCCESS) {
			return HRESULT_FROM_WIN32(hrc);
		}
        // make sure no old object exists
        DeleteSubKey(m_hk, pszPropName);
        break;

    case VT_BSTR: { //REG_SZ
		hrc = ERROR_SUCCESS;
        LPTSTR val = OLE2T(pVar->bstrVal);
		if (val) {
		    UINT len  = ::SysStringByteLen(pVar->bstrVal);
			hrc = RegSetValueEx(
				m_hk, 
				OLE2CT(pszPropName),
				0,            // dwReserved
				REG_SZ,
				reinterpret_cast<LPBYTE>(val), 
				len);
		}
        if (hrc == ERROR_SUCCESS) {
            // make sure no old object exists
            DeleteSubKey(m_hk, pszPropName);
        }
    } break;
#if 0
	// we're not actually going to enable this since REG_MULTI_SZ only exists on NT
	// if we had REG_MULTI_SZ on 9x then we'd have to loop over the hole block skipping embedded nulls and unicode/ansi convert the
	// entire vector of strings
	// instead we're just going to treat vectors of bstrs as binary blobs 
    case VT_VECTOR | VT_BSTR: { //REG_MULTI_SZ
		hrc = ERROR_SUCCESS;
        LPTSTR val = OLE2T(pVar->bstrVal);
		if (val) {
			UINT len = ::SysStringByteLen(pVar->bstrVal);
			hrc = RegSetValueEx(
				m_hk, 
				OLE2CT(pszPropName),
				0,            // dwReserved
				REG_MULTI_SZ,
				reinterpret_cast<LPBYTE>(val), 
				len);
		}
        if (hrc == ERROR_SUCCESS) {
            // make sure no old object exists
            DeleteSubKey(m_hk, pszPropName);
        }
    } break;
#else
	case VT_VECTOR | VT_BSTR: // fall-thru to array(REG_BINARY)
#endif
    case VT_BSTR_BLOB: { //REG_BINARY
		SIZE_T len  = 0;
		LPBYTE pData  = reinterpret_cast<LPBYTE>(pVar->bstrVal);
		if (pData) {
			len  = ::SysStringByteLen(pVar->bstrVal);
			hrc = RegSetValueEx(
				m_hk, 
				OLE2CT(pszPropName),
				0,            // dwReserved
				REG_BINARY,
				pData,
				len);
			if (hrc == ERROR_SUCCESS) {
				// make sure no old object exists
				DeleteSubKey(m_hk, pszPropName);
			}
		}
    } break;
    case VT_ARRAY | VT_UI1: { //REG_BINARY
		LPBYTE pData = NULL;
	    SIZE_T len = 0;
        if (pVar->parray) {
		    HRESULT hr = SafeArrayAccessData(pVar->parray, reinterpret_cast<LPVOID *>(&pData));
		    if (FAILED(hr)) {
			    return hr;
		    }
		    for (int i = pVar->parray->cDims; i--;) {
			    len += pVar->parray->rgsabound[i].cElements;
		    }
		    len *= pVar->parray->cbElements;
			hrc = RegSetValueEx(
				m_hk, 
				OLE2CT(pszPropName),
				0,            // dwReserved
				REG_BINARY,
				pData,
				len);
			if (hrc == ERROR_SUCCESS) {
				// make sure no old object exists
				DeleteSubKey(m_hk, pszPropName);
			}
			SafeArrayUnaccessData(pVar->parray);
        }
	} break;
    case VT_I8://change type and fall thru
        hrc = VariantChangeType(pVar, pVar, 0, VT_UI8);
        if (FAILED(hrc)) {
            return E_INVALIDARG;
        }
    case VT_UI8: //REG_QWORD
        hrc = RegSetValueEx(
            m_hk, 
            OLE2CT(pszPropName),
            0,            // dwReserved
            REG_QWORD,
            reinterpret_cast<LPBYTE>(&pVar->ullVal),
            sizeof(pVar->ullVal));
        if (hrc == ERROR_SUCCESS) {
            // make sure no old object exists
            DeleteSubKey(m_hk, pszPropName);
        }
        break;
    case VT_DISPATCH:
        hrc = VariantChangeType(pVar, pVar, 0, VT_UNKNOWN);
        if (FAILED(hrc)) {
            return E_UNEXPECTED;
        }
    case VT_UNKNOWN:
        DeleteValue(m_hk, pszPropName);
        hrc = SaveObject(m_hk, pszPropName, pVar);
        break;
    case VT_EMPTY:
    case VT_NULL:
        // remove from registry
        DeleteValue(m_hk, pszPropName);
        DeleteSubKey(m_hk, pszPropName);
        hrc = NOERROR;
        break;
    default: 
      hrc = E_INVALIDARG;
    }
    return hrc;
}


STDMETHODIMP CRegBag::CountProperties(ULONG * pcProperties) {
    if (!pcProperties) {
        return E_POINTER;
    }
	ATL_LOCK();
    if (!pcProperties) {
		return E_POINTER;
    }
    DWORD cKeys, cValues;
    DWORD rc = RegQueryInfoKey(m_hk, 
                               NULL, NULL, NULL,
                               &cKeys, NULL, NULL,
                               &cValues, NULL, NULL,
                               NULL, NULL);
    if (rc != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(rc);
    }
    *pcProperties = cKeys + cValues;
    return NOERROR;
}

STDMETHODIMP CRegBag::GetPropertyInfo(ULONG iProperty, ULONG cProperties, PROPBAG2* pPropBag, ULONG * pcProperties) {
    if (!pPropBag || !pcProperties) {
		return E_POINTER;
    }
	ATL_LOCK();
    memset(pPropBag, 0, sizeof(*pPropBag) * cProperties);
    // NOTE: since the registry functions don't provide a unified enumeration
    // of subkeys and values, we're just going to establish values as coming
    // before subkeys by definition.
    DWORD cKeys, cValues, cbMaxKeyName, cbMaxValueName, cbMaxValue;
    DWORD rc = RegQueryInfoKey(m_hk, 
                               NULL, NULL, NULL,
                               &cKeys, &cbMaxKeyName, NULL,
                               &cValues, &cbMaxValueName, &cbMaxValue,
                               NULL, NULL);
    if (rc != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(rc);
    }
    // nt doesn't return enough room for the terminating character
    // but these are still char counts not byte counts yet.
    ++cbMaxKeyName;
    ++cbMaxValueName;
        
    cbMaxKeyName *= sizeof(TCHAR);
    cbMaxValueName *= sizeof(TCHAR);
    // now they're real byte counts

    DWORD dwValIndex = 0, dwBagIndex = 0;
    USES_CONVERSION;
    if (iProperty < cValues) {
        LPTSTR pszName = new TCHAR[cbMaxValueName + 1];
        // we're starting with values
        for (;dwValIndex < cProperties; ++dwValIndex) {
            DWORD Type;
            DWORD cbName = cbMaxValueName + 1;
            rc = RegEnumValue(m_hk, dwValIndex, pszName, &cbName, NULL, &Type, NULL, NULL);
            if (rc != ERROR_SUCCESS) {
                break;
            }
            if (dwValIndex < iProperty) {
                continue;  // skip until we get to first requested
            }
            switch (Type) {
            case REG_DWORD:
                pPropBag[dwBagIndex].dwType = PROPBAG2_TYPE_DATA;
                pPropBag[dwBagIndex].vt = VT_UI4;
                break;
            case REG_QWORD:
                pPropBag[dwBagIndex].dwType = PROPBAG2_TYPE_DATA;
                pPropBag[dwBagIndex].vt = VT_UI8;
                break;
            case REG_SZ:
                pPropBag[dwBagIndex].dwType = PROPBAG2_TYPE_DATA;
                pPropBag[dwBagIndex].vt = VT_BSTR;
                pPropBag[dwBagIndex].cfType = CF_TEXT;
                break;
            default: // binary
                pPropBag[dwBagIndex].dwType = PROPBAG2_TYPE_DATA;
                pPropBag[dwBagIndex].vt = VT_UI1 | VT_ARRAY;
                break;
            }
            int len = sizeof(OLECHAR) * (_tcsclen(pszName) + 1);
            pPropBag[dwBagIndex].pstrName = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc(len + 1));
            if (!pPropBag[dwBagIndex].pstrName) {
                delete[] pszName;
                return E_OUTOFMEMORY;
            }
            (void)StringCchCopy(pPropBag[dwBagIndex].pstrName, len + 1, T2OLE(pszName));
            ++dwBagIndex;
        }
        delete[] pszName;
    }
    DWORD dwKeyIndex = 0;
    if (iProperty < cKeys + cValues) {
        LPTSTR pszName =  new TCHAR[cbMaxKeyName + 1];
        for (; (dwKeyIndex  + dwValIndex) < cProperties; ++dwKeyIndex) {
            DWORD cbName = cbMaxKeyName + 1;
            rc = RegEnumKeyEx(m_hk, dwKeyIndex, pszName, &cbName, NULL, NULL, NULL, NULL);
            if (rc != ERROR_SUCCESS) {
                break;
            }
            if ((dwValIndex + dwKeyIndex) < iProperty) {
                continue;
            }
            pPropBag[dwBagIndex].dwType = PROPBAG2_TYPE_OBJECT;
            pPropBag[dwBagIndex].vt = VT_UNKNOWN;

            int len = sizeof(OLECHAR) * (_tcsclen(pszName) + 1);
            pPropBag[dwBagIndex].pstrName = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc(len + 1));
            if (!pPropBag[dwBagIndex].pstrName) {
                delete[] pszName;
                return E_OUTOFMEMORY;
            }
            (void)StringCchCopy(pPropBag[dwBagIndex].pstrName, len + 1, T2OLE(pszName));
            ++dwBagIndex;
        }
        delete[] pszName;
    }
    *pcProperties = dwBagIndex;
    return NOERROR;
}

STDMETHODIMP CRegBag::LoadObject(LPCOLESTR pstrName, ULONG dwHint, IUnknown * pUnkObject, IErrorLog * pErrLog) {
    if (!pstrName  || !pUnkObject) {
        return E_POINTER;
    }
    VARIANT v;  // don't clear the variant, we're guaranteed nested lifetimes and
                // we're not addref'ing
    v.vt = VT_UNKNOWN;
    v.punkVal = pUnkObject;
    return Read(pstrName, &v, pErrLog);
}


STDMETHODIMP CCreateRegBag::Create(HKEY hkey, LPCOLESTR subkey, DWORD options, DWORD sam, REFIID iid, LPVOID* ppBag) {
    if (!ppBag) {
        return E_POINTER;
    }
	ATL_LOCK();
	if (ppBag == NULL)
		return E_POINTER;
    try {		
        USES_CONVERSION;
        if (iid == __uuidof(IPropertyBag)) {
            PQPropertyBag temp = new CRegBag(hkey, OLE2CT(subkey), options, sam);
            *ppBag = temp.Detach();
        } else if (iid == __uuidof(IPropertyBag2)) {
            PQPropertyBag2 temp = new CRegBag(hkey, OLE2CT(subkey), options, sam);
            *ppBag = temp.Detach();
        } else {
            return E_NOTIMPL;
        }
        if (!*ppBag) return E_OUTOFMEMORY;
        return NOERROR;
    } CATCHCOM();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\devices.h ===
//==========================================================================;
//
// Devices.h : Declaration of the CDevices
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef DEVICES_H_
#define DEVICES_H_

#include <vector>
#include <objectwithsiteimplsec.h>
#include "devseq.h"

#if 0
#define DEBUGREGISTRY
#endif

#ifdef DEBUGREGISTRY
#include <statreg.h>
#endif

void CtorStaticVWDevicesFwdSeqPMFs(void);
void DtorStaticVWDevicesFwdSeqPMFs(void);

template<class DEVICETYPECOLLECTIONINTERFACE, 
		 class DEVICETYPEINTERFACE, 
		 const CLSID* DEVICETYPE_CLSID, 
		 int IDSPROGID,
		 int IDSDESC> class CTypedDevices;

template<class DEVICETYPECOLLECTIONINTERFACE, class DEVICETYPEINTERFACE, const CLSID* DEVICETYPE_CLSID, int IDSPROGID, int IDSDESC> class ATL_NO_VTABLE CTypedDevicesBase : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, DEVICETYPEINTERFACE, DEVICETYPE_CLSID, IDSPROGID, IDSDESC>, DEVICETYPE_CLSID>,
	public ISupportErrorInfo,
    public IObjectWithSiteImplSec<CTypedDevicesBase>,
	public IDispatchImpl<DEVICETYPECOLLECTIONINTERFACE, &__uuidof(DEVICETYPECOLLECTIONINTERFACE), &LIBID_MSVidCtlLib>
{
public:

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTypedDevicesBase)
	COM_INTERFACE_ENTRY(DEVICETYPECOLLECTIONINTERFACE)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CTypedDevicesBase)
	IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
	IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
	IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{
		static const IID* arr[] = 
		{
			&__uuidof(DEVICETYPECOLLECTIONINTERFACE)
		};
		for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
		{
			if (InlineIsEqualGUID(*arr[i],riid))
				return S_OK;
		}
		return S_FALSE;
	}


virtual ~CTypedDevicesBase() {}

};

class CDevEnum;
/////////////////////////////////////////////////////////////////////////////
// CTypedDevices
template<class DEVICETYPECOLLECTIONINTERFACE, 
		 class DEVICETYPEINTERFACE, 
		 const CLSID* DEVICETYPE_CLSID, 
		 int IDSPROGID,
		 int IDSDESC> class CTypedDevices : 
	public CComObject<CTypedDevicesBase<DEVICETYPECOLLECTIONINTERFACE, DEVICETYPEINTERFACE, DEVICETYPE_CLSID, IDSPROGID, IDSDESC> >
{
	typedef CComQIPtr<DEVICETYPECOLLECTIONINTERFACE> PQDEVICETYPECOLLECTIONINTERFACE;
	typedef CComQIPtr<DEVICETYPEINTERFACE> PQDEVICETYPEINTERFACE;
	PQDEVICETYPECOLLECTIONINTERFACE m_Collection;
	bool m_fRO;
    bool m_fValid;
public:
	CTypedDevices(const DeviceCollection &Devices = DeviceCollection(), bool fRO = false, bool fValid = false) : 
		  m_fRO(fRO), m_fValid(fValid) {
		      m_Devices.clear();
			  m_Devices.insert(m_Devices.end(), Devices.begin(), Devices.end());
    }
	CTypedDevices(bool fRO, bool fValid = false) : 
		  m_Devices(DeviceCollection()), m_fRO(fRO), m_fValid(fValid) {}
	CTypedDevices(const CTypedDevices &src) : 
		  m_fRO(src.m_fRO), m_fValid(src.m_fValid) {
		      m_Devices.clear();
			  m_Devices.insert(m_Devices.end(), src.m_Devices.begin(), src.m_Devices.end());
    }
	CTypedDevices(const PQDEVICETYPECOLLECTIONINTERFACE& src) : 
		  m_fRO(static_cast<CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, 
                                          DEVICETYPEINTERFACE, 
                                          DEVICETYPE_CLSID,  
                                          IDSPROGID, 
                                          IDSDESC> *>(src.p)->m_fRO),
		  m_fValid(static_cast<CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, 
                                             DEVICETYPEINTERFACE, 
                                             DEVICETYPE_CLSID,  
                                             IDSPROGID, 
                                             IDSDESC> *>(src.p)->m_fValid) {
		      m_Devices.clear();
			  m_Devices.insert(m_Devices.end(),
                        static_cast<CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, 
                                             DEVICETYPEINTERFACE, 
                                             DEVICETYPE_CLSID,  
                                             IDSPROGID, 
                                             IDSDESC> *>(src.p)->m_Devices.begin(), 
                        static_cast<CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, 
                                             DEVICETYPEINTERFACE, 
                                             DEVICETYPE_CLSID,  
                                             IDSPROGID, 
                                             IDSDESC> *>(src.p)->m_Devices.end()
                        );
    }
	CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, DEVICETYPEINTERFACE, DEVICETYPE_CLSID,  IDSPROGID, IDSDESC> &operator=(const CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, DEVICETYPEINTERFACE, DEVICETYPE_CLSID, IDSPROGID, IDSDESC> &rhs) {
		if (this != &rhs) {
			m_Devices.clear();
			m_Devices.insert(m_Devices.end(), rhs.m_Devices.begin(), rhs.m_Devices.end());
			m_fRO = rhs.m_fRO;
			m_fValid = rhs.m_fValid;
		}

	}

	virtual ~CTypedDevices() {
	}

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {
		CRegObject ro;
		return CObjRegHelp::RegisterAutomationClass(bRegister ? true : false, 
												    ro, 
												    IDS_PROJNAME,
												    IDSPROGID, 
												    IDSDESC, 
												    *DEVICETYPE_CLSID,
												    LIBID_MSVidCtlLib);
	}

// IMSVidDevices
public:
	inline bool IsRO() { return m_fRO; }
    inline bool GetValid() { return m_fValid; }
    inline void SetValid(bool fValid) { m_fValid = fValid; }
    __declspec(property(get=GetValid, put=SetValid)) bool Valid;
	DeviceCollection m_Devices;
// IMSVidDevices
	STDMETHOD(get_Count)(LONG * lCount)
	{
		if (lCount == NULL)
			return E_POINTER;
			
		try {
			*lCount = m_Devices.size();
		} catch(...) {
			return E_POINTER;
		}
		return NOERROR;
	}

	STDMETHODIMP get__NewEnum(IEnumVARIANT * * pD)
	{
		if (pD == NULL)
			return E_POINTER;
			
		PQEnumVARIANT temp;
		try {
			temp = new CDevEnum(PQDispatch(this), m_Devices);
		} catch(...) {
			return E_OUTOFMEMORY;
		}
		try {
			*pD = temp.Detach();
		} catch(...) {
			return E_POINTER;
		}
		return NOERROR;
	}

	STDMETHOD(get_Item)(VARIANT v, DEVICETYPEINTERFACE * * pDB)
	{
		if (pDB == NULL)
			return E_POINTER;
		int idx;
		CComVariant vidx;
		try {
			if (SUCCEEDED(vidx.ChangeType(VT_I4, &v))) {
				idx = vidx.lVal;
			} else {
				return DISP_E_TYPEMISMATCH;
			}
			if (idx >= m_Devices.size()) {
				return DISP_E_BADINDEX;
			}
		} catch(...) {
			return E_UNEXPECTED;
		}
		try {
            PQDevice pd(m_Devices[idx]);
            if (!pd) {
                return E_UNEXPECTED;
            }
			*pDB = PQDEVICETYPEINTERFACE(pd);
            if (!*pDB) {
                return E_UNEXPECTED;
            }
            (*pDB)->AddRef();
		} catch(...) {
			return E_POINTER;
		}
			
		return NOERROR;
	}
	STDMETHOD(Add)(DEVICETYPEINTERFACE * pDB)
	{
		if (m_fRO) {
			return Error(IDS_E_ROCOLLECTION, __uuidof(DEVICETYPECOLLECTIONINTERFACE), E_ACCESSDENIED);
		}
		try {
			PQDevice p(pDB);
			try {
				m_Devices.push_back(p);
			} catch(...) {
				return E_OUTOFMEMORY;
			}
		} catch(...) {
			E_POINTER;
		}

		return NOERROR;
	}
	STDMETHOD(Remove)(VARIANT v)
	{
		if (m_fRO) {
			return E_ACCESSDENIED;
		}

		int idx;
		CComVariant vidx;
		try {
			if (SUCCEEDED(vidx.ChangeType(VT_I4, &v))) {
				idx = vidx.lVal;
			} else {
				return DISP_E_TYPEMISMATCH;
			}
			if (idx >= m_Devices.size()) {
				return DISP_E_BADINDEX;
			}

			m_Devices.erase(m_Devices.begin() + idx);
		} catch(...) {
			return E_UNEXPECTED;
		}
			
		return NOERROR;
	}
};

typedef CTypedDevices<IMSVidInputDevices, IMSVidInputDevice, &CLSID_MSVidInputDevices, IDS_INPUTDEVICES_PROGID, IDS_INPUTDEVICES_DESCRIPTION> CInputDevices;
typedef CTypedDevices<IMSVidOutputDevices, IMSVidOutputDevice, &CLSID_MSVidOutputDevices, IDS_OUTPUTDEVICES_PROGID, IDS_OUTPUTDEVICES_DESCRIPTION> COutputDevices;
typedef CTypedDevices<IMSVidVideoRendererDevices, IMSVidVideoRenderer, &CLSID_MSVidVideoRendererDevices, IDS_VIDEORENDERERS_PROGID, IDS_VIDEORENDERERS_DESCRIPTION> CVideoRendererDevices;
typedef CTypedDevices<IMSVidAudioRendererDevices, IMSVidAudioRenderer, &CLSID_MSVidAudioRendererDevices, IDS_AUDIORENDERERS_PROGID, IDS_AUDIORENDERERS_DESCRIPTION> CAudioRendererDevices;
typedef CTypedDevices<IMSVidFeatures, IMSVidFeature, &CLSID_MSVidFeatures, IDS_FEATURES_PROGID, IDS_FEATURES_DESCRIPTION> CFeatures;

/////////////////////////////////////////////////////////////////////////////
// CDevEnum
class ATL_NO_VTABLE CDevEnumBase : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IObjectWithSiteImplSec<CDevEnumBase>,
	public IEnumVARIANT
{
BEGIN_COM_MAP(CDevEnumBase)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()
DECLARE_PROTECT_FINAL_CONSTRUCT()

virtual ~CDevEnumBase() {}
};

/////////////////////////////////////////////////////////////////////////////
class CDevEnum : public CComObject<CDevEnumBase>
{
public:
	CDevEnum(const PQDispatch& pDevices, DeviceCollection& dci) : 
		m_pDevices(pDevices), m_DC(dci), i(dci.begin()) {}
	CDevEnum(const CDevEnum &orig) : 
		m_pDevices(orig.m_pDevices), m_DC(orig.m_DC), i(orig.i) {}
    virtual ~CDevEnum() {}

// IDevEnum
public:
	PQDispatch m_pDevices;
	DeviceCollection& m_DC;
	DeviceCollection::iterator i;
// IEnumVARIANT
	STDMETHOD(Next)(ULONG celt, VARIANT * rgvar, ULONG * pceltFetched)
	{
		// pceltFetched can legally == 0
		//
		if (pceltFetched != NULL) {
			try {
				*pceltFetched = 0;
			} catch(...) {
				return E_POINTER;
			}
		}

		for (ULONG l=0; l < celt; l++) {
			try {
				VariantInit( &rgvar[l] ) ;
			} catch(...) {
				return E_POINTER;
			}
		}

		// Retrieve the next celt elements.
		HRESULT hr = NOERROR ;
		for (l = 0;i != m_DC.end() && celt != 0 ; ++i, ++l, --celt) {
			rgvar[l].vt = VT_DISPATCH ;
			rgvar[l].pdispVal = PQDevice(*i).Detach();
			if (pceltFetched != NULL) {
				(*pceltFetched)++ ;
			}
		}

		if (celt != 0) {
		   hr = ResultFromScode( S_FALSE ) ;
		}

		return hr ;
	}
	STDMETHOD(Skip)(ULONG celt)
	{
		for (;i != m_DC.end() && celt--; ++i);
		return (celt == 0 ? NOERROR : ResultFromScode( S_FALSE )) ;
	}
	STDMETHOD(Reset)()
	{
		i = m_DC.begin();
		return NOERROR;
	}
	STDMETHOD(Clone)(IEnumVARIANT * * ppenum)
	{
		if (ppenum == NULL)
			return E_POINTER;
		PQEnumVARIANT temp;
		try {
			temp = new CDevEnum(*this);
		} catch(...) {
			return E_OUTOFMEMORY;
		}
		try {
			*ppenum = temp.Detach();
		} catch(...) {
			return E_POINTER;
		}
		return NOERROR;
	}
};

#endif 
//end of file devices.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\dvbslocator.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBSLocator.cpp : Implementation of CDVBSLocator
// Copyright (c) Microsoft Corporation 1999-2000.

#include "stdafx.h"
#include "Tuner.h"
#include "DVBSLocator.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_DVBSLocator, CDVBSLocator)

/////////////////////////////////////////////////////////////////////////////
// CDVBSLocator

STDMETHODIMP CDVBSLocator::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IDVBSLocator
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\dlldatax.c ===
/*********************************************************
   DllData file -- partially generated by MIDL compiler 

  we are building the .idls over in published but we want the actual proxy stub to live in
  msvidctl.dll *not* quartz.dll 
  this is because registering the typelibs wipes out the proxy stub registration and
  we want to avoid any registration order dependencies.  so , we must register the proxy/stubs in 
  the vidctl after the typelib registration and it wouldn't be good to do it in both places and
  make quartz.dll unecessarily larger.

  consequently, we are manually maintaining this file.  if you add a new .idl to the vidctl you
  must update these entries

  for simplicity sake since we know we're always merging the proxy stub we're combining dlldata.c and
  dlldatax.c as well.

*********************************************************/


#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow


//#include "dlldata.c" as follows...

// wrapper for dlldata.c
#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

#define USE_STUBLESS_PROXY

EXTERN_PROXY_FILE( regbag )
EXTERN_PROXY_FILE( tuner )
#ifndef TUNING_MODEL_ONLY
    EXTERN_PROXY_FILE( segment )
    EXTERN_PROXY_FILE( msvidctl )
#endif


PROXYFILE_LIST_START
    REFERENCE_PROXY_FILE( regbag ),
    REFERENCE_PROXY_FILE( tuner ),
#ifndef TUNING_MODEL_ONLY
        REFERENCE_PROXY_FILE( segment ),
        REFERENCE_PROXY_FILE( msvidctl ),
#endif
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldatax.c file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\dvbslocator.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBSLocator.h : Declaration of the CDVBSLocator
// Copyright (c) Microsoft Corporation 2000.

#ifndef __DVBSLOCATOR_H_
#define __DVBSLOCATOR_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "DVBSlocatorimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CDVBSLocator
class ATL_NO_VTABLE __declspec(uuid("1DF7D126-4050-47f0-A7CF-4C4CA9241333"))CDVBSLocator : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDVBSLocator, &CLSID_DVBSLocator>,
    public IObjectWithSiteImplSec<CDVBSLocator>,
	public IDVBSLocatorImpl<CDVBSLocator>,
	public ISupportErrorInfo
{
public:
    CDVBSLocator() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_DVBSLOCATOR_PROGID, 
						   IDS_REG_DVBSLOCATOR_DESC,
						   LIBID_TunerLib,
						   CLSID_DVBSLocator, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVBSLocator)
	COM_INTERFACE_ENTRY(IDVBSLocator)
	COM_INTERFACE_ENTRY(ILocator)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CDVBSLocator)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CDVBSLocator)
        CHAIN_PROP_MAP(IDVBSLocatorImpl<CDVBSLocator>)
    END_PROPERTY_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

typedef CComQIPtr<IDVBSLocator> PQDVBSLocator;

#endif //__DVBSLOCATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\dvbsts.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBSTS.h : Declaration of the CDVBSTS
// Copyright (c) Microsoft Corporation 1999.

#ifndef __DVBSTS_H_
#define __DVBSTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "dvbstsimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CDVBSTS
class ATL_NO_VTABLE __declspec(uuid("B64016F3-C9A2-4066-96F0-BD9563314726")) CDVBSTS : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDVBSTS, &__uuidof(CDVBSTS)>,
    public IObjectWithSiteImplSec<CDVBSTS>,
	public IDVBSTuningSpaceImpl<CDVBSTS>
{
public:
    CDVBSTS() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_DVBSTUNINGSPACE_PROGID, 
						   IDS_REG_DVBSTUNINGSPACE_DESC,
						   LIBID_TunerLib,
						   __uuidof(CDVBSTS), tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVBSTS)
    COM_INTERFACE_ENTRY(IDVBSTuningSpace)
    COM_INTERFACE_ENTRY(IDVBTuningSpace2)
    COM_INTERFACE_ENTRY(IDVBTuningSpace)
    COM_INTERFACE_ENTRY(ITuningSpace)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMPEG2TuneRequestSupport)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CDVBSTS)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

public:

    typedef IDVBSTuningSpaceImpl<CDVBSTS> basetype;
    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CDVBSTS)
        CHAIN_PROP_MAP(basetype)
    END_PROPERTY_MAP()

};

#endif //__DVBSTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\dlldatax.h ===
//
//
//
#if !defined(AFX_DLLDATAX_H__CC62DDF2_925F_4B29_BEFD_13EE1E7BEB70__INCLUDED_)
#define AFX_DLLDATAX_H__CC62DDF2_925F_4B29_BEFD_13EE1E7BEB70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif // !defined(AFX_DLLDATAX_H__CC62DDF2_925F_4B29_BEFD_13EE1E7BEB70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\dvbtlocator.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTLocator.h : Declaration of the CDVBTLocator
// Copyright (c) Microsoft Corporation 2000.

#ifndef __DVBTLOCATOR_H_
#define __DVBTLOCATOR_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "DVBTlocatorimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CDVBTLocator
class ATL_NO_VTABLE __declspec(uuid("9CD64701-BDF3-4d14-8E03-F12983D86664"))CDVBTLocator : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDVBTLocator, &CLSID_DVBTLocator>,
    public IObjectWithSiteImplSec<CDVBTLocator>,
	public IDVBTLocatorImpl<CDVBTLocator>,
	public ISupportErrorInfo
{
public:
    CDVBTLocator() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_DVBTLOCATOR_PROGID, 
						   IDS_REG_DVBTLOCATOR_DESC,
						   LIBID_TunerLib,
						   CLSID_DVBTLocator, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVBTLocator)
	COM_INTERFACE_ENTRY(IDVBTLocator)
	COM_INTERFACE_ENTRY(ILocator)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CDVBTLocator)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CDVBTLocator)
        CHAIN_PROP_MAP(IDVBTLocatorImpl<CDVBTLocator>)
    END_PROPERTY_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

typedef CComQIPtr<IDVBTLocator> PQDVBTLocator;

#endif //__DVBTLOCATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\dvbtlocator.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTLocator.cpp : Implementation of CDVBTLocator
// Copyright (c) Microsoft Corporation 1999-2000.

#include "stdafx.h"
#include "Tuner.h"
#include "DVBTLocator.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_DVBTLocator, CDVBTLocator)

/////////////////////////////////////////////////////////////////////////////
// CDVBTLocator

STDMETHODIMP CDVBTLocator::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IDVBTLocator
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\dvbts.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTS.h : Declaration of the CDVBTS
// Copyright (c) Microsoft Corporation 1999.

#ifndef __DVBTS_H_
#define __DVBTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "dvbtsimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CDVBTS
class ATL_NO_VTABLE __declspec(uuid("C6B14B32-76AA-4a86-A7AC-5C79AAF58DA7")) CDVBTS : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDVBTS, &__uuidof(CDVBTS)>,
    public IObjectWithSiteImplSec<CDVBTS>,
	public IDVBTuningSpaceImpl<CDVBTS>
{
public:
    CDVBTS() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_DVBTUNINGSPACE_PROGID, 
						   IDS_REG_DVBTUNINGSPACE_DESC,
						   LIBID_TunerLib,
						   __uuidof(CDVBTS), tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVBTS)
    COM_INTERFACE_ENTRY(IDVBTuningSpace2)
    COM_INTERFACE_ENTRY(IDVBTuningSpace)
    COM_INTERFACE_ENTRY(ITuningSpace)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMPEG2TuneRequestSupport)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CDVBTS)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

public:

    typedef IDVBTuningSpaceImpl<CDVBTS> basetype;
    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CDVBTS)
        CHAIN_PROP_MAP(basetype)
    END_PROPERTY_MAP()

};

#endif //__DVBTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\fileplaybackcp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _MSVIDFILEPLAYBACKCP_H_
#define _MSVIDFILEPLAYBACKCP_H_

template <class T, const IID* piid = &IID_IMSVidFilePlaybackEvent, class CDV = CComDynamicUnkArray>
class CProxy_FilePlaybackEvent : public CProxy_PlaybackEvent<T, piid, CDV>
{
public:

// TODO: add fileplayback specific events here	
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\factoryhelp.h ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// factoryhelp.h - helper class for creating vidctl instances from a variety of factories including element
// behavior factories and pluggable protocols

#include "atlbase.h"

typedef CComQIPtr<ICreatePropBagOnRegKey> PQCreatePropBagOnRegKey;
typedef CComQIPtr<IWebBrowserApp> PQWebBrowserApp;
typedef CComQIPtr<IWebBrowser2> PQWebBrowser2;

#define RBFACTORY_DEFAULT_KEY OLESTR("Software\\Microsoft\\MSVidCtl")
#define PROPNAME_DEFAULT_TR OLESTR("DefaultTuneRequest")

LPCOLESTR __declspec(selectany) BIND_TO_OBJ_VAL = OLESTR("TRUE");
LPOLESTR __declspec(selectany) KEY_CLSID_VidCtl = OLESTR("B0EDF163-910A-11D2-B632-00C04F79498E");
LPCOLESTR __declspec(selectany) TVPROT_SCHEME_NAME = OLESTR("tv");
LPCOLESTR __declspec(selectany) DVDPROT_SCHEME_NAME = OLESTR("dvd");

class CFactoryHelper {
public:
    static CComVariant GetDefaultTR() {
	    PQPropertyBag pBag;
	    PQCreatePropBagOnRegKey pCreateBag(CLSID_CreatePropBagOnRegKey, NULL, CLSCTX_INPROC_SERVER);
	    if (!pCreateBag) {
		    TRACELM(TRACE_ERROR, "can't create prop bag");
		    return CComVariant();
	    }
	    HRESULT hr = pCreateBag->Create(HKEY_CURRENT_USER, RBFACTORY_DEFAULT_KEY, 0, KEY_READ, IID_IPropertyBag, reinterpret_cast<LPVOID *>(&pBag));
	    if (FAILED(hr)) {
		    TRACELSM(TRACE_ERROR, (dbgDump << "No Default Tune Request Key Present.  hr = " << hr), "");
		    return CComVariant();
	    }
	    CComVariant pVar;
	    hr = pBag->Read(PROPNAME_DEFAULT_TR, &pVar, NULL);
	    if (FAILED(hr) || (pVar.vt != VT_UNKNOWN && pVar.vt != VT_DISPATCH)) {
		    TRACELSM(TRACE_ERROR, (dbgDump << "No Default Tune Request Property Present.  hr = " << hr), "");
		    return CComVariant();
	    }
	    PQTuningSpace pts;
	    PQTuneRequest ptr(pVar.vt == VT_UNKNOWN ? pVar.punkVal : pVar.pdispVal);
	    if (!ptr) {
		    TRACELSM(TRACE_ERROR, (dbgDump << PROPNAME_DEFAULT_TR << " not a tune request"), "");
		    return CComVariant();
	    }
	    hr = ptr->get_TuningSpace(&pts);
	    if (FAILED(hr) || !pts) {
		    TRACELSM(TRACE_ERROR, (dbgDump << "Can't get ts from tr " << hr), "");
		    return CComVariant();
	    }
	    
	    return pVar;
    }
};

// end of file factoryhelp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\dvbtunerequest.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTuneRequest.cpp : Implementation of CDVBTuneRequest
// Copyright (c) Microsoft Corporation 1999-2000.

#include "stdafx.h"
#include "Tuner.h"
#include "DVBTuneRequest.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_DVBTuneRequest, CDVBTuneRequest)

/////////////////////////////////////////////////////////////////////////////
// CDVBTuneRequest

STDMETHODIMP CDVBTuneRequest::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IDVBTuneRequest
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\enc2sin.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing encoder to sbe sink
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef ENC2SIN_H
#define ENC2SIN_H

#pragma once
#include <uuids.h>
#include "bdamedia.h"
#include "MSVidTVTuner.h"
#include "resource.h"       // main symbols
#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include "msvidsbesource.h"
#include "segment.h"

/////////////////////////////////////////////////////////////////////////////
// Helper functions
HRESULT CheckIfSecureClient(IUnknown *pUnk){
        if(!pUnk){ 
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckIfSecureClient NULL pointer");
            return E_POINTER;
        }
#ifndef BUILD_WITH_DRM
        TRACELM(TRACE_ERROR, "CAnaSinComp::CheckIfSecureClient BUILD_WITH_DRM = false");
        return S_OK;

#else

#ifdef USE_TEST_DRM_CERT
        {
            DWORD dwDisableDRMCheck = 0;
            CRegKey c;
            CString keyname(_T("SOFTWARE\\Debug\\MSVidCtl"));
            DWORD rc = c.Open(HKEY_LOCAL_MACHINE, keyname, KEY_READ);
            if (rc == ERROR_SUCCESS) {
                rc = c.QueryValue(dwDisableDRMCheck, _T("DisableDRMCheck"));
                if (rc != ERROR_SUCCESS) {
                    dwDisableDRMCheck = 0;
                }
            }

            if(dwDisableDRMCheck == 1){
                return S_OK;
            }
        }
#endif
        // QI for the SecureChannel interface on the Punk 
        // (hopefully the ETFilter)
        HRESULT hr = S_OK;
        CComQIPtr<IDRMSecureChannel> spSecureClient(pUnk);
        if (!spSecureClient) {
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckIfSecureClient Passed in pUnk doesnt support IDRMSecureChannel");
            // Error: Passed in pUnk doesnt support IDRMSecureChannel
            return E_NOINTERFACE;
        }

        // Create the Server side and Init the keys/certs
        CComPtr<IDRMSecureChannel>  spSecureServer; 
        hr = DRMCreateSecureChannel( &spSecureServer);
        if(spSecureServer == NULL ){
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckIfSecureClient Cannot create secure server");
            return E_OUTOFMEMORY;
        }

        hr = spSecureServer->DRMSC_AtomicConnectAndDisconnect(
            (BYTE *)pabCert2, cBytesCert2,                             // Cert
            (BYTE *)pabPVK2,  cBytesPVK2,                              // PrivKey
            (BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot),        // PubKey
            spSecureClient);
        if(FAILED(hr)){
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckIfSecureClient DRMSC_AtomicConnectAndDisconnect failed " << hr);
        }
        else{
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckIfSecureClient DRMSC_AtomicConnectAndDisconnect Succeeded");
        }
        return hr;

#endif  // BUILD_WITH_DRM

    }

/////////////////////////////////////////////////////////////////////////////
// CEnc2SinComp
class ATL_NO_VTABLE __declspec(uuid("A0B9B497-AFBC-45ad-A8A6-9B077C40D4F2")) CEnc2SinComp : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CEnc2SinComp, &__uuidof(CEnc2SinComp)>,
    public IObjectWithSiteImplSec<CEnc2SinComp>,
    public IMSVidCompositionSegmentImpl<CEnc2SinComp>
{
private:
    DSFilterList m_pEncFilters;
public:
    CEnc2SinComp() {}
    virtual ~CEnc2SinComp() {}
    
    REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_ENC2SINCOMP_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CEnc2SinComp));
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()
        
    BEGIN_COM_MAP(CEnc2SinComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()
        
        // IMSVidComposition
public:
    // IMSVidGraphSegment
    // IMSVidCompositionSegment
    STDMETHOD(CheckEncFilters)(){
        int j = 0;
        for(DSFilterList::iterator i = m_pEncFilters.begin(); i != m_pEncFilters.end(); ++i){
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters checking filter " << j);
            CComQIPtr<IETFilterConfig> spETConfig;
            CComPtr<IUnknown> spUnkSecChan;
            spETConfig = (*i);
            if(!spETConfig){
                TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters filter " << j << " could not get et filter config interface");
				return E_NOINTERFACE;
			}            
            HRESULT hr = spETConfig->GetSecureChannelObject(&spUnkSecChan);   
            hr = CheckIfSecureClient(spUnkSecChan);
            if(FAILED(hr)){
                TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters filter " << j << " Failed");
                return E_FAIL;
            }
            ++j;
        }
        TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters no failures");
        return NOERROR;
    }

    STDMETHOD(PreRun)(){
        return CheckEncFilters();
    }

    STDMETHOD(OnEventNotify)(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2){
        if (lEvent == EC_STATE_CHANGE && lParam1 == State_Running) {
            TRACELM(TRACE_ERROR, "CAnaSinComp::OnEventNotify State_Running Event");
            HRESULT hr = CheckEncFilters();
            if(FAILED(hr)){
                TRACELM(TRACE_ERROR, "CAnaSinComp::OnEventNotify CheckEncFilters Failed");
                // need to throw a cert failure
                CComQIPtr<IMSVidCtl> pq_vidCtl;
                if(!m_pContainer){
                    return S_OK;
                }
                else{
                    hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pq_vidCtl));
                    if(SUCCEEDED(hr) && pq_vidCtl){
                        pq_vidCtl->Stop();
                    }
                    CComQIPtr<IMSVidStreamBufferSinkEvent>pq_SBESink;
                    VWOutputDevices pq_dev;
                    hr = pq_vidCtl->get_OutputsActive(&pq_dev);
                    if(FAILED(hr)){
                        return hr;
                    }
                    VWOutputDevices::iterator i;
                    for(i = pq_dev.begin(); i != pq_dev.end(); ++i){
                        pq_SBESink = (*i).punkVal;
                        if(pq_SBESink){
                            break;
                        }
                    }

                    if(i != pq_dev.end() && pq_SBESink){
                        pq_SBESink->CertificateFailure();
                    }
                }
            }
        }
        return E_NOTIMPL;
    }
    STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl) {
        try {
            if (!pCtl) {
                m_pEncFilters.clear();
                return Unload();
            }
            if (m_pContainer) {
				if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
					//undone: support moving to different graph
					return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidGraphSegment), CO_E_ALREADYINITIALIZED);
				} else {
					return NO_ERROR;
				}
            }
            // DON'T addref the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            m_pContainer.p = pCtl;
            m_pGraph = m_pContainer.GetGraph();
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
    {
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            VIDPERF_FUNC;
            TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose()");
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
            
            CMSVidStreamBufferSink* ds = (CMSVidStreamBufferSink*)downstream;
            DSFilter pSink(ds->m_Filters[0]);
            
            CComQIPtr<IMSVidEncoder> qiEnc(upstream);
            CEncoder* iEnc;
            iEnc = static_cast<CEncoder*>(qiEnc.p);
            DSPin pVidPin;
            DSPin pAudPin;
            DSPin genVidPin;
            DSPin genAudPin;
            CString csName;
            // render demux out to vr
            DSFilter pDeMux = iEnc->m_Filters[iEnc->m_iDemux];
            DSFilter::iterator iVidPin;
            DSFilter vr;
            DSMediaType mtVideo(MEDIATYPE_Video, MEDIASUBTYPE_MPEG2_VIDEO, FORMAT_MPEG2Video);
            DSMediaType mtAudio(MEDIATYPE_Audio, MEDIASUBTYPE_MPEG1Payload, FORMAT_WaveFormatEx);
            DSMediaType genericVideo(MEDIATYPE_Video);
            DSMediaType genericAudio(MEDIATYPE_Audio);
            for (iVidPin = pDeMux.begin(); iVidPin != pDeMux.end(); ++iVidPin) {
                DSPin::iterator j;
                for(j = (*iVidPin).begin(); j != (*iVidPin).end(); ++j){
                    DSMediaType pinType(*j);
                    if (pinType == mtVideo){
                        CComPtr<IUnknown> spMpeg2Analyze(CLSID_Mpeg2VideoStreamAnalyzer, NULL, CLSCTX_INPROC_SERVER);
                        if (!spMpeg2Analyze) {
                            //TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidStreamBufferSink::Build() can't load Time Shift Sink");
                            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
                        }
                        spMpeg2Analyze->QueryInterface(IID_IBaseFilter, reinterpret_cast<void**>(&vr));
                        if (!vr) {
                            ASSERT(false);
                            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
                        }
                        m_Filters.push_back(vr);
                        csName = _T("Mpeg2 Analysis");
                        m_pGraph.AddFilter(vr, csName);
                        DSFilter::iterator a;
                        for(a = vr.begin(); a != vr.end(); ++a){
                            HRESULT hr = (*a).Connect(*iVidPin);
                            if(FAILED(hr)){
                                continue;
                            }
                            else{
                                break;
                            }
                        }
                        if(a == vr.end()){
                            return E_FAIL;
                        }
                        for(a = vr.begin(); a != vr.end(); ++a){
                            if((*a).GetDirection() == PINDIR_OUTPUT){
                                pVidPin = (*a); 
                            }
                        }
                        if(!pVidPin){
                            return E_FAIL;
                        }
                    }
                    else if(pinType == mtAudio){
                        pAudPin = (*iVidPin);
                    }
                    else if(pinType == genericVideo){
                        genVidPin = (*iVidPin);
                    }
                    else if(pinType == genericAudio){
                        genAudPin = (*iVidPin);
                    }
                }
                if(!!pVidPin && !!pAudPin){
                    break;
                }
            }
            if(!pVidPin){
                pVidPin = genVidPin;
            }
            if(!pAudPin){
                pAudPin = genAudPin;
            }
            if(!pVidPin){
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't find video pin on demux");
                return E_UNEXPECTED;  
            }
            if(!pAudPin){
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't find audio pin on demux");
                return E_UNEXPECTED;  
            }

            DSFilterList intermediates;
            HRESULT hr = S_OK;
            DSFilter::iterator fil;

#if ENCRYPT_NEEDED
            CComBSTR encString(L"{C4C4C4F1-0049-4E2B-98FB-9537F6CE516D}");
            GUID2 encdecGuid (encString);

            // Create and add to graph the Video Tagger Filter                
            CComPtr<IUnknown> spEncTagV(encdecGuid, NULL, CLSCTX_INPROC_SERVER);
            if (!spEncTagV) {
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSink::Build() can't load Tagger filter");
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), VFW_E_CERTIFICATION_FAILURE);
            }
            
            DSFilter vrV(spEncTagV);
            if (!vrV) {
                ASSERT(false);
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() on tagger interface");
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_NOINTERFACE);
            }
            m_pEncFilters.push_back(vrV);
            m_Filters.push_back(vrV);
            csName = _T("Video Encoder Tagger Filter");
            m_pGraph.AddFilter(vrV, csName);
            
            // Connect video pin to Tagger
            hr = pVidPin.IntelligentConnect(vrV, intermediates);
            if(FAILED(hr)){
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect audio pin to Audio Tagger");
                return E_UNEXPECTED;  
            }

            // Connect Video to Sink
            DSFilter::iterator vP;
            hr = E_FAIL;
            for(vP = vrV.begin(); vP != vrV.end(); ++ vP){
                if((*vP).GetDirection() == PINDIR_OUTPUT){
                    break;   
                }
            }
            if(vP == vrV.end()){
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() not video output pin");
                return E_UNEXPECTED;
            }
            for(fil = pSink.begin(); fil != pSink.end() && FAILED(hr); ++fil){
                hr = (*vP).Connect((*fil));
            }
            if(FAILED(hr)){
                
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Video Tagger to Sink");
                return E_UNEXPECTED;  
            }

            // Create and add to graph the Audio Tagger Filter 
            CComPtr<IUnknown> spEncTagA(encdecGuid, NULL, CLSCTX_INPROC_SERVER);
            if (!spEncTagA) {
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSink::Build() can't load Tagger filter");
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), VFW_E_CERTIFICATION_FAILURE);
            }
            
            DSFilter vrA(spEncTagA);
            if (!vrA) {
                ASSERT(false);
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't create audio tagger filter");
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_NOINTERFACE);
            }
            m_pEncFilters.push_back(vrV);
            m_Filters.push_back(vrA);
            csName = _T("Audio Encoder Tagger Filter");
            m_pGraph.AddFilter(vrA, csName);
            
            // Connect audio pin to the Tagger
            hr = pAudPin.IntelligentConnect(vrA, intermediates);
            if(FAILED(hr)){
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect audio pin to Audio Tagger");
                return E_UNEXPECTED;  
            }
            
            // Connect Tagger to Sink
            hr = E_FAIL;
            for(vP = vrA.begin(); vP != vrA.end(); ++ vP){
                if((*vP).GetDirection() == PINDIR_OUTPUT){
                    break;   
                }
            }
            if(vP == vrA.end()){
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() no audio tagger pin");
                return E_UNEXPECTED;
            }
            for(fil = pSink.begin(); fil != pSink.end() && FAILED(hr); ++fil){
                hr = (*vP).Connect((*fil));
            }
            if(FAILED(hr)){
                
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Audio Tagger to Sink");
                return E_UNEXPECTED;  
            }


#else
            // Connect the Video Pin to the sink
            DSFilter::iterator vidAnaPin;
            hr = E_FAIL;
            hr = E_FAIL;
            for(fil = pSink.begin(); fil != pSink.end() && FAILED(hr); ++fil){
                if((*fil).GetDirection() == PINDIR_INPUT && !(*fil).IsConnected()){
                    hr = pVidPin.Connect((*fil));
                }
            }

            if(FAILED(hr)){         
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Video Tagger to Sink");
                ASSERT((L"Can't Connect vid to sink", FALSE));
                return E_UNEXPECTED;  
            }
            
            // Connect the Audio Pin to the Sink
            hr = E_FAIL;
            for(fil = pSink.begin(); fil != pSink.end() && FAILED(hr); ++fil){
                if((*fil).GetDirection() == PINDIR_INPUT && !(*fil).IsConnected()){
                    hr = pAudPin.Connect((*fil));
                }
            }

            if(FAILED(hr)){                
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Audio Tagger to Sink");
                ASSERT((L"Can't Connect aud to sink", FALSE));
                return E_UNEXPECTED;  
            }


#endif

            
            /*                
            hr = m_pGraph.Connect(vrA, pSink, intermediates);
            if(FAILED(hr)){
            TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Audio Tagger to Sink");
            return E_UNEXPECTED;  
            }
            */
            
            ASSERT(intermediates.begin() == intermediates.end());
            m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
            
            TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() SUCCEEDED");
            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() com exception");
            return e;
        } catch (...) {
            TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() ... exception");
            return E_UNEXPECTED;
        }
        
    }
};

#endif // Enc2Sin_H
// end of file - Enc2Sin.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\fp2ar.h ===
//==========================================================================;
//
// fp2ar.h : Declaration of the custom composition class for gluing file 
//           playback to the audio renderer
//
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef FP2ARCOMP_H
#define FP2ARCOMP_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAnaCapComp
class ATL_NO_VTABLE __declspec(uuid("CC23F537-18D4-4ece-93BD-207A84726979")) CFP2ARComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFP2ARComp, &__uuidof(CFP2ARComp)>,
    public IObjectWithSiteImplSec<CFP2ARComp>,
	public IMSVidCompositionSegmentImpl<CFP2ARComp>
{
public:
    CFP2ARComp() {}
    virtual ~CFP2ARComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_FP2ARCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CFP2ARComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CFP2ARComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()

// IMSVidComposition
public:
// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        TRACELM(TRACE_DEBUG, "CFP2ARComp::Compose()");
        if (m_fComposed) {
            return NOERROR;
        }
        
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CFP2ARComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CFP2ARComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
			DSFilter pFP(*up.begin());
			ASSERT(!!pFP);
            ASSERT(pFP.GetGraph() == m_pGraph);
	
			VWGraphSegment::iterator iAR;
            DSFilter pAR;
			for (iAR = down.begin(); iAR != down.end(); ++iAR) {
                pAR = *iAR;
                if (IsDigitalAudioRenderer(pAR)) {
                    break;
                }
    		}
            if (iAR == down.end()) {
				TRACELM(TRACE_ERROR, "CFP2ARComp::Compose() FAILED to find AR ");
				return E_UNEXPECTED;
            }

			ASSERT(!!pAR);
            ASSERT(pAR.GetGraph() == m_pGraph);
            HRESULT hr = m_pGraph.Connect(pFP, pAR, m_Filters,
                                          DSGraph::ALLOW_WILDCARDS | 
                                          DSGraph::DONT_TERMINATE_ON_RENDERER |
                                          DSGraph::IGNORE_MEDIATYPE_ERRORS, 
                                          DOWNSTREAM);
            if (FAILED(hr)) {
				TRACELSM(TRACE_ERROR, (dbgDump << "CFP2ARComp::Compose() FAILED connect hr = " << hexdump(hr)), "");
				return hr;
            }

            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // FP2ARCOMP_H
// end of file - FP2ARComp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\dvdprot.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1998-2000.
//
//--------------------------------------------------------------------------;
//
// dvdprot.cpp : Implementation of CDVDProt
//
//
//
// URL ::= DVD | DVD:[//<path>?] [<address>]
// address ::= <title> | <title>/<chapter>[-<end_chapter>] | <title>/<time>[-<end_time>]
// path ::= <unc_path> | <drive_letter>:/<directory_path>
// title ::= [digit] digit
// chapter ::= [ [digit] digit] digit
// time ::= [<hours>:] [<minutes>:] [<seconds>:] <frames>
// hours := [digit | 0]  digit
// minutes:= [digit | 0]  digit
// seconds:= [digit | 0]  digit
// frames:= [digit | 0]  digit
//
// DVD:                  play first DVD found, enumerating from drive D:
// DVD:2                 play title 2 (in first DVD found)
// DVD:5/13              play chapter 13 of title 5 (in first DVD found)
// DVD:7/9:05-13:23      play from 7 seconds 5 frames to 13 seconds 23 frames in title 7
// DVD:7/00:00:12:05-00:00:17:23 (strict version of timecode)
// DVD://myshare/dvd?9   play title 9 from the DVD-Video volume stored in the dvd directory of share
// DVD://f:/video_ts     play the DVD-Video volume in the video_ts directory of drive F:


#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "devices.h"
#include "msvidwebdvd.h"
#include "vidprot.h"

#define MAX_FIELDS 10

HRESULT CMSVidWebDVD::ParseDVDPath(LPWSTR pPath)
{
    WCHAR wsUncPath[MAX_PATH];
	int nFields, i;
    DVD_HMSF_TIMECODE tc;
    BSTR bstrTime = NULL;
    BSTR bstrEndTime = NULL;
	long Fields[MAX_FIELDS];
	long Delimiters[MAX_FIELDS];
    HRESULT hr = S_OK;

    // recognize "DVD:" at the beginning of string
    // note: we also allow "DVD" for compatibility with old code

    if (!pPath)
    {
        return E_INVALIDARG;
    }

    if (_wcsicmp(pPath, L"DVD") == 0)
    {
        pPath += 3;
    }
    else if (_wcsnicmp(pPath, L"DVD:", 4) == 0)
    {
        pPath += 4;
    }
    else
    {
        return E_INVALIDARG;
    }

    // determine if a unc path follows (starts with "//")

    if (wcsncmp(pPath, L"//", 2) == 0)
    {
        // determine if it is followed by a share name or a drive letter
        if (iswalpha(pPath[2]) && pPath[3] == L':')
        {
            // filter out the two foward slashes in front of drive letter
            pPath += 2;
        }

        // copy over the remaining unc path
        if(wcslen(pPath) >= MAX_PATH){
            // pPath is longer than wsUncPath so it will be truncated
        }
        // Could chop off a char if wsclen(pPath) == MAX_PATH
        lstrcpyn(wsUncPath, pPath, MAX_PATH);

        // search for the ending '?'; replacing forward slash with backslash
        i = 0;
        while (wsUncPath[i] != L'?' && wsUncPath[i] != 0)
        {
            if (wsUncPath[i] == L'/')
            {
                wsUncPath[i] = L'\\';
            }

            i++;
        }

        if (wsUncPath[i] == L'?')
        {
            // replace ? with NULL to truncate the rest of the string
            wsUncPath[i] = 0;
            pPath += i+1; // advance pointer pass the ?
        }
        else
        {
            // the entire string is the unc without the ?
            // advance pointer so that it points to the NULL

            pPath += i;
        }

        // append VIDEO_TS directory if only the drive is given
        // wsUncPath is an array of WCHARs MAX_PATH in length
        if (wcslen(wsUncPath) == 2 && iswalpha(wsUncPath[0]) && wsUncPath[1] == L':')
        {
            (void)StringCchCat(wsUncPath, SIZEOF_CH(wsUncPath), L"\\video_ts");
            //wcscat(wsUncPath, L"\\video_ts");
        }
      
        // save the path to dvd directory

        if (m_urlInfo.bstrPath != NULL)
        {
            SysFreeString(m_urlInfo.bstrPath);
        }
        m_urlInfo.bstrPath = SysAllocString(wsUncPath);
    }

	// if no title or chapter is set, let it play with default settings

	if (*pPath == 0)
	{
		return hr;
	}

    // parse address section
    // address ::= <title> | <title>/<chapter>[-<end_chapter>] | <title>/<time>[-<end_time>]

    // fetch a two-digit title number
    m_urlInfo.lTitle = ParseNumber(pPath);

    // retrieve all the numerical fields and Delimiters

    nFields = 0;
    while (nFields < MAX_FIELDS && *pPath != 0)
    {
        Delimiters[nFields] = *pPath++;
        Fields[nFields] = ParseNumber(pPath);
        nFields++;
    }

    // analyze the fields

    // find if there is a '-' with and ending chapter/time, and ':' indicating time

    int nPosHyphen = nFields;
    bool fEndSpecified = false;
    bool fTimeSpecified = false;

    for (i=0; i<nFields; i++)
    {
        if (L'-' == Delimiters[i])
        {
            nPosHyphen = i;
            fEndSpecified = true;
        }

        if (L':' == Delimiters[i])
        {
            fTimeSpecified = true;
        }
    }

    // title

    if (nFields == 0)
    {
        // title is specified, but no starting chapter or time

        m_urlInfo.enumRef = DVD_Playback_Title;
    }
    else
    {
        if (Delimiters[0] != L'/')
        {
            return E_INVALIDARG;
        }

        if (fTimeSpecified)
        {
            // get start time
            // make sure there are 1 to 4 time fields
            if (nPosHyphen < 1 || nPosHyphen > 4)
            {
                return E_INVALIDARG;
            }
            else
            {
                for (i=1; i < nPosHyphen; i++)
                {
                    if (Delimiters[i] != L':')
                    {
                        return E_INVALIDARG;
                    }
                }

                tc.bHours = 0;
                tc.bMinutes = 0;
                tc.bSeconds = 0;
                tc.bFrames = 0;

                // fill up to 4 fields
                // shifting values from the lower field up
                for (i=0; i < nPosHyphen; i++)
                {
                    tc.bHours = tc.bMinutes;
                    tc.bMinutes = tc.bSeconds;
                    tc.bSeconds = tc.bFrames;
                    tc.bFrames = Fields[i];
                }

                m_urlInfo.ulTime = *(ULONG *)(&tc);
            }

            // end time
            if (fEndSpecified)
            {
                // make sure there are 1 to 4 time fields
                if (nFields-nPosHyphen < 1 || nFields-nPosHyphen > 4)
                {
                    return E_INVALIDARG;
                }
                else
                {
                    for (i=nPosHyphen+1; i < nFields; i++)
                    {
                        if (Delimiters[i] != L':')
                        {
                            return E_INVALIDARG;
                        }
                    }

                    tc.bHours = 0;
                    tc.bMinutes = 0;
                    tc.bSeconds = 0;
                    tc.bFrames = 0;

                    for (i=nPosHyphen; i < nFields; i++)
                    {
                        tc.bHours = tc.bMinutes;
                        tc.bMinutes = tc.bSeconds;
                        tc.bSeconds = tc.bFrames;
                        tc.bFrames = Fields[i];
                    }

                    m_urlInfo.ulEndTime = *(ULONG *)(&tc);
                    m_urlInfo.enumRef = DVD_Playback_Time_Range;
                }
            }
            else
            {
                // only start time specified, no end time

                m_urlInfo.enumRef = DVD_Playback_Time;
            }
        }
        else
        {
            // chapter specified
            if (nPosHyphen != 1)
            {
                return E_INVALIDARG;
            }

            m_urlInfo.lChapter = Fields[0];

            if (fEndSpecified)
            {
                if (nFields-nPosHyphen != 1)
                {
                    return E_INVALIDARG;
                }

                m_urlInfo.lEndChapter = Fields[1];

                if (m_urlInfo.lEndChapter < m_urlInfo.lChapter)
                {
                    return E_INVALIDARG;
                }

                m_urlInfo.enumRef = DVD_Playback_Chapter_Range;
            }
            else
            {
                m_urlInfo.enumRef = DVD_Playback_Chapter;
            }
        }
    }

	return hr;
}


void CMSVidWebDVD::DeleteUrlInfo()
{
    if (m_urlInfo.bstrPath != NULL)
    {
        SysFreeString(m_urlInfo.bstrPath);
    }
    ZeroMemory(&m_urlInfo, sizeof(m_urlInfo));

    m_fUrlInfoSet = false;
}


HRESULT CMSVidWebDVD::SetPlaybackFromUrlInfo()
{
    HRESULT hr = S_OK;
    BSTR bstrTime, bstrEndTime;

    if (!m_fUrlInfoSet)
    {
        return S_OK;
    }

    // clear this flag to prevent this function to be called recursively
    m_fUrlInfoSet = false;
    
    switch (m_urlInfo.enumRef)
    {
    case DVD_Playback_Title:
        hr = PlayTitle(m_urlInfo.lTitle);
        break;

    case DVD_Playback_Chapter:
        hr = PlayChapterInTitle(m_urlInfo.lTitle, m_urlInfo.lChapter);
        break;

    case DVD_Playback_Chapter_Range:
        hr = PlayChaptersAutoStop(m_urlInfo.lTitle, m_urlInfo.lChapter, 
                                  m_urlInfo.lEndChapter-m_urlInfo.lChapter+1);
        break;

    case DVD_Playback_Time:
        DVDTime2bstr((DVD_HMSF_TIMECODE *)&(m_urlInfo.ulTime), &bstrTime);
        hr = PlayAtTimeInTitle(m_urlInfo.lTitle, bstrTime);
        SysFreeString(bstrTime);
        break;

    case DVD_Playback_Time_Range:
        DVDTime2bstr((DVD_HMSF_TIMECODE *)&(m_urlInfo.ulTime), &bstrTime);
        DVDTime2bstr((DVD_HMSF_TIMECODE *)&(m_urlInfo.ulEndTime), &bstrEndTime);
        hr = PlayPeriodInTitleAutoStop(m_urlInfo.lTitle, bstrTime, bstrEndTime);
        SysFreeString(bstrTime);
        SysFreeString(bstrEndTime);
        break;

    default:
        // just let play with the default settings
        break;
    }

    // once the urlInfo has been applied, clear the urlInfo
    DeleteUrlInfo();

    return hr;
}


HRESULT CMSVidWebDVD::SetDirectoryFromUrlInfo()
{
    HRESULT hr = S_OK;
    if (!m_fUrlInfoSet || !(m_urlInfo.bstrPath) )
    {
        return hr;
    }

    hr = put_DVDDirectory(m_urlInfo.bstrPath);

    // clear up the path to prevent this function to be called recursively
    SysFreeString(m_urlInfo.bstrPath);
    m_urlInfo.bstrPath.Empty();

    return hr;
}


// fetch a positive integer from string p, upto nMaxDigits or until a non-digit char is reached
// unlimited nubmer of digits if 0 is passed in nMaxDigits
// advance the the pointer p by the number of chars interpreted.
// it would return 0 if no digit present

int CMSVidWebDVD::ParseNumber(LPWSTR& p, int nMaxDigits)
{
    int nDigits = 0;
    int nNumber = 0;

    while ((nDigits < nMaxDigits || nMaxDigits <= 0) && iswdigit(*p))
    {
        nNumber = nNumber * 10 + (*p - L'0');
        p++;
        nDigits++;
    }
        
    return nNumber;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CDVDProt
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CDVDProt -- IInternetProtocolRoot
STDMETHODIMP CDVDProt::Start(LPCWSTR szUrl,
				IInternetProtocolSink* pOIProtSink,
				IInternetBindInfo* pOIBindInfo,
				DWORD grfPI,
				HANDLE_PTR /* dwReserved */)
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Start()");
    if (!pOIProtSink)
    {
        TRACELM(TRACE_DEBUG, "CDVDProt::Start() IInternetProctocolSink * == NULL");
	    return E_POINTER;
    }
    m_pSink.Release();
    m_pSink = pOIProtSink;
    m_pSink->ReportData(BSCF_FIRSTDATANOTIFICATION, 0, 0);
#if 0
	// this bug is fixed in ie 5.5+ on whistler.  if you want to run on earlier versions of ie such as 2k gold then you need this.
	m_pSink->ReportProgress(BINDSTATUS_CONNECTING, NULL);  // put binding in downloading state so it doesn't ignore our IUnknown*
#endif

	if (!pOIBindInfo) {
		m_pSink->ReportResult(E_NOINTERFACE, 0, 0);
		return E_NOINTERFACE;
	}
    // don't run unless we're being invoked from a safe site
    HRESULT hr = IsSafeSite(m_pSink);
    if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
    }
	ULONG count;
	LPOLESTR pb;
	hr = pOIBindInfo->GetBindString(BINDSTRING_FLAG_BIND_TO_OBJECT, &pb, 1, &count);
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
	if (wcscmp(pb, BIND_TO_OBJ_VAL)) {
		// we must be getting a bind to storage so skip the expensive stuff and 
		// wait for the bind to object which is coming next
		m_pSink->ReportData(BSCF_LASTDATANOTIFICATION | 
							BSCF_DATAFULLYAVAILABLE, 0, 0);
		m_pSink->ReportResult(S_OK, 0, 0);
		m_pSink.Release();
		return S_OK;
	}

	// and, in one of the most bizarre maneuvers i've ever seen, rather than casting, 
	// urlmon passes back the ascii value of the ibindctx pointer in the string
	hr = pOIBindInfo->GetBindString(BINDSTRING_PTR_BIND_CONTEXT, &pb, 1, &count);
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
	_ASSERT(count == 1);	
	
	PQBindCtx pbindctx;
#define RADIX_BASE_10 (10)
#ifdef _WIN64
#if 0
	// undone: turn this back on for win64 when _wcstoxi64 get into libc.c, they're in the header
	// but not implemented so this doesn't link
	pbindctx.Attach(reinterpret_cast<IBindCtx*>(_wcstoui64(pb, NULL, RADIX_BASE_10)));	// urlmon already did an addref
#else
	swscanf(pb, L"%I64d", &pbindctx.p);
#endif // 0
#else
	pbindctx.Attach(reinterpret_cast<IBindCtx*>(wcstol(pb, NULL, RADIX_BASE_10)));	// urlmon already did an addref
#endif // _WIN64

	if (!pbindctx) {
		m_pSink->ReportResult(E_NOINTERFACE, 0, 0);
		return E_NOINTERFACE;
	}	

    TRACELM(TRACE_DEBUG, "CDVDProt::Start(): creating control object");
	PQVidCtl pCtl;
	PQWebBrowser2 pW2;
	// hunt for cached object
	PQServiceProvider pSP(m_pSink);
	if (pSP) {
		hr = pSP->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (LPVOID *)&pW2);
		if (SUCCEEDED(hr)) {
			CComVariant v;
            CComBSTR propname(KEY_CLSID_VidCtl);
            if (!propname) {
                return E_UNEXPECTED;
            }
	        hr = pW2->GetProperty(propname, &v);
			if (SUCCEEDED(hr)) {
				if (v.vt == VT_UNKNOWN) {
					pCtl = v.punkVal;
				} else if (v.vt == VT_DISPATCH) {
					pCtl = v.pdispVal;
				} else {
					TRACELM(TRACE_ERROR, "CDVDProt::Start(): non-object cached w/ our key");
				}
				// undone: look and see if pCtl already has a site.because
				// this means we're seeing the second tv: on this page
				// so just get the current TR/channel from it if necessary (tv: w/ no rhs)
				// and create a new ctl
			}
		}
	}
	if (!pCtl) {
        // undone: long term, we want to move a bunch of this create/setup logic into factoryhelp
        // so we can share more code with the dvd: protocol and the behavior factory
		hr = pCtl.CoCreateInstance(CLSID_MSVidCtl, NULL, CLSCTX_INPROC_SERVER);
		if (FAILED(hr)) {
			m_pSink->ReportResult(hr, 0, 0);
			return hr;
		}
		// cache this ctl for next time
		if (pW2) {
			VARIANT v;
			v.vt = VT_UNKNOWN;
			v.punkVal = pCtl;
            CComBSTR propname(KEY_CLSID_VidCtl);
            if (!propname) {
                return E_UNEXPECTED;
            }
	        hr = pW2->PutProperty(propname, v);
			if (FAILED(hr)) {
				TRACELM(TRACE_ERROR, "CTVProt::Start() Can't cache ctl");
			}
		}

		// pass the url to view, it will be parsed in pCtrl->View()		

        CComVariant vUrl(szUrl);
        hr = pCtl->View(&vUrl);
		if (FAILED(hr)) {
			m_pSink->ReportResult(hr, 0, 0);
			TRACELM(TRACE_ERROR, "CDVDProt::Start() Can't view dvd url");
			return hr;
		}

		// undone: once we know where vidctl will live in the registry then we need to put a flag
		// in the registry just disables including any features in the tv: prot 
		// this must be secured admin only since its a backdoor to disable CA

		// undone: look up default feature segments in registry
		// for now we're just going to take them all since the
		// only one that exists is data

		PQFeatures pF;
		hr = pCtl->get_FeaturesAvailable(&pF);
		if (FAILED(hr)) {
			m_pSink->ReportResult(hr, 0, 0);
			TRACELM(TRACE_ERROR, "CDVDProt::Start() Can't get features collection");
			return hr;
		}

		// undone: look up default feature segments for dvd: in registry
		// for now we're just going to hard code the ones we want

        CFeatures* pC = static_cast<CFeatures *>(pF.p);
        CFeatures* pNewColl = new CFeatures;
        if (!pNewColl) {
            return E_OUTOFMEMORY;
        }
        for (DeviceCollection::iterator i = pC->m_Devices.begin(); i != pC->m_Devices.end(); ++i) {
            PQFeature f(*i);
            GUID2 clsid;
            hr = f->get__ClassID(&clsid);
            if (FAILED(hr)) {
    			TRACELM(TRACE_ERROR, "CTVProt::GetVidCtl() Can't get feature class id");
                continue;
            }
            if (clsid == CLSID_MSVidClosedCaptioning) {
                pNewColl->m_Devices.push_back(*i);
            }
        }
		hr = pCtl->put_FeaturesActive(pNewColl);
		if (FAILED(hr)) {
			m_pSink->ReportResult(hr, 0, 0);
			TRACELM(TRACE_ERROR, "CDVDProt::Start() Can't put features collection");
			return hr;
		}

	}
	ASSERT(pCtl);
	hr = pbindctx->RegisterObjectParam(OLESTR("IUnknown Pointer"), pCtl);
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
	hr = pCtl->Run(); 
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
    TRACELSM(TRACE_DEBUG, (dbgDump << "BINDSTATUS_IUNKNOWNAVAILABLE(29), " << KEY_CLSID_VidCtl), "");
    m_pSink->ReportProgress(BINDSTATUS_IUNKNOWNAVAILABLE, NULL);
    m_pSink->ReportData(BSCF_LASTDATANOTIFICATION | 
			            BSCF_DATAFULLYAVAILABLE, 0, 0);
    m_pSink->ReportResult(S_OK, 0, 0);
    m_pSink.Release();
    return S_OK;
}

#endif // TUNING_MODEL_ONLY
// end of file dvdprot.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\dvbtunerequest.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTuneRequest.h : Declaration of the CDVBTuneRequest
// Copyright (c) Microsoft Corporation 1999.

#ifndef __DVBTUNEREQUEST_H_
#define __DVBTUNEREQUEST_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "dvbtunerequestimpl.h"

typedef CComQIPtr<IDVBTuneRequest> PQDVBTuneRequest;

/////////////////////////////////////////////////////////////////////////////
// CDVBTuneRequest
class ATL_NO_VTABLE CDVBTuneRequest : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public IObjectWithSiteImplSec<CDVBTuneRequest>,
	public IDVBTuneRequestImpl<CDVBTuneRequest>,
	public CComCoClass<CDVBTuneRequest, &CLSID_DVBTuneRequest>,
	public ISupportErrorInfo
{
public:

	CDVBTuneRequest() {}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_DVBTUNEREQUEST_PROGID, 
						   IDS_REG_DVBTUNEREQUEST_DESC,
						   LIBID_TunerLib,
						   CLSID_DVBTuneRequest, tvBoth);

BEGIN_COM_MAP(CDVBTuneRequest)
	COM_INTERFACE_ENTRY(IDVBTuneRequest)
	COM_INTERFACE_ENTRY(ITuneRequest)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CDVBTuneRequest)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    typedef IDVBTuneRequestImpl<CDVBTuneRequest> basetype;
    BEGIN_PROP_MAP(CDVBTuneRequest)
        CHAIN_PROP_MAP(basetype)
    END_PROP_MAP()


};

#endif //__DVBTUNEREQUEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\fp2vr.h ===
//==========================================================================;
//
// fp2vr.h : Declaration of the custom composition class for gluing file 
//           playback to the video renderer
//
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef FP2VRCOMP_H
#define FP2VRCOMP_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAnaCapComp
class ATL_NO_VTABLE __declspec(uuid("B401C5EB-8457-427f-84EA-A4D2363364B0")) CFP2VRComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFP2VRComp, &__uuidof(CFP2VRComp)>,
    public IObjectWithSiteImplSec<CFP2VRComp>,
	public IMSVidCompositionSegmentImpl<CFP2VRComp>
{
public:
    CFP2VRComp() {}
    virtual ~CFP2VRComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_FP2VRCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CFP2VRComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CFP2VRComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()

// IMSVidComposition
public:
// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        TRACELM(TRACE_DEBUG, "CFP2VRComp::Compose()");
        if (m_fComposed) {
            return NOERROR;
        }
        
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CFP2VRComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CFP2VRComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
			DSFilter pFP(*up.begin());
	
			VWGraphSegment::iterator iVR;
			VWGraphSegment::iterator prevVR;
			for (iVR = down.begin(); iVR != down.end(); ++iVR) {
				prevVR = iVR;
			}
			DSFilter pVR = DSFilter(*prevVR);
			ASSERT(!!pFP);
            ASSERT(pFP.GetGraph() == m_pGraph);
			ASSERT(!!pVR);
            ASSERT(pVR.GetGraph() == m_pGraph);
          
            HRESULT hr = m_pGraph.Connect(pFP, pVR, m_Filters, 
                                          DSGraph::ATTEMPT_MERIT_UNLIKELY | 
                                              DSGraph::ALLOW_WILDCARDS | 
                                              DSGraph::IGNORE_MEDIATYPE_ERRORS |
                                              DSGraph::DONT_TERMINATE_ON_RENDERER |
                                              DSGraph::BIDIRECTIONAL_MEDIATYPE_MATCHING,
                                          DOWNSTREAM);
            if (FAILED(hr)) {
				TRACELSM(TRACE_ERROR, (dbgDump << "CFP2VRComp::Compose() FAILED connect hr = " << hexdump(hr)), "");
				return hr;
            }

            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // FP2VRCOMP_H
// end of file - FP2VRComp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\languagecomponenttype.h ===
/////////////////////////////////////////////////////////////////////////////////////
// LanguageComponentType.h : Declaration of the CLanguageComponentType
// Copyright (c) Microsoft Corporation 1999.

#ifndef __LANGUAGECOMPONENTTYPE_H_
#define __LANGUAGECOMPONENTTYPE_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "languagecomponenttypeimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CLanguageComponentType
class ATL_NO_VTABLE __declspec(uuid("1BE49F30-0E1B-11d3-9D8E-00C04F72D980")) CLanguageComponentType : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CLanguageComponentType, &CLSID_LanguageComponentType>,
    public IObjectWithSiteImplSec<CLanguageComponentType>,
	public ILanguageComponentTypeImpl<CLanguageComponentType>
{
public:
	CLanguageComponentType()
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_LANGUAGECOMPONENTTYPE_PROGID, 
						   IDS_REG_LANGUAGECOMPONENTTYPE_DESC,
						   LIBID_TunerLib,
						   CLSID_LanguageComponentType, tvBoth);
DECLARE_NOT_AGGREGATABLE(CLanguageComponentType)

DECLARE_PROTECT_FINAL_CONSTRUCT()

public:
    bool m_bRequiresSave;
    typedef ILanguageComponentTypeImpl<CLanguageComponentType> basetype;
    BEGIN_PROP_MAP(CLanguageComponentType)
        CHAIN_PROP_MAP(basetype)
    END_PROPERTY_MAP()

    BEGIN_COM_MAP(CLanguageComponentType)
	    COM_INTERFACE_ENTRY(ILanguageComponentType)
	    COM_INTERFACE_ENTRY(IComponentType)
	    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    	COM_INTERFACE_ENTRY(IPersist)
	    COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CLanguageComponentType)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

};

typedef CComQIPtr<ILanguageComponentType> PQLanguageComponentType;

#endif //__LANGUAGECOMPONENTTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\iso3166.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __ISO3166_H
#define __ISO3166_H

char DVDToUpper(char x)
{
    if('a' <= x && x <= 'z') {
        return x - ('a' - 'A');
    } else {
        return x;
    }
}

struct ISO3166
{
    const char *Code;
    
    // access the table as ISO3166::GetCountry()
    static const ISO3166& GetCountry( unsigned i );
    static unsigned	GetNumCountries();

    // creates an ISO code from a two letter string
    static WORD	PackCode( const char string[2] )
    {
        return DVDToUpper(string[0])<<8 | DVDToUpper(string[1]);
    }
    
};

// ISO3166 country code table
static const ISO3166 g_Table[] =
{ // current as of Dec 22, 2000
    {/* "Afghanistan", */       "AF"},
    {/* "Albania", */           "AL"},
    {/* "Algeria", */           "DZ"},
    {/* "American Samoa", */    "AS"},
    {/* "Andorra", */           "AD"},
    {/* "Angola", */            "AO"},
    {/* "Anguilla", */          "AI"},
    {/* "Antarctica", */        "AQ"},
    {/* "Antigua and Barbuda", */  "AG"},
    {/* "Argentina", */         "AR"},
    {/* "Armenia", */           "AM"},
    {/* "Aruba", */             "AW"},
    {/* "Australia", */         "AU"},
    {/* "Austria", */           "AT"},
    {/* "Azerbaijan", */        "AZ"},
    {/* "Bahamas", */           "BS"},
    {/* "Bahrain", */           "BH"},
    {/* "Bangladesh", */        "BD"},
    {/* "Barbados", */          "BB"},
    {/* "Belarus", */           "BY"},
    {/* "Belgium", */           "BE"},
    {/* "Belize", */            "BZ"},
    {/* "Benin", */             "BJ"},
    {/* "Bermuda", */           "BM"},
    {/* "Bhutan", */            "BT"},
    {/* "Bolivia", */           "BO"},
    {/* "Bosnia and Herzegovina", */        "BA"},
    {/* "Botswana", */          "BW"},
    {/* "Bouvet Island", */     "BV"},
    {/* "Brazil", */            "BR"},
    {/* "British Indian Ocean Territory", */  "IO"},
    {/* "Brunei Darussalam", */ "BN"},
    {/* "Bulgaria", */          "BG"},
    {/* "Burkina Faso", */      "BF"},
    {/* "Burundi", */           "BI"},
    {/* "Cambodia", */          "KH"},
    {/* "Cameroon", */          "CM"},
    {/* "Canada", */            "CA"},
    {/* "Cape Verde", */        "CV"},
    {/* "Cayman Islands", */    "KY"},
    {/* "Central African Republic", */      "CF"},
    {/* "Chad", */              "TD"},
    {/* "Channel Islands", */	"GB"},
    {/* "Chile", */             "CL"},
    {/* "China", */             "CN"},
    {/* "Christmas Island", */  "CX"},
    {/* "Cocos (Keeling) Islands", */       "CC"},
    {/* "Colombia", */          "CO"},
    {/* "Comoros", */           "KM"},
    {/* "Congo", */             "CG"},
    {/* "Cook Islands", */      "CK"},
    {/* "Costa Rica", */        "CR"},
    {/* "Cte d'Ivoire", */     "CI"},
    {/* "Croatia (local name: Hrvatska)", */  "HR"},
    {/* "Cuba", */              "CU"},
    {/* "Cyprus", */            "CY"},
    {/* "Czech Republic", */    "CZ"},
    {/* "Denmark", */           "DK"},
    {/* "Djibouti", */          "DJ"},
    {/* "Dominica", */          "DM"},
    {/* "Dominican Republic", */  "DO"},
    {/* "East Timor", */        "TP"},
    {/* "Ecuador", */           "EC"},
    {/* "Egypt", */             "EG"},
    {/* "El Salvador", */       "SV"},
    {/* "Equatorial Guinea", */  "GQ"},
    {/* "Eritrea", */           "ER"},
    {/* "Estonia", */           "EE"},
    {/* "Ethiopia", */          "ET"},
    {/* "Falkland Islands (Malvinas)", */   "FK"},
    {/* "Faroe Islands", */     "FO"},
    {/* "Fiji", */              "FJ"},
    {/* "Finland", */           "FI"},
    {/* "France", */            "FR"},
    {/* "France, Metropolitan", */  "FX"},
    {/* "French Guiana", */     "GF"},
    {/* "French Polynesia", */  "PF"},
    {/* "French Southern and Antarctic Lands", */	"TF"},
    {/* "Gabon", */             "GA"},
    {/* "Gambia", */            "GM"},
    {/* "Georgia", */           "GE"},
    {/* "Germany", */           "DE"},
    {/* "Ghana", */             "GH"},
    {/* "Gibraltar", */         "GI"},
    {/* "Greece", */            "GR"},
    {/* "Greenland", */         "GL"},
    {/* "Grenada", */           "GD"},
    {/* "Guadeloupe", */        "GP"},
    {/* "Guam", */              "GU"},
    {/* "Guatemala", */         "GT"},
    {/* "Guinea", */            "GN"},
    {/* "Guinea-Bissau", */     "GW"},
    {/* "Guyana", */            "GY"},
    {/* "Haiti", */             "HT"},
    {/* "Heard and Mc Donald Islands", */   "HM"},
    {/* "Holy See (Vatican City State)", */ "VA"},
    {/* "Honduras", */          "HN"},
    {/* "Hong Kong SAR", */         "HK"},
    {/* "Hungary", */           "HU"},
    {/* "Iceland", */           "IS"},
    {/* "India", */             "IN"},
    {/* "Indonesia", */         "ID"},
    {/* "Iran (Islamic Republic Of)", */    "IR"},
    {/* "Iraq", */              "IQ"},
    {/* "Ireland", */           "IE"},
    {/* "Israel", */            "IL"},
    {/* "Italy", */             "IT"},
    {/* "Jamaica", */           "JM"},
    {/* "Japan", */             "JP"},
    {/* "Jordan", */            "JO"},
    {/* "Kazakhstan", */        "KZ"},
    {/* "Kenya", */             "KE"},
    {/* "Kiribati", */          "KI"},
    {/* "Korea, Democratic People's Republic Of", */  "KP"},
    {/* "Korea, Republic Of", */  "KR"},
    {/* "Kuwait", */            "KW"},
    {/* "Kyrgyzstan", */        "KG"},
    {/* "Lao People's Democratic Republic", */  "LA"},
    {/* "Latvia", */            "LV"},
    {/* "Lebanon", */           "LB"},
    {/* "Lesotho", */           "LS"},
    {/* "Liberia", */           "LR"},
    {/* "Libyan Arab Jamahiriya", */        "LY"},
    {/* "Liechtenstein", */     "LI"},
    {/* "Lithuania", */         "LT"},
    {/* "Luxembourg", */        "LU"},
    {/* "Macau SAR", */             "MO"},
    {/* "Macedonia, The Former Yugoslav Republic Of", */  "MK"},
    {/* "Madagascar", */        "MG"},
    {/* "Malawi", */            "MW"},
    {/* "Malaysia", */          "MY"},
    {/* "Maldives", */          "MV"},
    {/* "Mali", */              "ML"},
    {/* "Malta", */             "MT"},
    {/* "Man, Isle of",*/   	"GB"},
    {/* "Marshall Islands", */  "MH"},
    {/* "Martinique", */        "MQ"},
    {/* "Mauritania", */        "MR"},
    {/* "Mauritius", */         "MU"},
    {/* "Mayotte", */           "YT"},
    {/* "Mexico", */            "MX"},
    {/* "Micronesia, Federated States Of", */  "FM"},
    {/* "Moldova, Republic Of", */          "MD"},
    {/* "Monaco", */            "MC"},
    {/* "Mongolia", */          "MN"},
    {/* "Montserrat", */        "MS"},
    {/* "Morocco", */           "MA"},
    {/* "Mozambique", */        "MZ"},
    {/* "Myanmar", */           "MM"},
    {/* "Namibia", */           "NA"},
    {/* "Nauru", */             "NR"},
    {/* "Nepal", */             "NP"},
    {/* "Netherlands", */       "NL"},
    {/* "Netherlands ANTILLES", */          "AN"},
    {/* "New Caledonia", */     "NC"},
    {/* "New Zealand", */       "NZ"},
    {/* "Nicaragua", */         "NI"},
    {/* "Niger", */             "NE"},
    {/* "Nigeria", */           "NG"},
    {/* "Niue", */              "NU"},
    {/* "Norfolk Island", */    "NF"},
    {/* "Northern Mariana Islands", */      "MP"},
    {/* "Norway", */            "NO"},
    {/* "Oman", */              "OM"},
    {/* "Pakistan", */          "PK"},
    {/* "Palau", */             "PW"},
    {/* "Panama", */            "PA"},
    {/* "Papua New Guinea", */  "PG"},
    {/* "Paraguay", */          "PY"},
    {/* "Peru", */              "PE"},
    {/* "Philippines", */       "PH"},
    {/* "Pitcairn Islands", */  "PN"},
    {/* "Poland", */            "PL"},
    {/* "Portugal", */          "PT"},
    {/* "Puerto Rico", */       "PR"},
    {/* "Qatar", */             "QA"},
    {/* "Reunion", */           "RE"},
    {/* "Romania", */           "RO"},
    {/* "Russian Federation", */            "RU"},
    {/* "Rwanda", */            "RW"},
    {/* "Saint Kitts and Nevis", */         "KN"},
    {/* "Saint Lucia", */       "LC"},
    {/* "Saint Vincent and The Grenadines", */  "VC"},
    {/* "Samoa", */             "WS"},
    {/* "San Marino", */        "SM"},
    {/* "So Tom and Prncipe ", */         "ST"},
    {/* "Saudi Arabia", */      "SA"},
    {/* "Senegal", */           "SN"},
    {/* "Seychelles", */        "SC"},
    {/* "Sierra Leone", */      "SL"},
    {/* "Singapore", */         "SG"},
    {/* "Slovakia (Slovak Republic)", */    "SK"},
    {/* "Slovenia", */          "SI"},
    {/* "Solomon Islands", */   "SB"},
    {/* "Somalia", */           "SO"},
    {/* "South Africa", */      "ZA"},
    {/* "South Georgia and The South Sandwich Islands", */  "GS"},
    {/* "Spain", */             "ES"},
    {/* "Sri Lanka", */         "LK"},
    {/* "St. Helena", */        "SH"},
    {/* "St. Pierre and Miquelon", */        "PM"},
    {/* "Sudan", */             "SD"},
    {/* "Suriname", */          "SR"},
    {/* "Svalbard and Jan Mayen Islands", */ "SJ"},
    {/* "Swaziland", */         "SZ"},
    {/* "Sweden", */            "SE"},
    {/* "Switzerland", */       "CH"},
    {/* "Syrian Arab Republic", */  "SY"},
    {/* "Taiwan", */            "TW"},
    {/* "Tajikistan", */        "TJ"},
    {/* "Tanzania, United Republic Of", */  "TZ"},
    {/* "Thailand", */          "TH"},
    {/* "Togo", */              "TG"},
    {/* "Tokelau", */           "TK"},
    {/* "Tonga", */             "TO"},
    {/* "Trinidad and Tobago", */  "TT"},
    {/* "Tunisia", */           "TN"},
    {/* "Turkey", */            "TR"},
    {/* "Turkmenistan", */      "TM"},
    {/* "Turks and Caicos Islands", */      "TC"},
    {/* "Tuvalu", */            "TV"},
    {/* "Uganda", */            "UG"},
    {/* "Ukraine", */           "UA"},
    {/* "United Arab Emirates", */  "AE"},
    {/* "United Kingdom", */    "GB"},
    {/* "United States", */     "US"},
    {/* "U.S. Minor Outlying Islands", */  "UM"},
    {/* "Uruguay", */           "UY"},
    {/* "Uzbekistan", */        "UZ"},
    {/* "Vanuatu", */           "VU"},
    {/* "Venezuela", */         "VE"},
    {/* "Viet Nam", */          "VN"},
    {/* "Virgin Islands (British)", */      "VG"},
    {/* "Virgin Islands (U.S.)", */         "VI"},
    {/* "Wallis and Futuna Islands", */     "WF"},
    {/* "Yemen", */             "YE"},
    {/* "Yugoslavia", */        "YU"},
    {/* "Congo (DRC)", */             "ZR"},
    {/* "Zambia", */            "ZM"},
    {/* "Zimbabwe", */          "ZW"}
};

static const unsigned g_uTableSize = sizeof( g_Table )/ sizeof( g_Table[0] );

const ISO3166& ISO3166::GetCountry( unsigned i )
{
    return g_Table[i];
}

unsigned ISO3166::GetNumCountries()
{
    return g_uTableSize;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\mp2sin.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing bda MPeg2 tuner to sbe SINk
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef MP2SIN_H
#define MP2SIN_H

#pragma once
#include <uuids.h>
#include <objectwithsiteimplsec.h>
#include "bdamedia.h"
#include "bdaTuner.h"
#include "MSVidSbeSink.h"
#include "resource.h"       // main symbols
#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>



/////////////////////////////////////////////////////////////////////////////
// CMP2SinComp
class ATL_NO_VTABLE __declspec(uuid("ABE40035-27C3-4a2f-8153-6624471608AF")) CMP2SinComp : 
public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMP2SinComp, &__uuidof(CMP2SinComp)>,
    public IObjectWithSiteImplSec<CMP2SinComp>,
    public IMSVidCompositionSegmentImpl<CMP2SinComp>
{
public:
    CMP2SinComp() {}
    virtual ~CMP2SinComp() {}
    
    REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_MP2SINCOMP_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CMP2SinComp));
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()
        
    BEGIN_COM_MAP(CMP2SinComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()
        
        // IMSVidComposition
public:
    // IMSVidGraphSegment
    // IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
    {

        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            TRACELM(TRACE_DETAIL, "CMP2SinComp::Compose()");
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CMP2SinComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CMP2SinComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
#if 0
            VWGraphSegment::iterator iOv = std::find_if(down.begin(),
                down.end(),
                arity1_pointer(&IsVideoRenderer));
#endif            
            CMSVidStreamBufferSink* ds = (CMSVidStreamBufferSink*)downstream;
            DSFilter pSink(ds->m_Filters[0]);
            
            
            CComQIPtr<IMpeg2Demultiplexer> qiDeMux;
            VWGraphSegment::iterator i;
            for (i = up.begin(); i != up.end(); ++i){
                qiDeMux = (*i);
                if (!qiDeMux){
                    continue;
                }
                else{
                    break;
                }
            }
            if(i == up.end()){
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() cannot find demux");
                return E_INVALIDARG;
            }
            // render demux out to vr
            DSPin pVidPin;
            DSPin pAudPin;
            DSFilter pDeMux = (*i);
            DSFilter::iterator iVidPin;
            DSMediaType mtVideo(MEDIATYPE_Video, MEDIASUBTYPE_MPEG2_VIDEO, FORMAT_MPEG2Video);
            DSMediaType mtAudio(MEDIATYPE_Audio);
            for (iVidPin = pDeMux.begin(); iVidPin != pDeMux.end(); ++iVidPin) {
                DSPin::iterator j;
                for(j = (*iVidPin).begin(); j != (*iVidPin).end(); ++j){
                    DSMediaType pinType(*j);
                    CString csName;
                    if (pinType == mtVideo){
                        CComPtr<IUnknown> spMpeg2Analyze(CLSID_Mpeg2VideoStreamAnalyzer, NULL, CLSCTX_INPROC_SERVER);
                        if (!spMpeg2Analyze) {
                            //TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidStreamBufferSink::Build() can't load Stream Buffer Sink");
                            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
                        }
                        DSFilter vr(spMpeg2Analyze);
                        if (!vr) {
                            ASSERT(false);
                            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
                        }
                        m_Filters.push_back(vr);
                        csName = _T("Mpeg2 Analysis");
                        m_pGraph.AddFilter(vr, csName);
                        DSFilter::iterator a;
                        for(a = vr.begin(); a != vr.end(); ++a){
                            HRESULT hr = (*a).Connect(*iVidPin);
                            if(FAILED(hr)){
                                continue;
                            }
                            else{
                                break;
                            }
                        }
                        if(a == vr.end()){
                            return E_FAIL;
                        }
                        for(a = vr.begin(); a != vr.end(); ++a){
                            if((*a).GetDirection() == PINDIR_OUTPUT){
                                pVidPin = (*a); 
                            }
                        }
                        if(!pVidPin){
                            return E_FAIL;
                        }
                    }
                    if(pinType == mtAudio){
                        pAudPin = (*iVidPin);
                    }
                }
                if(!!pVidPin && !!pAudPin){
                    break;
                }
            }
            if(!pVidPin || !pAudPin){
                TRACELM(TRACE_DETAIL, "CMP2SinComp::Compose() can't find video and/or audio pin on demux");
                return E_UNEXPECTED;  
            }
            DSFilterList intermediates;
            
            HRESULT hr = pAudPin.IntelligentConnect(pSink, intermediates);
            if(FAILED(hr)){
                TRACELM(TRACE_DETAIL, "CMP2SinComp::Compose() can't find video and/or audio pin on demux");
                return E_UNEXPECTED;  
            }
            
            hr = pVidPin.IntelligentConnect(pSink, intermediates);
            if(FAILED(hr)){
                TRACELM(TRACE_DETAIL, "CMP2SinComp::Compose() can't find video and/or audio pin on demux");
                return E_UNEXPECTED;  
            }
            TRACELM(TRACE_DETAIL, "CMP2SinComp::Compose() SUCCEEDED");
            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            HRESULT hr = e;
            TRACELSM(TRACE_ERROR, (dbgDump << "CMP2SinComp::Compose() exception = " << hexdump(hr)), "");
            return e;
        } catch (...) {
            TRACELM(TRACE_ERROR, "CMP2SinComp::Compose() exception ... ");
            return E_UNEXPECTED;
        }
    }
};

#endif // MP2Sin_H
// end of file - MP2Sin.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\mp2cc.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing mpeg2 
// decoder to closed caption
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef MP2CCCOMP_H
#define MP2CCCOMP_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMP2CCComp
class ATL_NO_VTABLE __declspec(uuid("6AD28EE1-5002-4e71-AAF7-BD077907B1A4")) CMP2CCComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMP2CCComp, &__uuidof(CMP2CCComp)>,
    public IObjectWithSiteImplSec<CMP2CCComp>,
	public IMSVidCompositionSegmentImpl<CMP2CCComp>
{
public:
    CMP2CCComp() {}
    virtual ~CMP2CCComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_MP2CCCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMP2CCComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CMP2CCComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()

// IMSVidComposition
public:
// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        TRACELM(TRACE_DEBUG, "CMP2CCComp::Compose()");
        if (m_fComposed) {
            return NOERROR;
        }
        
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CMP2CCComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CMP2CCComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
#if 0
            VWGraphSegment::iterator iMP2 = std::find_if(up.begin(),
                                                         up.end(),
                                                         arity1_pointer(&IsMP2Demux));
#endif
			VWGraphSegment::iterator iMP2;
			int i;
			for (i = 0 , iMP2 = up.begin(); iMP2 != up.end(); ++iMP2, ++i);
			for (iMP2 = up.begin(); iMP2 != up.end() && --i; ++iMP2);
            if (iMP2 == up.end()) {
                TRACELM(TRACE_ERROR, "CMP2CCComp::Compose() upstream segment has no MPEG2 Decoder");
                return E_FAIL;
            }
            ASSERT((*iMP2).GetGraph() == m_pGraph);
          
            VWGraphSegment::iterator iL21 = std::find_if(down.begin(),
                down.end(),
                arity1_pointer(&IsL21Decoder));
            if (iL21 == down.end()) {
                TRACELM(TRACE_ERROR, "CMP2CCComp::Compose() downstream segment has no l21Decoder");
                return E_FAIL;
            }
            
            ASSERT((*iL21).GetGraph() == m_pGraph);
            
            DSFilter pMP2(*iMP2);
            DSFilter pL21(*iL21);

			HRESULT hr = m_pGraph.Connect(pMP2, pL21, m_Filters, DSGraph::RENDER_ALL_PINS, DOWNSTREAM);
            if (FAILED(hr)) {
				TRACELSM(TRACE_ERROR, (dbgDump << "CMP2CCComp::Compose() FAILED connect hr = " << hexdump(hr)), "");
				return hr;
            }

            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // MP2CCCOMP_H
// end of file - MP2CCComp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\mpeg2tunerequest.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2TuneRequest.cpp : Implementation of CMPEG2TuneRequest
// Copyright (c) Microsoft Corporation 1999.

#include "stdafx.h"
#include "Tuner.h"
#include "MPEG2TuneRequest.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MPEG2TuneRequestFactory, CMPEG2TuneRequestFactory)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MPEG2TuneRequest, CMPEG2TuneRequest)
/////////////////////////////////////////////////////////////////////////////
// CMPEG2TuneRequest

STDMETHODIMP CMPEG2TuneRequest::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMPEG2TuneRequest
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CMPEG2TuneRequestFactory::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMPEG2TuneRequestFactory
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\mpeg2componenttype.h ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2ComponentType.h : Declaration of the CMPEG2ComponentType
// Copyright (c) Microsoft Corporation 1999.

#ifndef __MPEG2COMPONENTTYPE_H_
#define __MPEG2COMPONENTTYPE_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "MPEG2componenttypeimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CMPEG2ComponentType
class ATL_NO_VTABLE __declspec(uuid("418008F3-CF67-4668-9628-10DC52BE1D08")) CMPEG2ComponentType : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMPEG2ComponentType, &CLSID_MPEG2ComponentType>,
    public IObjectWithSiteImplSec<CMPEG2ComponentType>,
	public IMPEG2ComponentTypeImpl<CMPEG2ComponentType>
{
public:
	CMPEG2ComponentType()
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_MPEG2COMPONENTTYPE_PROGID, 
						   IDS_REG_MPEG2COMPONENTTYPE_DESC,
						   LIBID_TunerLib,
						   CLSID_MPEG2ComponentType, tvBoth);
DECLARE_NOT_AGGREGATABLE(CMPEG2ComponentType)

DECLARE_PROTECT_FINAL_CONSTRUCT()

public:
    bool m_bRequiresSave;
    typedef IMPEG2ComponentTypeImpl<CMPEG2ComponentType> basetype;
    BEGIN_PROP_MAP(CMPEG2ComponentType)
        CHAIN_PROP_MAP(basetype)
    END_PROPERTY_MAP()

    BEGIN_COM_MAP(CMPEG2ComponentType)
	    COM_INTERFACE_ENTRY(IMPEG2ComponentType)
	    COM_INTERFACE_ENTRY(ILanguageComponentType)
	    COM_INTERFACE_ENTRY(IComponentType)
	    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    	COM_INTERFACE_ENTRY(IPersist)
	    COM_INTERFACE_ENTRY(IDispatch)
    	COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CMPEG2ComponentType)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

};

typedef CComQIPtr<IMPEG2ComponentType> PQMPEG2ComponentType;

#endif //__MPEG2COMPONENTTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\mpeg2component.h ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2Component.h : Declaration of the CMPEG2Component
// Copyright (c) Microsoft Corporation 1999.

#ifndef __MPEG2COMPONENT_H_
#define __MPEG2COMPONENT_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "MPEG2componentimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CMPEG2Component
class ATL_NO_VTABLE CMPEG2Component : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMPEG2Component, &CLSID_MPEG2Component>,
    public IObjectWithSiteImplSec<CMPEG2Component>,
	public IMPEG2ComponentImpl<CMPEG2Component>
{
public:
    CMPEG2Component() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_MPEG2COMPONENT_PROGID, 
						   IDS_REG_MPEG2COMPONENT_DESC,
						   LIBID_TunerLib,
						   CLSID_MPEG2Component, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMPEG2Component)
	COM_INTERFACE_ENTRY(IMPEG2Component)
	COM_INTERFACE_ENTRY(IComponent)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CMPEG2Component)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CMPEG2Component)
        CHAIN_PROP_MAP(IMPEG2ComponentImpl<CMPEG2Component>)
    END_PROPERTY_MAP()


};

typedef CComQIPtr<IMPEG2Component> PQMPEG2Component;

#endif //__MPEG2COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\mpeg2tunerequest.h ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2TuneRequest.h : Declaration of the CMPEG2TuneRequest
// Copyright (c) Microsoft Corporation 2000.

#ifndef __MPEG2TUNEREQUEST_H_
#define __MPEG2TUNEREQUEST_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "MPEG2tunerequestimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CMPEG2TuneRequest
class ATL_NO_VTABLE CMPEG2TuneRequest : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IMPEG2TuneRequestImpl<CMPEG2TuneRequest>,
	public CComCoClass<CMPEG2TuneRequest, &CLSID_MPEG2TuneRequest>,
    public IObjectWithSiteImplSec<CMPEG2TuneRequest>,
	public ISupportErrorInfo
{
public:

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_MPEG2TUNEREQUEST_PROGID, 
						   IDS_REG_MPEG2TUNEREQUEST_DESC,
						   LIBID_TunerLib,
						   CLSID_MPEG2TuneRequest, tvBoth);

BEGIN_COM_MAP(CMPEG2TuneRequest)
	COM_INTERFACE_ENTRY(IMPEG2TuneRequest)
	COM_INTERFACE_ENTRY(ITuneRequest)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CMPEG2TuneRequest)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    typedef IMPEG2TuneRequestImpl<CMPEG2TuneRequest> basetype;
    BEGIN_PROP_MAP(CMPEG2TuneRequest)
        CHAIN_PROP_MAP(basetype)
    END_PROP_MAP()


};

typedef CComQIPtr<IMPEG2TuneRequestSupport> PQMPEG2TuneRequestSupport;

/////////////////////////////////////////////////////////////////////////////
// CMPEG2TuneRequest
class ATL_NO_VTABLE CMPEG2TuneRequestFactory : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IMPEG2TuneRequestFactory, 
                         &__uuidof(IMPEG2TuneRequestFactory), 
                         &LIBID_TunerLib>,
	public CComCoClass<CMPEG2TuneRequestFactory, &CLSID_MPEG2TuneRequestFactory>,
    public IObjectWithSiteImplSec<CMPEG2TuneRequestFactory>,
	public ISupportErrorInfo
{
public:

REGISTER_AUTOMATION_OBJECT(IDS_REG_TUNEROBJ, 
						   IDS_REG_MPEG2TUNEREQUESTFACTORY_PROGID, 
						   IDS_REG_MPEG2TUNEREQUESTFACTORY_DESC,
						   LIBID_TunerLib,
						   CLSID_MPEG2TuneRequestFactory);

BEGIN_COM_MAP(CMPEG2TuneRequestFactory)
	COM_INTERFACE_ENTRY(IMPEG2TuneRequestFactory)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CMPEG2TuneRequestFactory)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
	END_CATEGORY_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(CreateTuneRequest)(ITuningSpace* pTS, IMPEG2TuneRequest** pTR) {
        if (!pTR) {
            return E_POINTER;
        }
        try {
            PQMPEG2TuneRequestSupport pt(pTS);
            if (!pt) {
                return Error(IDS_INVALID_TS, __uuidof(IMPEG2TuneRequestFactory), E_INVALIDARG);
            }
            CMPEG2TuneRequest* pNewTR = new CComObject<CMPEG2TuneRequest>;
			ATL_LOCK();
            ASSERT(!pNewTR->m_TS);
			HRESULT hr = pTS->Clone(&pNewTR->m_TS);
            if (FAILED(hr)) {
                pNewTR->Release();
                return hr;
            }
			pNewTR->AddRef();
            *pTR = pNewTR;
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }

    }

};

#endif //__MPEG2TUNEREQUESTFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidctlp.c ===
#ifndef TUNING_MODEL_ONLY
#include <msvidctl_p.c>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidaudiorenderer.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidAudioRenderer.cpp : Implementation of CMSVidAudioRenderer
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "MSVidCtl.h"
#include "MSVidAudioRenderer.h"
#include "MSVidVideoRenderer.h"
#include "dvdmedia.h"
#include "sbe.h"



DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAudioRenderer, CMSVidAudioRenderer)

/////////////////////////////////////////////////////////////////////////////
// CMSVidAudioRenderer

STDMETHODIMP CMSVidAudioRenderer::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidAudioRenderer
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CMSVidAudioRenderer::PreRun() {
    if (m_fUseKSRenderer) {
        return NOERROR;
    }
    // until sysaudio works correctly with ksproxy so that we only have 1 audio renderer
    // filter for both digital and analog we have to have two different rendering filters and
    // we don't which we're going to need.  in the analog case, after we're done building 
    // we're left with the dsound renderer hooked up to the analog filter which creates a 1/2 second(or so)
    // delayed echo.  find this scenario if it exists and disconnect the dsound renderer from the wavein filter
    TRACELM(TRACE_DEBUG, "CMSVidAudioRenderer::PreRun()");
    if (m_iAudioRenderer == -1) {
        TRACELM(TRACE_ERROR, "CMSVidAudioRenderer::PreRun() no dsr");
        return VFW_E_NO_AUDIO_HARDWARE;
    }
    DSFilter dsr(m_Filters[m_iAudioRenderer]);
    DSPin dsrin(*dsr.begin());
    if (dsrin.GetDirection() != PINDIR_INPUT) {
        TRACELM(TRACE_ERROR, "CMSVidAudioRenderer::PreRun() first dsound renderer pin not an input");
        return E_UNEXPECTED;
    }
    DSPin upstreampin;
    HRESULT hr = dsrin->ConnectedTo(&upstreampin);
    if (FAILED(hr) || !upstreampin) {
        // dsound renderer not connected to anything
        TRACELM(TRACE_DEBUG, "CMSVidAudioRenderer::PreRun() dsr not connected");
        return NOERROR;
    }
    DSFilter upstreamfilter(upstreampin.GetFilter());
    if (!upstreamfilter) {
        TRACELM(TRACE_ERROR, "CMSVidAudioRenderer::PreRun() upstream pin has no filter");
        return E_UNEXPECTED;
    }
    PQAudioInputMixer p(upstreamfilter);
    if (!p) {
        TRACELM(TRACE_ERROR, "CMSVidAudioRenderer::PreRun() upstream filter not wavein");
#if 0
        PQVidCtl pqCtl;
        hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
        if(FAILED(hr)){
            return hr;
        }
        
        CComQIPtr<IMSVidVideoRenderer> pq_VidVid;
        hr = pqCtl->get_VideoRendererActive(&pq_VidVid);
        if(FAILED(hr)){
            return hr;
        }

        CComQIPtr<IMSVidStreamBufferSource> pq_SBESource;
        CComQIPtr<IMSVidInputDevice> pq_Dev;
        hr = pqCtl->get_InputActive(&pq_Dev);
        if(FAILED(hr)){
            return hr;
        }
        pq_SBESource = pq_Dev;

        if(!pq_VidVid || !pq_SBESource){
            return NOERROR;
        }
        
        VWGraphSegment vVid(pq_VidVid);
        if(!vVid){
            return E_NOINTERFACE;
        }
        
        VWGraphSegment::iterator iV;
        for (iV = vVid.begin(); iV != vVid.end(); ++iV) {
            if (IsVideoRenderer(*iV)) {
                break;
            }
        }
        
        if (iV == vVid.end()) {
            TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() segment has no video mixer filter");
            return E_FAIL;
        }
        
        CComQIPtr<IMediaFilter> pq_MFVid(*iV);
        if(!pq_MFVid){
            return E_NOINTERFACE;
        }

        CComQIPtr<IMediaFilter> pq_MFAud(dsr);
        if(!pq_MFAud){
            return E_NOINTERFACE;
        }


        CComQIPtr<IMediaFilter> pq_MFGph(m_pGraph);
        if(!pq_MFGph){
            return E_NOINTERFACE;
        }

        VWGraphSegment vSbe(pq_SBESource);
        if(!vSbe){
            return E_NOINTERFACE;
        }
        
        CComQIPtr<IStreamBufferSource> pq_SBE;
        VWGraphSegment::iterator iS;
        for (iS = vSbe.begin(); iS != vSbe.end(); ++iS) {
            pq_SBE = (*iS);
            if (!!pq_SBE) {
                break;
            }
        }
        
        if (iS == vSbe.end()) {
            TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() segment has no video mixer filter");
            return E_FAIL;
        }    
        
        CComQIPtr<IReferenceClock> pq_IClock;
        hr = dsr->QueryInterface(&pq_IClock);
        if(FAILED(hr)){
            return hr;
        }
        
        if(!pq_IClock || !pq_MFVid || !pq_MFAud || !pq_MFGph){
            return E_NOINTERFACE;    
        }

        hr = pq_MFGph->SetSyncSource(pq_IClock);
        if(FAILED(hr)){
            return hr;
        }
#if 0


        hr = pq_MFilter2->SetSyncSource(pq_IClock);
        if(FAILED(hr)){
            return hr;
        }

#endif
        
        hr = pq_MFVid->SetSyncSource(pq_IClock);
        if(FAILED(hr)){
            return hr;
        }
#endif
        return NOERROR;
    }
    bool rc = m_pGraph.DisconnectFilter(dsr, false, false);
    if (!rc) {
        TRACELM(TRACE_ERROR, "CMSVidAudioRenderer::PreRun() disconnect filter failed");
        return E_UNEXPECTED;
    }

    return NOERROR;
}

STDMETHODIMP CMSVidAudioRenderer::Build() {
    if (!m_fInit || !m_pGraph) {
        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
    }
    try {
        CString csName;
		DSFilter ar;
        PQCreateDevEnum SysEnum(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
        if(m_iAudioRenderer==-1){
            if (m_fUseKSRenderer) {
                csName = _T("KS System Renderer");
                // undone: use ks system renderer
            } else if (m_fAnalogOnly) {
                csName = _T("Analog Audio Renderer");
                DSDevices ARList(SysEnum, CLSID_AudioInputDeviceCategory);
                if (ARList.begin() != ARList.end()) {
                    ar = m_pGraph.LoadFilter(*ARList.begin(), csName);
                    m_pAR = ar;
                }
            } else if (m_fDigitalOnly) {
                csName = _T("Default DSound Renderer");
                ar = DSFilter(CLSID_DSoundRender);
                m_pAR = ar;
            } else {
                // NOTE: its important that digital audio be first so that we short circuit
                // loading 8 billion audio codecs trying to connect a digital source
                // to the analog renderer.  there aren't any analog codecs(a physical impossiblity),
                // so we don't have to worry about the reverse case.
                csName = _T("Default DSound Renderer");
                ar = DSFilter(CLSID_DSoundRender);
                if (ar) {
                    m_pGraph.AddFilter(ar, csName);
                    m_Filters.push_back(ar);
                }
                
                csName = _T("Analog Audio Renderer");
                DSDevices ARList(SysEnum, CLSID_AudioInputDeviceCategory);
                if (ARList.begin() != ARList.end()) {
                    ar = m_pGraph.LoadFilter(*ARList.begin(), csName);
                }
            }
        }
        if (ar) {
            m_pGraph.AddFilter(ar, csName);
            m_Filters.push_back(ar);
            m_iAudioRenderer = 0;
        }
        if(m_iAudioRenderer == -1){
            return VFW_E_NO_AUDIO_HARDWARE;
        }
        else{
            return NOERROR;
        }
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

#endif //TUNING_MODEL_ONLY

// end of file - msvidaudiorenderer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\mslcid.h ===
/*************************************************************/
/* Name: MSLCID.h
/* Description: 
/*************************************************************/
#ifndef MSLCID_H_INCLUDE
#define MSLCID_H_INCLUDE

class MSLangID  
{
public:
	struct LanguageList
	{
		UINT   ResourceID;
		WORD   LangID;
	};

	int m_LLlength;
	LanguageList* m_LL;

    virtual ~MSLangID() {};

    MSLangID() {        
        static LanguageList LL[] = {
            { IDS_DVD_LANG1, LANG_AFRIKAANS },
            { IDS_DVD_LANG2, LANG_ALBANIAN },
            { IDS_DVD_LANG3, LANG_ARABIC },
            { IDS_DVD_LANG4, LANG_BASQUE },
            { IDS_DVD_LANG5, LANG_BELARUSIAN },
            { IDS_DVD_LANG6, LANG_BULGARIAN },
            { IDS_DVD_LANG7, LANG_CATALAN },
            { IDS_DVD_LANG8, LANG_CHINESE },
            { IDS_DVD_LANG9, LANG_CROATIAN },
            { IDS_DVD_LANG10, LANG_CZECH },
            { IDS_DVD_LANG11, LANG_DANISH },
            { IDS_DVD_LANG12, LANG_DUTCH },
            { IDS_DVD_LANG13, LANG_ENGLISH },
            { IDS_DVD_LANG14, LANG_ESTONIAN },
            { IDS_DVD_LANG15, LANG_FAEROESE },
            { IDS_DVD_LANG16, LANG_FARSI },
            { IDS_DVD_LANG17, LANG_FINNISH },
            { IDS_DVD_LANG18, LANG_FRENCH },
            { IDS_DVD_LANG19, LANG_GERMAN },
            { IDS_DVD_LANG20, LANG_GREEK },
            { IDS_DVD_LANG21, LANG_HEBREW },
            { IDS_DVD_LANG22, LANG_HUNGARIAN },
            { IDS_DVD_LANG23, LANG_ICELANDIC },
            { IDS_DVD_LANG24, LANG_INDONESIAN },
            { IDS_DVD_LANG25, LANG_ITALIAN },
            { IDS_DVD_LANG26, LANG_JAPANESE },
            { IDS_DVD_LANG27, LANG_KOREAN },
            { IDS_DVD_LANG28, LANG_LATVIAN },
            { IDS_DVD_LANG29, LANG_LITHUANIAN },
            { IDS_DVD_LANG30, LANG_MALAY },
            { IDS_DVD_LANG31, LANG_NORWEGIAN },
            { IDS_DVD_LANG32, LANG_POLISH },
            { IDS_DVD_LANG33, LANG_PORTUGUESE },
            { IDS_DVD_LANG34, LANG_ROMANIAN },
            { IDS_DVD_LANG35, LANG_RUSSIAN },
            { IDS_DVD_LANG36, LANG_SERBIAN },
            { IDS_DVD_LANG37, LANG_SLOVAK },
            { IDS_DVD_LANG38, LANG_SLOVENIAN },
            { IDS_DVD_LANG39, LANG_SPANISH },
            { IDS_DVD_LANG40, LANG_SWAHILI },
            { IDS_DVD_LANG41, LANG_SWEDISH },
            { IDS_DVD_LANG42, LANG_THAI },
            { IDS_DVD_LANG43, LANG_TURKISH },
            { IDS_DVD_LANG44, LANG_UKRAINIAN },
        };
        m_LL = LL;
        m_LLlength = sizeof(LL)/sizeof(LL[0]);
    }/* of Contructor */
    
    static LPTSTR LoadStringFromRes(DWORD redId){
        
        TCHAR *string = new TCHAR[MAX_PATH];
        ::ZeroMemory(string, sizeof(TCHAR) * MAX_PATH);
        if (::LoadString(_Module.GetModuleInstance(), redId, string, MAX_PATH))
            return string;
        
        delete[] string;
        return NULL;
    }/* end of function LoadStringFromRes */
    
    LPTSTR GetLanguageFromLCID(LCID lcid){
        
        // Try to get it from the system first
        TCHAR  *szLanguage = new TCHAR[MAX_PATH];
        int iRet = ::GetLocaleInfo(lcid, LOCALE_SENGLANGUAGE, szLanguage, MAX_PATH);
        if (iRet) {
            return szLanguage;
        }
        
        delete[] szLanguage;
        // Else try to find it in the private LCID table
        for(int i = 0; i < m_LLlength; i++) {
            if(m_LL[i].LangID == PRIMARYLANGID(LANGIDFROMLCID(lcid)))
                return LoadStringFromRes(m_LL[i].ResourceID);
        }
        return NULL;
    }/* end of function GetLanguageFromLCID */
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidcp.h ===
//===========================================================================
//
// msvidcp.h : msvidctl event connection point handler
// Copyright (c) Microsoft Corporation 1999-2000.
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _MSVideoCP_H_
#define _MSVideoCP_H_

//#import "..\..\common\include\MSVidCtl.tlb" raw_interfaces_only, raw_native_types, no_namespace, named_guids	//"Import typelib"
template <class T>
class CProxy_IMSVidCtlEvents : public IConnectionPointImpl<T, &DIID__IMSVidCtlEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_Click()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(DISPID_CLICK, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_DblClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(DISPID_DBLCLICK, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_KeyDown(SHORT * KeyCode, SHORT Shift)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = KeyCode;
				pvars[0] = Shift;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(DISPID_KEYDOWN, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_KeyPress(SHORT * KeyAscii)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = *KeyAscii;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(DISPID_KEYPRESS, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_KeyUp(SHORT * KeyCode, SHORT Shift)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = KeyCode;
				pvars[0] = Shift;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(DISPID_KEYUP, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_MouseDown(SHORT Button, SHORT Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[3] = Button;
				pvars[2] = Shift;
				pvars[1] = x;
				pvars[0] = y;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(DISPID_MOUSEDOWN, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_MouseMove(SHORT Button, SHORT Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[3] = Button;
				pvars[2] = Shift;
				pvars[1] = x;
				pvars[0] = y;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(DISPID_MOUSEMOVE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_MouseUp(SHORT Button, SHORT Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[3] = Button;
				pvars[2] = Shift;
				pvars[1] = x;
				pvars[0] = y;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(DISPID_MOUSEUP, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_Error(SHORT Number, BSTR * Description, LONG Scode, BSTR Source, BSTR HelpFile, LONG HelpContext, CHAR * CancelDisplay)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[7];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[6] = Number;
				pvars[5] = Description;
				pvars[4] = Scode;
				pvars[3] = Source;
				pvars[2] = HelpFile;
				pvars[1] = HelpContext;
				pvars[0] = CancelDisplay;
				DISPPARAMS disp = { pvars, NULL, 7, 0 };
				pDispatch->Invoke(DISPID_ERROREVENT, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
    VOID Fire_StateChange(MSVidCtlStateList PrevState, MSVidCtlStateList CurrState)
    {
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::FireStateChange(" << PrevState << ", " << CurrState << ")"), "");
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{

                pvars[1] = PrevState;
				pvars[0] = CurrState;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(dispidStateChange, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;

    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidaudiorenderer.h ===
//==========================================================================;
// MSVidAudioRenderer.h : Declaration of the CMSVidAudioRenderer
// copyright (c) Microsoft Corp. 1998-1999.
//==========================================================================;

#ifndef __MSVidAUDIORENDERER_H_
#define __MSVidAUDIORENDERER_H_

#pragma once

#include "segimpl.h"
#include "devimpl.h"
#include "seg.h"
#include <objectwithsiteimplsec.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMSVidAudioRenderer
class ATL_NO_VTABLE __declspec(uuid("37B03544-A4C8-11d2-B634-00C04F79498E")) CMSVidAudioRenderer : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidAudioRenderer, &CLSID_MSVidAudioRenderer>,
    public IObjectWithSiteImplSec<CMSVidAudioRenderer>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CMSVidAudioRenderer>,
	public IMSVidGraphSegmentImpl<CMSVidAudioRenderer, MSVidSEG_DEST, &GUID_NULL>,
    public IMSVidDeviceImpl<CMSVidAudioRenderer, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidAudioRenderer>
{
public:
    CMSVidAudioRenderer() : 
		m_fUseKSRenderer(false), 
		m_fAnalogOnly(false), 
		m_fDigitalOnly(false),
        m_iAudioRenderer(-1)
	{}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_AUDIORENDERER_PROGID, 
						   IDS_REG_AUDIORENDERER_DESC,
						   LIBID_MSVidCtlLib,
						   CLSID_MSVidAudioRenderer);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidAudioRenderer)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidAudioRenderer)
	COM_INTERFACE_ENTRY(IMSVidOutputDevice)
	COM_INTERFACE_ENTRY(IMSVidDevice)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CMSVidAudioRenderer)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSVidAudioRenderer)
END_CONNECTION_POINT_MAP()

	DSFilter m_pAR;
    int m_iAudioRenderer;
	bool m_fUseKSRenderer;
	bool m_fAnalogOnly;
	bool m_fDigitalOnly;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    CComBSTR __declspec(property(get=GetName)) m_Name;
    CComBSTR GetName(void) {
        return CComBSTR(OLESTR("audio renderer"));
    }

// IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		if (Name == NULL)
			return E_POINTER;
        try {
		    *Name = m_Name.Copy();	
        } catch(...) {
            return E_POINTER;
        }
		return NOERROR;
	}
	STDMETHOD(get_Status)(LONG * Status)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		if (Status == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_Segment)(IMSVidGraphSegment * * pIMSVidGraphSegment)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		if (pIMSVidGraphSegment == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
// IMSVidAudioRenderer
	STDMETHOD(get_Volume)(LONG * plPercent)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		if (plPercent == NULL)
			return E_POINTER;			
		try {
			if (!m_pGraph) {
				Error(IDS_INVALID_STATE, __uuidof(IMSVidAudioRenderer), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
			}
			PQBasicAudio pBA(m_pGraph);
			if (!pBA) {
				Error(IDS_E_CANTQI, __uuidof(IBasicAudio), E_NOINTERFACE);
			}
			return pBA->get_Volume(plPercent);
		} catch(...) {
			return E_POINTER;
		}
	}
	STDMETHOD(put_Volume)(LONG plPercent)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		try {
			if (!m_pGraph) {
				Error(IDS_INVALID_STATE, __uuidof(IMSVidAudioRenderer), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
			}
			PQBasicAudio pBA(m_pGraph);
			if (!pBA) {
				Error(IDS_E_CANTQI, __uuidof(IBasicAudio), E_NOINTERFACE);
			}
			return pBA->put_Volume(plPercent);
		} catch(...) {
			return E_UNEXPECTED;
		}
	}
	STDMETHOD(get_Balance)(LONG * plPercent)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		if (plPercent == NULL)
			return E_POINTER;
		try {
			if (!m_pGraph) {
				Error(IDS_INVALID_STATE, __uuidof(IMSVidAudioRenderer), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
			}
			PQBasicAudio pBA(m_pGraph);
			if (!pBA) {
				Error(IDS_E_CANTQI, __uuidof(IBasicAudio), E_NOINTERFACE);
			}
			return pBA->get_Balance(plPercent);
		} catch(...) {
			return E_POINTER;
		}
	}
	STDMETHOD(put_Balance)(LONG plPercent)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		try {
			if (!m_pGraph) {
				Error(IDS_INVALID_STATE, __uuidof(IMSVidAudioRenderer), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
			}
			PQBasicAudio pBA(m_pGraph);
			if (!pBA) {
				Error(IDS_E_CANTQI, __uuidof(IBasicAudio), E_NOINTERFACE);
			}
			return pBA->put_Balance(plPercent);
		} catch(...) {
			return E_UNEXPECTED;
		}
	}

// IMSVidGraphSegment
	STDMETHOD(Build)();
    STDMETHOD(PreRun)();
};

#endif //__MSVidAUDIORENDERER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msviddataservices.h ===
//==========================================================================;
// MSVidDataServices.h : Declaration of the CMSVidDataServices
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __MSVidDataServices_H_
#define __MSVidDataServices_H_

#include <algorithm>
#include <tchar.h>
#include <objectwithsiteimplsec.h>
#include "segimpl.h"
#include "dataserviceimpl.h"

#include "seg.h"

typedef CComQIPtr<ITuner> PQMSVidDataServices;

/////////////////////////////////////////////////////////////////////////////
// CMSVidDataServices
class ATL_NO_VTABLE __declspec(uuid("334125C0-77E5-11d3-B653-00C04F79498E")) CDataServices : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDataServices, &__uuidof(CDataServices)>,
    public IObjectWithSiteImplSec<CDataServices>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CDataServices>,
	public IMSVidGraphSegmentImpl<CDataServices, MSVidSEG_XFORM, &GUID_NULL>,
    public IMSVidDataServicesImpl<CDataServices, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidDataServices>
{
public:
    CDataServices() : m_iIPSink(-1) {
	}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_DATASERVICES_PROGID, 
						   IDS_REG_DATASERVICES_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CDataServices));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDataServices)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidDataServices)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMSVidFeature)
	COM_INTERFACE_ENTRY(IMSVidDevice)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CDataServices)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CDataServices)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    PQCreateDevEnum m_pSystemEnum;
    int m_iIPSink;

    HRESULT Unload(void) {
        IMSVidGraphSegmentImpl<CDataServices, MSVidSEG_XFORM, &GUID_NULL>::Unload();
        m_iIPSink = -1;
		return NOERROR;
	}
// IMSVidGraphSegment
    STDMETHOD(Build)() {
        return NOERROR;
    }

    STDMETHOD(PreRun)() {
        return NOERROR;
    }

	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl)
	{
        if (!m_fInit) {
            return CO_E_NOTINITIALIZED;
        }
        try {
            if (!pCtl) {
                return Unload();
            }
            if (m_pContainer) {
				if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
					return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidDataServices), CO_E_ALREADYINITIALIZED);
				} else {
					return NO_ERROR;
				}
            }
            // DON'T addref the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            m_pContainer.p = pCtl;
            m_pGraph = m_pContainer.GetGraph();

			// bring in all bda renderers
            m_pSystemEnum = PQCreateDevEnum(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
            DSDevices pe(m_pSystemEnum, KSCATEGORY_IP_SINK);
            DSDevices::iterator pit = pe.begin();
            if (!*pe.begin()) {
		        TRACELM(TRACE_ERROR, "CMSVidDataServices::put_Container() missing ipsink category, drivers not installed");
                return E_FAIL;
            }
            for (; pit != pe.end(); ++pit) {
			    DSFilter ipsink(m_pGraph.AddMoniker(*pe.begin()));
			    if (!ipsink) {
		            TRACELM(TRACE_ERROR, "CMSVidDataServices::put_Container() can't load ip sink");
				    return E_FAIL;
			    }
			    m_Filters.push_back(ipsink);
            }
			m_iIPSink = 0;  // assume ipsink was first in category
			return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}

    // IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name)
	{
        if (!m_fInit) {
            return CO_E_NOTINITIALIZED;
        }
        try {
            return GetName(((m_iIPSink > -1) ? (m_Filters[m_iIPSink]) : DSFilter()), m_pDev, CComBSTR(_T("BDA IPSink"))).CopyTo(Name);
        } catch(...) {
            return E_POINTER;
        }
	}

};

STDMETHODIMP CDataServices::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidDataServices
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

#endif //__MSVidDataServices_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidctl.cpp ===
// MSVidCtl.cpp : Implementation of DLL Exports.

#include "stdafx.h"

#if 0
#ifndef TUNING_MODEL_ONLY
#include "Devices.h"
#ifndef _WIN64
#include "bdatuner.h"
#include "MSVidTVTuner.h"
#include "MSVidVideoRenderer.h"
#include "MSVidAudioRenderer.h"
#include "MSVidFilePlayback.h"
#include "MSVidSBESource.h"
#include "MSVidWebDVD.h"
#include "MSVidDVDAdm.h"
#include "seg.h"					/// ??? Does this go here or above the _WIN64 ??? (jb 8/31)
#include "closedcaptioning.h"
#include "Composition.h"
#include "vidprot.h"
#include "anacap.h"
#include "anadata.h"
#include "MSViddataservices.h"
#include "WebDVDComp.h"
#include "WebDVDARComp.h"
#include "mp2cc.h"
#include "fp2vr.h"
#include "fp2ar.h"
#include "enc2sin.h"
#include "dat2sin.h"
#include "dat2xds.h"
#include "ana2xds.h"
#include "ana2enc.h"
#include "sbes2cc.h"
#include "sbes2vrm.h"
#include "VidCtl.h"
#include "msvidencoder.h"

#endif //_WIN64

#include "topwin.h"
#include "msvidStreamBufferrecorder.h"
#include "cmseventbinder.h"
#endif //TUNING_MODEL_ONLY

#include "createregbag.h"
#include "TuningSpaceContainer.h"
#include "ATSCTS.h"
#include "AnalogTVTS.h"
#include "AuxiliaryInTs.h"
#include "AnalogRadioTS.h"
#include "DVBTS.h"
#include "DVBSTS.h"
#include "Component.h"
#include "Components.h"
#include "ComponentTypes.h"
#include "ComponentType.h"
#include "LanguageComponentType.h"
#include "MPEG2ComponentType.h"
#include "ATSCComponentType.h"
#include "MPEG2Component.h"
#include "channeltunerequest.h"
#include "atscchanneltunerequest.h"
#include "atsclocator.h"
#include "dvbtlocator.h"
#include "dvbslocator.h"
#include "dvbtunerequest.h"

#else
#ifndef TUNING_MODEL_ONLY
#include "Devices.h"
#include "seg.h"
#endif //TUNING_MODEL_ONLY
#include "TuningSpaceContainer.h"

#endif
#include "dlldatax.h"
CComModule _Module;

#ifndef TUNING_MODEL_ONLY
    DECLARE_EXTERN_OBJECT_ENTRY(CVidCtl)
    // typesafe device collections
    DECLARE_EXTERN_OBJECT_ENTRY(CInputDevices)
    DECLARE_EXTERN_OBJECT_ENTRY(COutputDevices)
    DECLARE_EXTERN_OBJECT_ENTRY(CVideoRendererDevices)
    DECLARE_EXTERN_OBJECT_ENTRY(CAudioRendererDevices)
    DECLARE_EXTERN_OBJECT_ENTRY(CFeatures)
    // device segments
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidBDATuner)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidTVTuner)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidVideoRenderer)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidAudioRenderer)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidFilePlayback)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidWebDVD)
    DECLARE_EXTERN_OBJECT_ENTRY(CClosedCaptioning)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidStreamBufferSink)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidStreamBufferSource)
    // feature segments
    DECLARE_EXTERN_OBJECT_ENTRY(CDataServices)
    DECLARE_EXTERN_OBJECT_ENTRY(CEncoder)
    DECLARE_EXTERN_OBJECT_ENTRY(CXDS)
    //DECLARE_EXTERN_OBJECT_ENTRY(CMSVidTVEGSeg)
	//DECLARE_EXTERN_OBJECT_ENTRY(CMSVidCAGSeg)
    // composition segments
    DECLARE_EXTERN_OBJECT_ENTRY(CComposition)
    DECLARE_EXTERN_OBJECT_ENTRY(CAnaCapComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CAnaDataComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CWebDVDComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CWebDVDARComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CMP2CCComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CAnaSinComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CMP2SinComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CFP2VRComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CFP2ARComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CEnc2SinComp)    
    DECLARE_EXTERN_OBJECT_ENTRY(CDat2XDSComp)    
    DECLARE_EXTERN_OBJECT_ENTRY(CDat2SinComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CAna2XDSComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CAna2EncComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CSbeS2CCComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CSbeS2VmrComp)
    // pluggable protocols
    DECLARE_EXTERN_OBJECT_ENTRY(CTVProt)
    DECLARE_EXTERN_OBJECT_ENTRY(CDVDProt)
    // utility objects
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidWebDVDAdm)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSEventBinder)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidRect)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidStreamBufferRecordingControl)
#endif
// utility objects
DECLARE_EXTERN_OBJECT_ENTRY(CCreateRegBag)
// tuning model objects
DECLARE_EXTERN_OBJECT_ENTRY(CSystemTuningSpaces)
DECLARE_EXTERN_OBJECT_ENTRY(CATSCTS)
DECLARE_EXTERN_OBJECT_ENTRY(CAnalogTVTS)
DECLARE_EXTERN_OBJECT_ENTRY(CAuxInTS)
DECLARE_EXTERN_OBJECT_ENTRY(CAnalogRadioTS)
DECLARE_EXTERN_OBJECT_ENTRY(CDVBTS)
DECLARE_EXTERN_OBJECT_ENTRY(CDVBSTS)
DECLARE_EXTERN_OBJECT_ENTRY(CChannelTuneRequest)
DECLARE_EXTERN_OBJECT_ENTRY(CATSCChannelTuneRequest)
DECLARE_EXTERN_OBJECT_ENTRY(CDVBTuneRequest)
DECLARE_EXTERN_OBJECT_ENTRY(CMPEG2TuneRequest)
DECLARE_EXTERN_OBJECT_ENTRY(CComponent)
DECLARE_EXTERN_OBJECT_ENTRY(CMPEG2Component)
DECLARE_EXTERN_OBJECT_ENTRY(CComponentTypes)
DECLARE_EXTERN_OBJECT_ENTRY(CComponentType)
DECLARE_EXTERN_OBJECT_ENTRY(CLanguageComponentType)
DECLARE_EXTERN_OBJECT_ENTRY(CMPEG2ComponentType)
DECLARE_EXTERN_OBJECT_ENTRY(CATSCComponentType)
DECLARE_EXTERN_OBJECT_ENTRY(CATSCLocator)
DECLARE_EXTERN_OBJECT_ENTRY(CDVBTLocator)
DECLARE_EXTERN_OBJECT_ENTRY(CDVBSLocator)
DECLARE_EXTERN_OBJECT_ENTRY(CMPEG2TuneRequestFactory)
#ifndef TUNING_MODEL_ONLY
DECLARE_EXTERN_OBJECT_ENTRY(CBroadcastEventService)
#endif

BEGIN_EXTERN_OBJECT_MAP(ObjectMap)

#ifndef TUNING_MODEL_ONLY
	// primary control
    EXTERN_OBJECT_ENTRY(CVidCtl)
	// typesafe device collections
    EXTERN_OBJECT_ENTRY(CInputDevices)
    EXTERN_OBJECT_ENTRY(COutputDevices)
    EXTERN_OBJECT_ENTRY(CVideoRendererDevices)
    EXTERN_OBJECT_ENTRY(CAudioRendererDevices)
    EXTERN_OBJECT_ENTRY(CFeatures)
	// device segments
    EXTERN_OBJECT_ENTRY(CMSVidBDATuner)
    EXTERN_OBJECT_ENTRY(CMSVidTVTuner)
    EXTERN_OBJECT_ENTRY(CMSVidVideoRenderer)
    EXTERN_OBJECT_ENTRY(CMSVidAudioRenderer)
    EXTERN_OBJECT_ENTRY(CMSVidFilePlayback)
    EXTERN_OBJECT_ENTRY(CMSVidWebDVD)
	EXTERN_OBJECT_ENTRY(CClosedCaptioning)
    EXTERN_OBJECT_ENTRY(CMSVidStreamBufferSink)
    EXTERN_OBJECT_ENTRY(CMSVidStreamBufferSource)
    // feature segments
    EXTERN_OBJECT_ENTRY(CDataServices)
    EXTERN_OBJECT_ENTRY(CEncoder)
    EXTERN_OBJECT_ENTRY(CXDS)
	//EXTERN_OBJECT_ENTRY(CMSVidCAGSeg)
	//EXTERN_OBJECT_ENTRY(CMSVidTVEGSeg)
	// composition segments
    EXTERN_OBJECT_ENTRY(CComposition)
    EXTERN_OBJECT_ENTRY(CAnaCapComp)
    EXTERN_OBJECT_ENTRY(CAnaDataComp)
    EXTERN_OBJECT_ENTRY(CWebDVDComp)
    EXTERN_OBJECT_ENTRY(CWebDVDARComp)
    EXTERN_OBJECT_ENTRY(CMP2CCComp)
    EXTERN_OBJECT_ENTRY(CAnaSinComp)
    EXTERN_OBJECT_ENTRY(CMP2SinComp)
    EXTERN_OBJECT_ENTRY(CFP2VRComp)
    EXTERN_OBJECT_ENTRY(CFP2ARComp)
    EXTERN_OBJECT_ENTRY(CEnc2SinComp)    
    EXTERN_OBJECT_ENTRY(CDat2XDSComp)    
    EXTERN_OBJECT_ENTRY(CDat2SinComp)
    EXTERN_OBJECT_ENTRY(CAna2XDSComp)
    EXTERN_OBJECT_ENTRY(CAna2EncComp)    
    EXTERN_OBJECT_ENTRY(CSbeS2CCComp)    
    EXTERN_OBJECT_ENTRY(CSbeS2VmrComp)    
	// pluggable protocols
    EXTERN_OBJECT_ENTRY(CTVProt)
    EXTERN_OBJECT_ENTRY(CDVDProt)
    // utility objects
    EXTERN_OBJECT_ENTRY(CMSVidWebDVDAdm)
    EXTERN_OBJECT_ENTRY(CMSEventBinder)
    EXTERN_OBJECT_ENTRY(CMSVidStreamBufferRecordingControl)
#endif
	// utility objects
    EXTERN_OBJECT_ENTRY(CCreateRegBag)
	// tuning model objects
    EXTERN_OBJECT_ENTRY(CSystemTuningSpaces)
    EXTERN_OBJECT_ENTRY(CATSCTS)
    EXTERN_OBJECT_ENTRY(CAnalogTVTS)
    EXTERN_OBJECT_ENTRY(CAuxInTS)
    EXTERN_OBJECT_ENTRY(CAnalogRadioTS)
    EXTERN_OBJECT_ENTRY(CDVBTS)
    EXTERN_OBJECT_ENTRY(CDVBSTS)
    EXTERN_OBJECT_ENTRY(CChannelTuneRequest)
    EXTERN_OBJECT_ENTRY(CATSCChannelTuneRequest)
    EXTERN_OBJECT_ENTRY(CDVBTuneRequest)
    EXTERN_OBJECT_ENTRY(CMPEG2TuneRequest)
    EXTERN_OBJECT_ENTRY(CComponent)
    EXTERN_OBJECT_ENTRY(CMPEG2Component)
    EXTERN_OBJECT_ENTRY(CComponentTypes)
    EXTERN_OBJECT_ENTRY(CComponentType)
    EXTERN_OBJECT_ENTRY(CLanguageComponentType)
    EXTERN_OBJECT_ENTRY(CMPEG2ComponentType)
    EXTERN_OBJECT_ENTRY(CATSCComponentType)
    EXTERN_OBJECT_ENTRY(CATSCLocator)
    EXTERN_OBJECT_ENTRY(CDVBTLocator)
    EXTERN_OBJECT_ENTRY(CDVBSLocator)
    EXTERN_OBJECT_ENTRY(CMPEG2TuneRequestFactory)
#ifndef TUNING_MODEL_ONLY
    EXTERN_OBJECT_ENTRY(CBroadcastEventService)
#endif
END_EXTERN_OBJECT_MAP()

using namespace BDATuningModel;
#ifndef TUNING_MODEL_ONLY
using namespace MSVideoControl;
#endif

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
    if (dwReason == DLL_PROCESS_ATTACH)
    {
#ifdef _DEBUG
        // Turn on leak-checking bit
        int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
        _CrtSetDbgFlag( tmpFlag );
#endif

        INTERNALIZE_OBJMAP(ObjectMap);
        _Module.Init(ObjectMap, hInstance, &LIBID_MSVidCtlLib);
        DisableThreadLibraryCalls(hInstance);
#ifndef TUNING_MODEL_ONLY
        // work around compiler bug where static member intializer's not being ctord
#ifdef DEBUG
        CString csModuleName;
        csModuleName.LoadString(IDS_PROJNAME);
        DebugInit(csModuleName);
#endif
        CtorStaticDSExtendFwdSeqPMFs();
        CtorStaticVWSegmentFwdSeqPMFs();
        CtorStaticVWDevicesFwdSeqPMFs();
#endif
    } else if (dwReason == DLL_PROCESS_DETACH) {
#ifndef TUNING_MODEL_ONLY
        // work around compiler bug where static member intializer's not being ctord
        DtorStaticDSExtendFwdSeqPMFs();
        DtorStaticVWSegmentFwdSeqPMFs();
        DtorStaticVWDevicesFwdSeqPMFs();
#ifdef DEBUG
        DebugTerm();
#endif
#endif
        _Module.Term();
        DESTROY_OBJMAP(ObjectMap);
    }
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifndef TUNING_MODEL_ONLY
    // register secondary .tlb(s)
    HRESULT hr = AtlModuleRegisterTypeLib(&_Module, OLESTR("\\2"));				// tuner.tlb
    if (SUCCEEDED(hr)) {
#else
                HRESULT hr;
#endif
                // registers object, typelib and all interfaces in typelib
                hr = _Module.RegisterServer(TRUE);
                if (SUCCEEDED(hr)) {
                    hr = PrxDllRegisterServer();
                    if (SUCCEEDED(hr)) {
#ifdef REGISTER_CANONICAL_TUNING_SPACES
                        hr = RegisterTuningSpaces(_Module.GetModuleInstance());// uses objects in this .dll must be done after any other registering
#endif
                    }
                }
#ifndef TUNING_MODEL_ONLY
    }
#endif
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef REGISTER_CANONICAL_TUNING_SPACES
    // ignore rc and unreg everything we can
    UnregisterTuningSpaces();  // uses objects in this .dll must be done before any other unregistering
#endif
    PrxDllUnregisterServer();
#ifndef TUNING_MODEL_ONLY
	AtlModuleUnRegisterTypeLib(&_Module, OLESTR("\\2"));  // tuner.tlb
#endif
	_Module.UnregisterServer(TRUE);

	return NOERROR;
}
// end of file - msvidctl.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msviddvdbookmark.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: Bookmark.h                                                      */
/* Description: Implementation of Bookmark API                           */
/* Author: Steve Rowe                                                    */
/* Modified: David Janecek                                               */
/*************************************************************************/
#ifndef __BOOKMARK_H
#define __BOOKMARK_H

class CBookmark {

public:	
    static HRESULT SaveToRegistry(IDvdState *ppBookmark);
    static HRESULT LoadFromRegistry(IDvdState **ppBookmark);
    static HRESULT DeleteFromRegistry();

};/* end of class CBookmark */

#endif // __BOOKMARK_H
/*************************************************************************/
/* Function: Bookmark.h                                                  */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidencoder.cpp ===
//==========================================================================;
// MSVidEncoder.cpp : Declaration of the CMSVidEncoder
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#ifndef TUNING_MODEL_ONLY
#include "msvidencoder.h"

// HARD CODED pids for program stream video and audio
const ULONG g_AudioID = 0xC0;
const ULONG g_VideoID = 0xE0;

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidEncoder, CEncoder)

// "Copied" From Demux Proppage

static BYTE g_Mpeg2ProgramVideo [] = {
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcSource.left              = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcSource.top               = 0x00000000
    0xD0, 0x02, 0x00, 0x00,                         //  .hdr.rcSource.right             = 0x000002d0
    0xE0, 0x01, 0x00, 0x00,                         //  .hdr.rcSource.bottom            = 0x000001e0
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.left              = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.top               = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.right             = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.bottom            = 0x00000000
    0x00, 0x09, 0x3D, 0x00,                         //  .hdr.dwBitRate                  = 0x003d0900
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwBitErrorRate             = 0x00000000
    0x63, 0x17, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, //  .hdr.AvgTimePerFrame            = 0x0000000000051763
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwInterlaceFlags           = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwCopyProtectFlags         = 0x00000000
    0x04, 0x00, 0x00, 0x00,                         //  .hdr.dwPictAspectRatioX         = 0x00000004
    0x03, 0x00, 0x00, 0x00,                         //  .hdr.dwPictAspectRatioY         = 0x00000003
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwReserved1                = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwReserved2                = 0x00000000
    0x28, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biSize           = 0x00000028
    0xD0, 0x02, 0x00, 0x00,                         //  .hdr.bmiHeader.biWidth          = 0x000002d0
    0xE0, 0x01, 0x00, 0x00,                         //  .hdr.bmiHeader.biHeight         = 0x00000000
    0x00, 0x00,                                     //  .hdr.bmiHeader.biPlanes         = 0x0000
    0x00, 0x00,                                     //  .hdr.bmiHeader.biBitCount       = 0x0000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biCompression    = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biSizeImage      = 0x00000000
    0xD0, 0x07, 0x00, 0x00,                         //  .hdr.bmiHeader.biXPelsPerMeter  = 0x000007d0
    0x27, 0xCF, 0x00, 0x00,                         //  .hdr.bmiHeader.biYPelsPerMeter  = 0x0000cf27
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biClrUsed        = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biClrImportant   = 0x00000000
    0x98, 0xF4, 0x06, 0x00,                         //  .dwStartTimeCode                = 0x0006f498
    0x56, 0x00, 0x00, 0x00,                         //  .cbSequenceHeader               = 0x00000056
    0x02, 0x00, 0x00, 0x00,                         //  .dwProfile                      = 0x00000002
    0x02, 0x00, 0x00, 0x00,                         //  .dwLevel                        = 0x00000002
    0x00, 0x00, 0x00, 0x00,                         //  .Flags                          = 0x00000000
                                                    //  .dwSequenceHeader [1]
    0x00, 0x00, 0x01, 0xB3, 0x2D, 0x01, 0xE0, 0x24,
    0x09, 0xC4, 0x23, 0x81, 0x10, 0x11, 0x11, 0x12,
    0x12, 0x12, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
    0x18, 0x18, 0x18, 0x19, 0x18, 0x18, 0x18, 0x19,
    0x1A, 0x1A, 0x1A, 0x1A, 0x19, 0x1B, 0x1B, 0x1B,
    0x1B, 0x1B, 0x1C, 0x1C, 0x1C, 0x1C, 0x1E, 0x1E,
    0x1E, 0x1F, 0x1F, 0x21, 0x00, 0x00, 0x01, 0xB5,
    0x14, 0x82, 0x00, 0x01, 0x00, 0x00
} ;

//  WaveFormatEx format block; generated with the following settings:
//
//  fwHeadFlags         = 0x1c;
//  wHeadEmphasis       = 1;
//  fwHeadModeExt       = 1;
//  fwHeadMode          = 1;
//  dwHeadBitrate       = 0x3e800;
//  fwHeadLayer         = 0x2;
//  wfx.cbSize          = 0x16;
//  wfx.wBitsPerSample  = 0;
//  wfx.nBlockAlign     = 0x300;
//  wfx.nAvgBytesPerSec = 0x7d00;
//  wfx.nSamplesPerSec  = 0xbb80;
//  wfx.nChannels       = 2;
//  wfx.wFormatTag      = 0x50;
//  dwPTSLow            = 0;
//  dwPTSHigh           = 0;
static BYTE g_MPEG1AudioFormat [] = {
    0x50, 0x00, 0x02, 0x00, 0x80, 0xBB, 0x00, 0x00,
    0x00, 0x7D, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x16, 0x00, 0x02, 0x00, 0x00, 0xE8, 0x03, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x1C, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
} ;
// End "Copied" From Demux Proppage

STDMETHODIMP CEncoder::get_AudioEncoderInterface(/*[out, retval]*/ IUnknown **ppEncInt){
    if(!ppEncInt){
        return E_POINTER;
    }
    DSMediaType mediaAudio(MEDIATYPE_Audio);
    DSFilter p_filter = m_Filters[m_iEncoder];
    HRESULT hr = E_NOINTERFACE;
    // Starting at the ecoder filter find the pin/filter implimenting the endcoder api for audio
    // This should work because of two facts
    // 1. only one audio path or audio path coming into the encoder filter
    // 2. we only need to find one matching media type to identify the pin type 
    do{
        DSFilter::iterator pins;
        // check the current filters pins for a audio media type
        for(pins = p_filter.begin(); pins != p_filter.end(); ++pins){
            DSPin::iterator mTypes;
            for(mTypes = (*pins).begin(); mTypes != (*pins).end(); ++mTypes){
                if((*mTypes) == mediaAudio){
                    // see if the current pin impliments the encoder api
                    (*pins).QueryInterface(&m_qiAudEnc) ;
                    if(m_qiAudEnc){
                        hr = m_qiAudEnc.QueryInterface(ppEncInt);
                        if(SUCCEEDED(hr)){
                            return S_OK;
                        }
                        else{
                            return E_UNEXPECTED;
                        }
                    }
                    break;
                }
            }
            // If we did not get to the end of the media types then we found a audio type and the pin did not inpliment the interface
            // time to track backwards
            if(mTypes != (*pins).end() &&  (*pins).GetDirection() == PINDIR_INPUT){
                // Following the audio path get the next filter backwards from current filter
                DSPin back = (*pins).GetConnection();
                if(back){
                    p_filter = back.GetFilter();
                    // Check to see if the new filter impliments the encoder api
                    if(p_filter){
                        p_filter.QueryInterface(&m_qiAudEnc);
                        if(m_qiAudEnc){
                            hr = m_qiAudEnc.QueryInterface(ppEncInt);
                            if(SUCCEEDED(hr)){
                                return S_OK;
                            }
                            else{
                                return E_UNEXPECTED;
                            }
                        }
                    }
                }
                break;
            }
        }
        if(pins == p_filter.end()){
            p_filter.Release();
        }
    } while(p_filter && FAILED(hr));
    
    return hr;
}

STDMETHODIMP CEncoder::get_VideoEncoderInterface(/*[out, retval]*/ IUnknown **ppEncInt){
    if(!ppEncInt){
        return E_POINTER;
    }
    DSMediaType mediaVideo(MEDIATYPE_Video);
    DSFilter p_filter = m_Filters[m_iEncoder];
    HRESULT hr = E_NOINTERFACE;   
    if(!m_qiVidEnc){
        hr = p_filter.QueryInterface(&m_qiVidEnc);
        if(FAILED(hr)){
            m_qiVidEnc = static_cast<IUnknown*>(NULL);
        }
    }

    if(m_qiVidEnc){
        hr = m_qiVidEnc.QueryInterface(ppEncInt);                
        if(SUCCEEDED(hr)){
            return S_OK;
        }
        else{
            return hr;
        }
    }

    // Starting at the ecoder filter find the pin/filter implimenting the endcoder api for video
    // This should work because of two facts
    // 1. only one video path or audio path coming into the encoder filter
    // 2. we only need to find one matching media type to identify the pin type 
    do{
        DSFilter::iterator pins;
        // check the current filters pins for a video media type
        for(pins = p_filter.begin(); pins != p_filter.end(); ++pins){
            DSPin::iterator mTypes;
            for(mTypes = (*pins).begin(); mTypes != (*pins).end(); ++mTypes){
                if((*mTypes) == mediaVideo){
                    // see if the current pin impliments the encoder api
                    (*pins).QueryInterface(&m_qiVidEnc) ;
                    if(m_qiVidEnc){
                        hr = m_qiVidEnc.QueryInterface(ppEncInt);
                        if(SUCCEEDED(hr)){
                            return S_OK;
                        }
                        else{
                            return hr;
                        }
                    }
                    break;
                }
            }
            // If we did not get to the end of the media types then we found a video type and the pin did not inpliment the interface
            // time to track backwards
            if(mTypes != (*pins).end() &&  (*pins).GetDirection() == PINDIR_INPUT){
                // Following the video path get the next filter backwards from current filter
                DSPin back = (*pins).GetConnection();
                if(back){
                    p_filter = back.GetFilter();
                    // Check to see if the new filter impliments the encoder api
                    if(p_filter){
                        p_filter.QueryInterface(&m_qiVidEnc);
                        if(m_qiVidEnc){
                            hr = m_qiVidEnc.QueryInterface(ppEncInt);
                            if(SUCCEEDED(hr)){
                                return S_OK;
                            }
                            else{
                                return E_UNEXPECTED;
                            }
                        }
                    }
                }
                break;
            }
        }
        if(pins == p_filter.end()){
            p_filter.Release();
        }
    } while(p_filter && FAILED(hr));
    
    return hr;
}

HRESULT CEncoder::Unload(void) {
    IMSVidGraphSegmentImpl<CEncoder, MSVidSEG_XFORM, &GUID_NULL>::Unload();
    m_iEncoder = -1;
    m_qiVidEnc.Release();
    m_qiAudEnc.Release();
    return NOERROR;
}
// IMSVidGraphSegment
STDMETHODIMP CEncoder::Build() {
    return NOERROR;
}

STDMETHODIMP CEncoder::PreRun() {
    return NOERROR;
}

STDMETHODIMP CEncoder::put_Container(IMSVidGraphSegmentContainer *pCtl){
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    try {
        if (!pCtl) {
            return Unload();
        }

        if (m_pContainer) {
            if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
                return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidEncoder), CO_E_ALREADYINITIALIZED);
            } else {
                return NO_ERROR;
            }
        }
        
        // DON'T addref the container.  we're guaranteed nested lifetimes
        // and an addref creates circular refcounts so we never unload.
        m_pContainer.p = pCtl;
        m_pGraph = m_pContainer.GetGraph();
        
        // Add some filters when there is an encoder api

        DSFilter pEncoder(m_pGraph.AddMoniker(m_pDev));
        if (!pEncoder) {
            return E_UNEXPECTED;
        }
        
        m_Filters.push_back(pEncoder);
        m_iEncoder = 0;
        TRACELM(TRACE_DETAIL, "CMSVidEncoder::put_Container() Encoder added");
        
        DSFilter::iterator fPin;
        DSMediaType mpeg2ProgramType(MEDIATYPE_Stream, MEDIASUBTYPE_MPEG2_PROGRAM);
        DSMediaType streamType(MEDIATYPE_Stream);
        for(fPin = pEncoder.begin(); fPin != pEncoder.end(); ++fPin) {
            DSPin curPin(*fPin);
            DSPin::iterator pMedia;
            
            // Find the Mpeg2 Progam Steam Pin if there is one
            for(pMedia = curPin.begin(); pMedia != curPin.end(); ++pMedia){
                if ((*pMedia) == streamType && curPin.GetDirection() == PINDIR_OUTPUT){
                    break;
                }
            }
            
            if(pMedia == curPin.end()){
                continue;
            }
            else{
                if((*pMedia) == mpeg2ProgramType){
                    // Found the program stream pin get a demux and set it up
                    CComQIPtr<IMpeg2Demultiplexer> qiDeMux;
                    qiDeMux.CoCreateInstance(CLSID_MPEG2Demultiplexer);

                    if(!qiDeMux){
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    DSFilter DeMux(qiDeMux);
                    DSFilterList intermediates;
                    CString csName(_T("MPEG-2 Demultiplexer"));

                    HRESULT hr = m_pGraph.AddFilter(DeMux, csName);
                    if (FAILED(hr)) {
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    m_Filters.push_back(DeMux);
                    m_iDemux = m_Filters.size() - 1;

                    for(DSFilter::iterator dPin = DeMux.begin(); dPin != DeMux.end(); ++dPin){
                        DSPin demuxIn(*dPin);
                        if(demuxIn.GetDirection() == PINDIR_INPUT){
                            hr = demuxIn.Connect(curPin);
                            if (FAILED(hr)) {
                                ASSERT(FALSE);
                                return E_UNEXPECTED;
                            }
                        }
                    }

                    // Sprout the audio and video pins on the demxu
                    DSPin dspAudio, dspVideo;
                    DSMediaType mtVideo(MEDIATYPE_Video, MEDIASUBTYPE_MPEG2_VIDEO, FORMAT_MPEG2Video);
                    mtVideo.p->bFixedSizeSamples = TRUE;
                    mtVideo.p->cbFormat = sizeof(g_Mpeg2ProgramVideo);
                    mtVideo.p->pbFormat = g_Mpeg2ProgramVideo;

                    DSMediaType mtAudio(MEDIATYPE_Audio, MEDIASUBTYPE_MPEG1Payload, FORMAT_WaveFormatEx);
                    mtAudio.p->bFixedSizeSamples = TRUE;
                    mtAudio.p->cbFormat = sizeof(g_MPEG1AudioFormat);
                    mtAudio.p->pbFormat = g_MPEG1AudioFormat;

                    CComBSTR szAudio("Audio Pin");
                    CComBSTR szVideo("Video Pin");

                    hr = qiDeMux->CreateOutputPin(mtAudio, szAudio, &dspAudio);
                    if (FAILED(hr)) {
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    hr = qiDeMux->CreateOutputPin(mtVideo, szVideo, &dspVideo); 
                    if (FAILED(hr)) {
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    // Map the pids correctly
                    // TODO: use the encoder api to find the pids for audio and video
                    CComQIPtr<IMPEG2StreamIdMap>qiMapper(dspVideo);
                    hr = qiMapper->MapStreamId(g_VideoID, MPEG2_PROGRAM_ELEMENTARY_STREAM, 0, 0);
                    if (FAILED(hr)) {
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    qiMapper = dspAudio;
                    hr = qiMapper->MapStreamId(g_AudioID, MPEG2_PROGRAM_ELEMENTARY_STREAM, 0, 0);
                    if (FAILED(hr)) {
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    // Clean up
                    mtVideo.p->cbFormat = 0;
                    mtVideo.p->pbFormat = 0;
                    mtAudio.p->cbFormat = 0;
                    mtAudio.p->pbFormat = 0;
                    break;
                }
#if 0 // code to support custom demux (e.g. asf/wmv demux by a third party)
                else{
                    CRegKey c;
                    TCHAR szCLSID[MAX_PATH + 1];
                    szCLSID[0] = 0;
                    CString keyname(_T("SOFTWARE\\Debug\\MSVidCtl"));
                    DWORD rc = c.Open(HKEY_LOCAL_MACHINE, keyname, KEY_READ);
                    if (rc == ERROR_SUCCESS) {
                        DWORD len = sizeof(szCLSID);
                        rc = c.QueryValue(szCLSID, _T("CustomDemuxCLSID"), &len);
                        if (rc != ERROR_SUCCESS) {
                            szCLSID[0] = 0;
                        }
                    }
                    DSFilter DeMux;
                    CComBSTR asfCLSID(szCLSID);
                    GUID2 asfDemux(asfCLSID);
                    DeMux.CoCreateInstance(asfDemux);

                    if(!DeMux){
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    DSFilterList intermediates;
                    CString csName(_T("Custom Demultiplexer"));

                    HRESULT hr = m_pGraph.AddFilter(DeMux, csName);
                    if (FAILED(hr)) {
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    m_Filters.push_back(DeMux);
                    m_iDemux = m_Filters.size() - 1;

                    for(DSFilter::iterator dPin = DeMux.begin(); dPin != DeMux.end(); ++dPin){
                        DSPin demuxIn(*dPin);
                        if(demuxIn.GetDirection() == PINDIR_INPUT){
                            hr = demuxIn.Connect(curPin);
                            if (FAILED(hr)) {
                                ASSERT(FALSE);
                                return E_UNEXPECTED;
                            }
                        }
                    }
                }
#endif
            }                
            
            
        }
        // Don't fail if there is no program stream pin. could be elementry streams or non-mpeg content
        return NOERROR;
    } catch (ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
    return NOERROR;
}

// IMSVidDevice
STDMETHODIMP CEncoder::get_Name(BSTR * Name){
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    try {

        CComBSTR DefaultName("Encoder Segment");
        return GetName(((m_iEncoder > -1) ? (m_Filters[m_iEncoder]) : DSFilter()), m_pDev, DefaultName).CopyTo(Name);
        return NOERROR;
    } catch(...) {
        return E_POINTER;
    }
}



STDMETHODIMP CEncoder::InterfaceSupportsErrorInfo(REFIID riid){
    static const IID* arr[] = 
    {
        &IID_IMSVidEncoder
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++){
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}
#endif // TUNING_MODEL_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidencoder.h ===
//==========================================================================;
// MSVidEncoder.h : Declaration of the CMSVidEncoder
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __MSVidEncoder_H_
#define __MSVidEncoder_H_

#include <algorithm>
#include <tchar.h>
#include <objectwithsiteimplsec.h>
#include "segimpl.h"
#include "encoderimpl.h"
#include <strmif.h>
#include "seg.h"

typedef CComQIPtr<ITuner> PQMSVidEncoder;

/////////////////////////////////////////////////////////////////////////////
// CMSVidEncoder
class ATL_NO_VTABLE __declspec(uuid("BB530C63-D9DF-4b49-9439-63453962E598")) CEncoder : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEncoder, &__uuidof(CEncoder)>,
    public IObjectWithSiteImplSec<CEncoder>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CEncoder>,
	public IMSVidGraphSegmentImpl<CEncoder, MSVidSEG_XFORM, &GUID_NULL>,
    public IMSVidEncoderImpl<CEncoder, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidEncoder>
{
public:
    CEncoder() : m_iEncoder(-1), m_iDemux(-1) {
	}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_ENCODER_PROGID, 
						   IDS_REG_ENCODER_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CEncoder));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEncoder)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidEncoder)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMSVidFeature)
	COM_INTERFACE_ENTRY(IMSVidDevice)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CEncoder)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CEncoder)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    PQCreateDevEnum m_pSystemEnum;
    int m_iEncoder;
    int m_iDemux;

    HRESULT Unload(void);
    STDMETHOD(get_AudioEncoderInterface)(/*[out, retval]*/ IUnknown **ppEncInt);
    STDMETHOD(get_VideoEncoderInterface)(/*[out, retval]*/ IUnknown **ppEncInt);
    // IMSVidGraphSegment
    STDMETHOD(Build)();

    STDMETHOD(PreRun)();

	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl);
    // IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name);
protected:
    CComQIPtr<IVideoEncoder> m_qiVidEnc;
    CComQIPtr<IEncoderAPI> m_qiAudEnc;
};

#endif //__MSVidEncoder_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidfileplayback.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidFilePlayback.cpp : Implementation of CMSVidFilePlayback
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "atltmp.h"
#include "MSVidCtl.h"
#include "MSVidFilePlayback.h"
#include <nserror.h>
#include <wmsdkidl.h>

#define FILE_BEGINNING 0
#define LOCAL_OATRUE -1
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidFilePlaybackDevice, CMSVidFilePlayback)

/////////////////////////////////////////////////////////////////////////////
// CMSVidFilePlayback

STDMETHODIMP CMSVidFilePlayback::PostRun(){
    if(m_fGraphInit){
        InitGraph();
        m_fGraphInit = false;
    }
    return IMSVidPBGraphSegmentImpl<CMSVidFilePlayback, MSVidSEG_SOURCE, &GUID_NULL>::PostRun();
}

STDMETHODIMP CMSVidFilePlayback::put_Rate(double lRate){
    HRESULT hr = S_OK;
    try{
        /*** Checking args and init'ing interfaces ***/

        if (!m_pGraph) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidFilePlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // Attempt to set the rate using IMediaSeeking
        DSFilter Reader = m_Filters[m_iReader];
        PQMediaSeeking PQIMSeeking;
        if(Reader){
            for(DSFilter::iterator iPin = Reader.begin(); iPin != Reader.end(); ++iPin){
                PQIMSeeking = (*iPin);
                if(PQIMSeeking){
                    TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlayback::put_Rate found Pin"), ""); 
                    break;
                }
            }
        }
        if(!PQIMSeeking){
            TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlayback::put_Rate using graph"), ""); 
            PQIMSeeking = m_pGraph;
        }

        if(PQIMSeeking){
            TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlayback::put_Rate using Imediaseeking"), "");
            return PQIMSeeking->SetRate(lRate);
        }
        // If IMediaSeeking FAILS try IMediaPostion
        PQMediaPosition PQIMPos(m_pGraph);
        if(PQIMPos){
            // Change rate
            TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlayback::put_Rate using Imediaposition"), "");
            return PQIMPos->put_Rate((double)lRate);
        }

        // Could Not QI Either one set the error
        return Error(IDS_E_CANTQI , __uuidof(IMSVidFilePlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidFilePlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CMSVidFilePlayback::get_Rate(double *lRate){
    HRESULT hr = S_OK;
    try{
        /*** Checking args and init'ing interfaces ***/

        if (!m_pGraph) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidFilePlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // Attempt to set the rate using IMediaSeeking
        DSFilter Reader = m_Filters[m_iReader];
        PQMediaSeeking PQIMSeeking;
        if(Reader){
            for(DSFilter::iterator iPin = Reader.begin(); iPin != Reader.end(); ++iPin){
                PQIMSeeking = (*iPin);
                if(PQIMSeeking){
                    break;
                }
            }
        }
        if(!PQIMSeeking){
            PQIMSeeking = m_pGraph;
        }

        if(PQIMSeeking){
            return PQIMSeeking->GetRate(lRate);
        }
        // If IMediaSeeking FAILS try IMediaPostion
        PQMediaPosition PQIMPos(m_pGraph);
        if(PQIMPos){
            // Change rate
            return PQIMPos->get_Rate(lRate);
        }

        // Could Not QI Either one set the error
        return Error(IDS_E_CANTQI , __uuidof(IMSVidFilePlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidFilePlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CMSVidFilePlayback::PreStop(){
    TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlayback::PreStop()"), ""); 
    double curRate = 0;
    HRESULT hr = get_Rate(&curRate);
    if(SUCCEEDED(hr) && curRate != 1){
        hr = IMSVidFilePlaybackImpl<CMSVidFilePlayback, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidFilePlayback>::put_Rate(1);
        if(FAILED(hr)){
            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::PreStop() base put_Rate 1 failed"), ""); 
        }

        hr = put_Rate(1);
        if(FAILED(hr)){
            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::PreStop() put_Rate 1 failed"), ""); 
        }
    }
    else{
        TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::PreStop() get_Rate failed"), ""); 
    }

    return NOERROR;
}

STDMETHODIMP CMSVidFilePlayback::PostStop(){
    HRESULT hr = S_OK;
    TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlayback::PostStop()"), ""); 
    try {
#if 0
        // If the graph is not is stopped state
        // we make sure it is
        if (!m_pGraph.IsStopped()) {
            HRESULT hr = PQVidCtl(m_pContainer)->Stop();
        }
#endif 
        // If m_fEnableResetOnStop is true then we need to reset 
        // the postion back to the beggining
        // else do nothing
        // If it fails file cannot be reset to beginning
        if(m_fEnableResetOnStop){
            put_CurrentPosition(0);
        }
    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }
	return hr;
}

STDMETHODIMP CMSVidFilePlayback::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidFilePlayback
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CMSVidFilePlayback::put_Container(IMSVidGraphSegmentContainer *pCtl)
{
    try {
        if (!m_fInit) {
	        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
        if (!pCtl) {
            return Unload();
        }
        if (m_pContainer) {
            if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
                return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidFilePlayback), CO_E_ALREADYINITIALIZED);
            } else {
                return NO_ERROR;
            }
        }
        
        // DON'T addref the container.  we're guaranteed nested lifetimes
        // and an addref creates circular refcounts so we never unload.
        m_pContainer.p = pCtl;
        m_pGraph = m_pContainer.GetGraph();
        return NOERROR;
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CMSVidFilePlayback::Build() {
    if (!m_FileName) {
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidFilePlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }
    if(m_Filters.size() > 0){
        return NOERROR;
    }
    USES_CONVERSION;
    CString csName(_T("File Playback"));
    DSFilter pfr;
    HRESULT hr = pfr.CoCreateInstance(CLSID_WMAsfReader,0, CLSCTX_INPROC_SERVER);
    if(SUCCEEDED(hr)){
        CComQIPtr<IFileSourceFilter> pqFS(pfr);
        if(!!pqFS){
            // set the target ASF filename
            hr = pqFS->Load(m_FileName, NULL);
            if(FAILED(hr)){
                if(hr == (HRESULT)NS_E_LICENSE_REQUIRED){
                    CComQIPtr<IWMDRMReader> pq_DRMReader(pqFS);
                    if(pq_DRMReader){
                        hr = pq_DRMReader->AcquireLicense(1); // 1 == attempt silently
                        if(SUCCEEDED(hr)){
                            hr = pqFS->Load(m_FileName, NULL);
                        }
                        else{
                            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() Could not acquire license"), ""); 
                        }
                    }
                    else{
                       TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() Could not qi for IWMDRMReader "), ""); 
                    }
                }
            }
            if(SUCCEEDED(hr)){
                // add the ASF writer filter to the graph
                hr = m_pGraph->AddFilter(pfr, csName);
                if(SUCCEEDED(hr)){
                    TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() added WMV filter to graph hr = " << std::hex << hr), "");
                }
                else{
                    TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() could not add filter to graph hr = " << std::hex << hr), "");
                }
            }
            else{
                TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() Could not set file name, hr = " << std::hex << hr), "");
            }
        }
        else{
            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() Could not get IFileSourceFilter interface, hr = " << std::hex << hr), "");
        }
    }
    else{
        TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() CreateFilter AsfReader failed, hr = " << std::hex << hr), "");
    }

    if (FAILED(hr)) {
        hr = m_pGraph->AddSourceFilter(m_FileName, csName, &pfr);
        if(FAILED(hr)){
            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() Add Source Filter Failed, hr = " << std::hex << hr), "");
            return Error(IDS_CANT_PLAY_FILE, __uuidof(IMSVidFilePlayback), hr);
        }
    }
    m_Filters.clear();
    m_Filters.push_back(pfr);
    m_iReader = m_Filters.size() - 1;
    return NOERROR;
}

STDMETHODIMP CMSVidFilePlayback::OnEventNotify(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2) {
    return IMSVidPBGraphSegmentImpl<CMSVidFilePlayback, MSVidSEG_SOURCE, &GUID_NULL>::OnEventNotify(lEvent, lParam1, lParam2);
}

#endif //TUNING_MODEL_ONLY

// end of file - MSVidFilePlayback.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidfileplayback.h ===
//==========================================================================;
// MSVidFilePlayback.h : Declaration of the CMSVidFilePlayback class
// copyright (c) Microsoft Corp. 1998-1999.
//==========================================================================;

#ifndef __MSVidFILEPLAYBACK_H_
#define __MSVidFILEPLAYBACK_H_

#pragma once

#include <algorithm>
#include <objectwithsiteimplsec.h>
#include "pbsegimpl.h"
#include "fileplaybackimpl.h"
#include "fileplaybackcp.h"
#include "seg.h"
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMSVidFilePlayback
class ATL_NO_VTABLE __declspec(uuid("37B0353C-A4C8-11d2-B634-00C04F79498E")) CMSVidFilePlayback : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidFilePlayback, &__uuidof(CMSVidFilePlayback)>,
    public IObjectWithSiteImplSec<CMSVidFilePlayback>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CMSVidFilePlayback>,
    public CProxy_FilePlaybackEvent<CMSVidFilePlayback>,
	public IMSVidPBGraphSegmentImpl<CMSVidFilePlayback, MSVidSEG_SOURCE, &GUID_NULL>,
    public IMSVidFilePlaybackImpl<CMSVidFilePlayback, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidFilePlayback>,
    public IProvideClassInfo2Impl<&CLSID_MSVidFilePlaybackDevice, &IID_IMSVidFilePlaybackEvent, &LIBID_MSVidCtlLib>
{
public:
    CMSVidFilePlayback()
    {
        m_fEnableResetOnStop = true;
    }

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_FILEPLAYBACK_PROGID, 
						   IDS_REG_FILEPLAYBACK_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidFilePlayback));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidFilePlayback)
	COM_INTERFACE_ENTRY(IMSVidFilePlayback)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IMSVidPlayback)
	COM_INTERFACE_ENTRY(IMSVidInputDevice)
	COM_INTERFACE_ENTRY(IMSVidDevice)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CMSVidFilePlayback)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSVidFilePlayback)
	CONNECTION_POINT_ENTRY(IID_IMSVidFilePlaybackEvent)    
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    STDMETHOD(put_Rate)(double lRate);
    STDMETHOD(get_Rate)(double *lRate);
    STDMETHOD(PostStop)();
    STDMETHOD(PostRun)();
    STDMETHOD(PreStop)();
    // DON'T addref the container.  we're guaranteed nested lifetimes
    // and an addref creates circular refcounts so we never unload.
    CComBSTR __declspec(property(get=GetName)) m_Name;
    CComBSTR GetName(void) {
        CString csName;
        if(m_iReader != -1){
            csName = (m_Filters[m_iReader]).GetName();
        }        
        if (csName.IsEmpty()) {
            csName = _T("File Playback");
        }
        return CComBSTR(csName);
    }
    HRESULT Unload(void) {
        HRESULT hr = IMSVidGraphSegmentImpl<CMSVidFilePlayback, MSVidSEG_SOURCE, &GUID_NULL>::Unload();
        m_iReader = -1;
        return hr;
	}

    virtual ~CMSVidFilePlayback() {}

// IMSVidGraphSegment
	STDMETHOD(put_Init)(IUnknown *pInit)
	{
        HRESULT hr = IMSVidGraphSegmentImpl<CMSVidFilePlayback, MSVidSEG_SOURCE, &GUID_NULL>::put_Init(pInit);
        if (FAILED(hr)) {
            return hr;
        }
        if (pInit) {
            m_fInit = false;
            return E_NOTIMPL;
        }
        return NOERROR;
	}

    STDMETHOD(Build)();
	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pVal);
    STDMETHOD(OnEventNotify)(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2);

// IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
		if (Name == NULL)
			return E_POINTER;
        try {
		    *Name = m_Name.Copy();	
        } catch(...) {
            return E_POINTER;
        }
		return NOERROR;
	}
    // IMSVidInputDevice
	STDMETHOD(IsViewable)(VARIANT* pv, VARIANT_BOOL *pfViewable)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
        if (!pv) {
			return E_POINTER;
        }
		return E_NOTIMPL;
	}
	STDMETHOD(View)(VARIANT* pv) {
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
		if (!pv) {
			return E_POINTER;
		}
        if (pv->vt != VT_BSTR) {
			return E_INVALIDARG;
        }
        // if its a string then its either a dvd url or a filename
        // we don't do dvd urls
        if (!_wcsnicmp(pv->bstrVal, L"DVD:", 4)) {
            return E_FAIL;
        }
        if (m_pGraph && !m_pGraph.IsStopped()) {
	        return Error(IDS_INVALID_STATE, __uuidof(IMSVidFilePlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
		return put_FileName(pv->bstrVal);
	}
// IMSVidPlayback
// IMSVidFilePlayback
};

#endif //__MSVidFILEPLAYBACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msviddvdadm.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSVidWebDVDAdm.cpp                                              */
/* Description: DImplementation of CMSVidWebDVDAdm                       */
/* Author: Fang Wang                                                     */
/*************************************************************************/
#include "stdafx.h"
#include "MSVidCtl.h"
#include "MSVidDVDAdm.h"
#include "iso3166.h"
#include <stdio.h>
#include <errors.h>
#include <wincrypt.h>

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidWebDVDAdm, CMSVidWebDVDAdm)

const TCHAR g_szRegistryKey[] = TEXT("Software\\Microsoft\\Multimedia\\DVD");
const TCHAR g_szPassword[] = TEXT("DVDAdmin.password");
const TCHAR g_szSalt[] = TEXT("DVDAdmin.ps"); // password salt
const TCHAR g_szUserSalt[] = TEXT("DVDAdmin.us"); // username salt
const TCHAR g_szUsername[] = TEXT("DVDAdmin.username");
const TCHAR g_szPlayerLevel[] = TEXT("DVDAdmin.playerLevel");
const TCHAR g_szPlayerCountry[] = TEXT("DVDAdmin.playerCountry");
const TCHAR g_szDisableScrnSvr[] = TEXT("DVDAdmin.disableScreenSaver");
const TCHAR g_szBookmarkOnStop[] = TEXT("DVDAdmin.bookmarkOnStop");
const TCHAR g_szDefaultAudio[] = TEXT("DVDAdmin.defaultAudioLCID");
const TCHAR g_szDefaultSP[] = TEXT("DVDAdmin.defaultSPLCID");
const TCHAR g_szDefaultMenu[] = TEXT("DVDAdmin.defaultMenuLCID");

/*************************************************************/
/* Helper functions                                          */
/*************************************************************/

/*************************************************************/
/* Name: GetRegistryDword
/* Description: 
/*************************************************************/
BOOL GetRegistryDword(const TCHAR *pKey, DWORD* dwRet, DWORD dwDefault)
{
    HKEY hKey;
    LONG lRet;
    *dwRet = dwDefault;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;
        dwLen = sizeof(DWORD);

        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)dwRet, &dwLen)){ 
            *dwRet = dwDefault;
            RegCloseKey(hKey);
            return FALSE;
        }

        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryDword
/* Description: 
/*************************************************************/
BOOL SetRegistryDword(const TCHAR *pKey, DWORD dwRet)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_LOCAL_MACHINE, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_DWORD, (LPBYTE)&dwRet, sizeof(dwRet));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryString
/* Description: 
/*************************************************************/
BOOL GetRegistryString(const TCHAR *pKey, TCHAR* szRet, DWORD* dwLen, TCHAR* szDefault)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwTempLen = 0;
    lstrcpyn(szRet, szDefault, *dwLen);

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {
        DWORD dwType;
        dwTempLen = (*dwLen) * sizeof(TCHAR);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, &dwTempLen)) {
            lstrcpyn(szRet, szDefault, *dwLen);
            *dwLen = 0;
        }

        *dwLen = dwTempLen/sizeof(TCHAR);
        RegCloseKey(hKey);
    }

    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryString
/* Description: 
/*************************************************************/
BOOL SetRegistryString(const TCHAR *pKey, TCHAR *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_LOCAL_MACHINE, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_SZ, (LPBYTE)szString, dwLen*sizeof(TCHAR));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryByte
/* Description: 
/*************************************************************/
BOOL GetRegistryBytes(const TCHAR *pKey, BYTE* szRet, DWORD* dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, dwLen)) {
            *dwLen = 0;
        }
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryBytes
/* Description: 
/*************************************************************/
BOOL SetRegistryBytes(const TCHAR *pKey, BYTE *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_LOCAL_MACHINE, g_szRegistryKey, &hKey);

    BOOL bRet = TRUE;
    if (lRet == ERROR_SUCCESS) {

        if (szString == NULL) {
            lRet = RegDeleteValue(hKey, pKey);
            bRet = (lRet == ERROR_SUCCESS) || (lRet == ERROR_FILE_NOT_FOUND);
        }
        else  {
            lRet = RegSetValueEx(hKey, pKey, NULL, REG_BINARY, (LPBYTE)szString, dwLen);
            bRet = (lRet == ERROR_SUCCESS);
        }

        RegCloseKey(hKey);
    }
    return (bRet);
}

// Start not so lame functions

/*************************************************************/
/* Name: GetRegistryDwordCU
/* Description: 
/*************************************************************/
BOOL GetRegistryDwordCU(const TCHAR *pKey, DWORD* dwRet, DWORD dwDefault)
{
    HKEY hKey;
    LONG lRet;
    *dwRet = dwDefault;

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;
        dwLen = sizeof(DWORD);

        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)dwRet, &dwLen)){ 
            *dwRet = dwDefault;
            RegCloseKey(hKey);
            return FALSE;
        }

        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryDwordCU
/* Description: 
/*************************************************************/
BOOL SetRegistryDwordCU(const TCHAR *pKey, DWORD dwRet)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_CURRENT_USER, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_DWORD, (LPBYTE)&dwRet, sizeof(dwRet));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryStringCU
/* Description: 
/*************************************************************/
BOOL GetRegistryStringCU(const TCHAR *pKey, TCHAR* szRet, DWORD* dwLen, TCHAR* szDefault)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwTempLen = 0;
    lstrcpyn(szRet, szDefault, *dwLen);

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        dwTempLen = (*dwLen) * sizeof(TCHAR);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, &dwTempLen)) {
            lstrcpyn(szRet, szDefault, sizeof(szRet) / sizeof(szRet[0]));
            *dwLen = 0;
        }
        *dwLen = dwTempLen/sizeof(TCHAR);
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryStringCU
/* Description: 
/*************************************************************/
BOOL SetRegistryStringCU(const TCHAR *pKey, TCHAR *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_CURRENT_USER, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_SZ, (LPBYTE)szString, dwLen*sizeof(TCHAR));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryByteCU
/* Description: 
/*************************************************************/
BOOL GetRegistryBytesCU(const TCHAR *pKey, BYTE* szRet, DWORD* dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, dwLen)) {
            *dwLen = 0;
        }
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryBytesCU
/* Description: 
/*************************************************************/
BOOL SetRegistryBytesCU(const TCHAR *pKey, BYTE *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_CURRENT_USER, g_szRegistryKey, &hKey);

    BOOL bRet = TRUE;
    if (lRet == ERROR_SUCCESS) {

        if (szString == NULL) {
            lRet = RegDeleteValue(hKey, pKey);
            bRet = (lRet == ERROR_SUCCESS) || (lRet == ERROR_FILE_NOT_FOUND);
        }
        else  {
            lRet = RegSetValueEx(hKey, pKey, NULL, REG_BINARY, (LPBYTE)szString, dwLen);
            bRet = (lRet == ERROR_SUCCESS);
        }

        RegCloseKey(hKey);
    }
    return (bRet);
}

// end not so lame functions


/*************************************************************/
/* Function: CMSVidWebDVDAdm                                 */
/*************************************************************/
CMSVidWebDVDAdm::CMSVidWebDVDAdm(){

    DWORD temp;
    GetRegistryDword(g_szPlayerLevel, &temp, (DWORD)8);		
    m_lParentctrlLevel = temp;

    GetRegistryDword(g_szPlayerCountry, &temp, (DWORD)0);		
    m_lParentctrlCountry = temp;

    GetRegistryDword(g_szDisableScrnSvr, &temp, (DWORD)VARIANT_TRUE);		
    m_fDisableScreenSaver = (VARIANT_BOOL)temp;
    SaveScreenSaver();
    if (m_fDisableScreenSaver != VARIANT_FALSE)
        DisableScreenSaver();

    GetRegistryDword(g_szBookmarkOnStop, &temp, (DWORD)VARIANT_FALSE);		
    m_fBookmarkOnStop = (VARIANT_BOOL)temp;
}/* end of function CMSVidWebDVDAdm */

/*************************************************************/
/* Function: ~CMSVidWebDVDAdm                                */
/*************************************************************/
CMSVidWebDVDAdm::~CMSVidWebDVDAdm(){

    RestoreScreenSaver();
}/* end of function ~CMSVidWebDVDAdm */

/*************************************************************/
/* Name: EncryptPassword                                     */
/* Description: Hash the password                            */
/* Params:                                                   */
/*  lpPassword: password to hash                             */
/*  lpAssaultedHash: hashed password,                        */
/*      allocated by this fucntion, released by caller       */
/*  p_dwAssault: salt, save with hash; or salt passed in     */
/*  genAssault: TRUE = generate salt; FALSE = salt passed in */
/*************************************************************/
HRESULT CMSVidWebDVDAdm::EncryptPassword(LPTSTR lpPassword, BYTE **lpAssaultedHash, DWORD *p_dwCryptLen, DWORD *p_dwAssault, BOOL genAssault){
    if(!lpPassword || !lpAssaultedHash || !p_dwAssault || !p_dwCryptLen){
        return E_POINTER;
    }
    if( lstrlen(lpPassword) > MAX_PASSWD){
        return E_INVALIDARG;
    }
    
    HCRYPTPROV hProv = NULL;   // Handle to Crypto Context
    HCRYPTHASH hHash = NULL;   // Handle to Hash Function    
    DWORD dwAssault = 0;       // As(Sa)u(lt) for hash
    DWORD dwAssaultedHash = 0; // Length of Assaulted hash
    
    // Init Crypto Context
    if(!CryptAcquireContext(&hProv, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)){
        return E_UNEXPECTED;
    }
    
    // Store the Salt in dwAssault, either generate it or copy the user passed value
    if(genAssault){        
        if(!CryptGenRandom(hProv, sizeof(DWORD), reinterpret_cast<BYTE *>(&dwAssault))){
            if(hProv) CryptReleaseContext(hProv, 0);                                                                       
            return E_UNEXPECTED;   
        }
        *p_dwAssault = dwAssault;
    }
    else{
        dwAssault = *p_dwAssault;
    }
    
    // Create the handle to the Hash function
    if(!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Hash the password
    if(!CryptHashData(hHash, reinterpret_cast<BYTE *>(lpPassword), lstrlen(lpPassword)*sizeof(lpPassword[0]), 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Add the salt
    if(!CryptHashData(hHash, reinterpret_cast<BYTE *>(&dwAssault), sizeof(DWORD), 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Get the size of the hashed data
    if(!CryptGetHashParam(hHash, HP_HASHVAL, 0, &dwAssaultedHash, 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Allocate a string large enough to hold the hash data and a null
    *lpAssaultedHash = new BYTE[dwAssaultedHash];
    if(!lpAssaultedHash){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Zero the string
    ZeroMemory(*lpAssaultedHash, dwAssaultedHash);
    
    // Copy length of Encrypted bytes to return value
    *p_dwCryptLen = dwAssaultedHash;
    
    // Get the hash data and store it in a string
    if(!CryptGetHashParam(hHash, HP_HASHVAL, *lpAssaultedHash, &dwAssaultedHash, 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        if(lpAssaultedHash){
            delete[] *lpAssaultedHash;
            *lpAssaultedHash = NULL;
        }
        return E_UNEXPECTED;
    }
    
    // Clean up
    if(hProv) CryptReleaseContext(hProv, 0);                                  
    if(hHash) CryptDestroyHash(hHash);                                      

    return S_OK;

}/* end of function EncryptPassword */


/*************************************************************/
/* Function: ConfirmPassword                                 */
/* Description: comfired a password with the one saved       */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::ConfirmPassword(BSTR /* strUserName */,
											  BSTR strPassword, VARIANT_BOOL *fRight){
	
    HRESULT hr = S_OK;
	
    try {
        USES_CONVERSION;
		*fRight = VARIANT_FALSE;
		if(!strPassword || !fRight){
			return E_POINTER;
		}

        UINT bStrLen = lstrlen(strPassword);
        if(bStrLen >= MAX_PASSWD){
            return E_INVALIDARG;
        }
		
        LPTSTR szPassword = OLE2T(strPassword);
        BYTE szSavedPasswd[MAX_PASSWD];
        DWORD dwLen = MAX_PASSWD+PRE_PASSWD;
        BOOL bFound = GetRegistryBytes(g_szPassword, szSavedPasswd, &dwLen);
		
        // if no password has been set yet
        if (!bFound || dwLen == 0) {
			
            // so in this case accept only an empty string 
            if(lstrlen(szPassword) <= 0){
				
                *fRight = VARIANT_TRUE;
            }
            else {
				
                *fRight = VARIANT_FALSE;
            }
            throw (hr);
        }
        
        DWORD dwAssault = 0;
        bFound = GetRegistryDword(g_szSalt, &dwAssault, 0);
        if(!bFound ){
            // Old style password since there is no salt
            // ignore current password until it is reset
            *fRight = VARIANT_TRUE;
            throw(hr);
        }

        // Encrypt the password with the salt from the registry
	    BYTE *pszEncrypted = NULL;
        DWORD dwCryptLen = 0;
        hr = EncryptPassword(szPassword, &pszEncrypted, &dwCryptLen, &dwAssault, FALSE);
        if(FAILED(hr)){
            throw (hr);
        }

        // Compare the Encrypted input password with the saved password
        if(memcmp(pszEncrypted, szSavedPasswd, (dwAssault <= dwLen?dwAssault:dwLen) ) == 0)
            *fRight = VARIANT_TRUE;
        else
            *fRight = VARIANT_FALSE;
        delete[] pszEncrypted;
    }
    catch(HRESULT hrTmp){
		
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }
	
    if(FAILED(hr)){
        Sleep(1000);
    }

    return (HandleError(hr));        
}/* end of function ConfirmPassword */

/*************************************************************/
/* Function: ChangePassword                                  */
/* Description: password change requested                    */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::ChangePassword(BSTR strUserName, 
                                       BSTR strOldPassword, BSTR strNewPassword){

    HRESULT hr = S_OK;

    try {

        USES_CONVERSION;
		if(!strNewPassword){
			throw E_POINTER;
		}
        if(lstrlen(strNewPassword) >= MAX_PASSWD){
            //Error(IDS_PASSWORD_LENGTH);
            throw E_INVALIDARG;
        }

        LPTSTR szNewPassword = OLE2T(strNewPassword);

        // Confirm old password first
        VARIANT_BOOL temp;
        ConfirmPassword(strUserName, strOldPassword, &temp);
        if (temp == VARIANT_FALSE){

            throw E_ACCESSDENIED;
        }

        DWORD dwAssault = 0;
        DWORD dwCryptLen = 0;
        BYTE *pszEncrypted = NULL;
        
	    hr = EncryptPassword(szNewPassword, &pszEncrypted, &dwCryptLen, &dwAssault, TRUE);
        if(FAILED(hr)){
            throw E_FAIL;
        }

        BOOL bSuccess = SetRegistryBytes(g_szPassword, pszEncrypted, dwCryptLen);
        if (!bSuccess){
            hr = E_FAIL;
        }

        delete[] pszEncrypted;

        // If storing the password hash failed, don't store the salt
        if(SUCCEEDED(hr)){
            bSuccess = SetRegistryDword(g_szSalt, dwAssault);
            if (!bSuccess){
                hr = E_FAIL;
            }
        }

    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function ChangePassword */

/*************************************************************/
/* Function: SaveParentalLevel                               */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::SaveParentalLevel(long lParentalLevel, 
                         BSTR strUserName, BSTR strPassword){
    HRESULT hr = S_OK;

    try {

        if (lParentalLevel != PARENTAL_LEVEL_DISABLED && 
           (lParentalLevel < 1 || lParentalLevel > 8)) {

            throw (E_INVALIDARG);
        } 

        if (m_lParentctrlLevel != lParentalLevel) {

            // Confirm password first
            VARIANT_BOOL temp;
            ConfirmPassword(strUserName, strPassword, &temp);
            if (temp == VARIANT_FALSE)
                throw (E_ACCESSDENIED);

        }
    
        BOOL bSuccess = SetRegistryDword(g_szPlayerLevel, (DWORD) lParentalLevel);
        if (!bSuccess){
            throw E_FAIL;
        }

        m_lParentctrlLevel = lParentalLevel;

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}/* end of function SaveParentalLevel */

/*************************************************************/
/* Name: SaveParentalCountry                                 */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::SaveParentalCountry(long lCountry,                                               
                        BSTR strUserName,BSTR strPassword){

    HRESULT hr = S_OK;

    try {

        if(lCountry < 0 && lCountry > 0xffff){

            throw(E_INVALIDARG);
        }/* end of if statement */

        BYTE bCountryCode[2];

        bCountryCode[0] = BYTE(lCountry>>8);
        bCountryCode[1] = BYTE(lCountry);

        // convert the input country code to upper case by applying ToUpper to each letter
        WORD wCountry = ISO3166::PackCode( (char *)bCountryCode );
        BOOL bFound = FALSE;

        for( unsigned i=0; i<ISO3166::GetNumCountries(); i++ )
        {
            if( ISO3166::PackCode(ISO3166::GetCountry(i).Code) == wCountry )
            {
                bFound = TRUE;
            }
        }

        // Not a valid country code
        if (!bFound) {

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (m_lParentctrlCountry != lCountry) {

            // Confirm password first
            VARIANT_BOOL temp;
            ConfirmPassword(strUserName, strPassword, &temp);
            if (temp == VARIANT_FALSE)
                throw(E_ACCESSDENIED);
        
        }
    
        BOOL bSuccess = SetRegistryDword(g_szPlayerCountry, (DWORD) lCountry);
        if (!bSuccess){
            throw E_FAIL;
        }    

        m_lParentctrlCountry = lCountry;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return (HandleError(hr));        
}/* end of function SaveParentalCountry */

/*************************************************************/
/* Function: put_DisableScreenSaver                          */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::put_DisableScreenSaver(VARIANT_BOOL fDisable){

    HRESULT hr = S_OK;

    try {

        if (fDisable == VARIANT_FALSE)
            RestoreScreenSaver();
        else 
            DisableScreenSaver();

        SetRegistryDword(g_szDisableScrnSvr, (DWORD) fDisable);
        m_fDisableScreenSaver = fDisable;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function put_DisableScreenSaver */

/*************************************************************/
/* Function: get_DisableScreenSaver                          */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::get_DisableScreenSaver(VARIANT_BOOL *fDisable){

    HRESULT hr = S_OK;

    try {
        if(NULL == fDisable){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */
   
        *fDisable = m_fDisableScreenSaver;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}/* end of function get_DisableScreenSaver */

/*************************************************************/
/* Function: SaveScreenSaver                                 */
/*************************************************************/
HRESULT CMSVidWebDVDAdm::SaveScreenSaver(){
    /*
    SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, &m_bScrnSvrOld, 0);
    SystemParametersInfo(SPI_GETLOWPOWERACTIVE, 0, &m_bPowerlowOld, 0);
    SystemParametersInfo(SPI_GETPOWEROFFACTIVE, 0, &m_bPowerOffOld, 0);
    */
    return S_OK;
}
/*************************************************************/
/* Function: DisableScreenSaver                              */
/*************************************************************/
HRESULT CMSVidWebDVDAdm::DisableScreenSaver(){
    /*
    SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, FALSE, NULL, 0);
    SystemParametersInfo(SPI_SETLOWPOWERACTIVE, FALSE, NULL, 0);
    SystemParametersInfo(SPI_SETPOWEROFFACTIVE, FALSE, NULL, 0);
    */
    return S_OK;
}/* end of function DisableScreenSaver */

/*************************************************************/
/* Function: RestoreScreenSaver                              */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::RestoreScreenSaver(){

    HRESULT hr = S_OK;

    try {
        /*
        SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, m_bScrnSvrOld, NULL, 0);
        SystemParametersInfo(SPI_SETLOWPOWERACTIVE, m_bPowerlowOld, NULL, 0);
        SystemParametersInfo(SPI_SETPOWEROFFACTIVE, m_bPowerOffOld, NULL, 0);
        */
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}/* end of function RestoreScreenSaver */

/*************************************************************/
/* Function: GetParentalLevel                                */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::GetParentalLevel(long *lLevel){

    HRESULT hr = S_OK;

    try {
        if(NULL == lLevel){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        *lLevel = m_lParentctrlLevel;

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function GetParentalLevel */

/*************************************************************/
/* Function: GetParentalCountry                              */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::GetParentalCountry(long *lCountry){

    HRESULT hr = S_OK;

    try {
        if(NULL == lCountry){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        *lCountry = m_lParentctrlCountry;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function GetParentalCountry */

/*************************************************************/
/* Name: get_DefaultAudioLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::get_DefaultAudioLCID(long *pVal){

    HRESULT hr = S_OK;

    try {

        if(NULL == pVal){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */
    
        GetRegistryDwordCU(g_szDefaultAudio, (DWORD*) pVal, (DWORD)-1);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
} /* end of function get_DefaultAudioLCID */

/*************************************************************/
/* Name: put_DefaultAudioLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::put_DefaultAudioLCID(long newVal)
{
    HRESULT hr = S_OK;

    try {

        if (!::IsValidLocale(newVal, LCID_SUPPORTED) && newVal != -1) {

            throw (E_INVALIDARG);
        } /* end of if statement */
    
        SetRegistryDwordCU(g_szDefaultAudio, (DWORD) newVal);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
} /* end of put_DefaultAudioLCID */

/*************************************************************/
/* Name: get_DefaultSubpictureLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::get_DefaultSubpictureLCID(long *pVal)
{
    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        GetRegistryDwordCU(g_szDefaultSP, (DWORD*) pVal, (DWORD)-1);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);	
} /* end of get_DefaultSubpictureLCID */

/*************************************************************/
/* Name: put_DefaultSubpictureLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::put_DefaultSubpictureLCID(long newVal)
{
    HRESULT hr = S_OK;

    try {

        if (!::IsValidLocale(newVal, LCID_SUPPORTED) && newVal != -1) {

            throw (E_INVALIDARG);
        } /* end of if statement */
    
        SetRegistryDwordCU(g_szDefaultSP, (DWORD) newVal);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
} /* end of put_DefaultSubpictureLCID */

/*************************************************************/
/* Name: get_DefaultMenuLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::get_DefaultMenuLCID(long *pVal)
{
    HRESULT hr = S_OK;

    try {

       if(NULL == pVal){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        GetRegistryDwordCU(g_szDefaultMenu, (DWORD*) pVal, (DWORD)-1);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
} /* end of get_DefaultMenuLCID */

/*************************************************************/
/* Name: put_DefaultMenuLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::put_DefaultMenuLCID(long newVal)
{
    HRESULT hr = S_OK;

    try {

        if (!::IsValidLocale(newVal, LCID_SUPPORTED) && newVal != -1) {

            throw (E_INVALIDARG);
        } /* end of if statement */
    
        SetRegistryDwordCU(g_szDefaultMenu, (DWORD) newVal);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr); 
} /* end of put_DefaultMenuLCID */

/*************************************************************/
/* Name: put_BookmarkOnStop
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::put_BookmarkOnStop(VARIANT_BOOL fEnable){

    HRESULT hr = S_OK;

    try {
        m_fBookmarkOnStop = fEnable;
        SetRegistryDword(g_szBookmarkOnStop, (DWORD) fEnable);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
}

/*************************************************************/
/* Name: get_BookmarkOnStop
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::get_BookmarkOnStop(VARIANT_BOOL *fEnable){
    
    HRESULT hr = S_OK;

    try {

       if(NULL == fEnable){

           hr = E_POINTER;
           throw(hr);
       }/* end of if statement */

       *fEnable = m_fBookmarkOnStop;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
}

/*************************************************************************/
/* Function: InterfaceSupportsErrorInfo                                  */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::InterfaceSupportsErrorInfo(REFIID riid){	
	static const IID* arr[] = {
        &IID_IMSVidWebDVDAdm,		
	};

	for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++){
		if (InlineIsEqualGUID(*arr[i], riid))
			return S_OK;
	}/* end of for loop */

	return S_FALSE;
}/* end of function InterfaceSupportsErrorInfo */

/*************************************************************************/
/* Function: HandleError                                                 */
/* Description: Gets Error Descriptio, so we can suppor IError Info.     */
/*************************************************************************/
HRESULT CMSVidWebDVDAdm::HandleError(HRESULT hr){

    try {

        if(FAILED(hr)){
#if 0        
            TCHAR strError[MAX_ERROR_TEXT_LEN] = TEXT("");

            if(AMGetErrorText(hr , strError , MAX_ERROR_TEXT_LEN)){
                USES_CONVERSION;
                Error(T2W(strError));
            } 
            else {
                    ATLTRACE(TEXT("Unhandled Error Code \n")); // please add it
                    ATLASSERT(FALSE);
            }/* end of if statement */
#endif
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        // keep the hr same    
    }/* end of catch statement */
    
	return (hr);
}/* end of function HandleError */

/*************************************************************************/
/* End of file: MSVidWebDVDAdm.cpp                                       */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msviddvdbookmark.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: Bookmark.h                                                      */
/* Description: Implementation of Bookmark API                           */
/* Author: Steve Rowe                                                    */
/* Modified: David Janecek                                               */
/*************************************************************************/
#include "stdafx.h"
#include "msvidctl.h"
#include "msvidwebdvd.h"
#include "msviddvdadm.h"
#include "msviddvdBookmark.h"
#include "perfcntr.h"
/*************************************************************************/
/* Global consts.                                                        */
/*************************************************************************/
static const TCHAR g_szBookmark[] = TEXT("DVD.bookmark");

/*************************************************************************/
/* Outgoing interaface implementation.                                   */
/*************************************************************************/

/*************************************************************************/
/* Function: SaveBookmark                                                */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SaveBookmark(){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        CComPtr<IDvdState> pBookmark;

        hr = pDvdInfo2->GetState(&pBookmark);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = CBookmark::SaveToRegistry(pBookmark);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SaveBookmark */

/*************************************************************************/
/* Function: RestoreBookmark                                             */
/* Description: Restores the state by loading the bookmark stream        */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::RestoreBookmark(){
    VIDPERF_FUNC;
    HRESULT hr = S_OK;
    CComQIPtr<IDvdCmd>IDCmd;
    try {
       
        CComPtr<IDvdState> pBookmark;

        HRESULT hrTemp = CBookmark::LoadFromRegistry(&pBookmark);

        DeleteBookmark();

        if(SUCCEEDED(hrTemp)){

            INITIALIZE_GRAPH_IF_NEEDS_TO_BE
                
            if(!m_pDVDControl2){
                
                throw(E_UNEXPECTED);
            }/* end of if statement */
            hr = m_pDVDControl2->SetState(pBookmark, DVD_CMD_FLAG_Flush|DVD_CMD_FLAG_Block, 0);
            if(IDCmd){
                IDCmd->WaitForEnd();
            }

        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        DeleteBookmark();
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        DeleteBookmark();
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function RestoreBookmark */

/*************************************************************************/
/* Function: DeleteBookmark                                               */
/* Description: Blasts the bookmark file away.                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::DeleteBookmark(){

	HRESULT hr = S_OK;

    try {

        hr = CBookmark::DeleteFromRegistry();

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function DeleteBookmark */


/*************************************************************/
/* Name: SaveToRegistry
/* Description: Save the bookmark to registry
/*************************************************************/
HRESULT CBookmark::SaveToRegistry(IDvdState *pbookmark)
{
	IPersistMemory* pPersistMemory;
    HRESULT hr = pbookmark->QueryInterface(IID_IPersistMemory, (void **) &pPersistMemory );

    if (SUCCEEDED(hr)) {

		ULONG ulMax;
		hr = pPersistMemory->GetSizeMax( &ulMax );
		if( SUCCEEDED( hr )) {

			BYTE *buffer = new BYTE[ulMax];
			hr = pPersistMemory->Save( buffer, TRUE, ulMax );
            
            DWORD dwLen = ulMax;
            if (SUCCEEDED(hr)) {
                BOOL bSuccess = SetRegistryBytesCU(g_szBookmark, buffer, dwLen);
                if (!bSuccess)
                    hr = E_FAIL;
            }

            delete[] buffer; 
        }
		pPersistMemory->Release();
    } 
	return hr;
}

/*************************************************************/
/* Name: LoadFromRegistry
/* Description: load the bookmark from registry
/*************************************************************/
HRESULT CBookmark::LoadFromRegistry(IDvdState **ppBookmark)
{
	HRESULT hr = CoCreateInstance( CLSID_DVDState, NULL, CLSCTX_INPROC_SERVER, IID_IDvdState, (LPVOID*) ppBookmark );

	if( SUCCEEDED( hr )) {

		IPersistMemory* pPersistMemory;
		hr = (*ppBookmark)->QueryInterface(IID_IPersistMemory, (void **) &pPersistMemory );

        if( SUCCEEDED( hr )) {

            ULONG ulMax;
            hr = pPersistMemory->GetSizeMax( &ulMax );
            
            if (SUCCEEDED(hr)) {
                
                BYTE *buffer = new BYTE[ulMax];
                DWORD dwLen = ulMax;
                BOOL bFound = GetRegistryBytesCU(g_szBookmark, buffer, &dwLen);
           
                if (bFound && dwLen != 0){
                    hr = pPersistMemory->Load( buffer, dwLen);
                }
                else{
					dwLen = ulMax;
                    bFound = GetRegistryBytes(g_szBookmark, buffer, &dwLen);
                    if (bFound && dwLen != 0){
                        hr = pPersistMemory->Load( buffer, dwLen);
                        if(SUCCEEDED(hr)){
                            SetRegistryBytes(g_szBookmark, NULL, 0);
                        }
                    }
                    else{
                        hr = E_FAIL;
                    }
                }
                delete[] buffer; 

            }
            pPersistMemory->Release();
        }
	}
	return hr;
}


/*************************************************************/
/* Name: DeleteFromRegistry
/* Description: load the bookmark from registry
/*************************************************************/
HRESULT CBookmark::DeleteFromRegistry()
{
    HRESULT hr = S_OK;
    BOOL bSuccess = SetRegistryBytesCU(g_szBookmark, NULL, 0);
    if (!bSuccess)
        hr = E_FAIL;
    return hr;
}

/*************************************************************************/
/* End of file: Bookmark.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msviddvdadm.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSVidWebDVDAdm.h                                                */
/* Description: Declaration of the CMSDVDAdm                             */
/* Author: Fang Wang                                                     */
/*************************************************************************/

#ifndef __MSVidWebDVDAdm_H_
#define __MSVidWebDVDAdm_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <objectwithsiteimplsec.h>

#define MAX_PASSWD      256
#define PRE_PASSWD      20
#define MAX_SECTION     20
#define MAX_RATE        10

#define PARENTAL_LEVEL_DISABLED  -1

/////////////////////////////////////////////////////////////////////////////
// CMSDVDAdm
class ATL_NO_VTABLE __declspec(uuid("FA7C375B-66A7-4280-879D-FD459C84BB02")) CMSVidWebDVDAdm : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IMSVidWebDVDAdm, &IID_IMSVidWebDVDAdm, &LIBID_MSVidCtlLib>,
    public CComCoClass<CMSVidWebDVDAdm, &__uuidof(CMSVidWebDVDAdm)>,
    public IObjectWithSiteImplSec<CMSVidWebDVDAdm>,
    public IObjectSafetyImpl<CMSVidWebDVDAdm, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
    public ISupportErrorInfo
{
public:
    CMSVidWebDVDAdm();
    virtual ~CMSVidWebDVDAdm();

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
                           IDS_REG_MSVIDWEBDVDADM_PROGID, 
                           IDS_REG_MSVIDWEBDVDADM_DESC,
                           LIBID_MSVidCtlLib,
                           __uuidof(CMSVidWebDVDAdm));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidWebDVDAdm)
    COM_INTERFACE_ENTRY(IMSVidWebDVDAdm)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_PROP_MAP(CMSVidWebDVDAdm)
END_PROP_MAP()

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSDVDAdm
public:
    STDMETHOD(get_DefaultMenuLCID)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_DefaultMenuLCID)(/*[in]*/ long newVal);
    STDMETHOD(get_DefaultSubpictureLCID)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_DefaultSubpictureLCID)(/*[in]*/ long newVal);
    STDMETHOD(get_DefaultAudioLCID)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_DefaultAudioLCID)(/*[in]*/ long newVal);
    STDMETHOD(GetParentalCountry)(long *lCountry);
    STDMETHOD(GetParentalLevel)(long *lLevel);
    STDMETHOD(get_DisableScreenSaver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_DisableScreenSaver)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(ChangePassword)(BSTR strUserName, BSTR strOld, BSTR strNew);
    STDMETHOD(ConfirmPassword)(BSTR strUserName, BSTR szPassword, VARIANT_BOOL *fRight);
    STDMETHOD(SaveParentalLevel)(long lParentalLevel,BSTR strUserName,  BSTR strPassword);
    STDMETHOD(SaveParentalCountry)(long lCountry,BSTR strUserName,  BSTR strPassword);
    STDMETHOD(get_BookmarkOnStop)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_BookmarkOnStop)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(RestoreScreenSaver)();    

protected:
    long        m_lParentctrlLevel;
    long        m_lParentctrlCountry;
    VARIANT_BOOL m_fDisableScreenSaver;
    BOOL        m_bScrnSvrOld;
    BOOL        m_bPowerlowOld;
    BOOL        m_bPowerOffOld;
    VARIANT_BOOL m_fBookmarkOnStop;

    HRESULT EncryptPassword(LPTSTR lpPassword, BYTE **lpAssaultedHash, DWORD *dwCryptLen, DWORD *dwAssault, BOOL genAssault);
    HRESULT DisableScreenSaver();
    HRESULT SaveScreenSaver();
    HRESULT HandleError(HRESULT hr);
};

BOOL SetRegistryString(const TCHAR *pKey, TCHAR *szString, DWORD dwLen);
BOOL GetRegistryString(const TCHAR *pKey, TCHAR *szRet, DWORD *dwLen, TCHAR *szDefault);
BOOL SetRegistryDword(const TCHAR *pKey, DWORD dwRet);
BOOL GetRegistryDword(const TCHAR *pKey, DWORD *dwRet, DWORD dwDefault);
BOOL SetRegistryBytes(const TCHAR *pKey, BYTE *szString, DWORD dwLen);
BOOL GetRegistryBytes(const TCHAR *pKey, BYTE *szRet, DWORD *dwLen);

    // Not so lame functions that use hkcu
BOOL SetRegistryStringCU(const TCHAR *pKey, TCHAR *szString, DWORD dwLen);
BOOL GetRegistryStringCU(const TCHAR *pKey, TCHAR *szRet, DWORD *dwLen, TCHAR *szDefault);
BOOL SetRegistryDwordCU(const TCHAR *pKey, DWORD dwRet);
BOOL GetRegistryDwordCU(const TCHAR *pKey, DWORD *dwRet, DWORD dwDefault);
BOOL SetRegistryBytesCU(const TCHAR *pKey, BYTE *szString, DWORD dwLen);
BOOL GetRegistryBytesCU(const TCHAR *pKey, BYTE *szRet, DWORD *dwLen);

#endif //__MSVidWebDVDAdm_H_

/*************************************************************************/
/* End of file: MSVidWebDVDAdm.h                                         */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidsberecorder.h ===
// CMSVidStreamBufferRecorder.h : Declaration of the CMSVidStreamBufferRecorder

#ifndef __MSVIDSTREAMBUFFERRECORDER_H_
#define __MSVIDSTREAMBUFFERRECORDER_H_

#include "stdafx.h"
#include <map>
#include <Mshtml.h>
#include <activscp.h>
#include <Atlctl.h>
#include <Exdisp.h>
#include <dvdmedia.h>
#include <objectwithsiteimplsec.h>
#include "segimpl.h"
#include "seg.h"
#include "resource.h"       // main symbols
#include "mslcid.h"
#include "sbe.h"
#include "dvdmedia.h"

typedef CComQIPtr<IStreamBufferRecordControl> pqSBERecControl;
/////////////////////////////////////////////////////
    
        
class ATL_NO_VTABLE __declspec(uuid("CAAFDD83-CEFC-4e3d-BA03-175F17A24F91")) CMSVidStreamBufferRecordingControlBase : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidStreamBufferRecordingControlBase, &__uuidof(CMSVidStreamBufferRecordingControlBase)>,
    public IObjectWithSiteImplSec<CMSVidStreamBufferRecordingControlBase>,
    public ISupportErrorInfo,
    public IObjectSafetyImpl<CMSVidStreamBufferRecordingControlBase, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
	public IDispatchImpl<IMSVidStreamBufferRecordingControl, &IID_IMSVidStreamBufferRecordingControl, &LIBID_MSVidCtlLib>
{  

    public:
    CMSVidStreamBufferRecordingControlBase()
        {
            m_Start = -1;
            m_Stop = -1;
        }	

    virtual ~CMSVidStreamBufferRecordingControlBase(){
        if(!(!Recorder)){// not not'ing smart pointer, they assert if p == 0
            Recorder.Release();
        }
    }
REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
                           IDS_REG_MSVIDSTREAMBUFFERRECORDINGCONTROL_PROGID,
						   IDS_REG_MSVIDSTREAMBUFFERRECORDINGCONTROL_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidStreamBufferRecordingControlBase));

DECLARE_PROTECT_FINAL_CONSTRUCT()



BEGIN_COM_MAP(CMSVidStreamBufferRecordingControlBase)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMSVidStreamBufferRecordingControl)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()
protected:
    pqSBERecControl Recorder;
    CComBSTR m_pName;
    REFERENCE_TIME m_Start;
    REFERENCE_TIME m_Stop;
    RecordingType m_Type;


// IMSVidStreamBufferRecordingControl
public:
    // ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    STDMETHOD(get_StartTime)(/*[out, retval]*/ long *Start) ;
    STDMETHOD(put_StartTime)(/*[in]*/ long Start) ;
    STDMETHOD(get_StopTime)(/*[out, retval]*/ long *Stop) ;
    STDMETHOD(put_StopTime)(/*[in]*/ long  Stop) ;    
    STDMETHOD(get_RecordingStopped)(/*[out, retval]*/ VARIANT_BOOL* Result) ;
    STDMETHOD(get_RecordingStarted)(/*[out, retval]*/ VARIANT_BOOL* Result) ;
    STDMETHOD(get_FileName)(/*[out, retval]*/ BSTR* pName);
    STDMETHOD(get_RecordingType)(/*[out, retval]*/ RecordingType *dwType);
    STDMETHOD(get_RecordingAttribute)(/*[out, retval]*/ IUnknown **pRecordingAttribute);

};
class ATL_NO_VTABLE __declspec(uuid("7D0B2FDE-9CA8-4b71-AE65-12193F5F52D8")) CMSVidStreamBufferRecordingControl:
    public CComObject<CMSVidStreamBufferRecordingControlBase>
{
public:
    CMSVidStreamBufferRecordingControl(IStreamBufferRecordControl* newVal, BSTR name, DWORD type){
        Recorder.Attach(newVal);
        m_pName.Attach(name);
        if(type == RECORDING_TYPE_CONTENT){
            m_Type = CONTENT;
        }
        else{
            m_Type = REFERENCE;
        }
    }
    virtual ~CMSVidStreamBufferRecordingControl(){}
};
    
#endif //__MSVIDSTREAMBUFFERRECORDINGCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidsbesink.h ===
//==========================================================================;
// MSVidStreamBufferSink.h : Declaration of the CMSVidStreamBufferSink
// copyright (c) Microsoft Corp. 1998-1999.
//==========================================================================;

//==========================================================================;
/* MSVidStreamBufferSink is the sink (destination, output) segement for the MSVidCtl 
   implementation of the SBE/StreamBuffer (StreamBuffer/digital video recording).
        Other than the normal methods of a output segment (see msvidclt.idl and 
        segment.idl) the sink also has:
        get/put_SinkName to name this instance of the SBE/StreamBuffer filter, so it can
            be easily refered to in another 
   In the MSVidCtl solution for SBE/StreamBuffer there are three segments that had to be added
   to MSVidCtl. The sink, source and StreamBufferSource segements. 
   The sink is the segement that gets connected to the input that is being StreamBuffered.
   The source is the segment that acts as the input for playback of the StreamBuffered content.
   The StreamBufferSource segment exists to play back the recorded files that are stored seperatly 
   from the SBE/StreamBuffer buffers. This is a seperate segment since there is no support, currently,
   for wm* (v or a) or asf content in MSVidCtl and even if there was the SBE/StreamBuffer content is in a 
   form of asf that is not supported by the windows media codec anyway.

*/
//==========================================================================;

#ifndef __MSVidSTREAMBUFFERSINK_H_
#define __MSVidSTREAMBUFFERSINK_H_

#pragma once

#include <algorithm>
#include <map>
#include <functional>
#include <iostream>
#include <string>
#include <evcode.h>
#include <uuids.h>
#include <amvideo.h>
#include <strmif.h>
#include <dvdmedia.h>
#include <objectwithsiteimplsec.h>
#include <bcasteventimpl.h>
#include "sbesinkcp.h"
#include "msvidctl.h"
#include "vidrect.h"
#include "vrsegimpl.h"
#include "devimpl.h"
#include "devsegimpl.h"
#include "seg.h"
#include "msvidsberecorder.h"
#include "resource.h"       // main symbols
#ifdef BUILD_WITH_DRM
#include "DRMSecure.h"
#include "DRMRootCert.h"      

#ifdef USE_TEST_DRM_CERT                        // dont use true (7002) CERT 
#include "Keys_7001.h"                                 //   until final release
static const BYTE* pabCert2      = abCert7001;
static const int   cBytesCert2   = sizeof(abCert7001);
static const BYTE* pabPVK2       = abPVK7001;
static const int   cBytesPVK2    = sizeof(abPVK7001);
#else
#include "Keys_7002.h"                                 // used in release code
static const BYTE* pabCert2      = abCert7002;
static const int   cBytesCert2   = sizeof(abCert7002);
static const BYTE* pabPVK2       = abPVK7002;
static const int   cBytesPVK2    = sizeof(abPVK7002);
#endif
#endif
typedef CComQIPtr<IStreamBufferSink> PQTSSink;
typedef CComQIPtr<IMSVidStreamBufferRecordingControl> pqRecorder;

/////////////////////////////////////////////////////////////////////////////
// CMSVidStreamBufferSink
class ATL_NO_VTABLE __declspec(uuid("9E77AAC4-35E5-42a1-BDC2-8F3FF399847C")) CMSVidStreamBufferSink :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidStreamBufferSink, &CLSID_MSVidStreamBufferSink>,
    public IObjectWithSiteImplSec<CMSVidStreamBufferSink>,
	public ISupportErrorInfo,
    public IBroadcastEventImpl<CMSVidStreamBufferSink>,
    public CProxy_StreamBufferSinkEvent<CMSVidStreamBufferSink>,
	public IMSVidGraphSegmentImpl<CMSVidStreamBufferSink, MSVidSEG_DEST, &GUID_NULL>,
	public IConnectionPointContainerImpl<CMSVidStreamBufferSink>,
	public IMSVidDeviceImpl<CMSVidStreamBufferSink, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidStreamBufferSink>
{
public:
	CMSVidStreamBufferSink() :
        m_StreamBuffersink(-1),
        m_bNameSet(FALSE)
	{

	}
   virtual ~CMSVidStreamBufferSink() {
       Expunge();
    }

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME,
						   IDS_REG_MSVIDSTREAMBUFFERSINK_PROGID,
						   IDS_REG_MSVIDSTREAMBUFFERSINK_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidStreamBufferSink));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidStreamBufferSink)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidStreamBufferSink)
    COM_INTERFACE_ENTRY(IMSVidOutputDevice)
	COM_INTERFACE_ENTRY(IMSVidDevice)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IBroadcastEvent)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CMSVidStreamBufferSink)
	IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
	IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
	IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSVidStreamBufferSink)
	CONNECTION_POINT_ENTRY(IID_IMSVidStreamBufferSinkEvent)    
END_CONNECTION_POINT_MAP()
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
protected:
    PQTSSink m_ptsSink;
	int m_StreamBuffersink;
	CComBSTR m_SinkName;
public:
    CComBSTR __declspec(property(get=GetName)) m_Name;
    CComBSTR GetName(void) {
        CString csName;
        if(m_StreamBuffersink != -1){
            csName = (m_Filters[m_StreamBuffersink]).GetName();
        }
        if (csName.IsEmpty()) {
            csName = _T("Time Shift Sink");
        }
		csName += _T(" Segment");
        return CComBSTR(csName);
    }
	STDMETHOD(get_SinkName)(BSTR *pName);
	STDMETHOD(put_SinkName)(BSTR Name);
    STDMETHOD(get_ContentRecorder)(BSTR pszFilename, IMSVidStreamBufferRecordingControl ** ppRecording);  
    STDMETHOD(get_ReferenceRecorder)(BSTR pszFilename, IMSVidStreamBufferRecordingControl ** ppRecording);  
    STDMETHOD(get_SBESink)(IUnknown ** sbeConfig);
STDMETHOD(Unload)(void) {
    // TODO fix this
    TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::Unload()");
    BroadcastUnadvise();

	IMSVidGraphSegmentImpl<CMSVidStreamBufferSink, MSVidSEG_DEST, &GUID_NULL>::Unload();
	m_StreamBuffersink = -1;
	m_ptsSink = reinterpret_cast<IUnknown*>(NULL);
    m_RecordObj.Release();
    _ASSERT(!m_RecordObj);
    m_bNameSet = FALSE;
	return NO_ERROR;
}
STDMETHOD(Decompose)(void) {
    // TODO fix this
    TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::Decompose()");
	IMSVidGraphSegmentImpl<CMSVidStreamBufferSink, MSVidSEG_DEST, &GUID_NULL>::Decompose();
	Unload();
	return NO_ERROR;
}
 
STDMETHOD(Build)() {
    try{
        TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::Build()");
        if (!m_fInit || !m_pGraph) {
            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSink), CO_E_NOTINITIALIZED);
        }
        CString csName;
        PQTSSink pTSSink(CLSID_StreamBufferSink, NULL, CLSCTX_INPROC_SERVER);
        if (!pTSSink) {
            //TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidStreamBufferSink::Build() can't load Time Shift Sink");
            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
        }
        DSFilter vr(pTSSink);
        if (!vr) {
            ASSERT(false);
            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
        }
        if (m_StreamBuffersink == -1) {
            m_Filters.push_back(vr);
            csName = _T("Time Shift Sink");
            m_pGraph.AddFilter(vr, csName);
        }         
        m_ptsSink = pTSSink;
        if(!m_ptsSink){
            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
        }
        m_StreamBuffersink = 0;
        ASSERT(m_StreamBuffersink == 0);
        m_bNameSet = FALSE;
        return NOERROR;
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}
STDMETHOD(get_Segment)(IMSVidGraphSegment * * pIMSVidGraphSegment){
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSink), CO_E_NOTINITIALIZED);
        }
        try {
            if (pIMSVidGraphSegment == NULL) {
			    return E_POINTER;
            }
            *pIMSVidGraphSegment = this;
            AddRef();
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
// IGraphSegment
STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl) {
    try {
        TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::put_Container()");
        HRESULT hr = IMSVidGraphSegmentImpl<CMSVidStreamBufferSink, MSVidSEG_DEST, &GUID_NULL>::put_Container(pCtl);
        if (FAILED(hr)) {
            return hr;
        }

        if (!pCtl) {
#ifdef BUILD_WITH_DRM
            CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph);
            if (spServiceProvider != NULL) {
                CComPtr<IDRMSecureChannel>  spSecureService;  
                hr = spServiceProvider->QueryService(SID_DRMSecureServiceChannel, 
                    IID_IDRMSecureChannel,
                    reinterpret_cast<LPVOID*>(&spSecureService));
                if(S_OK == hr){
                    // Found existing Secure Server
                    CComQIPtr<IRegisterServiceProvider> spRegServiceProvider(m_pGraph);
                    if(spRegServiceProvider == NULL){
                        // no service provider interface on the graph - fatal!
                        hr = E_NOINTERFACE;                 
                    } 

                    if(SUCCEEDED(hr)){ 
                        hr = spRegServiceProvider->RegisterService(SID_DRMSecureServiceChannel, NULL);
                    }
                } 
                _ASSERT(SUCCEEDED(hr));
            }
#endif
        }

        hr = BroadcastAdvise();
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::put_Container() can't advise for broadcast events");
            return E_UNEXPECTED;
        }
#ifdef BUILD_WITH_DRM
#ifdef USE_TEST_DRM_CERT
        {
            DWORD dwDisableDRMCheck = 0;
            CRegKey c;
            CString keyname(_T("SOFTWARE\\Debug\\MSVidCtl"));
            DWORD rc = c.Open(HKEY_LOCAL_MACHINE, keyname, KEY_READ);
            if (rc == ERROR_SUCCESS) {
                rc = c.QueryValue(dwDisableDRMCheck, _T("DisableDRMCheck"));
                if (rc != ERROR_SUCCESS) {
                    dwDisableDRMCheck = 0;
                }
            }

            if(dwDisableDRMCheck == 1){
                return S_OK;
            }
        }
#endif
        CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph);
        if (spServiceProvider == NULL) {
            return E_NOINTERFACE;
        }
        CComPtr<IDRMSecureChannel>  spSecureService;  
        hr = spServiceProvider->QueryService(SID_DRMSecureServiceChannel, 
            IID_IDRMSecureChannel,
            reinterpret_cast<LPVOID*>(&spSecureService));
        if(S_OK == hr){
            // Found existing Secure Server
            return S_OK;
        } 
        else{
            // if it's not there or failed for ANY reason 
            //   lets create it and register it
            CComQIPtr<IRegisterServiceProvider> spRegServiceProvider(m_pGraph);
            if(spRegServiceProvider == NULL){
                // no service provider interface on the graph - fatal!
                hr = E_NOINTERFACE;                 
            } 
            else{
                // Create the Client 
                CComPtr<IDRMSecureChannel>  spSecureServiceServer; 
                hr = DRMCreateSecureChannel( &spSecureServiceServer);
                if(spSecureServiceServer == NULL){
                    hr = E_OUTOFMEMORY;
                }
                if(FAILED(hr)){ 
                    return hr;
                }

                // Init keys
                hr = spSecureServiceServer->DRMSC_SetCertificate((BYTE *)pabCert2, cBytesCert2);
                if(FAILED(hr)){                
                    return hr;
                }

                hr = spSecureServiceServer->DRMSC_SetPrivateKeyBlob((BYTE *)pabPVK2, cBytesPVK2);
                if(FAILED(hr)){ 
                    return hr;
                }

                hr = spSecureServiceServer->DRMSC_AddVerificationPubKey((BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot) );
                if(FAILED(hr)){ 
                    return hr;
                }

                // Register It
                //   note RegisterService does not addref pUnkSeekProvider             
                hr = spRegServiceProvider->RegisterService(SID_DRMSecureServiceChannel, spSecureServiceServer);
            }
        }
#endif      // BUILD_WITH_DRM
        return NOERROR;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

 
STDMETHODIMP CMSVidStreamBufferSink::PreRun(){
    TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::PreRun()");
    return NameSetLock();
}

STDMETHODIMP CMSVidStreamBufferSink::NameSetLock(){
    try {
        TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock()");
        HRESULT hr;
        if(!m_bNameSet){
            if(!m_SinkName){
                return S_FALSE;
            }
            else{
                hr = m_ptsSink->IsProfileLocked();
                if(FAILED(hr)){
                    TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock() IsProfileLocked failed");
                    return hr;
                }
                else if(hr == S_OK){
                    TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock() Profile is locked");
                    return E_FAIL;
                }
                hr = m_ptsSink->LockProfile(m_SinkName);
                if(FAILED(hr)){
                    TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock() LockedProfile failed");
                    return hr;
                }
                
            }
            m_bNameSet = TRUE;
        }
        TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock() Succeeded");
		return S_OK;

	} catch (ComException &e) {
        TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock() Exception");
		return e;
	} catch (...) {
        TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock() Possible AV");
		return E_UNEXPECTED;
	}
}

STDMETHODIMP CMSVidStreamBufferSink::PostStop() {
	try {
        m_bNameSet = FALSE;
		TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::PostStop()");
        return S_OK;
	} catch (...) {
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
}

// IMSVidDevice
STDMETHOD(get_Name)(BSTR * Name) {
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSink), CO_E_NOTINITIALIZED);
        }
		if (Name == NULL)
			return E_POINTER;
        try {
		    *Name = m_Name.Copy();	
        } catch(...) {
            return E_POINTER;
        }
		return NOERROR;
	}
STDMETHOD(get_Status)(LONG * Status) {
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSink), CO_E_NOTINITIALIZED);
        }
		if (Status == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}

STDMETHOD(OnEventNotify)(LONG lEventCode, LONG_PTR lEventParm1, LONG_PTR lEventParm2){
        if(lEventCode == STREAMBUFFER_EC_WRITE_FAILURE){
            TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::OnEventNotify STREAMBUFFER_EC_WRITE_FAILURE");
            Fire_WriteFailure();
            return NO_ERROR;
        }
        return E_NOTIMPL;
    }
    // IBroadcastEvent
    STDMETHOD(Fire)(GUID gEventID);
private:
    void Expunge();
    pqRecorder m_RecordObj;
    BOOL m_bNameSet;
};
#endif //__MSVIDSTREAMBUFFERSINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidsberecorder.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidSBERecorder.cpp : Implementation of CMSVidStreamBufferRecordingControl
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "MSVidCtl.h"
#include "MSVidSBERecorder.h"
const long nano_to_hundredths = 100000;

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidStreamBufferRecordingControl, CMSVidStreamBufferRecordingControl)

STDMETHODIMP CMSVidStreamBufferRecordingControlBase::InterfaceSupportsErrorInfo(REFIID riid){
	static const IID* arr[] = 
	{
		&IID_IMSVidStreamBufferRecordingControl
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CMSVidStreamBufferRecordingControlBase::get_StartTime(/*[out, retval]*/ long *Start) {
    if(!Start){
        return E_POINTER;
    }
    *Start = static_cast<long>(m_Start/nano_to_hundredths);
    return S_OK;
}

HRESULT CMSVidStreamBufferRecordingControlBase::put_StartTime(/*[in]*/ long Start) {
    if(Start < 0){
        return E_INVALIDARG;
    }
    if(!Recorder){
        return E_UNEXPECTED;
    }
    m_Start = Start * nano_to_hundredths;
    HRESULT hr = Recorder->Start(&m_Start);
    if(FAILED(hr)){
        return hr;
    }
    return S_OK;

}

HRESULT CMSVidStreamBufferRecordingControlBase::get_StopTime(/*[out, retval]*/ long *Stop) {
    if(!Stop){
        return E_POINTER;
    }
    *Stop = static_cast<long>(m_Stop/nano_to_hundredths);
    return S_OK;
}

HRESULT CMSVidStreamBufferRecordingControlBase::put_StopTime(/*[in]*/ long  Stop) {
    if(Stop < 0){
        return E_INVALIDARG;
    }
    if(!Recorder){
        return E_UNEXPECTED;
    }
    m_Stop = Stop * nano_to_hundredths;
    HRESULT hr = Recorder->Stop(m_Stop);
    if(FAILED(hr)){
        return hr;
    }
    return S_OK;
}

HRESULT CMSVidStreamBufferRecordingControlBase::get_RecordingStarted(/*[out, retval]*/ VARIANT_BOOL* Result) {
    if(!Result){
        return E_POINTER;
    }
    if(!Recorder){
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }
    HRESULT hres = S_OK;
    BOOL bStarted;
    HRESULT hr = Recorder->GetRecordingStatus(&hres, &bStarted , 0);
    if(FAILED(hr)){
        ASSERT(FALSE);
        return E_UNEXPECTED;  
    }
    if(bStarted){
        *Result = VARIANT_TRUE;
    }
    else{
        *Result = VARIANT_FALSE;
    }
    return S_OK;
}

HRESULT CMSVidStreamBufferRecordingControlBase::get_RecordingStopped(/*[out, retval]*/ VARIANT_BOOL* Result) {
    if(!Result){
        return E_POINTER;
    }
    if(!Recorder){
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }
    HRESULT hres = S_OK;
    BOOL bStopped;
    HRESULT hr = Recorder->GetRecordingStatus(&hres, 0 , &bStopped);
    if(FAILED(hr)){
        ASSERT(FALSE);
        return E_UNEXPECTED;  
    }
    if(bStopped){
        *Result = VARIANT_TRUE;
    }
    else{
        *Result = VARIANT_FALSE;
    }
    return S_OK;
}

HRESULT CMSVidStreamBufferRecordingControlBase::get_FileName(/*[out, retval]*/ BSTR* pName){
    if(!pName){
        return E_POINTER;
    }
    HRESULT hr = m_pName.CopyTo(pName);
    if(FAILED(hr)){
        ASSERT(FALSE);
        return hr;
    }
    return S_OK;
}
HRESULT CMSVidStreamBufferRecordingControlBase::get_RecordingType(/*[out, retval]*/RecordingType *dwType){
    if(!dwType){
        return E_POINTER;
    }
    *dwType = m_Type;
    return S_OK;
}
HRESULT CMSVidStreamBufferRecordingControlBase::get_RecordingAttribute(/*[out, retval]*/ IUnknown **pRecordingAttribute){
    if(!pRecordingAttribute){
        return E_POINTER;
    }
    CComPtr<IUnknown> pRecUnk(Recorder);
    if(!pRecUnk){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferRecordingControl), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }
    *pRecordingAttribute = pRecUnk.Detach();
    return S_OK;
}
#endif //TUNING_MODEL_ONLY

// end of file - MSVidSBERecorder.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidsbesink.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidStreamBufferSink.cpp : Implementation of CMSVidStreamBufferSink
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include <encdec.h>
#include "MSVidCtl.h"
#include "MSVidSbeSink.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidStreamBufferSink, CMSVidStreamBufferSink)

/////////////////////////////////////////////////////////////////////////////
// CMSVidStreamBufferSink


STDMETHODIMP CMSVidStreamBufferSink::InterfaceSupportsErrorInfo(REFIID riid){
	static const IID* arr[] = 
	{
		&IID_IMSVidStreamBufferSink
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}



STDMETHODIMP CMSVidStreamBufferSink::get_SinkName(BSTR *pName){
	try{
		if(!pName){
			return E_POINTER;
		}
		*pName = m_SinkName.Copy();
		return S_OK;
	}
	catch(...){
		return E_UNEXPECTED;
	}
}
// This function has to be called before the graph is running
// so before or after build but before run is called
STDMETHODIMP CMSVidStreamBufferSink::put_SinkName(BSTR Name){
	try{
        if(!wcslen(Name)){
            return E_INVALIDARG;
        }
		m_SinkName = Name; 
        m_bNameSet = FALSE;
		CComQIPtr<IMSVidCtl> pq_vidCtl;
        if(!m_pContainer){
			return S_OK;
		}
		else{
            HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pq_vidCtl));
            if(FAILED(hr)){
                return hr;
            }
            MSVidCtlStateList state;
            hr = pq_vidCtl->get_State(&state);
            if(FAILED(hr)){
                return hr;
            }
            
            if(state == STATE_UNBUILT || state == STATE_STOP){
                hr = m_ptsSink->IsProfileLocked();
                if(FAILED(hr)){
                    return hr;
                }
                else if(hr != S_FALSE){
                    return E_FAIL; // should be called after run called on sink
                }
            }
            else{
                return E_FAIL; // should be called after run called on sink
            }		
        }
		return S_OK;
	}
	catch(...){
		return E_UNEXPECTED;
	}
}
void CMSVidStreamBufferSink::Expunge(){
    if(!( !m_RecordObj)){// not not'ing smart pointer, they assert if p == 0
        m_RecordObj.Release();
    }
    return;   
}
HRESULT CMSVidStreamBufferSink::get_ContentRecorder(BSTR pszFilename, IMSVidStreamBufferRecordingControl ** ppRecording){
    try{
        if(!pszFilename || !ppRecording){
            return E_POINTER;
        }

        if(!( !m_RecordObj)){// not not'ing smart pointer, they assert if p == 0
            m_RecordObj.Release();
        }
            // Create the new recorder if needed and insert it
        PUnknown tempUnknown;
        if(!m_ptsSink){
            //return not_init
            return E_FAIL; // should be invalid state
        }
        CComBSTR val = pszFilename;
        HRESULT hr = m_ptsSink->CreateRecorder(val, RECORDING_TYPE_CONTENT,&tempUnknown);
        if(FAILED(hr)){
            return hr;
        }
        pqSBERecControl newRec(tempUnknown);
        if(!newRec){
            return E_UNEXPECTED;
        }
        tempUnknown.Release();
        m_RecordObj = new CMSVidStreamBufferRecordingControl(newRec.Detach(), val.Detach(), RECORDING_TYPE_CONTENT);
        if(!m_RecordObj){
            ASSERT(false);
            return E_UNEXPECTED;
        }
        /*        
        CComQIPtr<IMSVidStreamBufferRecorder>retObj(m_RecordObj);
        if(!retObj){
            ASSERT(false);
            return E_UNEXPECTED;
        }
        *ppRecording = retObj.Detach();
        */
        //m_RecordObj->AddRef();
        hr = m_RecordObj.CopyTo(ppRecording);
        if(!ppRecording || FAILED(hr)){
            ASSERT(false);
            return E_UNEXPECTED;
        }
    }
    catch(...){
        return E_UNEXPECTED;
    }
    
    return S_OK;
}
HRESULT CMSVidStreamBufferSink::get_ReferenceRecorder(BSTR pszFilename, IMSVidStreamBufferRecordingControl ** ppRecording){
    try{
        if(!pszFilename || !ppRecording){
            return E_POINTER;
        }

        if(!( !m_RecordObj)){// not not'ing smart pointer, they assert if p == 0
            m_RecordObj.Release();
        }
            // Create the new recorder if needed and insert it
        PUnknown tempUnknown;
        if(!m_ptsSink){
            //return not_init
            return E_FAIL; // should be invalid state
        }
        CComBSTR val = pszFilename;
        HRESULT hr = m_ptsSink->CreateRecorder(val, RECORDING_TYPE_REFERENCE, &tempUnknown);
        if(FAILED(hr)){
            return hr;
        }
        pqSBERecControl newRec(tempUnknown);
        if(!newRec){
            return E_UNEXPECTED;
        }
        tempUnknown.Release();
        m_RecordObj = new CMSVidStreamBufferRecordingControl(newRec.Detach(), val.Detach(), RECORDING_TYPE_REFERENCE);
        if(!m_RecordObj){
            ASSERT(false);
            return E_UNEXPECTED;
        }
        /*        
        CComQIPtr<IMSVidStreamBufferRecordingControl>retObj(m_RecordObj);
        if(!retObj){
            ASSERT(false);
            return E_UNEXPECTED;
        }
        *ppRecording = retObj.Detach();
        */
        //m_RecordObj->AddRef();
        hr = m_RecordObj.CopyTo(ppRecording);
        if(!ppRecording || FAILED(hr)){
            ASSERT(false);
            return E_UNEXPECTED;
        }
    }
    catch(...){
        return E_UNEXPECTED;
    }
    
    return S_OK;
}

HRESULT CMSVidStreamBufferSink::get_SBESink(IUnknown ** sbeConfig){
    if(!sbeConfig){
        return E_POINTER;
    }
    if(m_StreamBuffersink == -1){
        return E_UNEXPECTED;
    }
    CComQIPtr<IBaseFilter> spSinkFilter(m_Filters[m_StreamBuffersink]);
    CComPtr<IUnknown>spUnk;
    spUnk = spSinkFilter;
    if(!spUnk){
        return E_UNEXPECTED;
    }
    *sbeConfig = spUnk.Detach();
    return NOERROR;

}

HRESULT CMSVidStreamBufferSink::Fire(GUID gEventID) {
	TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidStreamBufferSink::Fire() guid = " << GUID2(gEventID)), "");
    if (gEventID == EVENTID_ETDTFilterLicenseFailure) {
		Fire_CertificateFailure();
    } else if (gEventID == EVENTID_ETDTFilterLicenseOK) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidStreamBufferSink::Fire() Certificate Success"), "");
		Fire_CertificateSuccess();
    } 
    return NOERROR;
}

#endif //TUNING_MODEL_ONLY

// end of file - MSVidStreamBufferSink.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidsbesource.h ===
//==========================================================================;
// MSVidSBESource.h : Declaration of the CMSVidStreamBufferSource class
// copyright (c) Microsoft Corp. 1998-1999.
//==========================================================================;

#ifndef __MSVIDSTREAMBUFFERSOURCE_H_
#define __MSVIDSTREAMBUFFERSOURCE_H_

#pragma once

#include <algorithm>
#include <dvdmedia.h>
#include <objectwithsiteimplsec.h>
#include <bcasteventimpl.h>
#include "pbsegimpl.h"
#include "fileplaybackimpl.h"
#include "seg.h"
#include <dvdmedia.h>
#include "sbesourcecp.h"
#include "resource.h"       // main symbols
#include "sbe.h"

typedef CComQIPtr<IStreamBufferMediaSeeking> PQISBEMSeeking;
typedef CComQIPtr<IFileSourceFilter> QIFileSource;

class ATL_NO_VTABLE __declspec(uuid("AD8E510D-217F-409b-8076-29C5E73B98E8")) CMSVidStreamBufferSource:
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidStreamBufferSource, &__uuidof(CMSVidStreamBufferSource)>,
    public IObjectWithSiteImplSec<CMSVidStreamBufferSource>,
	public ISupportErrorInfo,
    public IBroadcastEventImpl<CMSVidStreamBufferSource>,
	public IConnectionPointContainerImpl<CMSVidStreamBufferSource>,
    public CProxy_StreamBufferSourceEvent<CMSVidStreamBufferSource>,
	public IMSVidPBGraphSegmentImpl<CMSVidStreamBufferSource, MSVidSEG_SOURCE, &GUID_NULL>,
    public IMSVidFilePlaybackImpl<CMSVidStreamBufferSource, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidStreamBufferSource>,
    public IProvideClassInfo2Impl<&CLSID_MSVidStreamBufferSource, &IID_IMSVidStreamBufferSourceEvent, &LIBID_MSVidCtlLib>
{
public:
    CMSVidStreamBufferSource() : m_dwEventCookie(0) {
        m_fEnableResetOnStop = true;
    }
	virtual ~CMSVidStreamBufferSource() {}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_MSVIDSTREAMBUFFERSOURCE_PROGID, 
						   IDS_REG_MSVIDSTREAMBUFFERSOURCE_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidStreamBufferSource));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidStreamBufferSource)
	COM_INTERFACE_ENTRY(IMSVidStreamBufferSource)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IBroadcastEvent)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IMSVidPlayback)
	COM_INTERFACE_ENTRY(IMSVidInputDevice)
	COM_INTERFACE_ENTRY(IMSVidDevice)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CMSVidStreamBufferSource)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSVidStreamBufferSource)
	CONNECTION_POINT_ENTRY(IID_IMSVidStreamBufferSourceEvent)    
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
protected:
        QIFileSource m_spFileSource;
        DSFilterList m_decFilters;
        PQBroadcastEvent m_pBcast;
        DWORD m_dwEventCookie;
public:
    STDMETHOD(PostStop)();

    // DON'T addref the container.  we're guaranteed nested lifetimes
    // and an addref creates circular refcounts so we never unload.
    CComBSTR __declspec(property(get=GetName)) m_Name;
    CComBSTR GetName(void) {
        CString csName;
        if(m_iReader != -1){
            csName = (m_Filters[m_iReader]).GetName();
        }        
        if (csName.IsEmpty()) {
            csName = _T("Stream Buffer Source");
        }
        return CComBSTR(csName);
    }
    STDMETHOD(Unload)(void);
	// IMSVidGraphSegment
	STDMETHOD(put_Init)(IUnknown *pInit);
    STDMETHOD(Build)();
	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pVal);
    STDMETHOD(OnEventNotify)(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2);
    STDMETHOD(Decompose)();
// IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name);
    // IMSVidInputDevice
    STDMETHOD(IsViewable)(VARIANT* pv, VARIANT_BOOL *pfViewable);
    STDMETHOD(View)(VARIANT* pv);
    // IMSVidPlayback
    // IMSVidPlayback
    STDMETHOD(get_RecordingAttribute)(/*[out, retval]*/ IUnknown **pRecordingAttribute);
	STDMETHOD(CurrentRatings)(/*[out, retval]*/ EnTvRat_System *pEnSystem, /*[out, retval]*/ EnTvRat_GenericLevel *pEnRating, /*[out, retval]*/ LONG *plbfEnAttr);	//attrs are bitfields of BfEnTvRat_GenericAttributes   
	STDMETHOD(MaxRatingsLevel)(/*[in]*/ EnTvRat_System enSystem, /*[in]*/ EnTvRat_GenericLevel enRating, /*[in]*/ LONG lbfEnAttr);


	STDMETHOD(put_BlockUnrated)(/*[in]*/ VARIANT_BOOL bBlock);
	STDMETHOD(put_UnratedDelay)(/*[in]*/ long dwDelay);
 
    STDMETHOD(get_Start)(/*[out, retval]*/long *lStart); 
    ///////////////////////////////////////////////////////////////////////////////////////////
    // IMSVidPlaybackimpl
    ///////////////////////////////////////////////////////////////////////////////////////////
	STDMETHOD(get_Length)(/*[out, retval]*/long *lLength);
    STDMETHOD(get_CurrentPosition)(/*[out,retval]*/long *lPosition);
    STDMETHOD(put_CurrentPosition)(/*[in]*/long lPosition);
    STDMETHOD(put_PositionMode)(/*[in]*/PositionModeList lPositionMode);
    STDMETHOD(get_PositionMode)(/*[out,retval]*/PositionModeList* lPositionMode);
    STDMETHOD(put_Rate)(double lRate);
  	STDMETHOD(get_Rate)(double *plRate);
    STDMETHOD(get_CanStep)(VARIANT_BOOL fBackwards, VARIANT_BOOL *pfCan);
    STDMETHOD(Step)(long lStep);
    STDMETHOD(PreRun)();
    // IBroadcastEvent
    STDMETHOD(Fire)(GUID gEventID);
    STDMETHOD(get_SBESource)(/*[out, retval]*/ IUnknown **sbeFilter);	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidsbesource.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidStreamBufferSource.cpp : Implementation of CMSVidStreamBufferSource
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "atltmp.h"
#include <encdec.h>
#include "MSVidCtl.h"
#include "MSVidsbeSource.h"
#include "encdec.h"

#if 0 // code for testing wm content
#include <wmsdkidl.h>
#endif

#include "msvidsbesink.h"   // to get pabCert2


#define FILE_BEGINNING 0
#define LOCAL_OATRUE -1
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidStreamBufferSource, CMSVidStreamBufferSource)

enum{
    CLOSE_TO_LIVE = 50,
};

/////////////////////////////////////////////////////////////////////////////
// CMSVidStreamBufferSource
STDMETHODIMP CMSVidStreamBufferSource::get_SBESource(/*[out, retval]*/ IUnknown **sbeFilter){
    if(!sbeFilter){
         return E_POINTER;
    }

    if(!m_spFileSource){
        USES_CONVERSION;
        CString csName(_T("SBE Playback"));
        QIFileSource qiFSource;
        HRESULT hr = qiFSource.CoCreateInstance(CLSID_StreamBufferSource, NULL, CLSCTX_INPROC_SERVER);
        if (FAILED(hr)){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
        if(!qiFSource){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
        m_spFileSource = qiFSource;
    }

    CComPtr<IUnknown> pUnk(m_spFileSource);
    if(!pUnk){
        return E_UNEXPECTED;
    }

    *sbeFilter = pUnk.Detach();
    return NOERROR;
}

STDMETHODIMP CMSVidStreamBufferSource::CurrentRatings(/*[out, retval]*/ EnTvRat_System *pEnSystem, /*[out, retval]*/ EnTvRat_GenericLevel *pEnRating, 
                                               /*[out, retval]*/ LONG *plbfEnAttr){
    if(!pEnSystem || !pEnRating || !plbfEnAttr){
        return E_POINTER;
    }
    DSFilterList::iterator i;
    EnTvRat_System system = static_cast<EnTvRat_System>(-1);
    EnTvRat_GenericLevel level = static_cast<EnTvRat_GenericLevel>(-1);
    LONG attr = static_cast<LONG>(-1);
    
    if(m_decFilters.empty()){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }

    for(i = m_decFilters.begin(); i != m_decFilters.end(); ++i){
        EnTvRat_System temp_system = static_cast<EnTvRat_System>(-1);
        EnTvRat_GenericLevel temp_level = static_cast<EnTvRat_GenericLevel>(-1);
        LONG temp_attri = static_cast<LONG>(-1);
        CComQIPtr<IDTFilter> qiDT(*i);
        if(!qiDT){
            continue;
        }
        HRESULT hr = qiDT->GetCurrRating(&temp_system, &temp_level, &temp_attri);
        if(FAILED(hr)){
            continue;
        }
        if(temp_system != system || 
            temp_level != level || 
            temp_attri != attr){
            system = temp_system;
            level = temp_level;
            attr = temp_attri;
        }
    }
    
    if(static_cast<long>(system) < 0 || static_cast<long>(level) < 0 || static_cast<long>(attr) < 0){
        return E_FAIL;
    }

    *pEnSystem = system;
    *pEnRating = level;
    *plbfEnAttr = attr;
    return S_OK;
}
												   // ------------------

STDMETHODIMP CMSVidStreamBufferSource::MaxRatingsLevel(/*[in]*/ EnTvRat_System enSystem, /*[in]*/ EnTvRat_GenericLevel enRating, 
                                                /*[in]*/ LONG						 plbfEnAttr){
    DSFilterList::iterator i;
    
    if(m_decFilters.empty()){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }

    for(i = m_decFilters.begin(); i != m_decFilters.end(); ++i){
        CComQIPtr<IDTFilter> qiDT(*i);
        if(!qiDT){
            continue;
        }

		HRESULT hr = qiDT->put_BlockedRatingAttributes(enSystem, enRating, plbfEnAttr);

        if(FAILED(hr)){
            return hr;
        }
    }
    
    return S_OK;
}

STDMETHODIMP CMSVidStreamBufferSource::put_BlockUnrated(/*[in]*/ VARIANT_BOOL bBlock){
    DSFilterList::iterator i;
    bool block = (bBlock == VARIANT_TRUE) ? true : false;
    
    if(m_decFilters.empty()){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }
    
    for(i = m_decFilters.begin(); i != m_decFilters.end(); ++i){
        CComQIPtr<IDTFilter> qiDT(*i);
        if(!qiDT){
            continue;
        }
        HRESULT hr = qiDT->put_BlockUnRated(block);
        if(FAILED(hr)){
            return hr;
        }
    }
    return S_OK;
}

STDMETHODIMP CMSVidStreamBufferSource::put_UnratedDelay(/*[in]*/ long dwDelay){
    DSFilterList::iterator i;
    
    if(m_decFilters.empty()){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }

    for(i = m_decFilters.begin(); i != m_decFilters.end(); ++i){
        CComQIPtr<IDTFilter> qiDT(*i);
        if(!qiDT){
            continue;
        }
        HRESULT hr = qiDT->put_BlockUnRatedDelay(dwDelay);
        if(FAILED(hr)){
            return hr;
        }
    }
    
    return S_OK;
}

STDMETHODIMP CMSVidStreamBufferSource::Unload(void) {
    BroadcastUnadvise();
    m_decFilters.clear();
    HRESULT hr = IMSVidGraphSegmentImpl<CMSVidStreamBufferSource, MSVidSEG_SOURCE, &GUID_NULL>::Unload();
    m_iReader = -1;
    m_spFileSource = reinterpret_cast<IFileSourceFilter*>(NULL);
    return hr;
}
STDMETHODIMP CMSVidStreamBufferSource::put_Init(IUnknown *pInit){
    HRESULT hr = IMSVidGraphSegmentImpl<CMSVidStreamBufferSource, MSVidSEG_SOURCE, &GUID_NULL>::put_Init(pInit);
    if (FAILED(hr)) {
        return hr;
    }
    if (pInit) {
        m_fInit = false;
        return E_NOTIMPL;
    }
    return NOERROR;
}
STDMETHODIMP CMSVidStreamBufferSource::get_Name(BSTR * Name){
    if (!m_fInit) {
 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSource), CO_E_NOTINITIALIZED);
    }
	if (Name == NULL)
		return E_POINTER;
    try {
	    *Name = m_Name.Copy();	
    } catch(...) {
        return E_POINTER;
    }
	return NOERROR;
}
// IMSVidInputDevice
STDMETHODIMP CMSVidStreamBufferSource::IsViewable(VARIANT* pv, VARIANT_BOOL *pfViewable)
{
    if (!m_fInit) {
        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSource), CO_E_NOTINITIALIZED);
    }
    if (!pv) {
        return E_POINTER;
    }
    return E_NOTIMPL;
}
STDMETHODIMP CMSVidStreamBufferSource::View(VARIANT* pv) {
    if (!m_fInit) {
        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSource), CO_E_NOTINITIALIZED);
    }
    if (!pv) {
        return E_POINTER;
    }
    if (!_wcsnicmp(pv->bstrVal, L"DVD:", 4)) {
        return E_FAIL;
    }
	return put_FileName(pv->bstrVal);
}
STDMETHODIMP CMSVidStreamBufferSource::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidStreamBufferSource
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
STDMETHODIMP CMSVidStreamBufferSource::put_Container(IMSVidGraphSegmentContainer *pCtl){
    try {
        HRESULT hr = S_OK;
        if (!m_fInit) {
            return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSource), CO_E_NOTINITIALIZED);
        }
        if (!pCtl) {
#ifdef BUILD_WITH_DRM
            CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph);
            if (spServiceProvider != NULL) {
                CComPtr<IDRMSecureChannel>  spSecureService;  
                hr = spServiceProvider->QueryService(SID_DRMSecureServiceChannel, 
                    IID_IDRMSecureChannel,
                    reinterpret_cast<LPVOID*>(&spSecureService));
                if(S_OK == hr){
                    // Found existing Secure Server
                    CComQIPtr<IRegisterServiceProvider> spRegServiceProvider(m_pGraph);
                    if(spRegServiceProvider == NULL){
                        // no service provider interface on the graph - fatal!
                        hr = E_NOINTERFACE;                 
                    } 

                    if(SUCCEEDED(hr)){ 
                        hr = spRegServiceProvider->RegisterService(SID_DRMSecureServiceChannel, NULL);
                    }
                } 
                _ASSERT(SUCCEEDED(hr));
            }
#endif
            return Unload();
        }
        if (m_pContainer) {
            if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
                return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidStreamBufferSource), CO_E_ALREADYINITIALIZED);
            } else {
                return NO_ERROR;
            }
        }

        // DON'T addref the container.  we're guaranteed nested lifetimes
        // and an addref creates circular refcounts so we never unload.
        m_pContainer.p = pCtl;
        m_pGraph = m_pContainer.GetGraph();
        hr = BroadcastAdvise();
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::put_Container() can't advise for broadcast events");
            return E_UNEXPECTED;
        }
#if 0 // code for testing wm content
        CComPtr<IUnknown> pUnkCert;
        hr = WMCreateCertificate(&pUnkCert);
        if (FAILED(hr)){
            _ASSERT(false);
        }

        CComQIPtr<IMSVidCtl>tempCtl(pCtl);
        if(tempCtl){
            hr = tempCtl->put_ServiceProvider(pUnkCert);
            if (FAILED(hr)){
                _ASSERT(false);
            }
        }
#endif

#ifdef BUILD_WITH_DRM
#ifdef USE_TEST_DRM_CERT
        {
            DWORD dwDisableDRMCheck = 0;
            CRegKey c;
            CString keyname(_T("SOFTWARE\\Debug\\MSVidCtl"));
            DWORD rc = c.Open(HKEY_LOCAL_MACHINE, keyname, KEY_READ);
            if (rc == ERROR_SUCCESS) {
                rc = c.QueryValue(dwDisableDRMCheck, _T("DisableDRMCheck"));
                if (rc != ERROR_SUCCESS) {
                    dwDisableDRMCheck = 0;
                }
            }

            if(dwDisableDRMCheck == 1){
                return S_OK;
            }
        }
#endif
        CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph);
        if (spServiceProvider == NULL) {
            return E_NOINTERFACE;
        }
        CComPtr<IDRMSecureChannel>  spSecureService;  
        hr = spServiceProvider->QueryService(SID_DRMSecureServiceChannel, 
            IID_IDRMSecureChannel,
            reinterpret_cast<LPVOID*>(&spSecureService));
        if(S_OK == hr){
            // Found existing Secure Server
            return S_OK;
        } 
        else{
            // if it's not there or failed for ANY reason 
            //   lets create it and register it
            CComQIPtr<IRegisterServiceProvider> spRegServiceProvider(m_pGraph);
            if(spRegServiceProvider == NULL){
                // no service provider interface on the graph - fatal!
                hr = E_NOINTERFACE;                 
            } 
            else{
                // Create the Client 
                CComPtr<IDRMSecureChannel>  spSecureServiceServer; 
                hr = DRMCreateSecureChannel( &spSecureServiceServer);
                if(spSecureServiceServer == NULL){
                    hr = E_OUTOFMEMORY;
                }
                if(FAILED(hr)){ 
                    return hr;
                }

                // Init keys
                hr = spSecureServiceServer->DRMSC_SetCertificate((BYTE *)pabCert2, cBytesCert2);
                if(FAILED(hr)){                
                    return hr;
                }

                hr = spSecureServiceServer->DRMSC_SetPrivateKeyBlob((BYTE *)pabPVK2, cBytesPVK2);
                if(FAILED(hr)){ 
                    return hr;
                }

                hr = spSecureServiceServer->DRMSC_AddVerificationPubKey((BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot) );
                if(FAILED(hr)){ 
                    return hr;
                }

                // Register It
                //   note RegisterService does not addref pUnkSeekProvider             
                hr = spRegServiceProvider->RegisterService(SID_DRMSecureServiceChannel, spSecureServiceServer);
            }
        }
#endif      // BUILD_WITH_DRM

        return NOERROR;
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

//-----------------------------------------------------------------------------------------
// Name: get_CanStep(VARIANT_BOOL, VARIANT_BOOL*)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::get_CanStep(VARIANT_BOOL fBackwards, VARIANT_BOOL *pfCan){
        // NOTE: NO ONE supports backwords stepping (why not? who knows)
        // so just like everyone else we dont either
        try{
            // Checking args and interfaces 
       
            if(!pfCan){
                // Passed a NULL Pointer
                return E_POINTER;
            }

            if (!m_pGraph) {
                // graph not valid
                return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
			}

            //Get a VideoFrameStep Interface
			PQVideoFrameStep pVFS(m_pGraph);
            if(!pVFS){
                // Could Not QI
				return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);          
			}
            
            if(fBackwards == VARIANT_TRUE){
                *pfCan = VARIANT_TRUE;
                return S_OK;
            }
            else{
                if(pVFS->CanStep(FALSE, NULL)==S_OK){
                    // It is all Good, Can Step Forward
                    *pfCan = VARIANT_TRUE;
                    return S_OK;
                }
                
                else{
                    // Can't Step
                    *pfCan = VARIANT_FALSE;
                    return S_OK;
                }
            }
        }
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT
            return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;   
        }
    }

//-----------------------------------------------------------------------------------------
// Name: Step(long)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::Step(long lStep){
        try{
            // Checking args and interfaces
            long tempStep = lStep;
            if (!m_pGraph || !m_pContainer) {
                // graph not valid
                return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            
            PQVideoFrameStep pVFS(m_pGraph);
            
            if(!pVFS){
                // Could Not QI
                return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
                
            }
            
            if(lStep < 0){
                PQMediaControl pmc(m_pGraph);
                if (!pmc) {
                    return Error(IDS_NO_MEDIA_CONTROL, __uuidof(IMSVidPlayback), E_UNEXPECTED);
                }
                HRESULT hr = pmc->Pause();
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Pause() hr = " << std::hex << hr), "");
                    return Error(IDS_CANT_PAUSE_GRAPH, __uuidof(IMSVidPlayback), hr);
                }
                
                long cur = 0;
                long stepVal = (/*half a second in 100ths of a second*/ 50 * lStep);
                PositionModeList curMode;
                hr = get_PositionMode(&curMode);
                if(FAILED(hr)){
                    return hr;
                }
                
                if(curMode == FrameMode){
                    stepVal = (stepVal/100) * 30; // hard coded to 30 fps for now
                }
                
                hr = get_CurrentPosition(&cur);
                if(FAILED(hr)){
                    return hr;
                }

                if(cur == 0){
                    return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
                }
                
                cur = cur + stepVal; // stepVal is negative, duh
                hr = put_CurrentPosition(cur);
                if(FAILED(hr)){
                    return hr;
                }
                // Set tempStep and then step to refresh the current frame
                tempStep = 1;
            }
            // Make it step
            return pVFS->Step(tempStep, NULL);
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
    

//-----------------------------------------------------------------------------------------
// Name: get_Start(long)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::get_Start(/*[out, retval]*/long *lStart){
    HRESULT hr = S_OK;
    LONGLONG tempfirst, templatest;
    PositionModeList curMode;
    try{
        // Checking args and init'ing interfaces
        if (!lStart){
            return E_POINTER;
        }
        if (!m_pGraph) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // See if object supports ISBEMediaSeeking
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){ // not not'ing smart pointer, they assert if p == 0
            // Find out what postion mode is being used
            hr = get_PositionMode(&curMode);
            if(FAILED(hr)){
                return hr;
            }
            hr = PQIMSeeking->GetAvailable(&tempfirst, &templatest);
            if(FAILED(hr)){
                return hr;
            }
            // If it is FrameMode no conversion needed
            if(tempfirst == 0){
                *lStart = 0;
                hr = S_OK;
                return hr;
            }
            if(curMode == FrameMode){
                *lStart = static_cast<long>(tempfirst);
                TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::get_Start() return=" << (unsigned long)(*lStart) << " longlong=" << (double)(tempfirst)), "");

                hr = S_OK;
                return hr;
            }
            // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
            if(curMode == TenthsSecondsMode){
                *lStart = static_cast<long>(tempfirst / nano_to_hundredths);    
                TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::get_Start() return=" << (unsigned long)(*lStart) << " longlong=" << (double)(tempfirst)), "");
                hr = S_OK;
                return hr;
            }
            // If it is some other mode not supported by the vidctl
            else{
                return E_UNEXPECTED;
            }
        }
        // Could Not QI IMedia Seeking or Position
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
        
    }
    
    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CMSVidStreamBufferSource::get_RecordingAttribute(/*[out, retval]*/ IUnknown **pRecordingAttribute){
    if(!pRecordingAttribute){
        return E_POINTER;
    }
    CComPtr<IUnknown> pRecUnk(m_spFileSource);
    if(!pRecUnk){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }
    *pRecordingAttribute = pRecUnk.Detach();
    return S_OK;
}

//-----------------------------------------------------------------------------------------
// Name: get_Length(long)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::get_Length(/*[out, retval]*/long *lLength){
    HRESULT hr = S_OK;
    LONGLONG tempfirst, templatest;
    PositionModeList curMode;
    try{
        // Checking args and init'ing interfaces
        if (!lLength){
            return E_POINTER;
        }
        if (!m_pGraph) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // See if object supports ISBEMediaSeeking
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){ // not not'ing smart pointer, they assert if p == 0
            // Find out what postion mode is being used
            hr = get_PositionMode(&curMode);
            if(FAILED(hr)){
                return hr;
            }
            hr = PQIMSeeking->GetAvailable(&tempfirst, &templatest);
            if(FAILED(hr)){
                return hr;
            }
            // If it is FrameMode no conversion needed
            if(curMode == FrameMode){
                *lLength = static_cast<long>(templatest);
                TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::get_Length() return=" << (unsigned long)(*lLength) << " longlong=" << (double)(templatest)), "");
                hr = S_OK;
                return hr;
            }
            // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
            else if(curMode == TenthsSecondsMode){
                *lLength = static_cast<long>(templatest / nano_to_hundredths);
                TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::get_Length() return=" << (unsigned long)(*lLength) << " longlong=" << (double)(templatest)), "");
                hr = S_OK;
                return hr;
            }
            // If it is some other mode not supported by the vidctl
            else{
                return E_UNEXPECTED;
            }
        }

         // Could Not QI IMedia Seeking
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
        
    }
    
    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}

//-----------------------------------------------------------------------------------------
// Name: get_CurrentPosition(LONGLONG*)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::get_CurrentPosition(/*[out,retval]*/long *lPosition) {
    HRESULT hr = S_OK;
    LONGLONG tempval;
    PositionModeList curMode;
    try{
        // Checking args and init'ing interfaces
        if (!lPosition){
            return E_POINTER;
        }
        if (!m_spFileSource) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // See if object supports ISBEMediaSeeking
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){// not not'ing smart pointer, they assert if p == 0
            // Find out what postion mode is being used
            hr = get_PositionMode(&curMode);
            if(FAILED(hr)){
                return hr;
            }
            hr = PQIMSeeking->GetCurrentPosition(&tempval);
            if(FAILED(hr)){
                return hr;
            }
            // If it is FrameMode no conversion needed
            if(curMode == FrameMode){
                *lPosition = static_cast<long>(tempval);
                TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::get_CurrentPosition() return=" << (unsigned long)(*lPosition) << " longlong=" << (double)(tempval)), "");
                hr = S_OK;
                return hr;
            }
            // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
            else if(curMode == TenthsSecondsMode){
                *lPosition = static_cast<long>(tempval / nano_to_hundredths);
                TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::get_CurrentPosition() return=" << (unsigned long)(*lPosition) << " longlong=" << (double)(tempval)), "");
                hr = S_OK;
                return hr;
            }
            // If it is some other mode not supported by the vidctl
            else{
                return E_UNEXPECTED;
            }
        }
        // Could Not QI IMedia Seeking
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}
//-----------------------------------------------------------------------------------------
// Name: put_CurrentPosition(LONGLONG)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::put_CurrentPosition(/*[in]*/long lPosition) {
    HRESULT hr = S_OK;
    LONGLONG tempval;
    PositionModeList curMode;
    try{
        // Checking args and interfaces
        if (!m_spFileSource) {
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // Check for a ISBEMediaSeeking Interface
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){ // not not'ing smart pointer, they assert if p == 0
            // Get the position Mode
            hr = get_PositionMode(&curMode);
            if(FAILED(hr)){
                return hr;
            }
            tempval = lPosition;
            // If it is in TenthsSecondsMode convert input into 100 nanosecond units
            if(curMode == TenthsSecondsMode){
                tempval = (tempval) * nano_to_hundredths;
            }
            // If it is in some other mode
            else if(curMode != FrameMode){
                return E_UNEXPECTED;
            }
            // Set the new Position
            TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::put_CurrentPosition() set to: input=" << (unsigned long)(lPosition) << " longlong=" << (double)(tempval)), "");
            hr = PQIMSeeking->SetPositions(&tempval, AM_SEEKING_AbsolutePositioning, NULL, 0);
            TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::put_CurrentPosition() actually set to:" << (double)(tempval)), "");

            return hr; 
        }
        // Could Not QI Media Position
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}
//-----------------------------------------------------------------------------------------
// Name: put_PositionMode(LONGLONG)
//-----------------------------------------------------------------------------------------

STDMETHODIMP CMSVidStreamBufferSource::put_PositionMode(/*[in]*/PositionModeList lPositionMode) {
    HRESULT hr = S_OK;
    double testval;
    get_Rate(&testval);
    try{
        // Checking args and interfaces
        if (!m_spFileSource) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
        // only valid values
        if(lPositionMode != FrameMode && lPositionMode != TenthsSecondsMode){
            return E_INVALIDARG;
        }
        // Try for a ISBEMediaSeeking
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){// not not'ing smart pointer, they assert if p == 0
            // Set the new mode
            if(lPositionMode == FrameMode){
                hr = PQIMSeeking->SetTimeFormat( &( static_cast<GUID>(TIME_FORMAT_FRAME) ) );
                return hr; 
            }
            if(lPositionMode == TenthsSecondsMode){
                hr = PQIMSeeking->SetTimeFormat(&(static_cast<GUID>(TIME_FORMAT_MEDIA_TIME)));
                return hr; 
            }
        }
        // Could Not QI
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}


//-----------------------------------------------------------------------------------------
// Name: get_PositionMode(LONGLONG*)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::get_PositionMode(/*[out,retval]*/PositionModeList* lPositionMode) {
    HRESULT hr = S_OK;
    double testval;
    get_Rate(&testval);
    try{
        // Checking args and interfaces
        if(!lPositionMode){
            return E_POINTER;
        }
        if (!m_spFileSource) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
        // Get an ISBEMediaSeeking Interface
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){// not not'ing smart pointer, they assert if p == 0
            // Get the mode
            GUID cur_mode;
            hr = PQIMSeeking->GetTimeFormat(&cur_mode);
            if(FAILED(hr)){
                return hr;
            }
            // Check to see which mode it is in
            if(cur_mode == static_cast<GUID>(TIME_FORMAT_FRAME)){
                *lPositionMode = FrameMode;
                return S_OK;
            }
            if(cur_mode == static_cast<GUID>(TIME_FORMAT_MEDIA_TIME)){
                *lPositionMode = TenthsSecondsMode;
                return S_OK;
            }
            // Not in a vidctl supported mode
            else{
                return E_FAIL;
            }
        }
        // Could Not QI
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}

//-----------------------------------------------------------------------------------------
// Name: put_Rate(double)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::put_Rate(double lRate){
    HRESULT hr = S_OK;
    try{
        /*** Checking args and init'ing interfaces ***/

        if (!m_spFileSource) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // Attempt to set the rate using ISBEMediaSeeking
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){// not not'ing smart pointer, they assert if p == 0
            return PQIMSeeking->SetRate(lRate);
        }
        // Could Not QI set the error
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}
//-----------------------------------------------------------------------------------------
// Name: get_Rate(double*)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::get_Rate(double *plRate){
    HRESULT hr = S_OK;
    try{
        /*** Checking args and init'ing interfaces ***/
        if (!plRate){
            return E_POINTER;
        }
        if (!m_spFileSource) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){// not not'ing smart pointer, they assert if p == 0
            return PQIMSeeking->GetRate(plRate);
        }
        // Could Not QI
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CMSVidStreamBufferSource::PostStop(){
    HRESULT hr = S_OK;

    try {
#if 0
        // If the graph is not is stopped state
        // we make sure it is
        if (!m_pGraph.IsStopped()) {
            HRESULT hr = PQVidCtl(m_pContainer)->Stop();
        }
#endif
        // If m_fEnableResetOnStop is true then we need to reset 
        // the postion back to the beggining
        // else do nothing
        if(m_fEnableResetOnStop){
            return put_CurrentPosition(0);
        }

    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }
    return hr;      
}
STDMETHODIMP CMSVidStreamBufferSource::Decompose() {
    return put_Container(NULL);
}
STDMETHODIMP CMSVidStreamBufferSource::Build() {
    if (!m_FileName) {
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }

    QIFileSource qiFSource;
    HRESULT hr = S_OK;
    DSFilter pfr;
    if(!m_spFileSource){
        USES_CONVERSION;
        hr = qiFSource.CoCreateInstance(CLSID_StreamBufferSource, NULL, CLSCTX_INPROC_SERVER);
        if (FAILED(hr)){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
        if(!qiFSource){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
        m_spFileSource = qiFSource;
        hr = m_spFileSource->QueryInterface(&pfr);
        if (FAILED(hr) || !pfr) {
            _ASSERT(false);
            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidStreamBufferSource::Build() Could not create StreamBufferSource hr = " << std::hex << hr), "");
            return Error(IDS_CANT_PLAY_FILE, __uuidof(IMSVidStreamBufferSource), hr);
        }
    }
    else{
        qiFSource = m_spFileSource;
        if(!qiFSource){
            _ASSERT(false);
            return E_UNEXPECTED; 
        }
        hr = m_spFileSource->QueryInterface(&pfr);
        if (FAILED(hr) || !pfr) {
            _ASSERT(false);
            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidStreamBufferSource::Build() Could not create StreamBufferSource hr = " << std::hex << hr), "");
            return Error(IDS_CANT_PLAY_FILE, __uuidof(IMSVidStreamBufferSource), hr);
        }
    }

    CString csName(_T("SBE Playback"));
    m_Filters.clear();
    hr = m_pGraph.AddFilter(pfr, csName);
    if(FAILED(hr)){
        _ASSERT(false);
        return E_UNEXPECTED;
    }

    hr = qiFSource->Load(m_FileName, NULL);
    if (FAILED(hr)) {
        bool rc = m_pGraph.RemoveFilter(pfr);
        if (!rc) {
            return E_UNEXPECTED;
        }
        TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidStreamBufferSource::Build() Could not create StreamBufferSource hr = " << std::hex << hr), "");
        return Error(IDS_CANT_PLAY_FILE, __uuidof(IMSVidStreamBufferSource), hr);
    }

    m_Filters.push_back(pfr);
    m_iReader = m_Filters.size() - 1;
#if ENCRYPT_NEEDED
    DSFilterList intermediates;
    for(DSFilter::iterator i = pfr.begin(); i != pfr.end(); ++i){
        if((*i).GetDirection() == DOWNSTREAM && !(*i).IsConnected()){
            // Create and add a decoder Tagger Filter 
            CComPtr<IUnknown> spEncTagD(CLSID_DTFilter, NULL, CLSCTX_INPROC_SERVER);
            if (!spEncTagD) {
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSink::Build() can't load Tagger filter");
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
            }

            DSFilter vrD(spEncTagD);
            if (!vrD) {
                ASSERT(false);
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
            }

            m_Filters.push_back(vrD);
            m_decFilters.push_back(vrD);
            csName = _T("Decoder/Tagger Filter");
            m_pGraph.AddFilter(vrD, csName);

            // Connect pin to the Tagger
            hr = (*i).IntelligentConnect(vrD, intermediates);
            if(FAILED(hr)){
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() if you see this line more than once something must have gone wrong");  
            }

        }
    }
    ASSERT(intermediates.begin() == intermediates.end());
    m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
#endif
    return NOERROR;
}

STDMETHODIMP CMSVidStreamBufferSource::PreRun(){
#if 0 
    if(m_iReader == -1 || m_Filters.empty()){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }
    
    CComQIPtr<IReferenceClock> pq_IRClock(m_Filters[m_iReader]);
    if(!pq_IRClock){
        return S_FALSE;
    }

    CComQIPtr<IMediaFilter> pq_MFGph(m_pGraph);
    if(!pq_MFGph){
        return E_NOINTERFACE;
    }


    HRESULT hr = pq_MFGph->SetSyncSource(pq_IRClock);
    if(FAILED(hr)){
        ASSERT(false);
    }

    return hr;
#endif
    return E_NOTIMPL;
}

STDMETHODIMP CMSVidStreamBufferSource::OnEventNotify(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2) {
    if (lEvent == EC_COMPLETE) {
        double curRate = 0;
        HRESULT hr = S_OK;
        hr = get_Rate(&curRate);
        if(SUCCEEDED(hr)){
            if(curRate < 0){
                hr = put_Rate(1);
                if(FAILED(hr)){
                    _ASSERT(false);
                }

                // We need to transition to pause then back to play to flush all of the buffers
                // It appears to be a decoder issue, mostly
                PQVidCtl sp_VidCtl(m_pContainer);
                if(sp_VidCtl){
                    hr = sp_VidCtl->Pause();
                    if(FAILED(hr)){
                        _ASSERT(false); // Failed to pause this is really bad
                    }

                    hr = sp_VidCtl->Run();
                    if(FAILED(hr)){
                        _ASSERT(false); // Failed to run this is really bad
                    }
                }
                else{
                    _ASSERT(false); // We got events with no vidctl hosting us, really weird
                }



                CComQIPtr<IMSVidPlayback> ppb(this);
                Fire_EndOfMedia(ppb);
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::OnEventNotify Tossed EndOfMedia at start of sbe stream");  
                return NOERROR;

            }
        }
    }

    if(lEvent == STREAMBUFFER_EC_RATE_CHANGED){
        TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::OnEventNotify STREAMBUFFER_EC_RATE_CHANGED");
        HRESULT hr = S_OK;
#if 0 // code to try to make up for the lack of a rate change event on the vidctl
        MSVidCtlStateList curState = STATE_UNBUILT;
        hr = PQVidCtl(m_pContainer)->get_State(&curState);
        if(SUCCEEDED(hr) && curState == STATE_PLAY){
            CComQIPtr<IMSVidDevice> pd(this);
            if (!pd) {
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::OnEventNotify Could not qi SBE Source Segment for IMSVidDevice");  
            }
            else{
                Fire_StateChange(pd, STATE_PLAY, STATE_PLAY);
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::OnEventNotify Tossed StateChange STATE_PLAY STATE_PLAY for rate change");  
            }
        }
#endif
        long len;
        long curPos;
        curPos = len = 0;
        hr = get_Length(&len);
        if(SUCCEEDED(hr)){
            hr = get_CurrentPosition(&curPos);
            if(SUCCEEDED(hr)){
                if(len <= (curPos + CLOSE_TO_LIVE)){ // if current position is with in CLOSE_TO_LIVE of the len the we just bounced off of the end of the stream
                    CComQIPtr<IMSVidPlayback> ppb(this);
                    if (!ppb) {
                        TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::OnEventNotify Could not qi SBE Source Segment for IMSVidPlayback");  
                    }
                    else{
                        Fire_EndOfMedia(ppb);
                        TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::OnEventNotify Tossed EndOfMedia at end of sbe stream");  
                        return NOERROR;
                    }
                }
            }
        }
    }

    if(lEvent == STREAMBUFFER_EC_TIMEHOLE){
        Fire_TimeHole(lParam1, lParam2);
        return NOERROR;
    }

    if(lEvent == STREAMBUFFER_EC_STALE_DATA_READ){
        Fire_StaleDataRead();
        return NOERROR;
    }

    if(lEvent == STREAMBUFFER_EC_STALE_FILE_DELETED){
        Fire_StaleFilesDeleted();
        return NOERROR;
    }

    if(lEvent == STREAMBUFFER_EC_CONTENT_BECOMING_STALE){
        Fire_ContentBecomingStale();
        return NOERROR;
    }

    return IMSVidPBGraphSegmentImpl<CMSVidStreamBufferSource, MSVidSEG_SOURCE, &GUID_NULL>::OnEventNotify(lEvent, lParam1, lParam2);
}

HRESULT CMSVidStreamBufferSource::Fire(GUID gEventID) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidStreamBufferSource::Fire() guid = " << GUID2(gEventID)), "");
    if (gEventID == EVENTID_ETDTFilterLicenseFailure) {
		Fire_CertificateFailure();
    } else if (gEventID == EVENTID_ETDTFilterLicenseOK) {
		Fire_CertificateSuccess();
    } else if (gEventID == EVENTID_DTFilterRatingsBlock) {
        Fire_RatingsBlocked();
    } else if (gEventID == EVENTID_DTFilterRatingsUnblock) {
        Fire_RatingsUnblocked();
    } else if (gEventID == EVENTID_DTFilterRatingChange) {
        Fire_RatingsChanged();
    }

    return NOERROR;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidvideorenderer.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidVideoRenderer.cpp : Implementation of CMSVidVideoRenderer
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "MSVidCtl.h"
#include "MSVidVideoRenderer.h"
#include "Vidctl.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidVideoRenderer, CMSVidVideoRenderer)

/////////////////////////////////////////////////////////////////////////////
// CMSVidVideoRenderer

STDMETHODIMP CMSVidVideoRenderer::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidVideoRenderer
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
STDMETHODIMP CMSVidVideoRenderer::put_SuppressEffects(/*in*/ VARIANT_BOOL bSuppressEffects){
    m_vidSuppressEffects = bSuppressEffects==VARIANT_TRUE?true:false; 
    return NOERROR;
}
STDMETHODIMP CMSVidVideoRenderer::get_SuppressEffects(/*out, retval*/ VARIANT_BOOL *bSuppressEffects){
    if(!bSuppressEffects){
        return E_POINTER;
    }
    *bSuppressEffects = m_vidSuppressEffects?VARIANT_TRUE:VARIANT_FALSE;
    return NOERROR;
}
#endif //TUNING_MODEL_ONLY

// end of file - MSVidvideorenderer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidtvtuner.h ===
//==========================================================================;
// MSVidTVTuner.h : Declaration of the CMSVidTVTuner
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __MSVidTVTUNER_H_
#define __MSVidTVTUNER_H_

#include <algorithm>
#include <tchar.h>
#include <bdamedia.h>
#include <objectwithsiteimplsec.h>
#include <bcasteventimpl.h>
#include "segimpl.h"
#include "analogtunerimpl.h"
#include "analogtvcp.h"
#include "seg.h"

const int DEFAULT_OVERSCAN_PCT = 100; // 1%

/////////////////////////////////////////////////////////////////////////////
// CMSVidTVTuner
class ATL_NO_VTABLE __declspec(uuid("1C15D484-911D-11d2-B632-00C04F79498E")) CMSVidTVTuner : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMSVidTVTuner, &__uuidof(CMSVidTVTuner)>,
    public IObjectWithSiteImplSec<CMSVidTVTuner>,
    public ISupportErrorInfo,
    public IConnectionPointContainerImpl<CMSVidTVTuner>,
    public CProxy_IMSVidAnalogTuner<CMSVidTVTuner>,
    public IBroadcastEventImpl<CMSVidTVTuner>,
    public IMSVidGraphSegmentImpl<CMSVidTVTuner, MSVidSEG_SOURCE, &KSCATEGORY_TVTUNER>,
    public IMSVidAnalogTunerImpl<CMSVidTVTuner, &LIBID_MSVidCtlLib, &KSCATEGORY_TVTUNER, IMSVidAnalogTuner>,
    public IProvideClassInfo2Impl<&CLSID_MSVidAnalogTunerDevice, &IID_IMSVidAnalogTunerEvent, &LIBID_MSVidCtlLib>
{
public:
    CMSVidTVTuner() : m_iTuner(-1), 
        m_iCapture(-1),
        m_bRouted(false)
    {

    }

    virtual ~CMSVidTVTuner() {}

    REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_TVTUNER_PROGID, 
        IDS_REG_TVTUNER_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CMSVidTVTuner));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CMSVidTVTuner)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IMSVidAnalogTuner)
        COM_INTERFACE_ENTRY(IMSVidTuner)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IMSVidDevice)
        COM_INTERFACE_ENTRY(IMSVidInputDevice)
        COM_INTERFACE_ENTRY(IMSVidVideoInputDevice)
        COM_INTERFACE_ENTRY(IBroadcastEvent)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
    END_COM_MAP()

    BEGIN_CATEGORY_MAP(CMSVidTVTuner)
        IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
        IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
        IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
    END_CATEGORY_MAP()

    BEGIN_CONNECTION_POINT_MAP(CMSVidTVTuner)
        CONNECTION_POINT_ENTRY(IID_IMSVidAnalogTunerEvent)    
    END_CONNECTION_POINT_MAP()


    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    PQCreateDevEnum m_pSystemEnum;
    int m_iTuner;
    int m_iCapture;
    bool m_bRouted;

    virtual PQTVTuner GetTuner() {
        if (m_iTuner < 0) {
            return PQTVTuner();
        }
        return PQTVTuner(m_Filters[m_iTuner]);
    }
    virtual PQAnalogVideoDecoder GetDecoder() {
        if (m_iCapture < 0) {
            return PQAnalogVideoDecoder();
        }
        return PQAnalogVideoDecoder(m_Filters[m_iCapture]);
    }
    STDMETHOD(put_Tune)(ITuneRequest *pTR);
    STDMETHOD(ChannelAvailable)(LONG nChannel, LONG * SignalStrength, VARIANT_BOOL * fSignalPresent);
    STDMETHOD(Decompose)();
    virtual HRESULT DoTune(TNTuneRequest &ctr);
    virtual HRESULT UpdateTR(TNTuneRequest& pTR);
    HRESULT TwiddleXBar(ULONG dwInput);
    HRESULT Unload(void) {
        BroadcastUnadvise();
        IMSVidGraphSegmentImpl<CMSVidTVTuner, MSVidSEG_SOURCE, &KSCATEGORY_TVTUNER>::Unload();
        m_iTuner = -1;
        m_iCapture = -1;
        return NOERROR;
    }
    // IMSVidGraphSegment
    STDMETHOD(put_Init)(IUnknown *pDeviceMoniker)
    {
        if (!pDeviceMoniker) {
            return E_POINTER;
        }
        HRESULT hr = IMSVidGraphSegmentImpl<CMSVidTVTuner, MSVidSEG_SOURCE, &KSCATEGORY_TVTUNER>::put_Init(pDeviceMoniker);
        if (FAILED(hr)) {
            return hr;
        }
        if (!m_pDev) {
            m_fInit = false;
            return Error(IDS_INVALID_SEG_INIT, __uuidof(IMSVidAnalogTuner), E_NOINTERFACE);
        }
        return NOERROR;
    }
    STDMETHOD(Build)();

    STDMETHOD(PreRun)() {
        ASSERT(m_iTuner != -1);
        PQTVTuner pTV(m_Filters[m_iTuner]);
        if (!pTV) {
            return E_UNEXPECTED;
        }
        if (m_pCurrentTR) {
            return DoTune(m_pCurrentTR);
        }
        TunerInputType it = DEFAULT_ANALOG_TUNER_INPUT_TYPE;
        long cc = DEFAULT_ANALOG_TUNER_COUNTRY_CODE;
        if (m_TS) {
            TNAnalogTVTuningSpace ts(m_TS);
            it = ts.InputType();
            cc = ts.CountryCode();
        }
        HRESULT hr = pTV->put_InputType(0, it);
        _ASSERT(SUCCEEDED(hr));
        hr = pTV->put_CountryCode(cc);
        _ASSERT(SUCCEEDED(hr));

        return NOERROR;
    }

    STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl);
    // IMSVidDevice
    STDMETHOD(get_Name)(BSTR * Name)
    {
        if (!m_fInit) {
            return CO_E_NOTINITIALIZED;
        }
        try {
            CComBSTR DefaultName(OLESTR("Analog Tuner"));
            return GetName(((m_iTuner > -1) ? (m_Filters[m_iTuner]) : DSFilter()), m_pDev, DefaultName).CopyTo(Name);
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    // IBroadcastEvent
    STDMETHOD(Fire)(GUID gEventID) {
        if (gEventID == EVENTID_TuningChanged) {
            Fire_OnTuneChanged(this);
        }
        return NOERROR;
    }

};

typedef CComQIPtr<IMSVidAnalogTuner, &__uuidof(IMSVidAnalogTuner)> PQMSVidAnalogTuner;
typedef CComPtr<IMSVidAnalogTuner> PMSVidAnalogTuner;
#endif //__MSVidTVTUNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidtvtuner.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidTVTuner.cpp : Implementation of CMSVidTVTuner
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY



#include "perfcntr.h"
#include "MSVidCtl.h"
#include "MSVidTVTuner.h"
#include <bdamedia.h>
#include "segimpl.h"
#include "segimpl.h"
#include "devices.h"


const ULONG t_SVIDEO = 0;
const ULONG t_COMPOSITE = 1;
const ULONG t_TUNER = 2;
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAnalogTunerDevice, CMSVidTVTuner)

const int DEFAULT_ANALOG_CHANNEL = 4;

typedef CComQIPtr<IMSVidCtl> PQMSVidCtl;
typedef CComQIPtr<IMSVidVideoRenderer> PQMSVidVideoRenderer;

/////////////////////////////////////////////////////////////////////////////
// CMSVidTVTuner

STDMETHODIMP CMSVidTVTuner::Decompose(){
    m_bRouted = false;
    return S_OK;
}

STDMETHODIMP CMSVidTVTuner::ChannelAvailable(LONG nChannel, LONG * SignalStrength, VARIANT_BOOL * fSignalPresent){
    VIDPERF_FUNC; 
    if(!SignalStrength || !fSignalPresent){
        return E_POINTER;
    }
    CComQIPtr<IAMAnalogVideoDecoder> qi_VidDec(m_Filters[m_iCapture]);
    if(qi_VidDec){
        long signal = FALSE;
        HRESULT hr = qi_VidDec->get_HorizontalLocked(&signal);
        if(FAILED(hr)){
            return hr;
        }
        *fSignalPresent = signal ? VARIANT_TRUE:VARIANT_FALSE;
        return NOERROR;
    }
    return E_NOINTERFACE;
}


STDMETHODIMP CMSVidTVTuner::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IMSVidAnalogTuner
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}
STDMETHODIMP CMSVidTVTuner::put_Tune(ITuneRequest *pTR) {
    VIDPERF_FUNC;
    TRACELM(TRACE_DETAIL, "CMSVidTVTuner<>::put_Tune()");
    if (!m_fInit) {
        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidTuner), CO_E_NOTINITIALIZED);
    }
    if (!pTR) {
        return E_POINTER;
    }
    try {
        TNTuneRequest req(pTR);
        ASSERT(req);
        // This whole next section would be nice to check, but due to aux in 
        //   the Tuning Space may change
        /*if (m_TS) {
        // if this tuner has been initialized propertly it will have a tuning space
        // that it handles already specified.  in that case, we should only
        // handle tune requests for our ts
        TNTuningSpace ts(req.TuningSpace());
        if (ts != m_TS) {
        return ImplReportError(__uuidof(T), IDS_INVALID_TS, __uuidof(IMSVidTuner), E_INVALIDARG);
        }
        } else {
        // undone: if dev init is correct this case should never occur
        // return E_UNEXPECTED;
        }
        */
        HRESULT hr = S_OK;
        PQVidCtl pqCtl;
        if(!!m_pContainer){
            hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
            if(FAILED(hr)){
                return hr;
            }
            MSVidCtlStateList curState = STATE_UNBUILT;
            hr = pqCtl->get_State(&curState);
            if(SUCCEEDED(hr) && curState > STATE_STOP){
                hr = DoTune(req);
            }
            else{
                m_bRouted = false;
                hr = NOERROR;
            }
        }
        if (SUCCEEDED(hr)) {
            m_pCurrentTR = req;
            m_pCurrentTR.Clone();
            if (!m_TS) {
                // undone: this is bad.  temporary hack until dev init is correct.
                m_TS = req.TuningSpace();
                m_TS.Clone();
            }
        }
        return hr;
    } catch(...) {
        return E_INVALIDARG;
    }
}
HRESULT CMSVidTVTuner::UpdateTR(TNTuneRequest &tr) {
    TNChannelTuneRequest ctr(tr);

    // If we have not been routed yet, check the current tr first to make sure it is not set
    // if we don't get_Tune wacks the tr currently set
    if(!m_bRouted){
        if(m_pCurrentTR){
            TNChannelTuneRequest curTR(m_pCurrentTR);
            HRESULT hr = ctr->put_Channel(curTR.Channel());
            if (FAILED(hr)) {
                return E_UNEXPECTED;
            }
            return NOERROR;
        }
    }

    long channel;
    PQTVTuner ptv(m_Filters[m_iTuner]);
    long vs, as;
    HRESULT hr = ptv->get_Channel(&channel, &vs, &as);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }
    hr = ctr->put_Channel(channel);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }
    // undone: update the components 

    return NOERROR;
}
HRESULT CMSVidTVTuner::TwiddleXBar(ULONG dwInput){    // For Support for Aux Inputs
    VIDPERF_FUNC;
    if(dwInput < 0 || dwInput > 2){
        return E_INVALIDARG;
    }
    // Set up lists of audio and video types for use in routing data
    int m_iDeMux = -1;
    MediaMajorTypeList VideoTypes;
    MediaMajorTypeList AudioTypes;
    if (!VideoTypes.size()) {
        VideoTypes.push_back(MEDIATYPE_Video);
        VideoTypes.push_back(MEDIATYPE_AnalogVideo);

    }

    if (!AudioTypes.size()) {
        AudioTypes.push_back(MEDIATYPE_Audio);
        AudioTypes.push_back(MEDIATYPE_AnalogAudio);
    }

    // See how far we have to route the audio/video
    PQVidCtl pqCtl;
    if(!!m_pContainer){
        HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
        if(FAILED(hr)){
            return hr;
        }

        PQFeatures fa;
        hr = pqCtl->get_FeaturesActive(&fa);
        if(FAILED(hr)){
            return hr;
        }

        CFeatures* pC = static_cast<CFeatures *>(fa.p);
        DeviceCollection::iterator i;
        for(i = pC->m_Devices.begin(); i != pC->m_Devices.end(); ++i){
            if(VWGraphSegment(*i).ClassID() == CLSID_MSVidEncoder){
                break;
            }
        }

        if(i != pC->m_Devices.end()){
            m_iDeMux = 1;
        }
    }

    // Find the Capture Filter
    DSFilter capFilter (m_Filters[m_iCapture]);
    if(!capFilter){
        return E_FAIL;
    }

    // Get the Crossbar
    DSFilterList::iterator i;
    for(i = m_Filters.begin(); i != m_Filters.end(); ++i){
        if((*i).IsXBar()){
            break;
        }
    }
    if(i == m_Filters.end()){
        return E_FAIL;
    }

    // DSextend helper class
    PQCrossbarSwitch qiXBar((*i));
    if(!qiXBar){
        return E_FAIL;
    }

    // DSExtend does not have all the functions so get the filter as well
    DSFilter bar(qiXBar);
    if(!bar){
        return E_FAIL;
    }

    // Variables for routing audio and video
    DSFilter startFilter;
    DSPin audioStartPin, videoStartPin;
    VWStream vpath;
    VWStream apath;

    // Setup startFilter and startPins if needed
    if(dwInput == t_TUNER){
        PQVidCtl pqCtl;
        HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
        if(FAILED(hr)){
            return hr;
        }

        if(!pqCtl){
            return E_FAIL;
        }

        DSFilter tunerFilter(m_Filters[m_iTuner]);
        if(!tunerFilter){
            return E_FAIL;
        }

        startFilter = tunerFilter;
        if(!tunerFilter){
            _ASSERT(false);
            return E_UNEXPECTED;
        }

    }
    if(dwInput == t_SVIDEO || dwInput == t_COMPOSITE){
        // Route Audio from Audio Line In
        DSPin inAudio;
        DSPin inVideo;
        long inputs, outputs;

        HRESULT hr = qiXBar->get_PinCounts(&outputs, &inputs);
        if(FAILED(hr)){
            return E_FAIL;
        }

        long physConn, audioConn;
        // set up the physical connnecter we are looking for
        if(dwInput == t_SVIDEO){     
            physConn = PhysConn_Video_SVideo;
        }
        else if(dwInput == t_COMPOSITE){
            physConn = PhysConn_Video_Composite;
        }

        // always want line in
        audioConn = PhysConn_Audio_Line;
        long audioIdx = -1;
        long videoIdx = -1;

        // Look through all of the input pins looking for the audio and video input we need 
        for(long n = 0; n <= inputs; ++n){
            long inRelate, inType;
            hr = qiXBar->get_CrossbarPinInfo(TRUE, n, &inRelate, &inType);
            if(FAILED(hr)){
                continue;
            }

            if(inType == physConn){
                videoIdx = n;
            }

            if(inType == audioConn){
                audioIdx = n;
            }
        }
        if(videoIdx == audioIdx || videoIdx == -1 || audioIdx == -1){
            return E_FAIL;
        }

        long idx = -1;

        // Crossbars are wank and dont return pins instead they return indexes so we need to find the pin
        for(DSFilter::iterator foo = bar.begin(); foo != bar.end(); ++foo){
            if((*foo).GetDirection() == PINDIR_INPUT){
                ++idx;
                if(idx == videoIdx){
                    inVideo = (*foo);
                }

                if(idx == audioIdx){
                    inAudio = (*foo);
                }
            }
        }
        if(!inAudio || !inVideo){
            return E_FAIL;
        }
        startFilter = bar;
        audioStartPin = inAudio;
        videoStartPin = inVideo;
        if(!startFilter || !audioStartPin || !videoStartPin){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
    }

    m_pGraph.BuildGraphPath(startFilter, capFilter, vpath, VideoTypes, DOWNSTREAM, videoStartPin);
    // undone: in win64 size() is really __int64.  fix output operator for
    // that type and remove cast
    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::RouteStreams routing video path of size " << (long)vpath.size()), "");
    vpath.Route();

    TRACELM(TRACE_DETAIL, "CVidCtl::RouteStreams finding audio path");

    if(m_iDeMux > 0){
        m_pGraph.BuildGraphPath(startFilter, capFilter, apath, AudioTypes, DOWNSTREAM, audioStartPin);   
        apath.Route();
    }
    else {
        VWGraphSegment::iterator i;
        // there's an analog filter and a digital filter in every audio renderer segment, try both until
        // we find one that's connected.

        CComQIPtr<IMSVidAudioRenderer> audioR;
        pqCtl->get_AudioRendererActive(&audioR);
        VWGraphSegment ar(audioR);
        if(!!ar){
            for (i = ar.begin(); i != ar.end(); ++i) {
                m_pGraph.BuildGraphPath(startFilter, (*i), apath, AudioTypes, DOWNSTREAM, audioStartPin);
                if (apath.size()) {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "Analog tuner Twiddling for audio path of size " << (long)apath.size()), "");
                    apath.Route();
                    break;
                }
            }
        }

    }

    m_bRouted = true;
    return NOERROR;  
}

HRESULT CMSVidTVTuner::DoTune(TNTuneRequest &tr) {
    VIDPERF_FUNC;
    TRACELM(TRACE_DETAIL, "CMSVidTVTuner()::DoTune()");
    // validate that this tuning request is one we can handle
    TNChannelTuneRequest newTR(tr);
    if (!newTR) {
        return Error(IDS_INVALID_TR, __uuidof(IMSVidAnalogTuner), DISP_E_TYPEMISMATCH);
    }

    TNChannelTuneRequest curTR(m_pCurrentTR);
    TNAnalogTVTuningSpace ats;
    ats = newTR.TuningSpace();
    if (!ats) {
        //return Error(IDS_INVALID_TR, __uuidof(IMSVidAnalogTuner), E_INVALIDARG);

        //********************************************************************//
        // MOGUL "FIX":                                                       //
        // Support for Analog Tuners that output mpeg                         //
        //********************************************************************//
        TNAuxInTuningSpace auxts;
        auxts = newTR.TuningSpace();
        if(!auxts){
            return Error(IDS_INVALID_TR, __uuidof(IMSVidAnalogTuner), E_INVALIDARG);
        }

        // if the graph isn't built don't do any more.
        if (m_iTuner == -1) {
            return S_FALSE;
            //Error(IDS_NP_NOT_INIT, __uuidof(IMSVidAnalogTuner), S_FALSE);
        }

        long channel = newTR.Channel();
        // Default is SVideo
        if (channel == -1) {
            channel = t_SVIDEO;
        }        

        // Check to see if the m_pCurrentTR is the same type as the one we are tuning to
        TNAuxInTuningSpace curTS(m_pCurrentTR.TuningSpace());

        if(!m_bRouted || !curTS || !curTR || curTR.Channel() != channel){
            if(channel == t_SVIDEO){
                HRESULT hr = TwiddleXBar(t_SVIDEO); 
            }
            else if(channel == t_COMPOSITE){
                HRESULT hr = TwiddleXBar(t_COMPOSITE); 
            }
            else{
                return Error(IDS_INVALID_TR, __uuidof(IMSVidAnalogTuner), E_INVALIDARG);
            }
        }
        //********************************************************************//
        // END "FIX"                                                          //
        //********************************************************************//        

    }
    else{
        // if the graph isn't built don't do any more.
        if (m_iTuner == -1) {
            return S_FALSE;
            //Error(IDS_NP_NOT_INIT, __uuidof(IMSVidAnalogTuner), S_FALSE);
        }

        PQTVTuner ptv(m_Filters[m_iTuner]);
        if(!ptv){
            return E_NOINTERFACE;
        }

        long channel = newTR.Channel();
        if (channel == -1) {
            channel = DEFAULT_ANALOG_CHANNEL;
        }

        long curChannel = -1;
        if(curTR){
            curChannel = curTR.Channel();
        }

        long curInputType = ats.InputType();
        long curCountryCode = ats.CountryCode();
		TNAnalogTVTuningSpace curTS;
		if(curTR){
			curTS = curTR.TuningSpace();
			if(curTS){
				curInputType = curTS.InputType();
				curCountryCode = curTS.CountryCode();
			}
        }
        bool bXbarTwiddled = false;
        if(!m_bRouted || !curTR || curInputType != ats.InputType() || curCountryCode != ats.CountryCode() || !curTS || curTS != ats){
            HRESULT hr = TwiddleXBar(t_TUNER); 
            if(FAILED(hr)){
                return hr;
            }
            TunerInputType ti = ats.InputType();
            hr = ptv->put_InputType(0, ti);
            if (FAILED(hr)) {
                return Error(IDS_CANT_SET_INPUTTYPE, __uuidof(IMSVidAnalogTuner), E_UNEXPECTED);
            }

            long countrycode = ats.CountryCode();
            hr = ptv->put_CountryCode(countrycode);
            if (FAILED(hr)) {
                return Error(IDS_CANT_SET_COUNTRYCODE, __uuidof(IMSVidAnalogTuner), E_UNEXPECTED);
            }
            bXbarTwiddled = true;
        }

        if(channel != curChannel || bXbarTwiddled){
            // undone: use components to determine subchannel stuff
            HRESULT hr = ptv->put_Channel(channel, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);
            if (FAILED(hr)) {
                return Error(IDS_CANT_SET_CHANNEL, __uuidof(IMSVidAnalogTuner), hr);
            }
        }

    }
    if (!m_pBcast) {
        PQServiceProvider sp(m_pGraph);
        if (!sp) {
            TRACELM(TRACE_ERROR, "CMSVidTVTuner::DoTune() can't get service provider i/f");
            return Error(IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IMSVidAnalogTuner), E_UNEXPECTED);
        }

        HRESULT hr = sp->QueryService(SID_SBroadcastEventService, IID_IBroadcastEvent, reinterpret_cast<LPVOID*>(&m_pBcast));
        if (FAILED(hr) || !m_pBcast) {
            hr = m_pBcast.CoCreateInstance(CLSID_BroadcastEventService, 0, CLSCTX_INPROC_SERVER);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CMSVidTVTuner::DoTune() can't create bcast service");
                return Error(IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IMSVidAnalogTuner), E_UNEXPECTED);
            }

            PQRegisterServiceProvider rsp(m_pGraph);
            if (!rsp) {
                TRACELM(TRACE_ERROR, "CMSVidTVTuner::DoTune() can't get get register service provider i/f");
                return Error(IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IMSVidAnalogTuner), E_UNEXPECTED);
            }

            hr = rsp->RegisterService(SID_SBroadcastEventService, m_pBcast);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidTVTuner::DoTune() can't get register service provider. hr = " << hexdump(hr)), "");
                return Error(IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IMSVidAnalogTuner), E_UNEXPECTED);
            }
        }
    }

    ASSERT(m_pBcast);
    m_pBcast->Fire(EVENTID_TuningChanged);
    return NOERROR;
}

HRESULT CMSVidTVTuner::put_Container(IMSVidGraphSegmentContainer *pCtl)
{
    if (!m_fInit) {
        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
    }
    try {
        CPerfCounter pCounterTuner;
        pCounterTuner.Reset();
        if (!pCtl) {
            return Unload();
        }
        if (m_pContainer) {
            if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
                return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidAnalogTuner), CO_E_ALREADYINITIALIZED);
            } else {
                return NO_ERROR;
            }
        }
        // DON'T addref the container.  we're guaranteed nested lifetimes
        // and an addref creates circular refcounts so we never unload.
        m_pContainer.p = pCtl;
        m_pGraph = m_pContainer.GetGraph();
        DSFilter pTuner(m_pGraph.AddMoniker(m_pDev));
        if (!pTuner) {
            return E_UNEXPECTED;
        }
        m_Filters.push_back(pTuner);
        m_iTuner = 0;
        TRACELM(TRACE_DETAIL, "CMSVidTVTuner::put_Container() tuner added");
        pCounterTuner.Stop();
        TRACELSM(TRACE_ERROR, (dbgDump << "        CVidCtl:: PutContainer TVTuner Filter: " << (unsigned long)(pCounterTuner.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterTuner.GetLastTime() % _100NS_IN_MS) << " ms"), "");
        pCounterTuner.Reset();
        if (!m_pSystemEnum) {
            m_pSystemEnum = PQCreateDevEnum(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
            if (!m_pSystemEnum) {
                return E_UNEXPECTED;
            }
        }
        pCounterTuner.Stop();
        TRACELSM(TRACE_ERROR, (dbgDump << "        CVidCtl:: PutContainer TVTuner SysEnum: " << (unsigned long)(pCounterTuner.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterTuner.GetLastTime() % _100NS_IN_MS) << " ms"), "");
        pCounterTuner.Reset();
        DSDevices CaptureList(m_pSystemEnum, KSCATEGORY_CAPTURE);
        DSDevices::iterator i;
        DSFilter Capture;
        DSFilterList intermediates;
        try {
            ASSERT(m_iTuner > -1);
            for (i = CaptureList.begin(); i != CaptureList.end(); ++i) {
                CString csName;
                Capture = m_pGraph.LoadFilter(*i, csName);
                if (!Capture) {
                    continue;
                }
                TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidTVTuner::put_Container() found not video capture filter = " << csName), "");
                if (!IsVideoFilter(Capture)) {
                    continue;
                }
                TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidTVTuner::put_Container() found video capture filter = " << csName), "");
                HRESULT hr = m_pGraph.AddFilter(Capture, csName);
                if (FAILED(hr)) {
                    continue;
                }
                hr = m_pGraph.Connect(m_Filters[m_iTuner], Capture, intermediates);
                pCounterTuner.Stop();
                TRACELSM(TRACE_ERROR, (dbgDump << "        CVidCtl:: PutContainer Capture Filter: " << (unsigned long)(pCounterTuner.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterTuner.GetLastTime() % _100NS_IN_MS) << " ms"), "");
                pCounterTuner.Reset();
                if (SUCCEEDED(hr)) {
                    break;
                }
                TRACELM(TRACE_DETAIL, "CMSVidTVTuner::put_Container() removing unconnectable capture filter");
                m_pGraph.RemoveFilter(Capture);
            }
            if (i == CaptureList.end()) {
                TRACELM(TRACE_ERROR, "CMSVidTVTuner::put_Container() can't find valid capture");
                return Error(IDS_NO_CAPTURE, __uuidof(IMSVidAnalogTuner), E_NOINTERFACE);
            }
            m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
            m_iTuner = 0;
            ASSERT(m_iTuner > -1);
        } catch(ComException &e) {
            return e;
        }
        m_Filters.push_back(Capture);
        m_iCapture = m_Filters.size() - 1;
        m_iTuner = 0;
        ASSERT(m_iTuner > -1 && m_iCapture > 0 && m_iCapture != m_iTuner);
        TRACELM(TRACE_DETAIL, "CMSVidTVTuner::put_Container() tuner connected");
        pCounterTuner.Stop();
        TRACELSM(TRACE_ERROR, (dbgDump << "        CVidCtl:: PutContainer TVTuner added to list: " << (unsigned long)(pCounterTuner.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterTuner.GetLastTime() % _100NS_IN_MS) << " ms"), "");


        pCounterTuner.Reset();
        HRESULT hr = BroadcastAdvise();
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CMSVidTVTuner::put_Container() can't advise for broadcast events");
            return E_UNEXPECTED;
        }
        TRACELM(TRACE_DETAIL, "CMSVidTVTuner::put_Container() registered for tuning changed events");
        pCounterTuner.Stop();
        TRACELSM(TRACE_ERROR, (dbgDump << "        CVidCtl:: PutContainer Rest : " << (unsigned long)(pCounterTuner.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterTuner.GetLastTime() % _100NS_IN_MS) << " ms"), "");

    } catch (ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
    return NOERROR;
}


HRESULT CMSVidTVTuner::Build() {
    HRESULT hr = put_SAP(VARIANT_FALSE);
    if(FAILED(hr)){
        TRACELM(TRACE_ERROR, "CVidCtl put_sap failed");
        //ASSERT(false);
    }

    PQMSVidCtl pv(m_pContainer);
    if (!pv) {
        return E_UNEXPECTED;
    }

    PQMSVidVideoRenderer pvr;
    hr = pv->get_VideoRendererActive(&pvr);
    if (FAILED(hr) || !pvr) {
        return NOERROR; // video disabled, no vr present
    }

    hr = pvr->put_SourceSize(sslClipByOverScan);
    if (FAILED(hr)) {
        return hr;
    }

    return pvr->put_OverScan(DEFAULT_OVERSCAN_PCT);
}

#endif //TUNING_MODEL_ONLY

// end of file - msvidtvtuner.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidwebdvd.cpp ===
// MSVidWebDVD.cpp : Implementation of CMSVidApp and DLL registration.

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "MSVidCtl.h"
#include "MSVidWebDVD.h"
#include "MSVidDVDAdm.h"
//#include "vidrect.h"
#include <evcode.h>
#include <atltmp.h>

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidWebDVD, CMSVidWebDVD)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidRect, CVidRect)


/*************************************************************************/
/* Local constants and defines                                           */
/*************************************************************************/
const DWORD cdwDVDCtrlFlags = DVD_CMD_FLAG_Block | DVD_CMD_FLAG_Flush;
const DWORD cdwMaxFP_DOMWait = 30000; // 30sec for FP_DOM passing should be OK
const long cgStateTimeout = 0; // wait till the state transition occurs
                               // modify if needed

const long cgDVD_MIN_SUBPICTURE = 0;
const long cgDVD_MAX_SUBPICTURE = 31;
const long cgDVD_ALT_SUBPICTURE = 63;
const long cgDVD_MIN_ANGLE  = 0;
const long cgDVD_MAX_ANGLE = 9;
const double cgdNormalSpeed = 1.00;
const long cgDVDMAX_TITLE_COUNT = 99;
const long cgDVDMIN_TITLE_COUNT = 1;
const long cgDVDMAX_CHAPTER_COUNT = 999;
const long cgDVDMIN_CHAPTER_COUNT = 1;
const LONG cgTIME_STRING_LEN = 2;
const LONG cgMAX_DELIMITER_LEN = 4;
const LONG cgDVD_TIME_STR_LEN = (3*cgMAX_DELIMITER_LEN)+(4*cgTIME_STRING_LEN) + 1 /*NULL Terminator*/;
const long cgVOLUME_MAX = 0;
const long cgVOLUME_MIN = -10000;
const long cgBALANCE_MIN = -10000;
const long cgBALANCE_MAX = 10000;
const WORD cgWAVE_VOLUME_MIN = 0;
const WORD cgWAVE_VOLUME_MAX = 0xffff;

const DWORD cdwTimeout = 10; //100
const long  cgnStepTimeout = 100;

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CMSVidWebDVD::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidWebDVD,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*************************************************************************/
/* Function: AppendString                                                */
/* Description: Appends a string to an existing one.                     */
/*      strDest is MAX_PATH in length
/*************************************************************************/
HRESULT CMSVidWebDVD::AppendString(TCHAR* strDest, INT strID, LONG dwLen){
    if(dwLen < 0){
        return E_INVALIDARG;
    }

    TCHAR strBuffer[MAX_PATH];

    if(!::LoadString(_Module.m_hInstResource, strID, strBuffer, MAX_PATH)){

        return(E_UNEXPECTED);
    }/* end of if statement */

    (void)StringCchCat(strDest, dwLen, strBuffer);

    return(S_OK);
}/* end of function AppendString */

/*************************************************************************/
/* Function: HandleError                                                 */
/* Description: Gets Error Descriptio, so we can suppor IError Info.     */
/*************************************************************************/
HRESULT CMSVidWebDVD::HandleError(HRESULT hr){

    try {

        if(FAILED(hr)){
            switch(hr){

                case E_NO_IDVD2_PRESENT: 
                    Error(IDS_E_NO_IDVD2_PRESENT); 
                    return (hr);
                case E_NO_DVD_VOLUME: 
                    Error(IDS_E_NO_DVD_VOLUME); 
                    return (hr);
                case E_REGION_CHANGE_FAIL: 
                    Error(IDS_E_REGION_CHANGE_FAIL);   
                    return (hr);
                case E_REGION_CHANGE_NOT_COMPLETED: 
                    Error(IDS_E_REGION_CHANGE_NOT_COMPLETED); 
                    return(hr);
            }/* end of switch statement */

#if 0
            TCHAR strError[MAX_ERROR_TEXT_LEN] = TEXT("");

            if(AMGetErrorText(hr , strError , MAX_ERROR_TEXT_LEN)){
                USES_CONVERSION;
                Error(T2W(strError));
            } 
            else 
            {
                ATLTRACE(TEXT("Unhandled Error Code \n")); // please add it
                ATLASSERT(FALSE);
            }/* end of if statement */
#endif
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        // keep the hr same    
    }/* end of catch statement */
    
	return (hr);
}/* end of function HandleError */

/*************************************************************/
/* Name: CleanUp
/* Description: 
/*************************************************************/
HRESULT CMSVidWebDVD::CleanUp(){

    m_pDvdAdmin.Release();
    m_pDvdAdmin = NULL;
    DeleteUrlInfo();

    return NOERROR;
}

/*************************************************************/
/* Name: Init
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::put_Init(IUnknown *pInit)
{
    HRESULT hr = IMSVidGraphSegmentImpl<CMSVidWebDVD, MSVidSEG_SOURCE, &GUID_NULL>::put_Init(pInit);

    if (FAILED(hr)) {
        return hr;
    }
    if (pInit) {
        m_fInit = false;
        return E_NOTIMPL;
    }

    // create an event that lets us know we are past FP_DOM
    m_fResetSpeed = true;
    m_fStillOn = false;
    m_fEnableResetOnStop = false;
    m_fFireNoSubpictureStream = false;
    m_fStepComplete = false;
    m_bEjected = false;
    m_DVDFilterState = dvdState_Undefined;
    m_lKaraokeAudioPresentationMode = 0;

    // Create the DVD administrator
    m_pDvdAdmin = new CComObject<CMSVidWebDVDAdm>;

    return NOERROR;
}

/*************************************************************************/
/* Function: RestoreGraphState                                           */
/* Description: Restores the graph state.  Used when API fails.          */
/*************************************************************************/
HRESULT CMSVidWebDVD::RestoreGraphState(){

    HRESULT hr = S_OK;

    switch(m_DVDFilterState){
        case dvdState_Undefined: 
        case dvdState_Running:  // do not do anything 
            break;

        case dvdState_Unitialized:
        case dvdState_Stopped:  
            hr = Stop(); 
            break;

        case dvdState_Paused: 
            hr = Pause();		      
            break;
    }/* end of switch statement */

    return(hr);
}/* end of if statement */

/*************************************************************************/
/* Function: TwoDigitToByte                                              */
/*************************************************************************/
static BYTE TwoDigitToByte( const WCHAR* pTwoDigit ){

	int tens    = int(pTwoDigit[0] - L'0');
	return BYTE( (pTwoDigit[1] - L'0') + tens*10);
}/* end of function TwoDigitToByte */

/*************************************************************************/
/* Function: Bstr2DVDTime                                                */
/* Description: Converts a DVD Time info from BSTR into a TIMECODE.      */
/*************************************************************************/
HRESULT CMSVidWebDVD::Bstr2DVDTime(DVD_HMSF_TIMECODE *ptrTimeCode, const BSTR *pbstrTime){


    if(NULL == pbstrTime || NULL == ptrTimeCode){

        return E_INVALIDARG;
    }/* end of if statement */

    ::ZeroMemory(ptrTimeCode, sizeof(DVD_HMSF_TIMECODE));
    WCHAR *pszTime = *pbstrTime;

    ULONG lStringLength = wcslen(pszTime);

    if(0 == lStringLength){

        return E_INVALIDARG;
    }/* end of if statement */    
    TCHAR tszTimeSep[5];
    ::GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, tszTimeSep, 5);  
    
    // If the string is two long, it is seconds only
    if(lStringLength == 2){
        ptrTimeCode->bSeconds = TwoDigitToByte( &pszTime[0] );
        return S_OK;
    }

    // Otherwise it is a normal time code of the format
    // 43:32:21:10
    // Where the ':' can be replaced with a localized string of upto 4 char in len
    // There is a possible error case where the length of the delimeter is different
    // then the current delimeter

    if(lStringLength >= (4*cgTIME_STRING_LEN)+(3 * _tcslen(tszTimeSep))){ // longest string nnxnnxnnxnn e.g. 43:23:21:10
                                                                         // where n is a number and 
                                                                         // x is a time delimeter usually ':', but can be any string upto 4 char in len)
        ptrTimeCode->bFrames    = TwoDigitToByte( &pszTime[(3*cgTIME_STRING_LEN)+(3*_tcslen(tszTimeSep))]);
    }

    if(lStringLength >= (3*cgTIME_STRING_LEN)+(2 * _tcslen(tszTimeSep))) { // string nnxnnxnn e.g. 43:23:21
        ptrTimeCode->bSeconds   = TwoDigitToByte( &pszTime[(2*cgTIME_STRING_LEN)+(2*_tcslen(tszTimeSep))] );
    }

    if(lStringLength >= (2*cgTIME_STRING_LEN)+(1 * _tcslen(tszTimeSep))) { // string nnxnn e.g. 43:23
        ptrTimeCode->bMinutes   = TwoDigitToByte( &pszTime[(1*cgTIME_STRING_LEN)+(1*_tcslen(tszTimeSep))] );
    }

    if(lStringLength >= (cgTIME_STRING_LEN)) { // string nn e.g. 43
        ptrTimeCode->bHours   = TwoDigitToByte( &pszTime[0] );
    }
    return (S_OK);
}/* end of function bstr2DVDTime */

/*************************************************************************/
/* Function: DVDTime2bstr                                                */
/* Description: Converts a DVD Time info from ULONG into a BSTR.         */
/*************************************************************************/
HRESULT CMSVidWebDVD::DVDTime2bstr( const DVD_HMSF_TIMECODE *pTimeCode, BSTR *pbstrTime){

    if(NULL == pTimeCode || NULL == pbstrTime) 
        return E_INVALIDARG;

    USES_CONVERSION;

    TCHAR tszTime[cgDVD_TIME_STR_LEN];
    TCHAR tszTimeSep[5];

    ::ZeroMemory(tszTime, sizeof(TCHAR)*cgDVD_TIME_STR_LEN);

    ::GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, tszTimeSep, 5);


    (void)StringCchPrintf( tszTime, cgDVD_TIME_STR_LEN, TEXT("%02lu%s%02lu%s%02lu%s%02lu"), 
                pTimeCode->bHours,   tszTimeSep,
                pTimeCode->bMinutes, tszTimeSep,
                pTimeCode->bSeconds, tszTimeSep,
                pTimeCode->bFrames );
    
    *pbstrTime = SysAllocString(T2OLE(tszTime));
    return (S_OK);
}/* end of function DVDTime2bstr */

/*************************************************************************/
/* Function: PreRun                                                         */
/* Description: called before the filter graph is running                */
/*              set DVD_ResetOnStop to be false                          */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PreRun(){
    
    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */        
            
        // set dvd root directory from url
        // this has to happen before IMediaControl->Run()

        hr = SetDirectoryFromUrlInfo();
        if(FAILED(hr)){
            
            throw(hr);
        }/* end of if statement */
                
        if (!m_pGraph.IsPlaying()) {
            if(FALSE == m_fEnableResetOnStop){
                
                hr = m_pDVDControl2->SetOption(DVD_ResetOnStop, FALSE);
                
                if(FAILED(hr)){
          
                    throw(hr);
                }/* end of if statement */
            }/* end of if statement */

            hr = m_pDVDControl2->SetOption( DVD_HMSF_TimeCodeEvents, TRUE);
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */

        }/* end of if statement */            
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of PreRun */

/*************************************************************************/
/* Function: PostRun                                                     */
/* Description: Puts the filter graph in the running state in case not   */
/*              and reset play speed to normal                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PostRun(){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // save the state so we can restore it if an API fails
        m_DVDFilterState = (DVDFilterState) m_pGraph.GetState();

        bool bFireEvent = false;  // fire event only when we change the state
		
        if(!m_pDVDControl2){
            throw(E_UNEXPECTED);
        }/* end of if statement */        

        if(false == m_fStillOn && true == m_fResetSpeed){
            // if we are in the still do not reset the speed            
            m_pDVDControl2->PlayForwards(cgdNormalSpeed,0,0);
        }/* end of if statement */        

        // set playback references such title/chapter
        // this call will clear urlInfo

        hr = SetPlaybackFromUrlInfo();

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PostRun */

/*************************************************************************/
/* Function: PreStop                                                        */
/* Description: called before the filter graph is stopped                */
/*              set DVD_ResetOnStop to be true                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PreStop(){
    
    HRESULT hr = S_OK;
    
    try {
        
        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }
        
        if (!m_pGraph.IsStopped()) {
            VARIANT_BOOL onStop;
            long dwDomain = 0;
            hr = get_CurrentDomain(&dwDomain);
            if(FAILED(hr)){
                return hr;
            }
            if(dwDomain != DVD_DOMAIN_Stop){
                hr = m_pDvdAdmin->get_BookmarkOnStop(&onStop);
                if(FAILED(hr)){
                    throw(hr);
                }
                
                if(VARIANT_TRUE == onStop){
                    hr = SaveBookmark();
                    if(FAILED(hr)){
                        throw(hr);
                    }
                    
                }
                
                if(FALSE == m_fEnableResetOnStop){
                    
                    hr = m_pDVDControl2->SetOption(DVD_ResetOnStop, TRUE);
                    if(FAILED(hr)){
                        throw(hr);
                    }
                    
                }
            }
        }
    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
}/* end of function PreStop */

/*************************************************************************/
/* Function: PostStop                                                    */
/* Description: Stops the filter graph if the state does not indicate    */
/* it was stopped.                                                       */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PostStop(){
    HRESULT hr = S_OK;

    try {
#if 0
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

		PQVidCtl pvc(m_pContainer);
		MSVidCtlStateList slState;
		HRESULT hr = pvc->get_State(&slState);
        if (SUCCEEDED(hr) && slState != STATE_STOP) {
            hr = pvc->Stop();
            if (FAILED(hr)) {

                throw (hr);
            }/* end of if statement */
        }/* end of if statement */
#endif
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of PostStop */

/*************************************************************************/
/* Function: PlayTitle                                                   */
/* Description: If fails waits for FP_DOM to pass and tries later.       */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayTitle(LONG lTitle){

    HRESULT hr = S_OK;

    try {

        if(0 > lTitle){

            throw(E_INVALIDARG);
        }/* end of if statement */

        long lNumTitles = 0;
        hr = get_TitlesAvailable(&lNumTitles);
        if(FAILED(hr)){
            throw hr;
        }

        if(lTitle > lNumTitles){
            throw E_INVALIDARG;
        }

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayTitle(lTitle, cdwDVDCtrlFlags, 0);
        
        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayTitle */

/*************************************************************************/
/* Function: PlayChapterInTitle                                          */
/* Description: Plays from the specified chapter without stopping        */
/* THIS NEEDS TO BE ENHANCED !!! Current implementation and queing       */
/* into the message loop is insufficient!!! TODO.                        */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayChapterInTitle(LONG lTitle, LONG lChapter){

    HRESULT hr = S_OK;

    try {
        
        if ((lTitle > cgDVDMAX_TITLE_COUNT) || (lTitle < cgDVDMIN_TITLE_COUNT)){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if ((lChapter > cgDVDMAX_CHAPTER_COUNT) || (lChapter < cgDVDMIN_CHAPTER_COUNT)){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayChapterInTitle(lTitle, lChapter, cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayChapterInTitle */

/*************************************************************************/
/* Function: PlayChapter                                                 */
/* Description: Does chapter search. Waits for FP_DOM to pass and initi  */
/* lizes the graph as the other smar routines.                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayChapter(LONG lChapter){

    HRESULT hr = S_OK;

    try {

        if(lChapter < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayChapter(lChapter, cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function PlayChapter */

/*************************************************************************/
/* Function: PlayChapterAutoStop                                         */
/* Description: Plays set ammount of chapters.                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayChaptersAutoStop(LONG lTitle, LONG lChapter, 
                                          LONG lChapterCount){

    HRESULT hr = S_OK;

    try {        

        if ((lTitle > cgDVDMAX_TITLE_COUNT) || (lTitle < cgDVDMIN_TITLE_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        if ((lChapter > cgDVDMAX_CHAPTER_COUNT) || (lChapter < cgDVDMIN_CHAPTER_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        if ((lChapterCount > cgDVDMAX_CHAPTER_COUNT) || (lChapterCount < cgDVDMIN_CHAPTER_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayChaptersAutoStop(lTitle, lChapter, lChapterCount, cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayChaptersAutoStop */

/*************************************************************************/
/* Function: PlayAtTime                                                  */
/* Description: TimeSearch, converts from hh:mm:ss:ff format             */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayAtTime(BSTR strTime){

    HRESULT hr = S_OK;

    try {
        
        if(NULL == strTime){

            throw(E_POINTER);
        }/* end of if statement */
        
        DVD_HMSF_TIMECODE tcTimeCode;
        Bstr2DVDTime(&tcTimeCode, &strTime);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayAtTime( &tcTimeCode, cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayAtTime */

/*************************************************************************/
/* Function: PlayAtTimeInTitle                                           */
/* Description: Time plays, converts from hh:mm:ss:ff format             */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayAtTimeInTitle(long lTitle, BSTR strTime){

    HRESULT hr = S_OK;

    try {        
        if(NULL == strTime){

            throw(E_POINTER);
        }/* end of if statement */
        
        DVD_HMSF_TIMECODE tcTimeCode;
        hr = Bstr2DVDTime(&tcTimeCode, &strTime);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayAtTimeInTitle(lTitle, &tcTimeCode, cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayAtTimeInTitle */

/*************************************************************************/
/* Function: PlayPeriodInTitleAutoStop                                   */
/* Description: Time plays, converts from hh:mm:ss:ff format             */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayPeriodInTitleAutoStop(long lTitle, 
                                                  BSTR strStartTime, BSTR strEndTime){

    HRESULT hr = S_OK;

    try {        
        if(NULL == strStartTime){

            throw(E_POINTER);
        }/* end of if statement */

        if(NULL == strEndTime){

            throw(E_POINTER);
        }/* end of if statement */
        
        DVD_HMSF_TIMECODE tcStartTimeCode;
        hr = Bstr2DVDTime(&tcStartTimeCode, &strStartTime);

        if(FAILED(hr)){

            throw (hr);
        }

        DVD_HMSF_TIMECODE tcEndTimeCode;

        Bstr2DVDTime(&tcEndTimeCode, &strEndTime);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayPeriodInTitleAutoStop(lTitle, &tcStartTimeCode,
            &tcEndTimeCode,  cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayPeriodInTitleAutoStop */

/*************************************************************************/
/* Function: ReplayChapter                                               */
/* Description: Halts playback and restarts the playback of current      */
/* program inside PGC.                                                   */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::ReplayChapter(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->ReplayChapter(cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function ReplayChapter */

/*************************************************************************/
/* Function: PlayPrevChapter                                             */
/* Description: Goes to previous chapter                                 */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayPrevChapter(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayPrevChapter(cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function PlayPrevChapter */

/*************************************************************************/
/* Function: PlayNextChapter                                             */
/* Description: Goes to next chapter                                     */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayNextChapter(){

    HRESULT hr = S_OK;
    CComQIPtr<IDvdCmd>IDCmd;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayNextChapter(cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function PlayNextChapter */


/*************************************************************************/
/* Function: StillOff                                                    */
/* Description: Turns the still off, what that can be used for is a      */
/* mistery to me.                                                        */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::StillOff(){

    if(!m_pDVDControl2){
        
        throw(E_UNEXPECTED);
    }/* end of if statement */                
    
    return HandleError(m_pDVDControl2->StillOff());
}/* end of function StillOff */

/*************************************************************************/
/* Function: GetAudioLanguage                                            */
/* Description: Returns audio language associated with a stream.         */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_AudioLanguage(LONG lStream, VARIANT_BOOL fFormat, BSTR *strAudioLang){

    HRESULT hr = S_OK;
    LPTSTR pszString = NULL;

    try {
        if(NULL == strAudioLang){

            throw(E_POINTER);
        }/* end of if statement */

        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        USES_CONVERSION;
        LCID lcid = _UI32_MAX;
                
        hr = pDvdInfo2->GetAudioLanguage(lStream, &lcid);
    
        if (SUCCEEDED( hr ) && lcid < _UI32_MAX){

            // count up the streams for the same LCID like English 2
            
            pszString = m_LangID.GetLanguageFromLCID(PRIMARYLANGID(LANGIDFROMLCID(lcid)));
            if (pszString == NULL) {
                
                pszString = new TCHAR[MAX_PATH];
                TCHAR strBuffer[MAX_PATH];
                if(!::LoadString(_Module.m_hInstResource, IDS_DVD_AUDIOTRACK, strBuffer, MAX_PATH)){
                    delete[] pszString;
                    throw(E_UNEXPECTED);
                }/* end of if statement */

                (void)StringCchPrintf(pszString, MAX_PATH, strBuffer, lStream);
            }/* end of if statement */

            DVD_AudioAttributes attr;
            if(SUCCEEDED(pDvdInfo2->GetAudioAttributes(lStream, &attr))){
                
                // If want audio format param is set
                if (fFormat != VARIANT_FALSE) {
                    switch(attr.AudioFormat){
                    case DVD_AudioFormat_AC3: AppendString(pszString, IDS_DVD_DOLBY, MAX_PATH ); break; 
                    case DVD_AudioFormat_MPEG1: AppendString(pszString, IDS_DVD_MPEG1, MAX_PATH ); break;
                    case DVD_AudioFormat_MPEG1_DRC: AppendString(pszString, IDS_DVD_MPEG1, MAX_PATH ); break;
                    case DVD_AudioFormat_MPEG2: AppendString(pszString, IDS_DVD_MPEG2, MAX_PATH ); break;
                    case DVD_AudioFormat_MPEG2_DRC: AppendString(pszString, IDS_DVD_MPEG2, MAX_PATH); break;
                    case DVD_AudioFormat_LPCM: AppendString(pszString, IDS_DVD_LPCM, MAX_PATH ); break;
                    case DVD_AudioFormat_DTS: AppendString(pszString, IDS_DVD_DTS, MAX_PATH ); break;
                    case DVD_AudioFormat_SDDS: AppendString(pszString, IDS_DVD_SDDS, MAX_PATH ); break;
                    }/* end of switch statement */                    
                }

                switch(attr.LanguageExtension){
                case DVD_AUD_EXT_NotSpecified:
                case DVD_AUD_EXT_Captions:     break; // do not add anything
                case DVD_AUD_EXT_VisuallyImpaired:   AppendString(pszString, IDS_DVD_AUDIO_VISUALLY_IMPAIRED, MAX_PATH ); break;      
                case DVD_AUD_EXT_DirectorComments1:  AppendString(pszString, IDS_DVD_AUDIO_DIRC1, MAX_PATH ); break;
                case DVD_AUD_EXT_DirectorComments2:  AppendString(pszString, IDS_DVD_AUDIO_DIRC2, MAX_PATH ); break;
                }/* end of switch statement */

            }/* end of if statement */

            *strAudioLang = ::SysAllocString( T2W(pszString) );
            delete[] pszString;
            pszString = NULL;
        }
        else {

            *strAudioLang = ::SysAllocString( L"");

            // hr used to be not failed and return nothing 
            if(SUCCEEDED(hr)) // remove this after gets fixed in DVDNav
                hr = E_FAIL;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetAudioLanguage */

/*************************************************************************/
/* Function: ShowMenu                                                    */
/* Description: Invokes specific menu call.                              */
/* We set our selfs to play mode so we can execute this in case we were  */
/* paused or stopped.                                                    */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::ShowMenu(DVDMenuIDConstants MenuID){
    HRESULT hr = S_OK;

    try {

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDVDControl2->ShowMenu((tagDVD_MENU_ID)MenuID, cdwDVDCtrlFlags, 0)); //!!keep in sync, or this cast will not work
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}

/*************************************************************************/
/* Function: Resume                                                      */
/* Description: Resume from menu. We put our self in play state, just    */
/* in the case we were not in it. This might lead to some unexpected     */
/* behavior in case when we stopped and the tried to hit this button     */
/* but I think in this case might be appropriate as well.                */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::Resume(){
    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                

        hr = m_pDVDControl2->Resume(cdwDVDCtrlFlags, 0);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function Resume */

/*************************************************************************/
/* Function: ReturnFromSubmenu                                                      */
/* Description: Used in menu to return into prevoius menu.               */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::ReturnFromSubmenu(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
            
        RETRY_IF_IN_FPDOM(m_pDVDControl2->ReturnFromSubmenu(cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function Return */

/*************************************************************************/
/* Function: get_ButtonsAvailable                                        */
/* Description: Gets the count of the available buttons.                 */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_ButtonsAvailable(long *plNumButtons){

    HRESULT hr = S_OK;

    try {
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulCurrentButton = 0L;

        hr = pDvdInfo2->GetCurrentButton((ULONG*)plNumButtons, &ulCurrentButton);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_ButtonsAvailable */

/*************************************************************************/
/* Function: get_CurrentButton                                           */
/* Description: Gets currently selected button.                          */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentButton(long *plCurrentButton){

    HRESULT hr = S_OK;

    try {
        if(NULL == plCurrentButton){

            throw(E_POINTER);
        }/* end of if statement */            

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulNumButtons = 0L;
        *plCurrentButton = 0;

        hr = pDvdInfo2->GetCurrentButton(&ulNumButtons, (ULONG*)plCurrentButton);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_CurrentButton */

/*************************************************************************/
/* Function: SelectUpperButton                                           */
/* Description: Selects the upper button on DVD Menu.                    */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectUpperButton(){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Upper);        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectUpperButton */

/*************************************************************************/
/* Function: SelectLowerButton                                           */
/* Description: Selects the lower button on DVD Menu.                    */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectLowerButton(){

	HRESULT hr = S_OK;

    try {
        
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Lower);                
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectLowerButton */

/*************************************************************************/
/* Function: SelectLeftButton                                            */
/* Description: Selects the left button on DVD Menu.                     */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectLeftButton(){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Left);                
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectLeftButton */

/*************************************************************************/
/* Function: SelectRightButton                                           */
/* Description: Selects the right button on DVD Menu.                    */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectRightButton(){

	HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Right);        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return  HandleError(hr);
}/* end of function SelectRightButton */

/*************************************************************************/
/* Function: ActivateButton                                              */
/* Description: Activates the selected button on DVD Menu.               */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::ActivateButton(){

	HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->ActivateButton();
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function ActivateButton */

/*************************************************************************/
/* Function: SelectAndActivateButton                                     */
/* Description: Selects and activates the specific button.               */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectAndActivateButton(long lButton){

    HRESULT hr = S_OK;

    try {

        if(lButton < 0){
            
            throw(E_INVALIDARG);        
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectAndActivateButton((ULONG)lButton);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectAndActivateButton */

/*************************************************************************/
/* Function: TransformToWndwls                                           */
/* Description: Transforms the coordinates to screen onse.               */
/*************************************************************************/
HRESULT CMSVidWebDVD::TransformToWndwls(POINT& pt){

    HRESULT hr = S_FALSE;
#if 0
    // we are windowless we need to map the points to screen coordinates
    if(m_bWndLess){

        HWND hwnd = NULL;

        hr = GetParentHWND(&hwnd);

        if(FAILED(hr)){

            return(hr);
        }/* end of if statement */

        if(!::IsWindow(hwnd)){

            hr = E_UNEXPECTED;
            return(hr);
        }/* end of if statement */

        ::MapWindowPoints(hwnd, ::GetDesktopWindow(), &pt, 1);

        hr = S_OK;

    }/* end of if statement */
#endif
    return(hr);
}/* end of function TransformToWndwls */

/*************************************************************************/
/* Function: ActivateAtPosition                                          */
/* Description: Activates a button at selected position.                 */ 
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::ActivateAtPosition(long xPos, long yPos){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        POINT pt = {xPos, yPos};

        hr = TransformToWndwls(pt);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = m_pDVDControl2->ActivateAtPosition(pt);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function ActivateAtPosition */

/*************************************************************************/
/* Function: SelectAtPosition                                            */
/* Description: Selects a button at selected position.                   */ 
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectAtPosition(long xPos, long yPos){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        POINT pt = {xPos, yPos};

        hr = TransformToWndwls(pt);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        hr = m_pDVDControl2->SelectAtPosition(pt);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SelectAtPosition */

/*************************************************************************/
/* Function: GetButtonAtPosition                                         */
/* Description: Gets the button number associated with a position.       */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_ButtonAtPosition(long xPos, long yPos, 
                                              long *plButton)
{
	HRESULT hr = S_OK;

    try {
		if(!plButton){
			return E_POINTER;
		}
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        POINT pt = {xPos, yPos};

        hr = TransformToWndwls(pt);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        ULONG ulButton;
        hr = pDvdInfo2->GetButtonAtPosition(pt, &ulButton);

        if(SUCCEEDED(hr)){
            *plButton = ulButton;
        } 
        else {
            plButton = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetButtonAtPosition */

/*************************************************************************/
/* Function: GetNumberChapterOfChapters                                  */
/* Description: Returns the number of chapters in title.                 */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_NumberOfChapters(long lTitle, long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = pDvdInfo2->GetNumberOfChapters(lTitle, (ULONG*)pVal);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function GetNumberChapterOfChapters */

/*************************************************************************/
/* Function: get_TitlesAvailable                                         */
/* Description: Gets the number of titles.                               */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_TitlesAvailable(long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG NumOfVol;
        ULONG ThisVolNum;
        DVD_DISC_SIDE Side;
        ULONG TitleCount;

        hr = pDvdInfo2->GetDVDVolumeInfo(&NumOfVol, &ThisVolNum, &Side, &TitleCount);

        *pVal = (LONG) TitleCount;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function get_TitlesAvailable */

/*************************************************************************/
/* Function: get_TotalTitleTime                                          */
/* Description: Gets total time in the title.                            */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_TotalTitleTime(BSTR *pTime){

    HRESULT hr = S_OK;

    try {
        if(NULL == pTime){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_HMSF_TIMECODE tcTime;
        ULONG ulFlags;	// contains 30fps/25fps
        hr =  pDvdInfo2->GetTotalTitleTime(&tcTime, &ulFlags);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        hr = DVDTime2bstr(&tcTime, pTime);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_TotalTitleTime */ 

/*************************************************************************/
/* Function: get_VolumesAvailable                                        */
/* Description: Gets total number of volumes available.                  */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_VolumesAvailable(long *plNumOfVol){

    HRESULT hr = S_OK;

    try {    	
    
        if(NULL == plNumOfVol){

            throw(E_POINTER);
        }/* end of if statement */

        ULONG ulThisVolNum;
        DVD_DISC_SIDE discSide;
        ULONG ulNumOfTitles;

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = pDvdInfo2->GetDVDVolumeInfo( (ULONG*)plNumOfVol, 
            &ulThisVolNum, 
            &discSide, 
            &ulNumOfTitles);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_VolumesAvailable */

/*************************************************************************/
/* Function: get_CurrentVolume                                           */
/* Description: Gets current volume.                                     */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentVolume(long *plVolume){

    HRESULT hr = S_OK;

    try {    	
        if(NULL == plVolume){

            throw(E_POINTER);
        }/* end of if statement */

        ULONG ulNumOfVol;
        DVD_DISC_SIDE discSide;
        ULONG ulNumOfTitles;

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = pDvdInfo2->GetDVDVolumeInfo( &ulNumOfVol, 
            (ULONG*)plVolume, 
            &discSide, 
            &ulNumOfTitles);
	}/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_CurrentVolume */

/*************************************************************************/
/* Function: get_CurrentDiscSide                                         */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentDiscSide(long *plDiscSide){

    HRESULT hr = S_OK;

    try {    	

        if(NULL == plDiscSide){

            throw(E_POINTER);
        }/* end of if statement */
        
        ULONG ulNumOfVol;
        ULONG ulThisVolNum;
        DVD_DISC_SIDE discSide;
        ULONG ulNumOfTitles;

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = pDvdInfo2->GetDVDVolumeInfo( &ulNumOfVol, 
            &ulThisVolNum, 
            &discSide, 
            &ulNumOfTitles);
        *plDiscSide = discSide;
	}/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_CurrentDiscSide */

/*************************************************************************/
/* Function: get_CurrentDomain                                           */
/* Description: gets current DVD domain.                                 */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentDomain(long *plDomain){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(NULL == plDomain){

            throw(E_POINTER);
        }/* end of if statememt */

        hr = pDvdInfo2->GetCurrentDomain((DVD_DOMAIN *)plDomain);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_CurrentDomain */

/*************************************************************************/
/* Function: get_CurrentChapter                                          */
/* Description: Gets current chapter                                     */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentChapter(long *pVal){

    HRESULT hr = S_OK;

    try {        
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_PLAYBACK_LOCATION2 dvdLocation;

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentLocation(&dvdLocation));

        if(SUCCEEDED(hr)){

            *pVal = dvdLocation.ChapterNum;
        }
        else {

            *pVal = 0;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function get_CurrentChapter */

/*************************************************************************/
/* Function: get_CurrentTitle                                            */
/* Description: Gets current title.                                      */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentTitle(long *pVal){

    HRESULT hr = S_OK;

    try {        
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_PLAYBACK_LOCATION2 dvdLocation;

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentLocation(&dvdLocation));

        if(SUCCEEDED(hr)){

            *pVal = dvdLocation.TitleNum;
        }
        else {

            *pVal = 0;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function get_CurrentTitle */

/*************************************************************************/
/* Function: get_CurrentTime                                             */
/* Description: Gets current time.                                       */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentTime(BSTR *pVal){

    HRESULT hr = S_OK;

    try {       
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_PLAYBACK_LOCATION2 dvdLocation;

        hr = pDvdInfo2->GetCurrentLocation(&dvdLocation);
        
        DVDTime2bstr(&(dvdLocation.TimeCode), pVal);          
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CurrentTime */

/*************************************************************/
/* Name: DVDTimeCode2bstr
/* Description: returns time string for HMSF timecode
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::DVDTimeCode2bstr(/*[in]*/ long timeCode, /*[out, retval]*/ BSTR *pTimeStr){
    return DVDTime2bstr((DVD_HMSF_TIMECODE*)&timeCode, pTimeStr);
}

/*************************************************************************/
/* Function: get_DVDDirectory                                            */
/* Description: Gets the root of the DVD drive.                          */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDDirectory(BSTR *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   
    
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        WCHAR szRoot[MAX_PATH];
        ULONG ulActual;

        hr = pDvdInfo2->GetDVDDirectory(szRoot, MAX_PATH, &ulActual);

        *pVal = ::SysAllocString(szRoot);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function get_DVDDirectory */

/*************************************************************************/
/* Function: put_DVDDirectory                                            */
/* Description: Sets the root for DVD control.                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::put_DVDDirectory(BSTR bstrRoot){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   
    
        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SetDVDDirectory(bstrRoot);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function put_DVDDirectory */

/*************************************************************/
/* Name: IsSubpictureStreamEnabled
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::IsSubpictureStreamEnabled(long lStream, VARIANT_BOOL *fEnabled)
{
    HRESULT hr = S_OK;

    try {
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (fEnabled == NULL) {

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        BOOL temp;
        hr = pDvdInfo2->IsSubpictureStreamEnabled(lStream, &temp);
        if (FAILED(hr))
            throw hr;

        *fEnabled = temp==FALSE? VARIANT_FALSE:VARIANT_TRUE;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}

/*************************************************************/
/* Name: IsAudioStreamEnabled
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::IsAudioStreamEnabled(long lStream, VARIANT_BOOL *fEnabled)
{
    HRESULT hr = S_OK;

    try {
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (fEnabled == NULL) {

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        BOOL temp;
        hr = pDvdInfo2->IsAudioStreamEnabled(lStream, &temp);
        if (FAILED(hr))
            throw hr;

        *fEnabled = temp==FALSE? VARIANT_FALSE:VARIANT_TRUE;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}

/*************************************************************************/
/* Function: get_CurrentSubpictureStream                                 */
/* Description: Gets the current subpicture stream.                      */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentSubpictureStream(long *plSubpictureStream){

    HRESULT hr = S_OK;

    try {
        
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulStreamsAvailable = 0L;
        BOOL  bIsDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentSubpicture(&ulStreamsAvailable, (ULONG*)plSubpictureStream, &bIsDisabled ));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function get_CurrentSubpictureStream */

/*************************************************************************/
/* Function: put_CurrentSubpictureStream                                 */
/* Description: Sets the current subpicture stream.                      */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::put_CurrentSubpictureStream(long lSubpictureStream){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if( lSubpictureStream < cgDVD_MIN_SUBPICTURE 
            || (lSubpictureStream > cgDVD_MAX_SUBPICTURE 
            && lSubpictureStream != cgDVD_ALT_SUBPICTURE)){

            throw(E_INVALIDARG);
        }/* end of if statement */
         
        RETRY_IF_IN_FPDOM(m_pDVDControl2->SelectSubpictureStream(lSubpictureStream,0,0));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // now enabled the subpicture stream if it is not enabled
        ULONG ulStraemsAvial = 0L, ulCurrentStrean = 0L;
        BOOL fDisabled = TRUE;
        hr = pDvdInfo2->GetCurrentSubpicture(&ulStraemsAvial, &ulCurrentStrean, &fDisabled);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(TRUE == fDisabled){

            hr = m_pDVDControl2->SetSubpictureState(TRUE,0,0); //turn it on
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function put_CurrentSubpictureStream */

/*************************************************************************/
/* Function: get_SubpictureOn                                            */
/* Description: Gets the current subpicture status On or Off             */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_SubpictureOn(VARIANT_BOOL *pfDisplay){

    HRESULT hr = S_OK;

    try {
        
        if(NULL == pfDisplay){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
    
        ULONG ulSubpictureStream = 0L, ulStreamsAvailable = 0L;
        BOOL fDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentSubpicture(&ulStreamsAvailable, &ulSubpictureStream, &fDisabled))
    
        if(SUCCEEDED(hr)){

            *pfDisplay = fDisabled == FALSE ? VARIANT_TRUE : VARIANT_FALSE; // compensate for -1 true in OLE
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function get_SubpictureOn */

/*************************************************************************/
/* Function: put_SubpictureOn                                            */
/* Description: Turns the subpicture On or Off                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::put_SubpictureOn(VARIANT_BOOL fDisplay){

    HRESULT hr = S_OK;

    try {
        
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulSubpictureStream = 0L, ulStreamsAvailable = 0L;
        BOOL  bIsDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentSubpicture(&ulStreamsAvailable, &ulSubpictureStream, &bIsDisabled ));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        BOOL bDisplay = fDisplay == VARIANT_FALSE ? FALSE : TRUE; // compensate for -1 true in OLE

        hr = m_pDVDControl2->SetSubpictureState(bDisplay,0,0);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function put_SubpictureOn */

/*************************************************************************/
/* Function: get_SubpictureStreamsAvailable                              */
/* Description: gets the number of streams available.                    */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_SubpictureStreamsAvailable(long *plStreamsAvailable){

    HRESULT hr = S_OK;

    try {
	    
        if (NULL == plStreamsAvailable){

            throw(E_POINTER);         
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulSubpictureStream = 0L;
        *plStreamsAvailable = 0L;
        BOOL  bIsDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentSubpicture((ULONG*)plStreamsAvailable, &ulSubpictureStream, &bIsDisabled));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function get_SubpictureStreamsAvailable */

/*************************************************************************/
/* Function: GetSubpictureLanguage                                       */
/* Description: Gets subpicture language.                                */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_SubpictureLanguage(LONG lStream, BSTR* strSubpictLang){

    HRESULT hr = S_OK;
    LPTSTR pszString = NULL;

    try {
        if(NULL == strSubpictLang){

            throw(E_POINTER);
        }/* end of if statement */

        if(0 > lStream){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if((lStream > cgDVD_MAX_SUBPICTURE 
            && lStream != cgDVD_ALT_SUBPICTURE)){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        LCID lcid = _UI32_MAX;

        hr = pDvdInfo2->GetSubpictureLanguage(lStream, &lcid);
        
        if (SUCCEEDED( hr ) && lcid < _UI32_MAX){

            pszString = m_LangID.GetLanguageFromLCID(lcid);
            if (pszString == NULL) {
                
                pszString = new TCHAR[MAX_PATH];
                TCHAR strBuffer[MAX_PATH];
                if(!::LoadString(_Module.m_hInstResource, IDS_DVD_SUBPICTURETRACK, strBuffer, MAX_PATH)){
                    delete[] pszString;
                    throw(E_UNEXPECTED);
                }/* end of if statement */

                (void)StringCchPrintf(pszString, MAX_PATH, strBuffer, lStream);
            }/* end of if statement */
#if 0
            DVD_SubpictureAttributes attr;            
            if(SUCCEEDED(pDvdInfo2->GetSubpictureAttributes(lStream, &attr))){
                
                switch(attr.LanguageExtension){
                    case DVD_SP_EXT_NotSpecified:
                    case DVD_SP_EXT_Caption_Normal:  break;
                    
                    case DVD_SP_EXT_Caption_Big:  AppendString(pszString, IDS_DVD_CAPTION_BIG, MAX_PATH ); break; 
                    case DVD_SP_EXT_Caption_Children: AppendString(pszString, IDS_DVD_CAPTION_CHILDREN, MAX_PATH ); break; 
                    case DVD_SP_EXT_CC_Normal: AppendString(pszString, IDS_DVD_CLOSED_CAPTION, MAX_PATH ); break;                 
                    case DVD_SP_EXT_CC_Big: AppendString(pszString, IDS_DVD_CLOSED_CAPTION_BIG, MAX_PATH ); break; 
                    case DVD_SP_EXT_CC_Children: AppendString(pszString, IDS_DVD_CLOSED_CAPTION_CHILDREN, MAX_PATH ); break; 
                    case DVD_SP_EXT_Forced: AppendString(pszString, IDS_DVD_CLOSED_CAPTION_FORCED, MAX_PATH ); break; 
                    case DVD_SP_EXT_DirectorComments_Normal: AppendString(pszString, IDS_DVD_DIRS_COMMNETS, MAX_PATH ); break; 
                    case DVD_SP_EXT_DirectorComments_Big: AppendString(pszString, IDS_DVD_DIRS_COMMNETS_BIG, MAX_PATH ); break; 
                    case DVD_SP_EXT_DirectorComments_Children: AppendString(pszString, IDS_DVD_DIRS_COMMNETS_CHILDREN, MAX_PATH ); break; 
                }/* end of switch statement */
            }/* end of if statement */
#endif

            USES_CONVERSION;
            *strSubpictLang = ::SysAllocString( T2W(pszString) );
            delete[] pszString;
            pszString = NULL;
        }
        else {

            *strSubpictLang = ::SysAllocString( L"");

            // hr used to be not failed and return nothing 
            if(SUCCEEDED(hr)) // remove this after gets fixed in DVDNav
                hr = E_FAIL;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetSubpictureLanguage */

/*************************************************************************/
/* Function: get_AudioStreamsAvailable                                   */
/* Description: Gets number of available Audio Streams                   */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_AudioStreamsAvailable(long *plNumAudioStreams){

    HRESULT hr = S_OK;

    try {
        
        if(NULL == plNumAudioStreams){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulCurrentStream;

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentAudio((ULONG*)plNumAudioStreams, &ulCurrentStream));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_AudioStreamsAvailable */

/*************************************************************************/
/* Function: get_CurrentAudioStream                                      */
/* Description: Gets current audio stream.                               */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentAudioStream(long *plCurrentStream){

    HRESULT hr = S_OK;

    try {
        
        if(NULL == plCurrentStream){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulNumAudioStreams;

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentAudio(&ulNumAudioStreams, (ULONG*)plCurrentStream ));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CurrentAudioStream */

/*************************************************************************/
/* Function: put_CurrentAudioStream                                      */
/* Description: Changes the current audio stream.                        */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::put_CurrentAudioStream(long lAudioStream){

    HRESULT hr = S_OK;

    try {
        
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDVDControl2->SelectAudioStream(lAudioStream,0,0));            
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_CurrentAudioStream */

/*************************************************************************/
/* Function: get_CurrentAngle                                            */
/* Description: Gets current angle.                                      */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentAngle(long *plAngle){

    HRESULT hr = S_OK;

    try {
        if(NULL == plAngle){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulAnglesAvailable = 0;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentAngle(&ulAnglesAvailable, (ULONG*)plAngle));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CurrentAngle */

/*************************************************************************/
/* Function: put_CurrentAngle                                            */
/* Description: Sets the current angle (different DVD angle track.)      */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::put_CurrentAngle(long lAngle){

    HRESULT hr = S_OK;

    try {
        if( lAngle < cgDVD_MIN_ANGLE || lAngle > cgDVD_MAX_ANGLE ){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
      
        RETRY_IF_IN_FPDOM(m_pDVDControl2->SelectAngle(lAngle,0,0));          
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_CurrentAngle */

/*************************************************************************/
/* Function: get_AnglesAvailable                                         */
/* Description: Gets the number of angles available.                     */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_AnglesAvailable(long *plAnglesAvailable){

    HRESULT hr = S_OK;

    try {
        if(NULL == plAnglesAvailable){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulCurrentAngle = 0;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentAngle((ULONG*)plAnglesAvailable, &ulCurrentAngle));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_AnglesAvailable */

/*************************************************************************/
/* Function: get_DVDUniqueID                                             */
/* Description: Gets the UNIQUE ID that identifies the string.           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDUniqueID(BSTR *pStrID){

    HRESULT hr = E_FAIL;

    try {
        // TODO: Be able to get m_pDvdInfo2 without initializing the graph
	    if (NULL == pStrID){

            throw(E_POINTER);         
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONGLONG ullUniqueID;

        hr = pDvdInfo2->GetDiscID(NULL, &ullUniqueID);
                                 
        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        //TODO: Get rid of the STDLIB call!!
        // taken out of WMP

        // Script can't handle a 64 bit value so convert it to a string.
        // Doc's say _ui64tow returns 33 bytes (chars?) max.
        // we'll use double that just in case...
        //
        WCHAR wszBuffer[66];
        _ui64tow( ullUniqueID, wszBuffer, 10);
        *pStrID = SysAllocString(wszBuffer);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_DVDUniqueID */

/*************************************************************************/
/* Function: AcceptParentalLevelChange                                   */
/* Description: Accepts the temprary parental level change that is       */
/* done on the fly.                                                      */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::AcceptParentalLevelChange(VARIANT_BOOL fAccept, BSTR strUserName, BSTR strPassword){

    // Comfirm password first 
    if (m_pDvdAdmin == NULL) {

        throw(E_UNEXPECTED);
    } /* end of if statement */

    VARIANT_BOOL fRight;
    HRESULT hr = m_pDvdAdmin->ConfirmPassword(NULL, strPassword, &fRight);

    // if password is wrong and want to accept, no 
    if (fAccept != VARIANT_FALSE && fRight == VARIANT_FALSE)
        return E_ACCESSDENIED;

    try {  
        // should not make sense to do initialization here, since this should
        // be a response to a callback
        //INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        hr = m_pDVDControl2->AcceptParentalLevelChange(VARIANT_FALSE == fAccept? FALSE : TRUE);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function AcceptParentalLevelChange */

/*************************************************************************/
/* Function: put_NotifyParentalLevelChange                               */
/* Description: Sets the flag if to notify when parental level change    */
/* notification is required on the fly.                                  */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::NotifyParentalLevelChange(VARIANT_BOOL fNotify){

	HRESULT hr = S_OK;

    try {
        //TODO: Add IE parantal level control
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        hr = m_pDVDControl2->SetOption(DVD_NotifyParentalLevelChange,
                          VARIANT_FALSE == fNotify? FALSE : TRUE);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function NotifyParentalLevelChange */

/*************************************************************************/
/* Function: SelectParentalCountry                                       */
/* Description: Selects Parental Country.                                */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectParentalCountry(long lCountry, BSTR strUserName, BSTR strPassword){

    HRESULT hr = S_OK;

    try {

        if(lCountry < 0 && lCountry > 0xffff){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // Confirm password first
        if (m_pDvdAdmin == NULL) {

            throw(E_UNEXPECTED);
        }/* end of if statement */

        VARIANT_BOOL temp;
        hr = m_pDvdAdmin->ConfirmPassword(NULL, strPassword, &temp);
        if (temp == VARIANT_FALSE)
            throw (E_ACCESSDENIED);

        hr = SelectParentalCountry(lCountry);

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}

/*************************************************************************/
/* Function: SelectParentalCountry                                       */
/* Description: Selects Parental Country.                                */
/*************************************************************************/
HRESULT CMSVidWebDVD::SelectParentalCountry(long lCountry){

    HRESULT hr = S_OK;
    try {

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        BYTE bCountryCode[2];

        bCountryCode[0] = BYTE(lCountry>>8);
        bCountryCode[1] = BYTE(lCountry);

        hr = m_pDVDControl2->SelectParentalCountry(bCountryCode);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SelectParentalCountry */

/*************************************************************************/
/* Function: SelectParentalLevel                                         */
/* Description: Selects the parental level.                              */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectParentalLevel(long lParentalLevel, BSTR strUserName, BSTR strPassword){

    HRESULT hr = S_OK;

    try {

        if (lParentalLevel != PARENTAL_LEVEL_DISABLED && 
           (lParentalLevel < 1 || lParentalLevel > 8)) {

            throw (E_INVALIDARG);
        } /* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // Confirm password first
        if (m_pDvdAdmin == NULL) {

            throw(E_UNEXPECTED);
        } /* end of if statement */

        VARIANT_BOOL temp;
        hr = m_pDvdAdmin->ConfirmPassword(NULL, strPassword, &temp);
        if (temp == VARIANT_FALSE)
            throw (E_ACCESSDENIED);
    
        hr = SelectParentalLevel(lParentalLevel);

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}

/*************************************************************************/
/* Function: SelectParentalLevel                                         */
/* Description: Selects the parental level.                              */
/*************************************************************************/
HRESULT CMSVidWebDVD::SelectParentalLevel(long lParentalLevel){

    HRESULT hr = S_OK;
    try {

        //INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        hr = m_pDVDControl2->SelectParentalLevel(lParentalLevel);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SelectParentalLevel */

/*************************************************************************/
/* Function: GetTitleParentalLevels                                      */
/* Description: Gets the parental level associated with a specific title.*/
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_TitleParentalLevels(long lTitle, long *plParentalLevels){

	HRESULT hr = S_OK;

    try {
        if(NULL == plParentalLevels){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        ULONG ulLevel;
        hr = pDvdInfo2->GetTitleParentalLevels(lTitle, &ulLevel); 

        if(SUCCEEDED(hr)){

            *plParentalLevels = ulLevel;
        } 
        else {

            *plParentalLevels = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetTitleParentalLevels */

/*************************************************************************/
/* Function: GetPlayerParentalCountry                                    */
/* Description: Gets the player parental country.                        */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_PlayerParentalCountry(long *plCountryCode){

	HRESULT hr = S_OK;

    try {
        if(NULL == plCountryCode){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        BYTE bCountryCode[2];
        ULONG ulLevel;
        hr = pDvdInfo2->GetPlayerParentalLevel(&ulLevel, bCountryCode); 

        if(SUCCEEDED(hr)){

            *plCountryCode = bCountryCode[0]<<8 | bCountryCode[1];
        } 
        else {

            *plCountryCode = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetPlayerParentalCountry */

/*************************************************************************/
/*************************************************************************/
/* Function: GetPlayerParentalLevel                                      */
/* Description: Gets the player parental level.                          *
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_PlayerParentalLevel(long *plParentalLevel){
	HRESULT hr = S_OK;

    try {
        if(NULL == plParentalLevel){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        ULONG ulLevel;
        BYTE bCountryCode[2];
        hr = pDvdInfo2->GetPlayerParentalLevel(&ulLevel, bCountryCode); 

        if(SUCCEEDED(hr)){
            *plParentalLevel = ulLevel;
        } 
        else {
            *plParentalLevel = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetPlayerParentalLevel */

STDMETHODIMP CMSVidWebDVD::Eject(){
    USES_CONVERSION;
    BSTR bDrive;
    HRESULT hr = get_DVDDirectory(&bDrive);
    if(FAILED(hr)){
        return hr;
    }

	MCI_OPEN_PARMS  mciDrive;
	WCHAR*          pDrive = bDrive;
    TCHAR           szElementName[4];
	TCHAR           szAliasName[32];
	DWORD           dwFlags;
	DWORD           dwAliasCount = GetCurrentTime();
	DWORD           theMciErr;

    ZeroMemory( &mciDrive, sizeof(mciDrive) );
    mciDrive.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
    (void)StringCchPrintf( szElementName, sizeof(szElementName) / sizeof(szElementName[0]), TEXT("%c:"), pDrive[0] );
    (void)StringCchPrintf( szAliasName, sizeof(szAliasName) / sizeof(szAliasName[0]), TEXT("SJE%lu:"), dwAliasCount );
    mciDrive.lpstrAlias = szAliasName;

    mciDrive.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
    mciDrive.lpstrElementName = szElementName;
    dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_ALIAS |
	      MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;

	// send mci command
    theMciErr = mciSendCommand(0, MCI_OPEN, dwFlags, reinterpret_cast<DWORD_PTR>(&mciDrive));

    if ( theMciErr != MMSYSERR_NOERROR ) 
		return E_UNEXPECTED;

    DWORD DevHandle = mciDrive.wDeviceID;
    if(m_bEjected==false){
        m_bEjected = true;
        ZeroMemory( &mciDrive, sizeof(mciDrive) );
        theMciErr = mciSendCommand( DevHandle, MCI_SET, MCI_SET_DOOR_OPEN, 
            reinterpret_cast<DWORD_PTR>(&mciDrive) );
        hr = theMciErr ? E_FAIL : S_OK; // zero for success
        if(FAILED(hr)){
            return hr;
        }
    }
    else{
        m_bEjected = false;
        ZeroMemory( &mciDrive, sizeof(mciDrive) );
        theMciErr = mciSendCommand( DevHandle, MCI_SET, MCI_SET_DOOR_CLOSED, 
            reinterpret_cast<DWORD_PTR>(&mciDrive) );
        hr = theMciErr ? E_FAIL : S_OK; // zero for success
        if(FAILED(hr)){
            return hr;
        }
    }
    ZeroMemory( &mciDrive, sizeof(mciDrive) );
	theMciErr = mciSendCommand( DevHandle, MCI_CLOSE, 0L, reinterpret_cast<DWORD_PTR>(&mciDrive) );
    hr = theMciErr ? E_FAIL : S_OK; // zero for success
    return hr;
}

/*************************************************************************/
/* Function: UOPValid                                                    */
/* Description: Tells if UOP is valid or not, valid means the feature is */
/* turned on.                                                            */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::UOPValid(long lUOP, VARIANT_BOOL *pfValid){

    HRESULT hr = S_OK;

    try {
        if (NULL == pfValid){
            
            throw(E_POINTER);
        }/* end of if statement */

        if ((lUOP > 24) || (lUOP < 0)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        ULONG ulUOPS = 0;
        hr = pDvdInfo2->GetCurrentUOPS(&ulUOPS);

        *pfValid = ulUOPS & (1 << lUOP) ? VARIANT_FALSE : VARIANT_TRUE;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function UOPValid */

/*************************************************************************/
/* Function: GetSPRM                                                     */
/* Description: Gets SPRM at the specific index.                         */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_SPRM(long lIndex, short *psSPRM){

    HRESULT hr = E_FAIL;

    try {
	    if (NULL == psSPRM){

            throw(E_POINTER);         
        }/* end of if statement */

        SPRMARRAY sprm;                
        int iArraySize = sizeof(SPRMARRAY)/sizeof(sprm[0]);

        if(0 > lIndex || iArraySize <= lIndex){

            return(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */
        
        hr = pDvdInfo2->GetAllSPRMs(&sprm);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        *psSPRM = sprm[lIndex];            
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function GetSPRM */

/*************************************************************************/
/* Function: SetGPRM                                                     */
/* Description: Sets a GPRM at index.                                    */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::put_GPRM(long lIndex, short sValue){

       HRESULT hr = S_OK;

    try {
        if(lIndex < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        hr = m_pDVDControl2->SetGPRM(lIndex, sValue, cdwDVDCtrlFlags, 0);
            
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SetGPRM */

/*************************************************************************/
/* Function:  GetGPRM                                                    */
/* Description: Gets the GPRM at specified index                         */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_GPRM(long lIndex, short *psGPRM){

    HRESULT hr = E_FAIL;

    try {
	    if (NULL == psGPRM){

            throw(E_POINTER);         
        }/* end of if statement */

        GPRMARRAY gprm;
        int iArraySize = sizeof(GPRMARRAY)/sizeof(gprm[0]);

        if(0 > lIndex || iArraySize <= lIndex){

            return(E_INVALIDARG);
        }/* end of if statement */
    
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        hr = pDvdInfo2->GetAllGPRMs(&gprm);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *psGPRM = gprm[lIndex];        
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function GetGPRM */

/*************************************************************************/
/* Function: GetDVDTextNumberOfLanguages                                 */
/* Description: Retrieves the number of languages available.             */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDTextNumberOfLanguages(long *plNumOfLangs){

    HRESULT hr = S_OK;

    try {
        if (NULL == plNumOfLangs){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */
        
        ULONG ulNumOfLangs;

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetDVDTextNumberOfLanguages(&ulNumOfLangs));        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *plNumOfLangs = ulNumOfLangs;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextNumberOfLanguages */

/*************************************************************************/
/* Function: GetDVDTextNumberOfStrings                                   */
/* Description: Gets the number of strings in the partical language.     */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDTextNumberOfStrings(long lLangIndex, long *plNumOfStrings){

    HRESULT hr = S_OK;

    try {
        if (NULL == plNumOfStrings){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        LCID wLangCode;
        ULONG uNumOfStings;
        DVD_TextCharSet charSet;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetDVDTextLanguageInfo(lLangIndex, &uNumOfStings, &wLangCode, &charSet));        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *plNumOfStrings = uNumOfStings;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextNumberOfStrings */

/*************************************************************/
/* Name: GetDVDTextLanguageLCID
/* Description: Get the LCID of an index of the DVD texts
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDTextLanguageLCID(long lLangIndex, long *lcid)
{
    HRESULT hr = S_OK;

    try {
        if (NULL == lcid){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        LCID wLangCode;
        ULONG uNumOfStings;
        DVD_TextCharSet charSet;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetDVDTextLanguageInfo(lLangIndex, &uNumOfStings, &wLangCode, &charSet));        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *lcid = wLangCode;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextLanguageLCID */

/*************************************************************************/
/* Function: GetDVDtextString                                            */
/* Description: Gets the DVD Text string at specific location.           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDTextString(long lLangIndex, long lStringIndex, BSTR *pstrText){

    HRESULT hr = S_OK;

    try {
        if (NULL == pstrText){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */
        
        ULONG ulSize; 
        DVD_TextStringType type;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetDVDTextStringAsUnicode(lLangIndex, lStringIndex,  NULL, 0, &ulSize, &type));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        if (ulSize == 0) {
            *pstrText = ::SysAllocString(L"");
        }

        else {
            // got the length so lets allocate a buffer of that size
            WCHAR* wstrBuff = new WCHAR[ulSize];
            
            ULONG ulActualSize;
            hr = pDvdInfo2->GetDVDTextStringAsUnicode(lLangIndex, lStringIndex,  wstrBuff, ulSize, &ulActualSize, &type);
            
            ATLASSERT(ulActualSize == ulSize);
            
            if(FAILED(hr)){
                
                delete [] wstrBuff;
                throw(hr);
            }/* end of if statement */
            
            *pstrText = ::SysAllocString(wstrBuff);
            delete [] wstrBuff;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDtextString */

/*************************************************************************/
/* Function: GetDVDTextStringType                                        */
/* Description: Gets the type of the string at the specified location.   */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDTextStringType(long lLangIndex, long lStringIndex, DVDTextStringType *pType){

    HRESULT hr = S_OK;

    try {
        if (NULL == pType){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        ULONG ulTheSize;
        DVD_TextStringType type;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetDVDTextStringAsUnicode(lLangIndex, lStringIndex,  NULL, 0, &ulTheSize, &type));

        if(SUCCEEDED(hr)){

            *pType = (DVDTextStringType) type;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextStringType */

/*************************************************************************/
/* Function: RegionChange                                                */
/* Description:Changes the region code.                                  */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::RegionChange(){

    USES_CONVERSION;
    HRESULT hr = S_OK;
    typedef BOOL (APIENTRY *DVDPPLAUNCHER) (HWND HWnd, CHAR DriveLetter);

    try {
#if 0
        HWND parentWnd;
        GetParentHWND(&parentWnd);
        if (NULL != parentWnd) {
            // take the container out of the top-most mode
            ::SetWindowPos(parentWnd, HWND_NOTOPMOST, 0, 0, 0, 0, 
                SWP_NOREDRAW|SWP_NOMOVE|SWP_NOSIZE);
        }
#endif
        BOOL regionChanged = FALSE;
        OSVERSIONINFO ver;
        ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        ::GetVersionEx(&ver);

        if (ver.dwPlatformId==VER_PLATFORM_WIN32_NT) {

                HINSTANCE dllInstance;
                DVDPPLAUNCHER dvdPPLauncher;
                TCHAR szCmdLine[MAX_PATH], szDriveLetter[4];
                LPSTR szDriveLetterA;

                //
                // tell the user why we are showing the dvd region property page
                //
                // DVDMessageBox(m_hWnd, IDS_REGION_CHANGE_PROMPT);

                hr = GetDVDDriveLetter(szDriveLetter);

                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */

                szDriveLetterA = T2A(szDriveLetter);

                GetSystemDirectory(szCmdLine, MAX_PATH);
                (void)StringCchCat(szCmdLine, SIZEOF_CH(szCmdLine), _T("\\storprop.dll"));
        
                dllInstance = LoadLibrary (szCmdLine);
                if (dllInstance) {

                    dvdPPLauncher = (DVDPPLAUNCHER) GetProcAddress(
                        dllInstance,
                        "DvdLauncher");
                    
                    if (dvdPPLauncher) {
                        
                        regionChanged = dvdPPLauncher(NULL,
                            szDriveLetterA[0]);
                    }

                    FreeLibrary(dllInstance);
                }

        } 
        else {
#if 0
            // win9x code should be using complier defines rather than if0'ing it out
                INITIALIZE_GRAPH_IF_NEEDS_TO_BE

                //Get path of \windows\dvdrgn.exe and command line string
                TCHAR szCmdLine[MAX_PATH], szDriveLetter[4];
                
                hr = GetDVDDriveLetter(szDriveLetter);

                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */

                UINT rc = GetWindowsDirectory(szCmdLine, MAX_PATH);
                if (!rc) {
                    return E_UNEXPECTED;
                }
                (void)StringCchCat(szCmdLine, SIZEOF_CH(szCmdLine), _T("\\dvdrgn.exe "));
                TCHAR strModuleName[MAX_PATH];
                lstrcpyn(strModuleName, szCmdLine, MAX_PATH);

                TCHAR csTmp[2]; ::ZeroMemory(csTmp, sizeof(TCHAR)* 2);
                csTmp[0] = szDriveLetter[0];
                (void)StringCchCat(szCmdLine, SIZEOF_CH(szCmdLine), csTmp);
        
                //Prepare and execuate dvdrgn.exe
                STARTUPINFO StartupInfo;
                PROCESS_INFORMATION ProcessInfo;
                StartupInfo.cb          = sizeof(StartupInfo);
                StartupInfo.dwFlags     = STARTF_USESHOWWINDOW;
                StartupInfo.wShowWindow = SW_SHOW;
                StartupInfo.lpReserved  = NULL;
                StartupInfo.lpDesktop   = NULL;
                StartupInfo.lpTitle     = NULL;
                StartupInfo.cbReserved2 = 0;
                StartupInfo.lpReserved2 = NULL;
                if( ::CreateProcess(strModuleName, szCmdLine, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS,
                                                  NULL, NULL, &StartupInfo, &ProcessInfo) ){

                        //Wait dvdrgn.exe finishes.
                        WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
                        DWORD dwRet = 1;
                        BOOL bRet = GetExitCodeProcess(ProcessInfo.hProcess, &dwRet);
                        if(dwRet == 0){
                            //User changed the region successfully
                            regionChanged = TRUE;
    
                        }
                        else{
                            throw(E_REGION_CHANGE_NOT_COMPLETED);
                        }
                }/* end of if statement */
#endif
        }/* end of if statement */

        if (regionChanged) {

                // start playing again
                INITIALIZE_GRAPH_IF_NEEDS_TO_BE                      
        } 
        else {

            throw(E_REGION_CHANGE_FAIL);
        }/* end of if statement */
	}
    catch(HRESULT hrTmp){
        
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function RegionChange */

/*************************************************************************/
/* Function: GetDVDDriveLetter                                           */
/* Description: Gets the first three characters that denote the DVD-ROM  */
/*************************************************************************/
HRESULT CMSVidWebDVD::GetDVDDriveLetter(TCHAR* lpDrive) {

    HRESULT hr = E_FAIL;

    PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
    if(!pDvdInfo2){
        
        throw(E_UNEXPECTED);
    }/* end of if statement */
        
    WCHAR szRoot[MAX_PATH];
    ULONG ulActual;

    hr = pDvdInfo2->GetDVDDirectory(szRoot, MAX_PATH, &ulActual);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    USES_CONVERSION;
    
	lstrcpyn(lpDrive, OLE2T(szRoot), 3);
    if(::GetDriveType(&lpDrive[0]) == DRIVE_CDROM){
        
		return(hr);
    }
    else {
        //possibly root=c: or drive in hard disc
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */

    return(hr);
}/* end of function GetDVDDriveLetter */

/*************************************************************************/
/* Function: get_DVDAdm                                                  */
/* Description: Returns DVD admin interface.                             */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDAdm(IDispatch **pVal){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if (m_pDvdAdmin){

            hr = m_pDvdAdmin->QueryInterface(IID_IDispatch, (LPVOID*)pVal);
        }
        else {

            *pVal = NULL;            
            throw(E_FAIL);
        }/* end of if statement */
    
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_DVDAdm */


/*************************************************************/
/* Name: SelectDefaultAudioLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectDefaultAudioLanguage(long lang, long ext){

    HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectDefaultAudioLanguage(lang, (DVD_AUDIO_LANG_EXT)ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: SelectDefaultSubpictureLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectDefaultSubpictureLanguage(long lang, DVDSPExt ext){

    HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectDefaultSubpictureLanguage(lang, (DVD_SUBPICTURE_LANG_EXT)ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultMenuLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DefaultMenuLanguage(long *lang)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == lang){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = pDvdInfo2->GetDefaultMenuLanguage((LCID*)lang);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: put_DefaultMenuLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::put_DefaultMenuLanguage(long lang){

    HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectDefaultMenuLanguage(lang);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************************/
/* Function: get_PreferredSubpictureStream                                    */
/* Description: Gets current audio stream.                               */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_PreferredSubpictureStream(long *plPreferredStream){

    HRESULT hr = S_OK;

    try {
	    if (NULL == plPreferredStream){

            throw(E_POINTER);         
        }/* end of if statement */

        if(!m_pDvdAdmin){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        LCID langDefaultSP;
        m_pDvdAdmin->get_DefaultSubpictureLCID((long*)&langDefaultSP);
        
        // if none has been set
        if (langDefaultSP == (LCID) -1) {
            
            *plPreferredStream = 0;
            return hr;
        } /* end of if statement */
        
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
            
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        USES_CONVERSION;
        LCID lcid = 0;
        
        ULONG ulNumAudioStreams = 0;
        ULONG ulCurrentStream = 0;
        BOOL  fDisabled = TRUE;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentSubpicture(&ulNumAudioStreams, &ulCurrentStream, &fDisabled));
        
        *plPreferredStream = 0;
        for (ULONG i = 0; i<ulNumAudioStreams; i++) {
            hr = pDvdInfo2->GetSubpictureLanguage(i, &lcid);
            if (SUCCEEDED( hr ) && lcid){
                if (lcid == langDefaultSP) {
                    *plPreferredStream = i;
                }
            }
        }
    }
    
    catch(HRESULT hrTmp){
        return hrTmp;
    }/* end of catch statement */

    catch(...){
        return E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultSubpictureLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DefaultSubpictureLanguage(long *lang)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == lang){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        long ext;
        hr = pDvdInfo2->GetDefaultSubpictureLanguage((LCID*)lang, (DVD_SUBPICTURE_LANG_EXT*)&ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultSubpictureLanguageExt
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DefaultSubpictureLanguageExt(DVDSPExt *ext)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == ext){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        long lang;
        hr = pDvdInfo2->GetDefaultSubpictureLanguage((LCID*)&lang, (DVD_SUBPICTURE_LANG_EXT*)ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultAudioLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DefaultAudioLanguage(long *lang)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == lang){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        long ext;
        hr = pDvdInfo2->GetDefaultAudioLanguage((LCID*)lang, (DVD_AUDIO_LANG_EXT*)&ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultAudioLanguageExt
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DefaultAudioLanguageExt(long *ext)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == ext){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        long lang;
        hr = pDvdInfo2->GetDefaultAudioLanguage((LCID*)&lang, (DVD_AUDIO_LANG_EXT*)ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: GetLanguageFromLCID
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_LanguageFromLCID(long lcid, BSTR* lang)
{
    HRESULT hr = S_OK;

    try {
        if (lang == NULL) {

            throw(E_POINTER);
        }/* end of if statement */

        USES_CONVERSION;

        LPTSTR pszString = m_LangID.GetLanguageFromLCID(lcid);
    
        if (pszString) {
            *lang = ::SysAllocString(T2OLE(pszString));
            delete[] pszString;
        }
        
        else {
            *lang = ::SysAllocString( L"");
            throw(E_NOTIMPL);
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}

/*************************************************************/
/* Name: get_KaraokeAudioPresentationMode
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_KaraokeAudioPresentationMode(long *pVal)
{
    HRESULT hr = S_OK;

    try {

        if (NULL == pVal) {

            throw (E_POINTER);
        } /* end of if statement */

        *pVal = m_lKaraokeAudioPresentationMode;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: put_KaraokeAudioPresentationMode
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::put_KaraokeAudioPresentationMode(long newVal)
{
    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */        

        RETRY_IF_IN_FPDOM(m_pDVDControl2->SelectKaraokeAudioPresentationMode((ULONG)newVal));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // Cache the value
        m_lKaraokeAudioPresentationMode = newVal;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: GetKaraokeChannelContent
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_KaraokeChannelContent(long lStream, long lChan, long *lContent)
{
    HRESULT hr = S_OK;

    try {
        if(!lContent){
            return E_POINTER;
        }   
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (lChan >=8 || lChan < 0 ) {

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_KaraokeAttributes attrib;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetKaraokeAttributes(lStream, &attrib));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *lContent = (long)attrib.wChannelContents[lChan];

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: GetKaraokeChannelAssignment
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_KaraokeChannelAssignment(long lStream, long *lChannelAssignment)
{
    HRESULT hr = S_OK;

    try {
        if(!lChannelAssignment){
            return E_POINTER;
        }
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_KaraokeAttributes attrib;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetKaraokeAttributes(lStream, &attrib));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *lChannelAssignment = (long)attrib.ChannelAssignment;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}


STDMETHODIMP CMSVidWebDVD::OnEventNotify(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2) {
    if (lEvent == EC_STEP_COMPLETE || (lEvent > EC_DVDBASE && lEvent <= EC_DVD_KARAOKE_MODE) ) {
        return OnDVDEvent(lEvent, lParam1, lParam2);
    }

    if(lEvent == EC_STATE_CHANGE && lParam1 == State_Running){
        VARIANT_BOOL onStop;
        HRESULT hr = m_pDvdAdmin->get_BookmarkOnStop(&onStop);
        if(FAILED(hr)){
            throw(hr);
        }
        if(VARIANT_TRUE == onStop){
            hr = RestoreBookmark();
            if(FAILED(hr)){
                throw(hr);
            }
        }
    }
    return IMSVidPBGraphSegmentImpl<CMSVidWebDVD, MSVidSEG_SOURCE, &GUID_NULL>::OnEventNotify(lEvent, lParam1, lParam2);
}

/*************************************************************/
/* Name: OnDVDEvent
/* Description: Deal with DVD events
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::OnDVDEvent(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2)
{
    if (m_fFireNoSubpictureStream) {
        m_fFireNoSubpictureStream = FALSE;
        lEvent = EC_DVD_ERROR;
        lParam1 = DVD_ERROR_NoSubpictureStream;
        lParam2 = 0;

        VARIANT varLParam1;
        VARIANT varLParam2;

#ifdef _WIN64
        varLParam1.llVal = lParam1;
        varLParam1.vt = VT_I8;
        varLParam2.llVal = lParam2;
        varLParam2.vt = VT_I8;
#else
        varLParam1.lVal = lParam1;
        varLParam1.vt = VT_I4;
        varLParam2.lVal = lParam2;
        varLParam2.vt = VT_I4;
#endif

        // fire the event now after we have processed it internally
        Fire_DVDNotify(lEvent, varLParam1, varLParam2);        
    }

    
    ATLTRACE(TEXT("CMSVidWebDVD::OnDVDEvent %x\n"), lEvent-EC_DVDBASE);
    switch (lEvent){
    //
    // First the DVD error events
    //
    case EC_DVD_ERROR:
        switch (lParam1){
            
        case DVD_ERROR_Unexpected:
            break ;
            
        case DVD_ERROR_CopyProtectFail:
            break ;
            
        case DVD_ERROR_InvalidDVD1_0Disc:
            break ;
            
        case DVD_ERROR_InvalidDiscRegion:
            PreStop();
            PostStop();
            break ;
            
        case DVD_ERROR_LowParentalLevel:
            break ;
            
        case DVD_ERROR_MacrovisionFail:
            break ;
            
        case DVD_ERROR_IncompatibleSystemAndDecoderRegions:
            break ;
            
        case DVD_ERROR_IncompatibleDiscAndDecoderRegions:
            break ;
        }
        break;

    //
    // Next the normal DVD related events
    //
    case EC_DVD_VALID_UOPS_CHANGE:
    {
        VALID_UOP_SOMTHING_OR_OTHER validUOPs = (DWORD) lParam1;
        if (validUOPs&UOP_FLAG_Play_Title_Or_AtTime) {
            Fire_PlayAtTimeInTitle(VARIANT_FALSE);
            Fire_PlayAtTime(VARIANT_FALSE);
        }
        else {
            Fire_PlayAtTimeInTitle(VARIANT_TRUE);
            Fire_PlayAtTime(VARIANT_TRUE);
        }
            
        if (validUOPs&UOP_FLAG_Play_Chapter) {
            Fire_PlayChapterInTitle(VARIANT_FALSE);
            Fire_PlayChapter(VARIANT_FALSE);
        }
        else {
            Fire_PlayChapterInTitle(VARIANT_TRUE);
            Fire_PlayChapter(VARIANT_TRUE);
        }

        if (validUOPs&UOP_FLAG_Play_Title){
            Fire_PlayTitle(VARIANT_FALSE);
            
        }
        else {
            Fire_PlayTitle(VARIANT_TRUE);
        }

        if (validUOPs&UOP_FLAG_Stop)
            Fire_Stop(VARIANT_FALSE);
        else
            Fire_Stop(VARIANT_TRUE);

        if (validUOPs&UOP_FLAG_ReturnFromSubMenu)
            Fire_ReturnFromSubmenu(VARIANT_FALSE);
        else
            Fire_ReturnFromSubmenu(VARIANT_TRUE);

        
        if (validUOPs&UOP_FLAG_Play_Chapter_Or_AtTime) {
            Fire_PlayAtTimeInTitle(VARIANT_FALSE);
            Fire_PlayChapterInTitle(VARIANT_FALSE);
        }
        else {
            Fire_PlayAtTimeInTitle(VARIANT_TRUE);
            Fire_PlayChapterInTitle(VARIANT_TRUE);
        }

        if (validUOPs&UOP_FLAG_PlayPrev_Or_Replay_Chapter){

            Fire_PlayPrevChapter(VARIANT_FALSE);
            Fire_ReplayChapter(VARIANT_FALSE);
        }                    
        else {
            Fire_PlayPrevChapter(VARIANT_TRUE);
            Fire_ReplayChapter(VARIANT_TRUE);
        }/* end of if statement */

        if (validUOPs&UOP_FLAG_PlayNext_Chapter)
            Fire_PlayNextChapter(VARIANT_FALSE);
        else
            Fire_PlayNextChapter(VARIANT_TRUE);

        if (validUOPs&UOP_FLAG_Play_Forwards)
            Fire_PlayForwards(VARIANT_FALSE);
        else
            Fire_PlayForwards(VARIANT_TRUE);
        
        if (validUOPs&UOP_FLAG_Play_Backwards)
            Fire_PlayBackwards(VARIANT_FALSE);
        else 
            Fire_PlayBackwards(VARIANT_TRUE);
                        
        if (validUOPs&UOP_FLAG_ShowMenu_Title) 
            Fire_ShowMenu(dvdMenu_Title, VARIANT_FALSE);
        else 
            Fire_ShowMenu(dvdMenu_Title, VARIANT_TRUE);
            
        if (validUOPs&UOP_FLAG_ShowMenu_Root) 
            Fire_ShowMenu(dvdMenu_Root, VARIANT_FALSE);
        else
            Fire_ShowMenu(dvdMenu_Root, VARIANT_TRUE);
        
        //TODO: Add the event for specific menus
        
        if (validUOPs&UOP_FLAG_ShowMenu_SubPic)
            Fire_ShowMenu(dvdMenu_Subpicture, VARIANT_FALSE);
        else
            Fire_ShowMenu(dvdMenu_Subpicture, VARIANT_TRUE);
        
        if (validUOPs&UOP_FLAG_ShowMenu_Audio)
            Fire_ShowMenu(dvdMenu_Audio, VARIANT_FALSE);
        else
            Fire_ShowMenu(dvdMenu_Audio, VARIANT_TRUE);
            
        if (validUOPs&UOP_FLAG_ShowMenu_Angle)
            Fire_ShowMenu(dvdMenu_Angle, VARIANT_FALSE);
        else
            Fire_ShowMenu(dvdMenu_Angle, VARIANT_TRUE);

            
        if (validUOPs&UOP_FLAG_ShowMenu_Chapter)
            Fire_ShowMenu(dvdMenu_Chapter, VARIANT_FALSE);
        else
            Fire_ShowMenu(dvdMenu_Chapter, VARIANT_TRUE);

        
        if (validUOPs&UOP_FLAG_Resume)
            Fire_Resume(VARIANT_FALSE);
        else
            Fire_Resume(VARIANT_TRUE);
        
        if (validUOPs&UOP_FLAG_Select_Or_Activate_Button)
            Fire_SelectOrActivateButton(VARIANT_FALSE);
        else 
            Fire_SelectOrActivateButton(VARIANT_TRUE);
        
        if (validUOPs&UOP_FLAG_Still_Off)
            Fire_StillOff(VARIANT_FALSE);
        else
            Fire_StillOff(VARIANT_TRUE);

        if (validUOPs&UOP_FLAG_Pause_On)
            Fire_PauseOn(VARIANT_FALSE);
        else
            Fire_PauseOn(VARIANT_TRUE);

        if (validUOPs&UOP_FLAG_Select_Audio_Stream)
            Fire_ChangeCurrentAudioStream(VARIANT_FALSE);
        else
            Fire_ChangeCurrentAudioStream(VARIANT_TRUE);
        
        if (validUOPs&UOP_FLAG_Select_SubPic_Stream)
            Fire_ChangeCurrentSubpictureStream(VARIANT_FALSE);
        else
            Fire_ChangeCurrentSubpictureStream(VARIANT_TRUE);
        
        if (validUOPs&UOP_FLAG_Select_Angle)
            Fire_ChangeCurrentAngle(VARIANT_FALSE);
        else
            Fire_ChangeCurrentAngle(VARIANT_TRUE);

        /*
        if (validUOPs&UOP_FLAG_Karaoke_Audio_Pres_Mode_Change)
            ;
        if (validUOPs&UOP_FLAG_Video_Pres_Mode_Change)
            ;
        */
        }
        break;


    case EC_DVD_STILL_ON:
        m_fStillOn = true;    
        break ;
        
    case EC_DVD_STILL_OFF:                
        m_fStillOn = false;
        break ;
        
    case EC_DVD_DOMAIN_CHANGE:
        
        switch (lParam1){
            
        case DVD_DOMAIN_FirstPlay: // = 1
            //case DVD_DOMAIN_VideoManagerMenu:  // = 2
            break;
            
        case DVD_DOMAIN_Stop:       // = 5
        case DVD_DOMAIN_VideoManagerMenu:  // = 2                    
        case DVD_DOMAIN_VideoTitleSetMenu: // = 3
        case DVD_DOMAIN_Title:      // = 4
        default:
            break;
        }/* end of switch case */
        break ;
        
    case EC_DVD_BUTTON_CHANGE:                       
        break;
        
    case EC_DVD_CHAPTER_START:              
        break ;
        
    case EC_DVD_CURRENT_TIME: 
        //ATLTRACE(TEXT("Time event \n"));
        break;
        
    //
    // Then the general DirectShow related events
    //
    case EC_DVD_PLAYBACK_STOPPED:
        // DShow doesn't stop on end; we should do that
        // call PostStop to make sure graph is stopped properly
        //PostStop();
        break;
        
    case EC_DVD_DISC_EJECTED:
        m_bEjected = true;
        break;

    case EC_DVD_DISC_INSERTED:
        m_bEjected = false;
        break;
        
    case EC_STEP_COMPLETE:                
        m_fStepComplete = true;
        break;
        
    case EC_DVD_PLAYBACK_RATE_CHANGE:
        m_Rate = lParam1 / 10000;
        break;

    default:
        break ;
    }/* end of switch case */
        
    VARIANT varLParam1;
    VARIANT varLParam2;

#ifdef _WIN64
        varLParam1.llVal = lParam1;
        varLParam1.vt = VT_I8;
        varLParam2.llVal = lParam2;
        varLParam2.vt = VT_I8;
#else
        varLParam1.lVal = lParam1;
        varLParam1.vt = VT_I4;
        varLParam2.lVal = lParam2;
        varLParam2.vt = VT_I4;
#endif

        // fire the event now after we have processed it internally
        Fire_DVDNotify(lEvent, varLParam1, varLParam2);

    return NOERROR;
}

/*************************************************************/
/* Name: RestorePreferredSettings
/* Description: 
/*************************************************************/
HRESULT CMSVidWebDVD::RestorePreferredSettings()
{
    HRESULT hr = S_OK;
    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        // get the curent domain
        DVD_DOMAIN domain;
        
        hr = pDvdInfo2->GetCurrentDomain(&domain);
        
        if(FAILED(hr)){
            
            throw(hr);
        }/* end of if statement */
        
        // Have to be in the stop domain
        if(DVD_DOMAIN_Stop != domain)
            throw (VFW_E_DVD_INVALIDDOMAIN);
            
        if(!m_pDvdAdmin){
            
            throw (E_UNEXPECTED);
        }/* end of if statement */
        
        long level;
        hr = m_pDvdAdmin->GetParentalLevel(&level);
        if (SUCCEEDED(hr))
            SelectParentalLevel(level);
        LCID audioLCID;
        LCID subpictureLCID;
        LCID menuLCID;
        
        hr = m_pDvdAdmin->get_DefaultAudioLCID((long*)&audioLCID);
        if (SUCCEEDED(hr))
            SelectDefaultAudioLanguage(audioLCID, 0);
        
        hr = m_pDvdAdmin->get_DefaultSubpictureLCID((long*)&subpictureLCID);
        if (SUCCEEDED(hr))
            SelectDefaultSubpictureLanguage(subpictureLCID, dvdSPExt_NotSpecified);
        
        hr = m_pDvdAdmin->get_DefaultMenuLCID((long*)&menuLCID);
        if (SUCCEEDED(hr))
            put_DefaultMenuLanguage(menuLCID);
    }
    
    catch(HRESULT hrTmp){
        
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}
HRESULT CMSVidWebDVD::get_ButtonRect(long lButton, /*[out, retval] */ IMSVidRect** pRect){
    try{
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){    
            throw(E_UNEXPECTED);
        }/* end of if statement */
        if(!pRect){
            return E_POINTER;
        }
        CRect oRect;
        HRESULT hr = pDvdInfo2->GetButtonRect( lButton, &oRect);
        if(FAILED(hr)){
            return hr;
        }
        *((CRect*)(*pRect)) = oRect;
    }
    catch(...){
        return E_UNEXPECTED;
    }
    return S_OK;
}
HRESULT CMSVidWebDVD::get_DVDScreenInMouseCoordinates(/*[out, retval] */ IMSVidRect** ppRect){
    return E_NOTIMPL;
}
HRESULT CMSVidWebDVD::put_DVDScreenInMouseCoordinates(IMSVidRect* pRect){
    return E_NOTIMPL;
}

#endif //TUNING_MODEL_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidvideorenderer.h ===
//==========================================================================;
// MSVidVideoRenderer.h : Declaration of the CMSVidVideoRenderer
// copyright (c) Microsoft Corp. 1998-1999.
//==========================================================================;

#ifndef __MSVidVIDEORENDERER_H_
#define __MSVidVIDEORENDERER_H_

#pragma once

#include <algorithm>
#include <evcode.h>
#include <uuids.h>
#include <amvideo.h>
#include <strmif.h>
#include <objectwithsiteimplsec.h>
#include "vidrect.h"
#include "vidvidimpl.h"
#include "vrsegimpl.h"
#include "devimpl.h"
#include "seg.h"
#include "videorenderercp.h"
#include "strmif.h"
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMSVidVideoRenderer
class ATL_NO_VTABLE __declspec(uuid("37B03543-A4C8-11d2-B634-00C04F79498E")) CMSVidVideoRenderer :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidVideoRenderer, &__uuidof(CMSVidVideoRenderer)>,
    public IObjectWithSiteImplSec<CMSVidVideoRenderer>,
	public ISupportErrorInfo,
    public CProxy_IMSVidVideoRenderer<CMSVidVideoRenderer>,
	public IConnectionPointContainerImpl<CMSVidVideoRenderer>,
    public IMSVidVideoRendererImpl<CMSVidVideoRenderer, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidVideoRenderer2>,
    public IProvideClassInfo2Impl<&CLSID_MSVidVideoRenderer, &IID_IMSVidVideoRendererEvent, &LIBID_MSVidCtlLib>
{
public:
    CMSVidVideoRenderer() 
	{   
        m_APid = -1;
        m_compositorGuid = GUID_NULL;
        m_opacity = -1;
        m_rectPosition.top = -1;
        m_rectPosition.left = -1;
        m_rectPosition.bottom = -1;
        m_rectPosition.right = -1;
        m_SourceSize = sslFullSize;
        m_lOverScan = 1;
	}
    virtual ~CMSVidVideoRenderer() {
            m_PQIPicture.Release();
            CleanupVMR();
    }

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME,
						   IDS_REG_VIDEORENDERER_PROGID,
						   IDS_REG_VIDEORENDERER_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidVideoRenderer));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidVideoRenderer)
    COM_INTERFACE_ENTRY(IMSVidVideoRenderer)
	COM_INTERFACE_ENTRY(IMSVidVRGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
    COM_INTERFACE_ENTRY(IMSVidVideoRenderer2)
    COM_INTERFACE_ENTRY(IMSVidOutputDevice)
	COM_INTERFACE_ENTRY(IMSVidDevice)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CMSVidVideoRenderer)
	IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
	IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
	IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSVidVideoRenderer)
//	CONNECTION_POINT_ENTRY(IID_IMSVidVideoRendererEvent2)    
    CONNECTION_POINT_ENTRY(IID_IMSVidVideoRendererEvent)    
END_CONNECTION_POINT_MAP()

// ISupportsErrorInfo
protected:
    DSPinList connectedPins;
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
// IMSVidDevice
    CComBSTR __declspec(property(get=GetName)) m_Name;
    CComBSTR GetName(void) {
        CString csName;
        if(m_iVideoRenderer != -1){
            csName = (m_Filters[m_iVideoRenderer]).GetName();
        }
        if (csName.IsEmpty()) {
            csName = _T("Video Mixing Renderer");
        }
		csName += _T(" Segment");
        return CComBSTR(csName);
    }

	STDMETHOD(get_Name)(BSTR * Name) {
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
		if (Name == NULL)
			return E_POINTER;
        try {
		    *Name = m_Name.Copy();	
        } catch(...) {
            return E_POINTER;
        }
		return NOERROR;
	}
	STDMETHOD(get_Status)(LONG * Status) {
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
		if (Status == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_Segment)(IMSVidGraphSegment * * pIMSVidGraphSegment)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        try {
            if (pIMSVidGraphSegment == NULL) {
			    return E_POINTER;
            }
            *pIMSVidGraphSegment = reinterpret_cast<IMSVidGraphSegment*>(this);
            AddRef();
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_SuppressEffects)(/*in*/ VARIANT_BOOL bSuppress);
    STDMETHOD(get_SuppressEffects)(/*out, retval*/ VARIANT_BOOL *bSuppress);
// Methods to access the allocator presenter object in the vmr
    STDMETHOD(SetAllocator)(/*[in]*/ IUnknown *Allocator, long ID = -1){
        try{
            if(!Allocator){
                return _SetAllocator(NULL, ID);
            }
            PQVMRSAlloc qiAllocator(Allocator);
            if(!qiAllocator){
                _ASSERT(false);
                return E_UNEXPECTED;
            }

            return _SetAllocator(qiAllocator, ID);
            
        }
        catch(...){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(_SetAllocator)(/*[in]*/ IVMRSurfaceAllocator *Allocator, long ID = -1){
        try{
            PQVMRSAlloc qiAllocator(Allocator);

            HRESULT hr = CleanupVMR();
            if(FAILED(hr)){
                return hr;
            }

            qiSurfAlloc = qiAllocator;
            m_APid = ID;
            return S_OK;
        }
        catch(...){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_Allocator)(/*[in]*/ IUnknown **Allocator){
        try{
            if(!Allocator){
                return E_POINTER;
            }
            if(!qiSurfAlloc){
                return E_FAIL;
            }
			PUnknown retVal(qiSurfAlloc);
            if(!retVal){
                _ASSERT(false);
                return E_UNEXPECTED;
            }
            *Allocator = retVal.Detach();
            _ASSERT(Allocator);
            return S_OK;
        }
        catch(...){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(get__Allocator)(/*[in]*/ IVMRSurfaceAllocator **Allocator){
        try{
            if(!Allocator){
                return E_POINTER;
            }
            if(!qiSurfAlloc){
                return E_FAIL; // should be un-inited failure
            }
            PQVMRSAlloc qiAllocator(qiSurfAlloc);
            if(!qiAllocator){
                _ASSERT(false);
                return E_UNEXPECTED;
            }
            *Allocator = qiAllocator.Detach();
            _ASSERT(Allocator);
            return S_OK;
        }
        catch(...){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(get_Allocator_ID)(long *ID){
        try{
            if(!ID){
                return E_POINTER;
            }
            *ID = m_APid;
            return S_OK;
        }
        catch(...){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(OnEventNotify)(LONG lEventCode, LONG_PTR lEventParm1, LONG_PTR lEventParm2){
        if (lEventCode == EC_VMR_RENDERDEVICE_SET) {
            VARIANT_BOOL fUsingOverlay;
            get_UsingOverlay(&fUsingOverlay);
            if (fUsingOverlay == VARIANT_TRUE && !(lEventParm1 & VMR_RENDER_DEVICE_OVERLAY)) {
                put_UsingOverlay(VARIANT_FALSE);
                Fire_OverlayUnavailable();
                ReComputeSourceRect();
		return NOERROR;
            }
        }
        if (lEventCode == EC_VMR_RENDERDEVICE_SET || 
            lEventCode == EC_VIDEO_SIZE_CHANGED) {
                ReComputeSourceRect();
        }
        return E_NOTIMPL;
    }
    STDMETHOD(PostStop)(){
        TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop()"), "");
        HRESULT hr = IMSVidVideoRendererImpl<CMSVidVideoRenderer, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidVideoRenderer2>::PostStop();
        if(FAILED(hr)){
            TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop() base class PostStop failed; hr = " << std::hex << hr), "");
            return hr;
        }
        // need stestrops fix for deallocate on stop
        DSFilter sp_VMR = m_Filters[m_iVideoRenderer];
        if(!sp_VMR){
            TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop() could not get vmr filter"), "");
            return E_UNEXPECTED;
        }

        int i = 0;
        for(DSFilter::iterator pin = sp_VMR.begin(); pin != sp_VMR.end(); ++pin, ++i){
            if( (*pin).IsConnected()){
                hr = (*pin).Disconnect();
                if(FAILED(hr)){
                    TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop() disconnect failed; hr = " << std::hex << hr), "");
                    return hr;
                }
            }
        }
#ifdef _WIN64
        TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop() NumPins: " << (long)connectedPins.size() << " pins."), "");
#endif
        return S_OK;
    }

    STDMETHOD(PreRun)(){
        HRESULT hr = IMSVidVideoRendererImpl<CMSVidVideoRenderer, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidVideoRenderer2>::PreRun();
        if(FAILED(hr)){
            TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PreRun() base class PostStop failed; hr = " << std::hex << hr), "");
            return hr;
        }
        // need stestrops fix for deallocate on stop
        DSFilter sp_VMR = m_Filters[m_iVideoRenderer];
        if(!sp_VMR){
            TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop() could not get vmr filter"), "");
            return E_UNEXPECTED;
        }
        
        if(connectedPins.size() == 0){ // if the pin list is empty rebuild it otherwise reconnect the pins
            int i = 0;
            for(DSFilter::iterator pin = sp_VMR.begin(); pin != sp_VMR.end(); ++pin, ++i){
                if( (*pin).IsConnected()){
                    connectedPins.push_back((*pin).GetConnection());
                }
            }
#ifndef _WIN64
            TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop() Storing: " << connectedPins.size() << " pins."), "");
#endif
        }
        else{
            DSFilter::iterator vmrPin = sp_VMR.begin();
            for(DSPinList::iterator pin = connectedPins.begin(); pin != connectedPins.end() && vmrPin != sp_VMR.end(); ++pin, ++vmrPin){
                if(!(*vmrPin).IsConnected()){
                    hr = (*vmrPin).Connect(*pin);
                    if(FAILED(hr)){
                        TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PreRun() connect failed; hr = " << std::hex << hr), "");
                        return hr;
                    }
                }
                else{
                    _ASSERT((*vmrPin).GetConnection() != (*pin));
                }
            }
        }

        return S_OK;
    }
    STDMETHOD(Decompose)(){
        TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::Decompose() killing pin list"), "");
        connectedPins.clear();
        HRESULT hr = IMSVidVideoRendererImpl<CMSVidVideoRenderer, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidVideoRenderer2>::Decompose();
        if(FAILED(hr) && hr != E_NOTIMPL){
            TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PreRun() base class Decompose failed; hr = " << std::hex << hr), "");
            return hr;
        }

        return S_OK;

    }
#if 0
    STDMETHOD(get__CustomCompositorClass)(/*[out, retval]*/ GUID* CompositorCLSID) {
        return IMSVidVideoRendererImpl<CMSVidVideoRenderer, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidVideoRenderer2>::get__CustomCompositorClass(CompositorCLSID);
    }
#endif
};
#endif //__MSVidVIDEORENDERER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidwebdvd.h ===
//===========================================================================
//
// MSVidWebDVD.h: Definition of the CMSVidWebDVD class
// Copyright (c) Microsoft Corporation 1999-2000.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MSVIDWEBDVD_H__6CF9F624_1F3C_44FA_8F00_FCC31B2976D6__INCLUDED_)
#define AFX_MSVIDWEBDVD_H__6CF9F624_1F3C_44FA_8F00_FCC31B2976D6__INCLUDED_

#pragma once

#include <dvdevcod.h>
#include <algorithm>
#include <objectwithsiteimplsec.h>
#include "pbsegimpl.h"
#include "webdvdimpl.h"
#include "seg.h"
#include "resource.h"       // main symbols
#include "mslcid.h"
#include "MSVidWebDVDCP.h"
#include "vidrect.h"
#include <strmif.h>
#include <math.h>
#define DVD_ERROR_NoSubpictureStream   99
#define EC_DVD_PLAYING                 (EC_DVDBASE + 0xFE)
#define EC_DVD_PAUSED                  (EC_DVDBASE + 0xFF)
#define E_NO_IDVD2_PRESENT MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF0)
#define E_NO_DVD_VOLUME MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF1)
#define E_REGION_CHANGE_FAIL MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF2)
#define E_REGION_CHANGE_NOT_COMPLETED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF3)

typedef CComQIPtr<IDvdControl2, &IID_IDvdControl2> PQDVDControl2;
typedef CComQIPtr<IDvdInfo2, &IID_IDvdInfo2> PQDVDInfo2;
typedef CComQIPtr<IMSVidWebDVD, &IID_IMSVidWebDVD> PQWebDVD;

// the following enum and struct are for DVD url parsing.
typedef enum 
{
    DVD_Playback_Default,
    DVD_Playback_Title,
    DVD_Playback_Chapter,
    DVD_Playback_Chapter_Range,
    DVD_Playback_Time,
    DVD_Playback_Time_Range
} DVDPlaybackRef;

class DVDUrlInfo{
public:
    DVDPlaybackRef enumRef;
    CComBSTR bstrPath;
    long lTitle;
    long lChapter;
    long lEndChapter;
    ULONG ulTime;
    ULONG ulEndTime; 
    DVDUrlInfo(){
        bstrPath;
        lTitle = 0;
        lChapter = 0;
        lEndChapter = 0;
        ulTime = 0;
        ulEndTime = 0; 
    }
    virtual ~DVDUrlInfo(){
    }
};
////////////////////////////////////////////////////////////////////////////////////
/*************************************************************************/
/* Local Defines to sort of abstract the implementation and make the     */
/* changes bit more convinient.                                          */
/*************************************************************************/
#define INITIALIZE_GRAPH_IF_NEEDS_TO_BE     \
        {}

#define INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY   \
        {}

#define RETRY_IF_IN_FPDOM(func)              \
        {func;}

/////////////////////////////////////////////////////////////////////////////
// CMSVidWebDVD

class ATL_NO_VTABLE __declspec(uuid("011B3619-FE63-4814-8A84-15A194CE9CE3")) CMSVidWebDVD : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IMSVidPBGraphSegmentImpl<CMSVidWebDVD, MSVidSEG_SOURCE, &GUID_NULL>,
	public IMSVidGraphSegmentUserInput,
    public IObjectWithSiteImplSec<CMSVidWebDVD>,
	public CComCoClass<CMSVidWebDVD, &__uuidof(CMSVidWebDVD)>,
	public ISupportErrorInfo,
    public IMSVidWebDVDImpl<CMSVidWebDVD, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidWebDVD>,
    public CProxy_WebDVDEvent< CMSVidWebDVD >,
    public IConnectionPointContainerImpl<CMSVidWebDVD>,
    public IObjectSafetyImpl<CMSVidWebDVD, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
    public IProvideClassInfo2Impl<&CLSID_MSVidWebDVD, &IID_IMSVidWebDVDEvent, &LIBID_MSVidCtlLib>
{
public:
	CMSVidWebDVD() : 
        m_iDVDNav(-1), 
        m_fUrlInfoSet(false), 
        m_fResetSpeed(false), 
        m_fStillOn(false),
        m_fFireNoSubpictureStream(false),
        m_fStepComplete(false),
        m_bEjected(false),
        m_DVDFilterState(dvdState_Undefined),
        m_lKaraokeAudioPresentationMode(-1),
        m_usButton(-1),
        m_Rate(1),
        m_Mode(TenthsSecondsMode)
    {
        m_fEnableResetOnStop = false;
    }

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_MSVIDWEBDVD_PROGID, 
						   IDS_REG_MSVIDWEBDVD_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidWebDVD));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidWebDVD)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMSVidWebDVD)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidGraphSegmentUserInput)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IMSVidPlayback)
	COM_INTERFACE_ENTRY(IMSVidInputDevice)
	COM_INTERFACE_ENTRY(IMSVidDevice)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)    
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)    
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CMSVidWebDVD)
	CONNECTION_POINT_ENTRY(IID_IMSVidWebDVDEvent)    
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSVidWebDVD
public:
    int m_iDVDNav;

    // QI for IDVDControl2 from DVDNavigator
#if 0
    PQDVDControl2 GetDVDControl2() {
        if (m_iDVDNav < 0) {
            return PQDVDControl2();
        }
        return PQDVDControl2(m_Filters[m_iDVDNav]);
    }
#endif

    // QI for IDVDInfo2 from DVDNavigator
    PQDVDInfo2 GetDVDInfo2() {
        if (m_iDVDNav < 0) {
            return PQDVDInfo2();
        }
        return PQDVDInfo2(m_Filters[m_iDVDNav]);
    }

    CComBSTR __declspec(property(get=GetName)) m_Name;
    CComBSTR GetName(void) {
        CString csName = _T("DVD Playback");
        return CComBSTR(csName);
    }
    HRESULT Unload(void) {
		m_pDVDControl2.Release();
        HRESULT hr = IMSVidGraphSegmentImpl<CMSVidWebDVD, MSVidSEG_SOURCE, &GUID_NULL>::Unload();
        return hr;
	}

    virtual ~CMSVidWebDVD() {
        CleanUp();
    }

// IMSVidGraphSegment
	STDMETHOD(put_Init)(IUnknown *pInit);

    STDMETHOD(Build)() {
        return NOERROR;
    }
    STDMETHOD(put_Rate)(double lRate){
        HRESULT hr = S_OK;
        CComQIPtr<IDvdCmd>IDCmd;
        double newRate = lRate;
        try{
            /*** Checking args and init'ing interfaces ***/
            if(!m_pDVDControl2){
                hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), CO_E_NOTINITIALIZED);
            }
            // Change rate
            if(lRate > 0){
                // hr set in Retry macro
                long pauseCookie = 0;
                HRESULT hres = RunIfPause(&pauseCookie);
                if(FAILED(hres)){
                    return hres; 
                }

                hr = m_pDVDControl2->PlayForwards(lRate, DVD_CMD_FLAG_Flush, reinterpret_cast<IDvdCmd**>(&IDCmd));
                if(IDCmd){
                    IDCmd->WaitForEnd();
                }

                hres = PauseIfRan(pauseCookie);
                if(FAILED(hres)){
                    return hres;
                }

            }
            else if(lRate < 0){
                lRate = -lRate;
                // hr set in Retry macro

                long pauseCookie = 0;
                HRESULT hres = RunIfPause(&pauseCookie);
                if(FAILED(hres)){
                    return hres; 
                }

                hr = m_pDVDControl2->PlayBackwards(lRate, DVD_CMD_FLAG_Flush, reinterpret_cast<IDvdCmd**>(&IDCmd));
                if(IDCmd){
                    IDCmd->WaitForEnd();
                }

                hres = PauseIfRan(pauseCookie);
                if(FAILED(hres)){
                    return hres;
                }
            }
            else{
                hr = E_INVALIDARG;
            }        
        }
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            hr =  E_UNEXPECTED;
        }
        // Only set rate if it succeeds
        if(SUCCEEDED(hr)){
            m_Rate = newRate;
        }
        return hr;
    }
    STDMETHOD(get_Rate)(double* lRate){
        HRESULT hr;
        try{
            if(!lRate){
                return E_POINTER;
            }
            *lRate = m_Rate;
            return S_OK;
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            hr =  E_UNEXPECTED;
        }
        return hr;
    }
    STDMETHOD(put_EnableResetOnStop)(/*in*/VARIANT_BOOL newVal){
        
        HRESULT hr = S_OK;
        
        try {
            
            bool fEnable = (VARIANT_FALSE == newVal) ? false: true;
            bool fEnableOld = m_fEnableResetOnStop;
            
            m_fEnableResetOnStop = fEnable;
            
            if(!m_pDVDControl2){
                
                throw(S_FALSE); // we might not have initialized graph as of yet, but will
                // defer this to play state
            }/* end of if statement */
            
            hr = m_pDVDControl2->SetOption(DVD_ResetOnStop, fEnable);
            
            if(FAILED(hr)){
                
                m_fEnableResetOnStop = fEnableOld; // restore the old state
            }/* end of if statement */
            
        }/* end of try statement */
        catch(HRESULT hrTmp){
            
            hr = hrTmp;
        }
        catch(...){
            
            hr = E_UNEXPECTED;
        }/* end of catch statement */
        
        return HandleError(hr);
    }/* end of function put_EnableResetOnStop */
//-----------------------------------------------------------------------------------------
// Name: DVD_HMSF_TIMECODE convertDVDSeconds(double)
// Description: Converts a seconds to a dvd timecode 
//-----------------------------------------------------------------------------------------
    DVD_HMSF_TIMECODE convertDVDSeconds(double Seconds, ULONG ulFlags, LONG mode){
        HRESULT hr = S_OK;
        DVD_HMSF_TIMECODE dvdTCode = {0,0,0,0};
        double fps;
        if(ulFlags == DVD_TC_FLAG_25fps){
            fps = 25;
        }
        else if(ulFlags == DVD_TC_FLAG_30fps){
            fps = 30;
        }
        else if(ulFlags == DVD_TC_FLAG_DropFrame){
            fps = 29.97;
        }
        else if(ulFlags == DVD_TC_FLAG_Interpolated){
            fps = 30; // is this right???
        }
        else{
            return dvdTCode;
        }
        if(mode == FrameMode){
            Seconds = Seconds / fps;
        }
        // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
        else if(mode == TenthsSecondsMode){
            Seconds = Seconds / 100;
        }
        // If it is some other mode not supported by the vidctl
        else{
            return dvdTCode;
        }
        dvdTCode.bHours = (BYTE)(floor(Seconds/3600)); // Number of hours
        Seconds = Seconds - 3600 * dvdTCode.bHours;
        dvdTCode.bMinutes = (BYTE)(floor(Seconds/60));
        Seconds = Seconds - 60 *dvdTCode.bMinutes;
        dvdTCode.bSeconds = (BYTE)(floor(Seconds));
        Seconds = Seconds - dvdTCode.bSeconds;
        dvdTCode.bFrames = (BYTE)(floor(Seconds * fps));
        return dvdTCode;
    }
    //-----------------------------------------------------------------------------------------
    // Name: double convertDVDTimeCode(DVD_HMSF_TIMECODE, ULONG)
    // Description: Converts a dvd timecode with dvd flags into seconds and returns as a double 
    //-----------------------------------------------------------------------------------------
    double convertDVDTimeCode(DVD_HMSF_TIMECODE dvdTime, ULONG ulFlags, long mode ){
        double fps;
        if(ulFlags == DVD_TC_FLAG_25fps){
            fps = 25;
        } else if(ulFlags == DVD_TC_FLAG_30fps){
            fps = 30;
        } else if(ulFlags == DVD_TC_FLAG_DropFrame){
            fps = 29.97;
        } else if(ulFlags == DVD_TC_FLAG_Interpolated){
            fps = 30; // is this right???
        } else{
            return 0;
        }
        
        double time_temp = static_cast<double>( (3600*dvdTime.bHours) + (60*dvdTime.bMinutes) +
            dvdTime.bSeconds + (dvdTime.bFrames/fps) );
        if(mode == FrameMode){
            time_temp = time_temp * fps;
            return time_temp;
        } else if(mode == TenthsSecondsMode){
            // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
            time_temp = time_temp * 100;
            return time_temp;
        }
        // If it is some other mode not supported by the vidctl
        return 0;
    }
    //-----------------------------------------------------------------------------------------
    // Name: get_Length(LONGLONG*)
    //-----------------------------------------------------------------------------------------
    STDMETHOD(get_Length)(/*[out, retval]*/long *lLength){
        HRESULT hr = S_OK;
        try{
            /*** Checking args and init'ing interfaces ***/
            if(!lLength){
				return E_POINTER;
			}
			PQDVDInfo2 pqDInfo2 = GetDVDInfo2();
            if(!pqDInfo2){
                hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), CO_E_NOTINITIALIZED);
            }
            // Get length
            DVD_HMSF_TIMECODE TotalTime;
            ULONG ulFlags;
            double seconds;
            hr = pqDInfo2->GetTotalTitleTime(&TotalTime, &ulFlags);
            if(FAILED(hr)){
                return hr;
            }
            // Get the length in seconds
            seconds = convertDVDTimeCode(TotalTime, ulFlags, m_Mode);
            if(seconds == 0){
                return E_UNEXPECTED;
            }
            *lLength = static_cast<long>(seconds);
            return S_OK;
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            hr =  E_UNEXPECTED;
        }
        return hr;
    }
    
    //-----------------------------------------------------------------------------------------
    // Name: get_CurrentPosition(LONGLONG*)
    //-----------------------------------------------------------------------------------------
    STDMETHOD(get_CurrentPosition)(/*[out,retval]*/long *lPosition) {
        HRESULT hr = S_OK;
        try{
            /*** Checking args and init'ing interfaces ***/
            PQDVDInfo2 pqDInfo2 = GetDVDInfo2();
            if(!pqDInfo2){
                hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), CO_E_NOTINITIALIZED);
            }
            // Get length
            DVD_PLAYBACK_LOCATION2 dvdLocation;
            double seconds;
            hr = pqDInfo2->GetCurrentLocation(&dvdLocation);
            if(FAILED(hr)){
                return hr;
            }
            // Get the length in seconds
            seconds = convertDVDTimeCode(dvdLocation.TimeCode, dvdLocation.TimeCodeFlags, m_Mode);
            if(seconds == 0){
                
                return E_UNEXPECTED;
            }

            *lPosition = static_cast<long>(seconds);
            return S_OK;
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            hr =  E_UNEXPECTED;
        }
        return hr;
    }
//-----------------------------------------------------------------------------------------
// Name: put_CurrentPosition(LONGLONG)
//-----------------------------------------------------------------------------------------
    STDMETHOD(put_CurrentPosition)(/*[in]*/long lPosition) {
        HRESULT hr = S_OK;
        CComQIPtr<IDvdCmd>IDCmd;
        try{
            /*** Checking args and init'ing interfaces ***/
            PQDVDInfo2 pqDInfo2 = GetDVDInfo2();
            if(!pqDInfo2 || !m_pDVDControl2){
                hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), CO_E_NOTINITIALIZED);
            }
            // Get length
            DVD_PLAYBACK_LOCATION2 dvdLocation;
            hr = pqDInfo2->GetCurrentLocation(&dvdLocation);
            if(FAILED(hr)){
                return hr;
            }
            DVD_HMSF_TIMECODE dvdTCode;
            // Convert the length in seconds to dvd timecode
            dvdTCode = convertDVDSeconds(lPosition, dvdLocation.TimeCodeFlags, m_Mode);
            // set the dvd to play at time in the dvd
            // hr set in retry macro
            long pauseCookie = 0;
            HRESULT hres = RunIfPause(&pauseCookie);
            if(FAILED(hres)){
                return hres; 
            }

            hr = m_pDVDControl2->PlayAtTime(&dvdTCode, dvdLocation.TimeCodeFlags, reinterpret_cast<IDvdCmd**>(&IDCmd));
			if(IDCmd){
				IDCmd->WaitForEnd();
			}

            hres = PauseIfRan(pauseCookie);
            if(FAILED(hres)){
                return hres;
            }

            return hr;
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            hr =  E_UNEXPECTED;
        }

        return hr;
    }
    //-----------------------------------------------------------------------------------------
    // Name: put_PositionMode(LONGLONG)
    //-----------------------------------------------------------------------------------------
    
    STDMETHOD(put_PositionMode)(/*[in]*/PositionModeList lPositionMode) {
        HRESULT hr = S_OK;
        try{
            if(lPositionMode == FrameMode){
                m_Mode = FrameMode;
                return S_OK;
            }
            else if(lPositionMode == TenthsSecondsMode){
                m_Mode = TenthsSecondsMode;
                return S_OK;
            }
            // If it is some other mode not supported by the vidctl
            else{
                return E_UNEXPECTED;
            }           
        }        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return hrTmp;
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }


    //-----------------------------------------------------------------------------------------
    // Name: get_PositionMode(LONGLONG*)
    //-----------------------------------------------------------------------------------------
    STDMETHOD(get_PositionMode)(/*[out,retval]*/PositionModeList* lPositionMode) {
        HRESULT hr = S_OK;
        try{
            // Checking args and interfaces
            if(!lPositionMode){
                return E_POINTER;
            }
            *lPositionMode = m_Mode; 
            return hr;        
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return hrTmp;
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
    //-----------------------------------------------------------------------------------------
    STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl)
        {
            if (!m_fInit) {
                return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidWebDVD), CO_E_NOTINITIALIZED);
        }
        try {
            if (!pCtl) {
                return Unload();
            }
            if (m_pContainer) {
				if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
					return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidWebDVD), CO_E_ALREADYINITIALIZED);
				} else {
					return NO_ERROR;
				}
            }
			
            HRESULT hr = NO_ERROR;
            DSFilter pfr(CLSID_DVDNavigator);
            if (!pfr) {
                ASSERT(false);
		        return Error(IDS_CANT_CREATE_FILTER, __uuidof(IMSVidWebDVD), hr);
            }
            if (m_pContainer) {
                bool rc = m_pGraph.RemoveFilter(*m_Filters.begin());
                if (!rc) {
                    TRACELM(TRACE_ERROR,  "IMSVidWebDVD::Load() can't remove filter");
			        return Error(IDS_CANT_REMOVE_FILTER, __uuidof(IMSVidWebDVD), E_UNEXPECTED);
                }
            }
            m_Filters.clear();
            m_Filters.push_back(pfr);
            m_iDVDNav = m_Filters.size() - 1;
			m_pDVDControl2 = pfr;

            // DON'T addref the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            m_pContainer.p = pCtl;
            m_pGraph = m_pContainer.GetGraph();
            USES_CONVERSION;
            CString csName(_T("DVD Navigator"));
            hr = m_pGraph->AddFilter(m_Filters[m_iDVDNav], T2COLE(csName));
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR,  (dbgDump << "IMSVidWebDVD::Load() hr = " << std::hex << hr), "");
                return Error(IDS_CANT_ADD_FILTER, __uuidof(IMSVidWebDVD), hr);
            }

        } catch (ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}
// IMSVidGraphSegmentInputs
	STDMETHOD(Click)()
	{
        return E_NOTIMPL;
	}
	STDMETHOD(DblClick)()
	{
        return E_NOTIMPL;
	}
	STDMETHOD(KeyDown)(short* KeyCode, short Shift){
		return E_NOTIMPL; 
	}
	STDMETHOD(KeyPress)(short* KeyAscii){ 
		return E_NOTIMPL; 
	}
	STDMETHOD(KeyUp)(short* KeyCode, short Shift){ 
        HRESULT hr;
        switch (*KeyCode) {
        case VK_UP:
            hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Upper);
            if (FAILED(hr)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::KeyUp() select up failed hr = " << hexdump(hr)), "");
                return hr;
            } else {
                return S_FALSE;
            }
            break;
        case VK_DOWN:
            hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Lower);
            if (FAILED(hr)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::KeyUp() select down failed hr = " << hexdump(hr)), "");
                return hr;
            } else {
                return S_FALSE;
            }
            break;
        case VK_LEFT:
            hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Left);
            if (FAILED(hr)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::KeyUp() select left failed hr = " << hexdump(hr)), "");
                return hr;
            } else {
                return S_FALSE;
            }
            break;
        case VK_RIGHT:
            hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Right);
            if (FAILED(hr)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::KeyUp() select right failed hr = " << hexdump(hr)), "");
                return hr;
            } else {
                return S_FALSE;
            }
            break;
        case VK_SPACE:
        case VK_RETURN:
            hr = m_pDVDControl2->ActivateButton();
            if (FAILED(hr)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::KeyUp() activate failed hr = " << hexdump(hr)), "");
                return hr;
            } else {
                return S_FALSE;
            }
            break;

        }
		return E_NOTIMPL; 
	}
	STDMETHOD(MouseDown)(short Button, short Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y){
		if ((m_DVDFilterState & dvdState_Running) && m_pDVDControl2) {
			if (((m_usButton ^ Button) & MSVIDCTL_LEFT_BUTTON)) {
				CPoint pt(x, y);
				HRESULT hr = m_pDVDControl2->SelectAtPosition(pt);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::MouseDown() select failed hr = " << hexdump(hr)), "");
                    return hr;
                } else {
                    return S_FALSE;
                }
			}
			m_usButton = Button;
		}
		return NOERROR;
	}
	STDMETHOD(MouseMove)(short Button, short Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y){ 
		if ((m_DVDFilterState & dvdState_Running) && m_pDVDControl2) {
			if (Button & MSVIDCTL_LEFT_BUTTON) {
				CPoint pt(x, y);
				HRESULT hr = m_pDVDControl2->SelectAtPosition(pt);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::MouseMove() select failed hr = " << hexdump(hr)), "");
                    return hr;
                } else {
                    return S_FALSE;
                }
			}
			m_usButton = Button;
		}
		return NOERROR;
	}
	STDMETHOD(MouseUp)(short Button, short Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y){ 
		if ((m_DVDFilterState & dvdState_Running) && m_pDVDControl2) {
			if (((m_usButton ^ Button) & MSVIDCTL_LEFT_BUTTON)) {
				CPoint pt(x, y);
				HRESULT hr = m_pDVDControl2->ActivateAtPosition(pt);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::MouseUp() activate failed hr = " << hexdump(hr)), "");
                    return hr;
                } else {
                    return S_FALSE;
                }
			}
		}
		return NOERROR;
	}


// IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
		if (Name == NULL)
			return E_POINTER;
        try {
		    *Name = m_Name.Copy();	
        } catch(...) {
            return E_POINTER;
        }
		return NOERROR;
	}

// IMSVidInputDevice
	STDMETHOD(IsViewable)(VARIANT* pv, VARIANT_BOOL *pfViewable)
	{
        HRESULT hr = View(pv);

        if (SUCCEEDED(hr))
        {
            *pfViewable = VARIANT_TRUE;
        }

        return hr;
	}

	STDMETHOD(View)(VARIANT* pv) {
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidWebDVD), CO_E_NOTINITIALIZED);
        }
		if (!pv) {
			return E_POINTER;
		}
        if (pv->vt != VT_BSTR) {
			return E_INVALIDARG;
        }
        if (m_pGraph && !m_pGraph.IsStopped()) {
	        return Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // retrieve the DVD playback info from URL
        // save the info

        DeleteUrlInfo();
        
        HRESULT hr = ParseDVDPath(pv->bstrVal);

        if (SUCCEEDED(hr))
        {
            m_fUrlInfoSet = true;
        }

        return hr;
    }

    STDMETHOD(OnEventNotify)(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2);
    STDMETHOD(OnDVDEvent)(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2);
    STDMETHOD(PreRun)();
    STDMETHOD(PostRun)();
    STDMETHOD(PreStop)();
    STDMETHOD(PostStop)();
    STDMETHOD(PlayTitle)(long lTitle);
    STDMETHOD(PlayChapterInTitle)(long lTitle, long lChapter);
    STDMETHOD(PlayChapter)(long lChapter);
    STDMETHOD(PlayChaptersAutoStop)(long lTitle, long lstrChapter, long lChapterCount);
    STDMETHOD(PlayAtTime)(BSTR strTime);
    STDMETHOD(PlayAtTimeInTitle)(long lTitle, BSTR strTime);
    STDMETHOD(PlayPeriodInTitleAutoStop)(long lTitle, BSTR strStartTime, BSTR strEndTime);
    STDMETHOD(ReplayChapter)();
    STDMETHOD(PlayPrevChapter)();
    STDMETHOD(PlayNextChapter)();
    STDMETHOD(StillOff)();
    STDMETHOD(get_AudioLanguage)(long lStream, VARIANT_BOOL fFormat, BSTR* strAudioLang);
    STDMETHOD(ShowMenu)(DVDMenuIDConstants MenuID);
    STDMETHOD(Resume)();
    STDMETHOD(ReturnFromSubmenu)();
    STDMETHOD(get_ButtonsAvailable)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentButton)(/*[out, retval]*/ long *pVal);
    STDMETHOD(SelectAndActivateButton)(long lButton);
    STDMETHOD(ActivateButton)();
    STDMETHOD(SelectRightButton)();
    STDMETHOD(SelectLeftButton)();
    STDMETHOD(SelectLowerButton)();
    STDMETHOD(SelectUpperButton)();
    STDMETHOD(ActivateAtPosition)(long xPos, long yPos);
    STDMETHOD(SelectAtPosition)(long xPos, long yPos);
    STDMETHOD(get_ButtonAtPosition)(long xPos, long yPos, /*[out, retval] */ long* plButton);
    STDMETHOD(get_NumberOfChapters)(long lTitle, /*[out, retval]*/ long *pVal);
    STDMETHOD(get_TotalTitleTime)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_TitlesAvailable)(/*[out, retval]*/ long* pVal);
    STDMETHOD(get_VolumesAvailable)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentVolume)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentDiscSide)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentDomain)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentChapter)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentTitle)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentTime)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(DVDTimeCode2bstr)(/*[in]*/ long timeCode, /*[out, retval]*/ BSTR *pTimeStr);
    STDMETHOD(get_DVDDirectory)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_DVDDirectory)(/*[in]*/ BSTR newVal);
    STDMETHOD(IsSubpictureStreamEnabled)(/*[in]*/ long lstream, /*[out, retval]*/ VARIANT_BOOL *fEnabled);
    STDMETHOD(IsAudioStreamEnabled)(/*[in]*/ long lstream, /*[out, retval]*/ VARIANT_BOOL *fEnabled);
    STDMETHOD(get_CurrentSubpictureStream)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_CurrentSubpictureStream)(/*[in]*/ long newVal);
    STDMETHOD(get_SubpictureLanguage)(long lStream, /*[out, retval] */ BSTR* strLanguage);
    STDMETHOD(get_CurrentAudioStream)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_CurrentAudioStream)(/*[in]*/ long newVal);
    STDMETHOD(get_AudioStreamsAvailable)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_AnglesAvailable)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentAngle)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_CurrentAngle)(/*[in]*/ long newVal);
    STDMETHOD(get_SubpictureStreamsAvailable)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_SubpictureOn)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_SubpictureOn)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(get_DVDUniqueID)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(AcceptParentalLevelChange)(VARIANT_BOOL fAccept, BSTR strUserName, BSTR strPassword);	
    STDMETHOD(NotifyParentalLevelChange)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(SelectParentalCountry)(long lCountry, BSTR strUserName, BSTR strPassword);
    STDMETHOD(SelectParentalLevel)(long lParentalLevel, BSTR strUserName, BSTR strPassword);
    STDMETHOD(get_TitleParentalLevels)(long lTitle, /*[out, retval] */ long* plParentalLevels);
    STDMETHOD(get_PlayerParentalCountry)(/*[out, retval] */ long* plCountryCode);
    STDMETHOD(get_PlayerParentalLevel)(/*[out, retval] */ long* plParentalLevel);
    STDMETHOD(Eject)();
    STDMETHOD(UOPValid)(long lUOP, VARIANT_BOOL* pfValid);
    STDMETHOD(get_SPRM)(long lIndex, /*[out, retval] */ short *psSPRM);
    STDMETHOD(get_GPRM)(long lIndex, /*[out, retval] */ short *psSPRM);
    STDMETHOD(put_GPRM)(long lIndex, short sValue);
    STDMETHOD(get_DVDTextStringType)(long lLangIndex, long lStringIndex,  /*[out, retval] */ DVDTextStringType* pType);
    STDMETHOD(get_DVDTextString)(long lLangIndex, long lStringIndex, /*[out, retval] */ BSTR* pstrText);
    STDMETHOD(get_DVDTextNumberOfStrings)(long lLangIndex, /*[out, retval] */ long* plNumOfStrings);
    STDMETHOD(get_DVDTextNumberOfLanguages)(long* /*[out, retval] */ plNumOfLangs);
    STDMETHOD(get_DVDTextLanguageLCID)(/*[in]*/ long lLangIndex, /*[out, retval]*/ long* lcid);
    STDMETHOD(get_LanguageFromLCID)(/*[in]*/ long lcid, /*[out, retval]*/ BSTR* lang);
    STDMETHOD(RegionChange)();
    STDMETHOD(get_DVDAdm)(/*[out, retval]*/ IDispatch* *pVal);
    STDMETHOD(DeleteBookmark)();
    STDMETHOD(RestoreBookmark)();
    STDMETHOD(SaveBookmark)();
    STDMETHOD(SelectDefaultAudioLanguage)(long lang, long ext);
    STDMETHOD(SelectDefaultSubpictureLanguage)(long lang, DVDSPExt ext);
    STDMETHOD(get_PreferredSubpictureStream)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_DefaultMenuLanguage)(long* lang);
    STDMETHOD(put_DefaultMenuLanguage)(long lang);
    STDMETHOD(get_DefaultSubpictureLanguage)(long* lang);
    STDMETHOD(get_DefaultAudioLanguage)(long *lang);
    STDMETHOD(get_DefaultSubpictureLanguageExt)(DVDSPExt* ext);
    STDMETHOD(get_DefaultAudioLanguageExt)(long *ext);
    STDMETHOD(get_KaraokeAudioPresentationMode)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_KaraokeAudioPresentationMode)(/*[in]*/ long newVal);
    STDMETHOD(get_KaraokeChannelContent)(long lStream, long lChan, /*[out, retval] */ long* lContent);
    STDMETHOD(get_KaraokeChannelAssignment)(long lStream, /*[out, retval] */ long *lChannelAssignment);
    STDMETHOD(RestorePreferredSettings)();
    STDMETHOD(get_ButtonRect)(long lButton, /*[out, retval] */ IMSVidRect** pRect);
    STDMETHOD(get_DVDScreenInMouseCoordinates)(/*[out, retval] */ IMSVidRect** ppRect);	
    STDMETHOD(put_DVDScreenInMouseCoordinates)(IMSVidRect* pRect);
    //STDMETHOD(CanStep)(VARIANT_BOOL fBackwards, VARIANT_BOOL *pfCan);
    //STDMETHOD(Step)(long lStep);
private:
    // Private helper functions
    inline HRESULT RunIfPause(long *dwCookie){
        if(!dwCookie){
            return E_POINTER;
        }

        *dwCookie = 0;
        MSVidCtlStateList _curState = STATE_UNBUILT;   
        CComQIPtr<IMSVidCtl>_pq_VidCtl(m_pContainer);    
        if(!_pq_VidCtl){ 
            return E_UNEXPECTED;          
        } 

        HRESULT	_hr	= _pq_VidCtl->get_State(&_curState); 
        if(_curState ==	STATE_PAUSE){ 
            *dwCookie = 1;
            CComQIPtr<IMSVidAudioRenderer> _pq_AR;
            _hr = _pq_VidCtl->get_AudioRendererActive(&_pq_AR);
            if(FAILED(_hr)){
                return _hr;
            }

            _hr = _pq_AR->get_Volume(dwCookie);
            if(FAILED(_hr)){
                return _hr;
            }

            _hr = _pq_AR->put_Volume(-10000); // -10000 is volume off
            if(FAILED(_hr)){
                return _hr;
            }

            if(*dwCookie == 0){
                *dwCookie = 2;
            }

            _hr	= _pq_VidCtl->Run(); 
            if(FAILED(_hr)){ 
                return _hr;   
            }
        }

        return S_OK;
    }

    // Input is 0 not in pause state, < 0 volume settting, 1 muted audio, 2 full audio volume
    inline HRESULT PauseIfRan(long dwCookie){
        if(!dwCookie){
            return S_FALSE;
        }

        MSVidCtlStateList _curState = STATE_UNBUILT;   
        CComQIPtr<IMSVidCtl>_pq_VidCtl(m_pContainer);    
        if(!_pq_VidCtl){ 
            return E_UNEXPECTED;          
        } 

        HRESULT	_hr	= _pq_VidCtl->get_State(&_curState); 
        if(_curState !=	STATE_PAUSE){ 
            _hr	= _pq_VidCtl->Pause(); 
            if(FAILED(_hr)){ 
                return _hr;   
            }
        }

        if(dwCookie == 1){
            return S_OK;
        }

        if(dwCookie == 2){
            dwCookie = 0;
        }

        CComQIPtr<IMSVidAudioRenderer> _pq_AR;
        _hr = _pq_VidCtl->get_AudioRendererActive(&_pq_AR);
        if(FAILED(_hr)){
            return _hr;
        }

        _hr = _pq_AR->put_Volume(dwCookie);
        if(FAILED(_hr)){
            return _hr;
        }
        return S_OK;
    }   

    HRESULT PassFP_DOM();
    HRESULT HandleError(HRESULT hr);
    HRESULT CleanUp();
    HRESULT RestoreGraphState();
    HRESULT Bstr2DVDTime(DVD_HMSF_TIMECODE *ptrTimeCode, const BSTR *pbstrTime);
    HRESULT DVDTime2bstr(const DVD_HMSF_TIMECODE *pTimeCode, BSTR *pbstrTime);
    HRESULT TransformToWndwls(POINT& pt);
    HRESULT SelectParentalLevel(long lParentalLevel);
    HRESULT SelectParentalCountry(long lParentalCountry);
    HRESULT AppendString(TCHAR* strDest, INT strID, LONG dwLen);
    HRESULT GetDVDDriveLetter(TCHAR* lpDrive);
    HRESULT ParseDVDPath(BSTR pPath);
    HRESULT SetPlaybackFromUrlInfo();
    HRESULT SetDirectoryFromUrlInfo();
    void DeleteUrlInfo();
    int ParseNumber(LPWSTR& p, int nMaxDigits=0);

    // Private data members
    bool              m_fResetSpeed; 
    bool              m_fStillOn; 
    bool              m_fFireNoSubpictureStream;
    bool              m_fStepComplete;
    bool              m_bEjected;
    DVDFilterState    m_DVDFilterState;
    CComPtr<IMSVidWebDVDAdm> m_pDvdAdmin;
    MSLangID          m_LangID;
    long              m_lKaraokeAudioPresentationMode;
	PQDVDControl2     m_pDVDControl2;
	short			  m_usButton;
    DVDUrlInfo        m_urlInfo;
    bool              m_fUrlInfoSet;
    long              m_Rate;
    PositionModeList  m_Mode;
};

#endif // !defined(AFX_MSVIDWEBDVD_H__6CF9F624_1F3C_44FA_8F00_FCC31B2976D6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidwebdvdcp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _MSVIDWEBDVDCP_H_
#define _MSVIDWEBDVDCP_H_

template <class T>
class CProxy_WebDVDEvent : public CProxy_PlaybackEvent<T, &IID_IMSVidWebDVDEvent, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_DVDNotify(long lEventCode, VARIANT lParam1, VARIANT lParam2)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[2] = lEventCode;
				pvars[1] = lParam1;
				pvars[0] = lParam2;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(eventidDVDNotify, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayForwards(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayForwards, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayBackwards(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayBackwards, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ShowMenu(DVDMenuIDConstants __MIDL_0011, VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = __MIDL_0011;
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(eventidShowMenu, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_Resume(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidResume, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_SelectOrActivateButton(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidSelectOrActivateButton, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_StillOff(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidStillOff, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PauseOn(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPauseOn, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ChangeCurrentAudioStream(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidChangeCurrentAudioStream, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ChangeCurrentSubpictureStream(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidChangeCurrentSubpictureStream, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ChangeCurrentAngle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidChangeCurrentAngle, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayAtTimeInTitle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayAtTimeInTitle, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayAtTime(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayAtTime, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayChapterInTitle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayChapterInTitle, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayChapter, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ReplayChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidReplayChapter, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayNextChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayNextChapter, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_Stop(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidStop, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ReturnFromSubmenu(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidReturnFromSubmenu, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayTitle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayTitle, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayPrevChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayPrevChapter, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}	
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidxds.cpp ===
//==========================================================================;
// MSVidXDS.cpp : Declaration of the CMSVidXDS
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#ifndef TUNING_MODEL_ONLY
#include "msvidXDS.h"
#include <winerror.h>
#include <algorithm>
#include "segimpl.h"
#include "devices.h"
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include "resource.h"       // main symbols



DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidXDS, CXDS)

HRESULT CXDS::Unload(void) {
    IMSVidGraphSegmentImpl<CXDS, MSVidSEG_XFORM, &GUID_NULL>::Unload();
    m_iIPSink = -1;
    return NOERROR;
}
// IMSVidGraphSegment
STDMETHODIMP CXDS::Build() {
    return NOERROR;
}

STDMETHODIMP CXDS::PreRun() {
    return NOERROR;
}

STDMETHODIMP CXDS::put_Container(IMSVidGraphSegmentContainer *pCtl){
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    try {
        if (!pCtl) {
            return Unload();
        }

        if (m_pContainer) {
            if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
                return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidXDS), CO_E_ALREADYINITIALIZED);
            } else {
                return NO_ERROR;
            }
        }
        // DON'T addref the container.  we're guaranteed nested lifetimes
        // and an addref creates circular refcounts so we never unload.
        m_pContainer.p = pCtl;
        m_pGraph = m_pContainer.GetGraph();

        if (!m_pSystemEnum) {
            HRESULT hr = m_pSystemEnum.CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
            if (FAILED(hr)) {
                return E_UNEXPECTED;
            }
        }

        PQVidCtl pqCtl;
        HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
        if(FAILED(hr)){
            return hr;
        }

        PQFeatures activeFeat;
        hr = pqCtl->get_FeaturesActive(&activeFeat);
        if(FAILED(hr)){
            return hr;
        }

        CFeatures* pC = static_cast<CFeatures *>(activeFeat.p);
        DeviceCollection::iterator i;
        // Check to see if data services is active, if it is not find and load the cc codec
        for(i = pC->m_Devices.begin(); i != pC->m_Devices.end(); ++i){
            if(VWGraphSegment(*i).ClassID() == CLSID_MSVidDataServices){
                break;
            }
        }

        DSFilter ccDec;
        DSPin ccDecPin;
        if(i == pC->m_Devices.end()){
            DSDevices codeclist(m_pSystemEnum, KSCATEGORY_VBICODEC);
            DSMediaType mtL21(MEDIATYPE_AUXLine21Data, MEDIASUBTYPE_Line21_BytePair);
            for(DSDevices::iterator n = codeclist.begin(); n != codeclist.end() && !ccDec; ++n){
                DSFilter codecFilter = m_pGraph.AddMoniker((*n));
                for(DSFilter::iterator codecPin = codecFilter.begin(); codecPin != codecFilter.end(); ++codecPin){
                    if((*codecPin).GetDirection() == PINDIR_OUTPUT){
                        for(DSPin::iterator codecMediaType = (*codecPin).begin(); codecMediaType != (*codecPin).end(); ++codecMediaType){
                            if((*codecMediaType) == mtL21){
                                ccDec = codecFilter;
                                m_Filters.push_back(ccDec);
                                ccDecPin = *codecPin;                                    
                            }
                        }
                    }
                }
                if(!ccDec){
                    m_pGraph.RemoveFilter(codecFilter);
                }
            }
        }

        if(!ccDec){
            return E_UNEXPECTED;
        }

        CComBSTR xdsString(L"{C4C4C4F3-0049-4E2B-98FB-9537F6CE516D}");
        GUID2 xdsGuid(xdsString);
        // bring in xds filter
        CComPtr<IUnknown> fXDS(xdsGuid, NULL, CLSCTX_INPROC_SERVER);
        if (!fXDS) {
            TRACELM(TRACE_ERROR, "CMSVidClosedCaptioning::put_Container() can't load line 21 decoder");
            return E_FAIL;
        }

        DSFilter xdsFilter(fXDS);
        if (!xdsFilter) {
            return E_UNEXPECTED;
        }

        CString csName(_T("XDS Decoder"));
        hr = m_pGraph.AddFilter(xdsFilter, csName);
        if (FAILED(hr)) {
            return hr;
        }

        m_Filters.push_back(xdsFilter);    
        DSFilterList intermediates;
        hr = m_pGraph.Connect(ccDec, xdsFilter, intermediates); 
        if(FAILED(hr)){
            return hr;
        }

        m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
        return NOERROR;

    } catch (ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }

    return NOERROR;
}

// IMSVidDevice
STDMETHODIMP CXDS::get_Name(BSTR * Name){
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    try {
        return CComBSTR("XDS Segment").CopyTo(Name);
    } catch(...) {
        return E_POINTER;
    }
}



STDMETHODIMP CXDS::InterfaceSupportsErrorInfo(REFIID riid){
    static const IID* arr[] = 
    {
        &IID_IMSVidXDS
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++){
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}
#endif // TUNING_MODEL_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\msvidxds.h ===
//==========================================================================;
// MSVidXDS.h : Declaration of the CMSVidXDS
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __MSVidXDS_H_
#define __MSVidXDS_H_

#include <algorithm>
#include <tchar.h>
#include <objectwithsiteimplsec.h>
#include "segimpl.h"
#include "XDSimpl.h"

#include "seg.h"

typedef CComQIPtr<ITuner> PQMSVidXDS;

/////////////////////////////////////////////////////////////////////////////
// CMSVidXDS
class ATL_NO_VTABLE __declspec(uuid("0149EEDF-D08F-4142-8D73-D23903D21E90")) CXDS : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CXDS, &__uuidof(CXDS)>,
    public IObjectWithSiteImplSec<CXDS>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CXDS>,
	public IMSVidGraphSegmentImpl<CXDS, MSVidSEG_XFORM, &GUID_NULL>,
    public IMSVidXDSImpl<CXDS, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidXDS>
{
public:
    CXDS() {
	}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_XDS_PROGID, 
						   IDS_REG_XDS_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CXDS));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CXDS)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidXDS)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMSVidFeature)
	COM_INTERFACE_ENTRY(IMSVidDevice)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CXDS)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CXDS)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    PQCreateDevEnum m_pSystemEnum;
    int m_iIPSink;
    HRESULT Unload(void);
// IMSVidGraphSegment
    STDMETHOD(Build)();

    STDMETHOD(PreRun)();

	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl);
    // IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name);
};

#endif //__MSVidXDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\perfcntr.h ===
#define _100NS_IN_MS        (10*1000)
#define NANOSECONDS         10000000
#define CONVERT_PERFORMANCE_TIME(Frequency, PerformanceTime) \
    ((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS / (Frequency)) << 32) + \
    ((((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS) % (Frequency)) << 32) + \
    ((ULONGLONG)(PerformanceTime).LowPart * NANOSECONDS)) / (Frequency)))



#ifdef DEBUG

#include "trace.h"
#define VIDPERF(Y,X) CPerfVidCtl __cperfvidctl(Y,X);
#define VIDPERF_FUNC CPerfVidCtl __cperfvidctl(TRACE_ERROR, __FUNCTION__);
#define VIDPERF_FUNC2 CPerfVidCtl __cperfvidctl(TRACE_ALWAYS, __FUNCTION__);
class CPerfCounter
/*++

Abstract:

    This provides a simple performace counter. Simply call Start() to
    start counting.  Calling Stop() will spit out the results.  You can
    optional specify a name for your counter.

Author:

    Sam Clement (samclem) 24-Feb-2000

    Bryan A. Woodruff (bryanw) 10-Jun-2001
        Refactored for use with IOTest

    Luke W. McCullough (LukeM) 01-Jan-2002
    	Added VidCtl Specific Class and Debug state

--*/
{
public:
    CPerfCounter() : m_Name(NULL) { _Setup(); }
    explicit CPerfCounter(const char* Name) : m_Name(Name) { _Setup(); }
    ~CPerfCounter() {}

    void _Setup()
    {
        ZeroMemory(&m_StartTime, sizeof(m_StartTime));
        ZeroMemory(&m_CurrentTime, sizeof(m_CurrentTime));
        ZeroMemory(&m_CounterFreq, sizeof(m_CounterFreq));
        QueryPerformanceFrequency(&m_CounterFreq);
        QueryPerformanceCounter(&m_StartTime);
    }

    void Reset()
    {
        QueryPerformanceCounter(&m_StartTime);
    }

    LONGLONG Stop()
    {
        QueryPerformanceCounter(&m_CurrentTime);
        m_CurrentTime.QuadPart = m_CurrentTime.QuadPart - m_StartTime.QuadPart;
        m_CurrentTime.QuadPart = CONVERT_PERFORMANCE_TIME(m_CounterFreq.QuadPart, m_CurrentTime);
        return m_CurrentTime.QuadPart;
    }

    LONGLONG GetLastTime()
    {
        return m_CurrentTime.QuadPart;
    }

    void Trace()
    {
        Stop();

        (void)StringCchPrintfA(m_Outbuf, sizeof(m_Outbuf) / sizeof(m_Outbuf[0]), "\n*\n* PerfCounter: %s%s%s%ld ms\n*\n",
                (m_Name ? "(" : ""),
                (m_Name ? m_Name : ""),
                (m_Name ? ") " : ""),
                (m_CurrentTime.QuadPart / _100NS_IN_MS));

        puts( m_Outbuf );
    }

private:
    LARGE_INTEGER   m_StartTime;
    LARGE_INTEGER   m_CurrentTime;
    LARGE_INTEGER   m_CounterFreq;
    const char*     m_Name;
    char            m_Outbuf[MAX_PATH];

};

class CPerfVidCtl : public CPerfCounter{
private:
	char* dbString;
	DWORD traceLevel;
public:
	CPerfVidCtl(DWORD tLevel, char *debugString){
		traceLevel = tLevel;
		dbString = new char[strlen(debugString)+1];
		lstrcpynA(dbString, debugString, strlen(debugString)+1);
		_Setup();
		Reset();
        TRACELSM(traceLevel, (dbgDump << dbString << " : Start"), "");
	}
	~CPerfVidCtl(){
		if(!!dbString){
			LONGLONG curTime = Stop();
            TRACELSM(traceLevel, (dbgDump << dbString << " : End :" << (unsigned long)(curTime / _100NS_IN_MS) << "." << (unsigned long)(curTime % _100NS_IN_MS) << " ms"), "");
		}
		delete[] dbString;
	}

};
#else
//
// No perf counter.  Make it an empty object (should be optimized out)
//
class CPerfCounter
{
public:
    inline CPerfCounter() {}
    inline explicit CPerfCounter(const char* Name) {}
    inline ~CPerfCounter() {}
    inline void Reset() {}
    inline LONGLONG Stop() { return 0; }
    inline LONGLONG GetLastTime() { return 0; }
    inline void Trace() {}
};
#define VIDPERF(X,Y) 
#define VIDPERF_FUNC  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\regbagp.c ===
#include <regbag_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\regexthread.h ===
/////////////////////////////////////////////////////////////////////////////////////
// RegExThread.h : Declaration of the CSystemTuningSpaces
// Copyright (c) Microsoft Corporation 1999.

#ifndef __RegExThread_H_
#define __RegExThread_H_

#pragma once

#include "w32extend.h"
#include <regexp.h>

#define EXECUTE_ASSERT(x) x
typedef CComQIPtr<IRegExp> PQRegExp;

namespace BDATuningModel {


////////////////////////////////////////////////////////
// this is a private copy of some stuff from dshow's wxutil.h, .cpp.   i just need some of the win32 
// synchronization objects and thread stuff and i don't want to pull in all the rest of the 
// baggage in that file
// i've made some minor changes to CAMThread and renamed it to CBaseThread in order to avoid 
// any problems in the future

#ifndef __WXUTIL__
// wrapper for whatever critical section we have
class CCritSec {

    // make copy constructor and assignment operator inaccessible

    CCritSec(const CCritSec &refCritSec);
    CCritSec &operator=(const CCritSec &refCritSec);

    CRITICAL_SECTION m_CritSec;

public:
    CCritSec() {
		InitializeCriticalSection(&m_CritSec);
    };

    ~CCritSec() {
		DeleteCriticalSection(&m_CritSec);
    };

    void Lock() {
		EnterCriticalSection(&m_CritSec);
    };

    void Unlock() {
		LeaveCriticalSection(&m_CritSec);
    };
};

// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
class CAutoLock {

    // make copy constructor and assignment operator inaccessible

    CAutoLock(const CAutoLock &refAutoLock);
    CAutoLock &operator=(const CAutoLock &refAutoLock);

protected:
    CCritSec * m_pLock;

public:
    CAutoLock(CCritSec * plock)
    {
        m_pLock = plock;
        m_pLock->Lock();
    };

    ~CAutoLock() {
        m_pLock->Unlock();
    };
};



// wrapper for event objects
class CAMEvent
{

    // make copy constructor and assignment operator inaccessible

    CAMEvent(const CAMEvent &refEvent);
    CAMEvent &operator=(const CAMEvent &refEvent);

protected:
    HANDLE m_hEvent;
public:
    CAMEvent(BOOL fManualReset = FALSE)
	{
		m_hEvent = CreateEvent(NULL, fManualReset, FALSE, NULL);
		ASSERT(m_hEvent);
	}
    ~CAMEvent()
	{
        HANDLE hEvent = (HANDLE)InterlockedExchangePointer(&m_hEvent, 0);
		if (hEvent) {
			EXECUTE_ASSERT(CloseHandle(hEvent));
		}
	}

    // Cast to HANDLE - we don't support this as an lvalue
    operator HANDLE () const { return m_hEvent; };

    void Set() {EXECUTE_ASSERT(SetEvent(m_hEvent));};
    BOOL Wait(DWORD dwTimeout = INFINITE) {
	return (WaitForSingleObject(m_hEvent, dwTimeout) == WAIT_OBJECT_0);
    };
    BOOL Check() { return Wait(0); };
    void Reset() { ResetEvent(m_hEvent); };
};

#endif // __WXUTIL__


// support for a worker thread

// simple thread class supports creation of worker thread, synchronization
// and communication. Can be derived to simplify parameter passing
class __declspec(novtable) CBaseThread {

    // make copy constructor and assignment operator inaccessible

    CBaseThread(const CBaseThread &refThread);
    CBaseThread &operator=(const CBaseThread &refThread);

    CAMEvent m_EventComplete;

    DWORD m_dwParam;
    DWORD m_dwReturnVal;
	DWORD m_dwCoInitFlags;

protected:
    CAMEvent m_EventSend;
    HANDLE m_hThread;

    // thread will run this function on startup
    // must be supplied by derived class
    virtual DWORD ThreadProc() = 0;

public:
    CBaseThread(DWORD dwFlags = COINIT_DISABLE_OLE1DDE) :  // standard dshow behavior
		m_EventSend(TRUE),     // must be manual-reset for CheckRequest()
		m_dwCoInitFlags(dwFlags) 
	{
		m_hThread = NULL;
	}

	virtual ~CBaseThread() {
		Close();
	}

    CCritSec m_AccessLock;	// locks access by client threads
    CCritSec m_WorkerLock;	// locks access to shared objects

    // thread initially runs this. param is actually 'this'. function
    // just gets this and calls ThreadProc
    static DWORD WINAPI InitialThreadProc(LPVOID pv);

    // start thread running  - error if already running
    BOOL Create();

    // signal the thread, and block for a response
    //
    DWORD CallWorker(DWORD);

    // accessor thread calls this when done with thread (having told thread
    // to exit)
    void Close() {
        HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0);
        if (hThread) {
			for (;;) {
				DWORD rc = MsgWaitForMultipleObjectsEx(1, &hThread, INFINITE, QS_ALLEVENTS, 0);
				if (rc == WAIT_OBJECT_0) {
					break;
				} else {
					// pump messages so com runs
					MSG msg;
					while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
						TranslateMessage(&msg);
						DispatchMessage(&msg);
					}
				}
			}

            CloseHandle(hThread);
        }
    };

    // ThreadExists
    // Return TRUE if the thread exists. FALSE otherwise
    BOOL ThreadExists(void) const
    {
        if (m_hThread == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

#if 0
    // wait for the next request
    DWORD GetRequest();
#endif 

    // is there a request?
    BOOL CheckRequest(DWORD * pParam);

    // reply to the request
    void Reply(DWORD);

    // If you want to do WaitForMultipleObjects you'll need to include
    // this handle in your wait list or you won't be responsive
    HANDLE GetRequestHandle() const { return m_EventSend; };

    // Find out what the request was
    DWORD GetRequestParam() const { return m_dwParam; };

    // call CoInitializeEx (COINIT_DISABLE_OLE1DDE) if
    // available. S_FALSE means it's not available.
    static HRESULT CoInitializeHelper(DWORD dwCoInitFlags);
};

///////////////////////////////////////

class CRegExThread : public CBaseThread {
public:
	typedef enum OP {
		RETHREAD_NOREQUEST,
		RETHREAD_CREATEREGEX,
		RETHREAD_EXIT,
	} OP;
	
private:	
	virtual DWORD ThreadProc(void) {
		for (;;) {
			OP req = GetRequest();
			switch (req) {
			case RETHREAD_CREATEREGEX: {
				HRESULT hr = CreateRegEx();
				Reply(hr);
				if (FAILED(hr)) {
					goto exit_thread;
				}
				break;
			} case RETHREAD_EXIT:
				Reply(NOERROR);
				goto exit_thread;
			};
		};
exit_thread:
		CAutoLock lock(&m_WorkerLock);
		if (m_pGIT && m_dwCookie) {
			m_pGIT->RevokeInterfaceFromGlobal(m_dwCookie);
			m_dwCookie = 0;
			m_pGIT.Release();
		}
		return 0;
	}

	OP GetRequest() {
		HANDLE h = GetRequestHandle();
		for (;;) {
			DWORD rc = MsgWaitForMultipleObjectsEx(1, &h, INFINITE, QS_ALLEVENTS, 0);
			if (rc == WAIT_OBJECT_0) {
				return (OP)GetRequestParam();
			} else {
				// pump messages so com runs
				MSG msg;
				while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}
			}

		}
	}

	HRESULT CreateRegEx() {
		CAutoLock lock(&m_WorkerLock);
		if (!m_pGIT) {
			HRESULT hr = m_pGIT.CoCreateInstance(CLSID_StdGlobalInterfaceTable, 0, CLSCTX_INPROC_SERVER);
			if (FAILED(hr)) {
				return hr;
			}
			// this is an expensive object to create.  so, once we have one we hang onto it.
			PQRegExp pRE;
			hr = pRE.CoCreateInstance(__uuidof(RegExp), NULL, CLSCTX_INPROC);
			if (FAILED(hr)) {
				return hr;
			}
			hr = pRE->put_IgnoreCase(VARIANT_TRUE);
			if (FAILED(hr)) {
				return hr;
			}
			hr = pRE->put_Global(VARIANT_TRUE);
			if (FAILED(hr)) {
				return hr;
			}
			ASSERT(!m_dwCookie);
			hr = m_pGIT->RegisterInterfaceInGlobal(pRE, __uuidof(IRegExp), &m_dwCookie);
			if (FAILED(hr)) {
				return hr;
			}
		}
		ASSERT(m_pGIT);
		ASSERT(m_dwCookie);
		return NOERROR;
	}

	PQGIT m_pGIT;
	DWORD m_dwCookie;
public:
	CRegExThread() : 
		CBaseThread(COINIT_APARTMENTTHREADED),
	    m_dwCookie(0)
			{}
	~CRegExThread() {
		CallWorker(RETHREAD_EXIT);
		Close();
	}
	DWORD GetCookie() {
		CAutoLock lock(&m_WorkerLock);
		return m_dwCookie;
	}
};  // class CRegExThread


}; // namespace BDATuningModel
 
#endif //__RegExThread_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSVidCtl.rc
//
#include "msvidctlerrors.h"
#define IDS_PROJNAME                    100
#define IDB_VidCtl                      101
#define MESSAGETABLE                    102
#define IDS_INPUTDEVICES_PROGID         243
#define IDS_OUTPUTDEVICES_PROGID        244
#define IDS_VIDEORENDERERS_PROGID       245
#define IDS_AUDIORENDERERS_PROGID       246
#define IDS_FEATURES_PROGID             247
#define IDS_INPUTDEVICES_DESCRIPTION    248
#define IDS_OUTPUTDEVICES_DESCRIPTION   249
#define IDS_VIDEORENDERERS_DESCRIPTION  250
#define IDS_AUDIORENDERERS_DESCRIPTION  251
#define IDS_FEATURES_DESCRIPTION        252
#define IDS_MUTNAME                     253
#define IDS_TSREGKEY                    254
#define IDS_REG_TUNEROBJ                1024
#define IDS_REG_COMPONENTTYPE_PROGID    1025
#define IDS_REG_COMPONENTTYPE_DESC      1026
#define IDS_REG_COMPONENT_PROGID        1027
#define IDS_REG_COMPONENT_DESC          1028
#define IDS_REG_COMPOSITION_DESC        1029
#define IDS_REG_AUDIORENDERER_PROGID    1030
#define IDS_REG_AUDIORENDERER_DESC      1031
#define IDS_REG_BDATUNER_PROGID         1032
#define IDS_REG_BDATUNER_DESC           1033
#define IDS_REG_CREATEREGBAG_DESC       1034
#define IDS_REG_FILEPLAYBACK_PROGID     1035
#define IDS_REG_FILEPLAYBACK_DESC       1036
#define IDS_REG_TVTUNER_PROGID          1037
#define IDS_REG_TVTUNER_DESC            1038
#define IDS_REG_VIDEORENDERER_PROGID    1039
#define IDS_REG_VIDEORENDERER_DESC      1040
#define IDS_REG_TUNINGSPACECONTAINER_PROGID 1041
#define IDS_REG_TUNINGSPACECONTAINER_DESC 1042
#define IDS_REG_CHANNELTUNEREQUEST_PROGID 1043
#define IDS_REG_CHANNELTUNEREQUEST_DESC 1044
#define IDS_REG_ATSCCHANNELTUNEREQUEST_PROGID 1045
#define IDS_REG_ATSCCHANNELTUNEREQUEST_DESC 1046
#define IDS_REG_COMPONENTTYPES_PROGID   1047
#define IDS_REG_COMPONENTTYPES_DESC     1048
#define IDS_REG_TVPROTOCOL_DESC         1049
#define IDS_REG_ANACAPCOMP_DESC         1050
#define IDS_REG_ANADATACOMP_DESC        1051
#define IDS_REG_DATASERVICES_PROGID     1052
#define IDS_REG_DATASERVICES_DESC       1053
#define IDS_REG_ATSCTUNINGSPACE_PROGID  1054
#define IDS_REG_ATSCTUNINGSPACE_DESC    1055
#define IDS_REG_ANALOGTVTS_PROGID       1056
#define IDS_REG_ANALOGTVTS_DESC         1057
#define IDS_REG_ANALOGRADIOTS_PROGID    1058
#define IDS_REG_ANALOGRADIOTS_DESC      1059
#define IDS_REG_LANGUAGECOMPONENTTYPE_PROGID 1060
#define IDS_REG_LANGUAGECOMPONENTTYPE_DESC 1061
#define IDS_REG_ATSCLOCATOR_PROGID      1062
#define IDS_REG_ATSCLOCATOR_DESC        1063
#define IDS_REG_MPEG2COMPONENTTYPE_PROGID 1064
#define IDS_REG_MPEG2COMPONENTTYPE_DESC 1065
#define IDS_REG_ATSCCOMPONENTTYPE_PROGID 1066
#define IDS_REG_ATSCCOMPONENTTYPE_DESC  1067
#define IDS_REG_MPEG2COMPONENT_PROGID   1068
#define IDS_REG_MPEG2COMPONENT_DESC     1069
#define IDS_REG_DVBTLOCATOR_PROGID      1070
#define IDS_REG_DVBTLOCATOR_DESC        1071
#define IDS_REG_DVBSLOCATOR_PROGID      1072
#define IDS_REG_DVBSLOCATOR_DESC        1073
#define IDS_REG_DVBTUNEREQUEST_PROGID   1074
#define IDS_REG_DVBTUNEREQUEST_DESC     1075
#define IDS_REG_DVBTUNINGSPACE_PROGID   1076
#define IDS_REG_DVBTUNINGSPACE_DESC     1077
#define IDS_TSKEYNAMEVAL                1078
#define IDS_RGSLIST_TYPE                1079
#define IDS_TUNINGSPACE_FRAGMENT_TYPE   1080
#define IDS_REG_MSVIDWEBDVD_PROGID      1081
#define IDS_REG_MSVIDWEBDVD_DESC        1082
#define IDS_REG_WEBDVDCOMP_DESC         1083
#define IDS_REG_DVDEVENTHANDLER_PROGID  1084
#define IDS_REG_DVDEVENTHANDLER_DESC    1085
#define IDS_REG_MSVIDWEBDVDADM_PROGID   1086
#define IDS_REG_MSVIDWEBDVDADM_DESC     1087
#define IDS_REG_CLOSEDCAPTIONING_PROGID 1088
#define IDS_REG_CLOSEDCAPTIONING_DESC   1089
#define IDS_REG_DVDPROTOCOL_DESC        1090
#define IDS_REG_MSEVENTBINDER_PROGID    1091
#define IDS_REG_MSEVENTBINDER_DESC      1092
#define IDS_REG_DVBSTUNINGSPACE_PROGID  1093
#define IDS_REG_DVBSTUNINGSPACE_DESC    1094
#define IDS_REG_TRIGGERPROTOCOL_DESC    1095
#define IDS_REG_LIDPROTOCOL_DESC        1096
#define IDS_REG_MSVIDSTREAMBUFFERSINK_PROGID 1097
#define IDS_REG_MSVIDSTREAMBUFFERSINK_DESC 1098
#define IDS_REG_MSVIDSTREAMBUFFERRECORDINGCONTROL_PROGID 1099
#define IDS_REG_MSVIDSTREAMBUFFERRECORDINGCONTROL_DESC 1100
#define IDS_REG_MSVIDSTREAMBUFFERSOURCE_PROGID 1101
#define IDS_REG_MSVIDSTREAMBUFFERSOURCE_DESC   1102
#define IDS_REG_AUXINTS_PROGID          1103
#define IDS_REG_AUXINTS_DESC            1104
#define IDR_CANONICAL_TUNINGSPACE_LIST  5128
#define IDR_CANONICAL_ANALOG_CABLE      5129
#define IDR_CANONICAL_ANALOG_ANTENNA    5130
#define IDR_CANONICAL_ATSC              5131
#define IDR_CANONICAL_OPEN_CABLE        5132
#define IDS_REG_MP2CCCOMP_DESC          5133
#define IDS_REG_VIDRECT_DESC            5134
#define IDS_REG_MPEG2TUNEREQUEST_DESC   5135
#define IDS_REG_MPEG2TUNEREQUEST_PROGID 5136
#define IDS_REG_MPEG2TUNEREQUESTFACTORY_DESC   5137
#define IDS_REG_MPEG2TUNEREQUESTFACTORY_PROGID 5138
#define IDS_REG_VIDCTL_PROGID           5139
#define IDS_REG_VIDCTL_DESC		        5140
#define IDS_REG_ANASINCOMP_DESC         5141
#define IDS_REG_MP2SINCOMP_DESC         5142
#define IDS_REG_FP2VRCOMP_DESC	    	5143
#define IDS_REG_WEBDVDARCOMP_DESC       5144
#define IDS_REG_ENCODER_DESC            5145
#define IDS_REG_ENCODER_PROGID          5146
#define IDS_REG_XDS_PROGID              5147
#define IDS_REG_XDS_DESC                5148
#define IDS_REG_DAT2XDSCOMP_DESC        5149
#define IDS_REG_DAT2SINCOMP_DESC        5150
#define IDS_REG_ENC2SINCOMP_DESC        5151
#define IDR_CANONICAL_AUXIN1            5152
#define IDS_REG_ANA2XDSCOMP_DESC        5153
#define IDS_REG_ANA2ENCCOMP_DESC        5154
#define IDS_REG_FP2ARCOMP_DESC          5155
#define IDS_REG_SBES2CC_DESC            5156
#define IDS_REG_SBES2VMR_DESC           5157
#define IDS_DVD_LANGFIRST               10000
#define IDS_DVD_LANG1   1+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG2   2+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG3   3+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG4   4+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG5   5+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG6   6+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG7   7+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG8   8+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG9    9+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG10   10+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG11   11+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG12   12+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG13   13+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG14   14+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG15   15+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG16   16+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG17   17+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG18   18+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG19   19+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG20   20+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG21   21+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG22   22+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG23   23+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG24   24+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG25   25+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG26   26+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG27   27+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG28   28+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG29   29+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG30   30+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG31   31+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG32   32+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG33   33+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG34   34+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG35   35+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG36   36+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG37   37+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG38   38+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG39   39+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG40   40+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG41   41+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG42   42+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG43   43+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG44   44+IDS_DVD_LANGFIRST

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        255
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         255
#define _APS_NEXT_SYMED_VALUE           126
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\rgsbag.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// CRGSBag.cpp : Implementation for Read Only property bag on .RGS script fragment
// Copyright (c) Microsoft Corporation 2000.

#include "stdafx.h"
#include "rgsbag.h"

using namespace ::ATL::ATL;

CRGSBag::CRGSBag(LPCTSTR szRGS, CRegObject& croi, int& cchEaten) : CRegParser(&croi) {
	TCHAR   szToken[MAX_VALUE];
	HRESULT hr = S_OK;

	LPTSTR szReg = NULL;
	hr = PreProcessBuffer(szRGS, &szReg);
	if (FAILED(hr)) {
		THROWCOM(hr);
	}

#if defined(_DEBUG) && defined(DEBUG_REGISTRATION)
	OutputDebugString(szReg); //would call ATLTRACE but szReg is > 512 bytes
	OutputDebugString(_T("\n"));
#endif //_DEBUG

    szToken[0] = 0;
	m_pchCur = szReg;
	cchEaten = 0;

	try {
		while (NULL != *m_pchCur && chRightBracket != *szToken) {
			if (FAILED(hr = NextToken(szToken))) {
				break;
			}
			if (chLeftBracket != *szToken)
			{
				ATLTRACE2(atlTraceRegistrar, 0, _T("Syntax error, expecting a {, found a %s\n"), szToken);
				hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);
                THROWCOM(hr);
			}
			hr = BuildMapFromFragment(szToken);
			if (FAILED(hr)) {
                THROWCOM(hr);
			}
		}
	    if (NULL != *m_pchCur) {
		    m_pchCur = CharNext(m_pchCur);  // eat the }
	    }
	    cchEaten = m_pchCur - szReg;
        if (szReg) {
		    CoTaskMemFree(szReg);
            szReg = NULL;
        }
	} catch(ComException &e) {
        if (szReg) {
		    CoTaskMemFree(szReg);
            szReg = NULL;
        }
		throw;
	}
}

HRESULT CRGSBag::BuildMapFromFragment(LPTSTR pszToken) {
	HRESULT hr = S_OK;

	if (FAILED(hr = NextToken(pszToken)))
		return hr;


	while (*pszToken != chRightBracket) // Continue till we see a }
	{
		TCHAR  szValueName[MAX_VALUE];
		CComVariant v;
		if (!lstrcmpi(pszToken, szValToken)) // need to add a value to hkParent
		{

			if (FAILED(hr = NextToken(szValueName)))
				break;
			if (FAILED(hr = NextToken(pszToken)))
				break;


			if (*pszToken != chEquals)
				return GenerateError(E_ATL_EXPECTING_EQUAL);

			hr = GetValue(v);
			if (FAILED(hr)) {
				return hr;
			}
		} else {
			if (StrChr(pszToken, chDirSep) != NULL)
				return GenerateError(E_ATL_COMPOUND_KEY);

			lstrcpyn(szValueName, pszToken, sizeof(szValueName) / sizeof(TCHAR));

			hr = GetObject(v);
			if (FAILED(hr)) {
				return hr;
			}
		}
		m_mapBag[szValueName] = v;
		if (FAILED(hr = NextToken(pszToken)))
			break;
	}

	return hr;
}

HRESULT CRGSBag::GetObject(CComVariant& val) {
	ASSERT(val.vt == VT_EMPTY || val.vt == VT_NULL);
	val.vt = VT_UNKNOWN;
	val.punkVal = NULL;
	HRESULT hr;
	TCHAR   szToken[MAX_VALUE];
	if (FAILED(hr = NextToken(szToken)))
		return hr;

	if (*szToken != chEquals) {
		return GenerateError(E_ATL_EXPECTING_EQUAL);
	}
	// currently we're just expecting a guid here with no type specifier(s'')
	// we should really take genuine .rgs syntax and report an error if it isn't a string
	if (FAILED(hr = NextToken(szToken))) {
		return GenerateError(CO_E_CLASSSTRING);
	}
	USES_CONVERSION;
	GUID2 clsid(T2COLE(szToken));
	PUnknown pobj(clsid, NULL, CLSCTX_INPROC_SERVER);
	if (!pobj) {
		return REGDB_E_CLASSNOTREG;
	}
	hr = LoadPersistedObject<PQPropertyBag2, PQPersistPropertyBag2> (pobj, *m_pRegObj, &m_pchCur);
	if (FAILED(hr)) {
		hr = LoadPersistedObject<PQPropertyBag, PQPersistPropertyBag> (pobj, *m_pRegObj, &m_pchCur);
		if (FAILED(hr)) {
			return hr;
		}
	}
	val.punkVal = pobj;
	(val.punkVal)->AddRef();

	return NOERROR;
}

HRESULT CRGSBag::GetValue(CComVariant &val) {
	USES_CONVERSION;
	HRESULT hr;

	VARTYPE     vt;
	LONG        lRes = ERROR_SUCCESS;
	UINT        nIDRes = 0;

	TCHAR*       pszToken = new TCHAR[MAX_TYPE];
    if (!pszToken) {
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr = NextToken(pszToken))) {
        delete[] pszToken;
		return hr;
    }
	if (!VTFromRegType(pszToken, vt))
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("%s Type not supported\n"), pszToken);
        delete[] pszToken;
		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);
	}

    if (FAILED(hr = NextToken(pszToken))) {
        delete[] pszToken;
		return hr;
    }

	switch (vt)
	{
	case VT_BSTR:
		val.vt = VT_BSTR;
        ASSERT(val.bstrVal == NULL);
		val.bstrVal = ::SysAllocString(T2OLE(pszToken));
		break;
	case VT_UI4:
#ifdef _WIN64
		ATLASSERT(FALSE);
		val.ulVal = 0;
#pragma message( "Still need win64 version of VarUI4FromStr()." )
#else
		VarUI4FromStr(T2OLE(pszToken), 0, 0, &val.ulVal);
#endif
		val.vt = VT_UI4;
		break;
	case VT_UI1:
		{
			int cbValue = lstrlen(pszToken);
			if (cbValue & 0x00000001)
			{
				ATLTRACE2(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));
                delete[] pszToken;
				return E_FAIL;
			}
			int cbValDiv2 = cbValue/2;
			int cbLen = cbValDiv2 * sizeof(BYTE);
			BYTE* rgBinary = new BYTE[cbLen];
            if (!rgBinary) {
                delete[] pszToken;
                return E_OUTOFMEMORY;
            }
			memset(rgBinary, 0, cbValDiv2);
            if (rgBinary == NULL) {
                delete[] rgBinary;
                delete[] pszToken;
				return E_FAIL;
            }
			for (int irg = 0; irg < cbValue; irg++)
				rgBinary[(irg/2)] |= (ChToByte(pszToken[irg])) << (4*(1 - (irg & 0x00000001)));
			val.vt = VT_BSTR;
			val.bstrVal = ::SysAllocStringByteLen(reinterpret_cast<LPSTR>(rgBinary), cbLen);
            delete[] rgBinary;
			break;
		}
	}
    delete[] pszToken;

	return S_OK;
}


// end of file - crgsbag.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\sbes2cc.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing analog capture to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef SBES2CC_H
#define SBES2CC_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols
#include <objectwithsiteimplsec.h>
#include "dsextend.h"

/////////////////////////////////////////////////////////////////////////////
// CSbeS2CCComp
class ATL_NO_VTABLE __declspec(uuid("9193A8F9-0CBA-400e-AA97-EB4709164576")) CSbeS2CCComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSbeS2CCComp, &__uuidof(CSbeS2CCComp)>,
    public IObjectWithSiteImplSec<CSbeS2CCComp>,
	public IMSVidCompositionSegmentImpl<CSbeS2CCComp>
{
public:
    CSbeS2CCComp() {}
    virtual ~CSbeS2CCComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_SBES2CC_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CSbeS2CCComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSbeS2CCComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()

public:

	PQCreateDevEnum m_pSystemEnum;

	//////////////

// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        VIDPERF_FUNC;
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            TRACELM(TRACE_ERROR, "CSbeS2CCComp::Compose()");
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
			if (upstream == downstream) {
		 	    return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(CSbeS2CCComp), E_INVALIDARG);
			}
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CSbeS2CCComp::Compose() can't compose empty up segment");
		 	    return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CSbeS2CCComp::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
		 	    return NOERROR;
            }
            // do the list backwards
            DSFilterList upF;
/*            for(VWGraphSegment::iterator upStart = up.begin(); upStart != up.end(); ++upStart){
                upF.push_back(*upStart);
            }
  */
            DSMediaType mtL21(MEDIATYPE_AUXLine21Data, MEDIASUBTYPE_Line21_BytePair);

            for (VWGraphSegment::iterator iStart = up.begin(); iStart != up.end(); ++iStart) {
                ASSERT((*iStart).GetGraph() == m_pGraph);
                DSFilter::iterator iPins;
                for(iPins = (*iStart).begin(); iPins != (*iStart).end(); ++iPins){
                    DSPin::iterator iMedias;
                    for(iMedias = (*iPins).begin(); iMedias != (*iPins).end(); ++iMedias){
                        if(mtL21 == (*iMedias)){
                            break;
                        }
                    }
                    if(iMedias != (*iPins).end()){
                        break;
                    }
                }
                if(iPins == (*iStart).end()){
                    continue;
                }
				for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++iStop) {
					ASSERT((*iStop).GetGraph() == m_pGraph);
					DSFilter pStart(*iStart);
					DSFilter pStop(*iStop);
					HRESULT hr = m_pGraph.Connect(pStart, pStop, m_Filters);
                    if (SUCCEEDED(hr)) {
						m_Segments.push_back(up);
						m_Segments.push_back(down);
						m_pDown = m_Segments.end();
						--m_pDown;
						m_pUp = m_pDown;
						--m_pUp;
						m_fComposed = true;
						return NOERROR;
					}
				}
			}
            TRACELM(TRACE_ERROR, "CSbeS2CCComp::Compose() compose didn't connect anything");
	 	    return S_FALSE;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // SBES2CC_H
// end of file - SBES2CC.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\rgsbag.h ===
/////////////////////////////////////////////////////////////////////////////////////
// RGSBag.h : Declaration of the CRGSBag
// Copyright (c) Microsoft Corporation 2000.
//
// small internal class to provide readonly IPropertyBag access to a string containing
// an atl .rgs fragment

#ifndef __RGSBAG_H_
#define __RGSBAG_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include <propertybag2impl.h>

namespace BDATuningModel {

using ::ATL::ATL::CRegObject;
using ::ATL::ATL::CRegParser;
        
/////////////////////////////////////////////////////////////////////////////
// CRGSBag
class ATL_NO_VTABLE DECLSPEC_UUID("7B3CAA7B-5E78-4797-95F7-BDA2FCD807A2") CRGSBagBase : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CRGSBagBase, &__uuidof(CRGSBagBase)>,
    public IObjectWithSiteImplSec<CRGSBagBase>,
	public IPropertyBag2Impl<CRGSBagBase>,
	public IPropertyBag
{
public:
    CRGSBagBase() {}
    virtual ~CRGSBagBase() {
        m_mapBag.clear();
    }

DECLARE_NOT_AGGREGATABLE(CRGSBagBase)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRGSBagBase)
	COM_INTERFACE_ENTRY(IPropertyBag2)
	COM_INTERFACE_ENTRY(IPropertyBag)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

// IPropertyBag2
public:

// IPropertyBag
    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) {
		if (!pVar) {
			return E_POINTER;
		}
		try {
			CString csKey(pszPropName);
			ATL_LOCK();
			RGSBag_t::iterator i = m_mapBag.find(csKey);
			if (i == m_mapBag.end()) {
				return HRESULT_FROM_WIN32(ERROR_UNKNOWN_PROPERTY);
			}
			return (*i).second.CopyTo(pVar);
        } CATCHALL();
	}
    STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT *pVar) {
		return E_NOTIMPL;
	}
    
// IPropertyBag2
	STDMETHOD(CountProperties)(ULONG * pcProperties) {
		if (!pcProperties) {
			return E_POINTER;
		}
		try {
			ATL_LOCK();
			*pcProperties = m_mapBag.size();
			return NOERROR;
        } CATCHALL();

	}
	STDMETHOD(GetPropertyInfo)(ULONG iProperty, ULONG cProperties, PROPBAG2 * pPropBag, ULONG * pcProperties) {
		return E_NOTIMPL;
	}
	STDMETHOD(LoadObject)(LPCOLESTR pstrName, ULONG dwHint, IUnknown * pUnkObject, IErrorLog * pErrLog) {
		return E_NOTIMPL;
	}

protected:
    typedef std::map<CString, CComVariant> RGSBag_t;  // id->object mapping, id's not contiguous

    RGSBag_t m_mapBag;

};


class CRGSBag : public CComObject<CRGSBagBase>,
				public CRegParser

{
public:


    CRGSBag(LPCTSTR szRGS, CRegObject& croi, int& cchEaten);  // parse string into map
	HRESULT BuildMapFromFragment(LPTSTR pszToken);
	HRESULT GetObject(CComVariant& val);
	HRESULT GetValue(CComVariant &val);

};

template<class BAGTYPE, class PERSISTTYPE> HRESULT LoadPersistedObject(PUnknown& pobj, CRegObject& cro, TCHAR** ppchCur) {
	HRESULT hr = NOERROR;
    try {
	    PERSISTTYPE pPersistObj(pobj);
	    if (!pPersistObj) {
		    return E_NOINTERFACE;
	    }
	    hr = pPersistObj->InitNew();
	    if (FAILED(hr) && hr != E_NOTIMPL) {
		    return hr;
	    }
	    int cchEaten = 0;
	    BAGTYPE pBag(new CRGSBag(*ppchCur, cro, cchEaten));
	    if (!pBag) {
		    return E_OUTOFMEMORY;
	    }
	    *ppchCur += cchEaten;
        hr = pPersistObj->Load(pBag, NULL);
        if (FAILED(hr)) {
            delete pBag;
            return hr;
        }
	    return hr;
    } CATCHALL();
};


}; // namespace
 
#endif //__RGSBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\regexthread.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// RegExThread.cpp : Implementation of CRegExThread
// Copyright (c) Microsoft Corporation 1999.

#include "stdafx.h"
#include "RegExThread.h"

namespace BDATuningModel {


// --- CBaseThread ----------------------




// when the thread starts, it calls this function. We unwrap the 'this'
//pointer and call ThreadProc.
DWORD WINAPI
CBaseThread::InitialThreadProc(LPVOID pv)
{
    CBaseThread * pThread = (CBaseThread *) pv;

    HRESULT hrCoInit = CBaseThread::CoInitializeHelper(pThread->m_dwCoInitFlags);
    if(FAILED(hrCoInit)) {
        return hrCoInit;
    }


    HRESULT hr = pThread->ThreadProc();

    if(SUCCEEDED(hrCoInit)) {
        CoUninitialize();
    }

    return hr;
}

BOOL
CBaseThread::Create()
{
    DWORD threadid;

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {
	return FALSE;
    }

    m_hThread = CreateThread(
		    NULL,
		    0,
		    CBaseThread::InitialThreadProc,
		    this,
		    0,
		    &threadid);

    if (!m_hThread) {
	return FALSE;
    }

    return TRUE;
}

DWORD
CBaseThread::CallWorker(DWORD dwParam)
{
    // lock access to the worker thread for scope of this object
    CAutoLock lock(&m_AccessLock);

    if (!ThreadExists()) {
		return (DWORD) E_FAIL;
    }

    // set the parameter
    m_dwParam = dwParam;

	m_dwReturnVal = 0;
    // signal the worker thread
    m_EventSend.Set();

    // wait for the completion to be signalled or the thread to terminate
	HANDLE h[2];
	h[0] = m_EventComplete;
	h[1] = m_hThread;
	DWORD rc = WaitForMultipleObjects(2, h, 0, INFINITE);

    // done - this is the thread's return value
    return m_dwReturnVal;
}


#if 0
// Wait for a request from the client
DWORD
CBaseThread::GetRequest()
{
    m_EventSend.Wait();
    return m_dwParam;
}
#endif

// is there a request?
BOOL
CBaseThread::CheckRequest(DWORD * pParam)
{
    if (!m_EventSend.Check()) {
	return FALSE;
    } else {
	if (pParam) {
	    *pParam = m_dwParam;
	}
	return TRUE;
    }
}

// reply to the request
void
CBaseThread::Reply(DWORD dw)
{
    m_dwReturnVal = dw;

    // The request is now complete so CheckRequest should fail from
    // now on
    //
    // This event should be reset BEFORE we signal the client or
    // the client may Set it before we reset it and we'll then
    // reset it (!)

    m_EventSend.Reset();

    // Tell the client we're finished

    m_EventComplete.Set();
}

HRESULT CBaseThread::CoInitializeHelper(DWORD dwCoInitFlags)
{
    // call CoInitializeEx and tell OLE not to create a window (this
    // thread probably won't dispatch messages and will hang on
    // broadcast msgs o/w).
    //
    // If CoInitEx is not available, threads that don't call CoCreate
    // aren't affected. Threads that do will have to handle the
    // failure. Perhaps we should fall back to CoInitialize and risk
    // hanging?
    //

    // older versions of ole32.dll don't have CoInitializeEx

    HRESULT hr = E_FAIL;
    HINSTANCE hOle = GetModuleHandle(TEXT("ole32.dll"));
    if(hOle)
    {
        typedef HRESULT (STDAPICALLTYPE *PCoInitializeEx)(
            LPVOID pvReserved, DWORD dwCoInit);
        PCoInitializeEx pCoInitializeEx =
            (PCoInitializeEx)(GetProcAddress(hOle, "CoInitializeEx"));
        if(pCoInitializeEx)
        {
            hr = (*pCoInitializeEx)(NULL, dwCoInitFlags);
        }
    }

    return hr;
}


// end of private copy of dshow stuff

};
// end of file - RegExThread.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\sbesinkcp.h ===
// Copyright (c) 1999-2002  Microsoft Corporation.  All Rights Reserved.

#pragma once 

#ifndef _SBESINKCP_H_
#define _SBESINKCP_H_

#include <deviceeventimpl.h>

template <class T, const IID* piid = &IID_IMSVidStreamBufferSinkEvent, class CDV = CComDynamicUnkArray>
class CProxy_StreamBufferSinkEvent : public CProxy_DeviceEvent<T, piid, CDV>
{
public:
	void Fire_CertificateFailure() { Fire_VoidMethod(eventidSinkCertificateFailure); }
	void Fire_CertificateSuccess() { Fire_VoidMethod(eventidSinkCertificateSuccess); }
    void Fire_WriteFailure() { Fire_VoidMethod(eventidWriteFailure); }

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\sbes2vmr.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing sbe source to the vmr
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef SBES2VMR_H
#define SBES2VMR_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols
#include <objectwithsiteimplsec.h>
#include "dsextend.h"

/////////////////////////////////////////////////////////////////////////////
// CSbeS2VmrComp
class ATL_NO_VTABLE __declspec(uuid("3C4708DC-B181-46a8-8DA8-4AB0371758CD")) CSbeS2VmrComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSbeS2VmrComp, &__uuidof(CSbeS2VmrComp)>,
    public IObjectWithSiteImplSec<CSbeS2VmrComp>,
	public IMSVidCompositionSegmentImpl<CSbeS2VmrComp>
{
public:
    CSbeS2VmrComp() {}
    virtual ~CSbeS2VmrComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_SBES2VMR_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CSbeS2VmrComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSbeS2VmrComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()

public:

	PQCreateDevEnum m_pSystemEnum;

	//////////////

// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        VIDPERF_FUNC;
        TRACELM(TRACE_ERROR, "CSbeS2VmrComp::Compose()");
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (upstream == downstream) {
                return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(IMSVidCompositionSegment), E_INVALIDARG);
            }
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CSbeS2VmrComp::Compose() can't compose empty up segment");
                return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CSbeS2VmrComp::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
                return NOERROR;
            }
//            bool vidFound = false;
            // VMR has a bug so we need to connect the video before the cc or no cc will be displayed
            DSMediaType mtVideo(MEDIATYPE_Video);
            for (VWGraphSegment::iterator iStart = up.begin(); iStart != up.end(); ++iStart) {
                ASSERT((*iStart).GetGraph() == m_pGraph);
                for(DSFilter::iterator i = (*iStart).begin(); i != (*iStart).end(); ++i){
                    if((*i).GetDirection() == DOWNSTREAM){
                        for(DSPin::iterator p = (*i).begin(); p != (*i).end(); ++p){ 
                            if((*p) == mtVideo){
                                HRESULT hr = E_FAIL;
                                for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++ iStop) {
                                    ASSERT((*iStop).GetGraph() == m_pGraph);
                                    DSFilter pStop(*iStop);
                                    hr = (*i).IntelligentConnect(pStop, m_Filters);
                                    if(SUCCEEDED(hr)){
                                        return NOERROR;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            TRACELM(TRACE_ERROR, "CSbeS2VmrComp::Compose() compose didn't connect anything");
            return VFW_E_NO_DECOMPRESSOR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
        
	}
};

#endif // SBES2VMR_H
// end of file - SBES2VMR.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\segmentp.c ===
#ifndef TUNING_MODEL_ONLY
#include <segment_p.c>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>

#include <trace.cpp>
#include <initguid.h>
#ifndef TUNING_MODEL_ONLY
#include <encdec.h>
#ifdef BUILD_WITH_DRM
#include "DRMSecure.h"
#endif
#endif
// moved *_i.c to strmiids.lib
//nclude <regbag_i.c>
//nclude <MSVidctl_i.c>
//nclude <segment_i.c>
//nclude <tuner_i.c>

// end of file - stdafx.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B0EDF157_910A_11D2_B632_00C04F79498E__INCLUDED_)
#define AFX_STDAFX_H__B0EDF157_910A_11D2_B632_00C04F79498E__INCLUDED_

#pragma once

#pragma warning(disable: 4786)  // identifier truncated in debug info
#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
//#define _ATL_APARTMENT_THREADED

#define REGISTER_CANONICAL_TUNING_SPACES
#define ENABLE_WINDOWLESS_SUPPORT
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <atltmp.h>
#include <winreg.h>
#include <comcat.h>
#include <objsafe.h>
#ifndef TUNING_MODEL_ONLY
#include <urlmon.h>
#include <shlguid.h>
#endif

#include <algorithm>
#include <functional>
#include <utility>
#include <vector>
#include <list>
#include <map>
#include <comdef.h>

#include <w32extend.h>
#ifndef TUNING_MODEL_ONLY
#include <dsextend.h>
#endif
#include <objreghelp.h>

#include <regbag.h>
#include <MSVidCtl.h>
namespace MSVideoControl {
    typedef CComQIPtr<IMSVidCtl> PQVidCtl;
};
#ifndef TUNING_MODEL_ONLY
using namespace MSVideoControl;
#endif

#include <Tuner.h>
namespace BDATuningModel {
    typedef CComQIPtr<ITuningSpaces> PQTuningSpaces;
    typedef CComQIPtr<ITuningSpace> PQTuningSpace;
    typedef CComQIPtr<ITuneRequest> PQTuneRequest;
    typedef CComQIPtr<IBroadcastEvent> PQBroadcastEvent;
};
using namespace BDATuningModel;

#define ENCRYPT_NEEDED 1

#include "resource.h"
// REV2: this limit should be an non-script accessible property in the tuning space container
// this prevents DNOS attacks from filling the registry/disk with huge tuning space properties
#define MAX_BSTR_SIZE 1024
#define CHECKBSTRLIMIT(x) if (::SysStringByteLen(x) > MAX_BSTR_SIZE) { \
						      return HRESULT_FROM_WIN32(ERROR_DS_OBJ_TOO_LARGE); \
							}								
                          

#endif // !defined(AFX_STDAFX_H__B0EDF157_910A_11D2_B632_00C04F79498E__INCLUDED)
// end of file - stdafx.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\tunerp.c ===
#include <tuner_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\topwin.h ===
/////////////////////////////////////////////////////////////////////////////
// TopWin.h : Declaration of CTopWin, hidden top level window for handling system broadcast messages
// Copyright (c) Microsoft Corporation 1999-2000.


#pragma once

#ifndef __TopWin_H_
#define __TopWin_H_


typedef CWinTraits<WS_OVERLAPPEDWINDOW, WS_EX_NOACTIVATE> HiddenTopTraits;

class CVidCtl;

/////////////////////////////////////////////////////////////////////////////
// CTopWin
class CTopWin : public CWindowImpl<CTopWin, CWindow, HiddenTopTraits> {
public:
	enum {
		WMUSER_INPLACE_ACTIVATE,
        WMUSER_SITE_RECT_WRONG
	};

    CTopWin(CVidCtl *pVidCtli) : m_pVidCtl(pVidCtli) {}
    
    void Init() {
        ASSERT(m_pVidCtl);  // its pointless to create one of these without associating with a main control
        Create(NULL, CRect(), _T("MSVidCtl System Broadcast Message Receiver"));
    }
        
    virtual ~CTopWin() {
        m_pVidCtl = NULL;
    }
        
    // NOTE: since this window is created by the main vidctl its message queue is associated with the appropriate
    // apartment thread for the main vidctl.  thus whoever pumps the main apartment thread will pump this window too.
    // and, thus we're automatically synchronzied with the main vidctl and can simply reflect the significant 
    // messages over to the vidctl itself and be guaranteed that we're getting the same
    // behavior for windowless and windowed since its the same code for both cases.

    virtual BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0);
	void PostInPlaceActivate() {
		PostMessage(WM_USER + WMUSER_INPLACE_ACTIVATE, 0, 0);
	}

private:
    CVidCtl *m_pVidCtl;

};


#endif //__TopWin_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\surface.h ===
/////////////////////////////////////////////////////////////////////////////
// surface.h : surface management utility classes for vidctl
// Copyright (c) Microsoft Corporation 2000.

#pragma once

#ifndef SURFACE_H
#define SURFACE_H

#include <scalingrect.h>

typedef CComPtr<IOleInPlaceFrame> PQFrame;
typedef CComPtr<IOleInPlaceUIWindow> PQUIWin;


class AspectRatio : public CSize {
public:
        AspectRatio(ULONG xi = 0, ULONG yi = 0) : CSize(xi, yi) {
                Normalize();
        }
        AspectRatio(const AspectRatio& ar) : CSize(ar.cx, ar.cy) {}
        AspectRatio(const CRect& ri) : CSize(abs(ri.Width()), abs(ri.Height())) {
			Normalize();
        }
        AspectRatio(LPCRECT ri) : CSize(abs(ri->left - ri->right), 
				  				        abs(ri->top - ri->bottom)) {
			Normalize();
        }

        void Normalize() {
                ULONG d = GCD(abs(cx), abs(cy));
				if (!d) return;
                cx /= d;
                cy /= d;
        }

		// from knuth semi-numerical algorithms p. 321(sort of).
		// since >> on signed isn't guaranteed to be arithmetic in C/C++ we've made some modifications
		ULONG GCD(ULONG a, ULONG b) const {
			ULONG k = 0;
			if (!a) return b;  // by defn
			if (!b) return a;
			while ((!(a & 1)) && (!( b & 1))) {
				_ASSERT((a > 1) && (b > 1));  // since a,b != 0 and even then they must be > 1
				// if a and b are even then gcd(a,b) == 2 * gcd(a/2,b/2), so factor out all the 2s
				++k;
				a >>= 1;
				b >>= 1;
			}
			do {
				_ASSERT(a && b);  // neither can be zero otherwise we'd have returned from the top(1st time)
								  // or fallen out earlier(subsequent iterations)
				_ASSERT((a & 1) || (b & 1)); // at this point either a or b (or both) is odd
				if (!(a & 1) || !(b & 1)) {  // if one of them is even then factor out the 2s
					// since if x is even then gcd(x,y) == gcx(x/2,y)
					ULONG t = (a & 1) ? b : a;
					do {
						_ASSERT(t && (t > 1) && !(t & 1)); // t is even and non-zero(implying t > 1)
						t >>= 1;
					} while (!(t & 1));
					_ASSERT(t && (t & 1)); // t is odd and > 0
					// put t back where we got it from
					if (a & 1) {
						b = t;
					} else {
						a = t;
					}
					_ASSERT((a & 1) && (b & 1));  // they're both odd now
				}
				// replace larger with difference
				// gcd(x, y) == gcd(y, x)
				// gcd(x,y) == gcd(x - y, y)
				if (a > b) {
					a = a - b;
				} else {
					b = b - a;
				}
				_ASSERT(a | b);  // they can't both be 0 or we'd have been done last time through
			} while (a && b);  // if one of the values is 0 then we're done gcd(x,0) == x

			return (a > b ? a : b) << k;
		}

        AspectRatio& operator=(const AspectRatio& rhs) {
            if (&rhs != this) {
                cx = rhs.cx;
                cy = rhs.cy;
            }
			Normalize();
            return *this;
        }
        AspectRatio& operator=(const CRect& rhs) {
			cx = abs(rhs.Width());
			cy = abs(rhs.Height());
			Normalize();
            return *this;
        }
        AspectRatio& operator=(const CSize& rhs) {
            if (&rhs != this) {
			    cx = rhs.cx;
			    cy = rhs.cy;
            }
    	    Normalize();
            return *this;
        }
        AspectRatio& operator=(const LPSIZE rhs) {
            if (rhs != this) {
			    cx = rhs->cx;
			    cy = rhs->cy;
            }
    	    Normalize();
            return *this;
        }
        AspectRatio& operator=(LPCRECT rhs) {
			cx = abs(rhs->left - rhs->right);
			cy = abs(rhs->top - rhs->bottom);
			Normalize();
            return *this;
        }
        bool operator==(const AspectRatio& rhs) const {
                return cx == rhs.cx && cy == rhs.cy;
        }
        bool operator==(const CSize& rhs) const {
                return cx == rhs.cx && cy == rhs.cy;
        }
        bool operator!=(const AspectRatio& rhs) const {
                return !operator==(rhs);
        }
		bool operator!() {
			return !cx && !cy;
		}
        ULONG X() const { return cx; }
        ULONG Y() const { return cy; }
        ULONG X(ULONG xi) {
                cx = xi;
                Normalize();
				return cx;
        }
        ULONG Y(ULONG yi) {
                cy = yi;
                Normalize();
				return cy;
        }
        void XY(ULONG xi, ULONG yi) {
                cx = xi;
                cy = yi;
                Normalize();
        }
};

class SurfaceState : public CScalingRect {
public:
    const static int MIN_RECT_WIDTH = 4;
    const static int MIN_RECT_HEIGHT = 3;

    SurfaceState(const long l = 0,
                 const long t = 0,
                 const long r = 0,
                 const long b = 0,
				 const HWND iOwner = INVALID_HWND,
                 const bool iVis = false,
                 const bool iAspect = true,
                 const bool iSource = false) :
                     CScalingRect(l, t, r, b, iOwner),
                     m_fVisible(iVis),
                     m_fForceAspectRatio(iAspect),
                     m_fForceSourceSize(iSource) {}

    SurfaceState(const CRect& iPos,
                 const HWND iOwner = INVALID_HWND,
                 const bool iVis = false,
                 const bool iAspect = true,
                 const bool iSource = false) :
                         CScalingRect(iPos, iOwner),
                         m_fVisible(iVis),
                         m_fForceAspectRatio(iAspect),
                         m_fForceSourceSize(iSource) {}

    SurfaceState(const CScalingRect& iPos,
                 const bool iVis = false,
                 const bool iAspect = true,
                 const bool iSource = false) :
                         CScalingRect(iPos),
                         m_fVisible(iVis),
                         m_fForceAspectRatio(iAspect),
                         m_fForceSourceSize(iSource) {}

    SurfaceState(const HWND iOwner,
                 const bool iVis = false,
                 const bool iAspect = true,
                 const bool iSource = false) :
                         CScalingRect(iOwner),
                         m_fVisible(iVis),
                         m_fForceAspectRatio(iAspect),
                         m_fForceSourceSize(iSource) {}

    SurfaceState(const PQSiteWindowless& pSite, 
				 const bool iVis = false, 
				 const bool iAspect = true, 
				 const bool iSource = false) : 
                         m_fVisible(iVis),
                         m_fForceAspectRatio(iAspect),
                         m_fForceSourceSize(iSource) {
		Site(pSite);
    }

    SurfaceState(const WINDOWPOS *const wp,                  
				 const bool iAspect = true,
                 const bool iSource = false) :
                         m_fForceAspectRatio(iAspect),
                         m_fForceSourceSize(iSource) {
        ASSERT(!((wp->flags & SWP_SHOWWINDOW) && (wp->flags & SWP_HIDEWINDOW)));
        CScalingRect(CPoint(wp->x, wp->y), CSize(wp->cx, wp->cy));
        if (wp->flags & SWP_SHOWWINDOW) {
                Visible(true);
        } else  if (wp->flags & SWP_HIDEWINDOW) {
                Visible(false);
        }
	    TRACELSM(TRACE_DETAIL, (dbgDump << "SurfaceState::SurfaceState(LPWINDOWPOS) visible = " << m_fVisible), "" );
    }

    SurfaceState& operator=(const SurfaceState& rhs) {
        if (this != &rhs) {
            CScalingRect::operator=(rhs);
            m_fVisible = rhs.m_fVisible;
            m_fForceAspectRatio = rhs.m_fForceAspectRatio;
            m_fForceSourceSize = rhs.m_fForceSourceSize;
        }
        return *this;
    }

	SurfaceState& operator=(const CScalingRect& rhs) {
        if (this != &rhs) {
            CScalingRect::operator=(rhs);
        }
        return *this;
    }

	SurfaceState& operator=(const CRect& rhs) {
        if (this != &rhs) {
            CScalingRect::operator=(rhs);
        }
        return *this;
    }

    bool operator==(const SurfaceState& rhs) const {
            return CRect::operator==(rhs) &&
                    rhs.m_fVisible == m_fVisible &&
                    rhs.m_fForceAspectRatio == m_fForceAspectRatio &&
                    rhs.m_fForceSourceSize == m_fForceSourceSize;
    }
    bool operator !=(const SurfaceState& rhs) const {
            return !operator==(rhs);
    }
    bool operator==(const CScalingRect& rhs) const {
            return CScalingRect::operator==(rhs);
    }
    bool operator !=(const CScalingRect& rhs) const {
            return !operator==(rhs);
    }

    AspectRatio Aspect() const {
        return AspectRatio(*this);
    }

    bool Round(const AspectRatio& ar) {
        bool fChanged = false;
        // at some point we probably want to round the current rectangle to the 
        // nearest rectangle that has the specified aspect ratio
        // i.e. minimize total areal change
        // if we ever round we should take the monitor size into consideration 
        // i.e if we decide to round up and we go off the monitor in either direction
        // then round down instead.

        // for now we're choosing the next size down for ease of coding
        // try narrower first

		TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() ar = " << ar << "this = " << *this), "");
        NormalizeRect();

        // adjust height and width to nearest multiple of x, y to avoid fractional pixel problems
		ASSERT(ar.X() && ar.Y());
        if (Width() % ar.X()) {
            right -= Width() % ar.X();
    		TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() right adjusted to multiple =  " <<  bottom), "");
            fChanged = true;
        }
        if (Height() % ar.Y()) {
            bottom -= Height() % ar.Y();
    		TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() bottom adjusted to multiple =  " <<  bottom), "");
            fChanged = true;
        }
        // force very small rectangles to minimum size;
        if (Width() < MIN_RECT_WIDTH) {
            right = left + ar.X();
            fChanged = true;
    		TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() forcing min width =  " <<  Width()), "");
        }
        if (Height() < MIN_RECT_HEIGHT) {
            bottom = top + ar.Y();
            fChanged = true;
    		TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() forcing min height =  " <<  Height()), "");
        }
        TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() this =  " <<  *this), "");

        if (AspectRatio(this) != ar) {
        	TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() ar(this) x =  " <<  AspectRatio(this).X() 
                                           << " y = " << AspectRatio(this).Y()), "");
        	TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() terms w =  " <<  Width()
                                           << " ratio w = " << ((ar.X() * Height()) / ar.Y())), "");
            long delta = Width();
            delta -= ((ar.X() * Height()) / ar.Y());
        	TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() delta =  " <<  delta), "");
            if (delta > 0) {
                // too wide
                ASSERT( ((Height() / ar.Y()) * ar.Y()) == Height());
                right -= delta / 2;  // distribute adjustment evenly on both sides
                left += delta / 2; // shift so that adjustment is distributed evenly on both sides
                if (delta & 1) {
                    --right;  // if delta is odd distribute the extra on the right
                }
            	TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() was too wide, now this =  " <<  *this), "");
            } else {
                // too tall
                delta = Height();
                delta -= ((ar.Y() * Width()) / ar.X());
            	TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() too tall, now delta =  " <<  delta), "");
                ASSERT(delta > 0);
                ASSERT( ((Width() / ar.X()) * ar.X()) == Width());
                //bottom = (Width() / ar.X()) * ar.Y() + top;
                bottom -= (delta >> 1);
                top += (delta >> 1); // apply half of adjustment on each side
                if (delta & 1) {
                    --bottom; // if delta is odd distribute the extra on the bottom
                }
            	TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() was too tall, now this =  " <<  *this), "");
            }
            fChanged = true;
        }
        TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() complete, this =  " <<  *this << " ar.x = " << AspectRatio(this).X() << " ar.y = " << AspectRatio(this).Y()), "");
        ASSERT(AspectRatio(this) == ar);
        return fChanged;
    }
    bool IsVisible() const { return m_fVisible; }
    void Visible(const bool fVal) {
        if (m_fVisible != fVal) {
            m_fVisible = fVal;
            m_bRequiresSave = true;
        }
    }

    bool ForceAspectRatio() const { return m_fForceAspectRatio; }
    void ForceAspectRatio(const bool fVal) {
        if (m_fForceAspectRatio != fVal) {
            m_fForceAspectRatio = fVal;
            m_bRequiresSave = true;
        }
    }

    bool ForceSourceSize() const { return m_fForceSourceSize; }
    void ForceSourceSize(const bool fVal) {
        if (m_fForceSourceSize != fVal) {
            m_fForceSourceSize = fVal;
            m_bRequiresSave = true;
        }
    }

    void WindowPos(const WINDOWPOS *const wp) {
        ASSERT(!((wp->flags & SWP_SHOWWINDOW) && (wp->flags & SWP_HIDEWINDOW)));
        HWND parent = ::GetParent(Owner());
        CScalingRect newpos(CPoint(wp->x, wp->y), CSize(wp->cx, wp->cy), parent);
        operator=(newpos);
        if (wp->flags & SWP_SHOWWINDOW) {
                Visible(true);
        } else  if (wp->flags & SWP_HIDEWINDOW) {
                Visible(false);
        }
	    TRACELSM(TRACE_DETAIL, (dbgDump << "SurfaceState::SurfaceState(LPWINDOWPOS) visible = " << m_fVisible), "" );
    }

    PQSiteWindowless Site() const { return m_pSiteWndless; }

    void Site(const PQSiteWindowless& pSite) {
        PQFrame pFrame;
	    PQUIWin pDoc;

		// go ahead and reprocess even if site pointer matches existing site because the context may have changed and need
		// to be refreshed(for example we've been deactived and are being reactivated in a different size by the same site
#if 0
		if (m_pSiteWndless.IsEqualObject(static_cast<IUnknown*>(pSite.p))) {
			return;
		}
#endif
        m_pSiteWndless = static_cast<IUnknown*>(pSite.p);  // this forces the correct re-QI since atl improperly casts and overloads its pointer
        if (m_pSiteWndless) {
			CRect rc;
			CRect clip;
			OLEINPLACEFRAMEINFO frameInfo;
            // for some stupid reason none of these parms can be NULL, even if we don't care about them
            HRESULT hr = m_pSiteWndless->GetWindowContext(&pFrame, &pDoc, &rc, &clip, &frameInfo);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "SurfaceState::operator=(InPlaceSite*) can't get window context with frame");
                THROWCOM(hr);
            }
			CRect SiteRect;
			SiteRect.IntersectRect(&rc, &clip);
            HWND hOwner;
            // get container window
            hr = m_pSiteWndless->GetWindow(&hOwner);
            if (FAILED(hr)) {
                hr = pDoc->GetWindow(&hOwner);
                if (FAILED(hr)) {
                    TRACELM(TRACE_DETAIL, "SurfaceState::operator=(InPlaceSite*) can't get doc Owner");
                    hr = pFrame->GetWindow(&hOwner);
                    if (FAILED(hr)) {
                        THROWCOM(hr);
                    }
                }
            }
            ASSERT(::IsWindow(hOwner));
			Owner(hOwner);
			*this = SiteRect;
            TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Site(InPlaceSite*) new rect = " << *this), "");
        } else {
			*this = CScalingRect(0, 0, 0, 0, INVALID_HWND);
        }

        return;		
    }
    // translate a point relative to the owner window to a point relative to the rectangle
    // for this surface
    CPoint XlateOwnerPointToSurfacePoint(CPoint &p) {
        TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Xlate p = " << p.x << ", " << p.y), "");
        CPoint retp(p);
        retp.x -= left;
        retp.y -= top;
        TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Xlate retp = " << retp.x << ", " << retp.y <<                                          " this " << *this), "");
        return retp;
    }
private:
    bool m_fVisible;
    bool m_fForceAspectRatio;
    bool m_fForceSourceSize;
    PQSiteWindowless m_pSiteWndless;
};

#endif
// end of file surface.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\sbesourcecp.h ===
// Copyright (c) 1999-2002  Microsoft Corporation.  All Rights Reserved.

#pragma once 

#ifndef _MSVIDSTREAMBUFFERSOURCECP_H_
#define _MSVIDSTREAMBUFFERSOURCECP_H_

#include "fileplaybackcp.h"

template <class T, const IID* piid = &IID_IMSVidStreamBufferSourceEvent, class CDV = CComDynamicUnkArray>
class CProxy_StreamBufferSourceEvent : public CProxy_FilePlaybackEvent<T, piid, CDV>
{

public:
	void Fire_CertificateFailure() { Fire_VoidMethod(eventidSourceCertificateFailure); }
	void Fire_CertificateSuccess() { Fire_VoidMethod(eventidSourceCertificateSuccess); }
    void Fire_RatingsBlocked() { Fire_VoidMethod(eventidRatingsBlocked); }
    void Fire_RatingsUnblocked() { Fire_VoidMethod(eventidRatingsUnlocked); }
    void Fire_RatingsChanged() { Fire_VoidMethod(eventidRatingsChanged); }
    void Fire_StaleDataRead() { Fire_VoidMethod(eventidStaleDataRead); }
    void Fire_ContentBecomingStale() { Fire_VoidMethod(eventidContentBecomingStale); }
    void Fire_StaleFilesDeleted() { Fire_VoidMethod(eventidStaleFileDeleted); }
    void Fire_TimeHole(long lParam1, long lParam2){
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        CComVariant* pvars = new CComVariant[2];
        int nConnections = m_vec.GetSize();

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                pvars[1] = lParam1;
                pvars[0] = lParam2;
                DISPPARAMS disp = { pvars, NULL, 2, 0 };
                pDispatch->Invoke(eventidDVDNotify, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
        }
        delete[] pvars;

    }

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\topwin.cpp ===
/////////////////////////////////////////////////////////////////////////////
// TopWin.cpp : Implementation of CTopWin, hidden top level window for handling system broadcast messages
// Copyright (c) Microsoft Corporation 1999-2000.


#include <stdafx.h>

#ifndef TUNING_MODEL_ONLY

#include <vrsegimpl.h>
#include "vidctl.h"

BOOL CTopWin::ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID) {
    switch(uMsg) {
    case WM_TIMER:
        //
        // Do something to keep the screen saver from coming alive
        //
        //PostMessage(WM_CHAR,0,0); // didn't work
        //
        // Query the screen saver timeout value and set said value
        // to the value we get.  This should have no real effect,
        // so I can't think of any possible side effects even if
        // this crashes half way through, etc.
        //
        if(m_pVidCtl){
            if(m_pVidCtl->m_State == STATE_PLAY && m_pVidCtl->m_pVideoRenderer){
                CComQIPtr<IMSVidVideoRenderer2> sp_VidVid(m_pVidCtl->m_pVideoRenderer);
                if(sp_VidVid){
                    VARIANT_BOOL effects;
                    HRESULT hr = sp_VidVid->get_SuppressEffects(&effects);
                    if(SUCCEEDED(hr) && effects == VARIANT_TRUE){
                        unsigned int TimeOut;
                        if (SystemParametersInfo(SPI_GETSCREENSAVETIMEOUT, 0, &TimeOut, 0) == 0){
                            TRACELM(TRACE_ERROR, "Could not get screen saver timeout");
                        }
                        else {
                            if (SystemParametersInfo(SPI_SETSCREENSAVETIMEOUT, TimeOut, 0, 0) == 0){
                                TRACELM(TRACE_ERROR,"Cannot set screen saver timeout");
                            }
                            else{
                                TRACELM(TRACE_PAINT,"Successfully reset screen saver timeout");
                            }
                        }
                    }
                }
            }
        }
        // No break...fall through
    case WM_MEDIAEVENT:
    case WM_POWERBROADCAST:
    case WM_DEVICECHANGE:
    case WM_DISPLAYCHANGE:
    // WM_QUERYENDSESSION?
    // WM_ENDSESSION?
        if (m_pVidCtl) {
            return m_pVidCtl->ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, dwMsgMapID);
        }
        break;
	case WM_USER + WMUSER_INPLACE_ACTIVATE:
		if (m_pVidCtl) {
			TRACELM(TRACE_PAINT, "CTopWin::ProcessWindowMessage() InPlaceActivate()");
			m_pVidCtl->InPlaceActivate(OLEIVERB_INPLACEACTIVATE, NULL);
		}
        break;
    case WM_USER + WMUSER_SITE_RECT_WRONG:
		if (m_pVidCtl) {
			TRACELM(TRACE_PAINT, "CTopWin::ProcessWindowMessage() OnSizeChange");
			m_pVidCtl->OnSizeChange();
		}
        break;
    }

    return FALSE;
}

#endif //TUNING_MODEL_ONLY

// end of file - topwin.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\videorenderercp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _MSVIDVIDEORENDERERCP_H_
#define _MSVIDVIDEORENDERERCP_H_

template <class T>
class CProxy_IMSVidVideoRenderer : public CProxy_VRSeg<T, &IID_IMSVidVideoRendererEvent, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:

// TODO: add fileplayback specific events here	
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\vidctl.cpp ===
//===========================================================================
//
// VidCtl.cpp : Implementation of CVidCtl the core viewer control class
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY
#define ENCODERCAT_HACK 1
#include <atlgdi.h>
#include <bdatypes.h>
#include <bdamedia.h>
#include <evcode.h>
#include <wmsdk.h>
#include <wininet.h>
#include "seg.h"
#include "MSVidtvtuner.h"
#include "msvidvideorenderer.h"
#include "msvidwebdvd.h"
#include "VidCtl.h"
#include "msvidsbesink.h"
#include "msvidsbesource.h"
#include "msvidfileplayback.h"
//#include "perfevents.h"

const WCHAR g_kwszDVDURLPrefix[] = L"DVD:";
const WCHAR g_kwszDVDSimpleURL[] = L"DVD";

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidCtl, CVidCtl)

MediaMajorTypeList CVidCtl::VideoTypes;
MediaMajorTypeList CVidCtl::AudioTypes;


#ifndef KSCATEGORY_ENCODER
#define STATIC_KSCATEGORY_ENCODER \
    0x19689bf6, 0xc384, 0x48fd, 0xad, 0x51, 0x90, 0xe5, 0x8c, 0x79, 0xf7, 0xb
DEFINE_GUIDSTRUCT("19689BF6-C384-48fd-AD51-90E58C79F70B", KSCATEGORY_ENCODER);
#define KSCATEGORY_ENCODER DEFINE_GUIDNAMED(KSCATEGORY_ENCODER)
#endif

/////////////////////////////////////////////////////////////////////////////
// CVidCtl

STDMETHODIMP CVidCtl::get_State(MSVidCtlStateList *lState){
    try{
        if(lState){
            *lState = m_State;
            return S_OK;
        }
        return E_POINTER;
    }
    catch(HRESULT hres){
        return hres;
    }   
    catch(...){
        return E_UNEXPECTED;
    }
}

CVidCtl::~CVidCtl() {
    try {
        try {
            if (m_pGraph && !m_pGraph.IsStopped()) {
                Stop();
            }
        } catch(...) {
        }
        m_pSystemEnum.Release();
        m_pFilterMapper.Release();
        DecomposeAll(); // put_Container(NULL) on all the composition segments
        m_pComposites.clear();
        if (m_pInput) {
            PQGraphSegment(m_pInput)->put_Container(NULL);
            m_pInput.Release();
        }
        if (m_pVideoRenderer) {
            PQGraphSegment(m_pVideoRenderer)->put_Container(NULL);
            m_pVideoRenderer.Release();
        }
        if (m_pAudioRenderer) {
            PQGraphSegment(m_pAudioRenderer)->put_Container(NULL);
            m_pAudioRenderer.Release();
        }

        {
            // chosen devices&Outputs
            if (!!m_pOutputsInUse && m_pOutputsInUse.begin() != m_pOutputsInUse.end()) {

                VWOutputDevices::iterator i;
                for (i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
                    if ((*i).punkVal) {
                        PQGraphSegment((*i).punkVal)->put_Container(NULL);
                    }
                }
                m_pOutputsInUse.Release();
            }

        }

        {
            // chosen devices&features
            if(m_pFeaturesInUse && m_pFeaturesInUse.begin() != m_pFeaturesInUse.end()){
                VWFeatures::iterator i;
                for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
                    if ((*i).punkVal) {
                        PQGraphSegment((*i).punkVal)->put_Container(NULL);
                    }
                }
                m_pFeaturesInUse.Release();
            }
        }

        // available collections
        m_pInputs.Release();
        m_pOutputs.Release();
        m_pFeatures.Release();
        m_pVRs.Release();
        m_pARs.Release();

        if (m_fNotificationSet) {
            m_pGraph.SetMediaEventNotificationWindow(0, 0, 0);
        }
        if (m_pGraph) {
            if (m_dwROTCookie) {
                m_pGraph.RemoveFromROT(m_dwROTCookie);
            }
            m_pGraph.Release();
        }
        if (m_pTopWin && m_pTopWin->m_hWnd && ::IsWindow(m_pTopWin->m_hWnd)) {
            m_pTopWin->SendMessage(WM_CLOSE);
            delete m_pTopWin;
            m_pTopWin = NULL;
        }
    } catch (...) {
        TRACELM(TRACE_ERROR, "CVidCtl::~CVidCtl() catch(...)");
    }
}


void CVidCtl::Init()
{
    VIDPERF_FUNC;
    if (m_fInit) return;

    TRACELM(TRACE_DETAIL, "CVidCtl::Init()");
    ASSERT(!m_pGraph);

    m_pGraph = PQGraphBuilder(CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER);
    if (!m_pGraph) {
        TRACELM(TRACE_ERROR, "CVidCtl::Init() can't create graph object");
        THROWCOM(E_UNEXPECTED);
    }
    PQObjectWithSite pos(m_pGraph);
    if (pos) {
        pos->SetSite(static_cast<IMSVidCtl*>(this));
    }

    HRESULT hr =  m_pGraph.AddToROT(&m_dwROTCookie);
    if (FAILED(hr)) {
        m_dwROTCookie = 0;
        TRACELM(TRACE_ERROR, "CVidCtl::Init() can't add graph to ROT");
    }

    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::Init() graph = " << m_pGraph), "");
    SetTimer();
    SetMediaEventNotification();
    if (!m_pSystemEnum) {
        m_pSystemEnum = PQCreateDevEnum(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
        ASSERT(m_pSystemEnum);
    }
    if (!m_pFilterMapper) {
        m_pFilterMapper = m_pGraph;
        ASSERT(m_pFilterMapper);
    }

    m_pFeaturesInUse = static_cast<IMSVidFeatures *>(new CFeatures(false, true));
    m_pOutputsInUse = static_cast<IMSVidOutputDevices *>(new COutputDevices(false, true));
    m_fInit = true;

}


HRESULT CVidCtl::GetInputs(const GUID2& catguid, VWInputDevices& pInputs)
{
    VIDPERF_FUNC;
    //undone: look up category guid to segment object mapping in registry
    // for now we're just hard coding the few we're testing with

    // inputs

    if (catguid == KSCATEGORY_TVTUNER) {
        CInputDevices *pDev = new CInputDevices(true);
        DSDevices TunerList(m_pSystemEnum, catguid);
        DSDevices::iterator i;
        for (i = TunerList.begin(); i != TunerList.end(); ++i) {
            PQGraphSegment p(CLSID_MSVidAnalogTunerDevice);
            if (!p) continue;
            p->put_Init(*i);
            pDev->m_Devices.push_back(PQDevice(p));
        }
        pDev->Valid = true;
        pInputs = static_cast<IMSVidInputDevices *>(pDev);
        return NOERROR;
    } else if (catguid == KSCATEGORY_BDA_NETWORK_PROVIDER || catguid == KSCATEGORY_BDA_NETWORK_TUNER) {
        GUID2 catguid2 = KSCATEGORY_BDA_NETWORK_PROVIDER; 
        CInputDevices *pDev = new CInputDevices(true);
        DSDevices TunerList(m_pSystemEnum, catguid2);
        DSDevices::iterator i;
        for (i = TunerList.begin(); i != TunerList.end(); ++i) {
            PQGraphSegment p(CLSID_MSVidBDATunerDevice);
            if (!p) continue;
            p->put_Init(*i);
            pDev->m_Devices.push_back(PQDevice(p));
        }
        pDev->Valid = true;
        pInputs = static_cast<IMSVidInputDevices *>(pDev);
        return NOERROR;
    } else if (catguid == GUID_NULL) {
        CInputDevices *pDev = new CInputDevices(true);
        // non cat enumerated devices
        {
            PQGraphSegment p(CLSID_MSVidFilePlaybackDevice);
            if (!p) {
                _ASSERT(false);
                pDev->Release();
                return E_NOTIMPL;
            }
            p->put_Init(NULL);
            pDev->m_Devices.push_back(PQDevice(p));
            pDev->Valid = true;
            pInputs = static_cast<IMSVidInputDevices *>(pDev);
        }
        {
            PQGraphSegment p(CLSID_MSVidWebDVD);
            if (!p) {
                _ASSERT(false);
                pDev->Release();
                return E_NOTIMPL;
            }
            p->put_Init(NULL);
            pDev->m_Devices.push_back(PQDevice(p));
            pDev->Valid = true;
            pInputs = static_cast<IMSVidInputDevices *>(pDev);
        }
        {

            PQGraphSegment p(CLSID_MSVidStreamBufferSource);
            if (!p) {
                _ASSERT(false);
                pDev->Release();
                return E_NOTIMPL;
            }
            p->put_Init(NULL);
            pDev->m_Devices.push_back(PQDevice(p));
            pDev->Valid = true;
            pInputs = static_cast<IMSVidInputDevices *>(pDev);

        }

        return NOERROR;
    }


    return E_INVALIDARG;
}

HRESULT CVidCtl::GetOutputs(const GUID2& CategoryGuid)
{
    VIDPERF_FUNC;
    // We only have one output
    if (CategoryGuid == GUID_NULL) {
        COutputDevices *pDev = new COutputDevices(true);
        PQGraphSegment p(CLSID_MSVidStreamBufferSink);
        if (!p) {
            pDev->Release();
            return E_NOTIMPL;
        }
        p->put_Init(NULL);
        pDev->m_Devices.push_back(PQDevice(p));
        pDev->Valid = true;
        m_pOutputs = static_cast<IMSVidOutputDevices *>(pDev);
    }
    return S_OK;    

}

HRESULT CVidCtl::GetVideoRenderers()
{
    VIDPERF_FUNC;
    //Video Renderers
    CVideoRendererDevices *pDevs = new CVideoRendererDevices(true);

    PQGraphSegment p(CLSID_MSVidVideoRenderer);
    if (!p) {
        pDevs->Release();
        return Error(IDS_CANT_CREATE_FILTER, __uuidof(IMSVidCtl), IDS_CANT_CREATE_FILTER);
    }

    p->put_Init(NULL);
    PQDevice pd(p);
    if (!pd) {
        pDevs->Release();
        return E_UNEXPECTED;
    }
    pDevs->m_Devices.push_back(pd);
    pDevs->Valid = true;
    m_pVRs = static_cast<IMSVidVideoRendererDevices *>(pDevs);

    return NOERROR;
}

HRESULT CVidCtl::GetAudioRenderers()
{
    VIDPERF_FUNC;
    //Audio Renderers
    CAudioRendererDevices *pDevs = new CAudioRendererDevices(true);

    PQGraphSegment p(CLSID_MSVidAudioRenderer);
    if (!p) {
        pDevs->Release();
        return Error(IDS_CANT_CREATE_FILTER, __uuidof(IMSVidCtl), IDS_CANT_CREATE_FILTER);
    }
    p->put_Init(NULL);
    PQDevice pd(p);
    if (!pd) {
        pDevs->Release();
        return E_UNEXPECTED;
    }
    pDevs->m_Devices.push_back(pd);
    pDevs->Valid = true;
    m_pARs = static_cast<IMSVidAudioRendererDevices *>(pDevs);
    return NOERROR;
}

HRESULT CVidCtl::GetFeatures()
{
    VIDPERF_FUNC;
    // available features
    // undone: change hard coded list of features into registry lookup
    if (!m_pFeatures) {
        CFeatures *pDev = new CFeatures;
        if (!pDev) {
            return E_OUTOFMEMORY;
        }
        pDev->Valid = true;
        m_pFeatures = static_cast<IMSVidFeatures *>(pDev);
        {
            PQGraphSegment p(CLSID_MSVidDataServices);
            if (p) {
                p->put_Init(NULL);
                pDev->m_Devices.push_back(PQDevice(p));
            } else {
                _ASSERT(false);
            }
        }

        {
            PQGraphSegment p(CLSID_MSVidClosedCaptioning);
            if (p) {
                p->put_Init(NULL);
                pDev->m_Devices.push_back(PQDevice(p));
            } else {
                _ASSERT(false);
            }
        }
        {
            PQGraphSegment p(CLSID_MSVidXDS);
            if (p) {
                p->put_Init(NULL);
                pDev->m_Devices.push_back(PQDevice(p));
            } else {
                _ASSERT(false);
            }
        }
#if ENCODERCAT_HACK
        bool AddedMux = false;
#endif
        {
            // Hardware mux category
            DSDevices EncoderList(m_pSystemEnum, KSCATEGORY_MULTIPLEXER);
            DSDevices::iterator i;
            for (i = EncoderList.begin(); i != EncoderList.end(); ++i) {
                PQGraphSegment p(CLSID_MSVidEncoder);
                if (!p) continue;
                p->put_Init(*i);
                pDev->m_Devices.push_back(PQDevice(p));
#if ENCODERCAT_HACK
                AddedMux = true;
#endif
            }
        }
        {
            // Software mux category
            DSDevices EncoderList(m_pSystemEnum, CLSID_MediaMultiplexerCategory);
            DSDevices::iterator i;
            for (i = EncoderList.begin(); i != EncoderList.end(); ++i) {
                PQGraphSegment p(CLSID_MSVidEncoder);
                if (!p) continue;
                p->put_Init(*i);
                pDev->m_Devices.push_back(PQDevice(p));
#if ENCODERCAT_HACK
                AddedMux = true;
#endif
            }
        }
#if ENCODERCAT_HACK
        if(!AddedMux){
            DSDevices EncoderList(m_pSystemEnum, KSCATEGORY_ENCODER);
            DSDevices::iterator i;
            for (i = EncoderList.begin(); i != EncoderList.end(); ++i) {
                PQGraphSegment p(CLSID_MSVidEncoder);
                if (!p) continue;
                p->put_Init(*i);
                pDev->m_Devices.push_back(PQDevice(p));
            }
        }
#endif

    }

    return NOERROR;
}

// Takes a variant input and a list of input devices to attempt to view the input with
HRESULT CVidCtl::SelectViewFromSegmentList(CComVariant &pVar, VWInputDevices& grList, PQInputDevice& pCurInput) {
    VIDPERF_FUNC;
    VWInputDevices::iterator i = grList.begin();
    // skip devices until we're past the current one(if there is a current one)
    for (; pCurInput && i != grList.end(); ++i) {
        PQInputDevice pInDev((*i).punkVal);
        VARIANT_BOOL f = VARIANT_FALSE;
        HRESULT hr = pCurInput->IsEqualDevice(pInDev, &f);
        if (SUCCEEDED(hr) && f == VARIANT_TRUE){
            ++i;
            break;
        }
    }  
    // run thru to the end of the list
    for (; i != grList.end(); ++i) {
        PQInputDevice pInDev((*i).punkVal);
        HRESULT hr = pInDev->View(&pVar);
        if(SUCCEEDED(hr)){
            if(m_pInput){
                PQGraphSegment(m_pInput)->put_Container(NULL);
            }
            m_pInput = pInDev;
            m_pInputNotify = m_pInput;
            m_CurView = pVar;
            m_fGraphDirty = true;
            return NOERROR;
        }   
    }  
    if (pCurInput) {
        // retry the ones we skipped
        i = grList.begin();
        for (; i != grList.end(); ++i) {
            PQInputDevice pInDev((*i).punkVal);
            HRESULT hr = pInDev->View(&pVar);
            if(SUCCEEDED(hr)){
                if(m_pInput){
                    PQGraphSegment(m_pInput)->put_Container(NULL);
                }
                m_pInput = pInDev;
                m_pInputNotify = m_pInput;
                m_CurView = pVar;
                m_fGraphDirty = true;
                return NOERROR;
            }   
        }  
    }

    return E_FAIL;
}

// non-interface functions
HRESULT CVidCtl::SelectView(VARIANT *pv, bool fNext) {
    VIDPERF_FUNC;
    HRESULT hr;
    TRACELM(TRACE_DETAIL, "CVidCtl::SelectView()");
    if (!m_fInit) {
        Init();
    }
    if (!pv) {
        m_CurView = CComVariant();
        return NOERROR;
    }
    CComVariant pVar(*pv);
    if(pv->vt & VT_BYREF){
        if(pv->vt == (VT_UNKNOWN|VT_BYREF)){
            pVar=(*reinterpret_cast<IUnknown**>(pv->punkVal));
        }
        else if(pv->vt == (VT_DISPATCH|VT_BYREF)){
            pVar = (*reinterpret_cast<IDispatch**>(pv->pdispVal));
        }
    }
    if (!pVar) {
        m_CurView = CComVariant();
        return NOERROR;
    }
    if (m_pInput && !fNext)  {
        // && pVar != m_CurView) {
        // note: only try different content on current device, 
        // if app tries to re-view the current view content then we 
        // attempt to iterate to next available device
        hr = m_pInput->View(&pVar);
        if (SUCCEEDED(hr)) {
            // currently selected device can view this new content
            return hr;
        }
    }
    if (m_pGraph.GetState() != State_Stopped) {
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidCtl), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }

    if (m_pInput) {
        hr = DecomposeSegment(VWGraphSegment(m_pInput));
        if (FAILED(hr)) {
            return Error(IDS_CANT_REMOVE_SEG, __uuidof(IMSVidCtl), IDS_CANT_REMOVE_SEG);
        }
    }
    // Try the ATSC tune request
    if (pVar.vt == VT_UNKNOWN || pVar.vt == VT_DISPATCH) {
        PQTuneRequest ptr(pVar.vt == VT_UNKNOWN ? pVar.punkVal : pVar.pdispVal);
        if (ptr) {
            VWInputDevices pInputs;
            PQChannelTuneRequest ptr2(ptr);
            if (ptr2) {
                PQATSCChannelTuneRequest ptr3(ptr);
                if (!ptr3) {
                    hr = GetInputs(KSCATEGORY_TVTUNER, pInputs);
                    if(SUCCEEDED(hr)){
                        hr = SelectViewFromSegmentList(pVar, pInputs, m_pInput);
                        if(SUCCEEDED(hr)){
                            m_CurViewCatGuid = KSCATEGORY_TVTUNER;
                            return hr;
                        }
                    }
                }
            }

            hr = GetInputs(KSCATEGORY_BDA_NETWORK_PROVIDER, pInputs);
            if(SUCCEEDED(hr)){
                hr = SelectViewFromSegmentList(pVar, pInputs, m_pInput);
                if(SUCCEEDED(hr)){
                    m_CurViewCatGuid = KSCATEGORY_BDA_NETWORK_PROVIDER;
                    return hr;
                }
            }
            if(FAILED(hr)){
                return hr;
            }
        }
    }

    // Try to view the File input and DVD Segments
    VWInputDevices pInputs;
    hr = GetInputs(GUID_NULL, pInputs);
    hr = SelectViewFromSegmentList(pVar, pInputs, m_pInput);
    if(SUCCEEDED(hr)){
        m_CurViewCatGuid = GUID_NULL;
        return hr;
    }
    return Error(IDS_CANT_VIEW, __uuidof(IMSVidCtl), IDS_CANT_VIEW);
}


HRESULT CVidCtl::LoadDefaultVR(void) {
    VIDPERF_FUNC;
    PQVRGraphSegment pGS;
    HRESULT hr = pGS.CoCreateInstance(CLSID_MSVidVideoRenderer);
    if (FAILED(hr) || !pGS) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultVR() can't instantiate default video renderer. hr = " << std::hex << hr), "");
        return Error(IDS_CANT_CREATE_FILTER, __uuidof(IMSVidCtl), IDS_CANT_CREATE_FILTER);
    }
    hr = pGS->put_Init(NULL);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultVR() can't init default video renderer. hr = " << std::hex << hr), "");
        return hr;
    }
    hr = pGS->put_Container(this);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultVR() can't load default video renderer. hr = " << std::hex << hr), "");
        return hr;
    }
    if (!m_bNegotiatedWnd) {
        if (!m_bInPlaceActive) {
            hr = InPlaceActivate(OLEIVERB_INPLACEACTIVATE, NULL);
            if (FAILED(hr)) {
                return hr;
            }
        }
    }
#if 0
    VARIANT_BOOL ov = (m_bWndLess && WindowHasHWOverlay(m_CurrentSurface.Owner())) ? VARIANT_TRUE : VARIANT_FALSE;
#else
    // always try to use overlay if we're wndless. vmr will tell us if it isn't available
    VARIANT_BOOL ov = m_bWndLess ? VARIANT_TRUE : VARIANT_FALSE;
#endif
    hr = pGS->put_UseOverlay(ov);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultVR() can't set useoverlay. hr = " << std::hex << hr), "");
        return hr;
    }
    m_pVideoRenderer = pGS;

    return NOERROR;
}

HRESULT CVidCtl::LoadDefaultAR(void) {
    VIDPERF_FUNC;
    PQGraphSegment pGS;
    HRESULT hr = pGS.CoCreateInstance(CLSID_MSVidAudioRenderer);
    if (FAILED(hr) || !pGS) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultAR() can't instantiate default Audio renderer. hr = " << std::hex << hr), "");
        return Error(IDS_CANT_CREATE_FILTER, __uuidof(IMSVidCtl), IDS_CANT_CREATE_FILTER);
    }
    hr = pGS->put_Init(NULL);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultAR() can't init default Audio renderer. hr = " << std::hex << hr), "");
        return hr;
    }
    hr = pGS->put_Container(this);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultAR() can't load default Audio renderer. hr = " << std::hex << hr), "");
        return hr;
    }
    m_pAudioRenderer = pGS;

    return NOERROR;
}

HRESULT CVidCtl::Compose(VWGraphSegment &Up, VWGraphSegment &Down, int &NewIdx) {
    VIDPERF_FUNC;
    PQCompositionSegment pCS;
#if 0
    // This code is for returning error codes in failure cases for the default composition segment
    HRESULT hrExpected = S_OK;
    HRESULT hrFailed = E_FAIL;
    bool bCheckHR = false;
#endif
    _ASSERT(!!Up && !!Down);

    // Analog TV to Video Renderer Composition Segment
    if (VWGraphSegment(Up).Category() == KSCATEGORY_TVTUNER && VWGraphSegment(Down).ClassID() == CLSID_MSVidVideoRenderer) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidAnalogCaptureToOverlayMixer);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog capture to ov mixer composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    // Analog TV to Stream Buffer Sink Compsition Segment
    else if (VWGraphSegment(Up).Category() == KSCATEGORY_TVTUNER && VWGraphSegment(Down).ClassID() == CLSID_MSVidStreamBufferSink) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidAnalogCaptureToStreamBufferSink);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog capture to time shift sink composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    } 
    // Digital TV (bda) to Video Renderer Compsition Segment
    else if (VWGraphSegment(Up).ClassID() == CLSID_MSVidBDATunerDevice && VWGraphSegment(Down).ClassID() == CLSID_MSVidStreamBufferSink) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidDigitalCaptureToStreamBufferSink);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog capture to time shift sink composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    } 
    // Analog TV to Data Services Compsition Segment
    else if (VWGraphSegment(Up).Category() == KSCATEGORY_TVTUNER && VWGraphSegment(Down).ClassID() == CLSID_MSVidDataServices) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidAnalogCaptureToDataServices);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog tuner/capture to data services composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    // Digial TV (bda) or DVD to Closed Caption Compsition Segment
    else if ((VWGraphSegment(Up).ClassID() == CLSID_MSVidBDATunerDevice || 
        VWGraphSegment(Up).ClassID() == CLSID_MSVidWebDVD) &&
        VWGraphSegment(Down).ClassID() == CLSID_MSVidClosedCaptioning) {
            HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidMPEG2DecoderToClosedCaptioning);
            if (FAILED(hr) || !pCS) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate mp2 to CC composite. hr = " << std::hex << hr), "");
                return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
            }
        }        
        // File Playback to Video Renderer Compsition Segment
    else if ((VWGraphSegment(Up).ClassID() == CLSID_MSVidFilePlaybackDevice ) &&
        VWGraphSegment(Down).ClassID() == CLSID_MSVidVideoRenderer) {
            HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidFilePlaybackToVideoRenderer);
            if (FAILED(hr) || !pCS) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate file playback to video renderer composite. hr = " << std::hex << hr), "");
                return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
            }
        } 
        // File Playback to Audio Renderer Compsition Segment
    else if ((VWGraphSegment(Up).ClassID() == CLSID_MSVidFilePlaybackDevice ) &&
        VWGraphSegment(Down).ClassID() == CLSID_MSVidAudioRenderer) {
            HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidFilePlaybackToAudioRenderer);
            if (FAILED(hr) || !pCS) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate file playback to audio renderer composite. hr = " << std::hex << hr), "");
                return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), E_UNEXPECTED);
            }
        } 
        // DVD to Video Renderer Compsition Segment
    else if (VWGraphSegment(Up).ClassID() == CLSID_MSVidWebDVD && VWGraphSegment(Down).ClassID() == CLSID_MSVidVideoRenderer) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidWebDVDToVideoRenderer);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate webdvd to video renderer, hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
#if 0
    else if (VWGraphSegment(Up).ClassID() == CLSID_MSVidWebDVD && VWGraphSegment(Down).ClassID() == CLSID_MSVidAudioRenderer) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidWebDVDToAudioRenderer);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate time shift source to data services composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
#endif
    ///////////////////////////////////////////////////
    // New Compostion Segments for FreeStyle Endgame //
    ///////////////////////////////////////////////////
    // XDS to Stream Buffer Sink Compsition Segment
    else if (VWGraphSegment(Up).ClassID() == CLSID_MSVidXDS && (VWGraphSegment(Down).ClassID() == CLSID_MSVidStreamBufferSink)) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidDataServicesToStreamBufferSink);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate time shift source to data services composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    // Encoder to Stream Buffer Sink Compsition Segment
    else if (VWGraphSegment(Up).ClassID() == CLSID_MSVidEncoder && (VWGraphSegment(Down).ClassID() == CLSID_MSVidStreamBufferSink)) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidEncoderToStreamBufferSink);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate encoder to time shift sink composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    } 
    // StreamBufferSource to Video Renderer Compsition Segment
    else if ((VWGraphSegment(Up).ClassID() == CLSID_MSVidStreamBufferSource ) &&
        VWGraphSegment(Down).ClassID() == CLSID_MSVidVideoRenderer) {
            HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidStreamBufferSourceToVideoRenderer); // name change needed
            if (FAILED(hr) || !pCS) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate time shift source to CC composite. hr = " << std::hex << hr), "");
                return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
            }
        }
        // Analog Capture to XDS
    else if (VWGraphSegment(Up).Category() == KSCATEGORY_TVTUNER && VWGraphSegment(Down).ClassID() == CLSID_MSVidXDS){
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidAnalogCaptureToXDS); 
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog capture to XDS composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    // Analog Capture to Encoder
    else if (VWGraphSegment(Up).Category() == KSCATEGORY_TVTUNER && VWGraphSegment(Down).ClassID() == CLSID_MSVidEncoder){
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidAnalogTVToEncoder); 
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog capture to XDS composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    // StreamBufferSource to CC
    else if ((VWGraphSegment(Up).ClassID() == CLSID_MSVidStreamBufferSource ) && VWGraphSegment(Down).ClassID() == CLSID_MSVidClosedCaptioning){
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidSBESourceToCC); 
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog capture to XDS composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    else if ((VWGraphSegment(Up).ClassID() == CLSID_MSVidStreamBufferSource) && (VWGraphSegment(Down).ClassID() == CLSID_MSVidStreamBufferSink)){
            return E_FAIL;
    }
    else {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidGenericComposite);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate generic composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    HRESULT hr = pCS->put_Init(NULL);
    if (FAILED(hr) && hr != E_NOTIMPL) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't init new comp seg.  hr = " << std::hex << hr), "");
        return hr;
    }
    VWGraphSegment pSeg(pCS);
    ASSERT(pSeg);
    m_pComposites.push_back(pSeg);
    NewIdx = m_pComposites.size() - 1;
    hr = pCS->put_Container(this);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't put_continaer for new comp segment. hr = " << std::hex << hr), "");
        return hr;
    }

    hr = pCS->Compose(PQGraphSegment(Up), PQGraphSegment(Down));
#if 0
    if(bCheckHR){
        if(hr != hrExpected){
            return hrFailed;
        }
        else{
            return hr;
        }
    }
#endif
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't compose up = " << Up << " with down = " << Down << " hr = " << hexdump(hr) ), "");
        return hr;
    }

    return NOERROR;
}

HRESULT CVidCtl::BuildGraph(void) {
    CPerfCounter pCounterBuild, pCounterPutC, pCounterCompose, pCounterBuilds, pCounterComp, pCounterB;
    pCounterBuild.Reset();
    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph()");
    BOOL lRes = 0;
    OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
    HRESULT hr;
    ASSERT(m_pGraph);
    if(m_State != STATE_UNBUILT && m_fGraphDirty != true){
        return S_OK; // need a graph already built warning message
    }

    // make sure any needed default renderer's are selected prior to calling
    // build on the other segments so all segments are loaded before any
    // build() functions are called.

    // make sure required defaultable segments are set or assign a default
    // also make sure every segment knows the container

    bool fDefVideoRenderer = false;
    pCounterPutC.Reset();
    if (m_pVideoRenderer) {
        hr = PQGraphSegment(m_pVideoRenderer)->put_Container(this);
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() put_Container failed for Video Renderer");
            return hr;
        }
    } else if (!m_videoSetNull) {
        hr = LoadDefaultVR();
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() LoadDefaultVR failed");
            return hr;
        }
        if (!m_pVideoRenderer) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() LoadDefaultVR returned NULL Video Renderer");
            return E_UNEXPECTED;
        }
        fDefVideoRenderer = true;
    } 
    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() default vr checked");

    bool fDefAudioRenderer = false;
    if (m_pAudioRenderer) {
        hr = PQGraphSegment(m_pAudioRenderer)->put_Container(this);
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() put_Container failed for Audio Renderer");
            return hr;
        }
    } else if (!m_audioSetNull) {
        hr = LoadDefaultAR();
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() LoadDefaultAR failed");
            return hr;
        }
        if (!m_pAudioRenderer) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() LoadDefaultAR returned NULL Audio Renderer");
            return E_UNEXPECTED;
        }
        fDefAudioRenderer = true;
    }
    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() default ar checked");

    if (!m_pInput) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() input segment required" << std::hex << hr), "");
        return Error(IDS_INPUT_SEG_REQUIRED, __uuidof(IMSVidCtl), IDS_INPUT_SEG_REQUIRED);
    }

    hr = PQGraphSegment(m_pInput)->put_Container(this);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't load input segment. hr = " << std::hex << hr), "");
        return hr;
    }


    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() input container set");
    {
        for (VWFeatures::iterator i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
            // notify them that we're building
            hr = VWGraphSegment(*i)->put_Container(this);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't load feature segment: " << (*i) << " hr = " << std::hex << hr), "");
                return hr;
            }

        }
    }

    {
        for (VWOutputDevices::iterator i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
            // notify them that we're building
            hr = VWGraphSegment(*i)->put_Container(this);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't load output segment: " << (*i) << " hr = " << std::hex << hr), "");
                return hr;
            }
        }
    }

    pCounterPutC.Stop();
    TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() PutContainer " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterPutC.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterPutC.GetLastTime() % _100NS_IN_MS) << " ms"), "");

    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() feature container set");

    pCounterBuilds.Reset();
    // Notify all of the output segments that we are about to build
    pCounterB.Reset();        
    // Notify everyone that composition is about to start
    hr = VWGraphSegment(m_pInput)->Build();
    if (FAILED(hr) && hr != E_NOTIMPL) {
        TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() Build call for input failed");
        return hr;
    }

    pCounterB.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Build call to Input: " << (unsigned long)(pCounterB.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterB.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterB.Reset();        

    {
        VWFeatures::iterator i;
        for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
            // notify them that we're building
            hr = VWGraphSegment(*i)->Build();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't build feature segment: " << (*i) << " hr = " << std::hex << hr), "");
                return hr;
            }
            pCounterB.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Build call to Feature " << (*i) << " : " << (unsigned long)(pCounterB.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterB.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterB.Reset();        
        }
    }

    {
        VWOutputDevices::iterator i;
        for (i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
            // notify them that we're building
            hr = VWGraphSegment(*i)->Build();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't build output segment: " << (*i) << " hr = " << std::hex << hr), "");
                return hr;
            }                
            pCounterB.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Build call to Output " << (*i) << " : " << (unsigned long)(pCounterB.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterB.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterB.Reset();        
        }
    }

    if (m_pVideoRenderer) {
        hr = VWGraphSegment(m_pVideoRenderer)->Build();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() Build call to Video Renderer Failed");
            return hr;
        }
        pCounterB.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Build call to VideoRenderer: " << (unsigned long)(pCounterB.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterB.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterB.Reset();        
    }
    if (m_pAudioRenderer) {
        hr = VWGraphSegment(m_pAudioRenderer)->Build();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() Build call to Audio Renderer Failed");
            return hr;
        }
        pCounterB.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Build call to Audio Renderer: " << (unsigned long)(pCounterB.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterB.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterB.Reset();        
    }
    pCounterBuilds.Stop();
    TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Build Calls to segments " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterBuilds.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterBuilds.GetLastTime() % _100NS_IN_MS) << " ms"), "");

    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() build notifications issued");
    pCounterCompose.Reset();
    pCounterComp.Reset();
    {
        VWFeatures::iterator i;
        // composing input w/ features
        TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() Composing Input w/ Features");
        for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
            int NewCompositionSegmentIdx = -1;
            hr = Compose(VWGraphSegment(m_pInput), VWGraphSegment(*i), NewCompositionSegmentIdx);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose input segment with feature segment: " << (*i) << " hr = " << std::hex << hr), "");
                return hr;
            }
        }
    }
    pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Composing Input w/ Features " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();
    // compose input w/ renderers

    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() Composing Input w/ Video Renderer");
    if (m_pVideoRenderer) {
        if (m_iCompose_Input_Video == -1) {
            hr = Compose(VWGraphSegment(m_pInput), VWGraphSegment(m_pVideoRenderer), m_iCompose_Input_Video);
            if (FAILED(hr) /*&& !fDefVideoRenderer*/ ) { // this should fail even if it is the default video renderer
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose input and video. hr = " << std::hex << hr), "");
                return hr;
            }
        }
        ASSERT(m_iCompose_Input_Video != -1);
        PQCompositionSegment pCS(m_pComposites[m_iCompose_Input_Video]);
    }
    pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Input w/ Video Renderer " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();        

    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() Composing Input w/ Audio Renderer");
    if (m_pAudioRenderer) {
        if (m_iCompose_Input_Audio == -1) {
            hr = Compose(VWGraphSegment(m_pInput), VWGraphSegment(m_pAudioRenderer), m_iCompose_Input_Audio);
            if (FAILED(hr) && !fDefAudioRenderer) {
                // didn't work and the client explicitly specificed they want an audio renderer
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose input and audio. hr = " << std::hex << hr), "");
                return hr;
            }
        }
    }
    pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Input w/ Audio Renderer " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();        

    // compose input w/ outputs
    {
        TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() Composing Input w/ Outputs");
        for (VWOutputDevices::iterator i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
            int NewCompositionSegmentIdx = -1;
            hr = Compose(VWGraphSegment(m_pInput),VWGraphSegment(*i), NewCompositionSegmentIdx);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose output segment with input: " << (*i) << " hr = " << std::hex << hr), "");
                return hr;
            }

        }
    }
    pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() inputs w/ Outputs " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();        

    // composing Features w/ Renderers
    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() Composing Features w/ Renderers");
    for (VWFeatures::iterator i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
        int NewCompositionSegmentIdx = -1;
        if (m_pVideoRenderer) {
            hr = Compose(VWGraphSegment(*i), VWGraphSegment(m_pVideoRenderer), NewCompositionSegmentIdx);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose feature segment: " << (*i) << " w/ video renderer. hr = " << std::hex << hr), "");
                // note: this is not a fatal error for building.  many features won't
                // connect to vr(such as data services)
            }
        }
        pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Features w/ Video Renderer " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();        

        if (m_pAudioRenderer) {
            hr = Compose(VWGraphSegment(*i), VWGraphSegment(m_pAudioRenderer), NewCompositionSegmentIdx);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose feature segment: " << (*i) << " w/ Audio renderer. hr = " << std::hex << hr), "");
                // note: this is not a fatal error for building.  many features won't
                // connect to ar(such as data services)
            }
        }
        pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Features w/ Audio Renderer " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();        

        {					
            for (VWOutputDevices::iterator oi = m_pOutputsInUse.begin(); oi != m_pOutputsInUse.end(); ++oi) {
                hr = Compose(VWGraphSegment(*i),VWGraphSegment(*oi), NewCompositionSegmentIdx);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose output segment with feature: " << (*i) << " hr = " << std::hex << hr), "");
                    return hr;
                }

            }
        }
        pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Features w/ Outputs " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();        
    }
    pCounterCompose.Stop();
    TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() compose segments " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterCompose.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterCompose.GetLastTime() % _100NS_IN_MS) << " ms"), "");

    RouteStreams();
    SetExtents();

    m_fGraphDirty = false;
//    m_State = STATE_STOP;
    //SetMediaEventNotification();

    // fire state change at client
    PQMediaEventSink mes(m_pGraph);
    hr = mes->Notify(EC_BUILT, 0, 0);
    OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
	_ASSERT(m_State == STATE_STOP);
    TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterBuild.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterBuild.GetLastTime() % _100NS_IN_MS) << " ms"), "");
    pCounterBuild.Stop();
    return NOERROR;
}

HRESULT CVidCtl::RunGraph(void)
{
    VIDPERF_FUNC;
    TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph()");
    CPerfCounter pCounterMCRun, pCounterPostRun, pCounterPreRun, pCounterRunGraph, pCounterEachPreRun;
    pCounterRunGraph.Reset();
    if (!m_pInput || !m_pGraph) {
        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidCtl), CO_E_NOTINITIALIZED);
    }
    BOOL lRes = 0;
    OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
    HRESULT hr;
    if (m_pGraph.IsPlaying()) {
        TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph() already playing");
        return NOERROR;
    }
    else if (m_pGraph.IsPaused() && m_State == STATE_PAUSE) {
        TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph() is paused");
        PQMediaControl pmc(m_pGraph);
        if (!pmc) {
            return Error(IDS_NO_MEDIA_CONTROL, __uuidof(IMSVidCtl), IDS_NO_MEDIA_CONTROL);
        }
        hr = pmc->Run();
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Run() hr = " << hexdump(hr)), "");
            return Error(IDS_CANT_START_GRAPH, __uuidof(IMSVidCtl), hr);
        }        
        OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
        return NOERROR;
    }
    else {
        TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph() build/prerun");
        // Rebuild the graph if necessary
        if (m_fGraphDirty) {
            TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph() building");
            hr = BuildGraph();
            if (FAILED(hr)) {
                return hr;
            }
        }
        OAFilterState graphState = m_pGraph.GetState();

        TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph() prerun notifications");
        // Notify all segments graph is about to run
        pCounterPreRun.Reset();
        pCounterEachPreRun.Reset();
        ASSERT(m_pInput);
        hr = VWGraphSegment(m_pInput)->PreRun();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            return hr;
        }
        pCounterEachPreRun.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun Input  " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterEachPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterEachPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterEachPreRun.Reset();        
        if (m_pVideoRenderer) {
            hr = VWGraphSegment(m_pVideoRenderer)->PreRun();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }
        pCounterEachPreRun.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun VideoRenderer  " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterEachPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterEachPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterEachPreRun.Reset();        
        if (m_pAudioRenderer) {
            hr = VWGraphSegment(m_pAudioRenderer)->PreRun();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }
        pCounterEachPreRun.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun AudioRenderer  " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterEachPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterEachPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterEachPreRun.Reset();        
        {
            VWOutputDevices::iterator i;
            for (i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
                hr = VWGraphSegment(*i)->PreRun();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
        }
        pCounterEachPreRun.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun Output  " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterEachPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterEachPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterEachPreRun.Reset();        
        {
            VWFeatures::iterator i;
            for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
                hr = VWGraphSegment(*i)->PreRun();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
        }
        pCounterEachPreRun.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun Features  " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterEachPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterEachPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterEachPreRun.Reset();        
        {
            VWSegmentList::iterator i;
            for(i = m_pComposites.begin(); i != m_pComposites.end(); ++i){
                hr = VWGraphSegment(*i)->PreRun();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
        }
        pCounterEachPreRun.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun Composites  " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterEachPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterEachPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterEachPreRun.Reset();        
        // Make sure graph state hasn't changed
        ASSERT(graphState == m_pGraph.GetState());
        Refresh();  // make sure we're in place active etc.
        pCounterPreRun.Stop();
        TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), "");

        // Start the graph running
        PQMediaControl pmc(m_pGraph);
        if (!pmc) {
            return Error(IDS_NO_MEDIA_CONTROL, __uuidof(IMSVidCtl), IDS_NO_MEDIA_CONTROL);
        }
        pCounterMCRun.Reset();
        hr = pmc->Run();
        pCounterMCRun.Stop();
#if 0
        if(FAILED(hr)){
            hr = pmc->Run();
        }
#endif    
        TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() MediaControl Run Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterMCRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterMCRun.GetLastTime() % _100NS_IN_MS) << " ms"), "");
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Run() hr = " << hexdump(hr)), "");
            return Error(IDS_CANT_START_GRAPH, __uuidof(IMSVidCtl), hr);
        }        
    }
    TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph() postrun");
    // Notify all segments graph is running
    pCounterPostRun.Reset();
    ASSERT(m_pInput);
    hr = VWGraphSegment(m_pInput)->PostRun();
    if (FAILED(hr) && hr != E_NOTIMPL) {
        return hr;
    }

    if (m_pVideoRenderer) {
        hr = VWGraphSegment(m_pVideoRenderer)->PostRun();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            return hr;
        }
    }
    if (m_pAudioRenderer) {
        hr = VWGraphSegment(m_pAudioRenderer)->PostRun();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            return hr;
        }
    }

    {
        VWOutputDevices::iterator i;
        for (i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
            hr = VWGraphSegment(*i)->PostRun();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }
    }
    {
        VWFeatures::iterator i;
        for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
            hr = VWGraphSegment(*i)->PostRun();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }
    }
    {
        VWSegmentList::iterator i;
        for (i = m_pComposites.begin(); i != m_pComposites.end(); ++i){
            hr = VWGraphSegment(*i)->PostRun();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }
    }
    Refresh();
    OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
    pCounterPostRun.Stop();
    pCounterRunGraph.Stop();
    TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() Post Run Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterPostRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterPostRun.GetLastTime() % _100NS_IN_MS) << " ms"), "");
    TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::RunGraph() RunGraph Total Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterRunGraph.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterRunGraph.GetLastTime() % _100NS_IN_MS) << " ms"), "");

    return NOERROR;
}

HRESULT CVidCtl::DecomposeAll() {
    CPerfCounter pCounterDecompose;
    pCounterDecompose.Reset();
    HRESULT hr;

    if (!m_pGraph) {
        return NOERROR;
    }
    BOOL lRes = 0;
    OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
    
    if (m_pGraph.GetState() != State_Stopped) {
        hr = Stop();
        if (FAILED(hr)) {
            return Error(IDS_CANT_DECOMPOSE_GRAPH, __uuidof(IMSVidCtl), hr);
        }
    }

    {
        // decompose all the composites
        VWSegmentList::iterator i;
        for (i = m_pComposites.begin(); i != m_pComposites.end(); ++i) {
            hr = (*i)->put_Container(NULL);
            ASSERT(SUCCEEDED(hr));
        }
        m_pComposites.clear();
    }

    // Notify everyone to decompose

    if(!!m_pInput){
        hr = VWGraphSegment(m_pInput)->Decompose();
        if (FAILED(hr) && hr !=	E_NOTIMPL) {
            return hr;
        }
    }

    {
        // decompose all the features
        VWFeatures::iterator i;
        for	(i = m_pFeaturesInUse.begin(); i !=	m_pFeaturesInUse.end();	++i) {
            // notify them that	we're decomposing
            hr = VWGraphSegment(*i)->Decompose();
            if (FAILED(hr) && hr !=	E_NOTIMPL) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::DecomposeAll() can't decompose feature segment: "	<< (*i)	<< " hr	= "	<< std::hex	<< hr),	"");
                return hr;
            }
        }
    }

    {
        // decompose all the outputs
        VWOutputDevices::iterator i;
        for	(i = m_pOutputsInUse.begin(); i	!= m_pOutputsInUse.end(); ++i) {
            // notify them that	we're decomposing
            hr = VWGraphSegment(*i)->Decompose();
            if (FAILED(hr) && hr !=	E_NOTIMPL) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::DecomposeAll() can't decompose output	segment: " << (*i) << "	hr = " << std::hex << hr), "");
                return hr;
            }
        }
    }

    if (!!m_pVideoRenderer) {
        hr = VWGraphSegment(m_pVideoRenderer)->Decompose();
        if (FAILED(hr) && hr !=	E_NOTIMPL) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::DecomposeAll() can't decompose videorenderer	segment: " << "	hr = " << std::hex << hr), "");
            return hr;
        }
    }
    if (!!m_pAudioRenderer) {
        hr = VWGraphSegment(m_pAudioRenderer)->Decompose();
        if (FAILED(hr) && hr !=	E_NOTIMPL) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::DecomposeAll() can't decompose audiorenderer	segment: " << "	hr = " << std::hex << hr), "");
            return hr;
        }
    }

    TRACELM(TRACE_DETAIL, "CVidCtl::Decomose() decompose notifications issued");

    m_iCompose_Input_Video = -1;
    m_iCompose_Input_Audio = -1;

    m_fGraphDirty = true;
    PQMediaEventSink mes(m_pGraph);
    hr = mes->Notify(EC_UNBUILT, 0, 0);
    OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
    _ASSERT(m_State == STATE_UNBUILT);
    pCounterDecompose.Stop();
    TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::DecomposeAll() Death Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterDecompose.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterDecompose.GetLastTime() % _100NS_IN_MS) << " ms"), "");
    return NOERROR;
}

HRESULT CVidCtl::DecomposeSegment(VWGraphSegment& pSegment) {
    if (m_pGraph.GetState() != State_Stopped) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
    }
    return DecomposeAll();
}

// interface functions
STDMETHODIMP CVidCtl::get_InputsAvailable(BSTR CategoryGuid, IMSVidInputDevices * * pVal)
{
    try {
        GUID2 catguid(CategoryGuid);
        return get__InputsAvailable(&catguid, pVal);
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CVidCtl::get__InputsAvailable(LPCGUID CategoryGuid, IMSVidInputDevices * * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    try {
        if (!m_fInit) {
            Init();
        }
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
    try {
        *pVal = NULL;
    } catch(...) {
        return E_POINTER;
    }
    try {
        CInputDevices *p = NULL;
        if(m_InputsCatGuid == CategoryGuid){
            p = static_cast<CInputDevices *>(m_pInputs.p);
        }
        if (!p || !p->Valid) {
            HRESULT hr = GetInputs(GUID2(CategoryGuid), m_pInputs);
            if (FAILED(hr)) {
                return hr;
            }
            m_InputsCatGuid = CategoryGuid;
        }
        CInputDevices *d = new CInputDevices(m_pInputs);
        *pVal = PQInputDevices(d).Detach();
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
    return NOERROR;
}

STDMETHODIMP CVidCtl::get_OutputsAvailable(BSTR CategoryGuid, IMSVidOutputDevices * * pVal)
{
    try {
        GUID2 catguid(CategoryGuid);
        return get__OutputsAvailable(&catguid, pVal);
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CVidCtl::get__OutputsAvailable(LPCGUID CategoryGuid, IMSVidOutputDevices * * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    try {
        if (!m_fInit) {
            Init();
        }
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return Error(IDS_CANT_INIT, __uuidof(IMSVidCtl), IDS_CANT_INIT);
    }
    try {
        *pVal = NULL;
    } catch(...) {
        return E_POINTER;
    }
    try {
        COutputDevices *p = static_cast<COutputDevices *>(m_pOutputs.p);
        if (!p || !p->Valid) {
            HRESULT hr = GetOutputs(GUID2(CategoryGuid));
            if (FAILED(hr)) {
                return hr;
            }
        }
        COutputDevices *d = new COutputDevices(m_pOutputs);
        *pVal = PQOutputDevices(d).Detach();
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
    return NOERROR;
}

STDMETHODIMP CVidCtl::get_VideoRenderersAvailable(IMSVidVideoRendererDevices * * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    try {
        if (!m_fInit) {
            Init();
        }
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return Error(IDS_CANT_INIT, __uuidof(IMSVidCtl), IDS_CANT_INIT);
    }
    try {
        *pVal = NULL;
    } catch(...) {
        return E_POINTER;
    }
    try {
        CVideoRendererDevices *p = static_cast<CVideoRendererDevices *>(m_pVRs.p);
        if (!p || !p->Valid) {
            HRESULT hr = GetVideoRenderers();
            if (FAILED(hr)) {
                return hr;
            }
        }
        CVideoRendererDevices *d = new CVideoRendererDevices(m_pVRs);
        if (!d) {
            return E_OUTOFMEMORY;
        }
        *pVal = PQVideoRendererDevices(d).Detach();
        if (!*pVal) {
            return E_UNEXPECTED;
        }
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
    return NOERROR;
}

STDMETHODIMP CVidCtl::get_AudioRenderersAvailable(IMSVidAudioRendererDevices * * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    try {
        if (!m_fInit) {
            Init();
        }
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return Error(IDS_CANT_INIT, __uuidof(IMSVidCtl), IDS_CANT_INIT);
    }
    try {
        *pVal = NULL;
    } catch(...) {
        return E_POINTER;
    }
    try {
        CAudioRendererDevices *p = static_cast<CAudioRendererDevices *>(m_pARs.p);
        if (!p || !p->Valid) {
            HRESULT hr = GetAudioRenderers();
            if (FAILED(hr)) {
                return hr;
            }
        }
        CAudioRendererDevices *d = new CAudioRendererDevices(m_pARs);
        if (!d) {
            return E_OUTOFMEMORY;
        }
        *pVal = PQAudioRendererDevices(d).Detach();
        if (!*pVal) {
            return E_UNEXPECTED;
        }
        return NOERROR;
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CVidCtl::get_FeaturesAvailable(IMSVidFeatures * * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    try {
        if (!m_fInit) {
            Init();
        }
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return Error(IDS_CANT_INIT, __uuidof(IMSVidCtl), IDS_CANT_INIT);
    }
    try {
        *pVal = NULL;
    } catch(...) {
        return E_POINTER;
    }
    try {
        CFeatures *p = static_cast<CFeatures *>(m_pFeatures.p);
        if (!p || !p->Valid) {
            HRESULT hr = GetFeatures();
            if (FAILED(hr)) {
                return hr;
            }
        }
        CFeatures *d = new CFeatures(m_pFeatures);
        *pVal = PQFeatures(d).Detach();
        return NOERROR;
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

HRESULT CVidCtl::Pause(void)
{
    VIDPERF_FUNC;
    try {
        if (!m_pInput || !m_pGraph) {
            return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidCtl), IDS_OBJ_NO_INIT);
        }
        BOOL lRes = 0;
        OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
    
        if (m_pGraph.IsPaused()) {
            return NOERROR;
        }

        HRESULT hr = S_OK;
        if (m_fGraphDirty) {
            hr = BuildGraph();
        }
        if (FAILED(hr)) {
            return hr;
        }

        PQMediaControl pmc(m_pGraph);
        if (!pmc) {
            return Error(IDS_NO_MEDIA_CONTROL, __uuidof(IMSVidCtl), IDS_NO_MEDIA_CONTROL);
        }
        hr = pmc->Pause();
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Pause() hr = " << std::hex << hr), "");
            return Error(IDS_CANT_PAUSE_GRAPH, __uuidof(IMSVidCtl), hr);
        }

        // This is to force the pause event to get thrown up to apps.
        OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);    
        return NOERROR;

    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

HRESULT CVidCtl::Stop(void)
{
    VIDPERF_FUNC;
    CPerfCounter pCounterStop;
    pCounterStop.Reset();
    try {
        TRACELM(TRACE_DETAIL, "CVidCtl::Stop()");
        if (!m_pInput || !m_pGraph) {
            return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidCtl), CO_E_NOTINITIALIZED);
        }
        BOOL lRes = 0;
        OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
        HRESULT hr;
        if (!m_pGraph.IsStopped()) {

            OAFilterState graphState = m_pGraph.GetState();

            // Notify all segments graph is about to stop
            ASSERT(m_pInput);
            hr = VWGraphSegment(m_pInput)->PreStop();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }

            if (!!m_pVideoRenderer) {
                hr = VWGraphSegment(m_pVideoRenderer)->PreStop();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
            if (!!m_pAudioRenderer) {
                hr = VWGraphSegment(m_pAudioRenderer)->PreStop();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }

            {
                VWOutputDevices::iterator i;
                for (i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
                    hr = VWGraphSegment(*i)->PreStop();
                    if (FAILED(hr) && hr != E_NOTIMPL) {
                        return hr;
                    }
                }
            }
            {
                VWFeatures::iterator i;
                for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
                    hr = VWGraphSegment(*i)->PreStop();
                    if (FAILED(hr) && hr != E_NOTIMPL) {
                        return hr;
                    }
                }
            }
            {
                VWSegmentList::iterator i;
                for(i = m_pComposites.begin(); i != m_pComposites.end(); ++i){
                    hr = VWGraphSegment(*i)->PreStop();
                    if (FAILED(hr) && hr != E_NOTIMPL) {
                        return hr;
                    }
                }
            }
            if (!!m_pVideoRenderer) {
                m_pVideoRenderer->put_Visible(false);
                m_pVideoRenderer->put_Owner(0);
            }

            // Stop the graph
            PQMediaControl pmc(m_pGraph);
            if (!pmc) {
                return Error(IDS_NO_MEDIA_CONTROL, __uuidof(IMSVidCtl), IDS_NO_MEDIA_CONTROL);
            }
            hr = pmc->Stop();
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Stop() hr = " << std::hex << hr), "");
                return Error(IDS_CANT_PAUSE_GRAPH, __uuidof(IMSVidCtl), hr);
            }
        }

        // Notify all segments graph is stopped
        ASSERT(m_pInput);
        hr = VWGraphSegment(m_pInput)->PostStop();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            return hr;
        }

        if (!!m_pVideoRenderer) {
            hr = VWGraphSegment(m_pVideoRenderer)->PostStop();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }
        if (!!m_pAudioRenderer) {
            hr = VWGraphSegment(m_pAudioRenderer)->PostStop();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }

        {
            VWOutputDevices::iterator i;
            for (i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
                hr = VWGraphSegment(*i)->PostStop();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
        }
        {
            VWFeatures::iterator i;
            for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
                hr = VWGraphSegment(*i)->PostStop();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
        }        
        {
            VWSegmentList::iterator i;
            for(i = m_pComposites.begin(); i != m_pComposites.end(); ++i){
                hr = VWGraphSegment(*i)->PostStop();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
        }
        FireViewChange();  // force refresh to repaint background immediately(black)
        OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
        pCounterStop.Stop();
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Stop() Stop Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterStop.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterStop.GetLastTime() % _100NS_IN_MS) << " ms"), "");
        return NOERROR;

    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

// Setup events handling
// If we have a window, then send notification messages to it
// If we are windowless, then set up a timer to process the messages
void CVidCtl::SetMediaEventNotification() {

    SetTimer();
    if (!m_fNotificationSet) {

        // If graph is built and notification hasn't been set
        // then set it here
        if (m_pGraph) {
            // Setup notification window for WM_MEDIAEVENT
            HRESULT hr = m_pGraph.SetMediaEventNotificationWindow(m_pTopWin->m_hWnd, WM_MEDIAEVENT, 0);
            if (FAILED(hr)) {
                THROWCOM(E_UNEXPECTED);
            }
            m_fNotificationSet = true;
        }        
    } 

    return;
}

// actually submit changes to VR
bool CVidCtl::RefreshVRSurfaceState() {
    TRACELM(TRACE_PAINT, "CVidCtl::RefreshVRSurfaceState()");
    if (m_pVideoRenderer) {
        HWND hOwner(m_CurrentSurface.Owner());
        HRESULT hr = m_pVideoRenderer->put_Owner(hOwner);
        if (FAILED(hr) || hOwner == INVALID_HWND || !::IsWindow(hOwner)) {
            TRACELM(TRACE_PAINT, "CVidCtl::RefreshVRSurfaceState() unowned, vis false");
            hr = m_pVideoRenderer->put_Visible(false);
            if (FAILED(hr)) {
                return false;
            }
        } else {
            hr = m_pVideoRenderer->put_Destination(m_CurrentSurface);
            if (FAILED(hr)) {
                return false;
            }
            hr = m_pVideoRenderer->put_Visible(m_CurrentSurface.IsVisible() ? VARIANT_TRUE : VARIANT_FALSE);
            if (FAILED(hr) && hr == E_FAIL) {
                return false;
            }
        }
        m_CurrentSurface.Dirty(false);
    }
    return true;
}


HRESULT CVidCtl::Refresh() {
    try {
        TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::Refresh() owner = " << m_CurrentSurface.Owner()), "");
        BOOL temp;
        if (!m_bInPlaceActive) {
            HRESULT hr = InPlaceActivate(OLEIVERB_INPLACEACTIVATE, NULL);
            if (FAILED(hr)) {
                return hr;
            }
        }
        CheckMouseCursor(temp);

        ComputeDisplaySize();
        SetExtents();
        if (m_pVideoRenderer) {
            RefreshVRSurfaceState();
            m_pVideoRenderer->Refresh();
        }
        FireViewChange();

        return NOERROR;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

#if 0

// old flawed OnDraw saved for reference

HRESULT CVidCtl::OnDraw(ATL_DRAWINFO& di)
{
    try {
        SetTimer();
        //SetMediaEventNotification();
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() visible = " << m_CurrentSurface.IsVisible() << "surf = " << m_CurrentSurface), "" );
        bool fOverlay = false;
        if (m_pVideoRenderer) {
            VARIANT_BOOL fo = VARIANT_FALSE;
            HRESULT hr = m_pVideoRenderer->get_UseOverlay(&fo);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't get useoverlay flag");
            }
            fOverlay = !!fo;
            hr = m_pVideoRenderer->put_ColorKey(m_clrColorKey);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't set color key on vr");
            }
#ifdef 0
            hr = m_pVideoRenderer->put_BorderColor(0x0000ff);
#else
            hr = m_pVideoRenderer->put_BorderColor(m_clrBackColor);
#endif
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't set border color on vr");
            }
            hr = m_pVideoRenderer->put_MaintainAspectRatio(m_fMaintainAspectRatio);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't set fMaintainAspectRatio on vr");
            }
        }
        // undone: if we're straddling a monitor edge in the multimon case, then we treat the smaller
        // portion as part of the border/background

        // undone: if we're on a monitor that our input device cannot reach(video port case) then we need
        // to paint the background color

        // we only force overlay and tell vmr not to paint color key if we're windowless
        // this allows us to put the color key in the correct z-order amongst a stack of
        // multiple windowless controls. when we do this we also need to paint the letter box
        // border otherwise it won't z-order right since it isn't colorkeyed.
        // if we're windowed then gdi, ddraw, and the vmr deal 
        // with the z-order correctly so we let the vmr do the color key and border for us and we
        // fill rect the bg color

        // so, we have three cases 
        // 1: paint the whole rect the color key color
        // 2: paint the whole rect the bg color
        // 3: paint the video portion colorkey and the borders bg

        if (di.dwDrawAspect != DVASPECT_CONTENT) {
            return DV_E_DVASPECT;
        }
        if (!di.hdcDraw) {
            return NOERROR;
        }
        CDC pdc(di.hdcDraw);
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() di.prcBounds " << *(reinterpret_cast<LPCRECT>(di.prcBounds))), "");
        CRect rcBounds(reinterpret_cast<LPCRECT>(di.prcBounds));
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rcBounds = " << rcBounds << " w = " << rcBounds.Width() << " h = " << rcBounds.Height()), "");
        long lBGColor = m_clrBackColor;
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() wndless = " << m_bWndLess << " active = " << m_bInPlaceActive << " !stopped = " << (m_pGraph ? !m_pGraph.IsStopped() : 0)), "");
        if (m_bNegotiatedWnd) {
            if (m_bWndLess) {
                HWND hwndParent;
                if (m_spInPlaceSite && m_spInPlaceSite->GetWindow(&hwndParent) == S_OK) {
                    m_CurrentSurface.Owner(hwndParent);
                }
                CheckSurfaceStateChanged(CScalingRect(m_rcPos));
            } else {
                m_CurrentSurface.Owner(m_hWndCD);
                CScalingRect r(::GetDesktopWindow());
                if (!::GetWindowRect(m_hWndCD, &r)) {
                    return HRESULT_FROM_WIN32(GetLastError());
                }
                CheckSurfaceStateChanged(r);
            }
        } else {
            m_CurrentSurface.Site(PQSiteWindowless(m_spInPlaceSite));
            CheckSurfaceStateChanged(CScalingRect(m_rcPos));
        }
        if (m_bInPlaceActive && fOverlay) {
            if (m_pGraph && !m_pGraph.IsStopped()) {
                TRACELSM(TRACE_PAINT, (dbgDump << "CVidCtl::OnDraw() m_rcPos = " << m_rcPos << " m_cursurf = " << m_CurrentSurface), "");
                TRACELSM(TRACE_PAINT, (dbgDump << "CVidCtl::OnDraw() m_cursurf rounded = " << m_CurrentSurface), "");
                // get the color from the current video renderer because we always notify it
                // if we've received a colorkey change but it may not notify us if one went directly to
                // the vr object.

                if (m_fMaintainAspectRatio) {
                    AspectRatio src(SourceAspect());
                    AspectRatio surf(m_rcPos);
                    TRACELSM(TRACE_PAINT, (dbgDump << "CVidCtl::OnDraw() Checking AR() src = " << src << " surf = " << surf), "");
                    if (src != surf) {
                        CBrush hb;
                        HBRUSH hbrc = hb.CreateSolidBrush(m_clrBackColor);
                        if (!hbrc) {
                            TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't create brush for letterbox");
                            THROWCOM(E_UNEXPECTED);
                        }

                        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rcBounds at border paint = " << rcBounds << " w = " << rcBounds.Width() << " h = " << rcBounds.Height()), "");
                        if (!pdc.FillRect(&rcBounds, hb)) {
                            DWORD er = GetLastError();
                            TRACELSM(TRACE_ERROR, (dbgDump << "CVidctrl::OnDraw() can't fill top/left letterbox rect er = " << er), "");
                            return HRESULT_FROM_WIN32(er);
                        }
                    }
                }
                lBGColor = m_clrColorKey;
                CRect SurfDP(m_CurrentSurface);
                TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() SurfDP before LPtoDP = " << SurfDP << " w = " << SurfDP.Width() << " h = " << SurfDP.Height()), "");
                if (di.hicTargetDev == di.hdcDraw) {
                    // ATL has a weird bug in the windowless case where they reset the transform 
                    // origins of hicTargetDev inadvertently.  this happens because in the windowless
                    // non metafile case ATLCreateTargetDC returns the existing hdcDraw instead
                    // of creatin a new dc so after that in CComControlBase::OnDrawAdvanced
                    // when the save hdcDraw and reset the origins, they change hicTargetDev
                    // too(since they're the same ptr).
                    // we undo this so that we can map in the same space and then put it back
                    // the way it was just to be safe
                    // currently, this works because in the non-metafile case atl always 
                    // does a prior SaveDC everywhere they call the derived control's OnDraw 
                    // since we already reject non-metafile above(it doesn't make sense for video)
                    // we can just check for pointer equality and temporarily undo their 
                    // origin change and then put it back the way it was.  if atl ever calls
                    // our ondraw for non-metafiles anywhere without doing a savedc then this
                    // will break bigtime.
                    ::RestoreDC(di.hdcDraw, -1);
                }
                if (!::LPtoDP(di.hicTargetDev, reinterpret_cast<LPPOINT>(&SurfDP), 2)) {
                    DWORD er = GetLastError();
                    TRACELSM(TRACE_ERROR, (dbgDump << "CVidctrl::OnDraw() can't LPToDP current surf er = " << er), "");
                    return HRESULT_FROM_WIN32(er);
                }
                if (di.hicTargetDev == di.hdcDraw) {
                    // restore the window state as per the above comment block
                    SaveDC(di.hdcDraw);
                    SetMapMode(di.hdcDraw, MM_TEXT);
                    SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
                    SetViewportOrgEx(di.hdcDraw, 0, 0, NULL);
                }
                TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() SurfDP after LPtoDP = " << SurfDP << " w = " << SurfDP.Width() << " h = " << SurfDP.Height()), "");
#if 1
                TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rcBounds prior to boundary intersect = " << rcBounds << " w = " << rcBounds.Width() << " h = " << rcBounds.Height()), "");
                rcBounds.IntersectRect(&SurfDP);
                TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rcBounds after to boundary intersect = " << rcBounds << " w = " << rcBounds.Width() << " h = " << rcBounds.Height()), "");
#endif
            }
        } else {
            if (m_pGraph && !m_pGraph.IsStopped()) {
                lBGColor = m_clrColorKey;
                if (m_pVideoRenderer) {
                    m_pVideoRenderer->RePaint(di.hdcDraw);
                    pdc = NULL; // don't delete the DC, it isn't ours        
                    return S_OK;
                }
            }
        }
        CBrush hb;
        HBRUSH hbrc = hb.CreateSolidBrush(lBGColor);
        if (!hbrc) {
            TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't create brush for mainrect");
            THROWCOM(E_UNEXPECTED);
        }

        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rcBounds at main paint = " << rcBounds << " w = " << rcBounds.Width() << " h = " << rcBounds.Height()), "");
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() bkcolor = " << hexdump(lBGColor)), "");

        if (!pdc.FillRect(&rcBounds, hb)) {
            DWORD er = GetLastError();
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidctrl::OnDraw() can't fill main video rect er = " << er), "");
            return HRESULT_FROM_WIN32(er);
        }
        pdc = NULL; // don't delete the DC, it isn't ours        

        return S_OK;
    } catch(...) {
        return E_UNEXPECTED;
    }

}

#else 

HRESULT CVidCtl::OnDrawAdvanced(ATL_DRAWINFO& di)
{
    try {
        SetTimer();
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() visible = " << m_CurrentSurface.IsVisible() << "surf = " << m_CurrentSurface), "" );
        bool fOverlay = false;
        if (m_pVideoRenderer) {
            VARIANT_BOOL fo = VARIANT_FALSE;
            HRESULT hr = m_pVideoRenderer->get_UseOverlay(&fo);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't get useoverlay flag");
            }
            fOverlay = !!fo;
            hr = m_pVideoRenderer->put_ColorKey(m_clrColorKey);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't set color key on vr");
            }
#if 0
            hr = m_pVideoRenderer->put_BorderColor(0x0000ff);
#else
            hr = m_pVideoRenderer->put_BorderColor(m_clrBackColor);
#endif
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't set border color on vr");
            }
            hr = m_pVideoRenderer->put_MaintainAspectRatio(m_fMaintainAspectRatio);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't set fMaintainAspectRatio on vr");
            }
        }

        if (di.dwDrawAspect != DVASPECT_CONTENT) {
            return DV_E_DVASPECT;
        }
        if (!di.hdcDraw) {
            return NOERROR;
        }

        // we only default to force overlay if we're windowless, but overlay is an independently controllable
        // boolean property that can be overriden.  based on this, if we're in useoverlay == true mode
        // then we tell vmr not to paint color key.  if we don't have an rgb overlay available that vmr 
        // event causes useoverlay to go false.
        // when we have the overlay, this allows us to put the color key in the correct z-order 
        // amongst a stack of multiple windowless controls such as html page elements in IE.
        // when we do this we also need to paint the letter box
        // border otherwise it won't z-order right since it isn't colorkeyed.
        // if we're windowed then gdi, ddraw, and the vmr deal 
        // with the z-order correctly so we let the vmr do the color key and border for us and we
        // fill rect the bg color

        // so, we have three cases 
        // 1: paint the whole rect the color key color
        // 2: paint the whole rect the bg color
        // 3: paint the video portion colorkey and the borders bg

        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() wndless = " << m_bWndLess << " active = " << m_bInPlaceActive << " !stopped = " << (m_pGraph ? !m_pGraph.IsStopped() : 0) << " mar = " << m_fMaintainAspectRatio), "");
        CSize szSrc;
        GetSourceSize(szSrc);
        CRect rctSrc(0, 0, szSrc.cx, szSrc.cy); // rectangle representing the actual source size(and aspect ratio)
        // in zero top-left coords
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rctSrc =  " << rctSrc), "");


        CScalingRect rctOuterDst(reinterpret_cast<LPCRECT>(di.prcBounds));  // rectangle representing our paint area in client device coords
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rctOuterDst =  " << rctOuterDst), "");
        CScalingRect rctInnerDst(rctOuterDst);  // rectangle representing where the video goes that we pass through 
        // to the VMR in client logical coords. assume its the whole
        // paint area for now
        CScalingRect rctTLBorder(0, 0, 0, 0);  // rectangle representing our top/left letter box(if necessary) in client logical coords
        CScalingRect rctBRBorder(0, 0, 0, 0);  // rectangle representing our bottom/left letter box(if necessary) in client logical coords

        CDC pdc(di.hdcDraw);
        long lInnerColor = m_clrBackColor;
#if 0
        if (!m_bNegotiatedWnd) {
            if (!rctOuterDst) {
                // pull rctOuterDst from site
                //   m_CurrentSurface.Site(PQSiteWindowless(m_spInPlaceSite));
                //   CheckSurfaceStateChanged(CScalingRect(m_rcPos));
            }
        }
#endif
        if (m_bInPlaceActive) {
            if (fOverlay) {
                if (m_pGraph && !m_pGraph.IsStopped()) {
                    TRACELM(TRACE_PAINT, "CVidCtl::OnDraw() letterboxing");
                    // get the color from the current video renderer because we always notify it
                    // if we've received a colorkey change but it may not notify us if one went directly to
                    // the vr object.
                    lInnerColor = m_clrColorKey;
                    if (m_fMaintainAspectRatio) {
                        ComputeAspectRatioAdjustedRects(rctSrc, rctOuterDst, rctInnerDst, rctTLBorder, rctBRBorder);
                        ASSERT((!rctTLBorder && !rctBRBorder) || (rctTLBorder && rctBRBorder));  // both zero or both valid
                        if (rctTLBorder && rctBRBorder) {
                            CBrush lb;
                            HBRUSH hbrc = lb.CreateSolidBrush(m_clrBackColor);
                            if (!hbrc) {
                                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't create brush for letterbox borders");
                                THROWCOM(E_UNEXPECTED);
                            }
                            if (!pdc.FillRect(rctTLBorder, lb)) {
                                DWORD er = GetLastError();
                                TRACELSM(TRACE_ERROR, (dbgDump << "CVidctrl::OnDraw() can't fill rctTLBorder er = " << er), "");
                                return HRESULT_FROM_WIN32(er);
                            }
                            if (!pdc.FillRect(rctBRBorder, lb)) {
                                DWORD er = GetLastError();
                                TRACELSM(TRACE_ERROR, (dbgDump << "CVidctrl::OnDraw() can't fill rctBRBorder er = " << er), "");
                                return HRESULT_FROM_WIN32(er);
                            }
                        }
                    }
                }
            } else {
                if (m_pGraph && !m_pGraph.IsStopped()) {
                    TRACELM(TRACE_PAINT, "CVidctrl::OnDraw() vmr repaint");
                    lInnerColor = m_clrColorKey;
                    if (m_pVideoRenderer) {
                        CheckSurfaceStateChanged(rctInnerDst);
                        m_pVideoRenderer->RePaint(di.hdcDraw);
                        pdc = NULL; // don't delete the DC, it isn't ours        
                        return S_OK;
                    }
                }
            }
        }
        CheckSurfaceStateChanged(rctInnerDst);
        CBrush hb;
        HBRUSH hbrc = hb.CreateSolidBrush(lInnerColor);
        if (!hbrc) {
            TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't create brush for mainrect");
            THROWCOM(E_UNEXPECTED);
        }

        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rctInnerDst at main paint = " << rctInnerDst), "");
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() innercolor = " << hexdump(lInnerColor)), "");

        if (!pdc.FillRect(rctInnerDst, hb)) {
            DWORD er = GetLastError();
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidctrl::OnDraw() can't fill main video rect er = " << er), "");
            return HRESULT_FROM_WIN32(er);
        }
        pdc = NULL; // don't delete the DC, it isn't ours        

        return S_OK;
    } catch(...) {
        return E_UNEXPECTED;
    }

}

#endif

// this code is taken from the vmr utility library alloclib function LetterBoxDstRect().  
// its been modified to match my variable names, do inline __int64 arithmetic, use ATL CRect references,
// and always compute borders.
void CVidCtl::ComputeAspectRatioAdjustedRects(const CRect& rctSrc, const CRect& rctOuterDst, CRect& rctInnerDst, CRect& rctTLBorder, CRect& rctBRBorder) {
    // figure out src/dest scale ratios
    int iSrcWidth  = rctSrc.Width();
    int iSrcHeight = rctSrc.Height();

    int iOuterDstWidth  = rctOuterDst.Width();
    int iOuterDstHeight = rctOuterDst.Height();

    int iInnerDstWidth;
    int iInnerDstHeight;

    //
    // work out if we are Column or Row letter boxing
    //

    __int64 iWHTerm = iSrcWidth * (__int64)iOuterDstHeight;
    iWHTerm /= iSrcHeight;
    if (iWHTerm <= iOuterDstWidth) {

        //
        // column letter boxing - we add border color bars to the
        // left and right of the video image to fill the destination
        // rectangle.
        //
        iWHTerm = iOuterDstHeight * (__int64)iSrcWidth;
        iInnerDstWidth  = iWHTerm / iSrcHeight;
        iInnerDstHeight = iOuterDstHeight;
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::ComputeAspectRatioAdjustedRects() col lb iw = " << iInnerDstWidth << " ih = " << iInnerDstHeight), "");
    }
    else {

        //
        // row letter boxing - we add border color bars to the top
        // and bottom of the video image to fill the destination
        // rectangle
        //
        iWHTerm = iOuterDstWidth * (__int64)iSrcHeight;
        iInnerDstHeight = iWHTerm / iSrcWidth;
        iInnerDstWidth  = iOuterDstWidth;
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::ComputeAspectRatioAdjustedRects() row lb iw = " << iInnerDstWidth << " ih = " << iInnerDstHeight), "");
    }


    //
    // now create a centered inner letter-boxed rectangle within the current outer destination rect
    //

    rctInnerDst.left   = rctOuterDst.left + ((iOuterDstWidth - iInnerDstWidth) / 2);
    rctInnerDst.right  = rctInnerDst.left + iInnerDstWidth;

    rctInnerDst.top    = rctOuterDst.top + ((iOuterDstHeight - iInnerDstHeight) / 2);
    rctInnerDst.bottom = rctInnerDst.top + iInnerDstHeight;

    //
    // Fill out the border rects
    //

    if (rctOuterDst.top != rctInnerDst.top) {
        // border is on the top
        rctTLBorder = CRect(rctOuterDst.left, rctOuterDst.top,
            rctInnerDst.right, rctInnerDst.top);
    }
    else {
        // border is on the left
        rctTLBorder = CRect(rctOuterDst.left, rctOuterDst.top,
            rctInnerDst.left, rctInnerDst.bottom);
    }

    if (rctOuterDst.top != rctInnerDst.top) {
        // border is on the bottom
        rctBRBorder = CRect(rctInnerDst.left, rctInnerDst.bottom,
            rctOuterDst.right, rctOuterDst.bottom);
    }
    else {
        // border is on the right
        rctBRBorder = CRect(rctInnerDst.right, rctInnerDst.top, 
            rctOuterDst.right, rctOuterDst.bottom);
    }

    return;
}

LRESULT CVidCtl::OnShowWindow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    bHandled = false;
    m_CurrentSurface.Visible(wParam != 0);
    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnShowWindow() visible = " << m_CurrentSurface.IsVisible() << "surf = " << m_CurrentSurface), "" );
    RefreshVRSurfaceState();
    return  0;
}

LRESULT CVidCtl::OnMoveWindow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    bHandled = false;
    CSize cursize(m_CurrentSurface.Width(), m_CurrentSurface.Height());
    HWND parent = ::GetParent(m_CurrentSurface.Owner());
    POINTS p(MAKEPOINTS(lParam));
    CPoint pt(p.x, p.y);
    CScalingRect newpos(pt, cursize, parent);
    ::InvalidateRect(m_CurrentSurface.Owner(), newpos, false); // force repaint to recalc letterboxing, etc.
    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnMoveWindow() visible = " << m_CurrentSurface.IsVisible() << "surf = " << m_CurrentSurface), "" );
    return 0;
}

LRESULT CVidCtl::OnSizeWindow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    bHandled = false;
    CScalingRect newsize(m_CurrentSurface.TopLeft(), CSize(lParam), m_CurrentSurface.Owner());
    ::InvalidateRect(m_CurrentSurface.Owner(), newsize, false); // force repaint to recalc letterboxing, etc.
    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnSizeWindow() visible = " << m_CurrentSurface.IsVisible() << "surf = " << m_CurrentSurface), "" );
    return 0;
}

LRESULT CVidCtl::OnWindowPosChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    bHandled = false;
    m_CurrentSurface.WindowPos(reinterpret_cast<LPWINDOWPOS>(lParam));
    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnWindowPosChanged() visible = " << m_CurrentSurface.IsVisible() << "surf = " << m_CurrentSurface), "" );
    ::InvalidateRect(m_CurrentSurface.Owner(), m_CurrentSurface, false); // force repaint to recalc letterboxing, etc.
    return 0;
}

LRESULT CVidCtl::OnTerminate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    Stop();
    KillTimer();
    bHandled = false;
    return 0;
}

#if 0
[id(DISPID_CLICK)] void Click();
[id(DISPID_DBLCLICK)] void DblClick();
[id(DISPID_KEYDOWN)] void KeyDown(short* KeyCode, short Shift);
[id(DISPID_KEYPRESS)] void KeyPress(short* KeyAscii);
[id(DISPID_KEYUP)] void KeyUp(short* KeyCode, short Shift);
[id(DISPID_MOUSEDOWN)] void MouseDown(short Button, short Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
[id(DISPID_MOUSEMOVE)] void MouseMove(short Button, short Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
[id(DISPID_MOUSEUP)] void MouseUp(short Button, short Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
[id(DISPID_ERROREVENT)] void Error(short Number, BSTR* Description, long Scode, BSTR Source, BSTR HelpFile, long HelpContext, boolean* CancelDisplay);
#endif

LRESULT CVidCtl::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    if (m_TimerID == wParam) {
        if (m_bNegotiatedWnd) {
            if (!m_bWndLess) {
                if (m_CurrentSurface.Width() && m_CurrentSurface.Height()) {
                    CScalingRect prevpos(m_CurrentSurface);
                    prevpos.Owner(::GetDesktopWindow());
                    CScalingRect curpos(::GetDesktopWindow());
                    if (!::GetWindowRect(m_CurrentSurface.Owner(), &curpos)) {
                        return HRESULT_FROM_WIN32(GetLastError());
                    }
                    if (curpos != prevpos) {
                        FireViewChange();  // force a repaint
                    }
                }
            }
        }

        BOOL lRes = 0;
        if (m_pGraph) {
            // as long as we're here, check for events too.
            OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
        }

        bHandled = true;
    } else {
        bHandled = false;
    }
    return 0;
}

LRESULT CVidCtl::OnPNP(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    // undone: implement pnp support
    return 0;
}

LRESULT CVidCtl::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    return CheckMouseCursor(bHandled);
}

LRESULT CVidCtl::OnPower(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    // undone: implement rational power management support
    return 0;
}

LRESULT CVidCtl::OnDisplayChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    if (m_pVideoRenderer) {
        m_pVideoRenderer->DisplayChange();
        FireViewChange();
    }
    return 0;
}

HRESULT CVidCtl::OnPreEventNotify(LONG lEvent, LONG_PTR LParam1, LONG_PTR LParam2){
    try{
        TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::PreEventNotify ev = " << hexdump(lEvent)), "");         
        TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::PreEventNotify lp1 = " << hexdump(LParam1)), "");
        TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::PreEventNotify lp2 = " << hexdump(LParam2)), "");
        MSVidCtlStateList prevstate = m_State;
        MSVidCtlStateList newstate = m_State;
        // Events where stop is the new state
        if (lEvent == EC_BUILT) {
            prevstate = STATE_UNBUILT;
            newstate = STATE_STOP;
        }
        if (lEvent == EC_STATE_CHANGE && LParam1 == State_Stopped) {
            newstate = STATE_STOP;
        }
        // Events where play is the new state
        if (lEvent == EC_STATE_CHANGE && LParam1 == State_Running) {
            newstate = STATE_PLAY;
        }
        // Events where unbuilt is the new state
        if( lEvent == EC_UNBUILT ) {
            newstate = STATE_UNBUILT;
        }
        // Events where paused is the new state
        if( lEvent == EC_STATE_CHANGE && LParam1 == State_Paused ) {
            newstate = STATE_PAUSE;
        }
        if( lEvent == EC_PAUSED ){
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::PreEventNotify EC_PAUSED"), "");       
        }
        if (newstate != prevstate) {
            m_State = newstate;
            Fire_StateChange(prevstate, m_State);
        }
        if (lEvent == EC_DISPLAY_CHANGED) {
            ComputeDisplaySize();
        }
        if (lEvent == EC_VMR_RECONNECTION_FAILED){
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::PreEventNotify EC_VMR_RECONNECTION_FAILED"), ""); 
            HRESULT hr = Stop();
            if(FAILED(hr)){
                return hr;
            }
            return Error(IDS_NOT_ENOUGH_VIDEO_MEMORY, __uuidof(IMSVidCtl), IDS_NOT_ENOUGH_VIDEO_MEMORY);
        }
        if(lEvent == EC_COMPLETE){
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::PreEventNotify EC_COMPLETE"), "");     
        }
        // undone: recompute displaysize if video source changes
    }
    catch (HRESULT hr){
        return hr;
    }
    catch (...){
        return E_UNEXPECTED;
    }
    return E_NOTIMPL;
}

HRESULT CVidCtl::OnPostEventNotify(LONG lEvent, LONG_PTR LParam1, LONG_PTR LParam2){
    try{
        if (lEvent == EC_VMR_RENDERDEVICE_SET) {
#if 0
            CSize s;
            GetSourceSize(s);
            TRACELSM(TRACE_DEBUG, (dbgDump << "CVidCtl::OnPostEventNotify() VMR_RENDERDEVICE_SET srcrect = " << s), "");
#endif
            Refresh();
        }
    }
    catch (HRESULT hr){
        return hr;
    }
    catch (...){
        return E_UNEXPECTED;
    }
    return E_NOTIMPL;
}

LRESULT CVidCtl::OnMediaEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {

    PQMediaEventEx pme(m_pGraph);
    LONG        lEvent;
    LONG_PTR    lParam1, lParam2;
    HRESULT hr2;
    try{
        if (!pme) {
            return E_UNEXPECTED;
        }
        hr2 = pme->GetEvent(&lEvent, &lParam1, &lParam2, 0);
        while (SUCCEEDED(hr2)){
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::OnMediaevent ev = " << hexdump(lEvent) << " lp1 = " << hexdump(lParam1) << " lp2 = " << hexdump(lParam2)), "");       
            HRESULT hr;
            /*** Check who wants the Event ***/
            /*** If they want it should return something other than E_NOTIMPL ***/

            // Does CVidCtl want it?
            hr = OnPreEventNotify(lEvent, lParam1, lParam2);

            //Does the input want it?
            if(hr == E_NOTIMPL){
                PQGraphSegment pSeg(m_pInput);
                if (pSeg) {
                    hr = pSeg->OnEventNotify(lEvent, lParam1, lParam2);
                }
            }

            // Do any of the features want it?
            if (hr == E_NOTIMPL) {

                for ( VWFeatures::iterator i = m_pFeaturesInUse.begin(); hr == E_NOTIMPL && i != m_pFeaturesInUse.end(); ++i) {
                    hr = PQGraphSegment((*i).punkVal)->OnEventNotify(lEvent, lParam1, lParam2);
                }
            }

            //Does the video renderer want it?
            if(hr == E_NOTIMPL){
                PQGraphSegment pSeg(m_pVideoRenderer);
                if(pSeg){
                    hr = pSeg->OnEventNotify(lEvent, lParam1, lParam2);
                }
            }

            // Does the audio renderer want it?
            if(hr == E_NOTIMPL){
                PQGraphSegment pSeg(m_pAudioRenderer);
                if(pSeg){
                    hr = pSeg->OnEventNotify(lEvent, lParam1, lParam2);
                }
            }

            // Do any of the outputs want it?  
            if(hr == E_NOTIMPL){  
                if (!!m_pOutputsInUse && m_pOutputsInUse.begin() != m_pOutputsInUse.end()) {
                    for (VWOutputDevices::iterator i = m_pOutputs.begin(); hr == E_NOTIMPL && i != m_pOutputs.end(); ++i) {
                        hr = PQGraphSegment((*i).punkVal)->OnEventNotify(lEvent, lParam1, lParam2);
                    }
                }
            }

            // Finally do any of the composites want it?
            if(hr == E_NOTIMPL){
                for(VWSegmentList::iterator i = m_pComposites.begin(); hr == E_NOTIMPL && i != m_pComposites.end(); i++){    
                    hr = PQGraphSegment(*i)->OnEventNotify(lEvent, lParam1, lParam2);
                }  
            }

            // Check again to see if CVidCtl want to do anything else regardless of whether or not
            // it got handled by a segment
            hr = OnPostEventNotify(lEvent, lParam1, lParam2);

            //
            // Remember to free the event params
            //
            pme->FreeEventParams(lEvent, lParam1, lParam2) ;
            hr2 = pme->GetEvent(&lEvent, &lParam1, &lParam2, 0);
        }
    }
    catch (HRESULT hr){
        return hr;
    }
    catch (...){
        return E_UNEXPECTED;
    }
    return 0;
}

// rev2: if we ever redist to 9x then we need to examine the mfc dbcs processing
// and adapt it.
LRESULT CVidCtl::OnChar(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    //(UINT nChar, UINT nRepCnt, UINT nFlags)

    SHORT nCharShort = LOWORD(wParam);
    HRESULT hr = NOERROR;
    if (m_pInputNotify) {
        hr = m_pInputNotify->KeyPress(&nCharShort);
    }
    if (hr != S_FALSE) {
        Fire_KeyPress(&nCharShort);
    }
    if (!nCharShort) {
        return 0;
    }

    return 1;
}

LRESULT CVidCtl::OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    if (!(KF_REPEAT & HIWORD(lParam))) {
        short keycode = LOWORD(wParam);
        short shiftstate = GetShiftState();
        HRESULT hr = NOERROR;
        if (m_pInputNotify) {
            hr = m_pInputNotify->KeyDown(&keycode, shiftstate);
        }
        if (hr != S_FALSE) {
            Fire_KeyDown(&keycode, shiftstate);
        }
        if (!keycode) {
            return 0;
        }
    }

    return 1;
}

LRESULT CVidCtl::OnKeyUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    short keycode = LOWORD(wParam);
    short shiftstate = GetShiftState();
    HRESULT hr = NOERROR;
    if (m_pInputNotify) {
        hr = m_pInputNotify->KeyUp(&keycode, shiftstate);
    }
    if (hr != S_FALSE) {
        Fire_KeyUp(&keycode, shiftstate);
    }
    if (!keycode) {
        return 0;
    }

    return 1;
}

// undone: syskey stuff
LRESULT CVidCtl::OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    if (!m_bUIActive) {
        m_bPendingUIActivation = true;
    }

    return 1;
}

LRESULT CVidCtl::OnCancelMode(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    SetControlFocus(false);
    SetControlCapture(false);
    m_bPendingUIActivation = false;

    return 1;
}

LRESULT CVidCtl::OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT /*nFlags*/, CPoint point)
{
    CheckMouseCursor(bHandled);
    CPoint point(lParam);
    HRESULT hr = NOERROR;
    if (m_pInputNotify) {
        hr = m_pInputNotify->MouseMove(m_usButtonState, m_usShiftState, point.x, point.y);
    }
    if (hr != S_FALSE) {
        Fire_MouseMove(m_usButtonState, m_usShiftState, point.x, point.y);
    }

    return 1;
}

LRESULT CVidCtl::OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonDown(MSVIDCTL_LEFT_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnLButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonUp(MSVIDCTL_LEFT_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnLButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonDblClk(MSVIDCTL_LEFT_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnMButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonDown(MSVIDCTL_MIDDLE_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnMButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonUp(MSVIDCTL_MIDDLE_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnMButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonDblClk(MSVIDCTL_MIDDLE_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnRButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonDown(MSVIDCTL_RIGHT_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnRButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonUp(MSVIDCTL_RIGHT_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnRButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonDblClk(MSVIDCTL_RIGHT_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnXButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    UINT button = HIWORD(wParam);
    if (button & XBUTTON1) {
        OnButtonDown(MSVIDCTL_X_BUTTON1, wParam, lParam);
    } else {
        OnButtonDown(MSVIDCTL_X_BUTTON2, wParam, lParam);
    }

    return 1;
}

LRESULT CVidCtl::OnXButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    UINT button = HIWORD(wParam);
    if (button & XBUTTON1) {
        OnButtonUp(MSVIDCTL_X_BUTTON1, wParam, lParam);
    } else {
        OnButtonUp(MSVIDCTL_X_BUTTON2, wParam, lParam);
    }

    return 1;
}

LRESULT CVidCtl::OnXButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    UINT button = HIWORD(wParam);
    if (button & XBUTTON1) {
        OnButtonDblClk(MSVIDCTL_X_BUTTON1, wParam, lParam);
    } else {
        OnButtonDblClk(MSVIDCTL_X_BUTTON2, wParam, lParam);
    }

    return 1;
}

void CVidCtl::OnButtonDown(USHORT nButton, UINT nFlags, CPoint point)
{
    if (nButton == MSVIDCTL_LEFT_BUTTON) {
        if (m_bWndLess || m_bUIActive || m_bPendingUIActivation) {
            SetControlFocus(true);
        }
    }
    if (!m_usButtonState && (m_bUIActive || m_bPendingUIActivation)) {
        SetControlCapture(true);
    }

    m_usButtonState |= nButton;

    HRESULT hr = NOERROR;
    if (m_pInputNotify) {
        hr = m_pInputNotify->MouseDown(m_usButtonState, m_usShiftState, point.x, point.y);
    }
    if (hr != S_FALSE) {
        Fire_MouseDown(m_usButtonState, m_usShiftState, point.x, point.y);
    }

    m_iDblClkState &= ~nButton;

    return;
}

void CVidCtl::OnButtonUp(USHORT nButton, UINT nFlags, CPoint point)
{
    m_usButtonState &= nButton;

    if (!m_usButtonState) {
        SetControlCapture(false);
    }

    HRESULT hr = NOERROR;
    if (m_pInputNotify) {
        hr = m_pInputNotify->MouseUp(m_usButtonState, m_usShiftState, point.x, point.y);
    }
    if (hr != S_FALSE) {
        Fire_MouseUp(m_usButtonState, m_usShiftState, point.x, point.y);
    }

    if (!(m_iDblClkState & nButton))
    {
        bool bHitUs = false;
        if (m_bWndLess) {
            bHitUs = !!::PtInRect(&m_rcPos, point);
        } else if (m_hWnd && ::IsWindow(m_hWnd)) {
            CRect rect;
            GetClientRect(&rect);
            bHitUs = !!rect.PtInRect(point);
        }
        if (!bHitUs) {
            return;
        }
        hr = NOERROR;
        if (m_pInputNotify) {
            hr = m_pInputNotify->Click();
        }
        if (hr != S_FALSE) {
            Fire_Click();
        }
        if (!m_bInPlaceActive) {
            InPlaceActivate(OLEIVERB_INPLACEACTIVATE, NULL);
        } else if (!m_bUIActive && m_bPendingUIActivation)
        {
            InPlaceActivate(OLEIVERB_UIACTIVATE, NULL);
        }
        m_bPendingUIActivation = FALSE;
    } else {
        m_iDblClkState &= ~nButton;
    }

    return;
}

void CVidCtl::OnButtonDblClk(USHORT nButton, UINT nFlags, CPoint point)
{
    HRESULT hr = NOERROR;
    if (m_pInputNotify) {
        hr = m_pInputNotify->DblClick();
    }

    if (hr != S_FALSE) {
        Fire_DblClick();
    }

    m_iDblClkState |= nButton;
    if (!m_bInPlaceActive) {
        InPlaceActivate(OLEIVERB_INPLACEACTIVATE, NULL);
    } else if (!m_bUIActive && m_bPendingUIActivation){
        InPlaceActivate(OLEIVERB_UIACTIVATE, NULL);
    }

    m_bPendingUIActivation = FALSE;

    return;
}

// this routine sets up all the crossbar routing so the streams coming out of the
// input get where they're supposed to go
HRESULT CVidCtl::RouteStreams() {
    VIDPERF_FUNC;
    int isEncoder = -1;
    VWStream vpath;
    VWStream apath;
    // See how far we have to route the audio/video
    CComQIPtr<IMSVidAnalogTuner> qiITV(m_pInput);
    if(!!qiITV){
        CComQIPtr<ITuneRequest> qiTR;
        HRESULT hr = qiITV->get_Tune(&qiTR);
        if(SUCCEEDED(hr)){
            qiITV->put_Tune(qiTR);
        }
    }
    // undone: in win64 size() is really __int64.  fix output operator for
    // that type and remove cast
    {
        if (!!m_pOutputsInUse && m_pOutputsInUse.begin() != m_pOutputsInUse.end()) {

            for (VWOutputDevices::iterator i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
                CComQIPtr<IMSVidOutputDevice> pqODev = VWGraphSegment(*i);
                if(!pqODev){
                    return E_UNEXPECTED;
                }

                GUID2 outputID;
                HRESULT hr = pqODev->get__ClassID(&outputID);
                if(FAILED(hr)){
                    return hr;
                }

                if(outputID == CLSID_MSVidStreamBufferSink){
                    CComQIPtr<IMSVidStreamBufferSink> pqTSSink(pqODev);
                    hr = pqTSSink->NameSetLock();
                    if(FAILED(hr)){
                        return hr;
                    }
                }

            }
        }
    }
    // undone: other dest segments

    return NOERROR;
}

#if 0
CString CVidCtl::GetMonitorName(HMONITOR hm) {
    MONITORINFOEX mi;
    mi.cbSize = sizeof(mi);
    if (!GetMonitorInfo(hm, &mi)) {
        THROWCOM(HRESULT_FROM_WIN32(GetLastError()));
    }
    return CString(mi.szDevice);
}

HRESULT CVidCtl::GetDDrawNameForMonitor(HMONITOR hm, VMRGUID& guid) {
    PQVMRMonitorConfig pmc(m_pVideoRenderer);
    if (!pmc) {
        return E_UNEXPECTED;  // should always exist by now
    }
    DWORD dwCount;
    HRESULT hr = pmc->GetAvailableMonitors(NULL, 0, &dwCount);
    if (FAILED(hr)) {
        return hr;
    }
    VMRMONITORINFO* pInfo = reinterpret_cast<VMRMONITORINFO*>(_alloca(sizeof(VMRMONITORINFO) * dwCount));
    if (!pInfo) {
        return E_OUTOFMEMORY;
    }
    hr = pmc->GetAvailableMonitors(pInfo, dwCount, &dwCount);
    if (FAILED(hr)) {
        return hr;
    }
    CString csMonitorName(GetMonitorName(hm));

    for (int i = 0; i < dwCount; ++i) {
        CString csDevName(pInfo[i].szDevice);
        if (csDevName == csMonitorName) break;
    }
    if (i >= dwCount) {
        // no ddraw device exist with a name which matches the monitor name
        return HRESULT_FROM_WIN32(ERROR_DEV_NOT_EXIST);
    }
    guid = pInfo[i].guid;
    return NOERROR;
}

HRESULT CVidCtl::GetCapsForMonitor(HMONITOR hm, LPDDCAPS pDDCaps) {
    VMRGUID ddname;
    HRESULT hr = GetDDrawNameForMonitor(hm, ddname);
    if (FAILED(hr)) {
        return hr;
    }
    PQDirectDraw7 pDD;
    hr = DirectDrawCreateEx(ddname.pGUID, reinterpret_cast<LPVOID*>(&pDD), IID_IDirectDraw7, NULL);
    if (FAILED(hr)) {
        return hr;
    }
    return pDD->GetCaps(pDDCaps, NULL);
}

bool CVidCtl::MonitorHasHWOverlay(HMONITOR hm) {
    DDCAPS caps;
    HRESULT hr = GetCapsForMonitor(hm, &caps);
    if (SUCCEEDED(hr)) {
        // undone: if caps include hw overlay {
        //      return true;
        // }

    }
    return false;
}

bool CVidCtl::WindowHasHWOverlay(HWND hWnd) {
#if 0 // undone: turn on when finished
    DWORD dwFlags = MONITOR_DEFAULT_TO_NEAREST
        if (hWnd == INVALID_HWND_VALUE) {
            // if we don't have an hwnd yet, assume the primary
            hWnd = HWND_DESKTOP;
            dwFlags = MONITOR_DEFAULT_TO_PRIMARY;
        }
        HMONITOR hm = ::MonitorFromWindow(hWnd, dwFlags);
        return MonitorHasHWOverlay(hm);
#else
    return true; // mimic current behavior
#endif
}
#endif

// ISupportsErrorInfo
STDMETHODIMP CVidCtl::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &__uuidof(IMSVidCtl),
    };
    for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i], riid))
            return S_OK;
    }
    return S_FALSE;
}
STDMETHODIMP CVidCtl::put_ServiceProvider(/*[in]*/ IUnknown * pServiceP){
    if(!pServiceP){
        punkCert.Release();
        return S_FALSE;
    }
    punkCert = pServiceP;
    if(!punkCert){
        return E_NOINTERFACE;
    }
    return S_OK;
}
STDMETHODIMP CVidCtl::QueryService(REFIID service, REFIID iface, LPVOID* ppv) {  
    if (service == __uuidof(IWMReader) && iface == IID_IUnknown && 
        (VWGraphSegment(m_pInput).ClassID() == CLSID_MSVidFilePlaybackDevice || 
        VWGraphSegment(m_pInput).ClassID() == CLSID_MSVidStreamBufferSource)) {
        if (!!punkCert) {
            return punkCert.CopyTo(ppv);
        }
    }
    PQServiceProvider psp(m_spInPlaceSite);
    if (!psp) {
        if (m_spClientSite) {
            HRESULT hr = m_spClientSite->QueryInterface(IID_IServiceProvider, reinterpret_cast<LPVOID*>(&psp));
            if (FAILED(hr)) {
                return E_FAIL;
            }
        } else {
            return E_FAIL;
        }
    }
    return psp->QueryService(service, iface, ppv);
}
HRESULT CVidCtl::SetClientSite(IOleClientSite *pClientSite){
    if(!!pClientSite){
        HRESULT hr = IsSafeSite(pClientSite);
        if(FAILED(hr)){
            return hr;
        }
    }
    return IOleObjectImpl<CVidCtl>::SetClientSite(pClientSite);
}

#if 0
HRESULT CVidCtl::DoVerb(LONG iVerb, LPMSG pMsg, IOleClientSite* pActiveSite, LONG linddex,
                        HWND hwndParent, LPCRECT lprcPosRect){
                            if(!m_spClientSite){
                                return E_FAIL;
                            }
                            else{
                                return IOleObjectImpl<CVidCtl>::DoVerb(iVerb, pMsg, pActiveSite, linddex, hwndParent, lprcPosRect);
                            }
                        }
#endif

#endif //TUNING_MODEL_ONLY

                        // end of file - VidCtl.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\tuningspacecontainer.h ===
/////////////////////////////////////////////////////////////////////////////////////
// TuningSpaceContainer.h : Declaration of the CSystemTuningSpaces
// Copyright (c) Microsoft Corporation 1999.

#ifndef __TUNINGSPACECONTAINER_H_
#define __TUNINGSPACECONTAINER_H_

#pragma once

#include <regexthread.h>
#include <objectwithsiteimplsec.h>
#include "tuningspacecollectionimpl.h"

namespace BDATuningModel {
	
const int DEFAULT_MAX_COUNT = 32;  // by default only allow 32 tuning spaces in order to prevent
								   // dnos attacks from filling up disk/registry with bogus
								   // tuning space entries.

/////////////////////////////////////////////////////////////////////////////
// CSystemTuningSpaces
class CSystemTuningSpaces : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSystemTuningSpaces, &CLSID_SystemTuningSpaces>,
	public ISupportErrorInfo,
    public IObjectWithSiteImplSec<CSystemTuningSpaces>,
    public IObjectSafetyImpl<CSystemTuningSpaces, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
	public TuningSpaceCollectionImpl<CSystemTuningSpaces, ITuningSpaceContainer, &__uuidof(ITuningSpaceContainer), &LIBID_TunerLib> {
public:
    CSystemTuningSpaces() : 
	    m_CurrentAccess(KEY_READ), 
		m_MaxCount(DEFAULT_MAX_COUNT), 
		m_cookieRegExp(0),
        m_pRET(NULL) {
	}
    virtual ~CSystemTuningSpaces() {
	    ATL_LOCK();
		if (m_pRET) {
			HRESULT hr = m_pRET->CallWorker(CRegExThread::RETHREAD_EXIT);
			ASSERT(SUCCEEDED(hr));
			delete m_pRET;
			m_pRET = NULL;
		}
        m_mapTuningSpaces.clear();
        m_mapTuningSpaceNames.clear();
	}

    HRESULT FinalConstruct();
    void FinalRelease();

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_TUNINGSPACECONTAINER_PROGID, 
						   IDS_REG_TUNINGSPACECONTAINER_DESC,
						   LIBID_TunerLib,
						   CLSID_SystemTuningSpaces, tvBoth);

DECLARE_NOT_AGGREGATABLE(CSystemTuningSpaces)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSystemTuningSpaces)
	COM_INTERFACE_ENTRY(ITuningSpaceContainer)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP_WITH_FTM()

    HRESULT RegisterTuningSpaces(HINSTANCE hInst);

    HRESULT UnregisterTuningSpaces();
    PUnknown m_pSite;

public:

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ITuningSpaceContainer
	STDMETHOD(get_Item)(/*[in]*/ VARIANT varIndex, /*[out, retval]*/ ITuningSpace **ppTuningSpace);
    STDMETHOD(put_Item)(/*[in]*/VARIANT varIndex, /*[in]*/ITuningSpace *pTuningSpace);
    STDMETHOD(Add)(/*[in]*/ ITuningSpace *pTuningSpace, /*[out]*/ VARIANT* pvarIndex);
    STDMETHOD(Remove)(/*[in]*/ VARIANT varIndex);
    STDMETHOD(TuningSpacesForCLSID)(/*[in]*/ BSTR bstrSpace, /*[out, retval]*/ ITuningSpaces **ppTuningSpaces);
    STDMETHOD(_TuningSpacesForCLSID)(/*[in]*/ REFCLSID clsidSpace, /*[out, retval]*/ ITuningSpaces **ppTuningSpaces);
    STDMETHOD(TuningSpacesForName)(/*[in]*/ BSTR bstrName, /*[out, retval]*/ ITuningSpaces **ppTuningSpaces);
    STDMETHOD(FindID)(/*[in]*/ ITuningSpace* pTS, /*[out, retval]*/ long *pID);
    STDMETHOD(get_MaxCount)(/*[out, retval]*/ LONG *plCount);
    STDMETHOD(put_MaxCount)(LONG lCount);

protected:
    typedef std::map<CComBSTR, ULONG> TuningSpaceNames_t;          // unique name->id mapping

    CComPtr<ICreatePropBagOnRegKey> m_pFactory;
    HANDLE m_hMutex;
    // REV2:  use registry change notification to refresh cache

	ULONG m_MaxCount; // prevent dnos attack from filling registry with bogus tuning spaces
    PQPropertyBag2 m_pTSBag;
    CRegKey m_RootKey;
    REGSAM m_CurrentAccess;

    TuningSpaceNames_t m_mapTuningSpaceNames;

    HRESULT OpenRootKeyAndBag(REGSAM NewAccess);
    HRESULT ChangeAccess(REGSAM DesiredAccess);
    CComBSTR GetUniqueName(ITuningSpace* pTS);
    ULONG GetID(CComBSTR& UniqueName);
    HRESULT DeleteID(ULONG id);
    HRESULT Add(CComBSTR& un, long PreferredID, PQTuningSpace pTS, VARIANT *pvarAssignedID);

    // takes a variant index and returns an iterator to the cache and possibly an interator 
    // to the name cache depending on index type
    // on return if its != end() and itn == end() and name is wanted then look up with overloaded Find
    HRESULT Find(VARIANT varIndex, long& ID, TuningSpaceContainer_t::iterator &its, CComBSTR& UniqueName, TuningSpaceNames_t::iterator &itn);

    // takes a cache iterator and returns a name cache iterator
    HRESULT Find(TuningSpaceContainer_t::iterator &its, CComBSTR& UniqueName, TuningSpaceNames_t::iterator &itn);

	PQGIT m_pGIT;
	DWORD m_cookieRegExp;
	CRegExThread *m_pRET; // shared worker thread
};

/////////////////////////////////////////////////////////////////////////////
// CSystemTuningSpaces
class ATL_NO_VTABLE DECLSPEC_UUID("969EE7DA-7058-4922-BA78-DA3905D0325F") CTuningSpacesBase : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTuningSpacesBase, &__uuidof(CTuningSpacesBase)>,
	public ISupportErrorInfoImpl<&__uuidof(ITuningSpaces)>,
    public IObjectWithSiteImplSec<CTuningSpacesBase>,
	public TuningSpaceCollectionImpl<CTuningSpacesBase, ITuningSpaces, &IID_ITuningSpaces, &LIBID_TunerLib>,
	public IObjectSafetyImpl<CTuningSpacesBase, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CTuningSpacesBase() {}

DECLARE_NOT_AGGREGATABLE(CTuningSpacesBase)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTuningSpacesBase)
	COM_INTERFACE_ENTRY(ITuningSpaces)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

};

/////////////////////////////////////////////////////////////////////////////
class CTuningSpaces : public CComObject<CTuningSpacesBase> {
public:
	CTuningSpaces() {}
// we'd like to say:
//	CTuningSpaces(TuningSpaceContainer_t& init) : m_mapTuningSpaces(init.begin(), init.end()) {}
// but a compiler bug is causing it to match this against the explicit map ctor that just takes
// a pred and an allocator.  so, we'll do it the hard way.
	CTuningSpaces(TuningSpaceContainer_t& init) {
		for (TuningSpaceContainer_t::iterator i = init.begin(); i != init.end(); ++i) {
            CComVariant v((*i).second);
			if ((*i).second.vt != VT_UNKNOWN && (*i).second.vt != VT_DISPATCH) {
				THROWCOM(E_UNEXPECTED); //corrupt in-memory collection
			}
			PQTuningSpace pTS((*i).second.punkVal);
            PQTuningSpace newts;
            HRESULT hr = PQTuningSpace(pTS)->Clone(&newts);
            if (FAILED(hr)) {
                THROWCOM(hr);
            }
            m_mapTuningSpaces[(*i).first] = CComVariant(newts);
		}
	}

	STDMETHOD(get_Item)(/*[in]*/ VARIANT varIndex, /*[out, retval]*/ ITuningSpace **ppTuningSpace) {
		try {
			if (!ppTuningSpace) {
				return E_POINTER;
			}
			if (varIndex.vt != VT_UI4) {
                HRESULT hr = ::VariantChangeType(&varIndex, &varIndex, 0, VT_UI4);
				if (FAILED(hr))
				{
					return Error(IDS_E_TYPEMISMATCH, __uuidof(ITuningSpaces), hr);
				}
			}
			ATL_LOCK();
			TuningSpaceContainer_t::iterator its = m_mapTuningSpaces.find(varIndex.ulVal);
			if (its == m_mapTuningSpaces.end()) {
				return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaces), E_INVALIDARG);
			}
			_ASSERT(((*its).second.vt == VT_UNKNOWN) || ((*its).second.vt == VT_DISPATCH));
			PQTuningSpace pTS((*its).second.punkVal);
			if (!pTS) {
				return Error(IDS_E_NOINTERFACE, __uuidof(ITuningSpaces), E_NOINTERFACE);
			}

			return pTS.CopyTo(ppTuningSpace);
		} catch(...) {
			return E_UNEXPECTED;
		}
	}
};


HRESULT RegisterTuningSpaces(HINSTANCE hInst);

HRESULT UnregisterTuningSpaces();

};


 
#endif //__TUNINGSPACECONTAINER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\vidctl.h ===
/////////////////////////////////////////////////////////////////////////////
// VidCtl.h : Declaration of the CVidCtl
// Copyright (c) Microsoft Corporation 1999-2001.


#pragma once

#ifndef __VidCtl_H_
#define __VidCtl_H_

#include <msvidctl.h>
#include "devices.h"
#include "composition.h"
#include "surface.h"
#include "topwin.h"
#include <objectwithsiteimplsec.h>
#include "msvidcp.h"
#include "perfcntr.h"

typedef CComQIPtr<IMSVidGraphSegmentUserInput, &__uuidof(IMSVidGraphSegmentUserInput)> PQGraphSegmentUserInput;

#define OCR_ARROW_DEFAULT_SYSCUR 100       // Default Windows OEM arrow system cursor

// if source size isn't known default to 480P since its most common
const int DEFAULT_SIZE_X = 640;
const int DEFAULT_SIZE_Y = 480;

#ifdef ASYNC_VR_NOTIFY
#define SURFACESTATECHANGED() \         // post message to self
                if (m_CurrentSurface.IsDirty() { \
                        ::PostMessage(self registered msg,???); \
                }
#endif

const OLE_COLOR NO_DEVICE_COLOR = 0x0; //black if no device set(Default Background Color)
const OLE_COLOR DEFAULT_COLOR_KEY_COLOR = 0xff00ff; // magenta
const int DEFAULT_TIMER_ID = 42;
const int DEFAULT_WINDOW_SYNCH_TIMER_TIME = 1000; //ms

#define WM_MEDIAEVENT               (WM_USER+101)

const CRect crect0(0, 0, 0, 0);
const LPCRECT pcrect0 = &crect0;

class CTopWin;
/////////////////////////////////////////////////////////////////////////////
// CVidCtl
class ATL_NO_VTABLE CVidCtl :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComControl<CVidCtl>,
    public CStockPropImpl<CVidCtl, IMSVidCtl, &IID_IMSVidCtl, &LIBID_MSVidCtlLib>,
    public IPersistStreamInitImpl<CVidCtl>,
    public IOleControlImpl<CVidCtl>,
    public IOleObjectImpl<CVidCtl>,
    public IOleInPlaceActiveObjectImpl<CVidCtl>,
    public IViewObjectExImpl<CVidCtl>,
    public IOleInPlaceObjectWindowlessImpl<CVidCtl>,
    public ISupportErrorInfo,
    public IConnectionPointContainerImpl<CVidCtl>,
    public IPersistStorageImpl<CVidCtl>,
    public IPersistPropertyBagImpl<CVidCtl>,
    public ISpecifyPropertyPagesImpl<CVidCtl>,
    public IQuickActivateImpl<CVidCtl>,
    public IDataObjectImpl<CVidCtl>,
    public IProvideClassInfo2Impl<&CLSID_MSVidCtl, &DIID__IMSVidCtlEvents, &LIBID_MSVidCtlLib>,
    public IPropertyNotifySinkCP<CVidCtl>,
    public IObjectSafetyImpl<CVidCtl, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
    public IMSVidGraphSegmentContainer,
    public CComCoClass<CVidCtl, &CLSID_MSVidCtl>,
    public CProxy_IMSVidCtlEvents< CVidCtl >,
    public IServiceProvider,
    public IObjectWithSiteImplSec<CVidCtl>,
	public IPointerInactiveImpl<CVidCtl>
    {
private:
// can't find this catid in any system header so we're defining our own
struct __declspec(uuid("1D06B600-3AE3-11cf-87B9-00AA006C8166")) CATID_WindowlessObject;
friend CTopWin;        
public:
    CVidCtl() :
        m_fInit(false),
        m_fGraphDirty(true),
        m_TimerID(DEFAULT_TIMER_ID),
        m_WindowSynchTime(DEFAULT_WINDOW_SYNCH_TIMER_TIME),
        m_fTimerOn(false),
        m_fNotificationSet(false),
        m_pComposites(VWSegmentList()),
        m_iCompose_Input_Video(-1),
        m_iCompose_Input_Audio(-1),
        m_clrBackColor(NO_DEVICE_COLOR),
        m_clrColorKey(DEFAULT_COLOR_KEY_COLOR),
        m_iDblClkState(0),
        m_usButtonState(0),
        m_usShiftState(0),
        m_bPendingUIActivation(false),
        m_fMaintainAspectRatio(VARIANT_FALSE),
        m_pTopWin(NULL),
		m_hCursor(NULL),
        m_dwROTCookie(0),
        m_videoSetNull(false),
        m_dslDisplaySize(dslDefaultSize),
        m_audioSetNull(false)
        // undone: default displaystyle to source size
		{
            m_State = STATE_UNBUILT;
            m_bAutoSize = false; // default to autosized
			m_bRecomposeOnResize = true;
            if (!VideoTypes.size()) {
                VideoTypes.push_back(MEDIATYPE_Video);
                VideoTypes.push_back(MEDIATYPE_AnalogVideo);

            }
            if (!AudioTypes.size()) {
                AudioTypes.push_back(MEDIATYPE_Audio);
                AudioTypes.push_back(MEDIATYPE_AnalogAudio);
            }

#ifndef ENABLE_WINDOWLESS_SUPPORT
            m_bWindowOnly = true;
#endif            
        }   
        
    virtual ~CVidCtl();
        
    // IMPORTANT: no matter how tempting don't add OLEMISC_IGNOREACTIVATEWHENVISIBLE
    // to the registration of this control.  it breaks the case where we return
    // a running vidctl from the tv: pluggable protocol.  we never get activated.
    REGISTER_FULL_CONTROL(IDS_PROJNAME,
        IDS_REG_VIDCTL_PROGID,
        IDS_REG_VIDCTL_DESC,
        LIBID_MSVidCtlLib,
        CLSID_MSVidCtl, 1, 0,
		OLEMISC_ACTIVATEWHENVISIBLE | 
		OLEMISC_RECOMPOSEONRESIZE | OLEMISC_CANTLINKINSIDE | 
		OLEMISC_INSIDEOUT);
        
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_CATEGORY_MAP(CVidCtl)
    IMPLEMENTED_CATEGORY(CATID_Control)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
    IMPLEMENTED_CATEGORY(CATID_Programmable)
    IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
    IMPLEMENTED_CATEGORY(CATID_PersistsToStorage)
#ifdef ENABLE_WINDOWLESS_SUPPORT
    IMPLEMENTED_CATEGORY(__uuidof(CATID_WindowlessObject))
#endif
END_CATEGORY_MAP()

BEGIN_COM_MAP(CVidCtl)
    COM_INTERFACE_ENTRY(IMSVidCtl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
#ifdef ENABLE_WINDOWLESS_SUPPORT
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
#endif
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IPersistStorage)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IMSVidGraphSegmentContainer)
	COM_INTERFACE_ENTRY(IPointerInactive)
	COM_INTERFACE_ENTRY(IServiceProvider)
	COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

BEGIN_PROP_MAP(CVidCtl)
        PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
        PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
        PROP_ENTRY("AutoSize", DISPID_AUTOSIZE, CLSID_NULL)
        PROP_ENTRY("Enabled", DISPID_ENABLED, CLSID_NULL)
        PROP_ENTRY("TabStop", DISPID_TABSTOP, CLSID_NULL)
        PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_NULL)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CVidCtl)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
        CONNECTION_POINT_ENTRY(DIID__IMSVidCtlEvents)
END_CONNECTION_POINT_MAP()

void ComputeAspectRatioAdjustedRects(const CRect& rctSrc, const CRect& rctOuterDst, CRect& rctInnerDst, CRect& rctTLBorder, CRect& rctlBRBorder);
HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);

static MediaMajorTypeList VideoTypes;
static MediaMajorTypeList AudioTypes;

SurfaceState m_CurrentSurface;

CTopWin* m_pTopWin;

UINT m_iDblClkState;
bool m_bPendingUIActivation;
USHORT m_usButtonState;  // stock oa event bit positions
USHORT m_usShiftState;
HCURSOR m_hCursor; // mouse cursor to use over our window when overlay active to prevent colorkey bleed through

DWORD m_dwROTCookie;

void OnButtonDown(USHORT nButton, UINT nFlags, CPoint point);
void OnButtonUp(USHORT nButton, UINT nFlags, CPoint point);
void OnButtonDblClk(USHORT nButton, UINT nFlags, CPoint point);

#define MSG_FUNC(func) LRESULT func(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

MSG_FUNC(OnShowWindow);
MSG_FUNC(OnMoveWindow);
MSG_FUNC(OnSizeWindow);

inline MSG_FUNC(OnSurfaceStateChanged) {
        RefreshVRSurfaceState();
        return 0;
}

MSG_FUNC(OnWindowPosChanged);
MSG_FUNC(OnTerminate);
MSG_FUNC(OnTimer);
MSG_FUNC(OnMediaEvent);
MSG_FUNC(OnDisplayChange);
MSG_FUNC(OnPower);
MSG_FUNC(OnPNP);
MSG_FUNC(OnSetCursor);


MSG_FUNC(OnChar);
MSG_FUNC(OnKeyDown);
MSG_FUNC(OnKeyUp);
#if 0 // undone:
MSG_FUNC(OnSysKeyDown);
MSG_FUNC(OnSysKeyUp);
#endif

MSG_FUNC(OnCancelMode);
MSG_FUNC(OnMouseActivate);
MSG_FUNC(OnMouseMove);

MSG_FUNC(OnLButtonDown);
MSG_FUNC(OnLButtonUp);
MSG_FUNC(OnLButtonDblClk);

MSG_FUNC(OnMButtonDown);
MSG_FUNC(OnMButtonUp);
MSG_FUNC(OnMButtonDblClk);
MSG_FUNC(OnRButtonDown);
MSG_FUNC(OnRButtonUp);
MSG_FUNC(OnRButtonDblClk);
MSG_FUNC(OnXButtonDown);
MSG_FUNC(OnXButtonUp);
MSG_FUNC(OnXButtonDblClk);
#if 0 // undone:
MSG_FUNC(OnMouseWheel);
#endif


// undone: make sure we call onterminate for windowless close functions

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
BEGIN_MSG_MAP(CVidCtl)
        MESSAGE_HANDLER(WM_SHOWWINDOW, OnShowWindow)
        MESSAGE_HANDLER(WM_MOVE, OnMoveWindow)
        MESSAGE_HANDLER(WM_SIZE, OnSizeWindow)
        MESSAGE_HANDLER(WM_WINDOWPOSCHANGED, OnWindowPosChanged)
        MESSAGE_HANDLER(WM_CLOSE, OnTerminate)
        MESSAGE_HANDLER(WM_NCDESTROY, OnTerminate)
        MESSAGE_HANDLER(WM_DESTROY, OnTerminate)
        MESSAGE_HANDLER(WM_TIMER, OnTimer)
        MESSAGE_HANDLER(WM_MEDIAEVENT, OnMediaEvent)
        MESSAGE_HANDLER(WM_DISPLAYCHANGE, OnDisplayChange)
        MESSAGE_HANDLER(WM_POWERBROADCAST, OnPower)
        MESSAGE_HANDLER(WM_DEVICECHANGE, OnPNP)
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)

        // undone: decide if we also need to do something with the following:
        // WM_ENDSESSION
        // WM_QUERYENDSESSION
        // WM_QUERYPOWERBROADCAST
        // WM_DEVMODECHANGE

#if 0
        MESSAGE_HANDLER(WM_NCHITTEST, )
        MESSAGE_HANDLER(WM_NCLBUTTONDOWN, )
#endif

        MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
        MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
        MESSAGE_HANDLER(WM_CHAR, OnChar)
#if 0 // undone:
        MESSAGE_HANDLER(WM_SYSKEYDOWN, OnSysKeyDown)
        MESSAGE_HANDLER(WM_SYSKEYUP, OnSysKeyUp)
#endif

// Stock Events
        MESSAGE_HANDLER(WM_CANCELMODE, OnCancelMode)
        MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
        MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)

        MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
        MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
        MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDblClk)

        MESSAGE_HANDLER(WM_MBUTTONDOWN, OnMButtonDown)
        MESSAGE_HANDLER(WM_MBUTTONUP, OnMButtonUp)
        MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnMButtonDblClk)
        MESSAGE_HANDLER(WM_RBUTTONDOWN, OnRButtonDown)
        MESSAGE_HANDLER(WM_RBUTTONUP, OnRButtonUp)
        MESSAGE_HANDLER(WM_RBUTTONDBLCLK, OnRButtonDblClk)
        MESSAGE_HANDLER(WM_XBUTTONDOWN, OnXButtonDown)
        MESSAGE_HANDLER(WM_XBUTTONUP, OnXButtonUp)
        MESSAGE_HANDLER(WM_XBUTTONDBLCLK, OnXButtonDblClk)
#if 0 // undone:
        MESSAGE_HANDLER(WM_MOUSEWHEEL, OnMouseWheel)
#endif
// also xbutton and wheel

        //       async: update MESSAGE_HANDLER(Register message, OnSurfaceStateChanged)
        CHAIN_MSG_MAP(CComControl<CVidCtl>)
        DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
        int m_TimerID;
        bool m_fTimerOn;
        int m_WindowSynchTime;
        bool m_fNotificationSet;

		USHORT GetShiftState() {
			BOOL bShift = (GetKeyState(VK_SHIFT) < 0);
			BOOL bCtrl  = (GetKeyState(VK_CONTROL) < 0);
			BOOL bAlt   = (GetKeyState(VK_MENU) < 0);

			return (short)(bShift + (bCtrl << 1) + (bAlt << 2));
		}


// ISupportsErrorInfo
        STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);


// IViewObjectEx
        DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// Helpers
public:
// IMSVidCtl
public:
    MSVidCtlStateList m_State;
    DSGraph m_pGraph;
    PQCreateDevEnum m_pSystemEnum;
    PQFilterMapper m_pFilterMapper;

    // available collections
    VWInputDevices m_pInputs;
	PQGraphSegmentUserInput m_pInputNotify;
    VWOutputDevices m_pOutputs;
    VWFeatures m_pFeatures;
    VWVideoRendererDevices m_pVRs;  // video renderers
    VWAudioRendererDevices m_pARs;  // audio renderers

    // chosen devices&features
    PQInputDevice m_pInput;
    VWOutputDevices m_pOutputsInUse;
    PQVRGraphSegment m_pVideoRenderer;
    PQAudioRenderer m_pAudioRenderer;
    VWFeatures m_pFeaturesInUse;

    // Composition Segments
    VWSegmentList m_pComposites;
    int m_iCompose_Input_Video;
    int m_iCompose_Input_Audio;
    // undone: vector of these for features and outputs

    // REV2: ultimately we probably want streams to be a core dshow facility
    // but for now they're a list of xbar input/output point pairs just like in
    // win98 gold.
    VWStreamList m_Streams;

    // stock properties
    OLE_COLOR m_clrBackColor;
    BOOL m_bEnabled;
    BOOL m_bTabStop;
    BOOL m_bValid;

    STDMETHOD(get_State)(MSVidCtlStateList *lState);
    OLE_COLOR m_clrColorKey;
    DisplaySizeList m_dslDisplaySize;
    VARIANT_BOOL m_fMaintainAspectRatio;

    GUID2 m_InputsCatGuid;
    GUID2 m_CurViewCatGuid;
    CComVariant m_CurView;
    
    // Event handler
    HRESULT OnPreEventNotify(LONG lEvent, LONG_PTR LParam1, LONG_PTR LParam2);
    HRESULT OnPostEventNotify(LONG lEvent, LONG_PTR LParam1, LONG_PTR LParam2);

protected:
    bool m_fInit;
    bool m_fGraphDirty;
    void Init(void);
    bool m_audioSetNull;
    bool m_videoSetNull;
    CComPtr<IUnknown> punkCert;
    HRESULT GetInputs(const GUID2& CategoryGuid, VWInputDevices& pInputs);
    HRESULT GetOutputs(const GUID2& CategoryGuid);
    HRESULT GetVideoRenderers(void);
    HRESULT GetAudioRenderers(void);
    HRESULT GetFeatures(void);
    HRESULT SelectView(VARIANT *pv, bool fNext);
    HRESULT SelectViewFromSegmentList(CComVariant &v, VWInputDevices& list, PQInputDevice& m_pInput);
    HRESULT LoadDefaultVR(void);
    HRESULT LoadDefaultAR(void);
    HRESULT Compose(VWGraphSegment &Up, VWGraphSegment &Down, int &NewIdx);
    HRESULT BuildGraph(void);
    HRESULT RunGraph(void);
    HRESULT DecomposeSegment(VWGraphSegment& pSegment);
    HRESULT DecomposeAll();
    HRESULT RouteStreams(void);
    void SetMediaEventNotification();


protected:

	HRESULT SetControlCapture(bool bCapture) {
		if (m_bInPlaceActive && (m_bUIActive || m_bPendingUIActivation)) {
			if (!m_bWndLess) {
				if (bCapture) {
					if (m_hWnd) {
						HWND h;
						h = ::SetCapture(m_hWnd);
						return (h = m_hWnd) ? NOERROR : E_FAIL;
					}
				} else {
					BOOL rc = ::ReleaseCapture();
					if (!rc) {
						return HRESULT_FROM_WIN32(::GetLastError());
					}
				}
			} else {
				return m_spInPlaceSite->SetFocus(bCapture);
			}
		}
		return NOERROR;
	}

  bool CheckSurfaceStateChanged(CScalingRect& pos) {
       TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::CheckSurfaceStateChanged() pos = " << pos), "");
        m_CurrentSurface = pos;
        ValidateSurfaceState();
        return RefreshVRSurfaceState();
    }

    void CheckTopWin() {
        if (m_pTopWin) {
            return;
        }
        m_pTopWin = new CTopWin(this);
        m_pTopWin->Init();
    }

    UINT SetTimer() {
        if (!m_fTimerOn) {
            CheckTopWin();  
            m_fTimerOn = true;
            return m_pTopWin->SetTimer(m_TimerID, m_WindowSynchTime);
        }
        return 0;
    }

    void KillTimer() {
        if (m_pTopWin) {
            if (m_fTimerOn) {
                m_pTopWin->KillTimer(42);
            }
        } else if (m_fTimerOn) {
            CComControl<CVidCtl>::KillTimer(42);
        }
    }


    bool RefreshVRSurfaceState();

    void SetExtents() {
		TRACELM(TRACE_PAINT, "CVidCtl::SetExtents()");
        CSize prevNat(m_sizeNatural), prevSize(m_sizeExtent);
        CSize newsize(0, 0);
        if (m_pVideoRenderer) {
            CRect r;
            HRESULT hr = m_pVideoRenderer->get_Source(r);
            if (FAILED(hr)) {
                GetSourceSize(m_sizeNatural);
            } else {
                m_sizeNatural.cx = r.Width();
                m_sizeNatural.cy = r.Height();
            }
        } 
        if (m_bAutoSize) {
            ComputeDisplaySize();
            if (prevNat != m_sizeNatural || 
                prevSize != m_sizeExtent) {
                FireOnSizeChange();
            }
        }
    }

    void FireOnSizeChange() {
		TRACELM(TRACE_PAINT, "CVidCtl::FireOnSizeChange()");
        if (m_CurrentSurface != m_rcPos) {
            if (m_pTopWin) {
			    TRACELM(TRACE_PAINT, "CVidCtl::FireOnSizeChange() firing");
                m_pTopWin->PostMessage(WM_USER + CTopWin::WMUSER_SITE_RECT_WRONG, 0, 0);
            }
        }
    }

    void OnSizeChange() {
        // if we've already negotiated a site then 
        // notify our container that our rect size has changed
        // this can be because the source changed(such as broadcast show boundary)
        CScalingRect r(m_rcPos);
        CSize s;
        AtlHiMetricToPixel(&m_sizeExtent, &s);
        TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnSizeChange() new sz = " << s), "" );
        r.top = m_rcPos.top;
        r.left = m_rcPos.left;
        r.right = m_rcPos.left + s.cx;
        r.bottom = m_rcPos.top + s.cy;
        if (m_spInPlaceSite && r != m_rcPos && m_bAutoSize) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnSizeChange() changing to " << r << " from  " << m_rcPos), "" );
            HRESULT hr = m_spInPlaceSite->OnPosRectChange(r);
            if (FAILED(hr)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnSizeChange() site notify failed.  hr = " << hexdump(hr)), "" );
                return;
            }
        }
        return;
    }

    AspectRatio SourceAspect() {
        AspectRatio ar(4, 3);
        if (m_pGraph) {
            if (m_pVideoRenderer) {
                CSize p, a;
                HRESULT hr = m_pVideoRenderer->get_NativeSize(&p, &a);
                if (SUCCEEDED(hr))  {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::SourceAspect() ar = " << a), "");
                    if (a.cx && a.cy) {
                        ar = a;
                    }
                }
            }
        }
        return ar;  // default
    }

    void GetSourceSize(SIZE& s) {
        CSize a;
		if (m_pVideoRenderer) {
			HRESULT hr = m_pVideoRenderer->get_NativeSize(&s, &a);
			if (FAILED(hr) || !s.cx || !s.cy) {
				s.cx = DEFAULT_SIZE_X;
				s.cy = DEFAULT_SIZE_Y;
			}
		} else {
			s.cx = DEFAULT_SIZE_X;
			s.cy = DEFAULT_SIZE_Y;
		}
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidCtl::GetSourceSize() sz = " << s), "");
    }


    bool ValidateSurfaceState() {
#if 0
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidCtl::ValidateSurfaceState() m_bAutoSize = " << m_bAutoSize << " fMaintain " << m_fMaintainAspectRatio << " cursurf " << m_CurrentSurface << " objrct = " << m_rcPos), "");
        if (m_fMaintainAspectRatio) {
            AspectRatio src;
            src = SourceAspect();
            AspectRatio surf;
            surf = m_CurrentSurface.Aspect();
            if (!!surf && !!src && surf != src) {
                TRACELM(TRACE_PAINT, "CVidctrl::ValidateSurfaceState() aspect wrong");
                if (m_CurrentSurface.Round(src)) {
                    ASSERT(src == m_CurrentSurface.Aspect());
                } else {
                    // aspect ratios don't match and Round didn't fix it.
                    _ASSERT(false);
                }

            }
        }
#endif
        return true;
    }

    void ComputeDisplaySize() {
        CSize s;
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidCtl::ComputeDisplaySize() dsl = " << m_dslDisplaySize), "");
        switch (m_dslDisplaySize) {
        case dslSourceSize:
            GetSourceSize(s);
            break;
        case dslHalfSourceSize:
            GetSourceSize(s);
            s.cx >>= 1;
            s.cy >>= 1;
            break;
        case dslDoubleSourceSize:
            GetSourceSize(s);
            s.cx <<= 1;
            s.cy <<= 1;
            break;
        case dslFullScreen: {
            CRect rcdesk;
            ::GetWindowRect(::GetDesktopWindow(), &rcdesk);
            s.cx = rcdesk.Width();
            s.cy = rcdesk.Height();
            break;
        }
        case dslHalfScreen: {
            CScalingRect rcdesk;
            rcdesk.Owner(::GetDesktopWindow());
            ::GetWindowRect(rcdesk.Owner(), &rcdesk);
            rcdesk.Owner(m_CurrentSurface.Owner());
            s.cx = rcdesk.Width() * 3 / 4;
            s.cy = rcdesk.Height() * 3 / 4;
            break;
        }
        case dslQuarterScreen: {
            CScalingRect rcdesk;
            rcdesk.Owner(::GetDesktopWindow());
            ::GetWindowRect(rcdesk.Owner(), &rcdesk);
            rcdesk.Owner(m_CurrentSurface.Owner());
            s.cx = rcdesk.Width() / 2;
            s.cy = rcdesk.Height() / 2;
            break;
        }
        case dslSixteenthScreen: {
            CScalingRect rcdesk;
            rcdesk.Owner(::GetDesktopWindow());
            ::GetWindowRect(rcdesk.Owner(), &rcdesk);
            rcdesk.Owner(m_CurrentSurface.Owner());
            s.cx = rcdesk.Width() / 4;
            s.cy = rcdesk.Height() / 4;
            break;
        }}
        TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::ComputeDisplaySize() sz = " << s), "");
        AtlPixelToHiMetric(&s, &m_sizeExtent);
        OnSizeChange();
    }
#if 0
    CString GetMonitorName(HMONITOR hm);
    bool WindowHasHWOverlay(HWND hWnd);
    bool MonitorHasHWOverlay(HMONITOR hm);
    HRESULT GetCapsForMonitor(HMONITOR hm, LPDDCAPS pDDCaps);
    HRESULT GetDDrawNameForMonitor(HMONITOR hm, VMRGUID& guid);
#endif

public:

        STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::SetObjectRects() pos = " << *prcPos << " clip = " << *prcClip), "");
            if (prcPos == NULL || prcClip == NULL)
    		    return E_POINTER;
            bool bRectChange = !::EqualRect(prcPos, &m_rcPos);
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::SetObjectRects() bRectChange = " << bRectChange), "");
            HRESULT hr = IOleInPlaceObjectWindowlessImpl<CVidCtl>::SetObjectRects(prcPos, prcClip);
            if (FAILED(hr)) {
                return hr;
            }
            if (bRectChange) {
                FireViewChange();
            }
            return NOERROR;
        }

        HRESULT OnPostVerbShow() {
            SetTimer();
            m_CurrentSurface.Visible(true);
            RefreshVRSurfaceState();
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnPostVerbShow() visible = " << m_CurrentSurface.IsVisible() << " rect = " << CRect(m_CurrentSurface)), "" );
            return NOERROR;
        }

        HRESULT OnPostVerbUIActivate() {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnPostVerbUIActivate() visible = " << m_CurrentSurface.IsVisible()), "" );
			return OnPostVerbInPlaceActivate();
        }

        HRESULT OnPostVerbInPlaceActivate() {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnPostVerbInPlaceActivate() visible = " << m_CurrentSurface.IsVisible()), "" );
			HRESULT hr = OnPostVerbShow();
			if (FAILED(hr)) {
				return hr;
			}
			if (m_bWndLess) {
				m_CurrentSurface.Site(PQSiteWindowless(m_spInPlaceSite));
			} else {
				m_CurrentSurface.Owner(m_hWnd);
			}
            RefreshVRSurfaceState();
            return NOERROR;
        }

        HRESULT OnPreVerbHide() {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnPreVerbHide() visible = " << m_CurrentSurface.IsVisible()), "" );
			HRESULT hr = OnInPlaceDeactivate();
            m_CurrentSurface.Visible(false);
            KillTimer();
            RefreshVRSurfaceState();
            return hr;
        }
		HRESULT OnInPlaceDeactivate() {
            TRACELM(TRACE_DETAIL, "CVidctrl::OnInPlaceDeactivate()");
            HRESULT hr = OnUIDeactivate();
            if((long)m_State > 0){
                Stop();
            }
			m_CurrentSurface.Owner(INVALID_HWND);
            RefreshVRSurfaceState();
			return hr;
		}

        HRESULT OnUIDeactivate() {
            SetControlCapture(false);
            m_bPendingUIActivation = false;
            return NOERROR;
        }

		HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::InPlaceActivate() iverb = " << iVerb), "");
			HRESULT hr = CComControlBase::InPlaceActivate(iVerb, prcPosRect);
			if (SUCCEEDED(hr)) {
				if (DoesVerbUIActivate(iVerb)) {
					hr = OnPostVerbUIActivate();				
				} else {
					hr = OnPostVerbInPlaceActivate();
					if (FAILED(hr)) {
						return hr;
					}
				}	
			}
			return hr;
		}

#if 0
		STDMETHOD(DoVerb)(LONG iVerb, LPMSG pMsg, IOleClientSite *pActiveSite, LONG lIndex, HWND hParent, const RECT* prcPosRect) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::DoVerb() iverb = " << iVerb), "");
            HRESULT hr = IOleObjectImpl<CVidCtl>::DoVerb(iVerb, pMsg, pActiveSite, lIndex, hParent, prcPosRect);
			return hr;
		}
#endif

		void DoSetCursor() {
			if (!m_hCursor) {
			   // Create a default arrow cursor
				m_hCursor = (HCURSOR) LoadImage((HINSTANCE) NULL,
										  MAKEINTRESOURCE(OCR_ARROW_DEFAULT_SYSCUR),
										  IMAGE_CURSOR,0,0,0);

			}
			::SetCursor(m_hCursor);
		}
		LRESULT CheckMouseCursor(BOOL& bHandled) {
            try{
                // we can be running but not inplaceactive yet if we got started from a pluggable protocol
                if (m_pGraph && m_pGraph.IsPlaying() && m_pVideoRenderer && m_bInPlaceActive) {
                    CComQIPtr<IMSVidVideoRenderer2> sp_VidVid(m_pVideoRenderer);
                    if(sp_VidVid){
                        VARIANT_BOOL effects;
                        HRESULT hr = sp_VidVid->get_SuppressEffects(&effects);
                        if(SUCCEEDED(hr) && effects == VARIANT_TRUE){
                            DoSetCursor(); // note: we do this regardless of overlay status
                        }
                    }
                    return 0;
                }
                bHandled = FALSE;
                
                return 0;
            }
            catch(...){
                return E_UNEXPECTED;
            }
		}


#if 0
        // IOleObject::SetExtent
        STDMETHOD(SetExtent) {

        }
#endif
	STDMETHOD(InPlaceDeactivate)(void) {
		try {
			OnInPlaceDeactivate();
			return IOleInPlaceObjectWindowlessImpl<CVidCtl>::InPlaceDeactivate();
		} catch(...) {
			return E_UNEXPECTED;
		}
	}
    STDMETHOD(UIDeactivate)(void) {
		try {
			OnUIDeactivate();
			return IOleInPlaceObjectWindowlessImpl<CVidCtl>::UIDeactivate();
		} catch(...) {
			return E_UNEXPECTED;
		}
	}

    STDMETHOD(GetActivationPolicy)(DWORD* pdwPolicy) { 
		if (!pdwPolicy) {
			return E_POINTER;
		}
		try {
			*pdwPolicy = 0; 
			return NOERROR; 
		} catch(...) {
			return E_UNEXPECTED;
		}

	}
	// undone: do we need to process inactivemousemove?
	STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways)
	{
		try {
			if (fSetAlways) {
				DoSetCursor();
			} else {
				int temp;
				CheckMouseCursor(temp);
			}
			return NOERROR;
		} catch(...) {
			return E_UNEXPECTED;
		}
	}

    // IMSVidCtl
    STDMETHOD(put_ColorKey)(OLE_COLOR clr) {
        m_clrColorKey = clr;
		if (m_pVideoRenderer) {
			return m_pVideoRenderer->put_ColorKey(clr);
		}
        return NOERROR;
    }
    STDMETHOD(get_ColorKey)(OLE_COLOR* pclr) {
        try {
            if (!pclr) {
                return E_POINTER;
            }
            *pclr = m_clrColorKey;
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_DisplaySize)(DisplaySizeList dslNewSize) {
        if (dslNewSize != m_dslDisplaySize) {
            m_dslDisplaySize = dslNewSize;
            if (m_bAutoSize) {
                ComputeDisplaySize();
            }
        }
        return NOERROR;
    }
    STDMETHOD(get_DisplaySize)(DisplaySizeList* pdsl) {
        try {
            if (!pdsl) {
                return E_POINTER;
            }
            *pdsl = m_dslDisplaySize;
            return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
    }
    STDMETHOD(put_MaintainAspectRatio)(VARIANT_BOOL fNewSize) {
        m_fMaintainAspectRatio = fNewSize;
        return NOERROR;
    }
    STDMETHOD(get_MaintainAspectRatio)(VARIANT_BOOL* pf) {
        try {
            if (!pf) {
                return E_POINTER;
            }
            *pf = m_fMaintainAspectRatio;
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(Refresh)();
    STDMETHOD(get_InputsAvailable)(BSTR CategoryGuid, IMSVidInputDevices * * pVal);
    STDMETHOD(get_OutputsAvailable)(BSTR CategoryGuid, IMSVidOutputDevices * * pVal);
    STDMETHOD(get__InputsAvailable)(LPCGUID CategoryGuid, IMSVidInputDevices * * pVal);
    STDMETHOD(get__OutputsAvailable)(LPCGUID CategoryGuid, IMSVidOutputDevices * * pVal);
    STDMETHOD(get_VideoRenderersAvailable)(IMSVidVideoRendererDevices * * pVal);
    STDMETHOD(get_AudioRenderersAvailable)(IMSVidAudioRendererDevices * * pVal);
    STDMETHOD(get_FeaturesAvailable)(IMSVidFeatures * * pVal);
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
    //STDMETHOD(DoVerb)(LONG iVerb, LPMSG pMsg, IOleClientSite* pActiveSite, LONG linddex,
    //    HWND hwndParent, LPCRECT lprcPosRect);
    STDMETHOD(get_InputActive)(IMSVidInputDevice * * pVal) {
        try {
            return m_pInput.CopyTo(pVal);
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_InputActive)(IMSVidInputDevice * pVal) {
        if (pVal == NULL) {
            Decompose();
            if(m_pInput){
                PQGraphSegment(m_pInput)->put_Container(NULL);
                m_pInput.Release();
            }
        } else {
            try {
                if (m_pInput) {
                    Decompose();
                    PQGraphSegment(m_pInput)->put_Container(NULL);
                }
                m_pInput = pVal;
				m_pInputNotify = pVal;  // if input device wants keyboard/mouse stuff(currently dvd only)
                m_fGraphDirty = true;
            } catch(...) {
                return E_POINTER;
            }
        }
        return NOERROR;
    }
    STDMETHOD(get_OutputsActive)(IMSVidOutputDevices * * pVal)
    {
        try {
            return m_pOutputsInUse.CopyTo(pVal);
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(put_OutputsActive)(IMSVidOutputDevices * pVal)
    {
        if (pVal == NULL) {
            Decompose();
            m_pOutputsInUse.Release();
        } else {
            try {
                if (m_pOutputsInUse) {
                    Decompose();
                }
                m_pOutputsInUse = pVal;
                m_fGraphDirty = true;
            } catch(...) {
                return E_POINTER;
            }
        }
        return NOERROR;
    }
    STDMETHOD(get_VideoRendererActive)(IMSVidVideoRenderer * * pVal)
    {
        try {
            PQVideoRenderer vr(m_pVideoRenderer);
            *pVal = vr.Detach();
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_VideoRendererActive)(IMSVidVideoRenderer * pVal)
    {
        try {
            if (pVal == NULL) {
                m_videoSetNull = true;
                Decompose();
                m_pVideoRenderer.Release();
            } else {
                if (m_pVideoRenderer) {
                    Decompose();
                }
                m_pVideoRenderer = pVal;
            }
            m_fGraphDirty = true;
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(get_AudioRendererActive)(IMSVidAudioRenderer * * pVal)
    {
        try {
            return m_pAudioRenderer.CopyTo(pVal);
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(put_AudioRendererActive)(IMSVidAudioRenderer * pVal)
    {
        try {
            if (pVal == NULL) {
                m_audioSetNull = true;
                Decompose();
                m_pAudioRenderer.Release();
            } else {
                if (m_pAudioRenderer) {
                    Decompose();
                }
                m_pAudioRenderer = pVal;
            }
            m_fGraphDirty = true;
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(get_FeaturesActive)(IMSVidFeatures * * pVal)
    {
        try {
            return m_pFeaturesInUse.CopyTo(pVal);
        } catch(...) {
            return E_POINTER;
        }
                return NOERROR;
        }
    STDMETHOD(put_FeaturesActive)(IMSVidFeatures * pVal){
        VIDPERF_FUNC;
        try {
            // Release the old list of active features
            if (m_pFeaturesInUse) {
                Decompose();
            }
            for (VWFeatures::iterator i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
                if ((*i).punkVal) {
                    PQGraphSegment((*i).punkVal)->put_Container(NULL);
                }
            }
    	    m_pFeaturesInUse = pVal;
            m_fGraphDirty = true;
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }

    STDMETHOD(View)(VARIANT* pItem) {
        VIDPERF_FUNC;
        try {
            return SelectView(pItem, false);
		} catch(ComException &e) {
			return e;
		} catch(...) {
			return E_UNEXPECTED;
		}
    }

    STDMETHOD(ViewNext)(VARIANT* pItem) {
        VIDPERF_FUNC;
        try {
            return SelectView(pItem, true);
		} catch(ComException &e) {
			return e;
		} catch(...) {
			return E_UNEXPECTED;
		}
    }

    STDMETHOD(Build)(void) {
        VIDPERF_FUNC;
        try {
            return BuildGraph();
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
        STDMETHOD(Pause)(void);
    STDMETHOD(Run)(void) {
        VIDPERF_FUNC;
        try {
            return RunGraph();
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(Stop)(void);
    STDMETHOD(Decompose)() {
        VIDPERF_FUNC;
        try {
            return DecomposeAll();
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
// ISegmentContainer
    STDMETHOD(get_Graph)(IGraphBuilder **ppGraph) {
        try {
            return m_pGraph.CopyTo(ppGraph);
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_Input)(IMSVidGraphSegment **ppInput) {
        try {
            return PQGraphSegment(m_pInput).CopyTo(ppInput);
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_Outputs)(IEnumMSVidGraphSegment **ppOutputs) {
                PQEnumSegment temp;
                try {
                        temp = new CSegEnum(static_cast<COutputDevices *>(m_pOutputs.p)->m_Devices);
                } catch(...) {
                        return E_OUTOFMEMORY;
                }
                try {
                        *ppOutputs = temp.Detach();
                } catch(...) {
                        return E_POINTER;
                }
                return NOERROR;
    }
    STDMETHOD(get_VideoRenderer)(IMSVidGraphSegment **ppVR) {
        try {
            return PQGraphSegment(m_pVideoRenderer).CopyTo(ppVR);
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_AudioRenderer)(IMSVidGraphSegment **ppAR) {
        try {
            return PQGraphSegment(m_pAudioRenderer).CopyTo(ppAR);
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_Features)(IEnumMSVidGraphSegment **ppFeatures) {
                PQEnumSegment temp;
                try {
                        temp = new CSegEnum(static_cast<CFeatures *>(m_pFeatures.p)->m_Devices);
                } catch(...) {
                        return E_OUTOFMEMORY;
                }
                try {
                        *ppFeatures = temp.Detach();
                } catch(...) {
                        return E_POINTER;
                }
                return NOERROR;
    }
    STDMETHOD(get_Composites)(IEnumMSVidGraphSegment **ppComposites) {
                PQEnumSegment temp;
                try {
                        temp = new CSegEnum(m_pComposites);
                } catch(...) {
                        return E_OUTOFMEMORY;
                }
                try {
                        *ppComposites = temp.Detach();
                } catch(...) {
                        return E_POINTER;
                }
                return NOERROR;
    }
    STDMETHOD(get_ParentContainer)(IUnknown **ppUnk) {
        try {
			if (ppUnk) {
				return E_POINTER;
			}
			if (!m_spClientSite) {
				return E_NOINTERFACE;
			}
			m_spClientSite.CopyTo(ppUnk);
            return NOERROR;
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(Decompose)(IMSVidGraphSegment *pSegment) {
        try {
            return DecomposeSegment(VWGraphSegment(pSegment));
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(DisableVideo)() {
        return put_VideoRendererActive(NULL);
    }
    STDMETHOD(DisableAudio)() {
        return put_AudioRendererActive(NULL);
    }
    STDMETHOD(IsWindowless)() {
        return m_bWndLess ? NOERROR : S_FALSE;
    }
    STDMETHOD(GetFocus)() {
		try {
			if (!SetControlFocus(TRUE)) {
				return E_FAIL;
			}
			return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(QueryService)(REFIID service, REFIID iface, LPVOID* ppv);
	STDMETHOD(put_ServiceProvider)(/*[in]*/ IUnknown * pServiceP);

};

#endif //__VidCtl_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\vidprot.h ===
// VidProt.h : pluggable protocol for tv:

#pragma once

#ifndef VIDPROT_H
#define VIDPROT_H

#include "factoryhelp.h"

// protocol for TV

/////////////////////////////////////////////////////////////////////////////
// CTVProt
class ATL_NO_VTABLE __declspec(uuid("CBD30858-AF45-11d2-B6D6-00C04FBBDE6E")) CTVProt :
	public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTVProt, &__uuidof(CTVProt)>,
	public IInternetProtocol {
public:

CTVProt()
{
}

~CTVProt()
{
}

REGISTER_PROTOCOL(IDS_PROJNAME, 
				  IDS_REG_TVPROTOCOL_DESC,
				  LIBID_MSVidCtlLib,
				  __uuidof(CTVProt),
				  TVPROT_SCHEME_NAME);

DECLARE_PROTECT_FINAL_CONSTRUCT()
BEGIN_COM_MAP(CTVProt)
    COM_INTERFACE_ENTRY(IInternetProtocol)
    COM_INTERFACE_ENTRY(IInternetProtocolRoot)
END_COM_MAP()

private:
    CComPtr<IInternetProtocolSink> m_pSink;

public:
    HRESULT GetVidCtl(PQVidCtl &pCtl);
    HRESULT GetCachedVidCtl(PQVidCtl &pCtl, PQWebBrowser2& pW2);

/////////////////////////////////////////////////////////////////////////////
// CTVProt -- IInternetProtocol

STDMETHODIMP Read(LPVOID pv, ULONG cb, ULONG* pcbRead)
{
    TRACELM(TRACE_DEBUG, "CTVProt::Read()");
    *pcbRead = 0;
	return S_FALSE;
}

STDMETHODIMP Seek(LARGE_INTEGER /* dlibMove */, 
			    DWORD /* dwOrigin */, 
			    ULARGE_INTEGER* /* plibNewPosition*/)
{
    TRACELM(TRACE_DEBUG, "CTVProt::Seek()");
    return E_FAIL;
}

STDMETHODIMP LockRequest(DWORD /* dwOptions */)
{
    TRACELM(TRACE_DEBUG, "CTVProt::LockRequest()");
    return S_OK;
}

STDMETHODIMP UnlockRequest()
{
    TRACELM(TRACE_DEBUG, "CTVProt::UnlockRequest()");
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTVProt -- IInternetProtocolRoot
STDMETHOD(Start)(LPCWSTR szUrl,
				IInternetProtocolSink* pOIProtSink,
				IInternetBindInfo* pOIBindInfo,
				DWORD grfPI,
				HANDLE_PTR /* dwReserved */);

STDMETHODIMP Continue(PROTOCOLDATA* /* pProtocolData */)
{
    TRACELM(TRACE_DEBUG, "CTVProt::Continue()");
    return S_OK;
}

STDMETHODIMP Abort(HRESULT /* hrReason */, DWORD /* dwOptions */)
{
    TRACELM(TRACE_DEBUG, "CTVProt::Abort()");

    if (m_pSink)
    {
        m_pSink->ReportResult(E_ABORT, 0, 0);
    }

    return S_OK;
}

STDMETHODIMP Terminate(DWORD dwf/* dwOptions */)
{
    TRACELSM(TRACE_DEBUG, (dbgDump << "CTVProt::Terminate() " << hexdump(dwf)), "");
    return S_OK;
}

STDMETHODIMP Suspend()
{
    TRACELM(TRACE_DEBUG, "CTVProt::Suspend()");
    return E_NOTIMPL;
}

STDMETHODIMP Resume()
{
    TRACELM(TRACE_DEBUG, "CTVProt::Resume()");
    return E_NOTIMPL;
}
};

////////////////////////////////////////////////////////////////////////////////
//
//  protocol for DVD
//
/////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CDVDProt


class ATL_NO_VTABLE __declspec(uuid("12D51199-0DB5-46fe-A120-47A3D7D937CC")) CDVDProt :
	public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDVDProt, &__uuidof(CDVDProt)>,
	public IInternetProtocol {
public:

CDVDProt()
{
}

~CDVDProt()
{
}

REGISTER_PROTOCOL(IDS_PROJNAME, 
				  IDS_REG_DVDPROTOCOL_DESC,
				  LIBID_MSVidCtlLib,
				  __uuidof(CDVDProt),
				  DVDPROT_SCHEME_NAME);

DECLARE_PROTECT_FINAL_CONSTRUCT()
BEGIN_COM_MAP(CDVDProt)
    COM_INTERFACE_ENTRY(IInternetProtocol)
    COM_INTERFACE_ENTRY(IInternetProtocolRoot)
END_COM_MAP()

private:
    CComPtr<IInternetProtocolSink> m_pSink;

public:


/////////////////////////////////////////////////////////////////////////////
// CDVDProt -- IInternetProtocol

STDMETHODIMP Read(LPVOID pv, ULONG cb, ULONG* pcbRead)
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Read()");
    *pcbRead = 0;
	return S_FALSE;
}

STDMETHODIMP Seek(LARGE_INTEGER /* dlibMove */, 
			    DWORD /* dwOrigin */, 
			    ULARGE_INTEGER* /* plibNewPosition*/)
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Seek()");
    return E_FAIL;
}

STDMETHODIMP LockRequest(DWORD /* dwOptions */)
{
    TRACELM(TRACE_DEBUG, "CDVDProt::LockRequest()");
    return S_OK;
}

STDMETHODIMP UnlockRequest()
{
    TRACELM(TRACE_DEBUG, "CDVDProt::UnlockRequest()");
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDVDProt -- IInternetProtocolRoot
STDMETHOD(Start)(LPCWSTR szUrl,
				IInternetProtocolSink* pOIProtSink,
				IInternetBindInfo* pOIBindInfo,
				DWORD grfPI,
				HANDLE_PTR /* dwReserved */);

STDMETHODIMP Continue(PROTOCOLDATA* /* pProtocolData */)
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Continue()");
    return S_OK;
}

STDMETHODIMP Abort(HRESULT /* hrReason */, DWORD /* dwOptions */)
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Abort()");

    if (m_pSink)
    {
        m_pSink->ReportResult(E_ABORT, 0, 0);
    }

    return S_OK;
}

STDMETHODIMP Terminate(DWORD dwf/* dwOptions */)
{
    TRACELSM(TRACE_DEBUG, (dbgDump << "CDVDProt::Terminate() " << hexdump(dwf)), "");
    return S_OK;
}

STDMETHODIMP Suspend()
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Suspend()");
    return E_NOTIMPL;
}

STDMETHODIMP Resume()
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Resume()");
    return E_NOTIMPL;
}
};


#endif //__VIDPROT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\tuningspacecontainer.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// TuningSpaceContainer.cpp : Implementation of CSystemTuningSpaces
// Copyright (c) Microsoft Corporation 1999-2000.

#include "stdafx.h"

#include "TuningSpaceContainer.h"
#include "rgsbag.h"
#include "ATSCTS.h"
#include "AnalogTVTS.h"
#include "AuxiliaryInTs.h"
#include "AnalogRadioTS.h"
#include "dvbts.h"
#include "dvbsts.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_SystemTuningSpaces, CSystemTuningSpaces)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ATSCTuningSpace, CATSCTS)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_AnalogTVTuningSpace, CAnalogTVTS)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_AuxInTuningSpace, CAuxInTS)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_AnalogRadioTuningSpace, CAnalogRadioTS)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_DVBTuningSpace, CDVBTS)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_DVBSTuningSpace, CDVBSTS)

#define MAX_COUNT_NAME OLESTR("Max Count")
namespace BDATuningModel {

typedef CComQIPtr<ITuningSpaceContainer> PQTuningSpaceContainer;

class CAutoMutex {
public:
    const static int MAX_MUTEX_WAIT = 5000;
	CAutoMutex(HANDLE hMutex) throw(ComException) : m_hMutex(hMutex) {
        if (WaitForSingleObject(m_hMutex, MAX_MUTEX_WAIT) != WAIT_OBJECT_0)
            THROWCOM(E_FAIL);
    }

    ~CAutoMutex() throw(ComException) {
        if (!ReleaseMutex(m_hMutex))
            THROWCOM(E_FAIL);
    }

private:
    HANDLE m_hMutex;
};

// to avoid deadlock, always grab the objects critsec via ATL_LOCK before
// grabbing the registry section mutex.

/////////////////////////////////////////////////////////////////////////////
// CSystemTuningSpaces

HRESULT
CSystemTuningSpaces::FinalConstruct(void)
{
    // set up to serialize access to this point in the registry
    CString cs;
    cs.LoadString(IDS_MUTNAME);
    m_hMutex = CreateMutex(NULL, FALSE, cs);
    if (!m_hMutex)
    {
        return Error(IDS_E_NOMUTEX, __uuidof(ITuningSpaceContainer), HRESULT_FROM_WIN32(GetLastError()));
    }
    try {
        // wait for exclusive access
        CAutoMutex mutex(m_hMutex);

            // this must only be done once
        _ASSERT(!m_pFactory);

        // get the property bag class factory
        HRESULT hr = m_pFactory.CoCreateInstance(__uuidof(CreatePropBagOnRegKey));
        if (FAILED(hr))
        {
            return Error(IDS_E_NOPROPBAGFACTORY, __uuidof(ITuningSpaceContainer), hr);
        }

        hr = OpenRootKeyAndBag(KEY_READ);
        if (FAILED(hr)) {
            return Error(IDS_E_NOREGACCESS, __uuidof(ITuningSpaceContainer), hr);
        }

	    PQPropertyBag pb(m_pTSBag);
	    if (!pb) {
		    return E_UNEXPECTED;
	    }

        // discover the maximum possible number of tuning spaces that currently exist
        ULONG cTSPropCount;
        hr = m_pTSBag->CountProperties(&cTSPropCount);
        if (FAILED(hr))
        {
            return Error(IDS_E_CANNOTQUERYKEY, __uuidof(ITuningSpaceContainer), hr);
        }

        // allocate space to hold the tuning space object information entries
        PROPBAG2 *rgPROPBAG2 = new PROPBAG2[cTSPropCount];
        if (!rgPROPBAG2)
        {
            return Error(IDS_E_OUTOFMEMORY, __uuidof(ITuningSpaceContainer), E_OUTOFMEMORY);
        }

        ULONG cpb2Lim;

        // get all the property info structs at once
        hr = m_pTSBag->GetPropertyInfo(0, cTSPropCount, rgPROPBAG2, &cpb2Lim);
        if (FAILED(hr))
        {
            return Error(IDS_E_CANNOTQUERYKEY, __uuidof(ITuningSpaceContainer), hr);
        }
        _ASSERT(cTSPropCount == cpb2Lim);

	    HRESULT hrc = NOERROR;
        // go through the list of properties
        for (ULONG ipb2 = 0; ipb2 < cpb2Lim; ++ipb2)
        {
            // only deal with ones that represent sub-objects (keys)
            if (rgPROPBAG2[ipb2].vt == VT_UNKNOWN)
            {
                USES_CONVERSION;
                LPTSTR pstrName = OLE2T(rgPROPBAG2[ipb2].pstrName);
                TCHAR* pchStop;

                // check for a valid tuning space identifier
                ULONG idx = _tcstoul(pstrName, &pchStop, 10);
                if (idx != 0 && idx != ULONG_MAX && *pchStop == 0)
                {
                    CComVariant var;

                    // read the property from the bag (instantiating the tuning space object)
                    HRESULT hr2;
                    hr = m_pTSBag->Read(1, &rgPROPBAG2[ipb2], NULL, &var, &hr2);
				    if (FAILED(hr)) {
					    // even if the read fails, we should keep going.  
					    // a) this is the easiest way to prevent memory leaks from rgPROPBAG2
					    // b) a bad 3rd party uninstall could leave us with tuning space data
					    //    but no tuning space class to instantiate for that data.  we shouldn't
					    //    allow this to prevent use of other tuning spaces.
					    hrc = hr;
				    } else {
                        _ASSERT(var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH);
					    PQTuningSpace pTS(((var.vt == VT_UNKNOWN) ? var.punkVal : var.pdispVal));
					    CComBSTR UniqueName(GetUniqueName(pTS));
					    if (!UniqueName.Length()) {
						    // return Error(IDS_E_NOUNIQUENAME, __uuidof(ITuningSpace), E_UNEXPECTED);
                            // seanmcd 01/04/04  don't allow a corrupt tuning space to prevent
                            // use of the rest of them.  treat this as a read failure as per the above
                            // comment
                            // but remove it from the collection otherwise we've got a name/idx
                            // cache inconsistency problem
                            hrc = hr = E_UNEXPECTED; // indicate error to delete corrupt TS below
                        } else {
					        m_mapTuningSpaces[idx] = var;
					        m_mapTuningSpaceNames[UniqueName] = idx;
                        }
    #if 0
                        // the following code has been tested and works, but i don't want to
                        // turn it on because stress testing can cause false registry
                        // read failures that resolve themselves later when the system isn't under
                        // stress and i don't want to risk deleting a good tuning space just
                        // because of a bogus read error.
                        if (FAILED(hr)) {
                            // delete the corrupt TS
                            CComVariant var2;
                            var2.vt = VT_UNKNOWN;
                            var2.punkVal = NULL;
                            // can't do anything about a failure so ignore it
                            m_pTSBag->Write(1, &rgPROPBAG2[ipb2], &var2);
                        }
    #endif
				    }
                }
            }

            // free space allocated within rgPROPBAG2 by GetPropertyInfo
            CoTaskMemFree(rgPROPBAG2[ipb2].pstrName);
        }
        delete [] rgPROPBAG2;
	    _ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());

	    CComVariant v;
	    v.vt = VT_UI4;
	    hr = pb->Read(MAX_COUNT_NAME, &v, NULL);
	    if (SUCCEEDED(hr)) {
		    if (v.vt != VT_UI4) {
			    hr = ::VariantChangeType(&v, &v, 0, VT_UI4);
			    if (FAILED(hr)) {
				    return E_UNEXPECTED;
			    }
		    }
		    m_MaxCount = max(v.lVal, m_mapTuningSpaces.size());
		    if (m_MaxCount != v.lVal) {
			    //someone has added stuff to the registry by hand, by defn this is secure
			    // so just update max_count to be consistent
			    hr = put_MaxCount(m_MaxCount);
			    if (FAILED(hr)) {
				    return E_UNEXPECTED;
			    }
		    }
	    } else {
		    m_MaxCount = max(DEFAULT_MAX_COUNT, m_mapTuningSpaces.size());
	    }

    #if 0
        // we'd like to return some indicator that not all of the tuning spaces we're successfully
        // read.  but ATL's base CreateInstance method has a check that deletes the object if
        // the return code != S_OK which S_FALSE triggers.  this results in a successful return code 
        // with a NULL object pointer being returned which crashes clients(specifically the network
        // provider).
	    if (FAILED(hrc)) {
		    return Error(IDS_S_INCOMPLETE_LOAD, __uuidof(ITuningSpace), S_FALSE);
	    }
    #endif

        return NOERROR;
    } CATCHCOM();
}

void CSystemTuningSpaces::FinalRelease()
{
	_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
    if (m_hMutex)
        CloseHandle(m_hMutex);
}

STDMETHODIMP CSystemTuningSpaces::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITuningSpaceContainer
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////
HRESULT CSystemTuningSpaces::OpenRootKeyAndBag(REGSAM DesiredAccess) {
    CString cs;
    cs.LoadString(IDS_TSREGKEY);
    // make sure our entry exists
    LONG lRes = m_RootKey.Create(HKEY_LOCAL_MACHINE, cs, NULL, REG_OPTION_NON_VOLATILE, DesiredAccess);
    if (lRes != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(lRes);
    }
    m_CurrentAccess = DesiredAccess;
    // create a property bag for this portion of the registry
    HRESULT hr = m_pFactory->Create
        ( m_RootKey, 0,
          0,
          m_CurrentAccess,
          __uuidof(IPropertyBag2),
          reinterpret_cast<void **>(&m_pTSBag)
        );
    if (FAILED(hr))
    {
        return Error(IDS_E_CANNOTCREATEPROPBAG, __uuidof(ITuningSpaceContainer), hr);
    }
    return NOERROR;
}

HRESULT CSystemTuningSpaces::ChangeAccess(REGSAM NewAccess) {
    if (m_CurrentAccess == NewAccess) {
        return NOERROR;
    }
    m_RootKey.Close();
    m_pTSBag.Release();
    HRESULT hr = OpenRootKeyAndBag(NewAccess);
    if (FAILED(hr)) {
        return Error(IDS_E_NOREGACCESS, __uuidof(ITuningSpaceContainer), hr);
    }
    return NOERROR;
}

CComBSTR CSystemTuningSpaces::GetUniqueName(ITuningSpace* pTS) {
// don't assert map size equality here.  this function is used to create the name map and will
// always fail during finalconstrcut()
//	_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
    CComBSTR un;
    HRESULT hr = pTS->get_UniqueName(&un);
    if (FAILED(hr)) {
		THROWCOM(hr);
	}
    return un;
}

ULONG CSystemTuningSpaces::GetID(CComBSTR& un) {
	_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
    TuningSpaceNames_t::iterator i = m_mapTuningSpaceNames.find(un);
    if (i == m_mapTuningSpaceNames.end()) {
        return 0;
    }
    return (*i).second;
}

HRESULT CSystemTuningSpaces::DeleteID(ULONG id) {
	_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
    HRESULT hr = ChangeAccess(KEY_READ | KEY_WRITE);
    if (FAILED(hr)) {
        return hr;
    }
    OLECHAR idstr[66];
    _ltow(id, idstr, 10);
    VARIANT v;
    v.vt = VT_EMPTY;
    PQPropertyBag p(m_pTSBag);
    if (!p) {
        return Error(IDS_E_NOREGACCESS, __uuidof(IPropertyBag), E_UNEXPECTED);
    }
	USES_CONVERSION;
    hr = p->Write(idstr, &v);
    if (FAILED(hr)) {
        return Error(IDS_E_NOREGACCESS, __uuidof(ITuningSpaceContainer), E_UNEXPECTED);
    }
    return NOERROR;
}

HRESULT CSystemTuningSpaces::Add(CComBSTR& UniqueName, long PreferredID, PQTuningSpace pTS, VARIANT *pvarIndex) {
    try {
        CAutoMutex mutex(m_hMutex);
	    _ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
	    int newcount = m_mapTuningSpaces.size() + 1;
        if (!PreferredID || m_mapTuningSpaces.find(PreferredID) == m_mapTuningSpaces.end()) {
            // verify no unique name conflict
            TuningSpaceNames_t::iterator in;
            in = m_mapTuningSpaceNames.find(UniqueName);
            if (in != m_mapTuningSpaceNames.end()) {
                return Error(IDS_E_DUPLICATETS, __uuidof(ITuningSpace), HRESULT_FROM_WIN32(ERROR_DUP_NAME));
            }

            // hunt for first available unused id
            // start with 1, id 0 is invalid for a tuning space
            for (PreferredID = 1;
                 m_mapTuningSpaces.find(PreferredID) != m_mapTuningSpaces.end(); 
                 ++PreferredID) {

            }
        } else {
		    // this is the case for complete replacement via idx.
            // delete existing data for this id in preparation for overwriting it.
		    // they may also be changing the unique name at this point.
            HRESULT hr = DeleteID(PreferredID);
            if (FAILED(hr)){
                return hr;
            }
		    newcount--;
        }
	    if (newcount > m_MaxCount) {
		    return Error(IDS_E_MAXCOUNTEXCEEDED, __uuidof(ITuningSpaceContainer), STG_E_MEDIUMFULL);
	    }

        HRESULT hr = ChangeAccess(KEY_READ | KEY_WRITE);
        if (FAILED(hr)) {
            return hr;
        }

        OLECHAR idstr[66];
        _ltow(PreferredID, idstr, 10);

        PQPropertyBag p(m_pTSBag);
        if (!p) {
            return Error(IDS_E_NOREGACCESS, __uuidof(IPropertyBag), E_UNEXPECTED);
        }
	    USES_CONVERSION;
        VARIANT v;
        v.vt = VT_UNKNOWN;
        v.punkVal = pTS;
        hr = p->Write(idstr, &v);
	    if (FAILED(hr)) {
            return Error(IDS_E_NOREGACCESS, __uuidof(ITuningSpaceContainer), hr);
	    }

        PQTuningSpace newTS;
        hr = pTS->Clone(&newTS);
        if (FAILED(hr)) {
            return hr;
        }
        m_mapTuningSpaces[PreferredID] = newTS;
        m_mapTuningSpaceNames[UniqueName] = PreferredID;
        if (pvarIndex) {
            VARTYPE savevt = pvarIndex->vt;
            VariantClear(pvarIndex);
            switch(savevt) {
            case VT_BSTR:
                pvarIndex->vt = VT_BSTR;
                return newTS->get_UniqueName(&pvarIndex->bstrVal);
            default:
                pvarIndex->vt = VT_I4;
                pvarIndex->ulVal = PreferredID;
                return NOERROR;
            }
        }
        return NOERROR;
    } CATCHCOM();
}


HRESULT CSystemTuningSpaces::Find(TuningSpaceContainer_t::iterator &its, CComBSTR& UniqueName, TuningSpaceNames_t::iterator &itn) {
	ATL_LOCK();
	_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
    if (its == m_mapTuningSpaces.end()) {
        return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpace), E_FAIL);
    }
    _ASSERT(((*its).second.vt == VT_UNKNOWN) || ((*its).second.vt == VT_DISPATCH));
    PQTuningSpace pTS((*its).second.punkVal);
    if (!pTS) {
        return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaceContainer), E_UNEXPECTED);
    }
    UniqueName = GetUniqueName(pTS);
    if (!UniqueName.Length()) {
        return Error(IDS_E_NOUNIQUENAME, __uuidof(ITuningSpace), E_UNEXPECTED);
    }
    itn = m_mapTuningSpaceNames.find(UniqueName);
    _ASSERT(itn != m_mapTuningSpaceNames.end());  // cache inconsistency, in container but not in names
    return NOERROR;
}

HRESULT CSystemTuningSpaces::Find(VARIANT varIndex, long& ID, TuningSpaceContainer_t::iterator &its, CComBSTR& UniqueName, TuningSpaceNames_t::iterator &itn) {
	ATL_LOCK();
	_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
    HRESULT hr = S_OK;
    VARIANT varTmp;
    its = m_mapTuningSpaces.end();
    itn = m_mapTuningSpaceNames.end();
    PQTuningSpace pTuningSpace;

    VariantInit(&varTmp);

    // Try finding a tuning space by local system ID
    hr = VariantChangeType(&varTmp, &varIndex, 0, VT_I4);
    if (!FAILED(hr))
    {
        _ASSERT(varTmp.vt == VT_I4);
        ID = V_I4(&varTmp);
        its = m_mapTuningSpaces.find(ID);
    } else {

        // Try finding a tuning space by name
        hr = VariantChangeType(&varTmp, &varIndex, 0, VT_BSTR);
        if (FAILED(hr))
        {
            // we can only get here if both VariantChangeType calls failed
            return Error(IDS_E_TYPEMISMATCH, __uuidof(ITuningSpaceContainer), DISP_E_TYPEMISMATCH);
        }
        _ASSERT(varTmp.vt == VT_BSTR);
        UniqueName = V_BSTR(&varTmp);

        itn = m_mapTuningSpaceNames.find(UniqueName);
        if (itn != m_mapTuningSpaceNames.end()) {
            ID = (*itn).second;
            its = m_mapTuningSpaces.find(ID);
        }
    }

    if (its == m_mapTuningSpaces.end()) {
        return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaceContainer), E_FAIL);
    }
    _ASSERT(((*its).second.vt == VT_UNKNOWN) || ((*its).second.vt == VT_DISPATCH));
    return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////////////
// ITuningSpaceContainer
//////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSystemTuningSpaces::get_Item(/*[in]*/ VARIANT varIndex, /*[out, retval]*/ ITuningSpace **ppTuningSpace) {
	if (!ppTuningSpace) {
		return E_POINTER;
	}
	try {
	    ATL_LOCK();
		TuningSpaceContainer_t::iterator its = m_mapTuningSpaces.end();
		TuningSpaceNames_t::iterator itn = m_mapTuningSpaceNames.end();
		long id;
		CComBSTR un;
		HRESULT hr = Find(varIndex, id, its, un, itn);
		if (FAILED(hr) || its == m_mapTuningSpaces.end()) {
			return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaceContainer), E_INVALIDARG);
		}
		_ASSERT(((*its).second.vt == VT_UNKNOWN) || ((*its).second.vt == VT_DISPATCH));
		PQTuningSpace pTS((*its).second.punkVal);
		if (!pTS) {
			return Error(IDS_E_NOINTERFACE, __uuidof(ITuningSpace), E_NOINTERFACE);
		}
		PQTuningSpace pTSNew;
		hr = pTS->Clone(&pTSNew);
		if (FAILED(hr)) {
			return hr;
		}
		*ppTuningSpace = pTSNew.Detach();
        return NOERROR;
	} catch(...) {
		return E_UNEXPECTED;
	}
}

STDMETHODIMP CSystemTuningSpaces::put_Item(VARIANT varIndex, ITuningSpace *pTS)
{
	if (!pTS) {
		return E_POINTER;
	}
    try {
        // wait for exclusive access
        CAutoMutex mutex(m_hMutex);
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());

        HRESULT hr = ChangeAccess(KEY_READ | KEY_WRITE);
        if (FAILED(hr)) {
            return hr;
        }
        long id;
        CComBSTR idxun;
        TuningSpaceContainer_t::iterator its;
        TuningSpaceNames_t::iterator itn;
        hr = Find(varIndex, id, its, idxun, itn);
        if (FAILED(hr) || its == m_mapTuningSpaces.end()) {
            return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaceContainer), E_INVALIDARG);
        }
        _ASSERT(((*its).second.vt == VT_UNKNOWN) || ((*its).second.vt == VT_DISPATCH));
        CComBSTR un2(GetUniqueName(pTS));
        if (!un2.Length()) {
            // no uniquename prop set in ts
            return Error(IDS_E_NOUNIQUENAME, __uuidof(ITuningSpace), E_UNEXPECTED);
        }
        if (itn != m_mapTuningSpaceNames.end() && idxun != un2) {
            // unique name prop in ts doesn't match string specified in varindex
            return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpace), E_INVALIDARG);
        }
        return Add(un2, id, pTS, NULL);
    } CATCHCOM();
}

STDMETHODIMP CSystemTuningSpaces::Add(ITuningSpace *pTuningSpace, VARIANT *pvarIndex)
{
    try {
        // wait for exclusive access
        CAutoMutex mutex(m_hMutex);
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
        HRESULT hr = ChangeAccess(KEY_READ | KEY_WRITE);
        if (FAILED(hr)) {
            return Error(IDS_E_NOREGACCESS, __uuidof(ITuningSpaceContainer), hr);
        }

        if (!pTuningSpace) {
            return E_POINTER;
        }
        VARIANT vartmp;
        vartmp.vt = VT_I4;
        vartmp.ulVal = 0;
        if (pvarIndex && pvarIndex->vt != VT_I4) {
            hr = VariantChangeType(&vartmp, pvarIndex, 0, VT_I4);
            if (FAILED(hr)) {
                vartmp.vt = VT_I4;
                vartmp.ulVal = 0;
            }
        }
        CComBSTR un(GetUniqueName(pTuningSpace));
        if (!un.Length()) {
            return Error(IDS_E_NOUNIQUENAME, __uuidof(ITuningSpace), E_FAIL);
        }
        return Add(un, vartmp.ulVal, pTuningSpace, pvarIndex);
    } CATCHCOM();
}

STDMETHODIMP CSystemTuningSpaces::Remove(VARIANT varIndex)
{
    try {
        // wait for exclusive access
        CAutoMutex mutex(m_hMutex);
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());

        HRESULT hr = ChangeAccess(KEY_READ | KEY_WRITE);
        if (FAILED(hr)) {
            return hr;
        }

        TuningSpaceContainer_t::iterator its = m_mapTuningSpaces.end();
        TuningSpaceNames_t::iterator itn = m_mapTuningSpaceNames.end();

        long id;
        CComBSTR un;
        hr = Find(varIndex, id, its, un, itn);
        if (FAILED(hr)) {
            return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaceContainer), E_INVALIDARG);
        }
        if (itn == m_mapTuningSpaceNames.end()) {
            ASSERT(its != m_mapTuningSpaces.end());  // otherwise find above should have returned failure
            hr = Find(its, un, itn);
            if (FAILED(hr) || itn == m_mapTuningSpaceNames.end()) {
                // found its but not itn, must have inconsistent cache
                return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaceContainer), E_UNEXPECTED);
            }
        }
        
        m_mapTuningSpaces.erase(its);
        m_mapTuningSpaceNames.erase(itn);

        return DeleteID(id);
    } CATCHCOM();
}


STDMETHODIMP CSystemTuningSpaces::TuningSpacesForCLSID(BSTR bstrSpace, ITuningSpaces **ppTuningSpaces)
{
    try {
        return _TuningSpacesForCLSID(GUID2(bstrSpace), ppTuningSpaces);
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CSystemTuningSpaces::_TuningSpacesForCLSID(REFCLSID clsidSpace, ITuningSpaces **ppTuningSpaces)
{
	if (!ppTuningSpaces) {
		return E_POINTER;
	}
	try {
	    ATL_LOCK();
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
		CTuningSpaces* pTSCollection = new CTuningSpaces;
		for (TuningSpaceContainer_t::iterator i = m_mapTuningSpaces.begin(); i != m_mapTuningSpaces.end(); ++i) {
			CComVariant v((*i).second);
			if (v.vt != VT_UNKNOWN && v.vt != VT_DISPATCH) {
				return E_UNEXPECTED; //corrupt in-memory collection
			}
			PQPersist pTS(v.punkVal);
			if (!pTS) {
                delete pTSCollection;
				return E_UNEXPECTED;  // corrupt in-memory collection;
			}
			GUID2 g;
			HRESULT hr = pTS->GetClassID(&g);
			if (FAILED(hr)) {
                delete pTSCollection;
				return E_UNEXPECTED;
			}
			if (g == clsidSpace) {
                PQTuningSpace newts;
                hr = PQTuningSpace(pTS)->Clone(&newts);
                if (FAILED(hr)) {
                    delete pTSCollection;
                    return hr;
                }
                pTSCollection->m_mapTuningSpaces[(*i).first] = CComVariant(newts);
			}
		}
		*ppTuningSpaces = pTSCollection;
		(*ppTuningSpaces)->AddRef();
		return NOERROR;
	} catch(...) {
		return E_UNEXPECTED;
	}

}

STDMETHODIMP CSystemTuningSpaces::TuningSpacesForName(BSTR bstrName, ITuningSpaces **ppTuningSpaces)
{
	if (!ppTuningSpaces) {
		return E_POINTER;
	}
	try {
	    ATL_LOCK();
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
		PQRegExp pRE;
		HRESULT hr;
		if (!m_cookieRegExp) {
            // at the time this code was written the only regex library that was readily available
            // was the one in the vbscript engine.  therefore we create and access this through
            // com.  however, this is an apartment model object this we have to create it
            // on a background apartment thread so we can always marshall over and access no matter
            // what thread we're on.
            // there is now a good c++ regex in the http://toolbox and at some point we should probably 
            // check it for thread safety and convert.
			m_pRET = new CRegExThread();
			if (!m_pRET) {
				return E_OUTOFMEMORY;
			}
			if (!m_pRET->Create()) {
				return E_UNEXPECTED;
			}
			hr = m_pRET->CallWorker(CRegExThread::RETHREAD_CREATEREGEX);
			if (FAILED(hr)) {
				return hr;
			}
			m_cookieRegExp = m_pRET->GetCookie();
			if (!m_cookieRegExp) {
				return E_UNEXPECTED;
			}
		} 
		if (!m_pGIT) {
			hr = m_pGIT.CoCreateInstance(CLSID_StdGlobalInterfaceTable, 0, CLSCTX_INPROC_SERVER);
			if (FAILED(hr)) {
				return hr;
			}
		}
		hr = m_pGIT->GetInterfaceFromGlobal(m_cookieRegExp, __uuidof(IRegExp), reinterpret_cast<LPVOID *>(&pRE));
		if (FAILED(hr)) {
			return hr;
		}
		hr = pRE->put_Pattern(bstrName);
		if (FAILED(hr)) {
			return hr;
		}

		CTuningSpaces* pTSCollection = new CTuningSpaces;
		for (TuningSpaceContainer_t::iterator i = m_mapTuningSpaces.begin(); i != m_mapTuningSpaces.end(); ++i) {
			if ((*i).second.vt != VT_UNKNOWN && (*i).second.vt != VT_DISPATCH) {
				return E_UNEXPECTED; //corrupt in-memory collection
			}
			PQTuningSpace pTS((*i).second.punkVal);
			CComBSTR name;
			hr = pTS->get_FriendlyName(&name);
			if (FAILED(hr)) {
				return E_UNEXPECTED;
			}
            PQTuningSpace newTS;
			VARIANT_BOOL bMatch = VARIANT_FALSE;
			hr = pRE->Test(name, &bMatch);
			if (FAILED(hr) || bMatch != VARIANT_TRUE) {
				hr = pTS->get_UniqueName(&name);
				if (FAILED(hr)) {
					return E_UNEXPECTED;
				}
				hr = pRE->Test(name, &bMatch);
				if (FAILED(hr) || bMatch != VARIANT_TRUE) {
                    continue;
                }
            }
            hr = pTS->Clone(&newTS);
            if (FAILED(hr)) {
                return hr;
            }
            pTSCollection->m_mapTuningSpaces[(*i).first] = newTS;
		}

		*ppTuningSpaces = pTSCollection;
		(*ppTuningSpaces)->AddRef();
		return NOERROR;
	} catch(...) {
		return E_UNEXPECTED;
	}
}

STDMETHODIMP CSystemTuningSpaces::get_MaxCount(LONG *plVal)
{
	if (!plVal) {
		return E_POINTER;
	}
	try {
	    ATL_LOCK();
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
		*plVal = m_MaxCount;
		return NOERROR;
	} catch(...) {
		return E_POINTER;
	}

}

STDMETHODIMP CSystemTuningSpaces::put_MaxCount(LONG lVal)
{
	try {
        if (lVal < 0) {
            return E_INVALIDARG;
        }
	    CAutoMutex mutex(m_hMutex);
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
        HRESULT hr = ChangeAccess(KEY_READ | KEY_WRITE);
        if (FAILED(hr)) {
            return hr;
        }
		ULONG count = max(lVal, m_mapTuningSpaces.size());
		CComVariant v;
		v.vt = VT_UI4;
		v.lVal = count;
		PQPropertyBag pb(m_pTSBag);
		if (!pb) {
			return E_UNEXPECTED;
		}
		hr = pb->Write(MAX_COUNT_NAME, &v);
		if (FAILED(hr)) {
			return hr;
		}
		m_MaxCount = count;
		if (m_MaxCount != lVal) {
			return S_FALSE;
		}
		return NOERROR;
    } CATCHCOM();
}

STDMETHODIMP CSystemTuningSpaces::FindID(ITuningSpace *pTS, long* pID)
{
    try {
		if (!pID || !pTS) {
			return E_POINTER;
		}
	    ATL_LOCK();
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
        CComBSTR un(GetUniqueName(pTS));
        if (!un.Length()) {
            return Error(IDS_E_NOUNIQUENAME, __uuidof(ITuningSpace), E_UNEXPECTED);
        }
        *pID = GetID(un);
        if (!(*pID)) {
            return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpace), E_INVALIDARG);
        }
        return NOERROR;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

HRESULT CSystemTuningSpaces::RegisterTuningSpaces(HINSTANCE hMod) {
	try {
		CAutoMutex mutex(m_hMutex);
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
		CString cs;
		cs.LoadString(IDS_RGSLIST_TYPE);
		HRSRC hRes = ::FindResource(hMod, MAKEINTRESOURCE(IDR_CANONICAL_TUNINGSPACE_LIST), (LPCTSTR)cs);
		if (!hRes) {
			return HRESULT_FROM_WIN32(::GetLastError());
		}
		HANDLE hData = ::LoadResource(hMod, hRes);
		if (!hData) {
			return HRESULT_FROM_WIN32(::GetLastError());
		}
		DWORD *p = reinterpret_cast<DWORD *>(::LockResource(hData));
		if (!p) {
			return HRESULT_FROM_WIN32(::GetLastError());
		}
		cs.LoadString(IDS_TUNINGSPACE_FRAGMENT_TYPE);
		for (DWORD idx = 1; idx <= p[0]; ++idx) {
			hRes = ::FindResource(hMod, MAKEINTRESOURCE(p[idx]), (LPCTSTR)cs);
			if (!hRes) {
				return HRESULT_FROM_WIN32(::GetLastError());
			}
			LPCSTR psz = reinterpret_cast<LPCSTR>(::LoadResource(hMod, hRes));
			if (!psz) {
				return HRESULT_FROM_WIN32(::GetLastError());
			}
			USES_CONVERSION;
			int cch;
			CRegObject cro;  // init %mapping% macros here if desired
			PQPropertyBag rgsBag(new CRGSBag(A2CT(psz), cro, cch));
            if (!rgsBag) {
                return E_UNEXPECTED;
            }
			CString csName;
			csName.LoadString(IDS_TSKEYNAMEVAL);
			CComVariant tsval;
			HRESULT hr = rgsBag->Read(T2COLE(csName), &tsval, NULL);
			if (FAILED(hr)) {
				return E_FAIL;  // bad script, no unique name property
			}
			if (tsval.vt != VT_UNKNOWN) {
				return DISP_E_TYPEMISMATCH;
			}
			PQTuningSpace pTS(tsval.punkVal);
			if (!pTS) {
				return DISP_E_TYPEMISMATCH;
			}
			CComVariant Varidx;
			Varidx.vt = VT_UI4;
			Varidx.ulVal = 0;
			hr = Add(pTS, &Varidx);
			// ignore existing ts w/ same unique name and move one
			if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_DUP_NAME)) {  
				return hr;
			}
		}
	    return NOERROR;
    } CATCHCOM();
}

HRESULT CSystemTuningSpaces::UnregisterTuningSpaces() {
    try {
        CAutoMutex mutex(m_hMutex);
	    _ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
	    // currently we delete all tuning spaces when we unreg
        // its possible that it would be better to just delete the canonical ones
        // that we created when we registered.  on the other hand, that reg space
        // would leak forever if tv support is really being uninstalled.  and, since
        // we're in the os we're unlikely to ever get unregistered anyway.
        HRESULT hr = OpenRootKeyAndBag(KEY_READ | KEY_WRITE);
        if (SUCCEEDED(hr)) {
            DWORD rc = m_RootKey.RecurseDeleteKey(_T(""));
            if (rc != ERROR_SUCCESS) {
                return E_FAIL;
            }
        }
        return NOERROR;
    } CATCHCOM();
}

HRESULT UnregisterTuningSpaces() {
    PQTuningSpaceContainer pst(CLSID_SystemTuningSpaces, NULL, CLSCTX_INPROC_SERVER);
    if (!pst) {
        return E_UNEXPECTED;
    }
    CSystemTuningSpaces *pc = static_cast<CSystemTuningSpaces *>(pst.p);
    return pc->UnregisterTuningSpaces();

}

HRESULT RegisterTuningSpaces(HINSTANCE hMod) {
    PQTuningSpaceContainer pst(CLSID_SystemTuningSpaces, NULL, CLSCTX_INPROC_SERVER);
    if (!pst) {
        return E_UNEXPECTED;
    }
    CSystemTuningSpaces *pc = static_cast<CSystemTuningSpaces *>(pst.p);
    return pc->RegisterTuningSpaces(hMod);
}

};
// end of file - tuningspacecontainer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\vidprot.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1998-2000.
//
//--------------------------------------------------------------------------;
//
// vidprot.cpp : Implementation of CTVProt
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include <string.h>
#include <shlwapi.h>
#include "vidprot.h"
#include "devices.h"

DEFINE_EXTERN_OBJECT_ENTRY(__uuidof(CTVProt), CTVProt)
DEFINE_EXTERN_OBJECT_ENTRY(__uuidof(CDVDProt), CDVDProt)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTVProt
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CTVProt -- IInternetProtocolRoot
STDMETHODIMP CTVProt::Start(LPCWSTR szUrl,
				IInternetProtocolSink* pOIProtSink,
				IInternetBindInfo* pOIBindInfo,
				DWORD grfPI,
				HANDLE_PTR /* dwReserved */)
{
    TRACELM(TRACE_DEBUG, "CTVProt::Start()");
    if (!pOIProtSink)
    {
        TRACELM(TRACE_DEBUG, "CTVProt::Start() IInternetProctocolSink * == NULL");
	    return E_POINTER;
    }
    m_pSink.Release();
    m_pSink = pOIProtSink;
    m_pSink->ReportData(BSCF_FIRSTDATANOTIFICATION, 0, 0);
#if 0
	// this bug is fixed in ie 5.5+ on whistler.  if you want to run on earlier versions of ie such as 2k gold then you need this.
	m_pSink->ReportProgress(BINDSTATUS_CONNECTING, NULL);  // put binding in downloading state so it doesn't ignore our IUnknown*
#endif

	if (!pOIBindInfo) {
		m_pSink->ReportResult(E_NOINTERFACE, 0, 0);
		return E_NOINTERFACE;
	}
    // don't run unless we're being invoked from a safe site
    HRESULT hr = IsSafeSite(m_pSink);
    if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
    }
	ULONG count;
	LPOLESTR pb;
	hr = pOIBindInfo->GetBindString(BINDSTRING_FLAG_BIND_TO_OBJECT, &pb, 1, &count);
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
	if (wcscmp(pb, BIND_TO_OBJ_VAL)) {
		// we must be getting a bind to storage so skip the expensive stuff and 
		// wait for the bind to object which is coming next
		m_pSink->ReportData(BSCF_LASTDATANOTIFICATION | 
							BSCF_DATAFULLYAVAILABLE, 0, 0);
		m_pSink->ReportResult(S_OK, 0, 0);
		m_pSink.Release();
		return S_OK;
	}

	// and, in one of the most bizarre maneuvers i've ever seen, rather than casting, 
	// urlmon passes back the ascii value of the ibindctx pointer in the string
	hr = pOIBindInfo->GetBindString(BINDSTRING_PTR_BIND_CONTEXT, &pb, 1, &count);
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
	_ASSERT(count == 1);	
	
	PQBindCtx pbindctx;
#define RADIX_BASE_10 (10)
#ifdef _WIN64
#if 0
	// undone: turn this back on for win64 when _wcstoxi64 get into libc.c, they're in the header
	// but not implemented so this doesn't link
	pbindctx.Attach(reinterpret_cast<IBindCtx*>(_wcstoui64(pb, NULL, RADIX_BASE_10)));	// urlmon already did an addref
#else
	swscanf(pb, L"%I64d", &pbindctx.p);
#endif
#else
	pbindctx.Attach(reinterpret_cast<IBindCtx*>(wcstol(pb, NULL, RADIX_BASE_10)));	// urlmon already did an addref
#endif

	if (!pbindctx) {
		m_pSink->ReportResult(E_NOINTERFACE, 0, 0);
		return E_NOINTERFACE;
	}	

    TRACELM(TRACE_DEBUG, "CTVProt::Start(): creating control object");
	PQVidCtl pCtl;
    hr = GetVidCtl(pCtl);
    if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
        return hr;
    }

	hr = pbindctx->RegisterObjectParam(OLESTR("IUnknown Pointer"), pCtl);
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
    TRACELSM(TRACE_DEBUG, (dbgDump << "BINDSTATUS_IUNKNOWNAVAILABLE(29), " << KEY_CLSID_VidCtl), "");
    m_pSink->ReportProgress(BINDSTATUS_IUNKNOWNAVAILABLE, NULL);
    m_pSink->ReportData(BSCF_LASTDATANOTIFICATION | 
			            BSCF_DATAFULLYAVAILABLE, 0, 0);
    m_pSink->ReportResult(S_OK, 0, 0);
    m_pSink.Release();
    return S_OK;
}

HRESULT CTVProt::GetCachedVidCtl(PQVidCtl &pCtl, PQWebBrowser2& pW2) {
	// hunt for cached object
	PQServiceProvider pSP(m_pSink);
	if (!pSP) {
        return E_UNEXPECTED;
    }
	HRESULT hr = pSP->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (LPVOID *)&pW2);
    if (FAILED(hr)) {
        return hr;
    }
	CComVariant v;
    CComBSTR propname(KEY_CLSID_VidCtl);
    if (!propname) {
        return E_UNEXPECTED;
    }
	hr = pW2->GetProperty(propname, &v);
    if (FAILED(hr)) {
        return hr;
    }
	if (v.vt == VT_UNKNOWN) {
		pCtl = v.punkVal;
	} else if (v.vt == VT_DISPATCH) {
		pCtl = v.pdispVal;
	} else {
		TRACELM(TRACE_ERROR, "CTVProt::GetCachedObject(): non-object cached w/ our key");
        pCtl.Release();
        // don't return error.  we'll ignore this and create a new one
	}
	// undone: look and see if pCtl already has a site.because
	// this means we're seeing the second tv: on this page
	// so just get the current TR/channel from it if necessary (tv: w/ no rhs)
	// and create a new ctl
	return NOERROR;
}
HRESULT CTVProt::GetVidCtl(PQVidCtl &pCtl) {
	PQWebBrowser2 pW2;
    HRESULT hr = GetCachedVidCtl(pCtl, pW2);
    if (FAILED(hr)) {
        return hr;
    }
	if (!pCtl) {
        // undone: long term, we want to move a bunch of this create/setup logic into factoryhelp
        // so we can share more code with the dvd: protocol and the behavior factory
		hr = pCtl.CoCreateInstance(CLSID_MSVidCtl, NULL, CLSCTX_INPROC_SERVER);
		if (FAILED(hr)) {
			return hr;
		}
		// cache this ctl for next time
		if (pW2) {
			VARIANT v;
			v.vt = VT_UNKNOWN;
			v.punkVal = pCtl;

            CComBSTR propname(KEY_CLSID_VidCtl);
            if (!propname) {
                return E_UNEXPECTED;
            }
			hr = pW2->PutProperty(propname, v);
			if (FAILED(hr)) {
				TRACELM(TRACE_ERROR, "CTVProt::Start() Can't cache ctl");
                // ignore this error.  it shouldn't ever happen and if it does then it will 
                // just cause a perf degradation.  trace it and move on
			}
		}

		// undone: parse rhs of url and create the right tuning request
        CComVariant pTR(CFactoryHelper::GetDefaultTR());
		if (!pTR) {
			TRACELM(TRACE_ERROR, "CTVProt::Start() Can't find default Tune Request");
			return E_INVALIDARG;
		}
		hr = pCtl->View(&pTR);
		if (FAILED(hr)) {
			TRACELM(TRACE_ERROR, "CTVProt::Start() Can't view default Tune Request");
			return hr;
		}

		// undone: once we know where vidctl will live in the registry then we need to put a flag
		// in the registry just disables including any features in the tv: prot 

		PQFeatures pF;
		hr = pCtl->get_FeaturesAvailable(&pF);
		if (FAILED(hr)) {
			TRACELM(TRACE_ERROR, "CTVProt::Start() Can't get features collection");
			return hr;
		}
		// undone: look up default feature segments for tv: in registry
		// for now we're just going to hard code the ones we want

        CFeatures* pC = static_cast<CFeatures *>(pF.p);
        CFeatures* pNewColl = new CFeatures;
        if (!pNewColl) {
            return E_OUTOFMEMORY;
        }
        for (DeviceCollection::iterator i = pC->m_Devices.begin(); i != pC->m_Devices.end(); ++i) {
            PQFeature f(*i);
            GUID2 clsid;
            hr = f->get__ClassID(&clsid);
            if (FAILED(hr)) {
    			TRACELM(TRACE_ERROR, "CTVProt::GetVidCtl() Can't get feature class id");
                continue;
            }
            if (clsid == CLSID_MSVidClosedCaptioning ||
                clsid == CLSID_MSVidDataServices) {
                pNewColl->m_Devices.push_back(*i);
            }
        }

		hr = pCtl->put_FeaturesActive(pNewColl);
		if (FAILED(hr)) {
			TRACELM(TRACE_ERROR, "CTVProt::Start() Can't put features collection");
			return hr;
		}
	}
	ASSERT(pCtl);
	hr = pCtl->Run(); 
	if (FAILED(hr)) {
		TRACELSM(TRACE_ERROR, (dbgDump << "CTVProt::Start() run failed.  hr = " << hexdump(hr)), "");
		return hr;
	}
    return NOERROR;
}


#endif // TUNING_MODEL_ONLY
// end of file vidprot.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\webdvdarcomp.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing WebDVD to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef WEBDVDCOMPAR_H
#define WEBDVDCOMPAR_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <objectwithsiteimplsec.h>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAnaCapComp
class ATL_NO_VTABLE __declspec(uuid("8D04238E-9FD1-41c6-8DE3-9E1EE309E935")) CWebDVDARComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWebDVDARComp, &__uuidof(CWebDVDARComp)>,
    public IObjectWithSiteImplSec<CWebDVDARComp>,
	public IMSVidCompositionSegmentImpl<CWebDVDARComp>
{
public:
    CWebDVDARComp() {}
    virtual ~CWebDVDARComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_WEBDVDARCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CWebDVDARComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CWebDVDARComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
    	COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()

// IMSVidComposition
public:
// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        TRACELM(TRACE_DEBUG, "CWebDVDARComp::Compose()");
        if (m_fComposed) {
            return NOERROR;
        }
        
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDARComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDARComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
            VWGraphSegment::iterator iNav = std::find_if(up.begin(),
                                                         up.end(),
                                                         arity1_pointer(&IsDVDNavigator));
            if (iNav == up.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDARComp::Compose() upstream segment has no DVD Navigator");
                return E_FAIL;
            }
            ASSERT((*iNav).GetGraph() == m_pGraph);
            
            DSFilter pNav(*iNav);
#if 1
// Code to add mpeg2 video decoder
			CComBSTR decoder(L"{7E2E0DC1-31FD-11D2-9C21-00104B3801F6}");
			CComBSTR decoderName(L"InterVideo Audio Decoder");
			GUID2 decoderGuid(decoder);
            DSFilter pfr(decoderGuid);
            if (!pfr) {
                ASSERT(false);
		        return Error(IDS_CANT_CREATE_FILTER, __uuidof(IMSVidWebDVD), E_UNEXPECTED);
            }
            HRESULT hr = m_pGraph->AddFilter(pfr, decoderName);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR,  (dbgDump << "IMSVidWebDVD::Load() hr = " << std::hex << hr), "");
                return Error(IDS_CANT_ADD_FILTER, __uuidof(IMSVidWebDVD), hr);
            }
            m_Filters.push_back(pfr);

#endif
			// video
            hr = m_pGraph.Connect(pNav, pfr, m_Filters);
            if (FAILED(hr)) {
				TRACELM(TRACE_DETAIL, "CWebDVDARComp::Compose() SUCCEEDED");
				return hr;
            }  
          
			for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++iStop){
				DSFilter pStop(*iStop);
				hr = m_pGraph.Connect(pfr, pStop, m_Filters, DSGraph::RENDER_ALL_PINS | DSGraph::IGNORE_EXISTING_CONNECTIONS | DSGraph::DO_NOT_LOAD);
				if(SUCCEEDED(hr)){
					m_fComposed = true;
					return NOERROR;
				}
			}
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // WEBDVDCOMPAR_H
// end of file - WebDVDARComp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\msvidctl\webdvdcomp.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing WebDVD to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef WEBDVDCOMP_H
#define WEBDVDCOMP_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <objectwithsiteimplsec.h>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols
#include "perfcntr.h"
/////////////////////////////////////////////////////////////////////////////
// CAnaCapComp
class ATL_NO_VTABLE __declspec(uuid("267db0b3-55e3-4902-949b-df8f5cec0191")) CWebDVDComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWebDVDComp, &__uuidof(CWebDVDComp)>,
    public IObjectWithSiteImplSec<CWebDVDComp>,
	public IMSVidCompositionSegmentImpl<CWebDVDComp>
{
public:
    CWebDVDComp() {}
    virtual ~CWebDVDComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_WEBDVDCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CWebDVDComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CWebDVDComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
    	COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()

// IMSVidComposition
public:
// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        TRACELM(TRACE_DEBUG, "CWebDVDComp::Compose()");
        if (m_fComposed) {
            return NOERROR;
        }
        
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
            VWGraphSegment::iterator iNav = std::find_if(up.begin(),
                                                         up.end(),
                                                         arity1_pointer(&IsDVDNavigator));
            if (iNav == up.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDComp::Compose() upstream segment has no DVD Navigator");
                return E_FAIL;
            }
            ASSERT((*iNav).GetGraph() == m_pGraph);
          
            VWGraphSegment::iterator iOv = std::find_if(down.begin(),
                down.end(),
                arity1_pointer(&IsVideoRenderer));
            if (iOv == down.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDComp::Compose() downstream segment has no ov mixer filter");
                return E_FAIL;
            }
            
            ASSERT((*iOv).GetGraph() == m_pGraph);
            
            DSFilter pNav(*iNav);
            DSFilter pOv(*iOv);
            
            // video
            CPerfCounter pCounterDecoder;
            pCounterDecoder.Reset();
            DSFilter::iterator iNavVideoPin = std::find_if(pNav.begin(), 
                pNav.end(),
                arity1_pointer(&IsDVDNavigatorVideoOutPin));
            if (iNavVideoPin == pNav.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDComp::Compose() no video pin on DVD Navigator");
                return E_FAIL;
            }			
            DSPin pNavVideoPin(*iNavVideoPin);
            HRESULT hr = pNavVideoPin.IntelligentConnect(pOv, m_Filters);
            if (FAILED(hr)) {
                TRACELM(TRACE_DETAIL, "CWebDVDComp::Compose() SUCCEEDED");
                return hr;
            }
            pCounterDecoder.Stop();
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl:: Compose() connect decoder video: " << (unsigned long)(pCounterDecoder.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterDecoder.GetLastTime() % _100NS_IN_MS) << " ms"), "");
            
            // subpicture
            pCounterDecoder.Reset();
            
            iNavVideoPin = std::find_if(pNav.begin(), 
                pNav.end(),
                arity1_pointer(&IsDVDNavigatorSubpictureOutPin));
            if (iNavVideoPin == pNav.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDComp::Compose() no subpicture pin on DVD Navigator");
                return E_FAIL;
            }
            pNavVideoPin = *iNavVideoPin;
            hr = pNavVideoPin.IntelligentConnect(pOv, m_Filters, DSGraph::RENDER_ALL_PINS | DSGraph::IGNORE_EXISTING_CONNECTIONS | DSGraph::DO_NOT_LOAD);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CWebDVDComp::Compose() FAILED hr = " << hexdump(hr)), "");
                return hr;
            }
            pCounterDecoder.Stop();
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl:: Compose() connect decoder subpicture: " << (unsigned long)(pCounterDecoder.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterDecoder.GetLastTime() % _100NS_IN_MS) << " ms"), "");
            
            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // WEBDVDCOMP_H
// end of file - WebDVDComp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\filename\dirscan.cs ===
/*+*******************************************************************************************
  Project				: 
  File					: dirscan.c
  Summary				: 
  Classes / Fcns		: 
  Notes / Revisions		: 
*******************************************************************************************+*/
using System;
using System.IO;
namespace filename
{
    public class  DirScan
    {
        /*---------------------------------------------------------
            Public Member Fcns
        ----------------------------------------------------------*/
        /*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++
        Method: 	public void BeginScan()
        Summary:
        Args:
        Modifies:
        Returns:
        M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
        static public void BeginScan( string StartDir, string FileFilter, string OutputFile, int MaxLen, bool Recurse, bool Append, bool WriteHeader)
        {
            StreamWriter	os = null;
            DirectoryInfo	dir, subDir;
            String			FullName;
            long			FileSize;
            DateTime		CreationDate;
            
            if ( "" !=  OutputFile )
            {
                if ( true == Append)
                {
                    os = File.AppendText(OutputFile);
                }
                else
                {
                    os = File.CreateText(OutputFile);
                }
            }

            if ( null != os && true == WriteHeader )
            {
                os.WriteLine("Filename Length Checker");
                os.WriteLine("Parameters:");
                os.WriteLine("\tStarting Directory     = {0}",StartDir);
                os.WriteLine("\tFile Filter            = {0}",FileFilter);
                if ( true == Recurse)
                {
                    os.WriteLine("\tRecurse directories    = TRUE");
                }
                else
                {
                    os.WriteLine("\tRecurse directories    = FALSE");
                }
                os.WriteLine("\tOutput File            = {0}",OutputFile);
                os.WriteLine("\tMax File Name Length   = {0}",MaxLen);
                os.WriteLine("=============================================");
                os.WriteLine("Scanning Directory -> {0}",StartDir);
                os.WriteLine("-------------------------------------------------------------");
            }
            Console.WriteLine("Scanning Directory -> {0}",StartDir);


            dir		= new DirectoryInfo(StartDir);
            foreach (FileInfo f in dir.GetFiles(FileFilter)) 
            {
                if ( MaxLen < f.Name.Length )
                {
                    Console.WriteLine("{0}", f.Name);
                    if ( null != os )
                    {
                        os.WriteLine("{0}", f.FullName);
                    }
                }
            }

            if ( true == Recurse )
            {
                foreach ( DirectoryInfo d in dir.GetDirectories("*") )
                {
                    if ( null != os )
                    {
                        os.WriteLine("Scanning Directory -> {0}",d.FullName);
                        os.WriteLine("-------------------------------------------------------------");
                        os.Flush();
                        os.Close();
                        os = null;
                    }
                    Console.WriteLine("Scanning Directory -> {0}",StartDir);
                    DirScan.BeginScan(d.FullName, FileFilter, OutputFile, MaxLen, Recurse, true, false);
                }
            }
      
            if ( null != os )
            {
                os.Flush();
                os.Close();
            }
        }// public void BeginScan
    }
} // namespace filescan
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\filename\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\filename\filenameapp.cs ===
using System;

namespace filename
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class FileNameApp
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
            ProgramOpts opts = new ProgramOpts();

            if ( false == opts.CommandLine(args) )
            {
                return;
            }
            DirScan.BeginScan(opts.startDir, opts.fileFilter, opts.outputFile, opts.maxLen, opts.recurseDirs, false, true);
            //Console.WriteLine("Press ENTER to Exit");
            //Console.ReadLine();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\filename\programopts.cs ===
/********************************************************************
 * Project  : C:\DEPOT\multimedia\eHomeTest\UserXp\filename\filename.sln
 * File     : ProgramOpts.cs
 * Summary  : Collects program arguments from command line.
 * Classes  :
 * Notes    :
 * *****************************************************************/

using System;

namespace filename
{
	/// <summary>
	/// Summary description for ProgramOpts.
	/// </summary>
	public class ProgramOpts
	{
        /*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
         * static public int CommandLine(string[] args)
         * Args     :
         * Modifies :
         * Returns  :
         * M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M*/
        public bool CommandLine(string[] args)
        {
            if (args == null)
            {
                ArgsHelp();
                return false;
            }

            // Command line -m<max len> -o"output file" -p to append
            foreach(string s in args)
            {
                // file filter
                if ( s.StartsWith("-f") && 2 < s.Length)
                {
                    _fileFilter = s.Substring(2);
                }
                else if ( s.StartsWith("-s") && 2 < s.Length)
                {
                    _startDir = s.Substring(2);
                }
                    // Max allowed length of string
                else if ( s.StartsWith("-m") && 2 < s.Length)
                {
                    _maxLen = System.Convert.ToInt32(s.Substring(2));
                }
                    // output file - if any
                else if ( s.StartsWith("-o") && 2 < s.Length)
                {
                    _outputFile = s.Substring(2);
                }
                else if ( s.StartsWith("-p" ))
                {
                    _appendToFile = true;
                }
                else if ( s.StartsWith("-r"))
                {
                    _recurseDirs = true;
                }
                else
                {
                    Console.WriteLine("Invalid parameter!!");
                    ArgsHelp();
                    return false;
                }
            } // foreach
            return true;
        } // public int ProgramArgs(string[] args)


        /*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
         * static private void ArgsHelp()
         * Args     :
         * Modifies :
         * Returns  :
         * M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M*/
        static private void ArgsHelp()
        {
            Console.WriteLine("Filename -f<file filter> -s<start dir> -m<Max Length> -o<Output file> -r[recurse dirs flag]");
            Console.WriteLine("\tIf no output file is specified, data is written to console.");
            Console.WriteLine("\tIf the -p argument is given, output will be appended to specified file.");
        }

        /*---------------------------------------------------------
            Member Variables
        ----------------------------------------------------------*/
        public string fileFilter
        {
            get { return _fileFilter; }
            set { _fileFilter = value;}
        }
        public string startDir
        {
            get { return _startDir; }
            set { _startDir = value; }
        }
        public bool recurseDirs
        {
            get { return _recurseDirs; }
            set { _recurseDirs = value; }
        }
        public int maxLen
        {
            get { return _maxLen;}
            set { _maxLen = value;}
        }
        public string outputFile
        {
            get { return _outputFile;}
            set { _outputFile  = value;}
        }
        public bool append
        {
            get { return _appendToFile; }
            set { _appendToFile = value; }
        }

        
        string  _fileFilter     = "*";
        string  _startDir       = ".\\";
        bool    _recurseDirs    = false;
        int     _maxLen         = 20;
        string  _outputFile     = "";
        bool    _appendToFile   = false;

    } // public class 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\mediamanager\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\guidemanager\guidemgr.cs ===
/********************************************************************
 * Project  : C:\DEPOT\multimedia\eHomeTest\UserXp\guidesearch\guidesearch.sln
 * File     : GuideSearch.cs
 * Summary  :
 * Classes  :
 * Notes    :
 * *****************************************************************/

using System;
using System.IO;

namespace GuideMgr
{
	class GuideMgrApp
	{
        /// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
            ProgramArgs     opts = new ProgramArgs(); 
            LenCheck        lc;
            GuideSearch     gc;
            string[,]       results;
            string[]        sortedResults;
            StreamWriter	OutputStream = null;

            // Get command line args
            if ( !opts.CommandLine(args) ) return;

            // Run LENGTH test
            if ( opts.test == "len" )
            {
                // Scan guidestore and return all titles/descriptions.
                lc = new LenCheck();
                results = lc.ReturnResults(opts.MaxTitleLen,opts.MaxDescLen);
            }

            // run SEARCH test
            else if (opts.test == "search" )
            {
                gc = new GuideSearch(opts.QueryType, opts.QueryMode, opts.SearchString);
                results = gc.ReturnResults();
            }
            else
            {
                Console.WriteLine("Test {0} not supported or not implemented.", opts.test);
                return;
            }

            // Setup output file
            if ( opts.OutputFile != "" )
            {
                if ( opts.Append == true )
                {
                    OutputStream = File.AppendText(opts.OutputFile);
                }
                else
                {
                    OutputStream = File.CreateText(opts.OutputFile);
                }
            }

            // display results
            int count = results.GetLength(0);
            sortedResults = new string[count];
            for ( int x = 0; x < count; x++ )
            {
                sortedResults[x] = results[x,0] + "\r\n" + results[x,2] + results[x,1] + "\r\n\r\n";
            }
            Array.Sort(sortedResults);

            if (OutputStream != null)
            {
                OutputStream.WriteLine("Test Parameters");
                OutputStream.WriteLine("Test Mode = {0}", opts.test);
                OutputStream.WriteLine("Max Title Len = {0}, Max Desc Len = {1}", opts.MaxTitleLen, opts.MaxDescLen);
                OutputStream.WriteLine("Search Term = {0}", opts.SearchString);
                OutputStream.WriteLine("Search Mode = {0}:{1}", opts.QueryType, opts.QueryMode);
                OutputStream.WriteLine("===========================================================");
            }
            


            for ( int x = 0; x < count; x++ )
            {
                Console.WriteLine("{0}", sortedResults[x]);
                if (OutputStream != null)
                {
                    OutputStream.WriteLine("{0}", sortedResults[x]);
                }
            }


            if ( OutputStream != null )
            {
                OutputStream.Flush();
                OutputStream.Close();
            }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\guidemanager\guidesearch.cs ===
using System;
using MediaCenter.Video;
using System.Runtime.InteropServices;
using ServiceBus.Interop.RecordingGSCustomObject;

namespace GuideMgr
{
	/// <summary>
	/// Summary description for GuideSearch.
	/// </summary>
	public class GuideSearch
	{
        MediaCenter.Video.ShowQueryOp   query;
        GSMediaLibrary                  gs;
        IPrograms                       programs;
        
        public GuideSearch(QUERYTYPE type, QUERYMODE mode, string searchstring)
        {
            gs = new GSMediaLibrary();
            switch (mode)
            {
                case QUERYMODE.CONTAINS:
                    query = ShowQueryOp.Contains;
                    break;
                case QUERYMODE.STARTSWITH:
                    query = ShowQueryOp.StartsWith;
                    break;
            } // switch mode

            switch (type)
            {
                case QUERYTYPE.KEYWORD:
                    programs = gs.ShowsKeywordQuery(query, searchstring );
                    break;
                case QUERYTYPE.TITLE:
                    programs = gs.ShowsTitleQuery(query, searchstring);
                    break;
            } // switch type
        }

        public string[,] ReturnResults()
        {
            string[,] results = new string[programs.Count,3];

            // Display hits
            for(uint i=0; i < programs.Count; i++)
            {
                results[i,0] = programs.get_Item(i).Title;
                results[i,1] = programs.get_Item(i).Description;
                results[i,2] = "";
            }

            return results;
        }

        ~GuideSearch()
        {
            // release the programs com obj
            Marshal.ReleaseComObject(programs);
            programs = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\guidemanager\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\guidemanager\programargs.cs ===
/********************************************************************
 * Project  : C:\DEPOT\multimedia\eHomeTest\UserXp\guidesearch\guidesearch.sln
 * File     : ProgramArgs.cs
 * Summary  :
 * Classes  :
 * Notes    :
 * *****************************************************************/
using System;

namespace GuideMgr
{
    public enum QUERYTYPE {TITLE, KEYWORD, GENRE, ONNOW, TIME};
    public enum QUERYMODE {STARTSWITH, CONTAINS};

    /*C+C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C
     * public class ProgramArgs
     * 
     * Summary  :
     * ---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C*/
    public class ProgramArgs
    {
        /*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
         * static public int CommandLine(string[] args)
         * Args     :
         * Modifies :
         * Returns  :
         * M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M*/
        public bool CommandLine(string[] args)
        {
            foreach(string s in args)
            {
                /*----------------------------------------
                 * Check for test type
                 * ----------------------------------------*/
                // TEST = Length
                if ( s.StartsWith("tlen"))
                {
                    _test = "len";
                }
                // TEST = SEARCH
                else if ( s.StartsWith("tsrch"))
                {
                    _test = "search";
                }

                /*----------------------------------------
                 * SEARCH Test Options
                 * ----------------------------------------*/
                // Search type {STITILE, SKEYWORD, STIME}
                else if ( s.StartsWith("title"))
                {
                    _queryType = QUERYTYPE.TITLE;
                }
                else if (s.StartsWith("keyword"))
                {
                    _queryType = QUERYTYPE.KEYWORD;
                }

                // Search Mode { STARTSWITH, CONTAINS }
                else if ( s.StartsWith("contains"))
                {
                    _queryMode = QUERYMODE.CONTAINS;
                }
                else if ( s.StartsWith("startswith"))
                {
                    _queryMode = QUERYMODE.STARTSWITH;
                }

                // search string
                else if ( s.StartsWith("-s")  && 2 < s.Length)
                {
                    _searchString = s.Substring(2);
                }

                /*----------------------------------------
                 * LENGTH Test Options
                 * ----------------------------------------*/
                // title length
                else if ( s.StartsWith("-mt") && 3 < s.Length)
                {
                   _maxTitleLen = System.Convert.ToInt32(s.Substring(3));
                }
                else if ( s.StartsWith("-md") && 3 < s.Length)
                {
                    _maxDescLen = System.Convert.ToInt32(s.Substring(3));
                }
                /*----------------------------------------
                 * COMMON Options
                 * ----------------------------------------*/
                // Output File
                else if ( s.StartsWith("-o")  && 2 < s.Length)
                {
                    _outputFile = s.Substring(2);
                }

                    // Append flag
                else if ( s.StartsWith("-p"))
                {
                    _appendFlag = true;
                }

                    // help flags
                else if ( s.StartsWith("-?") || s.StartsWith("/?") || s.StartsWith("-h") )
                {
                    ArgsHelp();
                    return false;
                }
                else
                {
                    Console.WriteLine("Invalid parameter!!");
                    ArgsHelp();
                    return false;
                }
            } // foreach

            return true;
        } // public int ProgramArgs(string[] args)


        /*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
         * static private void ArgsHelp()
         * Args     :
         * Modifies :
         * Returns  :
         * M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M*/
        static private void ArgsHelp()
        {
            Console.WriteLine("Guidesearch [tlen|tsrch] [title|keyword] [startswith|contains] -s<Search String> -o<Output file> -p");

            Console.WriteLine("SEARCH MODE OPTIONS:");
            Console.WriteLine("\t[tlen|tsrch]             = test type to run. tlen = length test, tsrch = search test.");
            Console.WriteLine("\t[title|keyword]        = search on.");
            Console.WriteLine("\t[startswith|contains]  = search mode.");
            Console.WriteLine("\t-s = string to search for. Begins with or contains mode\n\tselected automatically based on string length.");

            Console.WriteLine("\nLENGTH MODE OPTIONS:");
            Console.WriteLine("\t-mt<value>             = Maximum title length allowed.");
            Console.WriteLine("\t-md<value>             = Maximum description length allowed.");

            Console.WriteLine("\nCOMMON OPTIONS:");
            Console.WriteLine("\t-o = File to write results to. If parameter not given, output is to console.");
            Console.WriteLine("\t-p = Pass this parameter to append results to the file specified with the -o option");
        }

        /*---------------------------------------------------------
            Member Variables
        ----------------------------------------------------------*/
        // Test mode
        public string test
        {
            get { return _test; }
            set { _test = value; }
        }

        // URL of guide file
        public string GuideDb
        {
            get { return _GuideDb;}
            set { _GuideDb = value;}
        }

        // Search Type
        public QUERYTYPE QueryType
        {
            get { return _queryType;}
            set { _queryType = value;}
        }

        // Search mode
        public QUERYMODE QueryMode
        {
            get { return _queryMode; }
            set { _queryMode = value; }
        }
    
        // Search string
        public string SearchString
        {
            get { return _searchString; }
            set { _searchString = value; }
        }

        public int MaxTitleLen
        {
            get { return _maxTitleLen; }
            set { _maxTitleLen = value;}
        }

        public int MaxDescLen
        {
            get { return _maxDescLen; }
            set { _maxDescLen = value;}
        }

        // Write results to this file
        public string OutputFile
        {
            get { return _outputFile; }
            set { _outputFile = value; }
        }

        // Append flag
        public bool Append
        {
            get { return _appendFlag; }
            set { _appendFlag = value; }
        }

        // test to run
        string      _test           = "len";
        
        // Search test params
        QUERYTYPE   _queryType      = QUERYTYPE.KEYWORD;
        QUERYMODE   _queryMode      = QUERYMODE.CONTAINS;
        string      _searchString   = " ";

        // Length test params
        int         _maxTitleLen    = 255;
        int         _maxDescLen     = 16484;

        // Common params
        string      _GuideDb        = "tms.mgs";
        string      _outputFile     = "";
        bool        _appendFlag     = false;

    } // public class ProgramArgs

} // namespace guidesearch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\mediamanager\lencheck.cs ===
/********************************************************************
 * Project  : C:\DEPOT\multimedia\eHomeTest\UserXp\MediaManager\MediaManager.sln
 * File     : LenCheck.cs
 * Summary  : Utility class used to verify the length of attributes in the Media Player Library.
 *              Primary use is for CES demo while word wrap bug exists in product.
 * Classes  :
 * Notes    :
 * *****************************************************************/

using System;
using System.IO;

namespace MediaManager
{
	/// <summary>
	/// Summary description for LenCheck.
	/// </summary>
	public class LenCheck
	{
		public LenCheck(string attribute, int maxLen, string outputFile, bool fileAppend)
		{
            string[]        results;
            int             resultsCount = 0;
            StreamWriter	OutputStream = null;
            MPCollection    mp      = new MPCollection();
            
            
            results = mp.GetAllItemsAttribute(attribute);
            Array.Sort(results);

            if ( outputFile != "" )
            {
                if ( fileAppend == true )
                {
                    OutputStream = File.AppendText(outputFile);
                }
                else
                {
                    OutputStream = File.CreateText(outputFile);
                }
            }

            Console.WriteLine("Media Manager Length Test\nParameters: Property={0} MaxLen={1} Output={2}",attribute, maxLen, outputFile);
            Console.WriteLine("=======================================================");
            if ( OutputStream != null)
            {
                OutputStream.WriteLine("Media Manager Length Test\nParameters: Property={0} MaxLen={1} Output={2}",attribute, maxLen, outputFile);
                OutputStream.WriteLine("=======================================================");
            }
            foreach (string s in results)
            {
                if ( s.Length > maxLen )
                {
                    resultsCount++;
                    Console.WriteLine("{0}",s);
                    if ( OutputStream != null)
                    {
                        OutputStream.WriteLine("{0}",s);
                    }
                }
            }
            Console.WriteLine("************************************************");
            Console.WriteLine("Run Complete. {0} Entries met requirements", resultsCount);

            if ( OutputStream != null)
            {
                OutputStream.WriteLine("************************************************");
                OutputStream.WriteLine("Run Complete. {0} Entries met requirements", resultsCount);
            }

            if ( OutputStream != null )
            {
                OutputStream.Flush();
                OutputStream.Close();
            }


		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\proctest\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\stringcheck\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\mediamanager\mediamanager.cs ===
/********************************************************************
 * Project  : C:\DEPOT\multimedia\eHomeTest\UserXp\MediaManager\MediaManager.sln
 * File     : MediaManager.cs
 * Summary  : Entry point for a series of media player management tools
 * Classes  :
 * Notes    :
 * *****************************************************************/

using System;


namespace MediaManager
{

	class MediaManagerApp
	{
		[STAThread]
		static void Main(string[] args)
		{
            ProgramArgs     prgargs = new ProgramArgs();
            LenCheck        lc;

            if ( false == prgargs.CommandLine(args) ) return;
            lc = new LenCheck(prgargs.attribute, prgargs.maxLen, prgargs.outputFile, prgargs.append);
		} // Main
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\mediamanager\programargs.cs ===
/********************************************************************
 * Project  : C:\DEPOT\multimedia\eHomeTest\UserXp\guidesearch\guidesearch.sln
 * File     : ProgramArgs.cs
 * Summary  :
 * Classes  :
 * Notes    :
 * *****************************************************************/
using System;

namespace MediaManager
{
    /*C+C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C
     * public class ProgramArgs
     * 
     * Summary  :
     * ---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C*/
    public class ProgramArgs
    {
        /*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
         * static public int CommandLine(string[] args)
         * Args     :
         * Modifies :
         * Returns  :
         * M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M*/
        public bool CommandLine(string[] args)
        {
            if (args == null)
            {
                ProgramArgs.ArgsHelp();
                return false;
            }

            if ( args.GetLength(0) < NUMPARAMS )
            {
                ProgramArgs.ArgsHelp();
                return false;
            }

            // Command line -m<max len> -a"attribute" -o"output file" -p to append
            foreach(string s in args)
            {
                // attribute to measure
                if ( s.StartsWith("-a")  && 2 < s.Length)
                {
                    _attribute = s.Substring(2);
                }
                    // Max allowed length of string
                else if ( s.StartsWith("-m") && 2 < s.Length)
                {
                    _maxLen = System.Convert.ToInt32(s.Substring(2));
                }
                    // output file - if any
                else if ( s.StartsWith("-o") && 2 < s.Length)
                {
                    _outputFile = s.Substring(2);
                }
                else if ( s.StartsWith("-p" ))
                {
                    _appendToFile = true;
                }
                else
                {
                    Console.WriteLine("Invalid parameter!!");
                    ArgsHelp();
                    return false;
                }
            } // foreach
            return true;
        } // public int ProgramArgs(string[] args)


        /*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
         * static private void ArgsHelp()
         * Args     :
         * Modifies :
         * Returns  :
         * M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M*/
        static private void ArgsHelp()
        {
            Console.WriteLine("MediaManager -a<attribute> -m<Max Length> -o<Output file> -p[append flag]");
            Console.WriteLine("\tAttribute can be any one of the attributes supported by media player.");
            Console.WriteLine("\tincluding: Name, Artist, Album, etc.");
            Console.WriteLine();
            Console.WriteLine("\tIf no output file is specified, data is written to console.");
            Console.WriteLine("\tIf the -p argument is given, output will be appended to specified file.");

        }

        /*---------------------------------------------------------
            Member Variables
        ----------------------------------------------------------*/
        // Required number of parameters
        public const int NUMPARAMS = 2;

        public int maxLen
        {
            get { return _maxLen;}
            set { _maxLen = value;}
        }
        public string attribute
        {
            get { return _attribute; }
            set { _attribute = value; }
        }
        public string outputFile
        {
            get { return _outputFile;}
            set { _outputFile  = value;}
        }
        public bool append
        {
            get { return _appendToFile; }
            set { _appendToFile = value; }
        }

        int     _maxLen         = 25;
        string  _attribute      = "title";
        string  _outputFile     = "";
        bool    _appendToFile   = false;

    } // public class ProgramArgs

} // namespace guidesearch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\guidemanager\lencheck.cs ===
/********************************************************************
 * Project  : C:\DEPOT\multimedia\eHomeTest\UserXp\guidesearch\guidesearch.sln
 * File     : LenCheck.cs
 * Summary  : This class is used to check the title and content lengths. Used for demos at CES while string wrapping bug exists.
 * Classes  :
 * Notes    :
 * *****************************************************************/

using System;
using MediaCenter.Video;
using System.Runtime.InteropServices;
using ServiceBus.Interop.RecordingGSCustomObject;
using System.Threading;

namespace GuideMgr
{
	/// <summary>
	/// Summary description for LenCheck.
	/// </summary>
	public class LenCheck
	{
        MediaCenter.Video.ShowQueryOp   query;
        GSMediaLibrary                  gs;
        IPrograms                       programs;
        
        public LenCheck()
        {
            gs = new GSMediaLibrary();
            query = ShowQueryOp.Contains;
            programs = gs.ShowsKeywordQuery(query, " " );
        }

        public string[,] ReturnResults(int titleLen, int descLen)
        {
            string[,]       fullResults;
            string[,]       filteredResults;
            int             index = 0;
            int             entryCount = 0;
            int             totalProgramCount = 0;
            int             tooLargeCount = 0;
            IProgram        prg = null;
            IScheduleEntry  se = null;

            Console.WriteLine("This is slow. Please be patient.");

            // Get results of search on "ALL"
            Console.WriteLine("Finding Results");
            totalProgramCount = programs.Count;
            fullResults = new string[totalProgramCount, 3];

            for(uint i=0; i < totalProgramCount; i++)
            {
                prg = programs.get_Item(i);
                fullResults[i,0] = prg.Title;
                fullResults[i,1] = prg.Description;
                
                /* // Here is some code that gives access to showings for this program
               
                entryCount = prg.ScheduleEntries.Count;
                fullResults[i,2] = "";
                for (int k = 0; k < entryCount; k++)
                {
                    prg = programs.get_Item(i);
                    se = prg.ScheduleEntries.get_Item(k);
                    {
                        fullResults[i,2] = fullResults[i,2]  + se.StartTime + "  " + 
                        se.Service.ProviderDescription + " " +  "\r\n";
                        Console.WriteLine("TITLE:{0}\r\nSHOWINGS:\r\n{1}DESCRIPTION:{2}", fullResults[i,0], fullResults[i,2], fullResults[i,1]);
                    }
                    Marshal.ReleaseComObject(se);
                    Marshal.ReleaseComObject(prg);
                } // for entries
                */

                if (fullResults[i,0].Length > titleLen || 
                    fullResults[i,1].Length > descLen)
                {
                    prg.Title = "**************************";
                    tooLargeCount++;
                }
                Marshal.ReleaseComObject(prg);
            } // for programs

            // create results array and fill it.
            filteredResults = new string[tooLargeCount,3];
            Console.WriteLine("Filling Array");
            for(uint i=0; i < totalProgramCount; i++)
            {
                if (fullResults[i,0].Length > titleLen || 
                    fullResults[i,1].Length > descLen)
                {
                    filteredResults[index,0] = fullResults[i,0];
                    filteredResults[index,1] = fullResults[i,1];
                    filteredResults[index,2] = fullResults[i,2];
                    index++;
                }
            }
            return filteredResults;
        }

        ~LenCheck()
        {
            // release the programs com obj
            Marshal.ReleaseComObject(programs);
            programs = null;
		}

  	} // public class LenCheck
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\stringcheck\filescan.cs ===
/*+*******************************************************************************************
  Project				: StringCheck
  File					: filescan.c
  Summary				: This class scans a file for instances of a search string and appends
							the filename, line# and matched string to a file.
  Classes / Fcns		: 
  Notes / Revisions		: 
*******************************************************************************************+*/

using System;
using System.IO;
using System.Text.RegularExpressions;


public class FileScan
{
/*---------------------------------------------------------
	Constructors
----------------------------------------------------------*/
	

	/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++
	Method: 	public FileScan()
	Summary:
	Args:
	Modifies:
	Returns:
	M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
	public FileScan()
	{
	}


	/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++
	Method: 	public FileScan(string InputFile, string OutputFile, string SearchString)
	Summary:
	Args:
	Modifies:
	Returns:
	M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
	public FileScan(string InputFile, string OutputFile, string SearchString)
	{
		Setup(InputFile, OutputFile, SearchString);
	}

/*---------------------------------------------------------
	Public Methods
----------------------------------------------------------*/

	/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++
	Method: 	public void Setup(string InputFile, string OutputFile, string SearchString)
	Summary:
	Args:
	Modifies:
	Returns:
	M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
	public void Setup(string InputFile, string OutputFile, string SearchString)
	{
		this.InputFile = InputFile;
		this.OutputFile = OutputFile;
		this.SearchString = SearchString;
	}


	/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++
	Method: 	public int ScanFile()
	Summary:
	Args:
	Modifies:
	Returns:
	M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
	public int ScanFile()
	{
/*---------------------------------------------------------
	To Do: Need error checking
----------------------------------------------------------*/	
		StreamWriter	OutputStream;
		StreamReader	InputStream;
		String			line, OutputString;
		int				linenum, padding, i ;
		Match			m;
		Regex			r;
        bool            excludeLine;

		// Open log file and input file
		OutputStream = File.AppendText(OutputFile);
		InputStream  = File.OpenText(InputFile);

		// Build regex expression
		// System.ArgumentException
		try
		{
			r = new Regex(SearchString);
		}
		catch ( System.ArgumentException )
		{
			Console.WriteLine("FileScan:ScanFile() - ERROR - \"{0}\" is not a valid regex expression", SearchString);
			return 0;
		}

		// Read input file line by line - repeat until end of file
		Console.WriteLine("Scanning {0} for {1}", InputFile, SearchString);
        linenum = 0;

        while ((line=InputStream.ReadLine())!=null)
		{
            linenum++;
			m = r.Match(line);
			if (m.Success)
			{
                // Remove leading spaces
                padding = 0;
                while ( line[padding] == ' ')
                {
                    padding++;
                }
                line = line.Substring(padding);
            
                // check exclusions
                excludeLine = false;
                foreach (string s in FileScan.excludes)
                {
                    if ( -1 != line.IndexOf(s) )
                    {
                        excludeLine = true;
                        break;
                    }
                }

                if ( excludeLine == false )
                {
                    // Write to output file in CSV format
                    //OutputString = "\"" + InputFile + "\"," + linenum + ",\"" + line + "\"";
                    OutputString = InputFile + "~" + linenum + "~" + line;
                    OutputStream.WriteLine(OutputString);
                }
			}
		}

		// cleanup and return
		OutputStream.Flush();
		OutputStream.Close();
		InputStream.Close();
		return 1;
	}


/*---------------------------------------------------------
	// member vars
----------------------------------------------------------*/
	private string			InputFile = "";
	private string			OutputFile = "out.txt";
	private string			SearchString = "*";

    static string[] excludes = { 
                                   "DllImport",
                                   "///",
                                   "StringTable.GetString",
                                   "new Button",
                                   "FillSpec.Parse",
                                   "case \"",
                                   "Debug.Assert",
                                   "Debug.Fail",
                                   "Debug.WriteLine",
                                   "MessageTrace" };
                                
	

} // class FileScan
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\stringcheck\dirscan.cs ===
/*+*******************************************************************************************
  Project				: StringCheck
  File					: dirscan.c
  Summary				: 
  Classes / Fcns		: 
  Notes / Revisions		: 
*******************************************************************************************+*/
using System;
using System.IO;

public class  DirScan
{
	/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++
	Method: 	public DirScan()
	Summary:
	Args:
	Modifies:
	Returns:
	M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
	public DirScan()
	{
	} // constructor DirScan()

	/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++
	Method: 	public DirScan(string StartDir, string FileFilter, string SearchString, string OutputFile)
	Summary:
	Args:
	Modifies:
	Returns:
	M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
	public DirScan(string StartDir, string FileFilter, string SearchString, string OutputFile)
	{
		Setup(StartDir, FileFilter, SearchString, OutputFile);
	} // constructor DirScan()


/*---------------------------------------------------------
	Public Member Fcns
----------------------------------------------------------*/
	/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++
	Method: 	public Setup(string StartDir, string FileFilter, string SearchString, string OutputFile)
	Summary:
	Args:
	Modifies:
	Returns:
	M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
	public void Setup(string StartDir, string FileFilter, string SearchString, string OutputFile)
	{
		this.StartDir		= StartDir;
		this.FileFilter		= FileFilter;
		this.SearchString	= SearchString;
		this.OutputFile		= OutputFile;

	} // public void Setup

	/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++
	Method: 	public void BeginScan()
	Summary:
	Args:
	Modifies:
	Returns:
	M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
	public void BeginScan()
	{
		DirectoryInfo	dir;
		FileScan		file;

		String			FullName;
		long			FileSize;
		DateTime		CreationDate;

		// Setup DirectoryInfo and FileScan instances;
		dir		= new DirectoryInfo(StartDir);
		file	= new FileScan();

		/*---------------------------------------------------------
			To Do: Need to set this up to call some type of 
					callback fcn using whatever mecanisim C# 
					supports. 

					For now, I just call an instance of FileScan
		----------------------------------------------------------*/
        try
        {
            foreach (FileInfo f in dir.GetFiles(FileFilter)) 
            {
                FullName	= f.FullName;
                FileSize	= f.Length;
                CreationDate= f.CreationTime;
                //Console.WriteLine("{0}", FullName);
                file.Setup(FullName, OutputFile, SearchString);
                if ( 0 == file.ScanFile())
                {
                    Console.WriteLine("DirScan:BeginScan() - ERROR - file.ScanFile Failed. Exiting\n");
                    return;
                }
            }
        } 
        catch (System.IO.IOException)
        {
            Console.WriteLine("Caught System.IO.IOException while scanning {0}", FileFilter);
        }
                                          
	}// public void BeginScan
	
/*---------------------------------------------------------
	Member vars
----------------------------------------------------------*/
	// Directory to scan
	private string			StartDir = "..";

	// Files to scan for
	private string			FileFilter = "*";

	// string to search for in each file
	private string			SearchString = "*";

	// path + filename to write results to
	private string			OutputFile = "out.txt";

} // class DirScan
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\mediamanager\wmptest.cs ===
using System;
using WMPOCX ;

namespace WindowsApplication1
{
    /// <summary>
    /// Summary description for Form1.
    /// </summary>
        public class Form1 : System.Windows.Forms.Form
        {
            WMPOCX.WMPOCX wmpocx = null ;
            WMPOCX.IWMPPlayer wmpplayer = null ;
            private System.Windows.Forms.ListBox albumListbox;
            private System.Windows.Forms.Label label1;
            private System.Windows.Forms.Label songTitle;
            private System.Windows.Forms.Label label2;
            private System.Windows.Forms.Label label3;
            private System.Windows.Forms.Label playState;
            private System.Windows.Forms.TextBox musicPath;
            private System.Windows.Forms.Button addMusic;
            private System.Windows.Forms.RichTextBox richTextBox1;

            // jmw added controls here
            private System.Windows.Forms.Button fullScreen ;
            
            /// <summary>
            /// Required designer variable.
            /// </summary>
            private System.ComponentModel.Container components = null;

            ///<summary>
            ///  internal event handler for when the play state changed. This routine checks to see if there is a playStateChanged
            ///  event handler and if so calls it.
            ///</summary>
            private void CDRomMediaChange( int i)
            {
                Debug.WriteLine("*** In CDRomMediaChange callback ***") ;
            }

            public void MediaChange( object sender )
            {
                Debug.WriteLine("In MediaChange") ;

                WMPOCX.IWMPMedia wmpmedia = wmpplayer.currentMedia ;
                if ( wmpmedia != null  )
                {
                    songTitle.Text = wmpmedia.name ;
                    ShowXML() ;
                }
                else
                {
                    songTitle.Text = "" ;
                }
            }

            public void MediaCollectionChange( )
            {
                ResetAlbumList() ;
            }

            public void PlayStateChange(int i)
            {
                Debug.WriteLine("*** In PlayStateChange callback ***") ;
                switch( wmpplayer.playState )
                {
                    case WMPOCX.WMPPlayState.wmppsBuffering:
                        playState.Text = "Buffering" ;
                        break ;
                    case WMPOCX.WMPPlayState.wmppsMediaEnded:
                        playState.Text = "Ended" ;
                        break ;
                    case WMPOCX.WMPPlayState.wmppsPaused:
                        playState.Text = "Paused" ;
                        break ;
                    case WMPOCX.WMPPlayState.wmppsPlaying:
                        playState.Text = "Playing" ;
                        break ;
                    case WMPOCX.WMPPlayState.wmppsStopped:
                        playState.Text = "Stopped" ;
                        break ;
                    case WMPOCX.WMPPlayState.wmppsReady:
                        playState.Text = "Ready" ;
                        break ;
                    case WMPOCX.WMPPlayState.wmppsScanForward :
                        playState.Text = "Scanning Forward" ;
                        break ;
                    case WMPOCX.WMPPlayState.wmppsScanReverse :
                        playState.Text = "Scanning Reverse" ;
                        break ;
                    case WMPOCX.WMPPlayState.wmppsTransitioning :
                        playState.Text = "Transitioning" ;
                        break ;
                    case WMPOCX.WMPPlayState.wmppsUndefined  :
                        playState.Text = "Undefined" ;
                        break ;
                    case WMPOCX.WMPPlayState.wmppsWaiting   :
                        playState.Text = "Waiting" ;
                        break ;
                }

            }

            public void ResetAlbumList()
            {
                // Get the list of album names and put them into the listbox.
                IWMPStringCollection rgsAlbumNames = wmpplayer.mediaCollection.getAttributeStringCollection("Album", "Audio" ) ;
                for ( int i = 0; i < rgsAlbumNames.count; i++ )
                {
                    string strAlbumName = rgsAlbumNames.Item(i) ;
                    albumListbox.Items.Add( strAlbumName ) ;
                }

            }

            public Form1()
            {
                //
                // Required for Windows Form Designer support
                //
                InitializeComponent();

                //
                // TODO: Add any constructor code after InitializeComponent call
                //
                wmpocx = new WMPOCX.WMPOCXClass() ;
                wmpplayer = (IWMPPlayer) wmpocx ;

                ResetAlbumList() ;


                WMPOCX._WMPOCXEvents_Event	wmpocxEvents = (WMPOCX._WMPOCXEvents_Event) wmpocx ;
                wmpocxEvents.CdromMediaChange += 
                new WMPOCX._WMPOCXEvents_CdromMediaChangeEventHandler( this.CDRomMediaChange ) ;
                wmpocxEvents.MediaChange += 
                new WMPOCX._WMPOCXEvents_MediaChangeEventHandler( this.MediaChange ) ;
                wmpocxEvents.PlayStateChange += new WMPOCX._WMPOCXEvents_PlayStateChangeEventHandler( this.PlayStateChange ) ;
                wmpocxEvents.MediaCollectionChange += 
                new WMPOCX._WMPOCXEvents_MediaCollectionChangeEventHandler( this.MediaCollectionChange ) ;

                // set the initial state
                PlayStateChange( 0 ) ;

                // Set the default music path
                musicPath.Text = Environment.GetFolderPath((Environment.SpecialFolder)0x000d) ;

            }

            /// <summary>
            /// Clean up any resources being used.
            /// </summary>
            protected override void Dispose( bool disposing )
            {
                if( disposing )
                {
                    if (components != null) 
                    {
                       components.Dispose();
                    }
                }
                base.Dispose( disposing );
            }

#region Windows Form Designer generated code
                /// <summary>
                /// Required method for Designer support - do not modify
                /// the contents of this method with the code editor.
                /// </summary>
                private void InitializeComponent()
                {
                    this.albumListbox = new System.Windows.Forms.ListBox();
                    this.label1 = new System.Windows.Forms.Label();
                    this.songTitle = new System.Windows.Forms.Label();
                    this.label2 = new System.Windows.Forms.Label();
                    this.label3 = new System.Windows.Forms.Label();
                    this.playState = new System.Windows.Forms.Label();
                    this.addMusic = new System.Windows.Forms.Button();
                    this.musicPath = new System.Windows.Forms.TextBox();
                    this.fullScreen = new System.Windows.Forms.Button() ;
                    this.richTextBox1 = new System.Windows.Forms.RichTextBox();

                    this.SuspendLayout();
                    // 
                    // albumListbox
                    // 
                    this.albumListbox.Location = new System.Drawing.Point(520, 64);
                    this.albumListbox.Name = "albumListbox";
                    this.albumListbox.Size = new System.Drawing.Size(280, 407);
                    this.albumListbox.TabIndex = 0;
                    this.albumListbox.SelectedIndexChanged += new System.EventHandler(this.albumListbox_SelectedIndexChanged);
                    // 
                    // label1
                    // 
                    this.label1.Location = new System.Drawing.Point(520, 32);
                    this.label1.Name = "label1";
                    this.label1.Size = new System.Drawing.Size(256, 23);
                    this.label1.TabIndex = 1;
                    this.label1.Text = "Album Names";
                    // 
                    // songTitle
                    // 
                    this.songTitle.BackColor = System.Drawing.SystemColors.HotTrack;
                    this.songTitle.ForeColor