
    // The total number of bytes currently in the receive packet 
    //
    ULONG   ReceivedByteNo;

    //  
    // This flag inidictes that the input filter treats the next packet as and ATR
    //
    BOOLEAN WaitForATR;

    //
    // Mask that indicates the input filter what events we are expecting
    //
    ULONG   WaitMask;

    // 
    // Smartcard notification DPC queue
    //
    KDPC    NotificationIsrDpc;

    //
    // Event used to indicate that an ack was received by the input filter.
    // This will signal the Lit220Command that it can continue.
    //
    KEVENT  AckEvnt;

    //
    // Event used to indicate that a data packet was received by the input filter.
    // This will signal the Lit220Command that it can continue.
    //
    KEVENT  DataEvnt;

    //
    // Holds the Device Object of the top of our stack
    //
    PDEVICE_OBJECT BusDeviceObject;

    //
    // Holds the Device Object of our parent (1394 bus driver)
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // State the Lit220SerialEventCallback is in.
    //
    DWORD SerialEventState; 

    //
    // Temporary transfer buffer used to get data from the serial port
    // before we send it to the input filter
    //
    BYTE TempXferBuf[270];


    // Flag that indicates that the caller requests a power-down or a reset
    BOOLEAN PowerRequest;

    // Saved card state for hibernation/sleeping modes.
    BOOLEAN CardPresent;

    // Current reader power state.
    READER_POWER_STATE ReaderPowerState;

    // Used to indicate that the device has been removed even before we can release
    // the remove lock throw SmartcardReleaseRemoveLockAndWait.  This way when we 
    // close the connection to the serial port we won't send any more IRPs to the
    // device 
    BOOLEAN DeviceRemoved;

    // Flag indicating whether the card is inserted or not
    DWORD CardIn;


} READER_EXTENSION, *PREADER_EXTENSION;



typedef struct _DEVICE_EXTENSION {

    SMARTCARD_EXTENSION SmartcardExtension;

    // The current number of io-requests
    LONG IoCount;

    // Used to signal that the reader is able to process reqeusts
    KEVENT ReaderStarted;

    // The pnp device name of our smart card reader
    UNICODE_STRING PnPDeviceName;

    // Used to signal the the reader has been closed
    LONG ReaderOpen;

    // Used to signal that the connection to the serial driver has been closed
    KEVENT SerialCloseDone;

    // Used to keep track of the current power state the reader is in
    LONG PowerState;

    KSPIN_LOCK SpinLock;

    // A worker thread that closes the serial driver &
    // handling IO timeouts
    PIO_WORKITEM WorkItem;

    // Keeps track of how many times the timeout
    // function has been called
    BYTE EntryCount;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;




//
// Prototypes
//
NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

VOID
Lit220Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
Lit220CreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Lit220SystemControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   );

NTSTATUS
Lit220DeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
Lit220Initialize(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220ConfigureSerialPort(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220SerialIo(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID
Lit220StopDevice(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID
Lit220RemoveDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
Lit220StartDevice(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS 
Lit220InitializeInputFilter(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220Cleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Lit220Cancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


BOOLEAN
Lit220InputFilter(
    IN BYTE SmartcardByte,
    IN PSMARTCARD_EXTENSION smartcardExtension
    );

NTSTATUS
Lit220CardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220SetProtocol(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220Power(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220IoRequest(
    PSMARTCARD_EXTENSION SmartcardExtension
    );


NTSTATUS
Lit220GetReaderError(
    PSMARTCARD_EXTENSION SmartcardExtension
    );


NTSTATUS
Lit220IoReply(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

BOOLEAN
Lit220IsCardPresent(
      IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220Command(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220AddDevice(
    IN     PDRIVER_OBJECT  DriverObject,
    IN     PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
Lit220PnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Lit220SynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );
                       
VOID 
Lit220CloseSerialPort(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context  
    );

NTSTATUS
Lit220CallSerialDriver(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp);

NTSTATUS 
Lit220SerialEventCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220DispatchPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
Lit220NotifyCardChange(
    IN PSMARTCARD_EXTENSION smartcardExtension,
    IN DWORD CardInserted
    );

NTSTATUS
Lit220DevicePowerCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID
Lit220CompleteCardTracking(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID
Lit220ReceiveBlockTimeout(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

VOID 
Lit220ProcessNack(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID 
Lit220StartTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM WorkItem
    );

VOID 
Lit220StopTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM WorkItem
    );

VOID 
Lit220ScheduleTimer(
    IN PSMARTCARD_EXTENSION SmartcardExtension,
    IN PIO_WORKITEM_ROUTINE Routine
    );




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\lit220\l220ser.c ===
/*++

    Copyright (C) Microsoft Corporation and Litronic, 1998 - 1999

Module Name:

    L220Ser.c

Abstract:

    This module contains the functions for the 220 serial smart card reader.
    Most functions herein will be called by the smart card lib.


Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 1996 by Klaus Schutz 

    - Modified December 1997 by Brian Manahan for use with
        the 220 reader.
--*/

#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#include "L220SCR.h"


// Make functions pageable
#pragma alloc_text(PAGEABLE, Lit220Command)
#pragma alloc_text(PAGEABLE, Lit220IoRequest)
#pragma alloc_text(PAGEABLE, Lit220IoReply)


NTSTATUS
Lit220CardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    The smart card lib requires to have this function. It is called 
    to set up event tracking for card insertion and removal events.
    We set the cancel routine so the IRP can be canceled.
    We always return STATUS_PENDING and the Lit220NotifyCardChange
    will signal the completion when called from the Lit220InputFilter.

Arguments:

    SmartcardExtension - pointer to the smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    KIRQL oldIrql;
    KIRQL oldOsDataIrql;

    //
    // Set the wait mask for the isr. The isr will complete the 
    // user request.
    //
    SmartcardExtension->ReaderExtension->WaitMask |= WAIT_INSERTION; // WAIT_INSERTION - wait for insertion or removal

    //
    // Set cancel routine for the notification irp
    //
    KeAcquireSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        &oldOsDataIrql
        );

    ASSERT (SmartcardExtension->OsData->NotificationIrp);

    if (SmartcardExtension->OsData->NotificationIrp) {
        IoAcquireCancelSpinLock(
            &oldIrql
            );
    
        IoSetCancelRoutine(
            SmartcardExtension->OsData->NotificationIrp, 
            Lit220Cancel
            );
        
        IoReleaseCancelSpinLock(
            oldIrql
            );

    } else {
        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!Lit220CardTracking: SmartcardExtension->OsData->NotificationIrp is NULL!!! This should not be.\n", 
            DRIVER_NAME
            ));
    }

    KeReleaseSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        oldOsDataIrql
        );

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220CardTracking: Exit, WaitMask %X, NotificationIRP %X\n", 
        DRIVER_NAME, 
        SmartcardExtension->ReaderExtension->WaitMask,
        SmartcardExtension->OsData->NotificationIrp
        ));

    return STATUS_PENDING;
}   



NTSTATUS
Lit220Command(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    ) 
/*++

Routine Description:

    This routine sends a command to the reader. 
    SerialIo is used to write the command to the reader synchronously.
    We then wait for an ACK from the reader (by waiting for a signal from
    the Lit220InputFilter) so we know it received the command OK.
    If data is expected we wait for the data event signal from the
    Lit220InputFilter to indicate that the data is ready.

Arguments:

    DeviceObject -  Pointer to the device object.

Return Value:

    -

--*/
{
    PDEVICE_OBJECT deviceObject = SmartcardExtension->OsData->DeviceObject;
    PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;
    ULONG i;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    LARGE_INTEGER timeout;
    ULONG localWaitMask;
    ULONG retry = 1;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Command: Enter\n",
        DRIVER_NAME)
        );

    do{

        // Make sure the data & ack events are not signaled before we start

        // Clear the DataEvnt
        KeClearEvent(
            &readerExtension->DataEvnt
            );


        // Clear the AckEvnt
        KeClearEvent(
            &readerExtension->AckEvnt
            );


        readerExtension->ReceivedByteNo = 0;

        readerExtension->GotNack = FALSE;

        // We always exect an ACK back
        readerExtension->WaitMask |= WAIT_ACK;


        // We need to copy the wait mask because the wait mask might change 
        // before we have a chance to check if we need to wait on it 
        localWaitMask = readerExtension->WaitMask;

        //
        // Send the data to the reader
        //
        readerExtension->SerialIoControlCode = IOCTL_SMARTCARD_220_WRITE;

        // Use SerialIo to actually send the bytes to the reader
        status = Lit220SerialIo(
            SmartcardExtension
            );

        //
        // Set Timeout according the protocol
        //
        timeout.HighPart = -1;
        switch (SmartcardExtension->CardCapabilities.Protocol.Selected) {

            case SCARD_PROTOCOL_UNDEFINED:
                // 3 sec timeout for undefined protocol
                timeout.LowPart = (ULONG)
                    (-30 * 1000 * 1000);    
                break;

            case SCARD_PROTOCOL_T0:
                // For t=0 protocol we must set the timeout to a very large time.  This
                // is becuase the card could ask for more time, but the reader must pay
                // keep paying attention to the card so it can not tell us that more time
                // is needed.  Therefore we must trust the readers timeout, and trust that
                // it will NACK us if there is a problem.
                timeout.LowPart = (-10 * 1000 * 1000 * 100) +  // Timeout 100 seconds
                    (-10) * SmartcardExtension->CardCapabilities.T0.WT;
                break;

            case SCARD_PROTOCOL_T1:
                          
                timeout.LowPart = 
                    SmartcardExtension->CardCapabilities.T1.BWT * 
                    (SmartcardExtension->T1.Wtx ? SmartcardExtension->T1.Wtx : 1);

                timeout.LowPart += SmartcardExtension->CardCapabilities.T1.CWT * 
                    SmartcardExtension->SmartcardReply.BufferLength;

                // Add a little extra time for reader to respond to the PC
                timeout.LowPart += 100 * 1000;

                // Convert timeout to NS
                timeout.LowPart *= -10;


                break;
        }

        ASSERT(timeout.LowPart != 0);




        //
        // Always for the ACK
        //
        status = KeWaitForSingleObject(
            &readerExtension->AckEvnt,
            Executive,
            KernelMode,
            FALSE,
            &timeout
            );

        // Did we actually get a nack instead of an ACK
        if (readerExtension->GotNack) {
            status = Lit220GetReaderError(SmartcardExtension); 
            // GetReaderError will clear this flag, but I need to
            // preserve the fact that I got nacked so I must reset it.
            readerExtension->GotNack = TRUE; 
        }

        //
        // Wait for the Data if requested
        //
        if ((localWaitMask & WAIT_DATA) && (status == STATUS_SUCCESS)) {

            // Wait for signal the data is ready (at least until we timeout)
            status = KeWaitForSingleObject(
                &readerExtension->DataEvnt,
                Executive,
                KernelMode,
                FALSE,
                &timeout
                );

            // Did we get NACKed?
            if (readerExtension->GotNack) {
                status = Lit220GetReaderError(SmartcardExtension); 
                // GetReaderError will clear this flag, but I need to
                // preserve the fact that I got nacked so I must reset it.
                readerExtension->GotNack = TRUE; 
            }

        }


        if (status == STATUS_TIMEOUT) {

            //
            // STATUS_TIMEOUT isn't correctly mapped 
            // to a WIN32 error, that's why we change it here
            // to STATUS_IO_TIMEOUT
            //
            status = STATUS_IO_TIMEOUT;

            SmartcardDebug(
                DEBUG_ERROR,
                ("%s(Lit220Command): Operation timed-out\n",
                DRIVER_NAME)
                );
        }

        {   // Sometimes after a command the reader is not reader to accept another command
            // so we need to wait for a short period of time for the reader to be ready.  We need to
            // take this out as soon as the reader is fixed!
            LARGE_INTEGER WaitTime;

            WaitTime.HighPart = -1;
            WaitTime.LowPart = -10;  // Wait 1uS

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &WaitTime
                );
        }

        // If we failed because the reader did not give us any response resend the command.
        // The reader should respond.
        if ((status != STATUS_SUCCESS) && (!readerExtension->GotNack)) {
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s(Lit220Command): Reader failed to respond!  Retrying once more.\n",
                DRIVER_NAME)
                );
        } else {
            break;
        }            


    } while (retry++ <= 2);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Command: Exit - status %X\n",
        DRIVER_NAME, 
        status)
        );

    return status;
}


NTSTATUS
Lit220SetProtocol(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
    
/*++

Routine Description:

    This function sends a set mode command to the reader set the 
    protocol and the parameters for the wait protocol.


Arguments:

    SmartcardExtension - Pointer to the smart card data struct


// Parameters are up to seven bytes as follows:
//
//  Flags -  Flags to indicate the presence or absence of the other parameters.
//    SETMODE_PROTOCOL, b0 - 1 if Protocol is present.
//    SETMODE_GT,       b1 - 1 if GuardTime is present.
//    SETMODE_WI,       b2 - 1 if WorkWaitTime is present.
//    SETMODE_BWI,      b3 - 1 if BWI/CWI is present.
//    SETMODE_WTX,      b4 - 1 if BlockWaitTimeExtension is present.
//    SETMODE_FI_DI,    b5 - 1 if BaudRate is present.
//
//  Protocol - possible values 00, 02, 10, 11, 12, 13
//    encodes T, C, CKS from the ATR
//    Use of this parameter may invoke a PTS request to the smartcard.
//    b4 - Protocol Type  (0 for T=0, 1 for T=1)
//    b3 - 0
//    b2 - 1 for convert 6A to 6A 00 and FA to 6A 01 on output to PS/2.
//    b1 - 0 ( use to be Convention used (0 for direct, 1 for inverse))
//    b0 - Checksum type  (0 for LRC, 1 for CRC)
//
//  GuardTime - possible values 00 to FE (0 to 254 etu between two characters)
//    encodes N (Extra Guardtime) from ATR
//
//  WorkWaitTime - possible values 00 to FF
//    encodes WI which is Work Waiting Time (character time-out for T=0)

//
//  BWI/CWI - possible values 00 to FF
//    encodes BWI and CWI which are the Block and Char Wait Time
//    (block and character time-out for T=1)
//
//  BlockWaitTimeExtension - possible values 00 to FF
//    encodes WTX which is the Block Waiting Time Extension.
//    00 = no WTX is requested by the ICC.
//    vv is the multiplier of the BWT value
//
//  BaudRate - possible values 00 to FF
//    encodes FI and DI in the same fashion as TA1 does.
//    FI is in the high nibble. DI is in the low nibble.
//    D and F can be looked up in a table in PC/SC part 2 sec. 4.4.3.
//    Use of this parameter may invoke a PTS request to the smartcard.

Return Value:

    NTSTATUS

--*/
{
    PSMARTCARD_REQUEST smartcardRequest = &SmartcardExtension->SmartcardRequest;
    NTSTATUS status;
    DWORD bufLen = 0;
    PCHAR flags;
    PCHAR protoByte;
    KIRQL irql;

    RtlZeroMemory(
        smartcardRequest->Buffer,
        8
        );
    
    // Send a set mode command to the reader
    smartcardRequest->Buffer[bufLen++] = LIT220_READER_ATTENTION;
    smartcardRequest->Buffer[bufLen++] = LIT220_READER_ATTENTION;
    smartcardRequest->Buffer[bufLen++] = LIT220_SET_MODE;
    flags = &smartcardRequest->Buffer[bufLen++];
    *flags = 0;

    // Set the protocol
    protoByte = &smartcardRequest->Buffer[bufLen++];
    *protoByte = 0; 
    *flags |= SETMODE_PROTOCOL;
        
    // Set the inverse convention bit
    if (SmartcardExtension->CardCapabilities.InversConvention) {
        // Set the bit in the protocol paramter
        *protoByte |= LIT220_READER_CONVENTION_INVERSE;
    }
    
    //
    // test if caller wants to have T=0 or T=1
    //
    if ((SmartcardExtension->MinorIoControlCode & SCARD_PROTOCOL_T1) &&
        (SmartcardExtension->CardCapabilities.Protocol.Supported & SCARD_PROTOCOL_T1)){
        
        SmartcardExtension->CardCapabilities.Protocol.Selected = 
            SCARD_PROTOCOL_T1;
        
        // Setup set mode command with T=1 parameters for protocol
        *protoByte |= LIT220_READER_PROTOCOL_T1;

        if (SmartcardExtension->CardCapabilities.T1.EDC & T1_CRC_CHECK) {

            *protoByte |= LIT220_READER_CHECK_CRC;
        }            
    
        // Set the guard time
        *flags |= SETMODE_GT;
        smartcardRequest->Buffer[bufLen++] = 
            SmartcardExtension->CardCapabilities.N; 
                
        // Set BWI and CWI
        *flags |= SETMODE_BWI;
        smartcardRequest->Buffer[bufLen++] = 
            (SmartcardExtension->CardCapabilities.T1.BWI << 4) |
            (SmartcardExtension->CardCapabilities.T1.CWI);

    }
    else if ((SmartcardExtension->MinorIoControlCode & SCARD_PROTOCOL_T0) &&
        (SmartcardExtension->CardCapabilities.Protocol.Supported & SCARD_PROTOCOL_T0))
    {
        
        SmartcardExtension->CardCapabilities.Protocol.Selected = 
            SCARD_PROTOCOL_T0;


        // Set the guard time
        *flags |= SETMODE_GT;
        smartcardRequest->Buffer[bufLen++] = 
            SmartcardExtension->CardCapabilities.N;
            
        // Set WI
        *flags |= SETMODE_WI;
        smartcardRequest->Buffer[bufLen++] = 
            SmartcardExtension->CardCapabilities.T0.WI;

    } else {
    
        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!Lit220SetProtocol: Error invalid protocol selected\n",
            DRIVER_NAME)
            );

        SmartcardExtension->CardCapabilities.Protocol.Selected = 
            SCARD_PROTOCOL_UNDEFINED;
        
        return STATUS_INVALID_PARAMETER;
    }

           
    // Set FI & DI for baud rate
    *flags |= SETMODE_FI_DI;
    smartcardRequest->Buffer[bufLen++] = 
        (SmartcardExtension->CardCapabilities.PtsData.Fl << 4) | 
        SmartcardExtension->CardCapabilities.PtsData.Dl;


    smartcardRequest->BufferLength = bufLen;

    
    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220SetProtocol - Sending SetMode command %x bytes, %X,%X,%X,%X,%X,%X,%X,%X,%X,%X\n",
        DRIVER_NAME,
        bufLen,
        smartcardRequest->Buffer[0],
        smartcardRequest->Buffer[1],
        smartcardRequest->Buffer[2],
        smartcardRequest->Buffer[3],
        smartcardRequest->Buffer[4],
        smartcardRequest->Buffer[5],
        smartcardRequest->Buffer[6],
        smartcardRequest->Buffer[7],
        smartcardRequest->Buffer[8],
        smartcardRequest->Buffer[9]
    ));

    status =Lit220Command(
        SmartcardExtension
        );


    if (status == STATUS_SUCCESS) {
        // now indicate that we're in specific mode 
        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
        return status;
    }

    //TODO: handle rertying code without optimal setting if optimal fails
    if (SmartcardExtension->CardCapabilities.PtsData.Type !=
        PTS_TYPE_DEFAULT) {
        DWORD saveMinorCode = SmartcardExtension->MinorIoControlCode;

        SmartcardDebug(
            DEBUG_TRACE,
            ("%s!Lit220SetProtocol: PTS failed. Trying default parameters...\n",
            DRIVER_NAME,
            status)
            );
        //
        // The card did either NOT reply or it replied incorrectly
        // so try default values
        //
        SmartcardExtension->CardCapabilities.PtsData.Type = 
            PTS_TYPE_DEFAULT;

        SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;

        status = Lit220Power(SmartcardExtension);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        SmartcardExtension->MinorIoControlCode = saveMinorCode;

        return Lit220SetProtocol(SmartcardExtension);
    } 
    
    // the card failed the pts-request
    status = STATUS_DEVICE_PROTOCOL_ERROR;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220SetProtocol: Exit with error.\n",
        DRIVER_NAME)
        );

    return status;
}

NTSTATUS
Lit220Power(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This function sends an SCARD_COLD_RESET, SCARD_WARM_RESET or SCARD_POWER_DOWN
    to the reader.  For cold or warm reset we set a flag indicating that an ATR
    is expected.  Once the Lit220InputFilter receives the ATR it will update the
    card capabilites.

Arguments:

    SmartcardExtension - Pointer to the smart card data struct

Return Value:

   NTSTATUS

--*/
{
    PSMARTCARD_REQUEST smartcardRequest = &SmartcardExtension->SmartcardRequest;
    NTSTATUS status;
    KIRQL irql;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Power: Enter\n",
        DRIVER_NAME)
        );

    smartcardRequest->BufferLength = 0;


    // Make sure card is still present

    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);
    if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_ABSENT) {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
        return STATUS_DEVICE_REMOVED;
    } else {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
    }


    //
    // Since power down triggers the UpdateSerialStatus function, we have
    // to inform it that we forced the change of the status and not the user
    // (who might have removed and inserted a card)
    //
    SmartcardExtension->ReaderExtension->PowerRequest = TRUE;

    switch(SmartcardExtension->MinorIoControlCode) {

        case SCARD_COLD_RESET:
            //
            // Send a power-on, if the reader is already off
            // it will perform a cold reset turning the power off
            // the back on again.  
            //
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_READER_ATTENTION;
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_READER_ATTENTION;
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_CARD_POWER_ON;
            
            // 
            // Power-on leads to an ATR
            //    
            SmartcardExtension->ReaderExtension->WaitMask |= WAIT_DATA;
            SmartcardExtension->ReaderExtension->WaitForATR = TRUE;
            break;
        
        case SCARD_WARM_RESET:

            //
            // Send a reset to the reader (warm reset)  
            //
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_READER_ATTENTION;
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_READER_ATTENTION;
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_RESET;
                
            // 
            // Warm reset leads to an ATR
            //    
            SmartcardExtension->ReaderExtension->WaitMask |= WAIT_DATA;
            SmartcardExtension->ReaderExtension->WaitForATR = TRUE;
            break;
            
        case SCARD_POWER_DOWN:
            //
            // Send a power down to the reader 
            //
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_READER_ATTENTION;
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_READER_ATTENTION;
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_CARD_POWER_OFF;
            break;
    }

    // Send the command
    status = Lit220Command(
        SmartcardExtension
        );

    SmartcardExtension->ReaderExtension->PowerRequest = FALSE;      

    if (status == STATUS_IO_TIMEOUT) {
        status = STATUS_UNRECOGNIZED_MEDIA;
    }

    if (status == STATUS_SUCCESS) {
        if (SmartcardExtension->MinorIoControlCode == SCARD_POWER_DOWN) {
            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);
            SmartcardExtension->ReaderCapabilities.CurrentState = 
                SCARD_PRESENT;
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);                    
            SmartcardExtension->CardCapabilities.Protocol.Selected = 
                SCARD_PROTOCOL_UNDEFINED;
        }
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Power: Exit\n",
        DRIVER_NAME)
        );

    return status;
}   




NTSTATUS
Lit220IoRequest(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:
    The routine handles IO request from the smartcard library.
    It sends the command to card and processes the reply.
    It may also be called from Lit220IoReply is more processing is 
    required.

Arguments:

    SmartcardExtension - Pointer to the smart card data struct

Return Value:

   NTSTATUS

--*/
{
    NTSTATUS status;
    LENGTH length;
//    ULONG offset = 0;
    ULONG indx;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220IoRequest: Enter\n",
        DRIVER_NAME)
        );

    //
    // Tell the lib function how many bytes I need for the prologue
    //
    SmartcardExtension->SmartcardRequest.BufferLength = 5;

    switch (SmartcardExtension->CardCapabilities.Protocol.Selected) {

        case SCARD_PROTOCOL_RAW:
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoRequest - SCARD_PROTOCOL_RAW\n",
                DRIVER_NAME)
                );

            status = SmartcardRawRequest(
                SmartcardExtension
                );
            break;

        case SCARD_PROTOCOL_T0:
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoRequest - SCARD_PROTOCOL_T0\n",
                DRIVER_NAME)
                );

            status = SmartcardT0Request(
                SmartcardExtension
                );
            break;

        case SCARD_PROTOCOL_T1:
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoRequest - SCARD_PROTOCOL_T1\n",
                DRIVER_NAME)
                );


            status = SmartcardT1Request(
                SmartcardExtension
                );
            break;

        default:
        {
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!Lit220IoRequest: Invalid Device Request - protocol selected = %X\n",
                DRIVER_NAME,
                SmartcardExtension->CardCapabilities.Protocol.Selected)
                );

            status = STATUS_INVALID_DEVICE_REQUEST;
        }
            
    }

    if (status == STATUS_SUCCESS) {

        // Add the send block command to the front of the buffer
        SmartcardExtension->SmartcardRequest.Buffer[0] = 
            LIT220_READER_ATTENTION;
        SmartcardExtension->SmartcardRequest.Buffer[1] = 
            LIT220_READER_ATTENTION;

        SmartcardExtension->SmartcardRequest.Buffer[2] = 
            LIT220_SEND_BLOCK;

        length.l.l0 = 
            SmartcardExtension->SmartcardRequest.BufferLength - 5;

        SmartcardExtension->SmartcardRequest.Buffer[3] = 
            length.b.b1;

        SmartcardExtension->SmartcardRequest.Buffer[4] = 
            length.b.b0;
        
        // We expect data back from this command
        SmartcardExtension->ReaderExtension->WaitMask |= WAIT_DATA;

        //
        // Send the command
        //
        status = Lit220Command(
            SmartcardExtension
            );
    }
    

    if (status == STATUS_SUCCESS) {
        // Process the reply
        status = Lit220IoReply(
            SmartcardExtension
            );
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220IoRequest: Exit - status %X\n",
        DRIVER_NAME, 
        status)
        );

    return status;
}   



NTSTATUS
Lit220IoReply(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:
    Handles the reply from a smartcard command.
    If more processing is required it will call Lit220IoRequest 
    to send another command.

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    LENGTH length;
    ULONG indx;

    PAGED_CODE();

    // Check which protocol is being used so we know how to respond
    switch (SmartcardExtension->CardCapabilities.Protocol.Selected) {

        case SCARD_PROTOCOL_RAW:
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoReply:  - SCARD_PROTOCOL_RAW\n",
                DRIVER_NAME)
                );

            // Let the smartcard lib process the reply
            status = SmartcardRawReply(
                SmartcardExtension
                );
            break;

        case SCARD_PROTOCOL_T0:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoReply - SCARD_PROTOCOL_T0\n",
                DRIVER_NAME)
                );

            // The instruction seems to be tagged onto the front of the buffer
            //   the smartcard library does not seem to like this so we must shift the buffer.
            for(indx=0;indx<SmartcardExtension->SmartcardReply.BufferLength;indx++){
                SmartcardExtension->SmartcardReply.Buffer[indx] =
                    SmartcardExtension->SmartcardReply.Buffer[indx+1];
            }

            SmartcardExtension->SmartcardReply.BufferLength--;

#if DBG   // DbgPrint the buffer
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoReply - Buffer - ",
                DRIVER_NAME)
                );
            for (indx=0; indx<SmartcardExtension->SmartcardReply.BufferLength; indx++){
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%X, ",
                    SmartcardExtension->SmartcardReply.Buffer[indx])
                    );
            }
            SmartcardDebug(
                DEBUG_DRIVER,
                ("\n")
                );
#endif

            // Let the smartcard lib process the reply
            status = SmartcardT0Reply(
                SmartcardExtension
                );

            break;

        case SCARD_PROTOCOL_T1:
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoReply - SCARD_PROTOCOL_T1\n",
                DRIVER_NAME)
                );

            // Let the smartcard lib process the reply
            status = SmartcardT1Reply(
                SmartcardExtension
                );
            break;

        default:
        {
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!Lit220IoRequest: Invalid Device Request2 - protocol selected = %X\n",
                DRIVER_NAME,
                SmartcardExtension->CardCapabilities.Protocol.Selected)
                );

            return STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    // If there is more work to be done send out another IoRequest.
    // The smartcard lib should have set up the buffers for the new
    // IO operation.
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = Lit220IoRequest(
            SmartcardExtension
            );
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220IoReply: - Exit - status %X\n", 
        DRIVER_NAME, 
        status)
        );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\pscr\pscrcb.h ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrCB.h

Abstract:

	prototypes of callback handlers for pscr.xxx

Author:

	Andreas Straub

Environment:

	Win 95
	NT	4.0

Revision History:

	Andreas Straub			7/16/1997	Initial Version

--*/

#if !defined( __PSCR_CALLBACK_H__ )
#define __PSCR_CALLBACK_H__

NTSTATUS
CBCardPower(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBSetProtocol(		
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBTransmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBT0Transmit(		
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBT1Transmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBRawTransmit(		
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBCardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

VOID
CBUpdateCardState(
	PSMARTCARD_EXTENSION SmartcardExtension,
    UCHAR CardState,
    BOOLEAN SystemWakeUp
	);

UCHAR 
CBGetCardState(
	PSMARTCARD_EXTENSION SmartcardExtension
	);
#endif // __PSCR_CALLBACK_H__

//	------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\pscr\pscrcb.c ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrCB.c

Abstract:

        callback handler for PSCR.xxx driver

Author:

        Andreas Straub

Environment:

        Win 95          Sys... calls are resolved by Pscr95Wrap.asm functions and
                                Pscr95Wrap.h macros, resp.

        NT      4.0             Sys... functions resolved by PscrNTWrap.c functions and
                                PscrNTWrap.h macros, resp.

Revision History:

        Andreas Straub                  8/18/1997       1.00    Initial Version
        Andreas Straub                  9/24/1997       1.02    Flush Interface if card tracking
                                                                                                requested

--*/

#if defined( SMCLIB_VXD )

#include <Pscr95.h>

#else   //      SMCLIB_VXD

#include <PscrNT.h>

#endif  //      SMCLIB_VXD


#include <PscrRdWr.h>
#include <PscrCmd.h>
#include <PscrCB.h>


NTSTATUS
CBCardPower(
           PSMARTCARD_EXTENSION SmartcardExtension 
           )
/*++

CBCardPower:
        callback handler for SMCLIB RDF_CARD_POWER

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_TIMEOUT
        STATUS_BUFFER_TOO_SMALL

--*/
{
    NTSTATUS                        NTStatus = STATUS_SUCCESS;
    UCHAR                           ATRBuffer[ ATR_SIZE ], TLVList[16];
    ULONG                           Command,
    ATRLength;
    PREADER_EXTENSION       ReaderExtension;
    BYTE                CardState;
    KIRQL               irql;
#if DBG || DEBUG
    static PCHAR request[] = { "PowerDown",  "ColdReset", "WarmReset"};
#endif

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!CBCardPower: Enter, Request = %s\n",
                    request[SmartcardExtension->MinorIoControlCode])
                  );

    ReaderExtension = SmartcardExtension->ReaderExtension;

        //
        //      update actual power state
        //
    Command = SmartcardExtension->MinorIoControlCode;

    switch ( Command ) {
    case SCARD_WARM_RESET:

        //      if the card was not powerd, fall thru to cold reset
        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);

        if ( SmartcardExtension->ReaderCapabilities.CurrentState >
             SCARD_SWALLOWED ) {
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

                                //      reset the card
            ATRLength = ATR_SIZE;
            NTStatus = CmdReset(
                               ReaderExtension,
                               ReaderExtension->Device,
                               TRUE,                           // warm reset
                               ATRBuffer,
                               &ATRLength
                               );

            break;
        } else {
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

        }

                        //      warm reset not possible because card was not powerd
    case SCARD_COLD_RESET:

                        //      reset the card
        ATRLength = ATR_SIZE;
        NTStatus = CmdReset(
                           ReaderExtension,
                           ReaderExtension->Device,
                           FALSE,                          // cold reset
                           ATRBuffer,
                           &ATRLength
                           );
        break;

    case SCARD_POWER_DOWN:
        ATRLength = 0;
        NTStatus = CmdDeactivate(
                                ReaderExtension,
                                ReaderExtension->Device
                                );

                        //      discard old card status
        CardState = CBGetCardState(SmartcardExtension);
        CBUpdateCardState(SmartcardExtension, CardState, FALSE);
        break;
    }

    if (NT_SUCCESS(NTStatus)) {

        //
        // Set the 'restart of work waiting time' counter for T=0
        // This will send a WTX request for n NULL bytes received
        //
        TLVList[0] = TAG_SET_NULL_BYTES;
        TLVList[1] = 1;
        TLVList[2] = 0x05; 

        NTStatus = CmdSetInterfaceParameter(
                                           ReaderExtension,
                                           DEVICE_READER,
                                           TLVList,
                                           3
                                           );
    }

    ASSERT(NT_SUCCESS(NTStatus));

        //      finish the request
    if ( NT_SUCCESS( NTStatus )) {
                //      update all neccessary data if an ATR was received
        if ( ATRLength > 2 ) {
                        //
                        //      the lib expects only the ATR, so we skip the 
                        //      900x from the reader
                        //
            ATRLength -= 2;

                        //      copy ATR to user buffer buffer
            if ( ATRLength <= SmartcardExtension->IoRequest.ReplyBufferLength ) {
                SysCopyMemory(
                             SmartcardExtension->IoRequest.ReplyBuffer,
                             ATRBuffer,
                             ATRLength
                             );
                *SmartcardExtension->IoRequest.Information = ATRLength;
            } else {
                NTStatus = STATUS_BUFFER_TOO_SMALL;
            }

                        //      copy ATR to card capability buffer
            if ( ATRLength <= MAXIMUM_ATR_LENGTH ) {
                SysCopyMemory(
                             SmartcardExtension->CardCapabilities.ATR.Buffer,
                             ATRBuffer,
                             ATRLength
                             );

                SmartcardExtension->CardCapabilities.ATR.Length = 
                ( UCHAR )ATRLength;

                                //      let the lib update the card capabilities
                NTStatus = SmartcardUpdateCardCapabilities(
                                                          SmartcardExtension 
                                                          );
            } else {
                NTStatus = STATUS_BUFFER_TOO_SMALL;
            }
        }
    }

    if ( !NT_SUCCESS( NTStatus )) {
        switch ( NTStatus ) {
        case STATUS_NO_MEDIA:
        case STATUS_BUFFER_TOO_SMALL:
            break;

        case STATUS_TIMEOUT:
            NTStatus = STATUS_IO_TIMEOUT;
            break;

        default:
            NTStatus = STATUS_UNRECOGNIZED_MEDIA;
            break;
        }
    }

    SmartcardDebug(
                  DEBUG_TRACE, 
                  ( "PSCR!CBCardPower: Exit (%lx)\n", NTStatus )
                  );

    return( NTStatus );
}

NTSTATUS
CBSetProtocol(
             PSMARTCARD_EXTENSION SmartcardExtension 
             )

/*++

CBSetProtocol:
        callback handler for SMCLIB RDF_SET_PROTOCOL

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_TIMEOUT
        STATUS_BUFFER_TOO_SMALL
        STATUS_INVALID_DEVICE_STATE
        STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS NTStatus = STATUS_PENDING;
    USHORT SCLibProtocol;
    UCHAR TLVList[ TLV_BUFFER_SIZE ];
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    KIRQL irql;

    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);

    if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC) {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);


        return STATUS_SUCCESS;
    } else {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);

    }

    SmartcardDebug(
                  DEBUG_TRACE, 
                  ( "PSCR!CBSetProtocol: Enter\n" )
                  );

    SCLibProtocol = ( USHORT )( SmartcardExtension->MinorIoControlCode );

    if (SCLibProtocol & (SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1)) {
                //
                //      setup the TLV list for the Set Interface Parameter List
                //
        TLVList[ 0 ] = TAG_ICC_PROTOCOLS;
        TLVList[ 1 ] = 0x01;
        TLVList[ 2 ] = 
        (SCLibProtocol & SCARD_PROTOCOL_T1 ? PSCR_PROTOCOL_T1 : PSCR_PROTOCOL_T0);

                //      do the PTS
        NTStatus = CmdSetInterfaceParameter(
                                           ReaderExtension,
                                           ReaderExtension->Device,
                                           TLVList,
                                           3                       // size of list
                                           );              

    } else {

                //      we don't support other modi
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
    }

        //      if protocol selection failed, prevent from calling invalid protocols
    if ( NT_SUCCESS( NTStatus )) {

        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
        SCLibProtocol = (SCLibProtocol & SCARD_PROTOCOL_T1 &
                         SmartcardExtension->CardCapabilities.Protocol.Supported) ?
                        SCARD_PROTOCOL_T1 :
                        SCARD_PROTOCOL_T0;

        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
    } else {
        SCLibProtocol = SCARD_PROTOCOL_UNDEFINED;
    }

        //      Return the selected protocol to the caller.
    SmartcardExtension->CardCapabilities.Protocol.Selected = SCLibProtocol;
    *( PULONG )( SmartcardExtension->IoRequest.ReplyBuffer ) = SCLibProtocol;
    *( SmartcardExtension->IoRequest.Information ) = sizeof( ULONG );

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!CBSetProtocol: Exit (%lx)\n", NTStatus )
                  );

    return( NTStatus );
}

NTSTATUS
CBTransmit(
          PSMARTCARD_EXTENSION SmartcardExtension 
          )
/*++

CBTransmit:
        callback handler for SMCLIB RDF_TRANSMIT

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_TIMEOUT
        STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS  NTStatus = STATUS_SUCCESS;

    SmartcardDebug(
                  DEBUG_TRACE, 
                  ( "PSCR!CBTransmit: Enter\n" )
                  );

        //      dispatch on the selected protocol
    switch ( SmartcardExtension->CardCapabilities.Protocol.Selected ) {
    case SCARD_PROTOCOL_T0:
        NTStatus = CBT0Transmit( SmartcardExtension );
        break;

    case SCARD_PROTOCOL_T1:
        NTStatus = CBT1Transmit( SmartcardExtension );
        break;

    case SCARD_PROTOCOL_RAW:
        NTStatus = CBRawTransmit( SmartcardExtension );
        break;

    default:
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    SmartcardDebug(
                  DEBUG_TRACE, 
                  ( "PSCR!CBTransmit: Exit (%lx)\n", NTStatus )
                  );

    return( NTStatus );
}

NTSTATUS
CBRawTransmit(
             PSMARTCARD_EXTENSION SmartcardExtension 
             )
/*++

CBRawTransmit:
        finishes the callback RDF_TRANSMIT for the RAW protocol

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_TIMEOUT
        STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS                    NTStatus = STATUS_SUCCESS;
    UCHAR                           TLVList[ TLV_BUFFER_SIZE ],
    Val,
    Len;
    ULONG                           TLVListLen;
    PREADER_EXTENSION       ReaderExtension;

    SmartcardDebug(
                  DEBUG_TRACE, 
                  ( "PSCR!CBRawTransmit: Enter\n" )
                  );

    ReaderExtension = SmartcardExtension->ReaderExtension;
        //
        //      read the status file of ICC1 from the reader
        //
    TLVListLen = TLV_BUFFER_SIZE;
    NTStatus = CmdReadStatusFile(
                                ReaderExtension,
                                ReaderExtension->Device,
                                TLVList,
                                &TLVListLen
                                );

        //
        //      check the active protocol of the reader
        //
    if ( NT_SUCCESS( NTStatus )) {
        Len = sizeof(Val);
        NTStatus = CmdGetTagValue(
                                 TAG_ICC_PROTOCOLS,
                                 TLVList,
                                 TLVListLen,
                                 &Len,
                                 ( PVOID ) &Val
                                 );

                //      execute the active protocol
        if ( NT_SUCCESS( NTStatus )) {

                        //      translate the actual protocol to a value the lib can understand
            switch ( Val ) {
            case PSCR_PROTOCOL_T0:
                NTStatus = CBT0Transmit( SmartcardExtension );
                break;
            case PSCR_PROTOCOL_T1:
                NTStatus = CBT1Transmit( SmartcardExtension );
                break;
            default:
                NTStatus = STATUS_UNSUCCESSFUL;
                break;
            }
        }
    }
    SmartcardDebug(
                  DEBUG_TRACE, 
                  ( "PSCR!CBRawTransmit: Exit (%lx)\n", NTStatus )
                  );
    return( NTStatus );
}

NTSTATUS
CBT1Transmit(
            PSMARTCARD_EXTENSION SmartcardExtension 
            )
/*++

CBT1Transmit:
        finishes the callback RDF_TRANSMIT for the T1 protocol

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_TIMEOUT
        STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS    NTStatus = STATUS_SUCCESS;
    ULONG           IOBytes;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!CBT1Transmit: Enter\n" )
                  );
        //
        //      use the lib support to construct the T=1 packets
        //
    do {
                //
                //      no header for the T=1 protocol
                //
        SmartcardExtension->SmartcardRequest.BufferLength = 0;
                //
                //      SCM-TM: Siemens 4440 accepts only NAD=0!!!
                //
        SmartcardExtension->T1.NAD = 0;
                //
                //      let the lib setup the T=1 APDU & check for errors
                //
        NTStatus = SmartcardT1Request( SmartcardExtension );
        if ( NT_SUCCESS( NTStatus )) {

                        //      send command (don't calculate LRC because CRC may be used!)
            IOBytes = 0;
            NTStatus = PscrWriteDirect(
                                      SmartcardExtension->ReaderExtension,
                                      SmartcardExtension->SmartcardRequest.Buffer,
                                      SmartcardExtension->SmartcardRequest.BufferLength,
                                      &IOBytes
                                      );
                        //
                        //      extend the timeout if a Wtx request was sent by the card. if the 
                        //      card responds before the waiting time extension expires, the data are
                        //      buffered in the reader. A delay without polling the reader status
                        //      slows down the performance of the driver, but wtx is an exeption,
                        //      not the rule.
                        //
            if (SmartcardExtension->T1.Wtx) {
                SysDelay(
                        (( SmartcardExtension->T1.Wtx * 
                           SmartcardExtension->CardCapabilities.T1.BWT + 999L )/
                         1000L) 
                        );

            }

                        //      get response
            SmartcardExtension->SmartcardReply.BufferLength = 0;
            NTStatus = PscrRead(
                               SmartcardExtension->ReaderExtension,
                               SmartcardExtension->SmartcardReply.Buffer,
                               MAX_T1_BLOCK_SIZE,
                               &SmartcardExtension->SmartcardReply.BufferLength
                               );

                        //      if PscrRead detects an LRC error, ignore it (maybe CRC used)
            if ( NTStatus == STATUS_CRC_ERROR ) {
                NTStatus = STATUS_SUCCESS;
            }

            //
            // We even continue if the prev. read failed.
            // We let the smart card library continue, because it might
            // send a resynch. request in case of a timeout
            //
            NTStatus = SmartcardT1Reply( SmartcardExtension );
        }

        //      continue if the lib wants to send the next packet
    } while ( NTStatus == STATUS_MORE_PROCESSING_REQUIRED );

    SmartcardDebug(
                  DEBUG_TRACE, 
                  ( "PSCR!CBT1Transmit: Exit (%lx)\n", NTStatus )
                  );

    return( NTStatus );
}

NTSTATUS
CBT0Transmit(
            PSMARTCARD_EXTENSION SmartcardExtension 
            )
/*++

CBT0Transmit:
        finishes the callback RDF_TRANSMIT for the T0 protocol

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_TIMEOUT
        STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    PUCHAR pRequest,pReply;
    ULONG IOBytes, APDULength, RequestLength;
    UCHAR IOData[ MAX_T1_BLOCK_SIZE ];
    UCHAR WtxReply[16];

    SmartcardDebug(
                  DEBUG_TRACE, 
                  ( "PSCR!CBT0Transmit: Enter\n" )
                  );

    pRequest        = SmartcardExtension->SmartcardRequest.Buffer;
    pReply          = SmartcardExtension->SmartcardReply.Buffer;

        //      setup the command header
    pRequest[ PSCR_NAD ] = 
    ( SmartcardExtension->ReaderExtension->Device == DEVICE_ICC1 ) ? 
    NAD_TO_ICC1 : NAD_TO_ICC1;

    pRequest[ PSCR_PCB ] = PCB_DEFAULT;
        //
        //      get the length of the user data packet & set the appropriate LEN
        //      information the complete user packet consists of a SCARD_IO_REQUEST
        //      structure followed by the APDU. the length of SCARD_IO_REQUEST is
        //      transferred in the member cbPciLength of the structure
        //
    APDULength = SmartcardExtension->IoRequest.RequestBufferLength;
    APDULength -= ((PSCARD_IO_REQUEST) SmartcardExtension->
                   IoRequest.RequestBuffer)->cbPciLength;
        //
        //      a 4 byte APDU will be patched to a 5 byte TPDU by the lib; see
        //      annex of the ISO
        //
    if ( APDULength == 4 ) APDULength++;
        //
        //      if the total length of the T1 (reader) packet is larger than 0xFF
        //      the extended length notation will be used
        //
    if ( APDULength >= 0xFF ) {
        pRequest[ PSCR_LEN ]    = 0xFF;
        pRequest[ PSCR_LEN+1 ]  = HIBYTE( APDULength );
        pRequest[ PSCR_LEN+2 ]  = LOBYTE( APDULength );
        SmartcardExtension->SmartcardRequest.BufferLength =
        PSCR_EXT_PROLOGUE_LENGTH;
    } else {
        pRequest[ PSCR_LEN ] = ( UCHAR ) APDULength;
        SmartcardExtension->SmartcardRequest.BufferLength = 
        PSCR_PROLOGUE_LENGTH;
    }

        //      let the lib setup the T=1 APDU & check for errors
    NTStatus = SmartcardT0Request( SmartcardExtension );
    RequestLength = SmartcardExtension->SmartcardRequest.BufferLength;

    while ( NT_SUCCESS( NTStatus )) {
                //      send command
        IOBytes = 0;
        NTStatus = PscrWrite(
                            SmartcardExtension->ReaderExtension,
                            pRequest,
                            RequestLength,
                            &IOBytes
                            );

                //      get response
        if ( NT_SUCCESS( NTStatus )) {
            IOBytes = 0;
            NTStatus = PscrRead(
                               SmartcardExtension->ReaderExtension,
                               IOData,
                               MAX_T1_BLOCK_SIZE,
                               &IOBytes
                               );

                        //      extract APDU from T=1 transport packet
            if ( NT_SUCCESS( NTStatus )) {

                if (IOBytes < 4) {

                    NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
                    break;

                }
                if (IOData[ PSCR_PCB ] == WTX_REQUEST) {

                    WtxReply[PSCR_NAD] = NAD_TO_PSCR;
                    WtxReply[PSCR_PCB] = WTX_REPLY;
                    WtxReply[PSCR_LEN] = 1;
                    WtxReply[PSCR_INF] = IOData[PSCR_INF];

                    RequestLength = 4;
                    pRequest = WtxReply;
                    continue;
                }

                if ( IOData[ PSCR_LEN ] == 0xFF ) {
                                        //
                                        //      extended length byte used
                                        //
                    APDULength  = IOData[ PSCR_LEN + 1 ] << 8;
                    APDULength += IOData[ PSCR_LEN + 2 ];

                    SmartcardExtension->SmartcardReply.BufferLength = APDULength ;
                    SysCopyMemory( pReply, &IOData[ PSCR_APDU + 2 ], APDULength );
                } else {

                    if ((IOData[PSCR_LEN] > SmartcardExtension->SmartcardReply.BufferSize) ||
                        (IOData[PSCR_LEN] > MAX_T1_BLOCK_SIZE + PSCR_APDU)) {
                        NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
                        break;
                    }
                    SmartcardExtension->SmartcardReply.BufferLength = 
                    IOData[ PSCR_LEN ];

                    SysCopyMemory(
                                 pReply, 
                                 &IOData[ PSCR_APDU ], 
                                 IOData[ PSCR_LEN ] 
                                 );
                }

                                // let the lib evaluate the result & tansfer the data
                NTStatus = SmartcardT0Reply( SmartcardExtension );
                break;
            }
        }
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!CBT0Transmit: Exit (%lx)\n", NTStatus )
                  );

    return( NTStatus );
}

NTSTATUS
CBCardTracking(
              PSMARTCARD_EXTENSION SmartcardExtension 
              )
/*++

CBCardTracking:
        callback handler for SMCLIB RDF_CARD_TRACKING. the requested event was 
        validated by the smclib (i.e. a card removal request will only be passed 
        if a card is present).
        for a win95 build STATUS_PENDING will be returned without any other action. 
        for NT the cancel routine for the irp will be set to the drivers cancel
        routine.

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_PENDING

--*/
{
    KIRQL CancelIrql;

    SmartcardDebug(
                  DEBUG_TRACE, 
                  ( "PSCR!CBCardTracking: Enter\n" )
                  );

        //      set cancel routine
    IoAcquireCancelSpinLock( &CancelIrql );

    IoSetCancelRoutine(
                      SmartcardExtension->OsData->NotificationIrp, 
                      PscrCancel
                      );

    IoReleaseCancelSpinLock( CancelIrql );

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!CBCardTracking: Exit \n" )
                  );

    return( STATUS_PENDING );
}

VOID
CBUpdateCardState(
                 PSMARTCARD_EXTENSION SmartcardExtension,
                 UCHAR IccState,
                 BOOLEAN SystemWakeUp
                 )
{
    ULONG oldState;
    KIRQL currentIrql, irql;

    KeAcquireSpinLock(
                     &SmartcardExtension->OsData->SpinLock,
                     &irql
                     );

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!CBUpdateCardState: Enter \n" )
                  );

    oldState = 
    (SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT ?
     SCARD_PRESENT : SCARD_ABSENT);

    SmartcardExtension->ReaderCapabilities.CurrentState = 
    (IccState == PSCR_ICC_PRESENT ? SCARD_PRESENT : SCARD_ABSENT);

    SmartcardDebug(
                  DEBUG_DRIVER, 
                  ( "PSCR!CBUpdateCardState: Smart card %s\n",
                    IccState == PSCR_ICC_PRESENT ? "inserted" : "removed")
                  );

    IoAcquireCancelSpinLock( &currentIrql );

    if ( SmartcardExtension->OsData->NotificationIrp != NULL && 
         (SystemWakeUp && 
          (oldState == SCARD_PRESENT ||
           SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_PRESENT) || 
          SmartcardExtension->ReaderCapabilities.CurrentState != oldState)) {

        PIRP notificationIrp = InterlockedExchangePointer(
                                                         &(SmartcardExtension->OsData->NotificationIrp),
                                                         NULL
                                                         );

        IoSetCancelRoutine(
                          notificationIrp, 
                          NULL 
                          );

        IoReleaseCancelSpinLock( currentIrql );

        if (notificationIrp->Cancel == FALSE) {

                    //  finish the request
            notificationIrp->IoStatus.Status    = STATUS_SUCCESS;
            notificationIrp->IoStatus.Information = 0;

            SmartcardDebug(
                          DEBUG_DRIVER, 
                          ( "PSCR!CBUpdateCardState: Completing Irp %lx\n",
                            notificationIrp)
                          );

            IoCompleteRequest(notificationIrp, IO_NO_INCREMENT );
        }

    } else {

        IoReleaseCancelSpinLock( currentIrql );
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!CBUpdateCardState: Exit \n" )
                  );

    KeReleaseSpinLock(
                     &SmartcardExtension->OsData->SpinLock,
                     irql
                     );
}

UCHAR 
CBGetCardState(
              PSMARTCARD_EXTENSION SmartcardExtension 
              )
/*++

CBUpdateCardState:
        updates the variable CurrentState in SmartcardExtension

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS

--*/
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    UCHAR TLVList[ TLV_BUFFER_SIZE ],       Val, Len;
    ULONG TLVListLen;
    PREADER_EXTENSION       ReaderExtension = SmartcardExtension->ReaderExtension;

        //      read the status file of ICC1 from the reader
    TLVListLen = TLV_BUFFER_SIZE;

    if ( NT_SUCCESS( CmdReadStatusFile(
                                      ReaderExtension,
                                      ReaderExtension->Device,
                                      TLVList,
                                      &TLVListLen
                                      ))) {

                //      get reader status value
        Len = sizeof(Val);
        CmdGetTagValue(
                      TAG_READER_STATUS,
                      TLVList,
                      TLVListLen,
                      &Len,
                      ( PVOID ) &Val
                      );
    } else {
                //      IO-error is interpreted as card absent
        Val = PSCR_ICC_ABSENT;
    }

    return Val;
}

//      -------------------------------- END OF FILE ------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\lit220\l220scr.c ===
/*++

    Copyright (C) Microsoft Corporation and Litronic, 1998 - 1999

Module Name:

    L220SCR.c - Main module for Driver

Abstract:

    Author:
        Brian Manahan

Environment:

    Kernel mode

Revision History :

--*/

#include <stdio.h>
#include "L220SCR.h"

// Make functions pageable
#pragma alloc_text(PAGEABLE, Lit220IsCardPresent)
#pragma alloc_text(PAGEABLE, Lit220ConfigureSerialPort)
#pragma alloc_text(PAGEABLE, Lit220CreateClose)
#pragma alloc_text(PAGEABLE, Lit220Unload)
#pragma alloc_text(PAGEABLE, Lit220InitializeInputFilter)


#if DBG
#pragma optimize ("", off)
#endif


BOOLEAN
Lit220IsCardPresent(
      IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine checks if a card is in the socket.  It is only done
    when the driver starts to set the intial state.  After that the
    reader will tell us when the status changes.
    It makes synchronous calls to the serial port.

--*/
{
    PSMARTCARD_REQUEST smartcardRequest = &SmartcardExtension->SmartcardRequest;
    NTSTATUS status;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220IsCardPresent: Enter\n",
        DRIVER_NAME)
        );

    smartcardRequest->BufferLength = 0;

    //
    // Send a get reader status to see if a card is inserted
    //
    smartcardRequest->Buffer[smartcardRequest->BufferLength++] =
        LIT220_READER_ATTENTION;
    smartcardRequest->Buffer[smartcardRequest->BufferLength++] =
        LIT220_READER_ATTENTION;
    smartcardRequest->Buffer[smartcardRequest->BufferLength++] =
        LIT220_GET_READER_STATUS;

    //
    // We Expect to get a response
    //
    SmartcardExtension->ReaderExtension->WaitMask |= WAIT_DATA;

    // Send the command
    status = Lit220Command(
        SmartcardExtension
        );

    if (status != STATUS_SUCCESS) {
        return FALSE;
    }

    // Check if length is correct
    if (SmartcardExtension->SmartcardReply.BufferLength != LIT220_READER_STATUS_LEN) {
        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!Lit220IsCardPresent: Reader response - bufLen %X, should be %X\n",
            DRIVER_NAME,
            SmartcardExtension->SmartcardReply.BufferLength,
            LIT220_READER_STATUS_LEN)
            );

        return FALSE;
    }

    // Check status byte to see if card is inserted
    if (SmartcardExtension->SmartcardReply.Buffer[0] & LIT220_STATUS_CARD_INSERTED) {
        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!Lit220IsCardPresent: Card is inserted\n",
            DRIVER_NAME)
            );

        return TRUE;
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220IsCardPresent: Card is not inserted\n",
        DRIVER_NAME)
        );

    return FALSE;
}





NTSTATUS
Lit220Initialize(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )

/*++

Routine Description:

    This routine initializes the reader for use.
    It sets up the serial communications, checks to make sure our
    reader is attached, checks if a card is inserted or not and
    sets up the input filter for receiving bytes from the reader
    asynchronously.

--*/

{
    PREADER_EXTENSION readerExtension;
    NTSTATUS status;
    KIRQL irql;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Initialize: Enter - SmartcardExtension %X\n",
        DRIVER_NAME,
        SmartcardExtension)
        );

    readerExtension = SmartcardExtension->ReaderExtension;



    //
    // Set the serial config data
    //

    // We always talk to the  at 57600 no matter what speed the reader talks to the card
    readerExtension->SerialConfigData.BaudRate.BaudRate = 57600;
    readerExtension->SerialConfigData.LineControl.StopBits = STOP_BITS_2;
    readerExtension->SerialConfigData.LineControl.Parity = EVEN_PARITY;
    readerExtension->SerialConfigData.LineControl.WordLength = SERIAL_DATABITS_8;

    //
    // set timeouts
    //
    readerExtension->SerialConfigData.Timeouts.ReadIntervalTimeout = 10;
    readerExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = 1;
    readerExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier = 1;

    //
    // set special characters
    //
    readerExtension->SerialConfigData.SerialChars.ErrorChar = 0;
    readerExtension->SerialConfigData.SerialChars.EofChar = 0;
    readerExtension->SerialConfigData.SerialChars.EventChar = 0;
    readerExtension->SerialConfigData.SerialChars.XonChar = 0;
    readerExtension->SerialConfigData.SerialChars.XoffChar = 0;
    readerExtension->SerialConfigData.SerialChars.BreakChar = 0xFF;

    //
    // Set handflow
    //
    readerExtension->SerialConfigData.HandFlow.XonLimit = 0;
    readerExtension->SerialConfigData.HandFlow.XoffLimit = 0;
    readerExtension->SerialConfigData.HandFlow.FlowReplace = SERIAL_XOFF_CONTINUE ;
    readerExtension->SerialConfigData.HandFlow.ControlHandShake = 0;

    //
    // Now setup default the card state
    //
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);
    SmartcardExtension->ReaderCapabilities.CurrentState = (ULONG) SCARD_UNKNOWN;
    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                      irql);

    //
    // Set the MechProperties
    //
    SmartcardExtension->ReaderCapabilities.MechProperties = 0;

    try {

        //
        // Configure the serial port
        //
        status = Lit220ConfigureSerialPort(
            SmartcardExtension
            );

        if (status != STATUS_SUCCESS) {

            SmartcardLogError(
                SmartcardExtension->OsData->DeviceObject,
                LIT220_SERIAL_COMUNICATION_FAILURE,
                NULL,
                0
                );

            SmartcardDebug(DEBUG_ERROR,
                ("%s!Lit220Initialize: ConfiguringSerialPort failed %X\n",
                DRIVER_NAME,
                status)
                );
            leave;
        }


        //
        // Initailize the input filter now
        //
        status = Lit220InitializeInputFilter(
            SmartcardExtension
            );

        if (status != STATUS_SUCCESS) {

            SmartcardLogError(
                SmartcardExtension->OsData->DeviceObject,
                LIT220_SERIAL_COMUNICATION_FAILURE,
                NULL,
                0
                );

            SmartcardDebug(DEBUG_ERROR,
                ("%s!Lit220Initialize: Lit220InitializeInputFilter failed %X\n",
                DRIVER_NAME, status)
                );
            leave;
        }


        //
        // Now check if the card is inserted
        //
        if (Lit220IsCardPresent(SmartcardExtension)) {


            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);            
            // Card is inserted
            SmartcardExtension->ReaderCapabilities.CurrentState =
                SCARD_SWALLOWED;

            SmartcardExtension->CardCapabilities.Protocol.Selected =
                SCARD_PROTOCOL_UNDEFINED;

            SmartcardExtension->ReaderExtension->CardIn = TRUE;
        } else {
            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);

            // Card is not inserted
            SmartcardExtension->ReaderCapabilities.CurrentState =
                SCARD_ABSENT;

            SmartcardExtension->CardCapabilities.Protocol.Selected =
                SCARD_PROTOCOL_UNDEFINED;

            SmartcardExtension->ReaderExtension->CardIn = FALSE;
        }

        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
    }
    finally
    {

        SmartcardDebug(DEBUG_TRACE,
            ("%s!Lit220Initialize: Exit - status %X\n",
            DRIVER_NAME, status)
            );
    }
    return status;
}


NTSTATUS
Lit220ConfigureSerialPort(
    PSMARTCARD_EXTENSION SmartcardExtension
    )

/*++

Routine Description:

    This routine will appropriately configure the serial port.
    It makes synchronous calls to the serial port.

Arguments:

    SmartcardExtension - Pointer to smart card struct

Return Value:

    NTSTATUS

--*/

{
    PSERIAL_READER_CONFIG configData = &SmartcardExtension->ReaderExtension->SerialConfigData;
    NTSTATUS status = STATUS_SUCCESS;
    LARGE_INTEGER WaitTime;
    PSERIALPERF_STATS perfData;
    USHORT indx;
    PUCHAR request = SmartcardExtension->SmartcardRequest.Buffer;

    PAGED_CODE();

    SmartcardExtension->SmartcardRequest.BufferLength = 0;
    SmartcardExtension->SmartcardReply.BufferLength =
        SmartcardExtension->SmartcardReply.BufferSize;

    for (indx = 0; NT_SUCCESS(status); indx++) {

        switch (indx) {

            case 0:
                //
                // Set up baudrate for the Lit220 reader
                //
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_BAUD_RATE;

                SmartcardExtension->SmartcardRequest.Buffer =
                    (PUCHAR) &configData->BaudRate;

                SmartcardExtension->SmartcardRequest.BufferLength =
                    sizeof(SERIAL_BAUD_RATE);
                break;

            case 1:
                //
                // Set up line control parameters
                //
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_LINE_CONTROL;

                SmartcardExtension->SmartcardRequest.Buffer =
                    (PUCHAR) &configData->LineControl;

                SmartcardExtension->SmartcardRequest.BufferLength =
                    sizeof(SERIAL_LINE_CONTROL);
                break;

            case 2:
                //
                // Set serial special characters
                //
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_CHARS;

                SmartcardExtension->SmartcardRequest.Buffer =
                    (PUCHAR) &configData->SerialChars;

                SmartcardExtension->SmartcardRequest.BufferLength =
                    sizeof(SERIAL_CHARS);
                break;

            case 3:
                //
                // Set up timeouts
                //
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_TIMEOUTS;

                SmartcardExtension->SmartcardRequest.Buffer =
                    (PUCHAR) &configData->Timeouts;

                SmartcardExtension->SmartcardRequest.BufferLength =
                    sizeof(SERIAL_TIMEOUTS);
                break;

            case 4:
                //
                // Set flowcontrol and handshaking
                //
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_HANDFLOW;

                SmartcardExtension->SmartcardRequest.Buffer =
                    (PUCHAR) &configData->HandFlow;

                SmartcardExtension->SmartcardRequest.BufferLength =
                    sizeof(SERIAL_HANDFLOW);
                break;

            case 5:
                //
                // Set break off
                //
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_BREAK_OFF;
                break;

            case 6:
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_DTR;
                break;

            case 7:
                // 500ms delay before we send the next command
                // To give the reader a chance to calm down after we started it.
                WaitTime.HighPart = -1;
                WaitTime.LowPart = -500 * 10000;

                KeDelayExecutionThread(
                    KernelMode,
                    FALSE,
                    &WaitTime
                    );

                // Clear possible error condition with the serial port
                perfData =
                    (PSERIALPERF_STATS) SmartcardExtension->SmartcardReply.Buffer;

                // we have to call GetCommStatus to reset the error condition
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_GET_COMMSTATUS;
                SmartcardExtension->SmartcardRequest.BufferLength = 0;
                SmartcardExtension->SmartcardReply.BufferLength =
                    sizeof(SERIAL_STATUS);
                break;

            case 8:
                return STATUS_SUCCESS;
        }

        // Send the command to the serial driver
        status = Lit220SerialIo(SmartcardExtension);

        //
        // restore pointer to original request buffer
        //
        SmartcardExtension->SmartcardRequest.Buffer = request;
    }

    return status;
}


NTSTATUS
Lit220CreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when the device is opened or closed.

Arguments:

    DeviceObject    - Pointer to device object for this miniport
    Irp             - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    if (irpStack->MajorFunction == IRP_MJ_CREATE) {

        status = SmartcardAcquireRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );

        if (status != STATUS_SUCCESS) {

            status = STATUS_DEVICE_REMOVED;             

        } else {

            // test if the device has been opened already
            if (InterlockedCompareExchange(
                &deviceExtension->ReaderOpen,
                TRUE,
                FALSE) == FALSE) {

                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220CreateClose: Open\n",
                    DRIVER_NAME)
                    );

            } else {
                
                // the device is already in use
                status = STATUS_UNSUCCESSFUL;

                // release the lock
                SmartcardReleaseRemoveLockWithTag(
                    &deviceExtension->SmartcardExtension,
                    'lCrC'
                    );
            }

        }

    } else {

        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!Lit220CreateClose: Close\n",
            DRIVER_NAME)
            );

        SmartcardReleaseRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );

        deviceExtension->ReaderOpen = FALSE;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;  
}




NTSTATUS
Lit220Cancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject    - Pointer to device object for this miniport
    Irp             - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Cancel: Enter\n",
        DRIVER_NAME)
        );

    ASSERT(Irp == smartcardExtension->OsData->NotificationIrp);

    IoReleaseCancelSpinLock(
        Irp->CancelIrql
        );

    Lit220CompleteCardTracking(
        smartcardExtension
        );

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Cancel: Exit\n",
        DRIVER_NAME)
        );

    return STATUS_CANCELLED;
}




NTSTATUS
Lit220Cleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when the calling thread terminates
    or when the irp should be cancelled

Arguments:

    DeviceObject    - Pointer to device object for this miniport
    Irp             - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PREADER_EXTENSION ReaderExtension = smartcardExtension->ReaderExtension;
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL oldOsDataIrql;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Cleanup: Enter\n",
        DRIVER_NAME)
        );

    Lit220CompleteCardTracking(smartcardExtension);

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220Cleanup: Completing IRP %lx\n",
        DRIVER_NAME,
        Irp)
        );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(
        Irp,
        IO_NO_INCREMENT
        );

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Cleanup: Exit\n",
        DRIVER_NAME)
        );

    return STATUS_SUCCESS;
}




VOID
Lit220Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    The driver unload routine.  This is called by the I/O system
    when the device is unloaded from memory.

Arguments:

    DriverObject - Pointer to driver object created by system.

Return Value:

    STATUS_SUCCESS.

--*/
{
    PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
    NTSTATUS status;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Unload: Enter\n",
        DRIVER_NAME)
        );

    //
    // All the device objects should be gone.
    //
    ASSERT (NULL == DriverObject->DeviceObject);

    //
    // Here we free any resources allocated in DriverEntry
    //

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Unload: Exit\n",
        DRIVER_NAME)
        );
}




NTSTATUS
Lit220SerialIo(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine sends IOCTL's to the serial driver. It waits on for their
    completion, and then returns.

    Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    ULONG currentByte = 0;
    DWORD indx;
    PDEVICE_EXTENSION devExt = SmartcardExtension->OsData->DeviceObject->DeviceExtension;

    if (KeReadStateEvent(&devExt->SerialCloseDone)) {

        //
        // we have no connection to serial, fail the call
        // this could be the case if the reader was removed
        // during stand by / hibernation
        //
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Check if the buffers are large enough
    //
    ASSERT(SmartcardExtension->SmartcardReply.BufferLength <=
        SmartcardExtension->SmartcardReply.BufferSize);

    ASSERT(SmartcardExtension->SmartcardRequest.BufferLength <=
        SmartcardExtension->SmartcardRequest.BufferSize);

    if (SmartcardExtension->SmartcardReply.BufferLength >
        SmartcardExtension->SmartcardReply.BufferSize ||
        SmartcardExtension->SmartcardRequest.BufferLength >
        SmartcardExtension->SmartcardRequest.BufferSize) {

        SmartcardLogError(
            SmartcardExtension->OsData->DeviceObject,
            LIT220_BUFFER_TOO_SMALL,
            NULL,
            0
            );

        return STATUS_BUFFER_TOO_SMALL;
    }

    do {

        IO_STATUS_BLOCK ioStatus;
        KEVENT event;
        PIRP irp;
        PIO_STACK_LOCATION irpNextStack;
        PUCHAR requestBuffer = NULL;
        PUCHAR replyBuffer = SmartcardExtension->SmartcardReply.Buffer;
        ULONG requestBufferLength = 0;
        ULONG replyBufferLength = SmartcardExtension->SmartcardReply.BufferLength;

        KeInitializeEvent(
            &event,
            NotificationEvent,
            FALSE
            );

        if (SmartcardExtension->ReaderExtension->SerialIoControlCode ==
            IOCTL_SMARTCARD_220_WRITE) {

            //
            // If we write data to the smart card we only write byte by byte,
            // because we have to insert a delay between every sent byte
            //
            requestBufferLength =
                SmartcardExtension->SmartcardRequest.BufferLength;

            requestBuffer =
                SmartcardExtension->SmartcardRequest.Buffer;

#if DBG   // DbgPrint the buffer
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220SerialIo - Sending Buffer - ",
                DRIVER_NAME)
                );
            for (indx=0; indx<requestBufferLength; indx++){
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%X, ",
                    requestBuffer[indx])
                    );
            }
            SmartcardDebug(
                DEBUG_DRIVER,
                ("\n")
                );
#endif
        } else {
            
            requestBufferLength =
                SmartcardExtension->SmartcardRequest.BufferLength;

            requestBuffer =
                (requestBufferLength ?
                SmartcardExtension->SmartcardRequest.Buffer : NULL);
        }

        //
        // Build irp to be sent to serial driver
        //
        irp = IoBuildDeviceIoControlRequest(
            SmartcardExtension->ReaderExtension->SerialIoControlCode,
            SmartcardExtension->ReaderExtension->ConnectedSerialPort,
            requestBuffer,
            requestBufferLength,
            replyBuffer,
            replyBufferLength,
            FALSE,
            &event,
            &ioStatus
            );

        ASSERT(irp != NULL);

        if (irp == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        irpNextStack = IoGetNextIrpStackLocation(irp);


        switch (SmartcardExtension->ReaderExtension->SerialIoControlCode) {

            //
            // The serial driver trasfers data from/to irp->AssociatedIrp.SystemBuffer
            //
            case IOCTL_SMARTCARD_220_WRITE:
                irpNextStack->MajorFunction = IRP_MJ_WRITE;
                irpNextStack->Parameters.Write.Length =
                    SmartcardExtension->SmartcardRequest.BufferLength;
                break;

            case IOCTL_SMARTCARD_220_READ:
                irpNextStack->MajorFunction = IRP_MJ_READ;
                irpNextStack->Parameters.Read.Length =
                    SmartcardExtension->SmartcardReply.BufferLength;

                break;
        }


        // Send the command to the serial driver
        status = IoCallDriver(
            SmartcardExtension->ReaderExtension->ConnectedSerialPort,
            irp
            );

        if (status == STATUS_PENDING) {

            // Wait for the command to complete
            KeWaitForSingleObject(
                &event,
                Suspended,
                KernelMode,
                FALSE,
                NULL
                );

            status = ioStatus.Status;
        }

    } while (status == STATUS_MORE_PROCESSING_REQUIRED);

    return status;
}




NTSTATUS
Lit220InitializeInputFilter(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine initialized input filter. It calls the serial driver to
    set a wait mask for character input or DSR change. After that it installs a completion
    routine to be called when a character is received or when DSR changes.
    The completion routine for the wait is Lit220SerialEventCallback and that IRP will
    run until the device is ready to be removed.

Arguments:

    SmartcardExtension - Pointer to our smartcard structure

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;

    PAGED_CODE();

    // Set the WaitMask
    SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask =
        SERIAL_EV_RXCHAR | SERIAL_EV_DSR;

    KeInitializeEvent(
        &SmartcardExtension->ReaderExtension->CardStatus.Event,
        NotificationEvent,
        FALSE
        );

    try {
        //
        // Send a wait mask to the serial driver.
        // This call only sets the wait mask.
        // We want to be informed if a character is received
        //
        SmartcardExtension->ReaderExtension->CardStatus.Irp = IoBuildDeviceIoControlRequest(
            IOCTL_SERIAL_SET_WAIT_MASK,
            SmartcardExtension->ReaderExtension->ConnectedSerialPort,
           &SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask,
            sizeof(SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask),
            NULL,
            0,
            FALSE,
           &(SmartcardExtension->ReaderExtension->CardStatus.Event),
           &(SmartcardExtension->ReaderExtension->CardStatus.IoStatus)
            );

        if (SmartcardExtension->ReaderExtension->CardStatus.Irp == NULL) {
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220InitializeCardTracking: Error STATUS_INSUFFICIENT_RESOURCES\n",
                DRIVER_NAME);
                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        // Call the serial driver
        status = IoCallDriver(
            SmartcardExtension->ReaderExtension->ConnectedSerialPort,
            SmartcardExtension->ReaderExtension->CardStatus.Irp
            );

        if (status == STATUS_PENDING) {
        
            KeWaitForSingleObject(&SmartcardExtension->ReaderExtension->CardStatus.Event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            status = SmartcardExtension->ReaderExtension->CardStatus.Irp->IoStatus.Status;
        }
        

        if (status == STATUS_SUCCESS) {

            KIRQL oldIrql;
            LARGE_INTEGER delayPeriod;
            PIO_STACK_LOCATION irpSp;

            //
            // Now tell the serial driver that we want to be informed
            // if a character is received or DSR changes
            //
            readerExtension->CardStatus.Irp = IoAllocateIrp(
                (CCHAR) (SmartcardExtension->OsData->DeviceObject->StackSize + 1),
                FALSE
                );

            if (readerExtension->CardStatus.Irp == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                leave;
            }

            irpSp = IoGetNextIrpStackLocation( readerExtension->CardStatus.Irp );
            irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

            irpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
            irpSp->Parameters.DeviceIoControl.OutputBufferLength =
                sizeof(readerExtension->SerialConfigData.WaitMask);
            irpSp->Parameters.DeviceIoControl.IoControlCode =
                IOCTL_SERIAL_WAIT_ON_MASK;
            
            readerExtension->CardStatus.Irp->AssociatedIrp.SystemBuffer =
                &readerExtension->SerialConfigData.WaitMask;

            //
            // this artificial delay is necessary to make this driver work
            // with digi board cards
            //
            delayPeriod.HighPart = -1;
            delayPeriod.LowPart = 100l * 1000 * (-10);

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &delayPeriod
                );

            // We simulate a callback now that triggers the card supervision
            Lit220SerialEventCallback(
                SmartcardExtension->OsData->DeviceObject,
                SmartcardExtension->ReaderExtension->CardStatus.Irp,
                SmartcardExtension
                );

            status = STATUS_SUCCESS;

        }
    }
    finally {

        if (status != STATUS_SUCCESS) {
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s(Lit220InitializeInputFilter): Initialization failed - stauts %X\n",
                DRIVER_NAME,
                status)
                );

            // Clear the WaitMask since we did not get the call out that does the wait
            SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask =
                0;
        }
    }

    return status;
}   


NTSTATUS
Lit220SystemControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )

/*++

Routine Description:

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/
{
   
   PDEVICE_EXTENSION DeviceExtension; 
   PSMARTCARD_EXTENSION SmartcardExtension; 
   PREADER_EXTENSION ReaderExtension; 
   NTSTATUS status = STATUS_SUCCESS;

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;
   ReaderExtension      = SmartcardExtension->ReaderExtension;

   IoSkipCurrentIrpStackLocation(Irp);
   status = IoCallDriver(ReaderExtension->BusDeviceObject, Irp);
      
   return status;

} 


NTSTATUS
Lit220DeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    This is the main entry point for the PCSC resource manager.
    We pass all commands to the smartcard libary and let the smartcard
    library call us directly when needed (If device is ready to receive
    calls).
    If the device is not ready we will hold the IRP until we get a signal
    that it is safe to send IRPs again.
    If the device is removed we return an error instead of calling the
    smartcard library.

Arguments:


Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PREADER_EXTENSION ReaderExtension = smartcardExtension->ReaderExtension;
    NTSTATUS status;
    KIRQL irql;

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s(Lit220DeviceControl): Enter DeviceObject %X, Irp %X\n",
        DRIVER_NAME,
        DeviceObject,
        Irp)
        );

    if (smartcardExtension->ReaderExtension->SerialConfigData.WaitMask == 0) {

        //
        // the wait mask is set to 0 whenever the device was either
        // surprise-removed or politely removed
        //
        status = STATUS_DEVICE_REMOVED;
    }

    // Increment the IRP count
    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    if (deviceExtension->IoCount == 0) {

        KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
        status = KeWaitForSingleObject(
            &deviceExtension->ReaderStarted,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        ASSERT(status == STATUS_SUCCESS);

        KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    }
    ASSERT(deviceExtension->IoCount >= 0);
    deviceExtension->IoCount++;
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    status = SmartcardAcquireRemoveLockWithTag(
        smartcardExtension,
        'tcoI');

    if ((status != STATUS_SUCCESS) || (ReaderExtension->DeviceRemoved)) {

        // the device has been removed. Fail the call
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        SmartcardReleaseRemoveLockWithTag(
            smartcardExtension,
            'tcoI');

        return STATUS_DEVICE_REMOVED;
    }

    ASSERT(deviceExtension->SmartcardExtension.ReaderExtension->ReaderPowerState ==
        PowerReaderWorking);

    //
    // We are in the common situation where we send the IRP
    // to the smartcard lib to handle it.
    //
    status = SmartcardDeviceControl(
        &(deviceExtension->SmartcardExtension),
        Irp
        );

    SmartcardReleaseRemoveLockWithTag(
        smartcardExtension,
        'tcoI');

    // Decrement the IRP count
    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    deviceExtension->IoCount--;
    ASSERT(deviceExtension->IoCount >= 0);
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220DeviceControl: Exit %X\n",
        DRIVER_NAME, status)
        );
    return status;
}



NTSTATUS
Lit220GetReaderError(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine checks the status of the previous error to determine the
    correct error code to return.
    The default error is timeout if we cannot determine the error from the
    reader.

--*/
{
    static ULONG PreventReentry = FALSE;
    PSMARTCARD_REQUEST smartcardRequest = &SmartcardExtension->SmartcardRequest;
    NTSTATUS status = STATUS_TIMEOUT;
    LARGE_INTEGER WaitTime;
    KIRQL irql;


    // Sometimes after a command the reader is not reader to accept another command
    // so we need to wait for a short period of time for the reader to be ready.  We need to
    // take this out as soon as the reader is fixed!

    WaitTime.HighPart = -1;
    WaitTime.LowPart = -10 * 1000 * 1000;  // Wait 1S for reader to recover from error.

    KeDelayExecutionThread(
        KernelMode,
        FALSE,
        &WaitTime
        );

    // Prevent a nack from this call from recursively calling itself
    if (InterlockedExchange(
            &PreventReentry,
            TRUE))
    {
        // Default error to timeout if reader keeps failing our calls
        return STATUS_TIMEOUT;
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220GetReaderError: Enter\n",
        DRIVER_NAME)
        );

    smartcardRequest->BufferLength = 0;

    //
    // Send a get reader status to see if a card is inserted
    //
    smartcardRequest->Buffer[smartcardRequest->BufferLength++] =
        LIT220_READER_ATTENTION;
    smartcardRequest->Buffer[smartcardRequest->BufferLength++] =
       LIT220_READER_ATTENTION;
    smartcardRequest->Buffer[smartcardRequest->BufferLength++] =
        LIT220_GET_READER_STATUS;

    //
    // We Expect to get a response
    //
    SmartcardExtension->ReaderExtension->WaitMask |= WAIT_DATA;

    // Send the command
    status = Lit220Command(
        SmartcardExtension
        );

    if (status == STATUS_SUCCESS) {
        // Check if length is correct
        if (SmartcardExtension->SmartcardReply.BufferLength != LIT220_READER_STATUS_LEN) {
            // Return a status timeout because the reader failed to respond
            status = STATUS_TIMEOUT;
        }

        if (status == STATUS_SUCCESS) {
            // Check the error byte to see if there was a protocol error
            // otherwise assume timeout
            if (SmartcardExtension->SmartcardReply.Buffer[1] & 0x04) {
                status = STATUS_TIMEOUT;
            } else {
                status = STATUS_DEVICE_PROTOCOL_ERROR;
            }

            // Check status byte to see if card is inserted
            // and send a notification accordingly
            if (SmartcardExtension->SmartcardReply.Buffer[0] & LIT220_STATUS_CARD_INSERTED) {
                Lit220NotifyCardChange(
                    SmartcardExtension,
                    TRUE
                    );

            } else {
                Lit220NotifyCardChange(
                    SmartcardExtension,
                    FALSE
                    );
            }

        }

    }

    InterlockedExchange(
        &PreventReentry,
        FALSE);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\pscr\pscrcmd.h ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrCmd.h

Abstract:

	Prototypes of basic command functions for SCM PSCR smartcard reader

Author:

	Andreas Straub

Revision History:

	Andreas Straub			7/16/1997	Initial Version

--*/

#if !defined( __PSCR_CMD_H__ )
#define __PSCR_CMD_H__

NTSTATUS
CmdResetInterface( 
	PREADER_EXTENSION	ReaderExtension			//	context of call
	);

NTSTATUS
CmdReset( 
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	UCHAR				Device,					//	device
	BOOLEAN				WarmReset,				//	TRUE: Warm, FALSE: cold Reset
	PUCHAR				pATR,					//	ptr to ATR buffer
	PULONG				ATRLength				//	len of ATR
	);

NTSTATUS
CmdDeactivate( 
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	UCHAR				Device					//	device
	);

NTSTATUS
CmdReadBinary(
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	USHORT				Offset,					//	offset in file
	PUCHAR				pData,					//	data buffer
	PULONG				pNBytes					//	length of bytes read
	);

NTSTATUS
CmdSelectFile(
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	USHORT				FileId					//	File Id
	);

NTSTATUS
CmdSetInterfaceParameter(
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	UCHAR				Device,					//	device
	PUCHAR				pTLVList,				//	ptr to TLV list
	UCHAR				TLVListLen				//	len of TLV list
	);

NTSTATUS
CmdReadStatusFile (
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	UCHAR				Device,					//	device
	PUCHAR				pTLVList,				//	ptr to TLV list
	PULONG				TLVListLen				//	len of TLV list
	);

NTSTATUS
CmdPscrCommand (
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	PUCHAR				pInData,				//	ptr to input buffer
	ULONG				InDataLen,				//	len of input buffer
	PUCHAR				pOutData,				//	ptr to ouput buffer
	ULONG				OutDataLen,				//	len of output buffer
	PULONG				pNBytes					//	number of bytes transferred
	);

NTSTATUS
CmdGetFirmwareRevision (
	PREADER_EXTENSION	ReaderExtension			//	context of call
	);

NTSTATUS
CmdGetTagValue (
	UCHAR				Tag,					//	tag to be searched
	PUCHAR				pTLVList,				//	ptr to TLV list
	ULONG				TLVListLen,				//	len of TLV list
	PUCHAR				pTagLen,				//	tag length
	PVOID				pTagVal					//	tag value
	);

#endif // __PSCR_CMD_H__

//------------------------------- END OF FILE -------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\pscr\pscrnt.h ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrNT.h

Abstract:

    Driver header - NT Version

Author:

    Andreas Straub  (SCM Microsystems, Inc.)
    Klaus Schuetz   (Microsoft Corp.)

Revision History:

    Andreas Straub  1.00        8/18/1997       Initial Version
    Klaus Schuetz   1.01        9/20/1997       Timing changed
    Andreas Straub  1.02        9/24/1997       Low Level error handling,
                                                minor bugfixes, clanup
    Andreas Straub  1.03        10/8/1997       Timing changed, generic SCM
                                                interface changed
    Andreas Straub  1.04        10/18/1997      Interrupt handling changed
    Andreas Straub  1.05        10/19/1997      Generic IOCTL's added
    Andreas Straub  1.06        10/25/1997      Timeout limit for FW update variable
    Andreas Straub  1.07        11/7/1997       Version information added
    Andreas Straub  1.08        11/10/1997      Generic IOCTL GET_CONFIGURATION
    Klaus Schuetz               1998            PnP and Power Management added

--*/

#if !defined ( __PSCR_NT_DRV_H__ )
#define __PSCR_NT_DRV_H__
#define SMARTCARD_POOL_TAG '4SCS'

#include <wdm.h>
#include <DEVIOCTL.H>
#include "SMCLIB.h"
#include "WINSMCRD.h"

#include "PscrRdWr.h"

#if !defined( STATUS_DEVICE_REMOVED )
#define STATUS_DEVICE_REMOVED STATUS_UNSUCCESSFUL
#endif

#define SysCompareMemory( p1, p2, Len )         ( RtlCompareMemory( p1,p2, Len ) != Len )
#define SysCopyMemory( pDest, pSrc, Len )       RtlCopyMemory( pDest, pSrc, Len )
#define SysFillMemory( pDest, Value, Len )      RtlFillMemory( pDest, Len, Value )

#define DELAY_WRITE_PSCR_REG    1
#define DELAY_PSCR_WAIT         5

#define LOBYTE( any )   ((UCHAR)( any & 0xFF ) )
#define HIBYTE( any )   ((UCHAR)( ( any >> 8) & 0xFF ))

typedef struct _DEVICE_EXTENSION
{
    SMARTCARD_EXTENSION SmartcardExtension;

    // The PDO that we are attached to
    PDEVICE_OBJECT AttachedPDO;

    // The DPC object for post interrupt processing
    KDPC DpcObject;

    // Out interrupt resource
    PKINTERRUPT InterruptObject;

    // Flag that indicates if we need to unmap the port upon stop
    BOOLEAN UnMapPort;

    // Our PnP device name
    UNICODE_STRING DeviceName;

    // Current number of io-requests
    LONG IoCount;

    // Used to access IoCount;
    KSPIN_LOCK SpinLock;

     // Used to signal that the device has been removed
    KEVENT ReaderRemoved;

    // Used to signal that the reader is able to process reqeusts
    KEVENT ReaderStarted;

    // Used to signal the the reader has been closed
    LONG ReaderOpen;

    // Used to keep track of the current power state the reader is in
    LONG PowerState;

    // Number of pending card tracking interrupts
    ULONG PendingInterrupts;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define PSCR_MAX_DEVICE     2

#define IOCTL_PSCR_COMMAND      SCARD_CTL_CODE( 0x8000 )
#define IOCTL_GET_VERSIONS      SCARD_CTL_CODE( 0x8001 )
#define IOCTL_SET_TIMEOUT       SCARD_CTL_CODE( 0x8002 )
#define IOCTL_GET_CONFIGURATION SCARD_CTL_CODE( 0x8003 )

typedef struct _VERSION_CONTROL
{
    ULONG   SmclibVersion;
    UCHAR   DriverMajor,
            DriverMinor,
            FirmwareMajor, 
            FirmwareMinor,
            UpdateKey;
} VERSION_CONTROL, *PVERSION_CONTROL;

#define SIZEOF_VERSION_CONTROL  sizeof( VERSION_CONTROL )

typedef struct _PSCR_CONFIGURATION
{
    PPSCR_REGISTERS IOBase;
    ULONG           IRQ;

} PSCR_CONFIGURATION, *PPSCR_CONFIGURATION;

#define SIZEOF_PSCR_CONFIGURATION   sizeof( PSCR_CONFIGURATION )

void SysDelay( ULONG Timeout );

BOOLEAN
PscrMapIOPort( 
    INTERFACE_TYPE  InterfaceType,
    ULONG BusNumber,
    PHYSICAL_ADDRESS BusAddress,
    ULONG Length,
    PULONG pIOPort
    );
        
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    );

NTSTATUS
PscrPnP(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
    );

NTSTATUS
PscrPower(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
    );

NTSTATUS 
PscrStartDevice(
    PDEVICE_OBJECT DeviceObject,
    PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor
    );

NTSTATUS
PscrPcmciaCallComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

VOID
PscrStopDevice( 
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PscrReportResources(
    PDRIVER_OBJECT DriverObject,
    PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDesciptor
    );

NTSTATUS
PscrAddDevice(
    IN PDRIVER_OBJECT DriverObject, 
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
PscrUnloadDevice( 
    PDEVICE_OBJECT DeviceObject
    );

VOID
PscrUnloadDriver( 
    PDRIVER_OBJECT DriverObject
    );

BOOLEAN
IsPnPDriver( 
    void 
    );

VOID
PscrFinishPendingRequest(
    PDEVICE_OBJECT DeviceObject,
    NTSTATUS NTStatus
    );

NTSTATUS
PscrCancel(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
PscrCleanup(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
PscrIrqServiceRoutine(
    PKINTERRUPT Interrupt,
    PDEVICE_EXTENSION DeviceExtension
    );

VOID
PscrDpcRoutine(
    PKDPC                   Dpc,
    PDEVICE_OBJECT          DeviceObject,
    PDEVICE_EXTENSION       DeviceExtension,
    PSMARTCARD_EXTENSION    SmartcardExtension
    );

NTSTATUS
PscrGenericIOCTL(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS 
PscrCreateClose(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
PscrSystemControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS 
PscrDeviceIoControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
PscrInterruptEvent(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
PscrFreeze(
    PSMARTCARD_EXTENSION    SmartcardExtension
    );

NTSTATUS 
PscrCallPcmciaDriver(
    IN PDEVICE_OBJECT AttachedPDO, 
    IN PIRP Irp
    );
#endif  // __PSCR_NT_DRV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\pscr\pscrvers.h ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrVers.h

Abstract:

	header file for version information

Author:

	Andreas Straub

Environment:

	Win 95, Win NT

Revision History:

--*/
#if !defined( __PSCRVERS_H__ )
#define __PSCRVERS_H__

#define PSCR_VERSION_STR	"1.26"
#define PSCR_MAJOR_VERSION	1
#define PSCR_MINOR_VERSION	26

#define PSCR_NAME			"PSCR"
#define PSCR_PRODUCT_NAME	"PSCR SmartCard Reader"
#define PSCR_VENDOR_NAME	"PSCR"
#define PSCR_IFD_TYPE		"PCMCIA Reader"
#define	PSCR_VXD_NAME		"PSCR.VXD"
#define PSCR_DEVICE_NAME	"PSCR_0"

#endif	//	__PSCRVERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\lit220\l220powr.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation and Litronic, 1998 - 1999
//
//  File:       l220powr.c
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////
//
// Power Management
//
//////////////////////////////////////////////////////////


NTSTATUS
Lit220DispatchPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The power dispatch routine.

    As this is a POWER irp, and therefore a special irp, special power irp
    handling is required.


Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION  stack;
    PSMARTCARD_EXTENSION SmartcardExtension = DeviceObject->DeviceExtension;
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS            status;

    LONG          requestCount;

    stack = IoGetCurrentIrpStackLocation(Irp);

    //
    // This IRP was sent to the function driver.
    // The behavior is similar with the one of SD_Pass
    //

    //
    // This IRP was sent to the function driver.
    // We don't queue power Irps, we'll only check if the
    // device was removed, otherwise we'll send it to the next lower
    // driver.
    //

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220DispatchPower: Enter - MinorFunction %X\n",
        DRIVER_NAME,
        stack->MinorFunction)
        );


    // Increment the IRP Count
    status = Lit220IncIoCount(ReaderExtension);

    if (ReaderExtension->IsRemoved) {
        status = STATUS_DELETE_PENDING;
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else {

        //
        // We always need to start the next power irp with PoStartNextPowerIrp
        //
        switch  (stack->MinorFunction)  {
            case IRP_MN_WAIT_WAKE   :
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220DispatchPower: IRP_MN_WAIT_WAKE\n",
                    DRIVER_NAME)
                    );

                status = Lit220PassDownToNextPowerDriver(
                    DeviceObject,
                    Irp
                    );

                break;

            case IRP_MN_POWER_SEQUENCE   :
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220DispatchPower: IRP_MN_POWER_SEQUENCE\n",
                    DRIVER_NAME)
                    );

                status = Lit220PassDownToNextPowerDriver(
                    DeviceObject,
                    Irp
                    );

                break;

            case IRP_MN_QUERY_POWER   :
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220DispatchPower: IRP_MN_QUERY_POWER\n",
                    DRIVER_NAME)
                    );


                status = Lit220QueryPowerState(
                    DeviceObject,
                    Irp
                    );

                break;

            case IRP_MN_SET_POWER   :
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220DispatchPower: IRP_MN_SET_POWER\n",
                    DRIVER_NAME)
                    );

                status = Lit220SetPowerState(
                    DeviceObject,
                    Irp
                    );

                break;


            default:
                //
                // Pass it down
                //
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220DispatchPower: IRP_MN_0x%x\n",
                    DRIVER_NAME,
                    stack->MinorFunction)
                    );

                status = Lit220PassDownToNextPowerDriver(
                    DeviceObject,
                    Irp
                    );

                break;
        }

    }

    return status;
}






NTSTATUS
Lit220PassDownToNextPowerDriver  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    )

/*++

Routine Description:

    Passes the Irp to the next device in the attchement chain

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    NTSTATUS            status;
    PSMARTCARD_EXTENSION SmartcardExtension = DeviceObject->DeviceExtension;
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;

    IoCopyCurrentIrpStackLocationToNext(Irp);

    PoStartNextPowerIrp(Irp);

    status = PoCallDriver(
        ReaderExtension->BusDeviceObject,
        Irp
        );

    if (!NT_SUCCESS(status)) {
        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!Lit220PassDownToNextPowerDriver : Lower driver fails a power irp\n",
            DRIVER_NAME)
            );
    }

    return status;
}


NTSTATUS
Lit220QueryPowerState  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    )

/*++

Routine Description:

   Completes the power Irp with STATUS_SUCCESS

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    Irp->IoStatus.Status = STATUS_SUCCESS;

    PoStartNextPowerIrp(Irp);

    IoCompleteRequest(
        Irp,
        IO_NO_INCREMENT
        );


    //
    // Do not send this Irp down.
    //
    return STATUS_SUCCESS;
}



NTSTATUS
Lit220SetPowerState  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    )

/*++

Routine Description:

   Processes IRP_MN_SET_POWER.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PSMARTCARD_EXTENSION SmartcardExtension = DeviceObject->DeviceExtension;
   PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    PIO_STACK_LOCATION  stack;

    PFDO_POWER_CONTEXT  context;

    BOOLEAN             passItDown;



    stack = IoGetCurrentIrpStackLocation (Irp);

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220SetPowerState: Type %X, State %X\n",
        DRIVER_NAME,
      stack->Parameters.Power.Type,
      stack->Parameters.Power.State.SystemState)
        );

    context = ExAllocatePool(
        NonPagedPool,
        sizeof(FDO_POWER_CONTEXT)
        );

    if (context == NULL) {

        status = STATUS_NO_MEMORY;

    } else {

        RtlZeroMemory(
            context,
            sizeof(FDO_POWER_CONTEXT)
            );

        stack = IoGetCurrentIrpStackLocation (Irp);

        context->newPowerType  = stack->Parameters.Power.Type;
        context->newPowerState = stack->Parameters.Power.State;

        passItDown = TRUE;

        if (stack->Parameters.Power.Type == SystemPowerState) {

            if (ReaderExtension->SystemPowerState ==
                stack->Parameters.Power.State.SystemState)
            {

                //
                // We are already in the given system state
                //
                passItDown = FALSE;
            }

        } else if (stack->Parameters.Power.Type == DevicePowerState) {

            if (ReaderExtension->DevicePowerState !=
                stack->Parameters.Power.State.DeviceState)
            {

                if (ReaderExtension->DevicePowerState == PowerDeviceD0) {

                    //
                    // getting out of D0 state, better call PoSetPowerState now
                    //
                    PoSetPowerState (
                        DeviceObject,
                        DevicePowerState,
                        stack->Parameters.Power.State
                        );
                }

            } else {

                //
                // We are already in the given device state
                //
                passItDown = FALSE;
            }
        } else {

            ASSERT (FALSE);
            status = STATUS_NOT_IMPLEMENTED;
        }
    }

    if (NT_SUCCESS(status) && passItDown) {

        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine(Irp,
                               Lit220PowerCompletionRoutine,
                               context,
                               TRUE,
                               TRUE,
                               TRUE);

        return PoCallDriver(
            ReaderExtension->BusDeviceObject,
            Irp
            );

    } else {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        PoStartNextPowerIrp (Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        //
        // Free the memory now
        //
        if (context) {
            ExFreePool (context);
        }

        return status;
    }
}



NTSTATUS
Lit220PowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

   The completion routine for IRP_MN_SET_POWER.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

   Context - a pointer to a structure that contains the new power type and
   new power state.

Return Value:

   NT status code

--*/
{
    PFDO_POWER_CONTEXT context = Context;
    BOOLEAN            callPoSetPowerState;
    PSMARTCARD_EXTENSION SmartcardExtension = DeviceObject->DeviceExtension;
   PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        callPoSetPowerState = TRUE;

        if (context->newPowerType == SystemPowerState) {

            ReaderExtension->SystemPowerState = context->newPowerState.SystemState;


        } else if (context->newPowerType == DevicePowerState) {

            if (ReaderExtension->DevicePowerState == PowerDeviceD0) {

                //
                // PoSetPowerState is called before we get out of D0
                //
                callPoSetPowerState = FALSE;
            }

            //TODO: Send Power command to device
            //Also, Not sure if we should do this yet it is
            // still TBD

            ReaderExtension->DevicePowerState = context->newPowerState.DeviceState;

        }

        if (callPoSetPowerState) {

            PoSetPowerState (
                DeviceObject,
                context->newPowerType,
                context->newPowerState
                );
        }
    }

    PoStartNextPowerIrp (Irp);
    //
    // We can happily free the heap here
    //
    ExFreePool(context);

    return Irp->IoStatus.Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\pscr\pscrrdwr.h ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrRdWr.h

Abstract:

    Constants & access function prototypes for SCM PSCR smartcard reader

Author:

    Andreas Straub

Revision History:

    Andreas Straub          7/16/1997   Initial Version

--*/

#if !defined( __PSCR_RDWR_H__ )
#define __PSCR_RDWR_H__

#pragma pack( 1 )
//
//  The usage of the PSCR_REGISTERS struct is a little bit tricky:
//  We set the address of that stucture to the IO Base Port, then
//  the other reg's can accessed by their address.
//  p.E.    &PscrRegs = 0x320 --> &PscrRegs->CmdStatusReg = 0x321...
//
typedef struct _PSCR_REGISTERS {

    UCHAR  DataReg;
    UCHAR  CmdStatusReg;
    UCHAR  SizeLSReg;
    UCHAR  SizeMSReg;

 } PSCR_REGISTERS, *PPSCR_REGISTERS;

#define SIZEOF_PSCR_REGISTERS       ( sizeof( PSCR_REGISTERS  )

#pragma pack()


typedef enum _READER_POWER_STATE {
    PowerReaderUnspecified = 0,
    PowerReaderWorking,
    PowerReaderOff
} READER_POWER_STATE, *PREADER_POWER_STATE;

typedef struct _READER_EXTENSION {

    //  I/O address where the reader is configured.
    PPSCR_REGISTERS IOBase;
    ULONG IOWindow;
    ULONG MaxIFSD;

    //  IRQ assigned by the system
    ULONG CurrentIRQ;

    //
    //  limit for read timeout. the absolute timeout limit is 
    //  MaxRetries * DELAY_PSCR_WAIT
    //

    ULONG MaxRetries;

    //  Source/Destination byte always used by the PCMCIA (PC Card) reader.
    UCHAR Device;

    //  Software revision ID of the SwapSmart firmware.
    UCHAR FirmwareMajor, FirmwareMinor, UpdateKey;

    //
    //  Interrupt status; the flag is raised if an freeze event was detected
    //  and cleared if the interface was cleared (int service routine or
    //  PscrRead)
    //
    BOOLEAN FreezePending;

    //
    //  Selected file in the reader file system; the flag is raised if the
    //  ICC1 status file was selected & is cleared if any generic ioctl was
    //  issued (in this case another file may be selected)
    //
    BOOLEAN StatusFileSelected;

    BOOLEAN InvalidStatus;

    BOOLEAN CardPresent;

    // Current reader power state.
    READER_POWER_STATE ReaderPowerState;

} READER_EXTENSION, *PREADER_EXTENSION;

#define SIZEOF_READER_EXTENSION     ( sizeof( READER_EXTENSION ))

//
//  Constants -----------------------------------------------------------------
//
#define PSCR_ID_STRING              "SCM SwapSmart 2."

#define TLV_BUFFER_SIZE             0x20
#define ATR_SIZE                    0x40    // TS + 32 + SW + PROLOGUE + EPILOGUE...

#define PSCR_MAX_RETRIES            1000

#define CLEAR_BIT                   0x00

#define DEFAULT_WAIT_TIME           0x01

#define PSCR_PROLOGUE_LENGTH        0x03
#define PSCR_EXT_PROLOGUE_LENGTH    0x05
#define PSCR_STATUS_LENGTH          0x02

#define PSCR_LRC_LENGTH             0x01
#define PSCR_CRC_LENGTH             0x02

#define PSCR_EPILOGUE_LENGTH        PSCR_LRC_LENGTH

#define PCB_DEFAULT                 0x00

#define MAX_T1_BLOCK_SIZE           270
//
//  data buffer idx
//
#define PSCR_NAD                    0x00
#define PSCR_PCB                    0x01
#define PSCR_LEN                    0x02
#define PSCR_INF                    0x03
#define PSCR_APDU                   PSCR_INF
//
//  device identifier for reset, deactivate
//
#define DEVICE_READER               0x00
#define DEVICE_ICC1                 0x01
#define DEVICE_ICC2                 0x02
//
//  NAD's
//
#define NAD_TO_ICC1                 0x02
#define NAD_TO_ICC2                 0x42
#define NAD_TO_PSCR                 0x12
#define REMOTE_NAD_TO_ICC1          0x03
#define REMOTE_NAD_TO_ICC2          0x43
#define REMOTE_NAD_TO_PSCR          0x13
//
//  PSCR Commands
//
#define CLA_SET_INTERFACE_PARAM     0x80
#define CLA_FREEZE                  0x80
#define CLA_RESET                   0x20
#define CLA_DEACTIVATE              0x20
#define CLA_SELECT_FILE             0x00
#define CLA_READ_BINARY             0x00
#define CLA_WRITE_BINARY            0x00
#define CLA_VERIFY                  0x00
#define CLA_WARM_RESET              0x20
#define CLA_SOFTWARE_UPDATE         0x80
#define CLA_SET_MODE                0x80

#define INS_SET_INTERFACE_PARAM     0x60
#define INS_FREEZE                  0x70
#define INS_RESET                   0x10
#define INS_DEACTIVATE              0x14
#define INS_SELECT_FILE             0xA4
#define INS_READ_BINARY             0xB0
#define INS_WRITE_BINARY            0xD0
#define INS_VERIFY                  0x20
#define INS_WARM_RESET              0x1F
#define INS_SOFTWARE_UPDATE         0xFF
#define INS_SET_MODE                0x61

//
//  Status Read Only Register
//
#define PSCR_DATA_AVAIL_BIT         0x80
#define PSCR_FREE_BIT               0x40
#define PSCR_WRITE_ERROR_BIT        0x02
#define PSCR_READ_ERROR_BIT         0x01
//
//  Command Write Only Register...
//
#define PSCR_RESET_BIT              0x08
#define PSCR_SIZE_READ_BIT          0x04
#define PSCR_SIZE_WRITE_BIT         0x02
#define PSCR_HOST_CONTROL_BIT       0x01
//
//  Tags...
//
#define TAG_MODULE                  0x02
#define TAG_MEMORY_SIZE             0x03
#define TAG_UPDATE_KEY              0x08
#define TAG_SOFTWARE_REV            0x0F
#define TAG_BLOCK_COMP_OPTION       0x13
#define TAG_READER_MECH_OPTIONS     0x20
#define TAG_READER_STATUS           0x21
#define TAG_ICC_PROTOCOLS           0x22
#define TAG_BI                      0x23
#define TAG_FI                      0x24
#define TAG_PTS_PARAM               0x25
#define TAG_PROTOCOL_STATUS         0x26
#define TAG_SET_NULL_BYTES          0x2d
#define TAG_FREEZE_EVENTS           0x30
#define TAG_BIT_LENGTH              0x40
#define TAG_CGT                     0x41
#define TAG_BWT                     0x42
#define TAG_CWT                     0x43
#define TAG_PROTOCOL_PARAM          0x44
//
//  card power definitions ( Tag 0x21 )
//
#define PSCR_ICC_ABSENT             0x00
#define PSCR_ICC_PRESENT            0x01
#define PSCR_ICC_POWERED            0x02
#define PSCR_ICC_IN_TRANSP_MODE     0xA0
#define PSCR_ICC_UNKNOWN            0xFF
//
//  protocol definitions ( Tag 0x22 )
//
#define PSCR_PROTOCOL_UNDEFINED     0x00
#define PSCR_PROTOCOL_T0            0x01
#define PSCR_PROTOCOL_T1            0x02
#define PSCR_PROTOCOL_T14           0x03
#define PSCR_PROTOCOL_I2C           0x80
#define PSCR_PROTOCOL_3WIRE         0x81
#define PSCR_PROTOCOL_2WIRE         0x81

#define WTX_REQUEST                 0xC3
#define WTX_REPLY                   0xE3
//
//  File ID's
//
#define FILE_MASTER                     0x3F00
#define FILE_PSCR_CONFIG                0x0020
#define FILE_PSCR_DIR                   0x7F60
#define FILE_PSCR_DIR_CONFIG            0x6020
#define FILE_PSCR_DIR_STATUS            0x6021
#define FILE_PSCR_DIR_FREEZE_CONFIG     0x6030
#define FILE_PSCR_DIR_FREEZE_STATUS     0x6031
#define FILE_ICC1_DIR                   0x7F70
#define FILE_ICC1_DIR_CONFIG            0x7020
#define FILE_ICC1_DIR_STATUS            0x7021
#define FILE_ICC2_DIR_CONFIG            0x7120
#define FILE_ICC2_DIR_STATUS            0x7121
//
//  Status Word Definitions
//
#define PSCR_SW_COMMAND_FAIL            0x6985
#define PSCR_SW_INVALID_PARAM           0x6A80
#define PSCR_SW_INCONSISTENT_DATA       0x6A85
#define PSCR_SW_NO_PROTOCOL_SUPPORT     0x62A3
#define PSCR_SW_SYNC_ATR_SUCCESS        0x9000
#define PSCR_SW_ASYNC_ATR_SUCCESS       0x9001
#define PSCR_SW_NO_PROTOCOL             0x62A5
#define PSCR_SW_NO_ATR                  0x62A6
#define PSCR_SW_NO_ATR_OR_PROTOCOL      0x62A7
#define PSCR_SW_NO_ICC                  0x64A1
#define PSCR_SW_ICC_NOT_ACTIVE          0x64A2
#define PSCR_SW_NON_SUPPORTED_PROTOCOL  0x64A3
#define PSCR_SW_PROTOCOL_ERROR          0x64A8
#define PSCR_SW_NO_ATR_OR_PROTOCOL2     0x64A7
#define PSCR_SW_FILE_NOT_FOUND          0x6A82
#define PSCR_SW_FILE_NO_ACCEPPTED_AUTH  0x6982
#define PSCR_SW_FILE_NO_ACCESS          0x6985
#define PSCR_SW_FILE_BAD_OFFSET         0x6B00
#define PSCR_SW_END_OF_FILE_READ        0x6282
#define PSCR_SW_END_OF_FILE_WRITE       0x6301
#define PSCR_SW_WRITE_FILE_FAIL         0x6500
#define PSCR_SW_NO_PASSWORD             0x6200
#define PSCR_SW_WRONG_PASSWORD          0x6300
#define PSCR_SW_VERIFY_COUNTER_FAIL     0x6983
#define PSCR_SW_NO_REF_DATA             0x6A88
#define PSCR_SW_FLASH_MEM_ERROR         0x6481
#define PSCR_SW_FLASH_MEM_ERR2          0x6581
#define PSCR_SW_WRONG_LENGTH            0x6700
#define PSCR_SW_UNKNOWN_ICC_ERROR       0x64A0
#define PSCR_SW_UNKNOWN_PROTOCOL_ERROR  0x64A9
#define PSCR_SW_NO_PROTOCOL_SELECTED    0x64A5
#define PSCR_SW_PTS_PROTOCOL_ERROR      0x64AA
#define PSCR_SW_WTX_ERROR               0x64AB
#define PSCR_SW_WTX_ERR2                0x65AB
#define PSCR_SW_INVALID_SOURCE_ADDR     0x6F82

//
//  Prototypes for access functions -------------------------------------------
//


VOID
PscrFlushInterface(
    PREADER_EXTENSION   ReaderExtension     //  context of call
    );

NTSTATUS
PscrRead(
    PREADER_EXTENSION   ReaderExtension,        //  context of call
    PUCHAR              pData,                  //  ptr to data buffer
    ULONG               DataLength,             //  length of data
    PULONG              pNBytes                 //  number of bytes read
    );

NTSTATUS
PscrWrite(
    PREADER_EXTENSION   ReaderExtension,        //  context of call
    PUCHAR              pData,                  //  ptr to data buffer
    ULONG               DataLength,             //  length of data
    PULONG              pNBytes                 //  number of bytes written
    );

NTSTATUS
PscrWriteDirect(
    PREADER_EXTENSION   ReaderExtension,        //  context of call
    PUCHAR              pData,                  //  ptr to data buffer
    ULONG               DataLength,             //  length of data
    PULONG              pNBytes                 //  number of bytes written
    );

UCHAR
PscrCalculateLRC( 
    PUCHAR              pData,                  //  ptr to data buffer
    USHORT              DataLength              //  length of data
    );

NTSTATUS
PscrWait(
    PREADER_EXTENSION   ReaderExtension,        //  context of call
    UCHAR               Mask                    //  mask of requested bits
    );

#endif  //  __PSCR_RDWR_H__

//  ------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\pscr\pscrcmd.c ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrCmd.c

Abstract:

   Basic command functions for SCM PSCR smartcard reader

Author:

   Andreas Straub

Environment:


   Win 95      Sys... calls are resolved by Pscr95Wrap.asm functions and
            Pscr95Wrap.h macros, resp.

   NT 4.0      Sys... functions resolved by PscrNTWrap.c functions and
            PscrNTWrap.h macros, resp.

Revision History:

   Andreas Straub       8/18/1997   1.00  Initial Version
   Andreas Straub       9/24/1997   1.02  delay for read/write removed

--*/

#if defined( SMCLIB_VXD )

#include <Pscr95.h>

#else // SMCLIB_VXD

#include <PscrNT.h>

#endif   // SMCLIB_VXD

#include <PscrRdWr.h>
#include <PscrCmd.h>

NTSTATUS
CmdResetInterface(
                 PREADER_EXTENSION ReaderExtension
                 )
/*++
CmdResetInterface:

   Performs a reset of the reader interface (NOT of the PCMCIA controller)
   - flush available data
   - set RESET bit
   - perform a buffer size exchange between reader & host
   - enables interrupts for freeze events
   - disables default PTS

Arguments:
   ReaderExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_IO_DEVICE_ERROR

--*/
{

    NTSTATUS    NTStatus = STATUS_SUCCESS;
    ULONG       IOBytes;
    UCHAR       Len,
    Tag,
    Cnt,
    InData[ TLV_BUFFER_SIZE ];
    PPSCR_REGISTERS   IOBase;
    UCHAR       EnableInterrupts[]   = { 0x28, 0x01, 0x01};


    IOBase = ReaderExtension->IOBase;

   // discard any data
    PscrFlushInterface( ReaderExtension );

   // reset reader
    WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_RESET_BIT );
    SysDelay( DELAY_WRITE_PSCR_REG );
    WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );

    NTStatus = PscrWait( ReaderExtension, PSCR_DATA_AVAIL_BIT );

   // read & check vendor string
    if ( NT_SUCCESS( NTStatus )) {

        WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_HOST_CONTROL_BIT );
        SysDelay( DELAY_WRITE_PSCR_REG );
      //
      // get actual len from TLV list
      //
        READ_PORT_UCHAR( &IOBase->SizeMSReg );
        READ_PORT_UCHAR( &IOBase->SizeLSReg );

        Tag = READ_PORT_UCHAR( &IOBase->DataReg );
        Len = READ_PORT_UCHAR( &IOBase->DataReg );
      //
      // avoid overwrite of buffer
      //
        if ( Len > TLV_BUFFER_SIZE ) {
            Len = TLV_BUFFER_SIZE;
        }
        for ( Cnt = 0; Cnt < Len; Cnt++ ) {
            InData[ Cnt ] = READ_PORT_UCHAR( &IOBase->DataReg );
        }
        WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );
      //
      // check vendor string
      //
        if ( SysCompareMemory(
                             InData,
                             PSCR_ID_STRING,
                             sizeof( PSCR_ID_STRING )
                             )) {
            NTStatus = STATUS_IO_DEVICE_ERROR;
        } else {
         //
         // vendor string was correct, check buffer size
         //
            WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_SIZE_READ_BIT );
            NTStatus = PscrWait( ReaderExtension, PSCR_DATA_AVAIL_BIT );
         //
         // reader ready to transfer interface buffer size
         //
            if ( NT_SUCCESS( NTStatus )) {
            //
            // set size read & host control
            //
                WRITE_PORT_UCHAR(
                                &IOBase->CmdStatusReg,
                                PSCR_SIZE_READ_BIT | PSCR_HOST_CONTROL_BIT
                                );

                SysDelay( DELAY_WRITE_PSCR_REG );
            //
            // read buffer length
            //
                Len = READ_PORT_UCHAR( &IOBase->SizeMSReg );
                Len = READ_PORT_UCHAR( &IOBase->SizeLSReg );
                for ( Cnt = 0; Cnt < Len; Cnt++ ) {
                    InData[ Cnt ] = READ_PORT_UCHAR( &IOBase->DataReg );
                }
            //
            // transfer of interface buffer size okay
            //
                WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );
                SysDelay( DELAY_WRITE_PSCR_REG );
            //
            // notify the reader about the supported buffer size
            //
                WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_HOST_CONTROL_BIT );
                SysDelay( DELAY_WRITE_PSCR_REG );

                WRITE_PORT_UCHAR( &IOBase->SizeMSReg, 0 );
                WRITE_PORT_UCHAR( &IOBase->SizeLSReg, 2 );
            //
            // Write the same data buffer size as the one we just got.
            //
                WRITE_PORT_UCHAR( &IOBase->DataReg, InData[ 0 ] );
                WRITE_PORT_UCHAR( &IOBase->DataReg, InData[ 1 ] );
            //
            // store the size to report to the lib
            //  The maximum buffer size of the reader is to betrieved with
                //  ((ULONG)InData[ 1 ] << 8) | InData[ 0 ]
                //
                ReaderExtension->MaxIFSD = 254;

            //
            // let the reader process the size write command
            //
                WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_SIZE_WRITE_BIT );
                NTStatus = PscrWait( ReaderExtension, PSCR_FREE_BIT );
            }
        }
    }
   //
   // clean up any host control settings
   //
    WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );
   //
   // enable interrupts
   //
    CmdSetInterfaceParameter(
                            ReaderExtension,
                            ReaderExtension->Device,
                            EnableInterrupts,
                            sizeof( EnableInterrupts )
                            );

    return( NTStatus );
}

NTSTATUS
CmdReset(
        PREADER_EXTENSION ReaderExtension,
        UCHAR          Device,
        BOOLEAN           WarmReset,
        PUCHAR            pATR,
        PULONG            pATRLength
        )
/*++
CmdReset:
   performs a reset of the reader / ICC

Arguments:
   ReaderExtension      context of call
   Device            device requested ( ICC_1, ICC_2, PSCR )
   WarmReset         kind of ICC reset
   pATR           ptr to ATR buffer, NULL if no ATR required
   pATRLength        size of ATR buffer / length of ATR

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_UNRECOGNIZED_MEDIA
   error values from PscrRead / PscrWrite

--*/
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    UCHAR    IOData[ MAX_T1_BLOCK_SIZE ],
    P2;
    USHORT      ICCStatus;
    ULONG    IOBytes;

   // ATR from the smartcard requestet? P2 = 1
    P2 = 0;
    if (( pATR != NULL ) && ( pATRLength != NULL )) {
        if ( *pATRLength > 0 )
            P2 = 0x01;
    }

   // build the RESET command.
    IOData[ PSCR_NAD ] = NAD_TO_PSCR;
    IOData[ PSCR_PCB ] = PCB_DEFAULT;
    IOData[ PSCR_LEN ] = 0x05;

    if ( WarmReset == TRUE ) {
        IOData[ PSCR_INF+0 ] = CLA_WARM_RESET;
        IOData[ PSCR_INF+1 ] = INS_WARM_RESET;
    } else {
        IOData[ PSCR_INF+0 ] = CLA_RESET;
        IOData[ PSCR_INF+1 ] = INS_RESET;
    }
    IOData[ PSCR_INF+2 ] = Device;
    IOData[ PSCR_INF+3 ] = P2;
    IOData[ PSCR_INF+4 ] = 0x00;

   // write command
    NTStatus = PscrWrite(
                        ReaderExtension,
                        IOData,
                        8,
                        &IOBytes
                        );

    if ( NT_SUCCESS( NTStatus )) {
      // read data
        IOBytes = 0;
        NTStatus = PscrRead(
                           ReaderExtension,
                           IOData,
                           MAX_T1_BLOCK_SIZE,
                           &IOBytes
                           );

      // error detection
        if ( NT_SUCCESS( NTStatus )) {
         //
         // the location of the error code in the buffer
         // is: ( data ) - STATUS_MSB - STATUS_LSB - EPILOGUE
         //
            ICCStatus = (( USHORT )IOData[ IOBytes-PSCR_EPILOGUE_LENGTH-2 ]) << 8;
            ICCStatus |= ( USHORT )IOData[ IOBytes-PSCR_EPILOGUE_LENGTH-1 ];

            switch ( ICCStatus ) {
            case PSCR_SW_SYNC_ATR_SUCCESS:
            case PSCR_SW_ASYNC_ATR_SUCCESS:
                break;

            case PSCR_SW_NO_ICC:
                NTStatus = STATUS_NO_MEDIA;
                break;

            case PSCR_SW_NO_PROTOCOL:
            case PSCR_SW_NO_ATR:
            case PSCR_SW_NO_ATR_OR_PROTOCOL:
            case PSCR_SW_NO_ATR_OR_PROTOCOL2:
            case PSCR_SW_ICC_NOT_ACTIVE:
            case PSCR_SW_NON_SUPPORTED_PROTOCOL:
            case PSCR_SW_PROTOCOL_ERROR:
            default:
                NTStatus = STATUS_UNRECOGNIZED_MEDIA;
            }
         //
         // copy ATR if required
         //
            if ( NT_SUCCESS( NTStatus )) {
                if ( P2 == 0x01 ) {
                    IOBytes -= PSCR_PROLOGUE_LENGTH + PSCR_EPILOGUE_LENGTH;
                    if ( IOBytes > *pATRLength ) {
                        IOBytes = *pATRLength;
                    }
                    SysCopyMemory(
                                 pATR,
                                 &IOData[ PSCR_PROLOGUE_LENGTH ],
                                 IOBytes
                                 );
                    *pATRLength = IOBytes;
                }
            }
        }
    }
    return( NTStatus );
}


NTSTATUS
CmdDeactivate(
             PREADER_EXTENSION ReaderExtension,
             UCHAR          Device
             )
/*++
CmdDeactivate:
   Deactivates the requested device

Arguments:
   ReaderExtension      context of call
   Device            requested device

Return Value:
   STATUS_SUCCESS
   error values from PscrRead / PscrWrite

--*/
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    UCHAR    IOData[  MAX_T1_BLOCK_SIZE ];
    ULONG    IOBytes;

   //
   // build the DEACTIVATE command.
   //
    IOData[ PSCR_NAD ] = NAD_TO_PSCR;
    IOData[ PSCR_PCB ] = PCB_DEFAULT;
    IOData[ PSCR_LEN ] = 0x05;

    IOData[ PSCR_INF+0 ] = CLA_DEACTIVATE;
    IOData[ PSCR_INF+1 ] = INS_DEACTIVATE;
    IOData[ PSCR_INF+2 ] = Device;
    IOData[ PSCR_INF+3 ] = 0x00;
    IOData[ PSCR_INF+4 ] = 0x00;
   //
   // write command
   //
    NTStatus = PscrWrite(
                        ReaderExtension,
                        IOData,
                        8,
                        &IOBytes
                        );

    if ( NT_SUCCESS( NTStatus )) {
      //
      // read data to trap communication errors
      //
        IOBytes = 0;
        NTStatus = PscrRead(
                           ReaderExtension,
                           IOData,
                           MAX_T1_BLOCK_SIZE,
                           &IOBytes
                           );
    }
    return( NTStatus );
}

NTSTATUS
CmdReadBinary(
             PREADER_EXTENSION ReaderExtension,
             USHORT            Offset,
             PUCHAR            pBuffer,
             PULONG            pBufferLength
             )
/*++
CmdReadBinary:
   read binary data from an PSCR data file

Arguments:
   ReaderExtension      context of call
   Offset            offset in file
   pBuffer           ptr to data buffer
   pBufferLength     length of buffer / number of bytes read

Return Value:

   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL
   error values from PscrRead / PscrWrite

--*/
{
    NTSTATUS   NTStatus = STATUS_SUCCESS;
    UCHAR      IOData[ MAX_T1_BLOCK_SIZE ];
    USHORT      ICCStatus;
    ULONG    IOBytes;
   //
   // check parameters
   //
    if (( pBuffer == NULL ) || ( pBufferLength == NULL)) {
        NTStatus = STATUS_INVALID_PARAMETER;
    } else {
      //
      // build the READ BINARY command
      //
        IOData[ PSCR_NAD] = NAD_TO_PSCR;
        IOData[ PSCR_PCB] = PCB_DEFAULT;
        IOData[ PSCR_LEN] = 0x05;

        IOData[ PSCR_INF+0 ] = CLA_READ_BINARY;
        IOData[ PSCR_INF+1 ] = INS_READ_BINARY;
        IOData[ PSCR_INF+2 ] = HIBYTE( Offset );
        IOData[ PSCR_INF+3 ] = LOBYTE( Offset );
        IOData[ PSCR_INF+4 ] = 0x00;
      //
      // write command
      //
        NTStatus = PscrWrite(
                            ReaderExtension,
                            IOData,
                            8,
                            &IOBytes
                            );

        if ( NT_SUCCESS( NTStatus )) {
         //
         // read data
         //
            IOBytes = 0;
            NTStatus = PscrRead(
                               ReaderExtension,
                               IOData,
                               MAX_T1_BLOCK_SIZE,
                               &IOBytes
                               );

            if ( NT_SUCCESS( NTStatus )) {
            //
            // error check
            //
                ICCStatus =
                ((USHORT)IOData[ IOBytes-2-PSCR_EPILOGUE_LENGTH ]) << 8;
                ICCStatus |=
                (USHORT)IOData[ IOBytes-1-PSCR_EPILOGUE_LENGTH ];

                switch ( ICCStatus ) {
                case PSCR_SW_FILE_NO_ACCEPPTED_AUTH:
                case PSCR_SW_FILE_NO_ACCESS:
                case PSCR_SW_FILE_BAD_OFFSET:
                case PSCR_SW_END_OF_FILE_READ:
                    NTStatus = STATUS_UNSUCCESSFUL;
                    break;
                default:
                    break;
                }
            //
            // copy data
            //
                if ( NT_SUCCESS( NTStatus )) {
                    if ( *pBufferLength <
                         IOBytes-PSCR_PROLOGUE_LENGTH-PSCR_STATUS_LENGTH ) {
                        NTStatus = STATUS_BUFFER_TOO_SMALL;
                    } else {
                        ( *pBufferLength ) =
                        IOBytes-PSCR_PROLOGUE_LENGTH-PSCR_STATUS_LENGTH;
                        SysCopyMemory(
                                     pBuffer,
                                     &IOData[ PSCR_PROLOGUE_LENGTH ],
                                     *pBufferLength
                                     );
                    }
                }
            }
        }
    }
    return( NTStatus );
}

NTSTATUS
CmdSelectFile(
             PREADER_EXTENSION ReaderExtension,
             USHORT            FileId
             )
/*++
CmdSelectFile:
   selects a file/directoy of the reader

Arguments:
   ReaderExtension      context of call
   FileId            ID of file

Return Value:
   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL
   error values from PscrRead / PscrWrite
--*/
{
    NTSTATUS   NTStatus = STATUS_SUCCESS;
    UCHAR      IOData[ MAX_T1_BLOCK_SIZE ];
    USHORT      ICCStatus;
    ULONG    IOBytes;

   //
   // build the SELECT FILE command
   //
    IOData[ PSCR_NAD ] = NAD_TO_PSCR;
    IOData[ PSCR_PCB ] = PCB_DEFAULT;
    IOData[ PSCR_LEN ] = 0x07;

    IOData[ PSCR_INF+0 ] = CLA_SELECT_FILE;
    IOData[ PSCR_INF+1 ] = INS_SELECT_FILE;
    IOData[ PSCR_INF+2 ] = 0x00;
    IOData[ PSCR_INF+3 ] = 0x00;
    IOData[ PSCR_INF+4 ] = 0x02;
    IOData[ PSCR_INF+5 ] = HIBYTE( FileId );
    IOData[ PSCR_INF+6 ] = LOBYTE( FileId );
   //
   // write command
   //
    NTStatus = PscrWrite(
                        ReaderExtension,
                        IOData,
                        10,
                        &IOBytes
                        );

    if ( NT_SUCCESS( NTStatus )) {
      //
      // get the response of the reader
      //
        IOBytes = 0;
        NTStatus = PscrRead(
                           ReaderExtension,
                           IOData,
                           MAX_T1_BLOCK_SIZE,
                           &IOBytes
                           );

        if ( NT_SUCCESS( NTStatus )) {
         //
         // check errors
         //
            ICCStatus =
            ((USHORT)IOData[ IOBytes-2-PSCR_EPILOGUE_LENGTH ]) << 8;
            ICCStatus |=
            (USHORT)IOData[ IOBytes-1-PSCR_EPILOGUE_LENGTH ];

            if ( ICCStatus == PSCR_SW_FILE_NOT_FOUND ) {
                NTStatus = STATUS_UNSUCCESSFUL;
            }
        }
    }
    return( NTStatus );
}

NTSTATUS
CmdSetInterfaceParameter(
                        PREADER_EXTENSION ReaderExtension,
                        UCHAR          Device,
                        PUCHAR            pTLVList,
                        UCHAR          TLVListLen
                        )
/*++
CmdSetInterfaceParameter:
   Sets the interface pareameter of the ICC interface to the values specified
   in the TLV list

Arguments:
   ReaderExtension      context of call
   Device            device
   pTLVList       ptr to list of tag-len-value's specified by caller
   TLVListLen        length of list

Return Value:
   STATUS_SUCCESS
   STATUS_INVALID_PARAMETER
   STATUS_INVALID_DEVICE_STATE
   error values from PscrRead / PscrWrite

--*/
{
    NTSTATUS   NTStatus = STATUS_SUCCESS;
    UCHAR      IOData[ MAX_T1_BLOCK_SIZE ];
    USHORT      ICCStatus;
    ULONG    IOBytes;

   //
   // check parameter
   //
    if ( pTLVList == NULL ) {
        NTStatus = STATUS_INVALID_PARAMETER;
    } else {
      //
      // build the SET INTERFACE PARAMETER command
      //
        IOData[ PSCR_NAD ] = NAD_TO_PSCR;
        IOData[ PSCR_PCB ] = PCB_DEFAULT;
        IOData[ PSCR_LEN ] = 0x05 + TLVListLen;

        IOData[ PSCR_INF+0 ] = CLA_SET_INTERFACE_PARAM;
        IOData[ PSCR_INF+1 ] = INS_SET_INTERFACE_PARAM;
        IOData[ PSCR_INF+2 ] = Device;
        IOData[ PSCR_INF+3 ] = 0x00;
        IOData[ PSCR_INF+4 ] = TLVListLen;

        SysCopyMemory( &IOData[ PSCR_INF+5 ], pTLVList, TLVListLen );
      //
      // write command
      //
        NTStatus = PscrWrite(
                            ReaderExtension,
                            IOData,
                            8 + TLVListLen,
                            &IOBytes
                            );

        if ( NT_SUCCESS( NTStatus )) {

         // do an dummy read to catch errors.
            IOBytes = 0;
            NTStatus = PscrRead(
                               ReaderExtension,
                               IOData,
                               MAX_T1_BLOCK_SIZE,
                               &IOBytes
                               );

            if ( NT_SUCCESS( NTStatus )) {

            // check error
                ICCStatus =
                ((USHORT)IOData[ IOBytes - 2 - PSCR_EPILOGUE_LENGTH ]) << 8;
                ICCStatus |=
                (USHORT)IOData[ IOBytes - 1 - PSCR_EPILOGUE_LENGTH ];

                if ( ICCStatus != 0x9000 ) {
                    NTStatus = STATUS_INVALID_DEVICE_STATE;
                }
            }
        }
    }
    return( NTStatus );
}


NTSTATUS
CmdReadStatusFile (
                  PREADER_EXTENSION ReaderExtension,
                  UCHAR          Device,
                  PUCHAR            pTLVList,
                  PULONG            pTLVListLen
                  )
/*++
CmdReadStatusFile:
   read the status file of the requested device from the reader filesystem

Arguments:
   ReaderExtension      context of call
   Device            requested device
   pTLVList       ptr to list (i.e. the status file)
   pTLVListLen       length of buffer / returned list

Return Value:
   STATUS_SUCCESS
   STATUS_BUFFER_TOO_SMALL
   error values from PscrRead / PscrWrite

--*/
{
    NTSTATUS       NTStatus = STATUS_UNSUCCESSFUL;
    UCHAR          IOData[ MAX_T1_BLOCK_SIZE ];
    ULONG          IOBytes;

   // select ICC status file if it's not the active file
    if ( ReaderExtension->StatusFileSelected == FALSE ) {

      // select master file on reader
        NTStatus = CmdSelectFile( ReaderExtension, FILE_MASTER );

      // select ICC directory
        if ( NT_SUCCESS( NTStatus )) {
            if ( Device != DEVICE_ICC1 ) {
                NTStatus = STATUS_UNSUCCESSFUL;
            } else {
                NTStatus = CmdSelectFile(
                                        ReaderExtension,
                                        FILE_ICC1_DIR
                                        );

            // select status file
                if ( NT_SUCCESS( NTStatus )) {
                    NTStatus = CmdSelectFile(
                                            ReaderExtension,
                                            FILE_ICC1_DIR_STATUS
                                            );
                    if ( NT_SUCCESS( NTStatus )) {
                        ReaderExtension->StatusFileSelected = TRUE;
                    }
                }
            }
        }
    }

   // read status file if successful selected
    if ( ReaderExtension->StatusFileSelected == TRUE ) {
        IOBytes = MAX_T1_BLOCK_SIZE;
        NTStatus = CmdReadBinary(
                                ReaderExtension,
                                0,
                                IOData,
                                &IOBytes
                                );

      // copy data to user buffer
        if ( NT_SUCCESS( NTStatus )) {
            if (( pTLVList != NULL ) && ( IOBytes < *pTLVListLen )) {
                *pTLVListLen = IOBytes;
                SysCopyMemory( pTLVList, IOData, IOBytes );
            } else {
                NTStatus = STATUS_BUFFER_TOO_SMALL;
            }
        }
    }
    return( NTStatus );
}


NTSTATUS
CmdGetFirmwareRevision (
                       PREADER_EXTENSION ReaderExtension
                       )
/*++
CmdGetFirmwareRevision:
   get the firmware revision of the reader. Ther firmware revision is found
   in the PSCR configuration file (ID 0x0020) in the master directory.
   The tag of the revision is 0x0F, and the value is coded as an ASCII string,
   p.E. "2.20"

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from PscrRead / PscrWrite

--*/
{
    NTSTATUS       NTStatus = STATUS_SUCCESS;
    UCHAR          TLVList[ MAX_T1_BLOCK_SIZE ],
    Len;
    char           Revision[ 0x10 ],
    UpdateKey[ 0x10 ];
    ULONG          IOBytes;
   //
   // select master file on reader
   //
    NTStatus = CmdSelectFile( ReaderExtension, FILE_MASTER );
   //
   // select pscr configuration file
   //
    if ( NT_SUCCESS( NTStatus )) {
        NTStatus = CmdSelectFile( ReaderExtension, FILE_PSCR_CONFIG );
      //
      // read confiuration file
      //
        if ( NT_SUCCESS( NTStatus )) {
            IOBytes = MAX_T1_BLOCK_SIZE;
            NTStatus = CmdReadBinary(
                                    ReaderExtension,
                                    0,
                                    TLVList,
                                    &IOBytes
                                    );
         //
         // get the value of revison
         //
            if ( NT_SUCCESS( NTStatus )) {
                Len = sizeof(Revision);
                CmdGetTagValue(
                              TAG_SOFTWARE_REV,
                              TLVList,
                              IOBytes,
                              &Len,
                              Revision
                              );
            //
            // the coding is always X.YY (in ASCII), so we can get the numeric
            // values hardcoded by taking the low nibbles of the char's.
            //
                ReaderExtension->FirmwareMajor =   Revision[0] & 0x0F;
                ReaderExtension->FirmwareMinor = ( Revision[2] & 0x0F ) << 4;
                ReaderExtension->FirmwareMinor |=  Revision[3] & 0x0F;
            //
            // get value of update key
            //
                Len = sizeof(UpdateKey);
                CmdGetTagValue(
                              TAG_UPDATE_KEY,
                              TLVList,
                              IOBytes,
                              &Len,
                              UpdateKey
                              );

                ReaderExtension->UpdateKey = UpdateKey[0];
            }
        }
    }
    ReaderExtension->StatusFileSelected = FALSE;
    return( NTStatus );
}

NTSTATUS
CmdPscrCommand (
               PREADER_EXTENSION ReaderExtension,
               PUCHAR            pInData,
               ULONG          InDataLen,
               PUCHAR            pOutData,
               ULONG          OutDataLen,
               PULONG            pNBytes
               )
/*++
CmdPscrCommand:
   send a command transparent to the reader

Arguments:
   ReaderExtension      context of call
   pInData,       ptr to input buffer
   InDataLen,        len of input buffer
   pOutData,         ptr to output buffer
   OutDataLen,       len of output buffer
   pNBytes           number of bytes transferred

Return Value:
   STATUS_SUCCESS
   STATUS_INVALID_PARAMETER
   error values from PscrRead / PscrWrite

--*/
{
    NTSTATUS       NTStatus = STATUS_SUCCESS;
    UCHAR          IOData[ MAX_T1_BLOCK_SIZE ] = { 0};
    ULONG          IOBytes;
   //
   // the function is used for generic ioctl's, so carful ALL
   // parametes will be checked!
   //
    if ( ( pInData == NULL ) ||
         ( pOutData == NULL ) ||
         ( pNBytes == NULL ) ||
         (InDataLen == 0 ) ||
         (OutDataLen == 0 )
       ) {
        NTStatus = STATUS_INVALID_PARAMETER;
    } else {
        IOBytes = 0;
        NTStatus = PscrWriteDirect(
                                  ReaderExtension,
                                  pInData,
                                  InDataLen,
                                  &IOBytes
                                  );

        if ( NT_SUCCESS( NTStatus )) {
         //
         // get result. ignore all reader errors
         //
            IOBytes = 0;
            NTStatus = PscrRead(
                               ReaderExtension,
                               IOData,
                               MAX_T1_BLOCK_SIZE,
                               &IOBytes
                               );
         //
         // tranfer data
         //
            if ( IOBytes > OutDataLen ) {
                NTStatus = STATUS_BUFFER_TOO_SMALL;
            } else {
                *pNBytes = IOBytes;
                SysCopyMemory( pOutData, IOData, IOBytes );
            }
        }
    }
    return( NTStatus );
}

NTSTATUS
CmdGetTagValue (
               UCHAR Tag,
               PUCHAR   pTLVList,
               ULONG TLVListLen,
               PUCHAR   pTagLen,
               PVOID pTagVal
               )
/*++
CmdGetTagValue:
   scans a TLV list for the value of a user specified tag
   it is assumed, the caller knows the kind of the requested
   field, so only the ptr to the buffer will be checked

Arguments:
   Tag            requested Tag
   pTLVList    ptr to list
   TLVListLen     length of list
   pTagLen        ptr to length
   pTagVal        ptr to value

Return Value:
   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL
   STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    ULONG    Idx;
    UCHAR maxLen = *pTagLen;
   //
   // step through the given list
   //
    if (( pTLVList != NULL ) && ( pTagVal != NULL ) && ( pTagLen != NULL )) {
      //
      // look for requested tag
      //
        Idx = 0;
        while ( Idx < TLVListLen ) {
            if ( pTLVList[ Idx ] == Tag ) {
            //
            // ASSUMED THE CALLER KNOWS KIND OF FIELD!!!
            //

                if (pTLVList[Idx+1] > maxLen) {
                    NTStatus = STATUS_UNSUCCESSFUL;
                    break;
                }
                *pTagLen = pTLVList[ Idx + 1 ];
                SysCopyMemory(
                             pTagVal,
                             &pTLVList[ Idx+2 ],
                             pTLVList[ Idx+1 ]
                             );

                break;
            }
            Idx += pTLVList[ Idx+1 ] + 2;
        }
        if ( Idx >= TLVListLen ) {
            NTStatus = STATUS_UNSUCCESSFUL;
        }
    } else {
        NTStatus = STATUS_INVALID_PARAMETER;
    }
    return( NTStatus );
}

// ------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\pscr\pscrnt.c ===
/*++

Copyright (c) 1997  - 1999 SCM Microsystems, Inc.

Module Name:

   PscrNT.c

Abstract:

   Main Driver Module - NT Version

Author:

   Andreas Straub

Revision History:


   Andreas Straub 1.00     8/18/1997      Initial Version
   Klaus Schuetz  1.01     9/20/1997      Timing changed
   Andreas Straub 1.02     9/24/1997      Low Level error handling,
                                    minor bugfixes, clanup
   Andreas Straub 1.03     10/8/1997      Timing changed, generic SCM
                                    interface changed
   Andreas Straub 1.04     10/18/1997     Interrupt handling changed
   Andreas Straub 1.05     10/19/1997     Generic IOCTL's added
   Andreas Straub 1.06     10/25/1997     Timeout limit for FW update variable
   Andreas Straub 1.07     11/7/1997      Version information added
   Klaus Schuetz  1.08     11/10/1997     PnP capabilities added
    Klaus Schuetz                               Cleanup added

--*/

#include <PscrNT.h>
#include <PscrCmd.h>
#include <PscrCB.h>
#include <PscrLog.h>
#include <PscrVers.h>

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGEABLE, PscrAddDevice)
#pragma alloc_text(PAGEABLE, PscrStartDevice)
#pragma alloc_text(PAGEABLE, PscrUnloadDriver)
#pragma alloc_text(PAGEABLE, PscrCreateClose)

BOOLEAN DeviceSlot[PSCR_MAX_DEVICE];

NTSTATUS
DriverEntry(
           PDRIVER_OBJECT DriverObject,
           PUNICODE_STRING   RegistryPath
           )
/*++

DriverEntry:
   entry function of the driver. setup the callbacks for the OS and try to
   initialize a device object for every device in the system

Arguments:
   DriverObject   context of the driver
   RegistryPath   path to the registry entry for the driver

Return Value:
   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL

--*/
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    ULONG Device;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!DriverEntry: Enter\n" )
                  );

   // tell the system our entry points
    DriverObject->MajorFunction[IRP_MJ_CREATE] =
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = PscrCreateClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PscrDeviceIoControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PscrSystemControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]  = PscrCleanup;
    DriverObject->MajorFunction[IRP_MJ_PNP]   = PscrPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER] = PscrPower;
    DriverObject->DriverExtension->AddDevice = PscrAddDevice;
    DriverObject->DriverUnload = PscrUnloadDriver;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("PSCR!DriverEntry: Exit %x\n",
                   NTStatus)
                  );

    return NTStatus;
}

NTSTATUS
PscrAddDevice(
             IN PDRIVER_OBJECT DriverObject,
             IN PDEVICE_OBJECT PhysicalDeviceObject
             )
/*++

Routine Description:
    This function is called by the pnp manager. This is used to create
    a new device instance.

--*/
{
    NTSTATUS status;
    UNICODE_STRING vendorNameU, ifdTypeU;
    ANSI_STRING vendorNameA, ifdTypeA;
    HANDLE regKey = NULL;
    PDEVICE_OBJECT DeviceObject = NULL;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!PscrAddDevice: Enter\n" )
                  );

    try {

        ULONG DeviceInstance;
        UNICODE_STRING DriverID;
        PDEVICE_EXTENSION DeviceExtension;
        PREADER_EXTENSION ReaderExtension;
        PSMARTCARD_EXTENSION SmartcardExtension;
        RTL_QUERY_REGISTRY_TABLE parameters[3];

        RtlZeroMemory(parameters, sizeof(parameters));
        RtlZeroMemory(&vendorNameU, sizeof(vendorNameU));
        RtlZeroMemory(&ifdTypeU, sizeof(ifdTypeU));
        RtlZeroMemory(&vendorNameA, sizeof(vendorNameA));
        RtlZeroMemory(&ifdTypeA, sizeof(ifdTypeA));

        for ( DeviceInstance = 0; DeviceInstance < PSCR_MAX_DEVICE; DeviceInstance++ ) {
            if (DeviceSlot[DeviceInstance] == FALSE) {

                DeviceSlot[DeviceInstance] = TRUE;
                break;
            }
        }

        if (DeviceInstance == PSCR_MAX_DEVICE) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

       // Create the device object
        status = IoCreateDevice(
                               DriverObject,
                               sizeof(DEVICE_EXTENSION),
                               NULL,
                               FILE_DEVICE_SMARTCARD,
                               0,
                               TRUE,
                               &DeviceObject
                               );

        if (status != STATUS_SUCCESS) {

            SmartcardLogError(
                             DriverObject,
                             PSCR_INSUFFICIENT_RESOURCES,
                             NULL,
                             0
                             );

            leave;
        }

       //   set up the device extension.
        DeviceExtension = DeviceObject->DeviceExtension;
        SmartcardExtension = &DeviceExtension->SmartcardExtension;

       //   initialize the DPC routine
        KeInitializeDpc(
                       &DeviceExtension->DpcObject,
                       PscrDpcRoutine,
                       DeviceObject
                       );

        KeInitializeSpinLock(&DeviceExtension->SpinLock);

        // Used for device removal notification
        KeInitializeEvent(
                         &DeviceExtension->ReaderRemoved,
                         NotificationEvent,
                         FALSE
                         );

        // Used for stop / start notification
        KeInitializeEvent(
                         &DeviceExtension->ReaderStarted,
                         NotificationEvent,
                         FALSE
                         );

       //   allocate the reader extension
        ReaderExtension = ExAllocatePool(
                                        NonPagedPool,
                                        sizeof( READER_EXTENSION )
                                        );

        if ( ReaderExtension == NULL ) {
            SmartcardLogError(
                             DriverObject,
                             PSCR_INSUFFICIENT_RESOURCES,
                             NULL,
                             0
                             );
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        RtlZeroMemory( ReaderExtension, sizeof( READER_EXTENSION ));

        SmartcardExtension->ReaderExtension = ReaderExtension;

       //   setup smartcard extension - callback's
        SmartcardExtension->ReaderFunction[RDF_CARD_POWER] = CBCardPower;
        SmartcardExtension->ReaderFunction[RDF_TRANSMIT] = CBTransmit;
        SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] = CBCardTracking;
        SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] = CBSetProtocol;
        SmartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR] = PscrGenericIOCTL;

      // setup smartcard extension - vendor attribute
        RtlCopyMemory(
                     SmartcardExtension->VendorAttr.VendorName.Buffer,
                     PSCR_VENDOR_NAME,
                     sizeof( PSCR_VENDOR_NAME )
                     );
        SmartcardExtension->VendorAttr.VendorName.Length =
        sizeof( PSCR_VENDOR_NAME );

        RtlCopyMemory(
                     SmartcardExtension->VendorAttr.IfdType.Buffer,
                     PSCR_IFD_TYPE,
                     sizeof( PSCR_IFD_TYPE )
                     );
        SmartcardExtension->VendorAttr.IfdType.Length =
        sizeof( PSCR_IFD_TYPE );

        SmartcardExtension->VendorAttr.UnitNo =
        DeviceInstance;
        SmartcardExtension->VendorAttr.IfdVersion.BuildNumber = 0;

       //   store firmware revision in ifd version
        SmartcardExtension->VendorAttr.IfdVersion.VersionMajor =
        ReaderExtension->FirmwareMajor;
        SmartcardExtension->VendorAttr.IfdVersion.VersionMinor =
        ReaderExtension->FirmwareMinor;
        SmartcardExtension->VendorAttr.IfdSerialNo.Length = 0;

       //   setup smartcard extension - reader capabilities
        SmartcardExtension->ReaderCapabilities.SupportedProtocols =
        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

        SmartcardExtension->ReaderCapabilities.ReaderType =
        SCARD_READER_TYPE_PCMCIA;
        SmartcardExtension->ReaderCapabilities.MechProperties = 0;
        SmartcardExtension->ReaderCapabilities.Channel = 0;

        SmartcardExtension->ReaderCapabilities.CLKFrequency.Default = 4000;
        SmartcardExtension->ReaderCapabilities.CLKFrequency.Max = 4000;

        SmartcardExtension->ReaderCapabilities.DataRate.Default = 10750;
        SmartcardExtension->ReaderCapabilities.DataRate.Max = 10750;

       //   enter correct version of the lib
        SmartcardExtension->Version = SMCLIB_VERSION;
        SmartcardExtension->SmartcardRequest.BufferSize   = MIN_BUFFER_SIZE;
        SmartcardExtension->SmartcardReply.BufferSize  = MIN_BUFFER_SIZE;

        SmartcardExtension->ReaderExtension->ReaderPowerState =
        PowerReaderWorking;

        status = SmartcardInitialize(SmartcardExtension);

        if (status != STATUS_SUCCESS) {

            SmartcardLogError(
                             DriverObject,
                             PSCR_INSUFFICIENT_RESOURCES,
                             NULL,
                             0
                             );

            leave;
        }

      // tell the lib our device object
        SmartcardExtension->OsData->DeviceObject = DeviceObject;

        DeviceExtension->AttachedPDO = IoAttachDeviceToDeviceStack(
                                                                  DeviceObject,
                                                                  PhysicalDeviceObject
                                                                  );

        if (DeviceExtension->AttachedPDO == NULL) {

            status = STATUS_UNSUCCESSFUL;
            leave;
        }

        // register our new device
        status = IoRegisterDeviceInterface(
                                          PhysicalDeviceObject,
                                          &SmartCardReaderGuid,
                                          NULL,
                                          &DeviceExtension->DeviceName
                                          );

        ASSERT(status == STATUS_SUCCESS);

        DeviceObject->Flags |= DO_BUFFERED_IO;
        DeviceObject->Flags |= DO_POWER_PAGABLE;
        DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

      //
      // try to read the reader name from the registry
      // if that does not work, we will use the default
      // (hardcoded) name
      //
        if (IoOpenDeviceRegistryKey(
                                   PhysicalDeviceObject,
                                   PLUGPLAY_REGKEY_DEVICE,
                                   KEY_READ,
                                   &regKey
                                   ) != STATUS_SUCCESS) {

            leave;
        }

        parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[0].Name = L"VendorName";
        parameters[0].EntryContext = &vendorNameU;
        parameters[0].DefaultType = REG_SZ;
        parameters[0].DefaultData = &vendorNameU;
        parameters[0].DefaultLength = 0;

        parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[1].Name = L"IfdType";
        parameters[1].EntryContext = &ifdTypeU;
        parameters[1].DefaultType = REG_SZ;
        parameters[1].DefaultData = &ifdTypeU;
        parameters[1].DefaultLength = 0;

        if (RtlQueryRegistryValues(
                                  RTL_REGISTRY_HANDLE,
                                  (PWSTR) regKey,
                                  parameters,
                                  NULL,
                                  NULL
                                  ) != STATUS_SUCCESS) {

            leave;
        }

        if (RtlUnicodeStringToAnsiString(
                                        &vendorNameA,
                                        &vendorNameU,
                                        TRUE
                                        ) != STATUS_SUCCESS) {

            leave;
        }

        if (RtlUnicodeStringToAnsiString(
                                        &ifdTypeA,
                                        &ifdTypeU,
                                        TRUE
                                        ) != STATUS_SUCCESS) {

            leave;
        }

        if (vendorNameA.Length == 0 ||
            vendorNameA.Length > MAXIMUM_ATTR_STRING_LENGTH ||
            ifdTypeA.Length == 0 ||
            ifdTypeA.Length > MAXIMUM_ATTR_STRING_LENGTH) {

            leave;
        }

        RtlCopyMemory(
                     SmartcardExtension->VendorAttr.VendorName.Buffer,
                     vendorNameA.Buffer,
                     vendorNameA.Length
                     );
        SmartcardExtension->VendorAttr.VendorName.Length =
        vendorNameA.Length;

        RtlCopyMemory(
                     SmartcardExtension->VendorAttr.IfdType.Buffer,
                     ifdTypeA.Buffer,
                     ifdTypeA.Length
                     );
        SmartcardExtension->VendorAttr.IfdType.Length =
        ifdTypeA.Length;
    } finally {

        if (vendorNameU.Buffer) {

            RtlFreeUnicodeString(&vendorNameU);
        }

        if (ifdTypeU.Buffer) {

            RtlFreeUnicodeString(&ifdTypeU);
        }

        if (vendorNameA.Buffer) {

            RtlFreeAnsiString(&vendorNameA);
        }

        if (ifdTypeA.Buffer) {

            RtlFreeAnsiString(&ifdTypeA);
        }

        if (regKey != NULL) {

            ZwClose(regKey);
        }

        if (status != STATUS_SUCCESS) {

            PscrUnloadDevice(DeviceObject);
        }

        SmartcardDebug(
                      DEBUG_TRACE,
                      ( "PSCR!PscrAddDevice: Exit %x\n",
                        status)
                      );
    }
    return status;
}

NTSTATUS
PscrCallPcmciaDriver(
                    IN PDEVICE_OBJECT AttachedPDO,
                    IN PIRP Irp
                    )
/*++

Routine Description:

   Send an Irp to the pcmcia driver and wait until the pcmcia driver has
   finished the request.

   To make sure that the pcmcia driver will not complete the Irp we first
   initialize an event and set our own completion routine for the Irp.

   When the pcmcia driver has processed the Irp the completion routine will
   set the event and tell the IO manager that more processing is required.

   By waiting for the event we make sure that we continue only if the pcmcia
   driver has processed the Irp completely.

Return Value:

   status returned by the pcmcia driver

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    KEVENT Event;

    // Copy our stack location to the next.
    IoCopyCurrentIrpStackLocationToNext(Irp);

   //
   // initialize an event for process synchronization. the event is passed
   // to our completion routine and will be set if the pcmcia driver is done
   //
    KeInitializeEvent(
                     &Event,
                     NotificationEvent,
                     FALSE
                     );

    // Our IoCompletionRoutine sets only our event
    IoSetCompletionRoutine (
                           Irp,
                           PscrPcmciaCallComplete,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER) {

        status = PoCallDriver(AttachedPDO, Irp);

    } else {

        // Call the serial driver
        status = IoCallDriver(AttachedPDO, Irp);
    }

   // Wait until the pcmcia driver has processed the Irp
    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject(
                                      &Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL
                                      );

        if (status == STATUS_SUCCESS) {

            status = Irp->IoStatus.Status;
        }
    }

    return status;
}

NTSTATUS
PscrPcmciaCallComplete (
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp,
                       IN PKEVENT Event
                       )
/*++

Routine Description:
   Completion routine for an Irp sent to the pcmcia driver. The event will
   be set to notify that the pcmcia driver is done. The routine will not
   'complete' the Irp, so the caller of PscrCallPcmciaDriver can continue.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    if (Irp->Cancel) {

        Irp->IoStatus.Status = STATUS_CANCELLED;
    }

    KeSetEvent (Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
PscrPnP(
       IN PDEVICE_OBJECT DeviceObject,
       IN PIRP Irp
       )
/*++

Routine Description:
   driver callback for pnp manager
   All other requests will be passed to the pcmcia driver to ensure correct processing.

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_OBJECT AttachedPDO;
    BOOLEAN deviceRemoved = FALSE, irpSkipped = FALSE;
    KIRQL irql;
    LARGE_INTEGER timeout;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!PscrPnPDeviceControl: Enter\n" )
                  );

    status = SmartcardAcquireRemoveLock(&DeviceExtension->SmartcardExtension);
    ASSERT(status == STATUS_SUCCESS);

    if (status != STATUS_SUCCESS) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    AttachedPDO = DeviceExtension->AttachedPDO;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    // Now look what the PnP manager wants...
    switch (IrpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:

            // Now we should connect to our resources (Irql, Io etc.)
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("PSCR!PscrPnPDeviceControl: IRP_MN_START_DEVICE\n")
                      );

            // We have to call the underlying driver first
        status = PscrCallPcmciaDriver(AttachedPDO, Irp);

        if (NT_SUCCESS(status)) {

            status = PscrStartDevice(
                                    DeviceObject,
                                    &IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated->List[0]
                                    );

            ASSERT(NT_SUCCESS(status));
        }
        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("PSCR!PscrPnPDeviceControl: IRP_MN_QUERY_STOP_DEVICE\n")
                      );
        KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);
        if (DeviceExtension->IoCount > 0) {

                // we refuse to stop if we have pending io
            KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
            status = STATUS_DEVICE_BUSY;

        } else {

                // stop processing requests
            KeClearEvent(&DeviceExtension->ReaderStarted);
            KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
            status = PscrCallPcmciaDriver(AttachedPDO, Irp);
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("PSCR!PscrPnPDeviceControl: IRP_MN_CANCEL_STOP_DEVICE\n")
                      );

        status = PscrCallPcmciaDriver(AttachedPDO, Irp);
        ASSERT(status == STATUS_SUCCESS);

            // we can continue to process requests
        DeviceExtension->IoCount = 0;
        KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);
        break;

    case IRP_MN_STOP_DEVICE:

            // Stop the device. Aka disconnect from our resources
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("PSCR!PscrPnPDeviceControl: IRP_MN_STOP_DEVICE\n")
                      );

        PscrStopDevice(DeviceObject);
        status = PscrCallPcmciaDriver(AttachedPDO, Irp);
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

            // Remove our device
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("PSCR!PscrPnPDeviceControl: IRP_MN_QUERY_REMOVE_DEVICE\n")
                      );

            // disable the reader
        status = IoSetDeviceInterfaceState(
                                          &DeviceExtension->DeviceName,
                                          FALSE
                                          );
        ASSERT(status == STATUS_SUCCESS);

        if (status != STATUS_SUCCESS) {

            break;
        }

            //
            // check if the reader has been opened
            //
        if (DeviceExtension->ReaderOpen) {

                // someone is connected, enable the reader and fail the call
            IoSetDeviceInterfaceState(
                                     &DeviceExtension->DeviceName,
                                     TRUE
                                     );
            status = STATUS_UNSUCCESSFUL;
            break;
        }

            // pass the call to the next driver in the stack
        status = PscrCallPcmciaDriver(AttachedPDO, Irp);
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

            // Removal of device has been cancelled
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("PSCR!PscrPnPDeviceControl: IRP_MN_CANCEL_REMOVE_DEVICE\n")
                      );

        status = PscrCallPcmciaDriver(AttachedPDO, Irp);

        if (status == STATUS_SUCCESS) {

            status = IoSetDeviceInterfaceState(
                                              &DeviceExtension->DeviceName,
                                              TRUE
                                              );
        }
        break;

    case IRP_MN_SURPRISE_REMOVAL:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("PSCR!PscrPnPDeviceControl: IRP_MN_SURPRISE_REMOVAL\n")
                      );
        if ( DeviceExtension->InterruptObject != NULL ) {
            IoDisconnectInterrupt(DeviceExtension->InterruptObject);
            DeviceExtension->InterruptObject = NULL;
        }
        status = PscrCallPcmciaDriver(AttachedPDO, Irp);
        break;



    case IRP_MN_REMOVE_DEVICE:

            // Remove our device
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("PSCR!PscrPnPDeviceControl: IRP_MN_REMOVE_DEVICE\n")
                      );

        KeSetEvent(&DeviceExtension->ReaderRemoved, 0, FALSE);

        PscrStopDevice(DeviceObject);
        PscrUnloadDevice(DeviceObject);

        status = PscrCallPcmciaDriver(AttachedPDO, Irp);
        deviceRemoved = TRUE;
        break;

    default:
            // This is an Irp that is only useful for underlying drivers
        status = PscrCallPcmciaDriver(AttachedPDO, Irp);
        irpSkipped = TRUE;
        break;
    }

    if (irpSkipped == FALSE) {

      // Don't touch the status field of irps we don't process
        Irp->IoStatus.Status = status;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    if (deviceRemoved == FALSE) {

        SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!PscrPnPDeviceControl: Exit %x\n",
                    status)
                  );

    return status;
}

VOID
PscrSystemPowerCompletion(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN UCHAR MinorFunction,
                         IN POWER_STATE PowerState,
                         IN PKEVENT Event,
                         IN PIO_STATUS_BLOCK IoStatus
                         )
/*++

Routine Description:
    This function is called when the underlying stacks
    completed the power transition.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (PowerState);
    UNREFERENCED_PARAMETER (IoStatus);

    KeSetEvent(Event, 0, FALSE);
}

NTSTATUS
PscrDevicePowerCompletion (
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp,
                          IN PSMARTCARD_EXTENSION SmartcardExtension
                          )
/*++

Routine Description:
    This routine is called after the underlying stack powered
    UP the serial port, so it can be used again.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    UCHAR state;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    status = CmdResetInterface(SmartcardExtension->ReaderExtension);
    ASSERT(status == STATUS_SUCCESS);

    SmartcardExtension->ReaderExtension->StatusFileSelected = FALSE;
    state = CBGetCardState(SmartcardExtension);

    CBUpdateCardState(SmartcardExtension, state, TRUE);

    // save the current power state of the reader
    SmartcardExtension->ReaderExtension->ReaderPowerState =
    PowerReaderWorking;

    SmartcardReleaseRemoveLock(SmartcardExtension);

    // inform the power manager of our state.
    PoSetPowerState (
                    DeviceObject,
                    DevicePowerState,
                    irpStack->Parameters.Power.State
                    );

    PoStartNextPowerIrp(Irp);

    // signal that we can process ioctls again
    KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

    return STATUS_SUCCESS;
}

typedef enum _ACTION {

    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending

} ACTION;

NTSTATUS
PscrPower (
          IN PDEVICE_OBJECT DeviceObject,
          IN PIRP Irp
          )
/*++

Routine Description:
    The power dispatch routine.
    This driver is the power policy owner of the device stack,
    because this driver knows about the connected reader.
    Therefor this driver will translate system power states
    to device power states.

Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT status code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    POWER_STATE powerState;
    ACTION action = SkipRequest;
    KEVENT event;
    KIRQL irql;

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("PSCR!PscrPower: Enter\n")
                  );

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Prefix initialization
    //

    powerState.DeviceState = PowerDeviceUnspecified;

    status = SmartcardAcquireRemoveLock(smartcardExtension);
    ASSERT(NT_SUCCESS(status));

    if (!NT_SUCCESS(status)) {

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (irpStack->Parameters.Power.Type == DevicePowerState &&
        irpStack->MinorFunction == IRP_MN_SET_POWER) {

        switch (irpStack->Parameters.Power.State.DeviceState) {
        
        case PowerDeviceD0:
            // Turn on the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("PSCR!PscrPower: PowerDevice D0\n")
                          );

            //
            // First, we send down the request to the bus, in order
            // to power on the port. When the request completes,
            // we turn on the reader
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine (
                                   Irp,
                                   PscrDevicePowerCompletion,
                                   smartcardExtension,
                                   TRUE,
                                   TRUE,
                                   TRUE
                                   );

            action = WaitForCompletion;
            break;

        case PowerDeviceD3:
            // Turn off the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("PSCR!PscrPower: PowerDevice D3\n")
                          );

            PoSetPowerState (
                            DeviceObject,
                            DevicePowerState,
                            irpStack->Parameters.Power.State
                            );

            // save the current card state
            KeAcquireSpinLock(&smartcardExtension->OsData->SpinLock,
                              &irql);

            smartcardExtension->ReaderExtension->CardPresent =
            smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;

            if (smartcardExtension->ReaderExtension->CardPresent) {
                KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                  irql);


                smartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
                status = CBCardPower(smartcardExtension);
                ASSERT(NT_SUCCESS(status));
            } else {
                KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                  irql);
            }

            // save the current power state of the reader
            smartcardExtension->ReaderExtension->ReaderPowerState =
            PowerReaderOff;

            action = SkipRequest;
            break;

        default:

            action = SkipRequest;
            break;
        }
    }

    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        //
        // The system wants to change the power state.
        // We need to translate the system power state to
        // a corresponding device power state.
        //

        POWER_STATE_TYPE powerType = DevicePowerState;

        ASSERT(smartcardExtension->ReaderExtension->ReaderPowerState !=
               PowerReaderUnspecified);

        switch (irpStack->MinorFunction) {
        
        case IRP_MN_QUERY_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("PSCR!PscrPower: Query Power\n")
                          );


            //
            // By default we succeed and pass down
            //

            action = SkipRequest;
            Irp->IoStatus.Status = STATUS_SUCCESS;

            switch (irpStack->Parameters.Power.State.SystemState) {
            
            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
                break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:
                KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
                if (deviceExtension->IoCount == 0) {

                    // Block any further ioctls
                    KeClearEvent(&deviceExtension->ReaderStarted);
                } else {

                    // can't go to sleep mode since the reader is busy.
                    status = STATUS_DEVICE_BUSY;
                    action = CompleteRequest;
                }
                KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
                break;
            }
            break;

        case IRP_MN_SET_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("PSCR!PscrPower: PowerSystem S%d\n",
                           irpStack->Parameters.Power.State.SystemState - 1)
                          );

            switch (irpStack->Parameters.Power.State.SystemState) {
            
            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:

                if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                    PowerReaderWorking) {

                    // We're already in the right state
                    KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
                    action = SkipRequest;
                    break;
                }

                powerState.DeviceState = PowerDeviceD0;

                // wake up the underlying stack...
                action = MarkPending;
                break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:

                if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                    PowerReaderOff) {

                    // We're already in the right state
                    action = SkipRequest;
                    break;
                }

                powerState.DeviceState = PowerDeviceD3;

                // first, inform the power manager of our new state.
                PoSetPowerState (
                                DeviceObject,
                                SystemPowerState,
                                powerState
                                );

                action = MarkPending;
                break;

            default:

                action = SkipRequest;
                break;
            }
        }
    }

    switch (action) {
    
    case CompleteRequest:
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;

        SmartcardReleaseRemoveLock(smartcardExtension);
        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    case MarkPending:

         // initialize the event we need in the completion function
        KeInitializeEvent(
                         &event,
                         NotificationEvent,
                         FALSE
                         );

         // request the device power irp
        status = PoRequestPowerIrp (
                                   DeviceObject,
                                   IRP_MN_SET_POWER,
                                   powerState,
                                   PscrSystemPowerCompletion,
                                   &event,
                                   NULL
                                   );
        ASSERT(status == STATUS_PENDING);

        if (status == STATUS_PENDING) {

            // wait until the device power irp completed
            status = KeWaitForSingleObject(
                                          &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL
                                          );

            SmartcardReleaseRemoveLock(smartcardExtension);

            if (powerState.SystemState == PowerSystemWorking) {

                PoSetPowerState (
                                DeviceObject,
                                SystemPowerState,
                                powerState
                                );
            }

            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->AttachedPDO, Irp);

        } else {

            SmartcardReleaseRemoveLock(smartcardExtension);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        break;

    case SkipRequest:
        SmartcardReleaseRemoveLock(smartcardExtension);
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        status = PoCallDriver(deviceExtension->AttachedPDO, Irp);
        break;

    case WaitForCompletion:
        status = PoCallDriver(deviceExtension->AttachedPDO, Irp);
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("PSCR!PscrPower: Exit %lx\n",
                   status)
                  );

    return status;
}

NTSTATUS
PscrStartDevice(
               PDEVICE_OBJECT DeviceObject,
               PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor
               )
/*++

Routine Description:
   get the actual configuration from the passed FullResourceDescriptor
   and initializes the reader hardware

Note:
   for an NT 4.00 build the resources must be translated by the HAL

Arguments:
   DeviceObject         context of call
   FullResourceDescriptor  actual configuration of the reader

Return Value:
   STATUS_SUCCESS
   status returned from the HAL (NT 4.00 only )
   status returned by LowLevel routines



--*/
{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR  PartialDescriptor;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &DeviceExtension->SmartcardExtension;
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS status;
    ULONG Count;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("PSCR!PscrStartDevice: Enter\n")
                  );

    // Get the number of resources we need
    Count = FullResourceDescriptor->PartialResourceList.Count;

    PartialDescriptor = FullResourceDescriptor->PartialResourceList.PartialDescriptors;

   // parse all partial descriptors
    while (Count--) {
        switch (PartialDescriptor->Type) {
        case CmResourceTypePort: {

                //   0 - memory, 1 - IO
                ULONG AddressSpace = 1;
                BOOLEAN Translated;
                PHYSICAL_ADDRESS PhysicalAddress;

                ReaderExtension->IOBase =
                (PPSCR_REGISTERS) UlongToPtr(PartialDescriptor->u.Port.Start.LowPart);

                ASSERT(PartialDescriptor->u.Port.Length >= 4);

                SmartcardDebug(
                              DEBUG_TRACE,
                              ("PSCR!PscrStartDevice: IoBase = %lxh\n",
                               ReaderExtension->IOBase)
                              );
                break;
            }

        case CmResourceTypeInterrupt: {

                KINTERRUPT_MODE   Mode;
                BOOLEAN  Shared;
                KIRQL Irql;
                KAFFINITY Affinity;
                ULONG Vector;

                Mode = (
                       PartialDescriptor->Flags &
                       CM_RESOURCE_INTERRUPT_LATCHED ?
                       Latched : LevelSensitive
                       );

                Shared = (
                         PartialDescriptor->ShareDisposition ==
                         CmResourceShareShared
                         );

                Vector = PartialDescriptor->u.Interrupt.Vector;
                Affinity = PartialDescriptor->u.Interrupt.Affinity;
                Irql = (KIRQL) PartialDescriptor->u.Interrupt.Level;

            // store IRQ to allow query configuration
                ReaderExtension->CurrentIRQ =
                PartialDescriptor->u.Interrupt.Vector;

                SmartcardDebug(
                              DEBUG_TRACE,
                              ("PSCR!PscrStartDevice: Irql: %d\n",
                               PartialDescriptor->u.Interrupt.Level)
                              );
            // connect the driver's isr
                status = IoConnectInterrupt(
                                           &DeviceExtension->InterruptObject,
                                           PscrIrqServiceRoutine,
                                           (PVOID) DeviceExtension,
                                           NULL,
                                           Vector,
                                           Irql,
                                           Irql,
                                           Mode,
                                           Shared,
                                           Affinity,
                                           FALSE
                                           );

                break;
            }

        case CmResourceTypeDevicePrivate:
            break;

        default:
            ASSERT(FALSE);
            status = STATUS_UNSUCCESSFUL;
            break;
        }
        PartialDescriptor++;
    }

    try {

        HANDLE handle;
        UCHAR CardState;

       //   IOBase initialized ?
        if ( ReaderExtension->IOBase == NULL ) {

         //
         // under NT 4.0 the failure of this fct for the second reader
         // means there is only one device
         //
            SmartcardLogError(
                             DeviceObject,
                             PSCR_ERROR_IO_PORT,
                             NULL,
                             0
                             );

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

       //   irq connected ?
        if ( DeviceExtension->InterruptObject == NULL ) {

            SmartcardLogError(
                             DeviceObject,
                             PSCR_ERROR_INTERRUPT,
                             NULL,
                             0
                             );

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        ReaderExtension->Device    = DEVICE_ICC1;
        ReaderExtension->MaxRetries = PSCR_MAX_RETRIES;
        status = CmdResetInterface( ReaderExtension );

        SmartcardExtension->ReaderCapabilities.MaxIFSD =
        ReaderExtension->MaxIFSD;

        if (status != STATUS_SUCCESS) {

            SmartcardLogError(
                             DeviceObject,
                             PSCR_CANT_INITIALIZE_READER,
                             NULL,
                             0
                             );

            leave;
        }

        status = CmdReset(
                         ReaderExtension,
                         0x00,          // reader
                         FALSE,            // cold reset
                         NULL,          // no atr
                         NULL
                         );

        if (status != STATUS_SUCCESS) {

            SmartcardLogError(
                             DeviceObject,
                             PSCR_CANT_INITIALIZE_READER,
                             NULL,
                             0
                             );

            leave;
        }

        PscrFlushInterface(DeviceExtension->SmartcardExtension.ReaderExtension);

        CmdGetFirmwareRevision(
                              DeviceExtension->SmartcardExtension.ReaderExtension
                              );

        // If you change the min. firmware version here, please update
        // the .mc file for the correct error message, too
        if (SmartcardExtension->ReaderExtension->FirmwareMajor < 2 ||
            SmartcardExtension->ReaderExtension->FirmwareMajor == 2 &&
            SmartcardExtension->ReaderExtension->FirmwareMinor < 0x30) {

            SmartcardLogError(
                             DeviceObject,
                             PSCR_WRONG_FIRMWARE,
                             NULL,
                             0
                             );
        }

      //
      // make sure the ICC1 status file in the reader file system will
      // be selected
      //
        ReaderExtension->StatusFileSelected = FALSE;
        CardState = CBGetCardState(&DeviceExtension->SmartcardExtension);
        CBUpdateCardState(&DeviceExtension->SmartcardExtension, CardState, FALSE);

        // signal that the reader has been started (again)
        KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);

        status = IoSetDeviceInterfaceState(
                                          &DeviceExtension->DeviceName,
                                          TRUE
                                          );

        if (status == STATUS_OBJECT_NAME_EXISTS) {

            // We tried to re-enable the device which is ok
            // This can happen after a stop - start sequence
            status = STATUS_SUCCESS;
        }
        ASSERT(status == STATUS_SUCCESS);
    } finally {

        if (status != STATUS_SUCCESS) {

            PscrStopDevice(DeviceObject);
        }

        SmartcardDebug(
                      DEBUG_TRACE,
                      ( "PSCR!PscrStartDevice: Exit %x\n",
                        status )
                      );

    }
    return status;
}

VOID
PscrStopDevice(
              PDEVICE_OBJECT DeviceObject
              )
/*++

Routine Description:
   Diconnect the interrupt used by the device & unmap the IO port

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS status;
    LARGE_INTEGER delayPeriod;

    if (DeviceObject == NULL) {

        return;
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!PscrStopDevice: Enter\n" )
                  );

    DeviceExtension = DeviceObject->DeviceExtension;
    KeClearEvent(&DeviceExtension->ReaderStarted);

   // disconnect the interrupt
    if ( DeviceExtension->InterruptObject != NULL ) {
        IoDisconnectInterrupt(DeviceExtension->InterruptObject);
        DeviceExtension->InterruptObject = NULL;
    }

   // unmap ports
    if (DeviceExtension->UnMapPort) {
        MmUnmapIoSpace(
                      DeviceExtension->SmartcardExtension.ReaderExtension->IOBase,
                      DeviceExtension->SmartcardExtension.ReaderExtension->IOWindow
                      );

        DeviceExtension->UnMapPort = FALSE;
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!PscrStopDevice: Exit\n" )
                  );
}

VOID
PscrUnloadDevice(
                PDEVICE_OBJECT DeviceObject
                )
/*++

Routine Description:
   close connections to smclib.sys and the pcmcia driver, delete symbolic
   link and mark the slot as unused.


Arguments:
   DeviceObject   device to unload

Return Value:
   void

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS status;

    if (DeviceObject == NULL) {

        return;
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!PscrUnloadDevice: Enter\n" )
                  );

    DeviceExtension = DeviceObject->DeviceExtension;

    ASSERT(
          DeviceExtension->SmartcardExtension.VendorAttr.UnitNo <
          PSCR_MAX_DEVICE
          );


    if (DeviceExtension->DeviceName.Buffer != NULL) {

        // disble our device so no one can open it
        IoSetDeviceInterfaceState(
                                 &DeviceExtension->DeviceName,
                                 FALSE
                                 );
    }

    // Mark this slot as available
    DeviceSlot[DeviceExtension->SmartcardExtension.VendorAttr.UnitNo] = FALSE;

   // report to the lib that the device will be unloaded
    if (DeviceExtension->SmartcardExtension.OsData != NULL) {
        KIRQL CancelIrql;
        PSMARTCARD_EXTENSION SmartcardExtension =
        &DeviceExtension->SmartcardExtension;

        ASSERT(SmartcardExtension->OsData->NotificationIrp == NULL);

        IoAcquireCancelSpinLock( &CancelIrql );

        if ( SmartcardExtension->OsData->NotificationIrp != NULL ) {
            PIRP notificationIrp;

            notificationIrp = InterlockedExchangePointer(
                                                        &(SmartcardExtension->OsData->NotificationIrp),
                                                        NULL
                                                        );

            IoSetCancelRoutine(
                              notificationIrp,
                              NULL
                              );

            IoReleaseCancelSpinLock( CancelIrql );

            SmartcardDebug(
                          DEBUG_TRACE,
                          ( "PSCR!PscrUnloadDevice: Completing NotificationIrp %lx\n",
                            notificationIrp)
                          );

          //   finish the request
            notificationIrp->IoStatus.Status = STATUS_SUCCESS;
            notificationIrp->IoStatus.Information = 0;

            IoCompleteRequest(
                             notificationIrp,
                             IO_NO_INCREMENT
                             );

        } else {

            IoReleaseCancelSpinLock( CancelIrql );
        }

        // Wait until we can safely unload the device
        SmartcardReleaseRemoveLockAndWait(SmartcardExtension);

        SmartcardExit(&DeviceExtension->SmartcardExtension);
    }

   // delete the symbolic link
    if ( DeviceExtension->DeviceName.Buffer != NULL ) {
        RtlFreeUnicodeString(&DeviceExtension->DeviceName);
        DeviceExtension->DeviceName.Buffer = NULL;
    }

    if (DeviceExtension->SmartcardExtension.ReaderExtension != NULL) {

        ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension);
        DeviceExtension->SmartcardExtension.ReaderExtension = NULL;
    }

    // Detach from the pcmcia driver
    if (DeviceExtension->AttachedPDO) {

        IoDetachDevice(DeviceExtension->AttachedPDO);
        DeviceExtension->AttachedPDO = NULL;
    }

   // delete the device object
    IoDeleteDevice(DeviceObject);

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!PscrUnloadDevice: Exit\n" )
                  );
}

VOID
PscrUnloadDriver(
                PDRIVER_OBJECT DriverObject
                )
/*++

PscrUnloadDriver:
   unloads all devices for a given driver object

Arguments:
   DriverObject   context of driver

--*/
{
    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!PscrUnloadDriver\n" )
                  );
}

NTSTATUS
PscrCreateClose(
               PDEVICE_OBJECT DeviceObject,
               PIRP        Irp
               )
/*++

PscrCreateClose:
   allowes only one open process a time

Arguments:
   DeviceObject   context of device
   Irp            context of call

Return Value:
   STATUS_SUCCESS
   STATUS_DEVICE_BUSY

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    __try {

        if (irpStack->MajorFunction == IRP_MJ_CREATE) {

            status = SmartcardAcquireRemoveLockWithTag(
                                                      &deviceExtension->SmartcardExtension,
                                                      'lCrC'
                                                      );

            if (status != STATUS_SUCCESS) {

                status = STATUS_DEVICE_REMOVED;
                __leave;
            }

         // test if the device has been opened already
            if (InterlockedCompareExchange(
                                          &deviceExtension->ReaderOpen,
                                          TRUE,
                                          FALSE) == FALSE) {

                SmartcardDebug(
                              DEBUG_DRIVER,
                              ("%s!PscrCreateClose: Open\n",
                               DRIVER_NAME)
                              );
            } else {

            // the device is already in use
                status = STATUS_UNSUCCESSFUL;

            // release the lock
                SmartcardReleaseRemoveLockWithTag(
                                                 &deviceExtension->SmartcardExtension,
                                                 'lCrC'
                                                 );
            }

        } else {

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!PscrCreateClose: Close\n",
                           DRIVER_NAME)
                          );
            SmartcardReleaseRemoveLockWithTag(
                                             &deviceExtension->SmartcardExtension,
                                             'lCrC'
                                             );

            deviceExtension->ReaderOpen = FALSE;
        }
    }
    __finally {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}

NTSTATUS
PscrSystemControl(
                 PDEVICE_OBJECT DeviceObject,
                 PIRP        Irp
                 )
/*++
PscrSystemControl:
--*/
{
    PDEVICE_EXTENSION DeviceExtension; 
    NTSTATUS status = STATUS_SUCCESS;

    DeviceExtension      = DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(DeviceExtension->AttachedPDO, Irp);

    return status;

}

NTSTATUS
PscrDeviceIoControl(
                   PDEVICE_OBJECT DeviceObject,
                   PIRP        Irp
                   )
/*++

PscrDeviceIoControl:

   all IRP's requiring IO are queued to the StartIo routine, other requests
   are served immediately

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    KIRQL irql;
    LARGE_INTEGER timeout;

    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    if (deviceExtension->IoCount == 0) {

        KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
        status = KeWaitForSingleObject(
                                      &deviceExtension->ReaderStarted,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL
                                      );
        ASSERT(status == STATUS_SUCCESS);

        KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    }
    ASSERT(deviceExtension->IoCount >= 0);
    deviceExtension->IoCount++;
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    timeout.QuadPart = 0;

    status = KeWaitForSingleObject(
                                  &deviceExtension->ReaderRemoved,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  &timeout
                                  );

    if (status == STATUS_SUCCESS) {

        status = STATUS_DEVICE_REMOVED;

    } else {

        status = SmartcardAcquireRemoveLock(&deviceExtension->SmartcardExtension);
    }

    if (status != STATUS_SUCCESS) {

        // the device has been removed. Fail the call
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }

    status = SmartcardDeviceControl(
                                   &(deviceExtension->SmartcardExtension),
                                   Irp
                                   );

    SmartcardReleaseRemoveLock(&deviceExtension->SmartcardExtension);

    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    deviceExtension->IoCount--;
    ASSERT(deviceExtension->IoCount >= 0);
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    return status;
}

NTSTATUS
PscrGenericIOCTL(
                PSMARTCARD_EXTENSION SmartcardExtension
                )
/*++

PscrGenericIOCTL:
   Performs generic callbacks to the reader

Arguments:
   SmartcardExtension   context of the call

Return Value:
   STATUS_SUCCESS

--*/
{
    NTSTATUS          NTStatus;
    PIRP              Irp;
    PIO_STACK_LOCATION      IrpStack;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!PscrGenericIOCTL: Enter\n" )
                  );

   //
   // get pointer to current IRP stack location
   //
    Irp         = SmartcardExtension->OsData->CurrentIrp;
    IrpStack = IoGetCurrentIrpStackLocation( Irp );
   //
   // assume error
   //
    NTStatus = STATUS_INVALID_DEVICE_REQUEST;
    Irp->IoStatus.Information = 0;
   //
   // dispatch IOCTL
   //
    switch ( IrpStack->Parameters.DeviceIoControl.IoControlCode ) {
    case IOCTL_PSCR_COMMAND:

        NTStatus = CmdPscrCommand(
                                 SmartcardExtension->ReaderExtension,
                                 (PUCHAR)Irp->AssociatedIrp.SystemBuffer,
                                 IrpStack->Parameters.DeviceIoControl.InputBufferLength,
                                 (PUCHAR)Irp->AssociatedIrp.SystemBuffer,
                                 IrpStack->Parameters.DeviceIoControl.OutputBufferLength,
                                 (PULONG) &Irp->IoStatus.Information
                                 );
         //
         // the command could change the active file in the reader file
         // system, so make sure that the status file will be selected
         // before the next read
         //
        SmartcardExtension->ReaderExtension->StatusFileSelected = FALSE;
        break;

    case IOCTL_GET_VERSIONS:

        if ( IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
             SIZEOF_VERSION_CONTROL ) {
            NTStatus = STATUS_BUFFER_TOO_SMALL;
        } else {
            PVERSION_CONTROL  VersionControl;

            VersionControl = (PVERSION_CONTROL)Irp->AssociatedIrp.SystemBuffer;

            VersionControl->SmclibVersion = SmartcardExtension->Version;
            VersionControl->DriverMajor      = PSCR_MAJOR_VERSION;
            VersionControl->DriverMinor      = PSCR_MINOR_VERSION;

            // update firmware version (changed after update)
            CmdGetFirmwareRevision(
                                  SmartcardExtension->ReaderExtension
                                  );
            VersionControl->FirmwareMajor =
            SmartcardExtension->ReaderExtension->FirmwareMajor;

            VersionControl->FirmwareMinor =
            SmartcardExtension->ReaderExtension->FirmwareMinor;

            VersionControl->UpdateKey =
            SmartcardExtension->ReaderExtension->UpdateKey;

            Irp->IoStatus.Information = SIZEOF_VERSION_CONTROL;
            NTStatus = STATUS_SUCCESS;
        }
        break;

    case IOCTL_SET_TIMEOUT:
        {
            ULONG NewLimit;
            //
            // get new timeout limit
            //
            if ( IrpStack->Parameters.DeviceIoControl.InputBufferLength ==
                 sizeof( ULONG )) {
                NewLimit = *(PULONG)Irp->AssociatedIrp.SystemBuffer;
            } else {
                NewLimit = 0;
            }
            //
            // report actual timeout limit
            //
            if ( IrpStack->Parameters.DeviceIoControl.OutputBufferLength ==
                 sizeof( ULONG )) {
                *(PULONG)Irp->AssociatedIrp.SystemBuffer =
                SmartcardExtension->ReaderExtension->MaxRetries * DELAY_PSCR_WAIT;
                Irp->IoStatus.Information = sizeof( ULONG );
            }
            //
            // set new timeout limit
            //
            if ( (NewLimit != 0) ||
                 (NewLimit == MAXULONG-DELAY_PSCR_WAIT+2 )) {
                SmartcardExtension->ReaderExtension->MaxRetries =
                (NewLimit + DELAY_PSCR_WAIT - 1) / DELAY_PSCR_WAIT;
            }
        }
        NTStatus = STATUS_SUCCESS;
        break;

    case IOCTL_GET_CONFIGURATION:
         //
         // return IOBase and IRQ
         //
        if ( IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
             SIZEOF_PSCR_CONFIGURATION ) {
            NTStatus = STATUS_BUFFER_TOO_SMALL;
        } else {
            PPSCR_CONFIGURATION  PSCRConfiguration;

            PSCRConfiguration =
            (PPSCR_CONFIGURATION)Irp->AssociatedIrp.SystemBuffer;
            PSCRConfiguration->IOBase =
            SmartcardExtension->ReaderExtension->IOBase;
            PSCRConfiguration->IRQ =
            SmartcardExtension->ReaderExtension->CurrentIRQ;

            Irp->IoStatus.Information = SIZEOF_PSCR_CONFIGURATION;
            NTStatus = STATUS_SUCCESS;
        }
        break;

    default:
        break;
    }
   //
   // set status of the packet
   //
    Irp->IoStatus.Status = NTStatus;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!PscrGenericIOCTL: Exit\n" )
                  );

    return( NTStatus );
}

BOOLEAN
PscrIrqServiceRoutine(
                     PKINTERRUPT         Interrupt,
                     PDEVICE_EXTENSION DeviceExtension
                     )
/*++

PscrIrqServiceRoutine:
   because the device not supports shared interrupts, the call is passed
   to the DPC routine immediately and the IRQ is reported as served

Arguments:
    Interrupt        interrupt object related to the interrupt
   DeviceExtension      context of call

Return Value:
   STATUS_SUCCESS

--*/
{
    SmartcardDebug(
                  DEBUG_TRACE,
                  ("PSCR!PscrIrqServiceRoutine: Enter\n")
                  );
   //
    // When someone yanks out the card the interrupt handler gets called,
    // but since there is no card anymore when don't need to schedule a DPC
    //

   //
   // the interrupt is caused by a freeze event. the interface will be
   // cleared either by PscrRead() or the DPC routine (depending on
   // which is called first)
   //
    DeviceExtension->SmartcardExtension.ReaderExtension->FreezePending = TRUE;

    InterlockedIncrement(&DeviceExtension->PendingInterrupts);

    KeInsertQueueDpc(
                    &DeviceExtension->DpcObject,
                    DeviceExtension,
                    &DeviceExtension->SmartcardExtension
                    );

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!PscrIrqServiceRoutine: Exit\n" )
                  );

    return TRUE;
}

VOID
PscrDpcRoutine(
              PKDPC             Dpc,
              PDEVICE_OBJECT       DeviceObject,
              PDEVICE_EXTENSION    DeviceExtension,
              PSMARTCARD_EXTENSION SmartcardExtension
              )
/*++

PscrDpcRoutine:
   finishes interrupt requests. the freeze event data of the reader will be read
   & the card state will be updated if data valid

Arguments:
   Dpc               dpc object related to the call
   DeviceObject      context of the device
   DeviceExtension      passed as system argument 1
   SmartcardExtension   passed as system argument 2

Return Value:
   void

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR Event;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!PscrInterruptEvent: IoBase %xh\n",
                    SmartcardExtension->ReaderExtension->IOBase)
                  );

   //
   // In case of a card change the reader provides a TLV packet describing
   // the event ('freeze event'). If PscrRead was called before the DPC
   // routine is called, this event was cleared; in this case the card state
   // will be updated by reading the card status file
   //


    do {

        ASSERT(DeviceExtension->PendingInterrupts < 10);

        SmartcardDebug(
                      DEBUG_TRACE,
                      ( "PSCR!PscrInterruptEvent: PendingInterrupts = %ld\n",
                        DeviceExtension->PendingInterrupts)
                      );

        PscrFreeze( SmartcardExtension );

    } while (InterlockedDecrement(&DeviceExtension->PendingInterrupts) > 0);
}

void
PscrFreeze(
          PSMARTCARD_EXTENSION SmartcardExtension
          )

/*++
PscrFreeze:
   Read & evaluate freeze data

Arguments:
   ReaderExtension   context of call
   pDevice        device which causes the freeze event

Return Value:
   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL

--*/
{
    NTSTATUS NTStatus = STATUS_UNSUCCESSFUL;
    PREADER_EXTENSION ReaderExtension;
    PPSCR_REGISTERS   IOBase;
    UCHAR TLVList[9], CardState;
    ULONG NBytes;
    ULONG Idx, Retries, Status;
    UCHAR ReadFreeze[] = { 0x12, 0x00, 0x05, 0x00, 0xB0, 0x00, 0x00, 0x01, 0xA6};

    ReaderExtension   = SmartcardExtension->ReaderExtension;
    IOBase = ReaderExtension->IOBase;

    for (Retries = 0; Retries < 5; Retries++) {

        Status = READ_PORT_UCHAR( &IOBase->CmdStatusReg );

        ReaderExtension->InvalidStatus = TRUE;
        if (!( Status & PSCR_DATA_AVAIL_BIT )) {
            PscrWriteDirect(
                           ReaderExtension,
                           ReadFreeze,
                           sizeof( ReadFreeze ),
                           &NBytes
                           );

            SysDelay(15);
        }

        NTStatus = PscrRead(
                           ReaderExtension,
                           (PUCHAR) TLVList,
                           sizeof( TLVList ),
                           &NBytes
                           );
        ReaderExtension->InvalidStatus = FALSE;

        if ( NT_SUCCESS( NTStatus ) && ( NBytes == 9 )) {
         // get result
            if ( ( TLVList[ PSCR_NAD ] == 0x21 ) &&
                 ( TLVList[ PSCR_INF ] == TAG_FREEZE_EVENTS )) {
                CardState =
                (TLVList[PSCR_INF + 2] == DEVICE_ICC1 ? PSCR_ICC_PRESENT : PSCR_ICC_ABSENT);

                SmartcardDebug(
                              DEBUG_TRACE,
                              ( "PSCR!PscrFreeze: CardState = %d\n",
                                CardState)
                              );

                CBUpdateCardState(SmartcardExtension, CardState, FALSE);
            }
        }
    }
}

NTSTATUS
PscrCancel(
          IN PDEVICE_OBJECT DeviceObject,
          IN PIRP Irp
          )

/*++

Routine Description:

    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("PSCR!PscrCancel: Enter\n")
                  );

    ASSERT(Irp == smartcardExtension->OsData->NotificationIrp);

    smartcardExtension->OsData->NotificationIrp = NULL;

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;

    IoReleaseCancelSpinLock(
                           Irp->CancelIrql
                           );

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("PSCR!PscrCancel: Completing wait for Irp = %lx\n",
                   Irp)
                  );

    IoCompleteRequest(
                     Irp,
                     IO_NO_INCREMENT
                     );

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("PSCR!PscrCancel: Exit\n")
                  );

    return STATUS_CANCELLED;
}

NTSTATUS
PscrCleanup(
           IN PDEVICE_OBJECT DeviceObject,
           IN PIRP Irp
           )

/*++

Routine Description:

    This routine is called by the I/O system when the calling thread terminates

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!PscrCleanup: Enter\n",
                   DRIVER_NAME)
                  );

    IoAcquireCancelSpinLock(&(Irp->CancelIrql));

    if (smartcardExtension->OsData->NotificationIrp) {

        // We need to complete the notification irp
        IoSetCancelRoutine(
                          smartcardExtension->OsData->NotificationIrp,
                          NULL
                          );

        PscrCancel(
                  DeviceObject,
                  smartcardExtension->OsData->NotificationIrp
                  );
    } else {

        IoReleaseCancelSpinLock( Irp->CancelIrql );
    }

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!PscrCleanup: Completing IRP %lx\n",
                   DRIVER_NAME,
                   Irp)
                  );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(
                     Irp,
                     IO_NO_INCREMENT
                     );

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!PscrCleanup: Exit\n",
                   DRIVER_NAME)
                  );

    return STATUS_SUCCESS;
}

void
SysDelay(
        ULONG Timeout
        )
/*++

SysDelay:
   performs a required delay. The usage of KeStallExecutionProcessor is
   very nasty, but it happends only if SysDelay is called in the context of
   our DPC routine (which is only called if a card change was detected).

   For 'normal' IO we have Irql < DISPATCH_LEVEL, so if the reader is polled
   while waiting for response we will not block the entire system

Arguments:
   Timeout     delay in milli seconds

Return Value:
   void

--*/
{
    LARGE_INTEGER  SysTimeout;

    if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
        ULONG Cnt = 20 * Timeout;

        while ( Cnt-- ) {
         // KeStallExecutionProcessor: counted in us
            KeStallExecutionProcessor( 50 );
        }
    } else {
        SysTimeout.QuadPart = (LONGLONG)-10 * 1000 * Timeout;

      // KeDelayExecutionThread: counted in 100 ns
        KeDelayExecutionThread( KernelMode, FALSE, &SysTimeout );
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\pscr\pscrrdwr.c ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrRdWr.c

Abstract:

    Hardware access functions for SCM PSCR smartcard reader

Author:

    Andreas Straub

Environment:

    Win 95      Sys... calls are resolved by Pscr95Wrap.asm functions and
                Pscr95Wrap.h macros, resp.

    NT  4.0     Sys... functions resolved by PscrNTWrap.c functions and
                PscrNTWrap.h macros, resp.

Revision History:

    Andreas Straub          7/16/1997   1.00    Initial Version
    Klaus Schuetz           9/20/1997   1.01    Timing changed
    Andreas Straub          9/24/1997   1.02    Low Level error handling,
                                                minor bugfixes, clanup

--*/

#if defined( SMCLIB_VXD )

#include <Pscr95.h>

#else   //  SMCLIB_VXD

#include <PscrNT.h>

#endif  //  SMCLIB_VXD

#include <PscrCmd.h>
#include <PscrRdWr.h>

#pragma optimize( "", off )
VOID
PscrFlushInterface( PREADER_EXTENSION ReaderExtension )
/*++

PscrFlushInterface:
    Read & discard data from the pcmcia interface

Arguments:
    ReaderExtension context of call

Return Value:
    void

--*/
{
    UCHAR           Status;
    ULONG           Length;
    PPSCR_REGISTERS IOBase;

    IOBase = ReaderExtension->IOBase;

    Status = READ_PORT_UCHAR( &IOBase->CmdStatusReg );
    if (( Status & PSCR_DATA_AVAIL_BIT ) && ( Status & PSCR_FREE_BIT )) {

        //  take control over
        WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_HOST_CONTROL_BIT );

        //  get number of available bytes
        Length = ((ULONG)READ_PORT_UCHAR( &IOBase->SizeMSReg )) << 8;
        Length |= READ_PORT_UCHAR( &IOBase->SizeLSReg );

        //  perform a dummy read
        while ( Length-- ) {
            READ_PORT_UCHAR( &IOBase->DataReg );
        }
        WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );
    }
    return;
}

NTSTATUS
PscrRead(
        PREADER_EXTENSION   ReaderExtension,
        PUCHAR              pData,
        ULONG               DataLen,
        PULONG              pNBytes
        )
/*++
PscrRead:
    wait until data available & transfer data from reader to host

Arguments:
    ReaderExtension context of call
    pData           ptr to data buffer
    DataLen         length of data buffer
    pNBytes         number of bytes returned

Return Value:
    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL
    STATUS_UNSUCCESSFUL

--*/
{
    NTSTATUS        NTStatus = STATUS_UNSUCCESSFUL;
    USHORT          ReaderStatus;
    PPSCR_REGISTERS IOBase;
    USHORT          InDataLen;

    IOBase = ReaderExtension->IOBase;

    //  wait until interface is ready to transfer
    InDataLen = 0;

    if ( NT_SUCCESS( NTStatus = PscrWait( ReaderExtension, PSCR_DATA_AVAIL_BIT | PSCR_FREE_BIT ))) {
        //  take control over
        WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_HOST_CONTROL_BIT );

        //  get number of available bytes
        InDataLen = ( READ_PORT_UCHAR( &IOBase->SizeMSReg ) << 8 );
        InDataLen |= READ_PORT_UCHAR( &IOBase->SizeLSReg );

        if (InDataLen <= PSCR_PROLOGUE_LENGTH) {

            // the buffer does not contain the minimum packet length
            NTStatus = STATUS_IO_TIMEOUT;

        } else if ( ( ULONG )InDataLen <= DataLen ) {

            //  check buffer size. if buffer to small, the data will be discarded

            //  read data
            ULONG Idx;
            for (Idx = 0; Idx < InDataLen; Idx++) {

                pData[ Idx ] = READ_PORT_UCHAR( &IOBase->DataReg );
            } 

            //  error check
            if ( pData[ InDataLen - 1 ] !=
                 PscrCalculateLRC( pData, (USHORT)( InDataLen - 1 ))) {
                NTStatus = STATUS_CRC_ERROR;
            } else {
                //
                //  Evaluation of reader errors. A reader error is indicated
                //  if the T1 length is 2 and the Nad indicates that this 
                //  packet came from the reader
                //
                if ( ( ( pData[ PSCR_NAD ] & 0x0F ) == 0x01 ) &&
                     ( pData[ PSCR_LEN ] == 0x02 )
                   ) {
                    ReaderStatus = (( USHORT ) pData[3] ) << 8;
                    ReaderStatus |= (( USHORT ) pData[4] );

                    if ( ( ReaderStatus != 0x9000 ) &&
                         ( ReaderStatus != 0x9001 )
                       ) {
                        SmartcardDebug(
                                      DEBUG_TRACE, 
                                      ( "PSCR!PscrRead: ReaderStatus = %lx\n", ReaderStatus )
                                      );

                        InDataLen   = 0;

                        if (ReaderStatus == PSCR_SW_PROTOCOL_ERROR) {

                            NTStatus = STATUS_IO_TIMEOUT;                           

                        } else {

                            NTStatus = STATUS_UNSUCCESSFUL;
                        }
                    }
                }
            }
        } else {

            //  flush interface in case of wrong buffer size
            do {
                READ_PORT_UCHAR( &IOBase->DataReg );

            } while ( --InDataLen );

            NTStatus = STATUS_BUFFER_TOO_SMALL;
        }

        //  clean up
        WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );
    }

    //  write number of bytes received
    if ( InDataLen ) {
        if ( pNBytes != NULL ) {
            ( *pNBytes ) = ( ULONG ) InDataLen;
        }
        NTStatus = STATUS_SUCCESS;
    }
    return( NTStatus );
}

NTSTATUS
PscrWrite(
         PREADER_EXTENSION   ReaderExtension,
         PUCHAR              pData,
         ULONG               DataLen,
         PULONG              pNBytes
         )
/*++
PscrWrite:
    calculates the LRC of the buffer & sends command to the reader

Arguments:
    ReaderExtension context of call
    pData               ptr to data buffer
    DataLen             length of data buffer (exclusive LRC!)
    pNBytes             number of bytes written

Return Value:
    return value of PscrWriteDirect

--*/
{
    NTSTATUS    NTStatus;

    //  Add the EDC field to the end of the data
    pData[ DataLen ] = PscrCalculateLRC( pData, ( USHORT ) DataLen );

    //  Send buffer
    NTStatus = PscrWriteDirect(
                              ReaderExtension,
                              pData,
                              DataLen + PSCR_EPILOGUE_LENGTH,
                              pNBytes
                              );

    return( NTStatus );
}

NTSTATUS
PscrWriteDirect(
               PREADER_EXTENSION   ReaderExtension,
               PUCHAR              pData,
               ULONG               DataLen,
               PULONG              pNBytes
               )

/*++
PscrWriteDirect:
    sends command to the reader. The LRC / CRC must be calculated by caller!

Arguments:
    ReaderExtension context of call
    pData               ptr to data buffer
    DataLen             length of data buffer (exclusive LRC!)
    pNBytes             number of bytes written

Return Value:
    STATUS_SUCCESS
    STATUS_DEVICE_BUSY

--*/
{
    NTSTATUS        NTStatus = STATUS_SUCCESS;
    UCHAR           Status;
    PPSCR_REGISTERS IOBase;

    IOBase = ReaderExtension->IOBase;

    //  in case of card change, there may be data available
    Status = READ_PORT_UCHAR( &IOBase->CmdStatusReg );
    if ( Status & PSCR_DATA_AVAIL_BIT ) {
        NTStatus = STATUS_DEVICE_BUSY;

    } else {
        //
        //  wait until reader is ready
        //
        WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_HOST_CONTROL_BIT );
        NTStatus = PscrWait( ReaderExtension, PSCR_FREE_BIT );

        if ( NT_SUCCESS( NTStatus )) {
            ULONG   Idx;

            //  take control over
            WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_HOST_CONTROL_BIT );

            //  write the buffer size
            WRITE_PORT_UCHAR( &IOBase->SizeMSReg, ( UCHAR )( DataLen >> 8 ));
            SysDelay( DELAY_WRITE_PSCR_REG );
            WRITE_PORT_UCHAR( &IOBase->SizeLSReg, ( UCHAR )( DataLen & 0x00FF ));
            SysDelay( DELAY_WRITE_PSCR_REG );

            //  write data
            for (Idx = 0; Idx < DataLen; Idx++) {

                WRITE_PORT_UCHAR( &IOBase->DataReg, pData[ Idx ] );
            }

            if ( pNBytes != NULL ) {
                *pNBytes = DataLen;
            }
        }

        //  clean up
        WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );
    }
    return( NTStatus );
}

UCHAR
PscrCalculateLRC(
                PUCHAR  pData, 
                USHORT  DataLen
                )
/*++

PscrCalculateLRC:
    calculates the XOR LRC of a buffer.

Arguments:
    pData       ptr to data buffer
    DataLen     length of range

Return Value:
    LRC

--*/
{
    UCHAR   Lrc;
    USHORT  Idx;

    //
    //  Calculate LRC by XORing all the bytes.
    //
    Lrc = pData[ 0 ];
    for ( Idx = 1 ; Idx < DataLen; Idx++ ) {
        Lrc ^= pData[ Idx ];
    }
    return( Lrc );
}

NTSTATUS
PscrWait(
        PREADER_EXTENSION   ReaderExtension, 
        UCHAR               Mask 
        )
/*++
PscrWait:
    Test the status port of the reader until ALL bits in the mask are set.
    The maximum of time until DEVICE_BUSY is returned is approx.
    MaxRetries * DELAY_PSCR_WAIT if MaxRetries != 0.
    If MaxRetries = 0 the driver waits until the requested status is reported or the
    user defines a timeout.

Arguments:
    ReaderExtension     context of call
    Mask                mask of bits to test the status register

Return Value:
    STATUS_SUCCESS
    STATUS_DEVICE_BUSY

--*/
{
    NTSTATUS        NTStatus;
    PPSCR_REGISTERS IOBase;
    ULONG           Retries;
    UCHAR           Status;

    IOBase      = ReaderExtension->IOBase;
    NTStatus    = STATUS_DEVICE_BUSY;

    //  wait until condition fulfilled or specified timeout expired
    for ( Retries = 0; Retries < ReaderExtension->MaxRetries; Retries++) {

        if (( (READ_PORT_UCHAR( &IOBase->CmdStatusReg )) == 0x01) && 
            ReaderExtension->InvalidStatus) {
            NTStatus = STATUS_CANCELLED;
            break;
        }

        //  test requested bits
        if (( (READ_PORT_UCHAR( &IOBase->CmdStatusReg )) & Mask ) == Mask ) {
            NTStatus = STATUS_SUCCESS;
            break;
        }
        SysDelay( DELAY_PSCR_WAIT );
    }

    Status = READ_PORT_UCHAR( &IOBase->CmdStatusReg );

    return NTStatus;
}

#pragma optimize( "", on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\sccmn50m\pcsc_cm.h ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmapiifd/sw/sccmn50m.ms/rcs/pcsc_cm.h $
* $Revision: 1.1 $
*-----------------------------------------------------------------------------
* $Author: TBruendl $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright (c) 1996-99 Utimaco Safeware AG
******************************************************************************/

#ifndef _INC_PCSC_CM
#define _INC_PCSC_CM

/*****************************************************************************/
/** includes                                                                **/
/*****************************************************************************/

#include <winsmcrd.h>
#include <devioctl.h>

/*****************************************************************************/
/** constants                                                               **/
/*****************************************************************************/

#define CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED           SCARD_CTL_CODE (3000)
#define CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED_OLD       SCARD_CTL_CODE (0x8100)

#define CM_IOCTL_GET_FW_VERSION                       SCARD_CTL_CODE (3001)
#define CM_IOCTL_GET_FW_VERSION_OLD                   SCARD_CTL_CODE (0x8101)

// #define CM_SPE_SECURE_PIN_ENTRY                    SCARD_CTL_CODE (0x8102)
//#define CM_IOCTL_IS_SPE_SUPPORTED                     SCARD_CTL_CODE (3003)
//#define CM_IOCTL_IS_SPE_SUPPORTED_OLD                 SCARD_CTL_CODE (0x8103)

#define CM_IOCTL_READ_DEVICE_DESCRIPTION              SCARD_CTL_CODE (3004)

#define CM_IOCTL_SET_SYNC_PARAMETERS                  SCARD_CTL_CODE (3010)
#define CM_IOCTL_2WBP_RESET_CARD                      SCARD_CTL_CODE (3011)
#define CM_IOCTL_2WBP_TRANSFER                        SCARD_CTL_CODE (3012)
#define CM_IOCTL_3WBP_TRANSFER                        SCARD_CTL_CODE (3013)
#define CM_IOCTL_SYNC_CARD_POWERON                    SCARD_CTL_CODE (3014)

#define CM_IOCTL_SET_READER_38400_BAUD                SCARD_CTL_CODE (3020)
#define CM_IOCTL_SET_READER_9600_BAUD                 SCARD_CTL_CODE (3021)

#define CM_IOCTL_OPEN_CT_INTERFACE                    SCARD_CTL_CODE (3022)
#define CM_IOCTL_CLOSE_CT_INTERFACE                   SCARD_CTL_CODE (3023)
#define CM_IOCTL_GET_CT_STATE                         SCARD_CTL_CODE (3024)




//****************************************************************************
//* SYNCHRONOUS SMART CARDS
//****************************************************************************
#define SCARD_RESET_LINE_HIGH      0x00000001
#define SCARD_RESET_LINE_LOW       0x00000000

#define SCARD_PROTOCOL_2WBP        0x00000001
#define SCARD_PROTOCOL_3WBP        0x00000002

//#define CLOCK_FORDCED_2WBP         0x00000040

//----------------------------------------------------------------------------
// structure for "CM_IOCTL_SET_SYNC_PARAMETERS" IO-Control (CrasControl)
//----------------------------------------------------------------------------
#ifndef BOOL
   #define BOOL unsigned int
#endif

typedef struct _SYNC_PARAMETERS {
   ULONG  ulProtocol;
   ULONG  ulStateResetLineWhileReading;
   ULONG  ulStateResetLineWhileWriting;
   ULONG  ulWriteDummyClocks;
   ULONG  ulHeaderLen;
   BOOL   fCardResetRequested;
   BOOL   fCardPowerRequested;
} SYNC_PARAMETERS, *PSYNC_PARAMETERS;


//----------------------------------------------------------------------------
//  structure for CM_IOCTL_2WBP_TRANSFER and  CM_IOCTL_3WBP_TRANSFER
//  IO-Control (CRASControl)
//----------------------------------------------------------------------------
typedef struct _SYNC_TRANSFER
{
   ULONG ulSyncBitsToWrite;
   ULONG ulSyncBitsToRead;
}SYNC_TRANSFER, *PSYNC_TRANSFER;

#endif /* _INC_PCSC_CM */


/*****************************************************************************
* History:
* $Log: pcsc_cm.h $
* Revision 1.1  2000/03/29 06:07:43  TBruendl
* No comment given
*
* Revision 1.10  2000/02/09 14:59:54  WFrischauf
* No comment given
*
* Revision 1.1  2000/02/03 07:50:28  TBruendl
* new IOCTLs : ENABEL_CT_INTERFACE and DISABLE_CT_INTERFACE
*
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\sccmn50m\sccmn50m.h ===
/*****************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbs0/sw/sccmn50m.ms/rcs/sccmn50m.h $
* $Revision: 1.3 $
*-----------------------------------------------------------------------------
* $Author: TBruendl $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/

#ifndef _CARDMAN_
   #define _CARDMAN_


// ****************************************************************************
//                    DEFINES
// ****************************************************************************
   #define DRIVER_NAME "SCCMN50M"
   #define SMARTCARD_POOL_TAG 'CMCS'

   #include <ntddk.h>
   #include <ntddser.h>

   #include "smclib.h"
   #include "sccmlog.h"

   #include "pcsc_cm.h"

   #define SMARTCARD_READ          SCARD_CTL_CODE(1000)
   #define SMARTCARD_WRITE         SCARD_CTL_CODE(1001)

   #define CARDMAN_DEVICE_NAME L"\\Device\\CM_2010_0"


   #define IFD_NT_VERSIONMAJOR_CARDMAN  3
   #define IFD_NT_VERSIONMINOR_CARDMAN  2
   #define IFD_NT_BUILDNUMBER_CARDMAN   1


   #define ATTR_VENDOR_NAME         "OMNIKEY"
   #define ATTR_IFD_TYPE_CM     "CardMan 2010"

   #define ATTR_MAX_IFSD_CARDMAN_II  80


   #define WAIT_MS  -10000
   #define ms_       1

   #define UNKNOWN    0xFFFFFFFF
   #define REMOVED    0x00000001
   #define INSERTED   0x00000002
   #define POWERED    0x00000004


// SCR control byte
   #define IGNORE_PARITY         0x01
   #define XMIT_HANDSHAKE_OFF    0x02
   #define CM2_GET_ATR           0x04
//#define reserved              0x08
   #define TO_STATE_XH           0x10
   #define LEDS_OFF              0x20
   #define LEDS_RED              0x40
   #define CARD_POWER            0x80


// card control byte
   #define INVERSE_DATA          0x01
   #define ENABLE_5MHZ_FAST      0x02
   #define ENABLE_3MHZ_FAST      0x04
   #define ENABLE_5MHZ           0x08
   #define ENABLE_3MHZ           0x00
   #define ENABLE_SYN            0x10
   #define ENABLE_T0             0x20
   #define ENABLE_T1             0x40
   #define ENABLE_CRC            0x80

   #define ALL_FLAGS             0xFF

// tx control byte
   #define  SYNC_RESET_LINE_HIGH    0x80
   #define  SYNC_RESET_LINE_LOW     0x00
   #define  CLOCK_FORCED_2WBP       0x40
   #define  TRANSMIT_A8             0x08
   #define  SYNC_DUMMY_RECEIVE      0x10

// rx control byte

   #define T0_DATA_TO_CARD          0x80
   #define T0_DATA_FROM_CARD        0x00
   #define COLD_RESET               0x40
   #define RECEIVE_A8               0x08

   #define DEFAULT_READ_INTERVAL_TIMEOUT           1000
   #define DEFAULT_READ_TOTAL_TIMEOUT_MULTIPLIER     50
   #define DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT     1500
   #define DEFAULT_WRITE_TOTAL_TIMEOUT_MULTIPLIER    50
   #define DEFAULT_WRITE_TOTAL_TIMEOUT_CONSTANT     250


// for protocol T=0
   #define T0_HEADER_LEN  0x05
   #define T0_STATE_LEN   0x02

// for protocol T=1
   #define T1_HEADER_LEN   0x03
   #define MAX_EDC_LEN     0x02



// for power on
   #define RESET_DELAY_SYNC              0x01

   #define ASYNC3_CARD                   0x00
   #define ASYNC5_CARD                   0x01


   #define ATR_LEN_SYNC                   4
   #define ATR_LEN_ASYNC                 33



   #define CHAR_INV                      0x03
   #define CHAR_NORM                     0x3B


   #define MIN_ATR_LEN                   0x03

   #define SYNC_ATR_RX_CONTROL           0x47
   #define SYNC_RESET_DELAY              0x01


   #define TS_OFFSET                     0
   #define T0_OFFSET                     1




typedef enum _READER_POWER_STATE
   {
   PowerReaderUnspecified = 0,
   PowerReaderWorking,
   PowerReaderOff
   } READER_POWER_STATE, *PREADER_POWER_STATE;

typedef struct _SERIAL_READER_CONFIG
   {
   // flow control
   SERIAL_HANDFLOW HandFlow;

   // special characters
   SERIAL_CHARS SerialChars;

   // read/write timeouts
   SERIAL_TIMEOUTS Timeouts;

   // Baudrate for reader
   SERIAL_BAUD_RATE BaudRate;

   // Stop bits, parity configuration
   SERIAL_LINE_CONTROL LineControl;

   //
   // current status of the serial port for IOCTL_GET_COMMSTATUS
   //
   SERIAL_STATUS SerialStatus;

   // mask for purge operation
   ULONG PurgeMask;

   } SERIAL_READER_CONFIG, *PSERIAL_READER_CONFIG;

typedef struct _CARDMAN_CONFIG
   {
   UCHAR SCRControl;
   UCHAR CardControl;
   UCHAR CardStopBits;
   UCHAR ResetDelay;
   } CARDMAN_CONFIG, *PCARDMAN_CONFIG;

typedef struct _CARDMAN_HEADER
   {
   UCHAR TxControl;
   UCHAR TxLength;
   UCHAR RxControl;
   UCHAR RxLength;
   } CARDMAN_HEADER, *PCARDMAN_HEADER;



typedef struct _DEVICE_EXTENSION
   {
   // Our smart card extension
   SMARTCARD_EXTENSION SmartcardExtension;

   // The current number of io-requests
   LONG IoCount;

   // Used to signal that the reader is able to process reqeusts
   KEVENT ReaderStarted;

   // Used to signal the the reader has been closed
   KEVENT ReaderClosed;

   // Used to signal that the connection to the serial driver has been closed
   KEVENT SerialCloseDone;

   ULONG DeviceInstance;

   // The pnp device name of our smart card reader
   UNICODE_STRING PnPDeviceName;


   KSPIN_LOCK SpinLock;


   } DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Define the reader specific portion of the smart card extension
//
typedef struct _READER_EXTENSION
   {

   HANDLE hThread;

   // DeviceObject pointer to serial port
   PDEVICE_OBJECT AttachedDeviceObject;

   // IoRequest to be send to serial driver
   ULONG SerialIoControlCode;


   // Saved card state for hibernation/sleeping modes.
   BOOLEAN CardPresent;

   // Current reader power state.
   READER_POWER_STATE ReaderPowerState;



   BOOLEAN              TimeToTerminateThread;
   PVOID                ThreadObjectPointer;
   KMUTEX               CardManIOMutex;
   SERIAL_READER_CONFIG SerialConfigData;
   BOOLEAN              NoConfig;
   BOOLEAN              ToRHConfig;
   BOOLEAN              BreakSet;
   ULONG                SerialErrors;
   CARDMAN_CONFIG       CardManConfig;
   CARDMAN_HEADER       CardManHeader;
   ULONG                ulOldCardState;
   ULONG                ulNewCardState;
   BOOLEAN              fRawModeNecessary;
   ULONG                ulFWVersion;
   BOOLEAN              fSPESupported;
   BOOLEAN              fTransparentMode;
   BOOLEAN              fInverseAtr;
   UCHAR                abDeviceDescription[42];
   SYNC_PARAMETERS      SyncParameters;
   } READER_EXTENSION, *PREADER_EXTENSION;

   #define READER_EXTENSION(member) (SmartcardExtension->ReaderExtension->member)
   #define ATTACHED_DEVICE_OBJECT deviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject




// ****************************************************************************
//                    PROTOTYPES
// ****************************************************************************
NTSTATUS
SCCMN50M_AddDevice (
                   IN PDRIVER_OBJECT DriverObject,
                   IN PDEVICE_OBJECT PhysicalDeviceObject
                   );


NTSTATUS
SCCMN50M_CallSerialDriver (
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp
                          );

NTSTATUS
SCCMN50M_Cancel (
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                );


NTSTATUS
SCCMN50M_Cleanup (
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp
                 );

VOID
SCCMN50M_ClearCardControlFlags (
                               IN PSMARTCARD_EXTENSION pSmartcardExtension,
                               IN UCHAR Flags
                               );

VOID
SCCMN50M_ClearCardManHeader (
                            IN PSMARTCARD_EXTENSION pSmartcardExtension
                            );

VOID
SCCMN50M_ClearSCRControlFlags (
                              IN PSMARTCARD_EXTENSION pSmartcardExtension,
                              IN UCHAR Flags
                              );
VOID
SCCMN50M_CompleteCardTracking (
                              IN PSMARTCARD_EXTENSION SmartcardExtension
                              );

NTSTATUS
SCCMN50M_CreateClose (
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
                     );

NTSTATUS
SCCMN50M_CreateDevice (
                      IN  PDRIVER_OBJECT DriverObject,
                      IN PDEVICE_OBJECT PhysicalDeviceObject,
                      OUT PDEVICE_OBJECT *DeviceObject
                      );

NTSTATUS
SCCMN50M_DeviceControl (
                       PDEVICE_OBJECT DeviceObject,
                       PIRP Irp
                       );

VOID
SCCMN50M_DriverUnload (
                      IN PDRIVER_OBJECT DriverObject
                      );

VOID
SCCMN50M_InitializeSmartcardExtension (
                                      IN PSMARTCARD_EXTENSION pSmartcardExtension,
                                      IN ULONG ulDeviceInstance
                                      );

NTSTATUS
SCCMN50M_PnP (
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp
             );

NTSTATUS
SCCMN50M_Power (
               IN PDEVICE_OBJECT    DeviceObject,
               IN PIRP              Irp
               );

VOID
SCCMN50M_RemoveDevice (
                      PDEVICE_OBJECT DeviceObject
                      );

NTSTATUS
SCCMN50M_SerialIo (
                  PSMARTCARD_EXTENSION SmartcardExtension
                  );


VOID
SCCMN50M_SetCardManHeader (
                          IN PSMARTCARD_EXTENSION pSmartcardExtension,
                          IN UCHAR TxControl,
                          IN UCHAR TxLength,
                          IN UCHAR RxControl,
                          IN UCHAR RxLength
                          );

VOID
SCCMN50M_SetCardControlFlags (
                             IN PSMARTCARD_EXTENSION pSmartcardExtension,
                             IN UCHAR Flags
                             );

VOID
SCCMN50M_SetSCRControlFlags (
                            IN PSMARTCARD_EXTENSION pSmartcardExtension,
                            IN UCHAR Flags
                            );

VOID
SCCMN50M_StopCardTracking (
                          IN PDEVICE_EXTENSION pDeviceExtension
                          );

VOID SCCMN50M_SetVendorAndIfdName(
                              IN  PDEVICE_OBJECT PhysicalDeviceObject,
                              IN  PSMARTCARD_EXTENSION SmartcardExtension
                              );
NTSTATUS
SCCMN50M_SystemControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   );

VOID
SCCMN50M_UpdateCurrentStateThread (
                                  IN PVOID Context
                                  );

NTSTATUS
SCCMN50M_UpdateCurrentState(
                           IN PSMARTCARD_EXTENSION smartcardExtension
                           );

NTSTATUS
SCCMN50M_VendorIoctl (
                     PSMARTCARD_EXTENSION SmartcardExtension
                     );

VOID
SCCMN50M_CloseSerialDriver(
                          IN PDEVICE_OBJECT DeviceObject
                          );

NTSTATUS
DriverEntry(
           IN  PDRIVER_OBJECT  DriverObject,
           IN  PUNICODE_STRING RegistryPath
           );

VOID
MemSet(PUCHAR pbBuffer,
       ULONG  ulBufferSize,
       UCHAR  ucPattern,
       ULONG  ulCount);

VOID
MemCpy(PUCHAR pbDestination,
       ULONG  ulDestinationLen,
       PUCHAR pbSource,
       ULONG  ulCount);

NTSTATUS Wait (
              IN PSMARTCARD_EXTENSION pSmartcardExtension,
              IN ULONG ulMilliseconds
              );








NTSTATUS
SCCMN50M_ReadCardMan  (
                      IN PSMARTCARD_EXTENSION pSmartcardExtension,
                      IN ULONG ulBytesToRead,
                      OUT PULONG pulBytesRead,
                      IN PUCHAR pbReadBuffer,
                      IN ULONG ulReadBufferSize
                      );

NTSTATUS
SCCMN50M_WriteCardMan (
                      IN PSMARTCARD_EXTENSION SmartcardExtension,
                      ULONG BytesToWrite,
                      PUCHAR pWriteBuffer
                      );
NTSTATUS
SCCMN50M_SerialIo(
                 IN PSMARTCARD_EXTENSION SmartcardExtension
                 );

NTSTATUS
SCCMN50M_SetWrite (
                  IN PSMARTCARD_EXTENSION pSmartcardExtension,
                  IN ULONG ulBytesToWrite,
                  IN PUCHAR pbWriteBuffer
                  );


NTSTATUS
SCCMN50M_SetRead(
                IN PSMARTCARD_EXTENSION pSmartcardExtension,
                IN ULONG ulBytesToRead
                );


NTSTATUS
SCCMN50M_PurgeComm (
                   IN PSMARTCARD_EXTENSION SmartcardExtension
                   );

NTSTATUS
SCCMN50M_GetCommStatus(
                      IN PSMARTCARD_EXTENSION SmartcardExtension
                      );

NTSTATUS
SCCMN50M_ResyncCardManII (
                         IN PSMARTCARD_EXTENSION SmartcardExtension
                         );

BOOLEAN
SCCMN50M_IOOperationFailed(
                          IN PSMARTCARD_EXTENSION pSmartcardExtension
                          );


NTSTATUS
SCCMN50M_StartCardTracking (
                           PDEVICE_EXTENSION pDeviceExtension
                           );


NTSTATUS
SCCMN50M_InitCommPort (
                      PSMARTCARD_EXTENSION   pSmartcardExtension
                      );

NTSTATUS
SCCMN50M_GetDeviceDescription (
                              PSMARTCARD_EXTENSION   pSmartcardExtension
                              );


NTSTATUS
SCCMN50M_InitializeCardMan (
                           IN PSMARTCARD_EXTENSION SmartcardExtension
                           );

NTSTATUS
SCCMN50M_SetRTS (
                PSMARTCARD_EXTENSION pSmartcardExtension
                );

NTSTATUS
SCCMN50M_SetDTR (
                PSMARTCARD_EXTENSION pSmartcardExtension
                );


NTSTATUS
SCCMN50M_TransmitT0 (
                    PSMARTCARD_EXTENSION pSmartcardExtension
                    );

NTSTATUS
SCCMN50M_TransmitT1 (
                    PSMARTCARD_EXTENSION pSmartcardExtension
                    );

NTSTATUS
SCCMN50M_Transmit (
                  PSMARTCARD_EXTENSION pSmartcardExtension
                  );


NTSTATUS
SCCMN50M_EnterTransparentMode (
                              IN PSMARTCARD_EXTENSION pSmartcardExtension
                              );

NTSTATUS
SCCMN50M_ExitTransparentMode (
                             IN PSMARTCARD_EXTENSION pSmartcardExtension
                             );

VOID
SCCMN50M_InverseBuffer (
                       PUCHAR pbBuffer,
                       ULONG  ulBufferSize
                       );

NTSTATUS
SCCMN50M_ResyncCardManI (
                        IN PSMARTCARD_EXTENSION SmartcardExtension
                        );


NTSTATUS
SCCMN50M_SetBRK (
                PSMARTCARD_EXTENSION pSmartcardExtension
                );

NTSTATUS
SCCMN50M_ClearBRK (
                  PSMARTCARD_EXTENSION pSmartcardExtension
                  );

NTSTATUS
SCCMN50M_ClearRTS (
                  PSMARTCARD_EXTENSION pSmartcardExtension
                  );


NTSTATUS
SCCMN50M_PowerOff (
                  IN PSMARTCARD_EXTENSION pSmartcardExtension
                  );

NTSTATUS
SCCMN50M_PowerOn (
                 IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                 OUT   PULONG pulAtrLength,
                 OUT   PUCHAR pbAtrBuffer,
                 IN    ULONG  ulAtrBufferSize
                 );

NTSTATUS
SCCMN50M_CardPower (
                   IN PSMARTCARD_EXTENSION pSmartcardExtension
                   );


NTSTATUS
SCCMN50M_UseParsingStrategy (
                            IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                            OUT   PULONG pulAtrLength,
                            OUT   PUCHAR pbAtrBuffer,
                            IN    ULONG  ulAtrBufferSize
                            );


NTSTATUS
SCCMN50M_UseColdWarmResetStrategy (
                                  IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                                  OUT   PULONG pulAtrLength,
                                  OUT   PUCHAR pbAtrBuffer,
                                  IN    ULONG  ulAtrBufferSize,
                                  IN    BOOLEAN fWarmReset
                                  );


BOOLEAN
SCCMN50M_IsAtrValid (
                    PUCHAR pbAtrBuffer,
                    ULONG  ulAtrLength
                    );


NTSTATUS
SCCMN50M_SetProtocol (
                     PSMARTCARD_EXTENSION pSmartcardExtension
                     );

NTSTATUS
SCCMN50M_CardTracking (
                      PSMARTCARD_EXTENSION pSmartcardExtension
                      );


NTSTATUS
SCCMN50M_IoCtlVendor (
                     PSMARTCARD_EXTENSION SmartcardExtension
                     );



NTSTATUS
SCCMN50M_SetHighSpeed_CR80S_SAMOS (
                                  IN PSMARTCARD_EXTENSION pSmartcardExtension
                                  );

NTSTATUS
SCCMN50M_GetFWVersion (
                      IN PSMARTCARD_EXTENSION pSmartcardExtension
                      );

NTSTATUS
SCCMN50M_ReadDeviceDescription (
                               IN PSMARTCARD_EXTENSION pSmartcardExtension
                               );

BOOLEAN
SCCMN50M_IsAsynchronousSmartCard (
                                 IN PSMARTCARD_EXTENSION pSmartcardExtension
                                 );


NTSTATUS
SCCMN50M_SetFl_1Dl_3(IN PSMARTCARD_EXTENSION pSmartcardExtension );

NTSTATUS
SCCMN50M_SetFl_1Dl_1(IN PSMARTCARD_EXTENSION pSmartcardExtension );


// synchronous smart cards
NTSTATUS
SCCMN50M_SyncCardPowerOn (
                         IN  PSMARTCARD_EXTENSION pSmartcardExtension
                         );

NTSTATUS
SCCMN50M_SetSyncParameters (
                           IN PSMARTCARD_EXTENSION pSmartcardExtension
                           );

UCHAR
SCCMN50M_CalcTxControlByte (
                           IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                           IN ULONG                 ulBitsToWrite
                           );

UCHAR
SCCMN50M_CalcTxLengthByte (
                          IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                          IN ULONG                 ulBitsToWrite
                          );

UCHAR
SCCMN50M_CalcRxControlByte (
                           IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                           IN ULONG                 ulBitsToRead
                           );

UCHAR
SCCMN50M_CalcRxLengthByte (
                          IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                          IN ULONG                 ulBitsToRead
                          );


NTSTATUS
SCCMN50M_ResetCard2WBP (
                       IN PSMARTCARD_EXTENSION pSmartcardExtension
                       );

NTSTATUS
SCCMN50M_Transmit2WBP (
                      IN PSMARTCARD_EXTENSION pSmartcardExtension
                      );

NTSTATUS
SCCMN50M_Transmit3WBP (
                      IN PSMARTCARD_EXTENSION pSmartcardExtension
                      );


NTSTATUS
SCCMN50M_UseSyncStrategy (
                         IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                         OUT   PULONG pulAtrLength,
                         OUT   PUCHAR pbAtrBuffer,
                         IN    ULONG  ulAtrBufferSize
                         );

VOID
SCCMN50M_Shift_Msg (
                   PUCHAR  pbBuffer,
                   ULONG   ulMsgLen
                   );



VOID SCCMN50M_CheckAtrModified (
                               IN OUT PUCHAR pbBuffer,
                               IN ULONG  ulBufferSize
                               );


#endif

/*****************************************************************************
* History:
* $Log: sccmn50m.h $
* Revision 1.3  2000/07/28 09:24:13  TBruendl
* Changes for OMNIKEY on Whistler CD
*
* Revision 1.8  2000/06/28 08:47:33  TBruendl
* R03_0_1_1
*
* Revision 1.7  2000/06/27 11:56:29  TBruendl
* workaraound for SAMOR smart cards with invalid ATR (ITSEC)
*
* Revision 1.6  2000/05/23 09:58:27  TBruendl
* OMNIKEY 3.0.0.1
*
* Revision 1.5  2000/03/01 09:32:06  TBruendl
* R02.20.0
*
* Revision 1.4  1999/12/13 07:57:30  TBruendl
* build number increased
*
* Revision 1.3  1999/07/12 12:50:10  TBruendl
* new version information
*
* Revision 1.2  1999/06/10 09:03:58  TBruendl
* No comment given
*
* Revision 1.1  1999/02/02 13:34:39  TBruendl
* This is the first release (R01.00) of the IFD handler for CardMan running under NT5.0.
*
*
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\sccmn50m\sccmcb.c ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbs0/sw/sccmn50m.ms/rcs/sccmcb.c $
* $Revision: 1.7 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/

#include <stdio.h>
#include <strsafe.h>
#include "sccmn50m.h"




static ULONG dataRatesSupported[]      = {9600,38400};
static ULONG CLKFrequenciesSupported[] = {4000,5000};


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_CardPower(PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status = STATUS_SUCCESS;
    NTSTATUS DebugStatus = STATUS_SUCCESS;
    UCHAR  pbAtrBuffer[MAXIMUM_ATR_LENGTH];
    UCHAR  abSyncAtrBuffer[MAXIMUM_ATR_LENGTH];
    ULONG  ulAtrLength;
    KIRQL  irql;
#if DBG
    ULONG i;
#endif;



    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!CardPower: Enter\n",
                    DRIVER_NAME)
                  );

#if DBG
    switch (pSmartcardExtension->MinorIoControlCode) {
    case SCARD_WARM_RESET:
        SmartcardDebug(
                      DEBUG_ATR,
                      ( "%s!SCARD_WARM_RESTART\n",
                        DRIVER_NAME)
                      );
        break;
    case SCARD_COLD_RESET:
        SmartcardDebug(
                      DEBUG_ATR,
                      ( "%s!SCARD_COLD_RESTART\n",
                        DRIVER_NAME)
                      );
        break;
    case SCARD_POWER_DOWN:
        SmartcardDebug(
                      DEBUG_ATR,
                      ( "%s!SCARD_POWER_DOWN\n",
                        DRIVER_NAME)
                      );
        break;
    }
#endif



    switch (pSmartcardExtension->MinorIoControlCode) {
    case SCARD_WARM_RESET:
    case SCARD_COLD_RESET:
        status = SCCMN50M_PowerOn(pSmartcardExtension,
                                  &ulAtrLength,
                                  pbAtrBuffer,
                                  sizeof(pbAtrBuffer));
        if (status != STATUS_SUCCESS) {
            goto ExitReaderPower;
        }
        if (ulAtrLength > MAXIMUM_ATR_LENGTH) {
            status = STATUS_UNRECOGNIZED_MEDIA;
            goto ExitReaderPower;
        }

        pSmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)ulAtrLength;

        if (pSmartcardExtension->ReaderExtension->fRawModeNecessary == FALSE) {
            // copy ATR to smart card structure
            // the lib needs the ATR for evaluation of the card parameters

            MemCpy(pSmartcardExtension->CardCapabilities.ATR.Buffer,
                   sizeof(pSmartcardExtension->CardCapabilities.ATR.Buffer),
                   pbAtrBuffer,
                   ulAtrLength);

            pSmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)ulAtrLength;

            KeAcquireSpinLock(&pSmartcardExtension->OsData->SpinLock,
                              &irql);
            pSmartcardExtension->ReaderCapabilities.CurrentState = SCARD_NEGOTIABLE;
            pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            KeReleaseSpinLock(&pSmartcardExtension->OsData->SpinLock,
                              irql);

            status = SmartcardUpdateCardCapabilities(pSmartcardExtension);
            if (status != STATUS_SUCCESS) {
                goto ExitReaderPower;
            }

            // add extra guard time value to card stop bits
            pSmartcardExtension->ReaderExtension->CardManConfig.CardStopBits   = (UCHAR)(pSmartcardExtension->CardCapabilities.N);

            // copy ATR to user space
            MemCpy(pSmartcardExtension->IoRequest.ReplyBuffer,
                   pSmartcardExtension->IoRequest.ReplyBufferLength,
                   pbAtrBuffer,
                   ulAtrLength);

            *pSmartcardExtension->IoRequest.Information = ulAtrLength;
#if DBG
            SmartcardDebug(DEBUG_ATR,
                           ("%s!ATR : ",
                            DRIVER_NAME));
            for (i = 0;i < ulAtrLength;i++) {
                SmartcardDebug(DEBUG_ATR,
                               ("%2.2x ",
                                pSmartcardExtension->CardCapabilities.ATR.Buffer[i]));
            }
            SmartcardDebug(DEBUG_ATR,("\n"));

#endif

        } else {

            if (ulAtrLength > MAXIMUM_ATR_LENGTH - 2) {
                status = STATUS_UNRECOGNIZED_MEDIA;
                goto ExitReaderPower;
            }
            abSyncAtrBuffer[0] = 0x3B;
            abSyncAtrBuffer[1] = 0x04;
            MemCpy(&abSyncAtrBuffer[2],
                   sizeof(abSyncAtrBuffer)-2,
                   pbAtrBuffer,
                   ulAtrLength);


            ulAtrLength += 2;

            MemCpy(pSmartcardExtension->CardCapabilities.ATR.Buffer,
                   sizeof(pSmartcardExtension->CardCapabilities.ATR.Buffer),
                   abSyncAtrBuffer,
                   ulAtrLength);

            pSmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)(ulAtrLength);
            
            KeAcquireSpinLock(&pSmartcardExtension->OsData->SpinLock,
                              &irql);
            pSmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
            pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;
            KeReleaseSpinLock(&pSmartcardExtension->OsData->SpinLock,
                              irql);

            status = SmartcardUpdateCardCapabilities(pSmartcardExtension);
            if (status != STATUS_SUCCESS) {
                goto ExitReaderPower;
            }
            SmartcardDebug(DEBUG_ATR,("ATR of synchronous smart card : %2.2x %2.2x %2.2x %2.2x\n",
                                      pbAtrBuffer[0],pbAtrBuffer[1],pbAtrBuffer[2],pbAtrBuffer[3]));
            pSmartcardExtension->ReaderExtension->SyncParameters.fCardResetRequested = TRUE;

            // copy ATR to user space
            MemCpy(pSmartcardExtension->IoRequest.ReplyBuffer,
                   pSmartcardExtension->IoRequest.ReplyBufferLength,
                   abSyncAtrBuffer,
                   ulAtrLength);

            *pSmartcardExtension->IoRequest.Information = ulAtrLength;
        }

        break;

    case SCARD_POWER_DOWN:
        status = SCCMN50M_PowerOff(pSmartcardExtension);
        if (status != STATUS_SUCCESS) {
            goto ExitReaderPower;
        }


        KeAcquireSpinLock(&pSmartcardExtension->OsData->SpinLock,
                          &irql);

        pSmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
        pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

        KeReleaseSpinLock(&pSmartcardExtension->OsData->SpinLock,
                          irql);


        break;
    }



    ExitReaderPower:

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!CardPower: Exit %lx\n",
                    DRIVER_NAME,status)
                  );
    return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_PowerOn (
                 IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                 OUT   PULONG pulAtrLength,
                 OUT   PUCHAR pbAtrBuffer,
                 IN    ULONG  ulAtrBufferSize
                 )
{
    NTSTATUS status;
    NTSTATUS DebugStatus;


   // We always use 0x80 for reset delay
    pSmartcardExtension->ReaderExtension->CardManConfig.ResetDelay = 0x80;


    if (SCCMN50M_IsAsynchronousSmartCard(pSmartcardExtension) == TRUE) {
        if (pSmartcardExtension->MinorIoControlCode == SCARD_COLD_RESET) {
            status = SCCMN50M_UseColdWarmResetStrategy(pSmartcardExtension,
                                                       pulAtrLength,
                                                       pbAtrBuffer,
                                                       ulAtrBufferSize,
                                                       FALSE);
         // if cold reset was not succesfull ,it maybe a SAMOS card with the sensor bug
            if (status != STATUS_SUCCESS) {
                status = SCCMN50M_UseColdWarmResetStrategy(pSmartcardExtension,
                                                           pulAtrLength,
                                                           pbAtrBuffer,
                                                           ulAtrBufferSize,
                                                           TRUE);

                if (status != STATUS_SUCCESS) {
                    status = SCCMN50M_UseParsingStrategy(pSmartcardExtension,
                                                         pulAtrLength,
                                                         pbAtrBuffer,
                                                         ulAtrBufferSize);
                }
            }
        } else {
            status = SCCMN50M_UseColdWarmResetStrategy(pSmartcardExtension,
                                                       pulAtrLength,
                                                       pbAtrBuffer,
                                                       ulAtrBufferSize,
                                                       TRUE);
            if (status != STATUS_SUCCESS) {
                status = SCCMN50M_UseParsingStrategy(pSmartcardExtension,
                                                     pulAtrLength,
                                                     pbAtrBuffer,
                                                     ulAtrBufferSize);
            }
        }
    } else {
        SmartcardDebug(DEBUG_ATR,
                       ("check if synchronous smart card is inserted\n"));
      // try to find a synchronous smart card
        status = SCCMN50M_UseSyncStrategy(pSmartcardExtension,
                                          pulAtrLength,
                                          pbAtrBuffer,
                                          ulAtrBufferSize);
    }




    if (status != STATUS_SUCCESS) {
      // smart card not powered
        status = STATUS_UNRECOGNIZED_MEDIA;
        *pulAtrLength = 0;
        DebugStatus = SCCMN50M_PowerOff(pSmartcardExtension);
        return status;
    } else {
      // add extra guard time value to card stop bits
        pSmartcardExtension->ReaderExtension->CardManConfig.CardStopBits   = (UCHAR)(pSmartcardExtension->CardCapabilities.N);
        return status;
    }

}







/*****************************************************************************
Routine Description:
This routine inverts the buffer
Bit0 -> Bit 7
Bit1 -> Bit 6
Bit2 -> Bit 5
Bit3 -> Bit 4
Bit4 -> Bit 3
Bit5 -> Bit 2
Bit6 -> Bit 1
Bit7 -> Bit 0


Arguments: pbBuffer     ... pointer to buffer
           ulBufferSize ... size of buffer


Return Value: none

*****************************************************************************/
VOID SCCMN50M_InverseBuffer (
                            PUCHAR pbBuffer,
                            ULONG  ulBufferSize
                            )
{
    ULONG i;
    ULONG j;
    ULONG m;
    ULONG n;

    for (i=0; i<ulBufferSize; i++) {
        n = 0;
        for (j=1; j<=8; j++) {
            m  = (pbBuffer[i] << j);
            m &= 0x00000100;
            n  |= (m >> (9-j));
        }
        pbBuffer[i] = (UCHAR)~n;
    }

    return;
}







/*****************************************************************************
Routine Description:

This function always permforms a cold reset of the smart card.
A SAMOS card with the sensor bug will not be powered by this function.


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_UseParsingStrategy (IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                             OUT   PULONG pulAtrLength,
                             OUT   PUCHAR pbAtrBuffer,
                             IN    ULONG  ulAtrBufferSize
                            )
{
    NTSTATUS status;
    NTSTATUS DebugStatus;
    UCHAR  ulCardType;
    UCHAR  ReadBuffer[SCARD_ATR_LENGTH];
    UCHAR  bAtrBytesRead[SCARD_ATR_LENGTH];
    ULONG  ulBytesRead;
    BOOLEAN    fInverseAtr = FALSE;
    ULONG  ulAtrBufferOffset = 0;
    ULONG  ulHistoricalBytes;
    ULONG  ulNextStepBytesToRead;
    ULONG  ulPrevStepBytesRead;
    ULONG  i;
    BOOLEAN    fTDxSent;
    BOOLEAN    fAtrParsed;
    BOOLEAN   fOnlyT0 = TRUE;
    ULONG  ulOldReadTotalTimeoutMultiplier;


   // DBGBreakPoint();

   // set ReadTotalTimeoutMultiplier to 250ms (9600 * 372/f = initial waiting time)
    ulOldReadTotalTimeoutMultiplier  = pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier;
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier = 250;



    pSmartcardExtension->ReaderExtension->CardManConfig.CardStopBits = 0x02;

    for (ulCardType = ASYNC3_CARD;ulCardType <= ASYNC5_CARD;ulCardType++) {
      // power off + resync
        status = SCCMN50M_PowerOff(pSmartcardExtension);
        if (status != STATUS_SUCCESS) {
            goto ExitUseParsingStrategy;
        }


        SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ALL_FLAGS);
        SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY);

        if (ulCardType == ASYNC3_CARD)
            SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ);
        else
            SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ);


        SCCMN50M_SetCardManHeader(pSmartcardExtension,
                                  0,
                                  0,
                                  0,
                                  2);  // TS and T0  expected

        SmartcardDebug(DEBUG_ATR,
                       ("%s!ResetDelay = %d\n",
                        DRIVER_NAME,
                        pSmartcardExtension->ReaderExtension->CardManConfig.ResetDelay));

      // write config + header
        status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
        if (status != STATUS_SUCCESS) {
            goto ExitUseParsingStrategy;
        }


      // read state and length + TS + T0
        status = SCCMN50M_ReadCardMan(pSmartcardExtension,4,&ulBytesRead,ReadBuffer,sizeof(ReadBuffer));
        if (status != STATUS_SUCCESS) {
            continue;    // try next card
        }


      // contents of read buffer
      // [0] ... state
      // [1] ... length
      // [2] ... TS
      // [3] ... T0

      // TS
        if (ReadBuffer[2] == CHAR_INV) {
            fInverseAtr = TRUE;
        }

        if (fInverseAtr)
            SCCMN50M_InverseBuffer(&ReadBuffer[3],1);

        ulHistoricalBytes = ReadBuffer[3] & 0x0F;
        ulPrevStepBytesRead = 2;

      // T0 codes following TA1 - TD1

        fAtrParsed = TRUE;
        SmartcardDebug(DEBUG_ATR,
                       ("%s!Step : Bytes to read = 2\n",
                        DRIVER_NAME));


        do {
            ulNextStepBytesToRead = ulPrevStepBytesRead;
            fTDxSent = FALSE;
            if (ReadBuffer[ulBytesRead - 1 ] & 0x10)
                ulNextStepBytesToRead++;
            if (ReadBuffer[ulBytesRead - 1 ] & 0x20)
                ulNextStepBytesToRead++;
            if (ReadBuffer[ulBytesRead - 1 ] & 0x40)
                ulNextStepBytesToRead++;
            if (ReadBuffer[ulBytesRead - 1 ] & 0x80) {
                ulNextStepBytesToRead++;
                fTDxSent = TRUE;
            }

            if (ulPrevStepBytesRead != 2  &&
                ReadBuffer[ulBytesRead -1 ] & 0x0f) {
                fOnlyT0 = FALSE;
            }

         // -----------------------
         // POWER OFF
         // -----------------------
         // turn power off and get state
            status = SCCMN50M_PowerOff(pSmartcardExtension);
            if (status != STATUS_SUCCESS) {
                fAtrParsed = FALSE;
                goto ExitUseParsingStrategy;    // try next card
            }

         // -----------------------
         // POWER ON
         // -----------------------
         // turn on power flag
            SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY);

            if (ulCardType == ASYNC3_CARD)
                SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ);
            else
                SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ);

            SCCMN50M_SetCardManHeader(pSmartcardExtension,
                                      0,
                                      0,
                                      0,
                                      (UCHAR)ulNextStepBytesToRead);


         // write config + header
            status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
            if (status != STATUS_SUCCESS) {
                fAtrParsed = FALSE;
                goto ExitUseParsingStrategy;    // try next card
            }



         // read state and length + TAx,TBx,TCx,TDx
            SmartcardDebug(DEBUG_ATR,
                           ("%s!Step : Bytes to read =  %ld\n",
                            DRIVER_NAME,
                            ulNextStepBytesToRead));
            status = SCCMN50M_ReadCardMan(pSmartcardExtension,2 + ulNextStepBytesToRead,&ulBytesRead,ReadBuffer,sizeof(ReadBuffer));
            if (status != STATUS_SUCCESS) {
                fAtrParsed = FALSE;
                break;    // try next card
            }
            if (fInverseAtr)
                SCCMN50M_InverseBuffer(&ReadBuffer[2],ulBytesRead-2);
            MemCpy(bAtrBytesRead,sizeof(bAtrBytesRead),&ReadBuffer[2],ulBytesRead -2);

#if  DBG
            SmartcardDebug(DEBUG_ATR,
                           ("%s!read ATR bytes: ",
                            DRIVER_NAME));
            for (i = 0;i < ulBytesRead-2;i++)
                SmartcardDebug(DEBUG_ATR,
                               ("%2.2x ",
                                bAtrBytesRead[i]));
            SmartcardDebug(DEBUG_ATR,("\n"));

#endif

            ulPrevStepBytesRead = ulBytesRead - 2;

        } while (fTDxSent == TRUE);


      // +++++++++++++++++++++++++++++++++++++++
      // now we know how long the whole ATR is
      // +++++++++++++++++++++++++++++++++++++++

      // -----------------------
      // POWER OFF
      // -----------------------
      // turn power off and get state
        status = SCCMN50M_PowerOff(pSmartcardExtension);
        if (!NT_SUCCESS(status)) {
            goto ExitUseParsingStrategy;
        }


      // -----------------------
      // POWER ON
      // -----------------------
      // turn on power flag
        SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY);

        if (ulCardType == ASYNC3_CARD)
            SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ);
        else
            SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ);

      // bug fix : old SAMOS cards have a damaged ATR
        if (bAtrBytesRead[0] == 0x3b   &&
            bAtrBytesRead[1] == 0xbf   &&
            bAtrBytesRead[2] == 0x11   &&
            bAtrBytesRead[3] == 0x00   &&
            bAtrBytesRead[4] == 0x81   &&
            bAtrBytesRead[5] == 0x31   &&
            bAtrBytesRead[6] == 0x90   &&
            bAtrBytesRead[7] == 0x73      ) {
            ulHistoricalBytes = 4;
        }


        ulNextStepBytesToRead = ulPrevStepBytesRead + ulHistoricalBytes;
        if (fOnlyT0 == FALSE)
            ulNextStepBytesToRead++;  // TCK !


        SCCMN50M_SetCardManHeader(pSmartcardExtension,
                                  0,
                                  0,
                                  0,
                                  (UCHAR)ulNextStepBytesToRead);



      // write config + header
        status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
        if (status != STATUS_SUCCESS) {
            goto ExitUseParsingStrategy;    // try next card
        }


      // read whole ATR
        SmartcardDebug(DEBUG_ATR,
                       ("%s!Step : Bytes to read =  %ld\n",
                        DRIVER_NAME,
                        ulNextStepBytesToRead));
        status = SCCMN50M_ReadCardMan(pSmartcardExtension,2+ulNextStepBytesToRead,&ulBytesRead,ReadBuffer,sizeof(ReadBuffer));
        if (!NT_SUCCESS(status)) {
            SmartcardDebug(DEBUG_ATR,
                           ("%s!Reading of whole ATR failed\n !",
                            DRIVER_NAME));
            continue;    // try next card
        }

      // check ATR
        if (ulBytesRead - 2 < MIN_ATR_LEN) {
            status = STATUS_UNRECOGNIZED_MEDIA;
            DebugStatus = SCCMN50M_ReadCardMan(pSmartcardExtension,2+ulNextStepBytesToRead,&ulBytesRead,ReadBuffer,sizeof(ReadBuffer));
            goto ExitUseParsingStrategy;
        }

        if (ulBytesRead -2 > ulAtrBufferSize) {
         // the ATR is larger then 33 bytes !!!
            status = STATUS_BUFFER_OVERFLOW;
            goto ExitUseParsingStrategy;
        }

        SCCMN50M_CheckAtrModified(pbAtrBuffer,*pulAtrLength);

      // pass ATR and ATR length to calling function
        MemCpy(pbAtrBuffer,ulAtrBufferSize,&ReadBuffer[2],ulBytesRead -2);
        *pulAtrLength = ulBytesRead -2;


        if (fInverseAtr) {
            SCCMN50M_SetCardControlFlags(pSmartcardExtension,INVERSE_DATA);
            SCCMN50M_InverseBuffer(pbAtrBuffer,*pulAtrLength);
            pSmartcardExtension->ReaderExtension->fInverseAtr = TRUE;
        } else {
            pSmartcardExtension->ReaderExtension->fInverseAtr = FALSE;
        }
        pSmartcardExtension->ReaderExtension->fRawModeNecessary = FALSE;
        break;
    }


    ExitUseParsingStrategy:
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier
    = ulOldReadTotalTimeoutMultiplier ;
    SCCMN50M_ClearSCRControlFlags(pSmartcardExtension,IGNORE_PARITY);
    SCCMN50M_ClearCardManHeader(pSmartcardExtension);
    return status;
}





/*****************************************************************************
Routine Description:


   This function performs either a cold or a warm reset depending on
   the fWarmReset parameter .



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_UseColdWarmResetStrategy  (IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                                    OUT   PULONG pulAtrLength,
                                    OUT   PUCHAR pbAtrBuffer,
                                    IN    ULONG  ulAtrBufferSize,
                                    IN    BOOLEAN   fWarmReset
                                   )
{
    NTSTATUS status;
    NTSTATUS DebugStatus;
    ULONG ulCardType;
    UCHAR  bReadBuffer[SCARD_ATR_LENGTH];
    ULONG  ulBytesRead;
    ULONG  ulOldReadTotalTimeoutMultiplier;


   //DBGBreakPoint();
   // set ReadTotalTimeoutMultiplier to 250ms (9600 * 372/f = initial waiting time)
    ulOldReadTotalTimeoutMultiplier  = pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier;
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier = 250;

    if (fWarmReset == FALSE) {
        SCCMN50M_SetCardManHeader(pSmartcardExtension,0,0,COLD_RESET,ATR_LEN_ASYNC);
    } else {
        SCCMN50M_SetCardManHeader(pSmartcardExtension,0,0,0,ATR_LEN_ASYNC);
    }

    pSmartcardExtension->ReaderExtension->CardManConfig.CardStopBits = 0x02;


    for (ulCardType = ASYNC3_CARD;ulCardType <= ASYNC5_CARD;ulCardType++) {
        SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ALL_FLAGS);

        SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY | CM2_GET_ATR);


        if (ulCardType == ASYNC3_CARD) {
            SmartcardDebug(
                          DEBUG_ATR,
                          ("%s!ASYNC_3\n",
                           DRIVER_NAME));
            SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ);
        } else {
            SmartcardDebug(
                          DEBUG_ATR,
                          ("%s!ASYN_5\n",
                           DRIVER_NAME));
            SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ);
        }


        status = SCCMN50M_ResyncCardManII(pSmartcardExtension);
        if (status != STATUS_SUCCESS) {
            goto ExitUseColdWarmResetStrategy;
        }

      // write config + header
        status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
        if (status != STATUS_SUCCESS) {
            goto ExitUseColdWarmResetStrategy;
        }


        pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;

      // read state and length
        status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
        if (status != STATUS_SUCCESS) {
            continue;    // try next card
        }


        if (bReadBuffer[1] < MIN_ATR_LEN) {
         // read all remaining bytes from the CardMan
            DebugStatus = SCCMN50M_ReadCardMan(pSmartcardExtension,bReadBuffer[1],&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
            status = STATUS_UNRECOGNIZED_MEDIA;
            goto ExitUseColdWarmResetStrategy;
        }

        if (bReadBuffer[1] > ulAtrBufferSize) {
            status = STATUS_BUFFER_OVERFLOW;
            goto ExitUseColdWarmResetStrategy;
        }

      // read ATR
        status = SCCMN50M_ReadCardMan(pSmartcardExtension,bReadBuffer[1],pulAtrLength,pbAtrBuffer,ulAtrBufferSize);
        if (status != STATUS_SUCCESS) {
            continue;
        }

        switch (pbAtrBuffer[0]) {
        case CHAR_INV:
            pSmartcardExtension->ReaderExtension->fRawModeNecessary = FALSE;
            SCCMN50M_SetCardControlFlags(pSmartcardExtension,INVERSE_DATA);
            SCCMN50M_InverseBuffer(pbAtrBuffer,*pulAtrLength);
            pSmartcardExtension->ReaderExtension->fInverseAtr = TRUE;
            break;

        case CHAR_NORM:
            pSmartcardExtension->ReaderExtension->fRawModeNecessary = FALSE;
            pSmartcardExtension->ReaderExtension->fInverseAtr = FALSE;
            break;

        default :
            status = STATUS_UNRECOGNIZED_MEDIA;
            goto ExitUseColdWarmResetStrategy;
            break;

        }

      // the smart card has been powered
        SCCMN50M_CheckAtrModified(pbAtrBuffer,*pulAtrLength);
        MemCpy(pSmartcardExtension->CardCapabilities.ATR.Buffer,
               sizeof(pSmartcardExtension->CardCapabilities.ATR.Buffer),
               pbAtrBuffer,
               *pulAtrLength);

        pSmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)*pulAtrLength;

        status = SmartcardUpdateCardCapabilities(pSmartcardExtension);
        if (status != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_ATR,
                           ("%s!Invalid ATR received\n",
                            DRIVER_NAME));
            goto ExitUseColdWarmResetStrategy;
        }
        if (SCCMN50M_IsAtrValid(pbAtrBuffer,*pulAtrLength) == FALSE) {
            SmartcardDebug(
                          DEBUG_ATR,
                          ("%s!Invalid ATR received\n",
                           DRIVER_NAME));
            status = STATUS_UNRECOGNIZED_MEDIA;
            goto ExitUseColdWarmResetStrategy;
        }
        break;
    } // end for

    ExitUseColdWarmResetStrategy:
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier
    = ulOldReadTotalTimeoutMultiplier ;
    SCCMN50M_ClearSCRControlFlags(pSmartcardExtension,CM2_GET_ATR | IGNORE_PARITY);
    SCCMN50M_ClearCardManHeader(pSmartcardExtension);
    return status;
}






/*****************************************************************************
Routine Description:

  This function checks if the received ATR is valid.


Arguments:



Return Value:

*****************************************************************************/
BOOLEAN
SCCMN50M_IsAtrValid(
                   PUCHAR pbAtrBuffer,
                   ULONG  ulAtrLength
                   )
{
    BOOLEAN  fAtrValid = TRUE;
    ULONG ulTD1Offset = 0;
    BOOLEAN  fTD1Transmitted = FALSE;
    BOOLEAN fOnlyT0 = FALSE;
    BYTE bXor;
    ULONG ulHistoricalBytes;
    ULONG ulTx2Characters = 0;
    ULONG i;

   //DBGBreakPoint();

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!IsAtrValid : Enter\n",
                    DRIVER_NAME)
                  );
   // basic checks
    if (ulAtrLength <  2             ||
        (pbAtrBuffer[0] != 0x3F &&
         pbAtrBuffer[0] != 0x3B    ) ||
        (pbAtrBuffer[1] & 0xF0)  == 0x00 ) {
        return FALSE;
    }


    if (pbAtrBuffer[1] & 0x10)
        ulTD1Offset++;
    if (pbAtrBuffer[1] & 0x20)
        ulTD1Offset++;
    if (pbAtrBuffer[1] & 0x40)
        ulTD1Offset++;

    ulHistoricalBytes = pbAtrBuffer[1] & 0x0F;

    if (pbAtrBuffer[1] & 0x80) {  // TD1 in ATR ?
        fTD1Transmitted = TRUE;

        if ((pbAtrBuffer[2 + ulTD1Offset] & 0x0F) == 0x00)  // T0 indicated ?
            fOnlyT0 = TRUE;
    } else {
        fOnlyT0 = TRUE;
    }


    if (fOnlyT0 == FALSE) {
        bXor = pbAtrBuffer[1];
        for (i=2;i<ulAtrLength;i++)
            bXor ^= pbAtrBuffer[i];

        if (bXor != 0x00)
            fAtrValid = FALSE;
    } else {
      // only T0 protocol is indicated
        if (fTD1Transmitted == TRUE) {
            if (pbAtrBuffer[2 + ulTD1Offset] & 0x10)
                ulTx2Characters++;
            if (pbAtrBuffer[2 + ulTD1Offset] & 0x20)
                ulTx2Characters++;
            if (pbAtrBuffer[2 + ulTD1Offset] & 0x40)
                ulTx2Characters++;
            if (ulAtrLength  != 2 + ulTD1Offset + 1 + ulTx2Characters + ulHistoricalBytes)
                fAtrValid = FALSE;


        } else {
            if (ulAtrLength  != 2 + ulTD1Offset + ulHistoricalBytes)
                fAtrValid = FALSE;

        }

    }




    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!IsAtrValid : Exit %d\n",
                    DRIVER_NAME,fAtrValid)
                  );
    return fAtrValid;
}


/*****************************************************************************
Routine Description:

  This function checks if the received ATR is valid.


Arguments:



Return Value:

*****************************************************************************/
VOID SCCMN50M_CheckAtrModified (
                               PUCHAR pbBuffer,
                               ULONG  ulBufferSize
                               )
{
    UCHAR bNumberHistoricalBytes;
    UCHAR bXorChecksum;
    ULONG i;

    if (ulBufferSize < 0x09)  // mininmum length of a modified ATR
        return ;               // ATR is ok


   // variant 2
    if (pbBuffer[0] == 0x3b   &&
        pbBuffer[1] == 0xbf   &&
        pbBuffer[2] == 0x11   &&
        pbBuffer[3] == 0x00   &&
        pbBuffer[4] == 0x81   &&
        pbBuffer[5] == 0x31   &&
        pbBuffer[6] == 0x90   &&
        pbBuffer[7] == 0x73   &&
        ulBufferSize == 13   ) {
      // correct number of historical bytes
        bNumberHistoricalBytes = 4;

        pbBuffer[1] &= 0xf0;
        pbBuffer[1] |= bNumberHistoricalBytes;

      // correct checksum byte
        bXorChecksum = pbBuffer[1];
        for (i=2;i<ulBufferSize-1;i++)
            bXorChecksum ^= pbBuffer[i];

        pbBuffer[ulBufferSize -1 ] = bXorChecksum;
        SmartcardDebug(DEBUG_ATR,
                       ("%s!correcting SAMOS ATR (variant 2)\n",
                        DRIVER_NAME));
    }




   // variant 1
    if (pbBuffer[0] == 0x3b   &&
        pbBuffer[1] == 0xb4   &&
        pbBuffer[2] == 0x11   &&
        pbBuffer[3] == 0x00   &&
        pbBuffer[4] == 0x81   &&
        pbBuffer[5] == 0x31   &&
        pbBuffer[6] == 0x90   &&
        pbBuffer[7] == 0x73   &&
        ulBufferSize == 13      ) {
      // correct checksum byte
        bXorChecksum = pbBuffer[1];
        for (i=2;i<ulBufferSize-1;i++)
            bXorChecksum ^= pbBuffer[i];


        if (pbBuffer[ulBufferSize -1 ] != bXorChecksum ) {
            pbBuffer[ulBufferSize -1 ] = bXorChecksum;
            SmartcardDebug(DEBUG_ATR,
                           ("%s!correcting SAMOS ATR (variant 1)\n",
                            DRIVER_NAME));

        }
    }



   // variant 3
    if (pbBuffer[0] == 0x3b   &&
        pbBuffer[1] == 0xbf   &&
        pbBuffer[2] == 0x11   &&
        pbBuffer[3] == 0x00   &&
        pbBuffer[4] == 0x81   &&
        pbBuffer[5] == 0x31   &&
        pbBuffer[6] == 0x90   &&
        pbBuffer[7] == 0x73   &&
        ulBufferSize ==  9      ) {
      // correct number of historical bytes
        bNumberHistoricalBytes = 0;

        pbBuffer[1] &= 0xf0;
        pbBuffer[1] |= bNumberHistoricalBytes;

      // correct checksum byte
        bXorChecksum = pbBuffer[1];
        for (i=2;i<ulBufferSize-1;i++)
            bXorChecksum ^= pbBuffer[i];

        pbBuffer[ulBufferSize -1 ] = bXorChecksum;
        SmartcardDebug(DEBUG_ATR,
                       ("%s!correcting SAMOS ATR (variant 3)\n",
                        DRIVER_NAME));
    }



}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_PowerOff (IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
    NTSTATUS status;
    NTSTATUS DebugStatus = STATUS_SUCCESS;
    UCHAR pReadBuffer[2];
    ULONG ulBytesRead;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!PowerOff: Enter\n",
                    DRIVER_NAME)
                  );


   // SCR control bytes
    SCCMN50M_ClearSCRControlFlags(pSmartcardExtension,CARD_POWER);
   // card control bytes
    SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ALL_FLAGS);
   // header
    SCCMN50M_SetCardManHeader(pSmartcardExtension,0,0,0,1);
   // rx length = 1 because we don't want to receive a status



   // write config + header
    status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
    if (status != STATUS_SUCCESS) {
        goto ExitSCCMN50M_PowerOff;
    }



   // CardMan echoes a BRK which is recevied in the read functions


    DebugStatus = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,pReadBuffer,sizeof(pReadBuffer));

#if 0
    if (DebugStatus != STATUS_SUCCESS)
        SmartcardDebug(
                      DEBUG_ERROR,
                      ( "%s!PowerOffBRK received\n",
                        DRIVER_NAME)
                      );
#endif


    ExitSCCMN50M_PowerOff:
    if (pSmartcardExtension->ReaderExtension->ulOldCardState == POWERED)
        pSmartcardExtension->ReaderExtension->ulOldCardState = INSERTED;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!PowerOff: Exit %lx\n",
                    DRIVER_NAME,status)
                  );
    return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_Transmit(PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status;
    NTSTATUS DebugStatus;



    switch (pSmartcardExtension->CardCapabilities.Protocol.Selected) {
    case SCARD_PROTOCOL_RAW:
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case SCARD_PROTOCOL_T0:
        status =  SCCMN50M_TransmitT0(pSmartcardExtension);
        break;

    case SCARD_PROTOCOL_T1:
        status = SCCMN50M_TransmitT1(pSmartcardExtension);
        break;

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    }

    return status;

}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_TransmitT0(PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status;
    NTSTATUS DebugStatus;
    UCHAR    bWriteBuffer[MIN_BUFFER_SIZE];
    UCHAR    bReadBuffer [MIN_BUFFER_SIZE];
    ULONG    ulWriteBufferOffset;
    ULONG    ulReadBufferOffset;
    ULONG    ulBytesToWrite;
    ULONG    ulBytesToRead;
    ULONG    ulBytesToWriteThisStep;
    ULONG    ulBytesToReadThisStep;
    ULONG    ulBytesStillToWrite;
    ULONG    ulBytesRead;
    ULONG    ulBytesStillToRead;
    BOOLEAN  fDataDirectionFromCard;
    BYTE     bProcedureByte;
    BYTE     bINS;
    BOOLEAN  fT0TransferToCard = FALSE;
    BOOLEAN  fT0TransferFromCard = FALSE;
    BOOLEAN  fSW1SW2Sent = FALSE;
    ULONG ulReadTotalTimeoutMultiplier;

    ULONG  ulStatBytesRead;
    BYTE   abStatReadBuffer[2];

   //SmartcardDebug(DEBUG_TRACE,("TransmitT0 : Enter\n"));

   //
   // Let the lib build a T=0 packet
   //
    pSmartcardExtension->SmartcardRequest.BufferLength = 0;  // no bytes additionally needed
    status = SmartcardT0Request(pSmartcardExtension);
    if (status != STATUS_SUCCESS) {
      //
      // This lib detected an error in the data to send.
      //
      // ------------------------------------------
      // ITSEC E2 requirements: clear write buffers
      // ------------------------------------------
        MemSet(bWriteBuffer,
               sizeof(bWriteBuffer),
               '\0',
               sizeof(bWriteBuffer));
        MemSet(pSmartcardExtension->SmartcardRequest.Buffer,
               pSmartcardExtension->SmartcardRequest.BufferSize,
               '\0',
               pSmartcardExtension->SmartcardRequest.BufferSize);
        return status;
    }


   // increase timeout for T0 Transmission
    ulReadTotalTimeoutMultiplier = pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier;

    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier =
    pSmartcardExtension->CardCapabilities.T0.WT/1000 + 1500;



   // ##################################
   // TRANSPARENT MODE
   // ##################################

    ulBytesStillToWrite = ulBytesToWrite = T0_HEADER_LEN + pSmartcardExtension->T0.Lc;
    ulBytesStillToRead  = ulBytesToRead  = pSmartcardExtension->T0.Le;
    if (pSmartcardExtension->T0.Lc)
        fT0TransferToCard = TRUE;
    if (pSmartcardExtension->T0.Le)
        fT0TransferFromCard = TRUE;




   // copy data to the write buffer

    MemCpy(bWriteBuffer,
           sizeof(bWriteBuffer),
           pSmartcardExtension->SmartcardRequest.Buffer,
           ulBytesToWrite);

    bINS = bWriteBuffer[1];
    if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE) {
        SCCMN50M_InverseBuffer(bWriteBuffer,ulBytesToWrite);
    }

    status = SCCMN50M_EnterTransparentMode(pSmartcardExtension);
    if (status != STATUS_SUCCESS) {
        goto ExitTransparentTransmitT0;
    }

   // STEP 1 : write config + header to enter transparent mode
    SCCMN50M_SetCardManHeader(pSmartcardExtension,
                              0,                         // Tx control
                              0,                         // Tx length
                              0,                         // Rx control
                              0);                       // Rx length

    status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                    0,
                                    NULL);
    if (NT_ERROR(status)) {
        goto ExitTransparentTransmitT0;
    }


    pSmartcardExtension->ReaderExtension->fTransparentMode = TRUE;

   // if the inserted card uses inverse convention , we must now switch the COM port
   // to odd parity
    if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE) {
        pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.StopBits   = STOP_BITS_2;
        pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.Parity     = ODD_PARITY;
        pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.WordLength = SERIAL_DATABITS_8;

        pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_LINE_CONTROL;
        RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                      &pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl,
                      sizeof(SERIAL_LINE_CONTROL));
        pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_LINE_CONTROL);
        pSmartcardExtension->SmartcardReply.BufferLength = 0;

        status =  SCCMN50M_SerialIo(pSmartcardExtension);
        if (!NT_SUCCESS(status)) {
            goto ExitTransparentTransmitT0;
        }
    }
    ulWriteBufferOffset = 0;
    ulReadBufferOffset = 0;


   // STEP 2 : write CLA INS P1 P2 Lc

    ulBytesToWriteThisStep = 5;
    status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                    ulBytesToWriteThisStep,
                                    bWriteBuffer+ulWriteBufferOffset);
    if (NT_ERROR(status)) {
        goto ExitTransparentTransmitT0;
    }
    ulWriteBufferOffset += ulBytesToWriteThisStep;
    ulBytesStillToWrite -= ulBytesToWriteThisStep;





   // STEP 2 : read procedure byte
    do {
        do {
            pSmartcardExtension->ReaderExtension->ToRHConfig= FALSE;
            status = SCCMN50M_ReadCardMan(pSmartcardExtension,1,&ulBytesRead,&bProcedureByte,sizeof(bProcedureByte));
            if (NT_ERROR(status)) {
                goto ExitTransparentTransmitT0;
            }

            if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE) {
                SCCMN50M_InverseBuffer(&bProcedureByte,ulBytesRead);
            }

         //SmartcardDebug(DEBUG_TRACE,("Procedure byte = %x\n",bProcedureByte));
         //SmartcardDebug(DEBUG_TRACE,("waiting time = %x\n",pSmartcardExtension->CardCapabilities.T0.WT));
            if (bProcedureByte == 0x60) {
            // ISO 7816-3 :
            // This byte is sent by the card to reset the work waiting time and to anticipate
            // a subsequent procedure byte
            // => we do nothing here
            }
        } while (bProcedureByte == 0x60);


      // check for ACK
        if ((bProcedureByte & 0xFE) ==  (bINS & 0xFE) ) {
            if (fT0TransferToCard) {
                ulBytesToWriteThisStep = ulBytesStillToWrite;

                if ((ulWriteBufferOffset > MIN_BUFFER_SIZE) ||
                    (MIN_BUFFER_SIZE - ulWriteBufferOffset < ulBytesToWriteThisStep)) {
                    status = STATUS_DEVICE_PROTOCOL_ERROR;
                    goto ExitTransparentTransmitT0;
                }
                status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                                ulBytesToWriteThisStep,
                                                bWriteBuffer+ulWriteBufferOffset);
                if (NT_ERROR(status)) {
                    goto ExitTransparentTransmitT0;
                }
                ulWriteBufferOffset += ulBytesToWriteThisStep;
                ulBytesStillToWrite -= ulBytesToWriteThisStep;

            }
            if (fT0TransferFromCard) {
                ulBytesToReadThisStep = ulBytesStillToRead;

                pSmartcardExtension->ReaderExtension->ToRHConfig= FALSE;

                if (ulReadBufferOffset > MIN_BUFFER_SIZE) {
                    status = STATUS_DEVICE_PROTOCOL_ERROR;
                    goto ExitTransparentTransmitT0;
                }
                status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                              ulBytesToReadThisStep,
                                              &ulBytesRead,
                                              bReadBuffer + ulReadBufferOffset,
                                              sizeof(bReadBuffer)-ulReadBufferOffset);
                if (NT_ERROR(status)) {
                    goto ExitTransparentTransmitT0;
                }
                if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE) {
                    SCCMN50M_InverseBuffer(bReadBuffer+ulReadBufferOffset,ulBytesRead);
                }

                ulReadBufferOffset += ulBytesRead;
                ulBytesStillToRead -= ulBytesRead;
            }




        }
      // check for NAK
        else if ( (~bProcedureByte & 0xFE) == (bINS & 0xFE)) {
            if (fT0TransferToCard) {
                ulBytesToWriteThisStep = 1;
                if ((ulWriteBufferOffset > MIN_BUFFER_SIZE) ||
                    (MIN_BUFFER_SIZE - ulWriteBufferOffset < ulBytesToWriteThisStep)) {
                    status = STATUS_DEVICE_PROTOCOL_ERROR;
                    goto ExitTransparentTransmitT0;
                }

                status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                                ulBytesToWriteThisStep,
                                                bWriteBuffer+ulWriteBufferOffset);
                if (NT_ERROR(status)) {
                    goto ExitTransparentTransmitT0;
                }
                ulWriteBufferOffset += ulBytesToWriteThisStep;
                ulBytesStillToWrite -= ulBytesToWriteThisStep;

            }
            if (fT0TransferFromCard) {
                ulBytesToReadThisStep = 1;

                pSmartcardExtension->ReaderExtension->ToRHConfig= FALSE;
                if (ulReadBufferOffset > MIN_BUFFER_SIZE) {
                    status = STATUS_DEVICE_PROTOCOL_ERROR;
                    goto ExitTransparentTransmitT0;
                }

                status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                              ulBytesToReadThisStep,
                                              &ulBytesRead,
                                              bReadBuffer + ulReadBufferOffset,
                                              sizeof(bReadBuffer)-ulReadBufferOffset);
                if (NT_ERROR(status)) {
                    goto ExitTransparentTransmitT0;
                }
                if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE) {
                    SCCMN50M_InverseBuffer(bReadBuffer+ulReadBufferOffset,ulBytesRead);
                }

                ulReadBufferOffset += ulBytesRead;
                ulBytesStillToRead -= ulBytesRead;
            }
        }
      // check for SW1
        else if ( (bProcedureByte > 0x60 && bProcedureByte <= 0x6F) ||
                  (bProcedureByte >= 0x90 && bProcedureByte <= 0x9F)   ) {
            pSmartcardExtension->ReaderExtension->ToRHConfig= FALSE;
            bReadBuffer[ulReadBufferOffset] = bProcedureByte;
            ulReadBufferOffset++;
            if (ulReadBufferOffset > MIN_BUFFER_SIZE) {
                status = STATUS_DEVICE_PROTOCOL_ERROR;
                goto ExitTransparentTransmitT0;
            }

            status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                          1,
                                          &ulBytesRead,
                                          bReadBuffer+ulReadBufferOffset,
                                          sizeof(bReadBuffer)-ulReadBufferOffset);
            if (NT_ERROR(status)) {
                goto ExitTransparentTransmitT0;
            }
            if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE) {
                SCCMN50M_InverseBuffer(bReadBuffer+ulReadBufferOffset,ulBytesRead);
            }
            ulReadBufferOffset += ulBytesRead;
            fSW1SW2Sent = TRUE;
        } else {
            status =  STATUS_UNSUCCESSFUL;
            goto ExitTransparentTransmitT0;
        }

    }while (!fSW1SW2Sent);


   // copy received bytes
    MemCpy(pSmartcardExtension->SmartcardReply.Buffer,
           pSmartcardExtension->SmartcardReply.BufferSize,
           bReadBuffer,
           ulReadBufferOffset);
    pSmartcardExtension->SmartcardReply.BufferLength = ulReadBufferOffset;


   // let the lib copy the received bytes to the user buffer
    status = SmartcardT0Reply(pSmartcardExtension);
    if (NT_ERROR(status)) {
        goto ExitTransparentTransmitT0;
    }





    ExitTransparentTransmitT0:
   // ------------------------------------------
   // ITSEC E2 requirements: clear write buffers
   // ------------------------------------------
    MemSet(bWriteBuffer,
           sizeof(bWriteBuffer),
           '\0',
           sizeof(bWriteBuffer));
    MemSet(pSmartcardExtension->SmartcardRequest.Buffer,
           pSmartcardExtension->SmartcardRequest.BufferSize,
           '\0',
           pSmartcardExtension->SmartcardRequest.BufferSize);

    DebugStatus = SCCMN50M_ExitTransparentMode(pSmartcardExtension);
    pSmartcardExtension->ReaderExtension->fTransparentMode = FALSE;
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier  = ulReadTotalTimeoutMultiplier;

   // to be sure that the new settings take effect
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = 250;
    DebugStatus = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT;
    if (NT_SUCCESS(DebugStatus)) {
        DebugStatus = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulStatBytesRead,abStatReadBuffer,sizeof(abStatReadBuffer));
    }
    return status;

}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_TransmitT1(PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status;
    ULONG  ulBytesToWrite;
    UCHAR  bWriteBuffer [256 + T1_HEADER_LEN + MAX_EDC_LEN];
    UCHAR  bReadBuffer [256 + T1_HEADER_LEN + MAX_EDC_LEN];
    ULONG  ulBytesRead;
    ULONG  ulBytesStillToRead;

    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant    =
    pSmartcardExtension->CardCapabilities.T1.BWT/1000;
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier  =
    pSmartcardExtension->CardCapabilities.T1.CWT/1000;

   // set T1 protocol flag for CardMan
    SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_T1);

    if (pSmartcardExtension->CardCapabilities.T1.EDC == T1_CRC_CHECK) {
        SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_CRC);
    }


    do {

        pSmartcardExtension->SmartcardRequest.BufferLength = 0;  // no bytes additionally needed


        status = SmartcardT1Request(pSmartcardExtension);
        if (status != STATUS_SUCCESS) {
            goto ExitTransmitT1;
        }

        ulBytesToWrite = pSmartcardExtension->SmartcardRequest.BufferLength;

        SCCMN50M_SetCardManHeader(pSmartcardExtension,
                                  0,                        // Tx conrol
                                  (UCHAR)ulBytesToWrite,      // Tx length
                                  0,                        // Rx control
                                  T1_HEADER_LEN);          // Rx length



        if (sizeof(bWriteBuffer) < ulBytesToWrite) {
            status = STATUS_BUFFER_OVERFLOW;
            goto ExitTransmitT1;
        }

      // copy data to the write buffer
        MemCpy(bWriteBuffer,
               sizeof(bWriteBuffer),
               pSmartcardExtension->SmartcardRequest.Buffer,
               ulBytesToWrite);


      // write data to card
        status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                        ulBytesToWrite,
                                        bWriteBuffer);
        if (status == STATUS_SUCCESS) {

         // read CardMan Header
            pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;
            status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                          2,
                                          &ulBytesRead,
                                          bReadBuffer,
                                          sizeof(bReadBuffer));
            if (status == STATUS_SUCCESS) {
                ulBytesStillToRead = bReadBuffer[1];


                status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                              ulBytesStillToRead,
                                              &ulBytesRead,
                                              bReadBuffer,
                                              sizeof(bReadBuffer));
                if (status == STATUS_SUCCESS) {
                    if (bReadBuffer[1] == T1_WTX_REQUEST) {
                        pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant =
                        (ULONG)(1000 +((pSmartcardExtension->CardCapabilities.T1.BWT*bReadBuffer[3])/1000));
                        SmartcardDebug(DEBUG_PROTOCOL,("%s!ReadTotalTimeoutConstant = %ld(ms)\n",
                                                       DRIVER_NAME,
                                                       pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant));
                    } else {
                        pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant =
                        pSmartcardExtension->CardCapabilities.T1.BWT/1000;
                        SmartcardDebug(DEBUG_PROTOCOL,("%s!ReadTotalTimeoutConstant = %ld(ms)\n",
                                                       DRIVER_NAME,
                                                       pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant));
                    }
               // copy received bytes
                    MemCpy(pSmartcardExtension->SmartcardReply.Buffer,
                           pSmartcardExtension->SmartcardReply.BufferSize,
                           bReadBuffer,
                           ulBytesRead);
                    pSmartcardExtension->SmartcardReply.BufferLength = ulBytesRead;
                }
            }
        }

        if (status != STATUS_SUCCESS) {
         // reset serial timeout
            SmartcardDebug(
                          DEBUG_PROTOCOL,
                          ( "%s!reseting timeout constant\n",
                            DRIVER_NAME)
                          );
            pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant =
            pSmartcardExtension->CardCapabilities.T1.BWT/1000;
            SmartcardDebug(DEBUG_PROTOCOL,("%s!ReadTotalTimeoutConstant = %ld(ms)\n",
                                           DRIVER_NAME,
                                           pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant));

            pSmartcardExtension->SmartcardReply.BufferLength = 0L;
        }

      // bug fix for smclib
        if (pSmartcardExtension->T1.State         == T1_IFS_RESPONSE &&
            pSmartcardExtension->T1.OriginalState == T1_I_BLOCK) {
            pSmartcardExtension->T1.State = T1_I_BLOCK;
        }

        status = SmartcardT1Reply(pSmartcardExtension);
    }
    while (status == STATUS_MORE_PROCESSING_REQUIRED);



    ExitTransmitT1:
   // ------------------------------------------
   // ITSEC E2 requirements: clear write buffers
   // ------------------------------------------
    MemSet(bWriteBuffer,
           sizeof(bWriteBuffer),
           '\0',
           sizeof(bWriteBuffer));
    MemSet(pSmartcardExtension->SmartcardRequest.Buffer,
           pSmartcardExtension->SmartcardRequest.BufferSize,
           '\0',
           pSmartcardExtension->SmartcardRequest.BufferSize);

    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier  =
    DEFAULT_READ_TOTAL_TIMEOUT_MULTIPLIER;
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant    =
    DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT;
    return status;
}








/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_InitializeSmartcardExtension(
                                     IN PSMARTCARD_EXTENSION pSmartcardExtension,
                                     IN ULONG ulDeviceInstance
                                     )
{
   // ==================================
   // Fill the Vendor_Attr structure
   // ==================================
    MemCpy(pSmartcardExtension->VendorAttr.VendorName.Buffer,
           sizeof(pSmartcardExtension->VendorAttr.VendorName.Buffer),
           ATTR_VENDOR_NAME,
           sizeof(ATTR_VENDOR_NAME)
          );

   //
   // Length of vendor name
   //
    pSmartcardExtension->VendorAttr.VendorName.Length = sizeof(ATTR_VENDOR_NAME);


   //
   // Version number
   //
    pSmartcardExtension->VendorAttr.IfdVersion.BuildNumber  = IFD_NT_BUILDNUMBER_CARDMAN;
    pSmartcardExtension->VendorAttr.IfdVersion.VersionMinor = IFD_NT_VERSIONMINOR_CARDMAN;
    pSmartcardExtension->VendorAttr.IfdVersion.VersionMajor = IFD_NT_VERSIONMAJOR_CARDMAN;


    MemCpy(pSmartcardExtension->VendorAttr.IfdType.Buffer,
           sizeof(pSmartcardExtension->VendorAttr.IfdType.Buffer),
           ATTR_IFD_TYPE_CM,
           sizeof(ATTR_IFD_TYPE_CM));

   //
   // Length of reader name
   //
    pSmartcardExtension->VendorAttr.IfdType.Length = sizeof(ATTR_IFD_TYPE_CM);



   //
   // Unit number which is zero based
   //
    pSmartcardExtension->VendorAttr.UnitNo = ulDeviceInstance;



   // ================================================
   // Fill the SCARD_READER_CAPABILITIES structure
   // ===============================================
   //
   // Supported protoclols by the reader
   //

    pSmartcardExtension->ReaderCapabilities.SupportedProtocols = SCARD_PROTOCOL_T1 | SCARD_PROTOCOL_T0;




   //
   // Reader type serial, keyboard, ....
   //
    pSmartcardExtension->ReaderCapabilities.ReaderType = SCARD_READER_TYPE_SERIAL;

   //
   // Mechanical characteristics like swallows etc.
   //
    pSmartcardExtension->ReaderCapabilities.MechProperties = 0;


   //
   // Current state of the reader
   //
    pSmartcardExtension->ReaderCapabilities.CurrentState  = SCARD_UNKNOWN;






   //
   // Data Rate
   //
    pSmartcardExtension->ReaderCapabilities.DataRate.Default =
    pSmartcardExtension->ReaderCapabilities.DataRate.Max =
    dataRatesSupported[0];


   // reader could support higher data rates
    pSmartcardExtension->ReaderCapabilities.DataRatesSupported.List =
    dataRatesSupported;
    pSmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
    sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);




   //
   // CLKFrequency
   //
    pSmartcardExtension->ReaderCapabilities.CLKFrequency.Default =
    pSmartcardExtension->ReaderCapabilities.CLKFrequency.Max =
    CLKFrequenciesSupported[0];


    pSmartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.List =
    CLKFrequenciesSupported;
    pSmartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.Entries =
    sizeof(CLKFrequenciesSupported) / sizeof(CLKFrequenciesSupported[0]);


   //pSmartcardExtension->ReaderCapabilities.CLKFrequency.Default = 3571;    //3.571 MHz
   //pSmartcardExtension->ReaderCapabilities.CLKFrequency.Max = 3571;        //3.571 MHz

   //
   // MaxIFSD
   //
    pSmartcardExtension->ReaderCapabilities.MaxIFSD = ATTR_MAX_IFSD_CARDMAN_II;





}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
MemSet(PUCHAR pBuffer,
       ULONG  ulBufferSize,
       UCHAR  ucPattern,
       ULONG  ulCount)
{
    ULONG i;

    for (i=0; i<ulCount;i++) {
        if (i >= ulBufferSize)
            break;
        pBuffer[i] = ucPattern;
    }

    return ;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
MemCpy(PUCHAR pDestination,
       ULONG  ulDestinationLen,
       PUCHAR pSource,
       ULONG ulCount)
{
    ULONG i = 0;
    while ( ulCount--  &&  ulDestinationLen-- ) {
        pDestination[i] = pSource[i];
        i++;
    }
    return;

}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_UpdateCurrentStateThread(
                                 IN PVOID Context
                                 )

{
    PDEVICE_EXTENSION    deviceExtension = Context;
    PSMARTCARD_EXTENSION smartcardExtension;
    NTSTATUS status;
    LONG lRetry;
    KIRQL irql;
    LONG  ulFailures;
    BOOLEAN fPriorityIncreased;
    LONG  lOldPriority;

    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!UpdateCurrentStateThread started\n",DRIVER_NAME));

    ulFailures = 0;
    smartcardExtension = &deviceExtension->SmartcardExtension;

   //
   // Increase priority for first loop,
   // because state of card must be known for resource manager
   //
    fPriorityIncreased=TRUE;
    lOldPriority=KeSetPriorityThread(KeGetCurrentThread(),HIGH_PRIORITY);

    do {
        KeWaitForSingleObject(&smartcardExtension->ReaderExtension->CardManIOMutex,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        if ( smartcardExtension->ReaderExtension->TimeToTerminateThread ) {
            KeReleaseMutex(&smartcardExtension->ReaderExtension->CardManIOMutex,FALSE);
            smartcardExtension->ReaderExtension->TimeToTerminateThread = FALSE;
            PsTerminateSystemThread( STATUS_SUCCESS );
        }

        lRetry = 1;



        do {
         

            status=SCCMN50M_UpdateCurrentState(smartcardExtension);
            if (NT_SUCCESS(status)) {
                break;
            } else {
                lRetry--;
            }
        }
        while (lRetry >= 0);

        if (lRetry < 0) {
            ulFailures++;
            if (ulFailures == 1) {
                SmartcardDebug(
                              DEBUG_DRIVER,
                              ( "%s!CardMan removed\n",
                                DRIVER_NAME)
                              );
            // issue a card removal event if reader  has been removed
                if (smartcardExtension->ReaderExtension->ulOldCardState == INSERTED ||
                    smartcardExtension->ReaderExtension->ulOldCardState == POWERED     ) {
                    SmartcardDebug(
                                  DEBUG_DRIVER,
                                  ( "%s!issuing card removal event\n",
                                    DRIVER_NAME)
                                  );

                    SCCMN50M_CompleteCardTracking(smartcardExtension);
                    smartcardExtension->ReaderExtension->SyncParameters.fCardPowerRequested = TRUE;

                    KeAcquireSpinLock(&smartcardExtension->OsData->SpinLock,
                                      &irql);

                    smartcardExtension->ReaderExtension->ulNewCardState = REMOVED;
                    smartcardExtension->ReaderExtension->ulOldCardState = smartcardExtension->ReaderExtension->ulNewCardState;
                    smartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
                    smartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
                    smartcardExtension->CardCapabilities.ATR.Length        = 0;

                    KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                      irql);


                    SCCMN50M_ClearCardControlFlags(smartcardExtension,ALL_FLAGS);
                    smartcardExtension->ReaderExtension->CardManConfig.CardStopBits   = 0;
                    smartcardExtension->ReaderExtension->CardManConfig.ResetDelay     = 0;
                }
            }
            if (ulFailures == 3) {
            // remove the device and terminate this thread
                if (KeReadStateEvent(&deviceExtension->SerialCloseDone) == 0l) {
                    SmartcardDebug(
                                  DEBUG_DRIVER,
                                  ( "%s!closing serial driver\n",
                                    DRIVER_NAME)
                                  );

                    SCCMN50M_CloseSerialDriver(smartcardExtension->OsData->DeviceObject);


                    KeReleaseMutex(&smartcardExtension->ReaderExtension->CardManIOMutex,FALSE);
                    smartcardExtension->ReaderExtension->TimeToTerminateThread = FALSE;
                    smartcardExtension->ReaderExtension->ThreadObjectPointer = NULL;
                    PsTerminateSystemThread( STATUS_SUCCESS );
                }
            }
        } else {
            ulFailures = 0;
        }

        KeReleaseMutex(&smartcardExtension->ReaderExtension->CardManIOMutex,FALSE);

        if (fPriorityIncreased) {
            fPriorityIncreased=FALSE;
            KeSetPriorityThread(KeGetCurrentThread(),lOldPriority);

         //
         // Lower ourselves down just at tad so that we compete a
         // little less.
         //
            KeSetBasePriorityThread(KeGetCurrentThread(),-1);
        }

      //SmartcardDebug(DEBUG_TRACE,( "...#\n"));

        Wait (smartcardExtension,500 * ms_);
    }
    while (TRUE);
}




NTSTATUS SCCMN50M_UpdateCurrentState(
                                    IN PSMARTCARD_EXTENSION smartcardExtension
                                    )
{
    NTSTATUS    NTStatus;
    UCHAR       pbReadBuffer[2];
    ULONG       ulBytesRead;
    BOOLEAN     fCardStateChanged;
    KIRQL       irql;

    fCardStateChanged = FALSE;


    SCCMN50M_ClearCardManHeader(smartcardExtension);

    smartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = 250;
    NTStatus = SCCMN50M_WriteCardMan(smartcardExtension,0,NULL);
    smartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT;
    if (NT_SUCCESS(NTStatus)) {
        NTStatus = SCCMN50M_ReadCardMan(smartcardExtension,2,&ulBytesRead,pbReadBuffer,sizeof(pbReadBuffer));

        KeAcquireSpinLock(&smartcardExtension->OsData->SpinLock,
                  &irql);

        if (ulBytesRead == 0x02      &&         // two bytes must have benn received
            (pbReadBuffer[0] & 0x0F) &&         // at least one version bit must be set
            ((pbReadBuffer[0] & 0x09) == 0x00)) { // Bit 0 and Bit 3 must be 0
            if ((pbReadBuffer[0] & 0x04) == 0x04    &&
                (pbReadBuffer[0] & 0x02) == 0x02)
                smartcardExtension->ReaderExtension->ulNewCardState = INSERTED;

            if ((pbReadBuffer[0] & 0x04) == 0x00    &&
                (pbReadBuffer[0] & 0x02) == 0x02)
                smartcardExtension->ReaderExtension->ulNewCardState = REMOVED;

            if ((pbReadBuffer[0] & 0x04) == 0x04    &&
                (pbReadBuffer[0] & 0x02) == 0x00)
                smartcardExtension->ReaderExtension->ulNewCardState = POWERED;

            if (smartcardExtension->ReaderExtension->ulNewCardState == INSERTED &&
                smartcardExtension->ReaderExtension->ulOldCardState == POWERED     ) {
            // card has been removed and reinserted within 500ms
                fCardStateChanged = TRUE;
                SmartcardDebug(DEBUG_DRIVER,( "%s!Smartcard removed and reinserted\n",DRIVER_NAME));
                smartcardExtension->ReaderExtension->ulOldCardState = REMOVED;
                smartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
                smartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

            // clear any cardspecific data
                smartcardExtension->CardCapabilities.ATR.Length = 0;
                SCCMN50M_ClearCardControlFlags(smartcardExtension,ALL_FLAGS);
                smartcardExtension->ReaderExtension->CardManConfig.CardStopBits   = 0;
                smartcardExtension->ReaderExtension->CardManConfig.ResetDelay     = 0;
            }


            if (smartcardExtension->ReaderExtension->ulNewCardState == REMOVED      &&
                (smartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN  ||
                 smartcardExtension->ReaderExtension->ulOldCardState == INSERTED ||
                 smartcardExtension->ReaderExtension->ulOldCardState == POWERED    )   ) {
            // card has been removed
                fCardStateChanged = TRUE;
                SmartcardDebug(DEBUG_DRIVER,( "%s!Smartcard removed\n",DRIVER_NAME));
                smartcardExtension->ReaderExtension->ulOldCardState = smartcardExtension->ReaderExtension->ulNewCardState;
                smartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
                smartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

            // clear any cardspecific data
                smartcardExtension->CardCapabilities.ATR.Length = 0;
                SCCMN50M_ClearCardControlFlags(smartcardExtension,ALL_FLAGS);
                smartcardExtension->ReaderExtension->CardManConfig.CardStopBits   = 0;
                smartcardExtension->ReaderExtension->CardManConfig.ResetDelay     = 0;
            }



            if (smartcardExtension->ReaderExtension->ulNewCardState  == INSERTED    &&
                (smartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN ||
                 smartcardExtension->ReaderExtension->ulOldCardState == REMOVED    )   ) {
            // card has been inserted
                fCardStateChanged = TRUE;
                SmartcardDebug(DEBUG_DRIVER,( "%s!Smartcard inserted\n",DRIVER_NAME));
                smartcardExtension->ReaderExtension->ulOldCardState = smartcardExtension->ReaderExtension->ulNewCardState;
                smartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
                smartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            }


         // state after reset of the PC (only for CardMan Power+ possible)
            if (smartcardExtension->ReaderExtension->ulNewCardState == POWERED &&
                smartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN    ) {
            // card has been inserted
                fCardStateChanged = TRUE;
                SmartcardDebug(DEBUG_DRIVER,( "%s!Smartcard inserted (and powered)\n",DRIVER_NAME));
                smartcardExtension->ReaderExtension->ulOldCardState = smartcardExtension->ReaderExtension->ulNewCardState;
                smartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
                smartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            }

            if (smartcardExtension->ReaderExtension->ulNewCardState == POWERED &&
                smartcardExtension->ReaderExtension->ulOldCardState == INSERTED     ) {
                smartcardExtension->ReaderExtension->ulOldCardState = smartcardExtension->ReaderExtension->ulNewCardState;
            }

        }

        KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                          irql);

        // complete IOCTL_SMARTCARD_IS_ABSENT or IOCTL_SMARTCARD_IS_PRESENT
        if (fCardStateChanged == TRUE) {
            SCCMN50M_CompleteCardTracking(smartcardExtension);        
        }


    }

    return NTStatus;

}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS Wait (PSMARTCARD_EXTENSION pSmartcardExtension,ULONG ulMilliseconds)
{
    NTSTATUS status = STATUS_SUCCESS;
    LARGE_INTEGER   WaitTime;


    WaitTime = RtlConvertLongToLargeInteger(ulMilliseconds * WAIT_MS);
    KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);

    return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_SetSCRControlFlags(
                           IN PSMARTCARD_EXTENSION pSmartcardExtension,
                           IN UCHAR Flags
                           )
{
    pSmartcardExtension->ReaderExtension->CardManConfig.SCRControl |= Flags;
}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_ClearSCRControlFlags(
                             IN PSMARTCARD_EXTENSION pSmartcardExtension,
                             IN UCHAR Flags
                             )
{
    pSmartcardExtension->ReaderExtension->CardManConfig.SCRControl &= ~Flags;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_SetCardControlFlags(
                            IN PSMARTCARD_EXTENSION pSmartcardExtension,
                            IN UCHAR Flags
                            )
{
    pSmartcardExtension->ReaderExtension->CardManConfig.CardControl |= Flags;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_ClearCardControlFlags(
                              IN PSMARTCARD_EXTENSION pSmartcardExtension,
                              IN UCHAR Flags
                              )
{
    pSmartcardExtension->ReaderExtension->CardManConfig.CardControl &=  ~Flags;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_ClearCardManHeader(
                           IN PSMARTCARD_EXTENSION pSmartcardExtension
                           )
{
    pSmartcardExtension->ReaderExtension->CardManHeader.TxControl      = 0x00;
    pSmartcardExtension->ReaderExtension->CardManHeader.TxLength       = 0x00;
    pSmartcardExtension->ReaderExtension->CardManHeader.RxControl      = 0x00;
    pSmartcardExtension->ReaderExtension->CardManHeader.RxLength       = 0x00;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_SetCardManHeader(
                         IN PSMARTCARD_EXTENSION pSmartcardExtension,
                         IN UCHAR TxControl,
                         IN UCHAR TxLength,
                         IN UCHAR RxControl,
                         IN UCHAR RxLength
                         )
{
    pSmartcardExtension->ReaderExtension->CardManHeader.TxControl      = TxControl;
    pSmartcardExtension->ReaderExtension->CardManHeader.TxLength       = TxLength;
    pSmartcardExtension->ReaderExtension->CardManHeader.RxControl      = RxControl;
    pSmartcardExtension->ReaderExtension->CardManHeader.RxLength       = RxLength;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_WriteCardMan (
                      IN PSMARTCARD_EXTENSION pSmartcardExtension,
                      IN ULONG ulBytesToWrite,
                      IN PUCHAR pbWriteBuffer
                      )
{
    NTSTATUS status;
    NTSTATUS DebugStatus;
    PSERIAL_STATUS  pSerialStatus;


   // ===============================================
   // Set up timeouts for following read operation
   // ===============================================
    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_TIMEOUTS;


    RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  &pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts,
                  sizeof(SERIAL_TIMEOUTS));

    pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_TIMEOUTS);
    pSmartcardExtension->SmartcardReply.BufferLength = 0;


   /*
   SmartcardDebug(DEBUG_TRACE,("ReadTotalTimeoutMultiplier = %ld\n",
                  pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier));
   SmartcardDebug(DEBUG_TRACE,("ReadTotalTimeoutConstant = %ld\n",
                  pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant));
   */
    status =  SCCMN50M_SerialIo(pSmartcardExtension);







   // ===============================================
   // write to the CardMan
   // ===============================================
    DebugStatus = SCCMN50M_SetWrite(pSmartcardExtension,ulBytesToWrite,pbWriteBuffer);


   // add pseudoboost (0x00) to write buffer for CardManII
    if (pSmartcardExtension->ReaderExtension->fTransparentMode == FALSE       ) {
        pSmartcardExtension->SmartcardRequest.Buffer[pSmartcardExtension->SmartcardRequest.BufferLength] = 0x00;
        pSmartcardExtension->SmartcardRequest.BufferLength++;
    }
    status =  SCCMN50M_SerialIo(pSmartcardExtension);



   // overwrite write buffer with '@'
    RtlFillMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  pSmartcardExtension->SmartcardRequest.BufferLength,
                  '@');



   // ===============================================
   // error checking
   // ===============================================
    DebugStatus = SCCMN50M_GetCommStatus(pSmartcardExtension);

    pSerialStatus = (PSERIAL_STATUS) pSmartcardExtension->SmartcardReply.Buffer;
    if (pSerialStatus->Errors || NT_ERROR(status)) {
        pSmartcardExtension->ReaderExtension->SerialErrors = pSerialStatus->Errors;
        if (!pSmartcardExtension->ReaderExtension->fTransparentMode            )
            DebugStatus = SCCMN50M_ResyncCardManII(pSmartcardExtension);
        goto ExitSCCMN50M_WriteCardMan;
    }




    ExitSCCMN50M_WriteCardMan:

    if (status != STATUS_SUCCESS) {
        SmartcardDebug(
                      DEBUG_TRACE,
                      ( "%s!WriteCardMan: Failed, exit %lx\n",
                        DRIVER_NAME,status)
                      );
    }

    return status;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS SCCMN50M_ResyncCardManI (IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
    NTSTATUS status;


   // SmartcardDebug(DEBUG_TRACE,("%s!ResyncCardManI: Enter\n",DRIVER_NAME))

   // clear error flags
    pSmartcardExtension->ReaderExtension->SerialErrors = 0;


   // clear any pending errors
    status = SCCMN50M_GetCommStatus(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("SCCMN50M_GetCommStatus failed !   status = %x\n",status))
        goto ExitSCCMN50M_ResyncCardManI;
    }


   // clear COM buffers
    status = SCCMN50M_PurgeComm(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("SCCMN50M_PurgeComm failed !   status = %x\n",status))
        goto ExitSCCMN50M_ResyncCardManI;
    }




   // ####################################################################
   // set break
    if (!pSmartcardExtension->ReaderExtension->fTransparentMode) {
        status = SCCMN50M_SetBRK(pSmartcardExtension);
        if (!NT_SUCCESS(status)) {
            SmartcardDebug(DEBUG_ERROR,("SetBreak failed !   status = %x\n",status))
            goto ExitSCCMN50M_ResyncCardManI;
        }
    }


   // wait 1ms
    Wait(pSmartcardExtension,1 * ms_);

   // clear RTS
    status = SCCMN50M_ClearRTS(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("SCCMN50M_ClearRTS failed !   status = %x\n",status))
        goto ExitSCCMN50M_ResyncCardManI;
    }

   // wait 2ms
    Wait(pSmartcardExtension,2 * ms_);


   // set RTS
    status = SCCMN50M_SetRTS(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("SCCMN50M_SetRTS failed !   status = %x\n",status))
        goto ExitSCCMN50M_ResyncCardManI;
    }

   // wait 1ms
    Wait(pSmartcardExtension,1 * ms_);



   // clear break

    if (!pSmartcardExtension->ReaderExtension->fTransparentMode) {
        pSmartcardExtension->ReaderExtension->BreakSet = FALSE;
        status = SCCMN50M_ClearBRK(pSmartcardExtension);
        if (!NT_SUCCESS(status)) {
            SmartcardDebug(DEBUG_ERROR,("ClearBreak failed !   status = %x\n",status))
            goto ExitSCCMN50M_ResyncCardManI;
        }
    }

   // ####################################################################

   // next write operation must send config data
    pSmartcardExtension->ReaderExtension->NoConfig       = FALSE;

   // clear COM buffers
    status = SCCMN50M_PurgeComm(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        goto ExitSCCMN50M_ResyncCardManI;
    }

   // clear any pending errors
    status = SCCMN50M_GetCommStatus(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        goto ExitSCCMN50M_ResyncCardManI;
    }


    ExitSCCMN50M_ResyncCardManI:
   //SmartcardDebug(DEBUG_TRACE,("%s!ResyncCardManI: Exit %lx\n",DRIVER_NAME,status))
    return status;
}





NTSTATUS SCCMN50M_ResyncCardManII (IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
    NTSTATUS status;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!ResyncCardManII: Enter\n",
                    DRIVER_NAME)
                  );

   // clear error flags
    pSmartcardExtension->ReaderExtension->SerialErrors = 0;


   // clear any pending errors
    status = SCCMN50M_GetCommStatus(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("SCCMN50M_GetCommStatus failed !   status = %x\n",status))
        goto ExitSCCMN50M_ResyncCardManII;
    }


   // clear COM buffers
    status = SCCMN50M_PurgeComm(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("SCCMN50M_PurgeComm failed !   status = %x\n",status))
        goto ExitSCCMN50M_ResyncCardManII;
    }



   // 150 * 0xFE
    RtlFillMemory(pSmartcardExtension->SmartcardRequest.Buffer,150,0xFE);
    pSmartcardExtension->SmartcardRequest.Buffer[150] = 0x00;
    pSmartcardExtension->SmartcardRequest.BufferLength = 151;
    pSmartcardExtension->SmartcardReply.BufferLength   =   0;

    pSmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_WRITE;

    status =  SCCMN50M_SerialIo(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        Wait(pSmartcardExtension,2 * ms_);
      // try resync once more

      // clear error flags
        pSmartcardExtension->ReaderExtension->SerialErrors = 0;

      // clear any pending errors
        status = SCCMN50M_GetCommStatus(pSmartcardExtension);
        if (!NT_SUCCESS(status)) {
            SmartcardDebug(DEBUG_ERROR,("SCCMN50M_GetCommStatus failed !   status = %x\n",status))
            goto ExitSCCMN50M_ResyncCardManII;
        }

      // clear COM buffers
        status = SCCMN50M_PurgeComm(pSmartcardExtension);
        if (!NT_SUCCESS(status)) {
            SmartcardDebug(DEBUG_ERROR,("SCCMN50M_PurgeComm failed !   status = %x\n",status))
            goto ExitSCCMN50M_ResyncCardManII;
        }


      // 150 * 0xFE
        RtlFillMemory(pSmartcardExtension->SmartcardRequest.Buffer,150,0xFE);
        pSmartcardExtension->SmartcardRequest.Buffer[150] = 0x00;
        pSmartcardExtension->SmartcardRequest.BufferLength = 151;
        pSmartcardExtension->SmartcardReply.BufferLength   =   0;

        pSmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_WRITE;
        status =  SCCMN50M_SerialIo(pSmartcardExtension);
        if (status != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_ERROR,("SCCMN50M_SerialIo failed !   status = %x\n",status))
            goto ExitSCCMN50M_ResyncCardManII;
        }
      // normally the second resync command is always successful

    }


   // clear COM buffers
    status = SCCMN50M_PurgeComm(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        goto ExitSCCMN50M_ResyncCardManII;
    }

   // clear any pending errors
    status = SCCMN50M_GetCommStatus(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        goto ExitSCCMN50M_ResyncCardManII;
    }


    ExitSCCMN50M_ResyncCardManII:

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!ResyncCardManII: Exit %lx\n",
                    DRIVER_NAME,status)
                  );

    return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SerialIo(IN PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;
    PIO_STACK_LOCATION irpNextStack;
    PUCHAR pbRequestBuffer;
    PUCHAR pbReplyBuffer;
    ULONG ulRequestBufferLength;
    ULONG ulReplyBufferLength ;

   //
   // Check if the buffers are large enough
   //
    ASSERT(pSmartcardExtension->SmartcardReply.BufferLength <=
           pSmartcardExtension->SmartcardReply.BufferSize);

    ASSERT(pSmartcardExtension->SmartcardRequest.BufferLength <=
           pSmartcardExtension->SmartcardRequest.BufferSize);

    if (pSmartcardExtension->SmartcardReply.BufferLength >
        pSmartcardExtension->SmartcardReply.BufferSize      ||
        pSmartcardExtension->SmartcardRequest.BufferLength >
        pSmartcardExtension->SmartcardRequest.BufferSize) {
        SmartcardLogError(pSmartcardExtension->OsData->DeviceObject,
                          SCCMN50M_BUFFER_TOO_SMALL,
                          NULL,
                          0);
        return STATUS_BUFFER_TOO_SMALL;
    }




   // set pointer and length of request and reply buffer
    ulRequestBufferLength = pSmartcardExtension->SmartcardRequest.BufferLength;
    pbRequestBuffer       = (ulRequestBufferLength ? pSmartcardExtension->SmartcardRequest.Buffer : NULL);

    pbReplyBuffer         = pSmartcardExtension->SmartcardReply.Buffer;
    ulReplyBufferLength   = pSmartcardExtension->SmartcardReply.BufferLength;



    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);


   //
   // Build irp to be sent to serial driver
   //
    irp = IoBuildDeviceIoControlRequest(pSmartcardExtension->ReaderExtension->SerialIoControlCode,
                                        pSmartcardExtension->ReaderExtension->AttachedDeviceObject,
                                        pbRequestBuffer,
                                        ulRequestBufferLength,
                                        pbReplyBuffer,
                                        ulReplyBufferLength,
                                        FALSE,
                                        &event,
                                        &ioStatus);


    ASSERT(irp != NULL);
    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    irpNextStack = IoGetNextIrpStackLocation(irp);

    switch (pSmartcardExtension->ReaderExtension->SerialIoControlCode) {
      //
      // The serial driver transfers data from/to irp->AssociatedIrp.SystemBuffer
      //
    case SMARTCARD_WRITE:
        irpNextStack->MajorFunction = IRP_MJ_WRITE;
        irpNextStack->Parameters.Write.Length = pSmartcardExtension->SmartcardRequest.BufferLength;
        break;


    case SMARTCARD_READ:
        irpNextStack->MajorFunction = IRP_MJ_READ;
        irpNextStack->Parameters.Read.Length = pSmartcardExtension->SmartcardReply.BufferLength;
        break;
    }


    status = IoCallDriver(pSmartcardExtension->ReaderExtension->AttachedDeviceObject,irp);


    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
        status = ioStatus.Status;
    }

    switch (pSmartcardExtension->ReaderExtension->SerialIoControlCode) {
    case SMARTCARD_READ:
        if (status == STATUS_TIMEOUT) {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s!Timeout while reading from CardMan\n",
                            DRIVER_NAME));
            //
            // STATUS_TIMEOUT isn't correctly mapped
            // to a WIN32 error, that's why we change it here
            // to STATUS_IO_TIMEOUT
            //
            status = STATUS_IO_TIMEOUT;

            pSmartcardExtension->SmartcardReply.BufferLength = 0;
        }
        break;
    }

#if 0
    if (status != STATUS_SUCCESS) {
        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!SerialIo = %lx\n",
                        DRIVER_NAME,
                        status));
    }
#endif

    return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_ReadCardMan  (
                      IN PSMARTCARD_EXTENSION pSmartcardExtension,
                      IN ULONG BytesToRead,
                      OUT PULONG pBytesRead,
                      IN PUCHAR pReadBuffer,
                      IN ULONG ReadBufferSize
                      )
{
    NTSTATUS status;
    NTSTATUS DebugStatus;
    BOOLEAN fRc;

   // check if read buffer is large enough
    ASSERT(BytesToRead <= ReadBufferSize);


    *pBytesRead = 0;   // default setting


    DebugStatus = SCCMN50M_SetRead(pSmartcardExtension,BytesToRead);

   //
   // read operation
   //
    status = SCCMN50M_SerialIo(pSmartcardExtension);
    if (status == STATUS_SUCCESS) {
        *pBytesRead = pSmartcardExtension->SmartcardReply.BufferLength;

        MemCpy(pReadBuffer,
               ReadBufferSize,
               pSmartcardExtension->SmartcardReply.Buffer,
               pSmartcardExtension->SmartcardReply.BufferLength);

      // overwrite read buffer with '@'
        MemSet(pSmartcardExtension->SmartcardReply.Buffer,
               pSmartcardExtension->SmartcardReply.BufferSize,
               '@',
               pSmartcardExtension->SmartcardReply.BufferLength);
    }

    if (status != STATUS_SUCCESS || SCCMN50M_IOOperationFailed(pSmartcardExtension)) {
        if (!pSmartcardExtension->ReaderExtension->fTransparentMode) {
            DebugStatus = SCCMN50M_ResyncCardManII(pSmartcardExtension);
        }
        goto ExitSCCMN50M_ReadCardMan;
    }


   // *****************************************
   // set CardManII to state RH Config
   // *****************************************
   // don't set CardMan to RH config if there are still bytes to be read
    if (pSmartcardExtension->ReaderExtension->ToRHConfig == TRUE) {
        pSmartcardExtension->SmartcardReply.BufferLength    = 0;

        pSmartcardExtension->SmartcardRequest.Buffer  [0] = 0x00;
        pSmartcardExtension->SmartcardRequest.Buffer  [1] = 0x00;
        pSmartcardExtension->SmartcardRequest.Buffer  [2] = 0x00;
        pSmartcardExtension->SmartcardRequest.Buffer  [3] = 0x00;
        pSmartcardExtension->SmartcardRequest.Buffer  [4] = 0x89;

        pSmartcardExtension->SmartcardRequest.BufferLength   = 5;


        pSmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_WRITE;
        status = SCCMN50M_SerialIo(pSmartcardExtension);
        if (status != STATUS_SUCCESS || SCCMN50M_IOOperationFailed(pSmartcardExtension)) {
            DebugStatus = SCCMN50M_ResyncCardManII(pSmartcardExtension);
            goto ExitSCCMN50M_ReadCardMan;
        }
    }



    ExitSCCMN50M_ReadCardMan:
   // set default value;
    pSmartcardExtension->ReaderExtension->ToRHConfig = TRUE;

    if (status != STATUS_SUCCESS) {
        SmartcardDebug(
                      DEBUG_TRACE,
                      ( "%s!ReadCardMan: Failed, exit %lx\n",
                        DRIVER_NAME,status)
                      );
    }

    return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_GetCommStatus (
                       IN PSMARTCARD_EXTENSION SmartcardExtension
                       )
{
    PSERIAL_READER_CONFIG configData = &SmartcardExtension->ReaderExtension->SerialConfigData;
    NTSTATUS status;
    PUCHAR request = SmartcardExtension->SmartcardRequest.Buffer;


    SmartcardExtension->SmartcardReply.BufferLength = SmartcardExtension->SmartcardReply.BufferSize;

    SmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_GET_COMMSTATUS;

    SmartcardExtension->SmartcardRequest.Buffer = (PUCHAR) &configData->SerialStatus;

    SmartcardExtension->SmartcardRequest.BufferLength = sizeof(SERIAL_STATUS);

    status =  SCCMN50M_SerialIo(SmartcardExtension);

   //
   // restore pointer to original request buffer
   //
    SmartcardExtension->SmartcardRequest.Buffer = request;

    return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
BOOLEAN
SCCMN50M_IOOperationFailed(PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS DebugStatus;
    PSERIAL_STATUS  pSerialStatus;

    DebugStatus = SCCMN50M_GetCommStatus(pSmartcardExtension);

    pSerialStatus = (PSERIAL_STATUS)pSmartcardExtension->SmartcardReply.Buffer;
    if (pSerialStatus->Errors)
        return TRUE;
    else
        return FALSE;
}




/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS SCCMN50M_PurgeComm (IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
    PSERIAL_READER_CONFIG configData = &pSmartcardExtension->ReaderExtension->SerialConfigData;
    NTSTATUS status;
    PUCHAR request = pSmartcardExtension->SmartcardRequest.Buffer;


    pSmartcardExtension->SmartcardReply.BufferLength = pSmartcardExtension->SmartcardReply.BufferSize;

    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_PURGE;

    pSmartcardExtension->SmartcardRequest.Buffer = (PUCHAR) &configData->PurgeMask;

    pSmartcardExtension->SmartcardRequest.BufferLength = sizeof(ULONG);

    status =  SCCMN50M_SerialIo(pSmartcardExtension);

   //
   // restore pointer to original request buffer
   //
    pSmartcardExtension->SmartcardRequest.Buffer = request;

   // under W2000 & CardMan P+ STATUS_CANCELLED may be returned

    if (status == STATUS_CANCELLED)
        status = STATUS_SUCCESS;

    return status;

}







/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetRead(IN PSMARTCARD_EXTENSION pSmartcardExtension,
                 IN ULONG ulBytesToRead
                )
{
    pSmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_READ;

    pSmartcardExtension->SmartcardRequest.BufferLength = 0;

    pSmartcardExtension->SmartcardReply.BufferLength    = ulBytesToRead;

    return  STATUS_SUCCESS;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetWrite(IN PSMARTCARD_EXTENSION pSmartcardExtension,
                  IN ULONG BytesToWrite,
                  IN PUCHAR WriteBuffer
                 )
{
    ULONG Offset = 0;
    pSmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_WRITE;

    pSmartcardExtension->SmartcardReply.BufferLength    = 0;


    if (pSmartcardExtension->ReaderExtension->fTransparentMode == FALSE) {
      // send always config string for CardManII, expect we set it manualy
      // to NoConfig = TRUE.  (note: only one time)
        if (pSmartcardExtension->ReaderExtension->NoConfig == FALSE) {
            MemCpy(pSmartcardExtension->SmartcardRequest.Buffer,
                   pSmartcardExtension->SmartcardRequest.BufferSize,
                   (PUCHAR)&pSmartcardExtension->ReaderExtension->CardManConfig,
                   sizeof(CARDMAN_CONFIG));
            Offset = 4;
        } else {
            pSmartcardExtension->ReaderExtension->NoConfig = FALSE;
        }



        MemCpy(pSmartcardExtension->SmartcardRequest.Buffer + Offset,
               pSmartcardExtension->SmartcardRequest.BufferSize - Offset,
               (PUCHAR)&pSmartcardExtension->ReaderExtension->CardManHeader,
               sizeof(CARDMAN_HEADER));
        Offset+=4;
    }


    if (BytesToWrite != 0) {
        MemCpy(pSmartcardExtension->SmartcardRequest.Buffer + Offset,
               pSmartcardExtension->SmartcardRequest.BufferSize - Offset,
               WriteBuffer,
               BytesToWrite);
    }


    pSmartcardExtension->SmartcardRequest.BufferLength   = Offset +  BytesToWrite;


    return  STATUS_SUCCESS;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_StartCardTracking(
                          PDEVICE_EXTENSION pDeviceExtension
                          )
{
    NTSTATUS status;
    HANDLE hThread;
    PSMARTCARD_EXTENSION pSmartcardExtension = &pDeviceExtension->SmartcardExtension;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!StartCardTracking: Enter\n",DRIVER_NAME));

    KeWaitForSingleObject(&pSmartcardExtension->ReaderExtension->CardManIOMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);


    if (pSmartcardExtension->ReaderExtension->ThreadObjectPointer == NULL) {

       // create thread for updating current state
        status = PsCreateSystemThread(&hThread,
                                      THREAD_ALL_ACCESS,
                                      NULL,
                                      NULL,
                                      NULL,
                                      SCCMN50M_UpdateCurrentStateThread,
                                      pDeviceExtension);

        if (!NT_ERROR(status)) {
         //
         // We've got the thread.  Now get a pointer to it.
         //
            status = ObReferenceObjectByHandle(hThread,
                                               THREAD_ALL_ACCESS,
                                               NULL,
                                               KernelMode,
                                               &pSmartcardExtension->ReaderExtension->ThreadObjectPointer,
                                               NULL);

            if (NT_ERROR(status)) {
                pSmartcardExtension->ReaderExtension->TimeToTerminateThread = TRUE;
            } else {
            //
            // Now that we have a reference to the thread
            // we can simply close the handle.
            //
                ZwClose(hThread);
            }
        } else {
        }
    }

   // Release the mutex
    KeReleaseMutex(&pSmartcardExtension->ReaderExtension->CardManIOMutex,
                   FALSE);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!StartCardTracking: Exit %lx\n",DRIVER_NAME,status));
    return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_InitCommPort (PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!InitCommPort: Enter\n",
                    DRIVER_NAME)
                  );

   // ===============================
   // clear any pending errors
   // ===============================
    status = SCCMN50M_GetCommStatus(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("SCCMN50M_GetCommStatus failed !   status = %ld\n",status))
        goto ExitInitCommPort;
    }



   // ==============================
   // set baudrate for CardMan
   // ==============================
    pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate      = 38400;


    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BAUD_RATE;
    RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  &pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate,
                  sizeof(SERIAL_BAUD_RATE));
    pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_BAUD_RATE);
    pSmartcardExtension->SmartcardReply.BufferLength = 0;

    status =  SCCMN50M_SerialIo(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_BAUDRATE failed !   status = %ld\n",status))
        goto ExitInitCommPort;
    }




   // ===============================
   // set comm timeouts
   // ===============================
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadIntervalTimeout         = DEFAULT_READ_INTERVAL_TIMEOUT;
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant    = DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT;
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier  = DEFAULT_READ_TOTAL_TIMEOUT_MULTIPLIER;
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.WriteTotalTimeoutConstant   = DEFAULT_WRITE_TOTAL_TIMEOUT_CONSTANT;
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.WriteTotalTimeoutMultiplier = DEFAULT_WRITE_TOTAL_TIMEOUT_MULTIPLIER;


    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_TIMEOUTS;
    RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  &pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts,
                  sizeof(SERIAL_TIMEOUTS));
    pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_TIMEOUTS);
    pSmartcardExtension->SmartcardReply.BufferLength = 0;

    status =  SCCMN50M_SerialIo(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_TIMEOUTS failed !   status = %x\n",status))
        goto ExitInitCommPort;
    }


   // ===============================
   // set line control
   // ===============================
    pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.StopBits   = STOP_BITS_2;
    pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.Parity     = EVEN_PARITY;
    pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.WordLength = 8;

    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_LINE_CONTROL;
    RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  &pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl,
                  sizeof(SERIAL_LINE_CONTROL));
    pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_LINE_CONTROL);
    pSmartcardExtension->SmartcardReply.BufferLength = 0;

    status =  SCCMN50M_SerialIo(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_LINE_CONTROL failed !   status = %x\n",status))
        goto ExitInitCommPort;
    }




   // ===============================
   // Set handflow
   // ===============================
    pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.XonLimit         = 0;
    pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.XoffLimit        = 0;
    pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.FlowReplace      = 0;
    pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.ControlHandShake = SERIAL_ERROR_ABORT | SERIAL_DTR_CONTROL;

    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_HANDFLOW;


    RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  &pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow,
                  sizeof(SERIAL_HANDFLOW));

    pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_HANDFLOW);
    pSmartcardExtension->SmartcardReply.BufferLength = 0;

    status =  SCCMN50M_SerialIo(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_HANDFLOW failed !   status = %x\n",status))
        goto ExitInitCommPort;
    }


   // ===============================
   //  set purge mask
   // ===============================
    pSmartcardExtension->ReaderExtension->SerialConfigData.PurgeMask =
    SERIAL_PURGE_TXABORT | SERIAL_PURGE_RXABORT |
    SERIAL_PURGE_TXCLEAR | SERIAL_PURGE_RXCLEAR;



   // ===============================
   //  set DTR
   // ===============================
    status = SCCMN50M_SetDTR(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_DRT failed !   status = %x\n",status))
        goto ExitInitCommPort;
    }

   // ===============================
   //  set RTS
   // ===============================
    status = SCCMN50M_SetRTS(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_RTS failed !   status = %x\n",status))
        goto ExitInitCommPort;
    }




    ExitInitCommPort:

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!InitCommPort: Exit %lx\n",
                    DRIVER_NAME,status)
                  );
    return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetDTR(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
    NTSTATUS status;


    pSmartcardExtension->SmartcardReply.BufferLength = 0;
    pSmartcardExtension->SmartcardRequest.BufferLength = 0;

    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_DTR;



    status =  SCCMN50M_SerialIo(pSmartcardExtension);

   // under W2000 & CardMan P+ STATUS_CANCELLED may be returned

    if (status == STATUS_CANCELLED)
        status = STATUS_SUCCESS;

    return status;

}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetRTS(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
    NTSTATUS status;


    pSmartcardExtension->SmartcardReply.BufferLength = pSmartcardExtension->SmartcardReply.BufferSize;
    pSmartcardExtension->SmartcardRequest.BufferLength = 0;

    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_RTS;



    status =  SCCMN50M_SerialIo(pSmartcardExtension);

   // under W2000 & CardMan P+ STATUS_CANCELLED may be returned

    if (status == STATUS_CANCELLED)
        status = STATUS_SUCCESS;

    return status;

}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_InitializeCardMan(IN PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status;
    UCHAR pReadBuffer[2];
    ULONG ulBytesRead;
    BOOLEAN fCardManFound = FALSE;
    PREADER_EXTENSION readerExtension = pSmartcardExtension->ReaderExtension;
    ULONG ulRetries;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!InitializeCardMan: Enter\n",
                    DRIVER_NAME)
                  );


    pSmartcardExtension->ReaderExtension->ulOldCardState = UNKNOWN;


   // ==============================================
   // CardManII
   // ==============================================
    pSmartcardExtension->ReaderExtension->NoConfig    = FALSE;
    pSmartcardExtension->ReaderExtension->ToRHConfig  = TRUE;


   // This waiting time if necessary for CardMan Power+, because
   // the pnP string may be dumped
    Wait(pSmartcardExtension,200);

    status = SCCMN50M_InitCommPort(pSmartcardExtension);
    if (status != STATUS_SUCCESS)
        goto ExitInitializeCardMan;
   //
   // init CommPort was O.K.
   // now try to find a reader
   //

   // To be sure wait make an additional wait
    Wait(pSmartcardExtension,100);

    status = SCCMN50M_ResyncCardManII(pSmartcardExtension);
    status = SCCMN50M_ResyncCardManII(pSmartcardExtension);


   // no data except config + header

    pSmartcardExtension->ReaderExtension->CardManConfig.SCRControl      = XMIT_HANDSHAKE_OFF;
    pSmartcardExtension->ReaderExtension->CardManConfig.CardControl    = 0x00;
    pSmartcardExtension->ReaderExtension->CardManConfig.CardStopBits   = 0x00;
    pSmartcardExtension->ReaderExtension->CardManConfig.ResetDelay     = 0x00;

    pSmartcardExtension->ReaderExtension->CardManHeader.TxControl      = 0x00;
    pSmartcardExtension->ReaderExtension->CardManHeader.TxLength       = 0x00;
    pSmartcardExtension->ReaderExtension->CardManHeader.RxControl      = 0x00;
    pSmartcardExtension->ReaderExtension->CardManHeader.RxLength       = 0x00;


    status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
    if (status == STATUS_SUCCESS) {
        status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,pReadBuffer,sizeof(pReadBuffer));

        if (status == STATUS_SUCCESS     &&
            ulBytesRead == 0x02          &&   // two bytes received
            pReadBuffer[0] >= 0x40       &&   // at least one version bit must be set
            pReadBuffer[1] == 0x00       &&
            ((pReadBuffer[0] & 0x09) == 0)   ) { // bit 0 and 3 must be cleared
            pSmartcardExtension->ReaderExtension->ulFWVersion = (pReadBuffer[0] >> 4) * 30 + 120;
            pSmartcardExtension->ReaderExtension->fSPESupported = FALSE;

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ( "%s!CardMan (FW %ld) found\n",
                            DRIVER_NAME,pSmartcardExtension->ReaderExtension->ulFWVersion)
                          );
            fCardManFound = TRUE;
        }
    }


    ExitInitializeCardMan:

    if (fCardManFound == TRUE)
        status =  STATUS_SUCCESS;
    else
        status = STATUS_UNSUCCESSFUL;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!InitializeCardMan: Exit %lx\n",
                    DRIVER_NAME,status)
                  );
    return status;

}







/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_EnterTransparentMode (IN PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status;

    SmartcardDebug(DEBUG_TRACE,("EnterTransparentMode : enter\n"));

   // Step 1 : Resync CardMan by RTS usage
    status = SCCMN50M_ResyncCardManI(pSmartcardExtension);
    if (status != STATUS_SUCCESS) {
        SmartcardDebug(DEBUG_ERROR,("SCCMN50M_ResyncCardManI failed !   status = %ld\n",status))
        goto ExitEnterTransparentMode;
    }

   // Step 2  : set baud rate to 9600
    pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate      = 9600;

    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BAUD_RATE;
    RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  &pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate,
                  sizeof(SERIAL_BAUD_RATE));
    pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_BAUD_RATE);
    pSmartcardExtension->SmartcardReply.BufferLength = 0;

    status =  SCCMN50M_SerialIo(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_BAUDRATE failed !   status = %ld\n",status))
        goto ExitEnterTransparentMode;
    }



    ExitEnterTransparentMode:
   // Step 3  : set ATR and DUMP_BUFFER flags
   // During normal operation these two flags can never be set at the same time
    SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CM2_GET_ATR | TO_STATE_XH);





    SmartcardDebug(DEBUG_TRACE,("EnterTransparentMode : exit\n"));
    return status;

}







/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_ExitTransparentMode (IN PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status;



    SmartcardDebug(DEBUG_TRACE,("ExitTransparentMode : enter\n"));


   // ===============================
   // clear any pending errors
   // ===============================
    status = SCCMN50M_GetCommStatus(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("SCCMN50M_GetCommStatus failed !   status = %ld\n",status))
        goto ExitExitTransparentMode;
    }


   // Step 1 : Resync CardMan by RTS usage
    status = SCCMN50M_ResyncCardManI(pSmartcardExtension);
    if (status != STATUS_SUCCESS) {
        SmartcardDebug(DEBUG_ERROR,("SCCMN50M_ResyncCardManI failed !   status = %ld\n",status))
        goto ExitExitTransparentMode;
    }

   // Step 2  : set baud rate to 38400
    pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate      = 38400;

    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BAUD_RATE;
    RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  &pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate,
                  sizeof(SERIAL_BAUD_RATE));
    pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_BAUD_RATE);
    pSmartcardExtension->SmartcardReply.BufferLength = 0;

    status =  SCCMN50M_SerialIo(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_BAUDRATE failed !   status = %ld\n",status))
        goto ExitExitTransparentMode;
    }


   // if the inserted card uses inverse convention , we must now switch the COM port
   // back to even parity
    if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE) {
        pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.StopBits   = STOP_BITS_2;
        pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.Parity     = EVEN_PARITY;
        pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.WordLength = SERIAL_DATABITS_8;

        pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_LINE_CONTROL;
        RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                      &pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl,
                      sizeof(SERIAL_LINE_CONTROL));
        pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_LINE_CONTROL);
        pSmartcardExtension->SmartcardReply.BufferLength = 0;

        status =  SCCMN50M_SerialIo(pSmartcardExtension);
        if (!NT_SUCCESS(status)) {
            SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_LINE_CONTROL failed !   status = %x\n",status))
            goto ExitExitTransparentMode;
        }
    }



    ExitExitTransparentMode:

   // Step 3  : set ATR and DUMP_BUFFER flags
   // During normal operation these two flags can never be set at the same time
    SCCMN50M_ClearSCRControlFlags(pSmartcardExtension,CM2_GET_ATR | TO_STATE_XH);



    status = SCCMN50M_ResyncCardManII(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("SCCMN50M_ResyncCardManII failed !   status = %x\n",status))
        goto ExitExitTransparentMode;
    }


    SmartcardDebug(DEBUG_TRACE,("ExitTransparentMode : exit\n"));


    return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_ClearRTS(IN PSMARTCARD_EXTENSION SmartcardExtension )
{
    NTSTATUS status;


    SmartcardExtension->SmartcardReply.BufferLength = SmartcardExtension->SmartcardReply.BufferSize;
    SmartcardExtension->SmartcardRequest.BufferLength = 0;

    SmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_CLR_RTS;



    status =  SCCMN50M_SerialIo(SmartcardExtension);


    return status;

}




/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_IoCtlVendor(PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status = STATUS_SUCCESS;
    NTSTATUS DebugStatus;
    UCHAR  pbAttrBuffer[MAXIMUM_ATR_LENGTH];
    ULONG  ulAtrLength;


    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!IoCtlVendor : Enter\n",
                    DRIVER_NAME)
                  );



    switch (pSmartcardExtension->MajorIoControlCode) {
    case CM_IOCTL_SET_READER_9600_BAUD:
        status = SCCMN50M_SetFl_1Dl_1(pSmartcardExtension);
        break;

    case CM_IOCTL_SET_READER_38400_BAUD:
        status = SCCMN50M_SetFl_1Dl_3(pSmartcardExtension);
        break;

    case CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED:
        status = SCCMN50M_SetHighSpeed_CR80S_SAMOS(pSmartcardExtension);
        break;

    case CM_IOCTL_GET_FW_VERSION:
        status = SCCMN50M_GetFWVersion(pSmartcardExtension);
        break;

    case CM_IOCTL_READ_DEVICE_DESCRIPTION:
        status = SCCMN50M_ReadDeviceDescription(pSmartcardExtension);
        break;

    case CM_IOCTL_SET_SYNC_PARAMETERS :
        status = SCCMN50M_SetSyncParameters(pSmartcardExtension);
        break;

    case CM_IOCTL_3WBP_TRANSFER :  // for SLE4428
        status = SCCMN50M_Transmit3WBP(pSmartcardExtension);
        break;

    case CM_IOCTL_2WBP_TRANSFER :  // for SLE4442
        status = SCCMN50M_Transmit2WBP(pSmartcardExtension);
        break;

    case CM_IOCTL_2WBP_RESET_CARD: // SLE4442  Reset Card
        status = SCCMN50M_ResetCard2WBP(pSmartcardExtension);
        break;

    case CM_IOCTL_SYNC_CARD_POWERON:
        status = SCCMN50M_SyncCardPowerOn(pSmartcardExtension);
        break;
    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }





    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!IoCtlVendor : Exit %lx\n",
                    DRIVER_NAME,status)
                  );
    return status;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetFl_1Dl_3(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
    NTSTATUS status = STATUS_SUCCESS;
    NTSTATUS DebugStatus;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetFl_1Dl_3 Enter\n",
                    DRIVER_NAME));

   // check if T=1 active
    if (pSmartcardExtension->CardCapabilities.Protocol.Selected !=
        SCARD_PROTOCOL_T1) {
        status = STATUS_CTL_FILE_NOT_SUPPORTED;
        goto ExitSetFl_1Dl_3;
    }

   // Fl=1
   // Dl=3
   // => 38400 Baud for 3.72 MHz

    SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ENABLE_3MHZ      | ENABLE_5MHZ     |
                                   ENABLE_3MHZ_FAST | ENABLE_5MHZ_FAST );
    SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ_FAST);


    ExitSetFl_1Dl_3:
    *pSmartcardExtension->IoRequest.Information = 0L;
    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetFl_1Dl_3  Exit\n",
                    DRIVER_NAME));
    return status;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetFl_1Dl_1(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
    NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetFl_1Dl_1 Enter\n",
                    DRIVER_NAME));
   // Fl=1
   // Dl=1
   // => 9600 for 3.72 MHz

    SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ENABLE_3MHZ      | ENABLE_5MHZ     |
                                   ENABLE_3MHZ_FAST | ENABLE_5MHZ_FAST );
    SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ);


    *pSmartcardExtension->IoRequest.Information = 0L;
    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetFl_1Dl_1  Exit\n",
                    DRIVER_NAME));
    return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_GetFWVersion (IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
    NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!GetFWVersion : Enter\n",
                    DRIVER_NAME)
                  );


    if (pSmartcardExtension->IoRequest.ReplyBufferLength  < sizeof (ULONG)) {
        status = STATUS_BUFFER_OVERFLOW;
        goto ExitGetFWVersion;
    } else {
        *(PULONG)(pSmartcardExtension->IoRequest.ReplyBuffer) =
        pSmartcardExtension->ReaderExtension->ulFWVersion;
    }


    ExitGetFWVersion:
    *pSmartcardExtension->IoRequest.Information = sizeof(ULONG);
    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!GetFWVersion : Exit %lx\n",
                    DRIVER_NAME,status)
                  );
    return status;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_ReadDeviceDescription(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT result;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!ReadDeviceDescription : Enter\n",
                    DRIVER_NAME)
                  );


    if (pSmartcardExtension->IoRequest.ReplyBufferLength  < sizeof(pSmartcardExtension->ReaderExtension->abDeviceDescription)) {
        status = STATUS_BUFFER_OVERFLOW;
        *pSmartcardExtension->IoRequest.Information = 0L;
        goto ExitReadDeviceDescription;
    } else {
        if (pSmartcardExtension->ReaderExtension->abDeviceDescription[0] == 0x00 &&
            pSmartcardExtension->ReaderExtension->abDeviceDescription[1] == 0x00    ) {
            status = SCCMN50M_GetDeviceDescription(pSmartcardExtension);
        }

        if (status == STATUS_SUCCESS) {
            result = StringCchCopy(pSmartcardExtension->IoRequest.ReplyBuffer,
                                    pSmartcardExtension->IoRequest.ReplyBufferLength,
                                    pSmartcardExtension->ReaderExtension->abDeviceDescription);
            if (FAILED(result)) {

                *pSmartcardExtension->IoRequest.Information = 0;
                status = STATUS_BUFFER_OVERFLOW;

            } else {
                size_t size;
            
                StringCchLength(pSmartcardExtension->ReaderExtension->abDeviceDescription,
                                sizeof(pSmartcardExtension->ReaderExtension->abDeviceDescription),
                                &size);
                *pSmartcardExtension->IoRequest.Information = (ULONG)size;

                pSmartcardExtension->IoRequest.Information++;

            }
        } else {
            MemSet(pSmartcardExtension->ReaderExtension->abDeviceDescription,
                   sizeof(pSmartcardExtension->ReaderExtension->abDeviceDescription),
                   0x00,
                   sizeof(pSmartcardExtension->ReaderExtension->abDeviceDescription));

            *pSmartcardExtension->IoRequest.Information = 0;
        }

    }


    ExitReadDeviceDescription:
    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!ReadDeviceDescription : Exit %lx\n",
                    DRIVER_NAME,status)
                  );
    return status;
}












/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetHighSpeed_CR80S_SAMOS (IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
    NTSTATUS status;
    NTSTATUS DebugStatus;
    UCHAR bReadBuffer[16];
    ULONG ulBytesRead;
    BYTE bCR80S_SAMOS_SET_HIGH_SPEED[4] = {0xFF,0x11,0x94,0x7A};
    ULONG ulAtrLength;
    BYTE bAtr[MAXIMUM_ATR_LENGTH];

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!SetHighSpeed_CR80S_SAMOS : Enter\n",
                    DRIVER_NAME)
                  );



    SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ENABLE_SYN      | ENABLE_T0     |
                                   ENABLE_T1 );

    SCCMN50M_SetCardManHeader(pSmartcardExtension,
                              0,                                    // Tx control
                              sizeof(bCR80S_SAMOS_SET_HIGH_SPEED),  // Tx length
                              0,                                    // Rx control
                              sizeof(bCR80S_SAMOS_SET_HIGH_SPEED)); // Rx length

    status = SCCMN50M_WriteCardMan(pSmartcardExtension,
                                   sizeof(bCR80S_SAMOS_SET_HIGH_SPEED),
                                   bCR80S_SAMOS_SET_HIGH_SPEED);
    if (status != STATUS_SUCCESS)
        goto ExitSetHighSpeed;


    pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;
    status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
    if (status != STATUS_SUCCESS)
        goto ExitSetHighSpeed;

    if (bReadBuffer[1] > sizeof(bReadBuffer)) {
        status = STATUS_BUFFER_OVERFLOW;
        goto ExitSetHighSpeed;
    }

    status = SCCMN50M_ReadCardMan(pSmartcardExtension,bReadBuffer[1],&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
    if (status != STATUS_SUCCESS)
        goto ExitSetHighSpeed;

   // if the card has accepted this string , the string is echoed
    if (bReadBuffer[0] == bCR80S_SAMOS_SET_HIGH_SPEED[0]  &&
        bReadBuffer[1] == bCR80S_SAMOS_SET_HIGH_SPEED[1]  &&
        bReadBuffer[2] == bCR80S_SAMOS_SET_HIGH_SPEED[2]  &&
        bReadBuffer[3] == bCR80S_SAMOS_SET_HIGH_SPEED[3]      ) {
        SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ENABLE_3MHZ      | ENABLE_5MHZ     |
                                       ENABLE_3MHZ_FAST | ENABLE_5MHZ_FAST );

        SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ_FAST);
    } else {
        DebugStatus = SCCMN50M_PowerOff(pSmartcardExtension);

        DebugStatus = SCCMN50M_PowerOn(pSmartcardExtension,&ulAtrLength,bAtr,sizeof(bAtr));
        status = STATUS_UNSUCCESSFUL;

    }




    ExitSetHighSpeed:
    *pSmartcardExtension->IoRequest.Information = 0L;
    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!SetHighSpeed_CR80S_SAMOS : Exit %lx\n",
                    DRIVER_NAME,status)
                  );
    return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetBRK(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
    NTSTATUS status;


    pSmartcardExtension->SmartcardReply.BufferLength = pSmartcardExtension->SmartcardReply.BufferSize;
    pSmartcardExtension->SmartcardRequest.BufferLength = 0;

    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BREAK_ON;



    status =  SCCMN50M_SerialIo(pSmartcardExtension);


    return status;

}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_ClearBRK(IN PSMARTCARD_EXTENSION SmartcardExtension )
{
    NTSTATUS status;


    SmartcardExtension->SmartcardReply.BufferLength = SmartcardExtension->SmartcardReply.BufferSize;
    SmartcardExtension->SmartcardRequest.BufferLength = 0;

    SmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BREAK_OFF;



    status =  SCCMN50M_SerialIo(SmartcardExtension);


    return status;

}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetProtocol(PSMARTCARD_EXTENSION pSmartcardExtension )
{
    NTSTATUS status;
    NTSTATUS DebugStatus;
    ULONG ulNewProtocol;
    UCHAR abPTSRequest[4];
    UCHAR abReadBuffer[6];
    UCHAR abPTSReply [4];
    ULONG ulBytesRead;
    UCHAR bTemp;
    ULONG ulPtsType;
    ULONG ulPTSReplyLength=0;
    ULONG  ulStatBytesRead;
    BYTE   abStatReadBuffer[2];
    KIRQL irql;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!SetProtocol : Enter\n",
                    DRIVER_NAME)
                  );


   //
   // Check if the card is already in specific state
   // and if the caller wants to have the already selected protocol.
   // We return success if this is the case.
   //
    if ((pSmartcardExtension->CardCapabilities.Protocol.Selected & pSmartcardExtension->MinorIoControlCode)) {
        status = STATUS_SUCCESS;
        goto ExitSetProtocol;
    }

    ulNewProtocol = pSmartcardExtension->MinorIoControlCode;



    ulPtsType = PTS_TYPE_OPTIMAL;

   // we are not sure if we need this at all
    pSmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_OPTIMAL;
    while (TRUE) {

      // set initial character of PTS
        abPTSRequest[0] = 0xFF;

      // set the format character
        if (pSmartcardExtension->CardCapabilities.Protocol.Supported &
            ulNewProtocol &
            SCARD_PROTOCOL_T1) {
         // select T=1 and indicate that PTS1 follows
            abPTSRequest[1] = 0x11;
            pSmartcardExtension->CardCapabilities.Protocol.Selected =
            SCARD_PROTOCOL_T1;
        } else if (pSmartcardExtension->CardCapabilities.Protocol.Supported &
                   ulNewProtocol &
                   SCARD_PROTOCOL_T0) {
         // select T=1 and indicate that PTS1 follows
            abPTSRequest[1] = 0x10;
            pSmartcardExtension->CardCapabilities.Protocol.Selected =
            SCARD_PROTOCOL_T0;
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
            goto ExitSetProtocol;
        }

      // bug fix :
      // don 't use the suggestion from smclib
        pSmartcardExtension->CardCapabilities.PtsData.Fl =
        pSmartcardExtension->CardCapabilities.Fl;
        pSmartcardExtension->CardCapabilities.PtsData.Dl  =
        pSmartcardExtension->CardCapabilities.Dl;


      // CardMan support higher baudrates only for T=1
      // ==> Dl=1
        if (abPTSRequest[1] == 0x10) {
            SmartcardDebug(
                          DEBUG_PROTOCOL,
                          ( "%s!overwriting PTS1 for T=0\n",
                            DRIVER_NAME)
                          );
            pSmartcardExtension->CardCapabilities.PtsData.Fl = 0x01;
            pSmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
        }


        if (ulPtsType == PTS_TYPE_DEFAULT) {
            SmartcardDebug(
                          DEBUG_PROTOCOL,
                          ( "%s!overwriting PTS1 with default values\n",
                            DRIVER_NAME)
                          );
            pSmartcardExtension->CardCapabilities.PtsData.Fl = 0x01;
            pSmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
        }


      // set pts1 which codes Fl and Dl
        bTemp = (BYTE) (pSmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                        pSmartcardExtension->CardCapabilities.PtsData.Dl);

        SmartcardDebug(
                      DEBUG_PROTOCOL,
                      ( "%s!PTS1 = %x (suggestion)\n",
                        DRIVER_NAME,bTemp)
                      );


        switch (bTemp) {
        case 0x11:
            // do nothing
            // we support these Fl/Dl parameters
            break;

        case 0x13:
        case 0x94:
            break ;


        case 0x14:
            // let's try it with 38400 baud
            SmartcardDebug(
                          DEBUG_PROTOCOL,
                          ( "%s!trying 57600 baud\n",DRIVER_NAME)
                          );
            // we must correct Fl/Dl
            pSmartcardExtension->CardCapabilities.PtsData.Dl = 0x03;
            pSmartcardExtension->CardCapabilities.PtsData.Fl = 0x01;
            bTemp = (BYTE) (pSmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                            pSmartcardExtension->CardCapabilities.PtsData.Dl);
            break;

        default:
            SmartcardDebug(
                          DEBUG_PROTOCOL,
                          ( "%s!overwriting PTS1(0x%x)\n",
                            DRIVER_NAME,bTemp)
                          );
            // we must correct Fl/Dl
            pSmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
            pSmartcardExtension->CardCapabilities.PtsData.Fl = 0x01;
            bTemp = (BYTE) (pSmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                            pSmartcardExtension->CardCapabilities.PtsData.Dl);
            break;


        }

        abPTSRequest[2] = bTemp;

      // set pck (check character)
        abPTSRequest[3] = (BYTE)(abPTSRequest[0] ^ abPTSRequest[1] ^ abPTSRequest[2]);

        SmartcardDebug(DEBUG_PROTOCOL,("%s!PTS request: 0x%x 0x%x 0x%x 0x%x\n",
                                       DRIVER_NAME,
                                       abPTSRequest[0],
                                       abPTSRequest[1],
                                       abPTSRequest[2],
                                       abPTSRequest[3]));


        MemSet(abPTSReply,sizeof(abPTSReply),0x00,sizeof(abPTSReply));



        DebugStatus = SCCMN50M_EnterTransparentMode(pSmartcardExtension);

      // STEP 1 : write config + header to enter transparent mode
        SCCMN50M_SetCardManHeader(pSmartcardExtension,
                                  0,                         // Tx control
                                  0,                         // Tx length
                                  0,                         // Rx control
                                  0);                       // Rx length

        status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                        0,
                                        NULL);
        if (NT_ERROR(status)) {
            goto ExitSetProtocol;
        }


        pSmartcardExtension->ReaderExtension->fTransparentMode = TRUE;

        SmartcardDebug(
                      DEBUG_PROTOCOL,
                      ( "%s!writing PTS request\n",
                        DRIVER_NAME)
                      );
        status = SCCMN50M_WriteCardMan(pSmartcardExtension,
                                       4,
                                       abPTSRequest);
        if (status != STATUS_SUCCESS) {
            SmartcardDebug(
                          DEBUG_PROTOCOL,
                          ( "%s!writing PTS request failed\n",
                            DRIVER_NAME)
                          );
            goto ExitSetProtocol;
        }



      // read back pts data
        SmartcardDebug(
                      DEBUG_PROTOCOL,
                      ( "%s!trying to read PTS reply\n",
                        DRIVER_NAME)
                      );


      // first read CardMan header
        pSmartcardExtension->ReaderExtension->ToRHConfig= FALSE;
        status = SCCMN50M_ReadCardMan(pSmartcardExtension,3,&ulBytesRead,abReadBuffer,sizeof(abReadBuffer));
        if (status != STATUS_SUCCESS     &&
            status != STATUS_IO_TIMEOUT      ) {
            SmartcardDebug(
                          DEBUG_PROTOCOL,
                          ( "%s!reading status failed\n",
                            DRIVER_NAME)
                          );
            goto ExitSetProtocol;
        }
        ulPTSReplyLength = 3;
        MemCpy(abPTSReply,sizeof(abPTSReply),abReadBuffer,3);



      // check if bit 5 is set
        if (abPTSReply[1] & 0x10) {
            pSmartcardExtension->ReaderExtension->ToRHConfig= FALSE;
            status = SCCMN50M_ReadCardMan(pSmartcardExtension,1,&ulBytesRead,abReadBuffer,sizeof(abReadBuffer));
            if (status != STATUS_SUCCESS     &&
                status != STATUS_IO_TIMEOUT      ) {
                SmartcardDebug(
                              DEBUG_PROTOCOL,
                              ( "%s!reading status failed\n",
                                DRIVER_NAME)
                              );
                goto ExitSetProtocol;
            }
            ulPTSReplyLength += 1;
            MemCpy(&abPTSReply[3],sizeof(abPTSReply)-3,abReadBuffer,1);
        }

        DebugStatus = SCCMN50M_ExitTransparentMode(pSmartcardExtension);
        pSmartcardExtension->ReaderExtension->fTransparentMode = FALSE;

      // to be sure that the new settings take effect
        pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = 250;
        DebugStatus = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
        pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT;
        if (NT_SUCCESS(DebugStatus)) {
            DebugStatus = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulStatBytesRead,abStatReadBuffer,sizeof(abStatReadBuffer));
        }


#if DBG
        if (ulPTSReplyLength == 3) {
            SmartcardDebug(DEBUG_PROTOCOL,("PTS reply: 0x%x 0x%x 0x%x\n",
                                           abPTSReply[0],
                                           abPTSReply[1],
                                           abPTSReply[2]));
        }

        if (ulPTSReplyLength == 4) {
            SmartcardDebug(DEBUG_PROTOCOL,("PTS reply: 0x%x 0x%x 0x%x 0x%x\n",
                                           abPTSReply[0],
                                           abPTSReply[1],
                                           abPTSReply[2],
                                           abPTSReply[3]));
        }
#endif



        if (ulPTSReplyLength == 3 &&
            abPTSReply[0] == abPTSRequest[0] &&
            (abPTSReply[1] & 0x7F) == (abPTSRequest[1] & 0x0F) &&
            abPTSReply[2] == (BYTE)(abPTSReply[0] ^ abPTSReply[1]) ) {
            SmartcardDebug(
                          DEBUG_PROTOCOL,
                          ( "%s!short PTS reply received\n",
                            DRIVER_NAME)
                          );

            break;
        }

        if (ulPTSReplyLength == 4 &&
            abPTSReply[0] == abPTSRequest[0] &&
            abPTSReply[1] == abPTSRequest[1] &&
            abPTSReply[2] == abPTSRequest[2] &&
            abPTSReply[3] == abPTSRequest[3]) {
            SmartcardDebug(
                          DEBUG_PROTOCOL,
                          ( "%s!PTS request and reply match\n",
                            DRIVER_NAME)
                          );
            switch (bTemp) {
            case 0x11:
                break;

            case 0x13:
                SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ENABLE_3MHZ      | ENABLE_5MHZ     |
                                               ENABLE_3MHZ_FAST | ENABLE_5MHZ_FAST );
                SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ_FAST);
                break ;

            case 0x94:
                SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ENABLE_3MHZ      | ENABLE_5MHZ     |
                                               ENABLE_3MHZ_FAST | ENABLE_5MHZ_FAST );
                SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ_FAST);
                break;
            }
            break;
        }

        if (pSmartcardExtension->CardCapabilities.PtsData.Type !=
            PTS_TYPE_DEFAULT) {
            SmartcardDebug(
                          DEBUG_PROTOCOL,
                          ( "%s!PTS failed : Trying default parameters\n",
                            DRIVER_NAME)
                          );


         // the card did either not reply or it replied incorrectly
         // so try default valies
            ulPtsType = pSmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_DEFAULT;
            pSmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
            status = SCCMN50M_CardPower(pSmartcardExtension);
            continue;
        }

      // the card failed the pts request
        status = STATUS_DEVICE_PROTOCOL_ERROR;
        goto ExitSetProtocol;

    }



    ExitSetProtocol:
    switch (status) {
    case STATUS_IO_TIMEOUT:
        pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
        *pSmartcardExtension->IoRequest.Information = 0;
        break;


    case STATUS_SUCCESS:

         // now indicate that we're in specific mode

        KeAcquireSpinLock(&pSmartcardExtension->OsData->SpinLock,
                          &irql);

        pSmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;

        KeReleaseSpinLock(&pSmartcardExtension->OsData->SpinLock,
                          irql);


         // return the selected protocol to the caller
        *(PULONG) pSmartcardExtension->IoRequest.ReplyBuffer =
        pSmartcardExtension->CardCapabilities.Protocol.Selected;

        *pSmartcardExtension->IoRequest.Information =
        sizeof(pSmartcardExtension->CardCapabilities.Protocol.Selected);
        SmartcardDebug(
                      DEBUG_PROTOCOL,
                      ( "%s!Selected protocol: T=%ld\n",
                        DRIVER_NAME,pSmartcardExtension->CardCapabilities.Protocol.Selected-1)
                      );
        break;

    default :
        pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
        *pSmartcardExtension->IoRequest.Information = 0;
        break;
    }



    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!SetProtocol : Exit %lx\n",
                    DRIVER_NAME,status)
                  );
    return status;
}





/*****************************************************************************
Routine Description:

   The smart card lib requires to have this function. It is called
   to setup event tracking for card insertion and removal events.

Arguments:

    pSmartcardExtension - pointer to the smart card data struct.

Return Value:

    NTSTATUS

*****************************************************************************/
NTSTATUS
SCCMN50M_CardTracking(PSMARTCARD_EXTENSION pSmartcardExtension)
{
    KIRQL oldIrql;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!CardTracking: Enter\n",
                    DRIVER_NAME)
                  );

   //
   // Set cancel routine for the notification irp
   //
    IoAcquireCancelSpinLock(&oldIrql);

    IoSetCancelRoutine(pSmartcardExtension->OsData->NotificationIrp,SCCMN50M_Cancel);

    IoReleaseCancelSpinLock(oldIrql);

   //
   // Mark notification irp pending
   //
    IoMarkIrpPending(pSmartcardExtension->OsData->NotificationIrp);

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!CardTracking: Exit\n",
                    DRIVER_NAME)
                  );

    return STATUS_PENDING;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_StopCardTracking(
                         IN PDEVICE_EXTENSION pDeviceExtension
                         )
{
    PSMARTCARD_EXTENSION pSmartcardExtension = &pDeviceExtension->SmartcardExtension;
    NTSTATUS status;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!StopCardTracking: Enter\n",
                    DRIVER_NAME)
                  );

    if (pSmartcardExtension->ReaderExtension->ThreadObjectPointer != NULL) {

      // kill thread
        KeWaitForSingleObject(&pSmartcardExtension->ReaderExtension->CardManIOMutex,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL
                             );
        pSmartcardExtension->ReaderExtension->TimeToTerminateThread = TRUE;
        KeReleaseMutex(&pSmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);


      //
      // Wait on the thread handle, when the wait is satisfied, the
      // thread has gone away.
      //
        status = KeWaitForSingleObject(
                                      pSmartcardExtension->ReaderExtension->ThreadObjectPointer,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL
                                      );

        pSmartcardExtension->ReaderExtension->ThreadObjectPointer = NULL;
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!StopCardTracking: Exit %lx\n",
                    DRIVER_NAME,
                    status)
                  );

}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_GetDeviceDescription (PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status;
    NTSTATUS DebugStatus;
    ULONG ulBytesRead;
    BYTE bByteRead;
    ULONG i,j;
    BYTE abReadBuffer[256];
    ULONG ulPnPStringLength = 0;
    ULONG ulExtend;


    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!GetDeviceDescriptiong: Enter\n",
                    DRIVER_NAME)
                  );



   // ===============================
   // clear any pending errors
   // ===============================
    status = SCCMN50M_GetCommStatus(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("SCCMN50M_GetCommStatus failed !   status = %ld\n",status))
        goto ExitGetDeviceDescription;
    }



   // =================================
   // set baudrate for CardMan to 1200
   // =================================
    pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate      = 1200;


    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BAUD_RATE;
    RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  &pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate,
                  sizeof(SERIAL_BAUD_RATE));
    pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_BAUD_RATE);
    pSmartcardExtension->SmartcardReply.BufferLength = 0;

    status =  SCCMN50M_SerialIo(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_BAUDRATE failed !   status = %ld\n",status))
        goto ExitGetDeviceDescription;
    }


   // ===============================
   // set comm timeouts
   // ===============================
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadIntervalTimeout         = DEFAULT_READ_INTERVAL_TIMEOUT;
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant    = DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT + 5000;
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier  = DEFAULT_READ_TOTAL_TIMEOUT_MULTIPLIER;
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.WriteTotalTimeoutConstant   = DEFAULT_WRITE_TOTAL_TIMEOUT_CONSTANT;
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.WriteTotalTimeoutMultiplier = DEFAULT_WRITE_TOTAL_TIMEOUT_MULTIPLIER;


    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_TIMEOUTS;
    RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  &pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts,
                  sizeof(SERIAL_TIMEOUTS));
    pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_TIMEOUTS);
    pSmartcardExtension->SmartcardReply.BufferLength = 0;

    status =  SCCMN50M_SerialIo(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_TIMEOUTS failed !   status = %x\n",status))
        goto ExitGetDeviceDescription;
    }





   // ===============================
   // set line control
   // ===============================
    pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.StopBits   = STOP_BITS_2;
    pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.Parity     = NO_PARITY;
    pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.WordLength = 7;

    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_LINE_CONTROL;
    RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  &pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl,
                  sizeof(SERIAL_LINE_CONTROL));
    pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_LINE_CONTROL);
    pSmartcardExtension->SmartcardReply.BufferLength = 0;

    status =  SCCMN50M_SerialIo(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_LINE_CONTROL failed !   status = %x\n",status))
        goto ExitGetDeviceDescription;
    }




   // ===============================
   // Set handflow
   // ===============================
    pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.XonLimit         = 0;
    pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.XoffLimit        = 0;
    pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.FlowReplace      = 0;
    pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.ControlHandShake = SERIAL_ERROR_ABORT | SERIAL_DTR_CONTROL;

    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_HANDFLOW;


    RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  &pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow,
                  sizeof(SERIAL_HANDFLOW));

    pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_HANDFLOW);
    pSmartcardExtension->SmartcardReply.BufferLength = 0;

    status =  SCCMN50M_SerialIo(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_HANDFLOW failed !   status = %x\n",status))
        goto ExitGetDeviceDescription;
    }


   // ===============================
   //  set purge mask
   // ===============================
    pSmartcardExtension->ReaderExtension->SerialConfigData.PurgeMask =
    SERIAL_PURGE_TXABORT | SERIAL_PURGE_RXABORT |
    SERIAL_PURGE_TXCLEAR | SERIAL_PURGE_RXCLEAR;


   // ===============================
   //  clear RTS
   // ===============================
    status = SCCMN50M_ClearRTS(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_RTS failed !   status = %x\n",status))
        goto ExitGetDeviceDescription;
    }

    Wait(pSmartcardExtension,1);

   // ===============================
   //  set DTR
   // ===============================

    status = SCCMN50M_SetDTR(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_DRT failed !   status = %x\n",status))
        goto ExitGetDeviceDescription;
    }

    Wait(pSmartcardExtension,1);


   // ===============================
   //  set RTS
   // ===============================
    status = SCCMN50M_SetRTS(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_RTS failed !   status = %x\n",status))
        goto ExitGetDeviceDescription;
    }

    i=0;
    while (i < sizeof(abReadBuffer)) {
        pSmartcardExtension->ReaderExtension->ToRHConfig  = FALSE;
        status = SCCMN50M_ReadCardMan(pSmartcardExtension,1,&ulBytesRead,&bByteRead,sizeof(bByteRead));
        if (status == STATUS_SUCCESS) {
            abReadBuffer[i++] = bByteRead;
            if (bByteRead == 0x29) {
                ulPnPStringLength = i;
                break;
            }
        } else {
            break;
        }
    }

    if (i >= sizeof(abReadBuffer)) {
        status = STATUS_UNSUCCESSFUL;
        goto ExitGetDeviceDescription;
    }


    if (ulPnPStringLength > 11 ) {
        ulExtend = 0;
        for (i=0;i<ulPnPStringLength;i++) {
            if (abReadBuffer[i] == 0x5C)
                ulExtend++;
            if (ulExtend == 4) {
                j = 0;
                i++;
                while (i < ulPnPStringLength - 3) {
                    pSmartcardExtension->ReaderExtension->abDeviceDescription[j] = abReadBuffer[i];
                    i++;
                    j++;
                }
                pSmartcardExtension->ReaderExtension->abDeviceDescription[j] = 0;
                SmartcardDebug(
                              DEBUG_DRIVER,
                              ( "%s!Device=%s\n",
                                pSmartcardExtension->ReaderExtension->abDeviceDescription)
                              );
                break;
            }

        }



    }





   // ===================
   // restore baud rate
   // ===================
    pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate      = 38400;


    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BAUD_RATE;
    RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  &pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate,
                  sizeof(SERIAL_BAUD_RATE));
    pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_BAUD_RATE);
    pSmartcardExtension->SmartcardReply.BufferLength = 0;

    status =  SCCMN50M_SerialIo(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_BAUDRATE failed !   status = %ld\n",status))
        goto ExitGetDeviceDescription;
    }

   // ====================
   // retore line control
   // ====================
    pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.StopBits   = STOP_BITS_2;
    pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.Parity     = EVEN_PARITY;
    pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.WordLength = 8;

    pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_LINE_CONTROL;
    RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                  &pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl,
                  sizeof(SERIAL_LINE_CONTROL));
    pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_LINE_CONTROL);
    pSmartcardExtension->SmartcardReply.BufferLength = 0;

    status =  SCCMN50M_SerialIo(pSmartcardExtension);
    if (!NT_SUCCESS(status)) {
        SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_LINE_CONTROL failed !   status = %x\n",status))
        goto ExitGetDeviceDescription;
    }







    ExitGetDeviceDescription:
    DebugStatus = SCCMN50M_ResyncCardManII(pSmartcardExtension);

    if (status != STATUS_SUCCESS) {  // map all errors to STATUS_UNSUCCESSFULL;
        status = STATUS_UNSUCCESSFUL;
    }
    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!GetDeviceDescriptiong: Exit %lx\n",
                    DRIVER_NAME,status)
                  );
    return status;
}




/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetSyncParameters(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
    NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!SetSyncParameters: Enter\n",
                    DRIVER_NAME)
                  );

   //DBGBreakPoint();

    pSmartcardExtension->ReaderExtension->SyncParameters.ulProtocol =
    ((PSYNC_PARAMETERS)pSmartcardExtension->IoRequest.RequestBuffer)->ulProtocol;

    pSmartcardExtension->ReaderExtension->SyncParameters.ulStateResetLineWhileReading =
    ((PSYNC_PARAMETERS)pSmartcardExtension->IoRequest.RequestBuffer)->ulStateResetLineWhileReading;

    pSmartcardExtension->ReaderExtension->SyncParameters.ulStateResetLineWhileWriting =
    ((PSYNC_PARAMETERS)pSmartcardExtension->IoRequest.RequestBuffer)->ulStateResetLineWhileWriting;

    pSmartcardExtension->ReaderExtension->SyncParameters.ulWriteDummyClocks =
    ((PSYNC_PARAMETERS)pSmartcardExtension->IoRequest.RequestBuffer)->ulWriteDummyClocks;

    pSmartcardExtension->ReaderExtension->SyncParameters.ulHeaderLen =
    ((PSYNC_PARAMETERS)pSmartcardExtension->IoRequest.RequestBuffer)->ulHeaderLen;

   // Used for the 2 Wire Protocol. We must make a Card reset after Power On
    pSmartcardExtension->ReaderExtension->SyncParameters.fCardResetRequested = TRUE;


   // return length of reply
    *pSmartcardExtension->IoRequest.Information = 0L;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!SetSyncParameters: Exit\n",
                    DRIVER_NAME)
                  );
    return status;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
UCHAR
SCCMN50M_CalcTxControlByte (IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                            IN ULONG ulBitsToWrite                        )
{
    UCHAR bTxControlByte = 0;

    if (pSmartcardExtension->ReaderExtension->SyncParameters.ulProtocol == SCARD_PROTOCOL_2WBP) {
        bTxControlByte = CLOCK_FORCED_2WBP;
    } else {
        if (ulBitsToWrite >=  255 * 8)
            bTxControlByte  |= TRANSMIT_A8;

        if (pSmartcardExtension->ReaderExtension->SyncParameters.ulStateResetLineWhileWriting ==
            SCARD_RESET_LINE_HIGH)
            bTxControlByte  |= SYNC_RESET_LINE_HIGH;
    }

    bTxControlByte |= (BYTE)((ulBitsToWrite-1) & 0x00000007);

    return bTxControlByte;

}


//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
UCHAR
SCCMN50M_CalcTxLengthByte (IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                           IN ULONG                 ulBitsToWrite       )
{
    UCHAR bTxLengthByte = 0;

    bTxLengthByte = (BYTE)( ((ulBitsToWrite - 1) >> 3) + 1);

    return bTxLengthByte;
}


//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
UCHAR
SCCMN50M_CalcRxControlByte (IN PSMARTCARD_EXTENSION pSmartcardExtension,
                            IN ULONG                ulBitsToRead        )
{
    UCHAR bRxControlByte = 0;


    if (pSmartcardExtension->ReaderExtension->SyncParameters.ulStateResetLineWhileReading ==
        SCARD_RESET_LINE_HIGH)
        bRxControlByte  |= SYNC_RESET_LINE_HIGH;

    if (ulBitsToRead == 0) {
        ulBitsToRead    = pSmartcardExtension->ReaderExtension->SyncParameters.ulWriteDummyClocks;
        bRxControlByte |= SYNC_DUMMY_RECEIVE;
    }

    if (ulBitsToRead  > 255 * 8)
        bRxControlByte  |= RECEIVE_A8;

    bRxControlByte |= (BYTE)( (ulBitsToRead-1) & 0x00000007);

    return bRxControlByte;
}


//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
UCHAR
SCCMN50M_CalcRxLengthByte (IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                           IN ULONG                 ulBitsToRead        )
{
    UCHAR bRxLengthByte = 0;

//   if (pSmartcardExtension->ReaderExtension->SyncParameters.ulProtocol == SCARD_PROTOCOL_3WBP)
//      {
    if (ulBitsToRead == 0)
        ulBitsToRead = pSmartcardExtension->ReaderExtension->SyncParameters.ulWriteDummyClocks;

    bRxLengthByte = (BYTE)( ((ulBitsToRead - 1) >> 3) + 1);
//      }

    return bRxLengthByte;
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SyncCardPowerOn  (
                          IN  PSMARTCARD_EXTENSION pSmartcardExtension
                          )
{
    NTSTATUS status;
    UCHAR  pbAtrBuffer[MAXIMUM_ATR_LENGTH];
    UCHAR  abSyncAtrBuffer[MAXIMUM_ATR_LENGTH];
    ULONG  ulAtrLength = 0;
    KIRQL  irql;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!SyncCardPowerOn: Enter\n",
                    DRIVER_NAME)
                  );

    status = SCCMN50M_UseSyncStrategy(pSmartcardExtension,
                                      &ulAtrLength,
                                      pbAtrBuffer,
                                      sizeof(pbAtrBuffer));


    abSyncAtrBuffer[0] = 0x3B;
    abSyncAtrBuffer[1] = 0x04;
    MemCpy(&abSyncAtrBuffer[2],
           sizeof(abSyncAtrBuffer)-2,
           pbAtrBuffer,
           ulAtrLength);


    ulAtrLength += 2;

    MemCpy(pSmartcardExtension->CardCapabilities.ATR.Buffer,
           sizeof(pSmartcardExtension->CardCapabilities.ATR.Buffer),
           abSyncAtrBuffer,
           ulAtrLength);

    pSmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)(ulAtrLength);

    KeAcquireSpinLock(&pSmartcardExtension->OsData->SpinLock,
                      &irql);

    pSmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
    pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;
    pSmartcardExtension->ReaderExtension->SyncParameters.fCardResetRequested = TRUE;
    pSmartcardExtension->ReaderExtension->SyncParameters.fCardPowerRequested = FALSE;

    KeReleaseSpinLock(&pSmartcardExtension->OsData->SpinLock,
                      irql);


    SmartcardDebug(DEBUG_ATR,("ATR of synchronous smart card : %2.2x %2.2x %2.2x %2.2x\n",
                              pbAtrBuffer[0],pbAtrBuffer[1],pbAtrBuffer[2],pbAtrBuffer[3]));



    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!SyncCardPowerOn: Exit %lx\n",
                    DRIVER_NAME,status)
                  );

    return status;
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_Transmit2WBP(PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR    bWriteBuffer [128];
    UCHAR    bReadBuffer [128];
    UCHAR    bTxControlByte;
    UCHAR    bTxLengthByte;
    UCHAR    bRxControlByte;
    UCHAR    bRxLengthByte;
    ULONG    ulBytesToWrite;
    ULONG    ulBytesToRead;
    ULONG    ulBitsToWrite;
    ULONG    ulBitsToRead;
    ULONG    ulBytesRead;
//   ULONG    ulBitsRead;
    ULONG    ulBytesStillToRead;
    ULONG    ulMaxIFSD;
    PCHAR    pbInData;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!Transmit2WBP: Enter\n",
                    DRIVER_NAME)
                  );


   /*-----------------------------------------------------------------------*/
   /** Power smartcard - if smartcard was removed and reinserted           **/
   /*-----------------------------------------------------------------------*/
    if (pSmartcardExtension->ReaderExtension->SyncParameters.fCardPowerRequested == TRUE) {
        status = SCCMN50M_SyncCardPowerOn (pSmartcardExtension);
        if (status != STATUS_SUCCESS) {
            goto ExitTransmit2WBP;
        }
    }


    pbInData       = pSmartcardExtension->IoRequest.RequestBuffer + sizeof(SYNC_TRANSFER);
    ulBitsToWrite  = ((PSYNC_TRANSFER)(pSmartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToWrite;
    ulBitsToRead   = ((PSYNC_TRANSFER)(pSmartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToRead;
    ulBytesToWrite = ulBitsToWrite/8;
    ulBytesToRead  = ulBitsToRead/8 + (ulBitsToRead % 8 ? 1 : 0);

   /*-----------------------------------------------------------------------*/
   // check buffer sizes
   /*-----------------------------------------------------------------------*/
    ulMaxIFSD = ATTR_MAX_IFSD_CARDMAN_II;


    if (ulBytesToRead > ulMaxIFSD                                         ||
        ulBytesToRead > pSmartcardExtension->SmartcardReply.BufferSize) {
        status = STATUS_BUFFER_OVERFLOW;
        goto ExitTransmit2WBP;
    }

    if (ulBytesToWrite > pSmartcardExtension->SmartcardRequest.BufferSize) {
        status = STATUS_BUFFER_OVERFLOW;
        goto ExitTransmit2WBP;
    }

    pSmartcardExtension->SmartcardRequest.BufferLength = ulBytesToWrite+1;

   /*-----------------------------------------------------------------------*/
   // copy data to the Smartcard Request Buffer
   /*-----------------------------------------------------------------------*/
    (pSmartcardExtension->SmartcardRequest.Buffer)[0] = '\x0F';
    MemCpy((pSmartcardExtension->SmartcardRequest.Buffer+1),
           pSmartcardExtension->SmartcardRequest.BufferSize-1,
           pbInData,
           ulBytesToWrite);

   /*-----------------------------------------------------------------------*/
   // copy data to the write buffer
   /*-----------------------------------------------------------------------*/
    MemCpy((bWriteBuffer),
           sizeof(bWriteBuffer),
           pSmartcardExtension->SmartcardRequest.Buffer,
           (ulBytesToWrite+1));


   /*-----------------------------------------------------------------------*/
   // set SYNC protocol flag for CardMan
   /*-----------------------------------------------------------------------*/
    SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_SYN);

   /*-----------------------------------------------------------------------*/
   // Header
   /*-----------------------------------------------------------------------*/
    if (pSmartcardExtension->ReaderExtension->SyncParameters.fCardResetRequested == TRUE) {
        status = SCCMN50M_ResetCard2WBP(pSmartcardExtension);
        if (NT_ERROR(status)) {
            goto ExitTransmit2WBP;
        }

        pSmartcardExtension->ReaderExtension->SyncParameters.fCardResetRequested = FALSE;
    }

   /*-----------------------------------------------------------------------*/
   // 1. Send Carman-Header   4-Byte
   // 2. Send 0x0F, that builds a HIGH-LOW Edge for 4432 CC
   // 3. Send the Data (CC command = 3 Byte)
   /*-----------------------------------------------------------------------*/
    bTxControlByte = SCCMN50M_CalcTxControlByte(pSmartcardExtension,ulBitsToWrite);
    bTxLengthByte =  (BYTE)(SCCMN50M_CalcTxLengthByte(pSmartcardExtension,ulBitsToWrite)+1);
    bRxControlByte = 0;
    bRxLengthByte =  0;

    SCCMN50M_SetCardManHeader(pSmartcardExtension,
                              bTxControlByte,
                              bTxLengthByte,
                              bRxControlByte,
                              bRxLengthByte);

   /*-----------------------------------------------------------------------*/
   // write data to card
   /*-----------------------------------------------------------------------*/
    status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                    (ulBytesToWrite+1),
                                    bWriteBuffer);
    if (NT_ERROR(status)) {
        goto ExitTransmit2WBP;
    }

   /*-----------------------------------------------------------------------*/
   // read CardMan Header
   // no Data from CC received
   /*-----------------------------------------------------------------------*/
    pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;

    status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                  2,
                                  &ulBytesRead,
                                  bReadBuffer,
                                  sizeof(bReadBuffer));

    if (NT_ERROR(status)) {
        goto ExitTransmit2WBP;
    }

   /*-----------------------------------------------------------------------*/
   // 1. Send Carman-Header   4-Byte
   // 2. Send 0xF0, that builds a LOW-HIGH Edge for 4432 CC
   // 3. Now the receiviing of card-data begins
   /*-----------------------------------------------------------------------*/
    bTxControlByte = SCCMN50M_CalcTxControlByte(pSmartcardExtension, 8);
    bTxLengthByte =  SCCMN50M_CalcTxLengthByte(pSmartcardExtension, 8);
    bRxControlByte = SCCMN50M_CalcRxControlByte(pSmartcardExtension,ulBitsToRead);
    bRxLengthByte =  SCCMN50M_CalcRxLengthByte(pSmartcardExtension,ulBitsToRead);

    SCCMN50M_SetCardManHeader(pSmartcardExtension,
                              bTxControlByte,
                              bTxLengthByte,
                              bRxControlByte,
                              bRxLengthByte);

   /*-----------------------------------------------------------------------*/
   // in this sequnce SCCMN50M_WriteCardMan must not send the Config string.
   // write 0xF0 -> is the trigger to read data from card or start the
   // processing.
   /*-----------------------------------------------------------------------*/
    pSmartcardExtension->ReaderExtension->NoConfig = TRUE;

    status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                    1,                       // one byte to write
                                    "\xF0");                 // LOW-HIGH - Edge
    if (NT_ERROR(status)) {
        goto ExitTransmit2WBP;
    }

   /*-----------------------------------------------------------------------*/
   // read CardMan Header
   // Data from CC received will be received
   /*-----------------------------------------------------------------------*/
    pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;

    status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                  2,
                                  &ulBytesRead,
                                  bReadBuffer,
                                  sizeof(bReadBuffer));

    if (NT_ERROR(status)) {
        goto ExitTransmit2WBP;
    }

   /*-----------------------------------------------------------------------*/
   // Read the data string
   /*-----------------------------------------------------------------------*/
    ulBytesStillToRead = (ULONG)bReadBuffer[1];

    if (bReadBuffer[0] & RECEIVE_A8)
        ulBytesStillToRead += 256;

    status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                  ulBytesStillToRead,
                                  &ulBytesRead,
                                  bReadBuffer,
                                  sizeof(bReadBuffer));

    if (NT_ERROR(status)) {
        goto ExitTransmit2WBP;
    }

   /*-----------------------------------------------------------------------*/
   /** calculate data length in bits  -  this value is not used            **/
   /*-----------------------------------------------------------------------*/
// ulBitsRead = ((ulBytesRead-1) * 8) + ((ulBitsToRead-1 ) & 0x00000007) + 1;

   /*-----------------------------------------------------------------------*/
   /** shift the bits in the last byte to the correct position             **/
   /*-----------------------------------------------------------------------*/
    bReadBuffer[ulBytesRead-1]  >>= (7 - ((ulBitsToRead-1) & 0x00000007));

   /*-----------------------------------------------------------------------*/
   // the first bit of the returned string is lost
   // so we must shift the whole data string one bit left
   // the first bit of the first data byte is lost while reading
   // this bit maybe incorrect
   /*-----------------------------------------------------------------------*/
    SCCMN50M_Shift_Msg(bReadBuffer, ulBytesRead);

   /*-----------------------------------------------------------------------*/
   // copy received bytes to Smartcard Reply Buffer
   /*-----------------------------------------------------------------------*/
    MemCpy(pSmartcardExtension->SmartcardReply.Buffer,
           pSmartcardExtension->SmartcardReply.BufferSize,
           bReadBuffer,
           ulBytesRead);

    pSmartcardExtension->SmartcardReply.BufferLength = ulBytesRead;

   /*-----------------------------------------------------------------------*/
   // copy received bytes to IoReply Buffer
   /*-----------------------------------------------------------------------*/
    MemCpy(pSmartcardExtension->IoRequest.ReplyBuffer,
           pSmartcardExtension->IoRequest.ReplyBufferLength,
           pSmartcardExtension->SmartcardReply.Buffer,
           ulBytesRead);

    *(pSmartcardExtension->IoRequest.Information) = ulBytesRead;


    ExitTransmit2WBP:
    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!Transmit2WBP: Exit\n",
                    DRIVER_NAME,status)
                  );
    return status;
}




/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_Shift_Msg (PUCHAR  pbBuffer,
                    ULONG   ulMsgLen)
{
    UCHAR  bTmp1, bTmp2;
    int    i;

    for (i=(int)ulMsgLen-1; i>=0; i--) {
        bTmp1=(BYTE)((pbBuffer[i] >> 7) & 0x01);      /* bTmp1 = bit 7 naechstes byte */
        if (i+1 != (int)ulMsgLen) {
            bTmp2=(BYTE)((pbBuffer[i+1] << 1) | bTmp1);
            pbBuffer[i+1] = bTmp2;
        }
    }

    pbBuffer[0] = (BYTE)(pbBuffer[0] << 1);

    return;
}



/*****************************************************************************
Routine Description:

  Reset Card 4442


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_ResetCard2WBP(IN PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status = STATUS_SUCCESS;
    BYTE     bBuffer[10];
    ULONG    ulBytesRead;

   /*-----------------------------------------------------------------------*/
   // Enter Card Reset
   /*-----------------------------------------------------------------------*/
    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!ResetCard2WBP: Enter\n",
                    DRIVER_NAME)
                  );

   /*-----------------------------------------------------------------------*/
   //      bTxControlByte = 0;
   //      bTxLengthByte =  0;
   //      bRxControlByte = RESET_CARD;
   //      bRxLengthByte =  5;
   /*-----------------------------------------------------------------------*/

    SCCMN50M_SetCardManHeader(pSmartcardExtension,
                              0,                        // bTxControlByte
                              0,                        // bTxLengthByte
                              COLD_RESET,               // bRxControlByte
                              5);                       // bRxLengthByte


   /*-----------------------------------------------------------------------*/
   // write data to card
   /*-----------------------------------------------------------------------*/
    status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                    0,
                                    NULL);
    if (NT_ERROR(status)) {
        goto ExitResetCard2WBP;
    }

   /*-----------------------------------------------------------------------*/
   // read CardMan Header
   /*-----------------------------------------------------------------------*/
    pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;

    status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                  2, &ulBytesRead, bBuffer, sizeof(bBuffer));

    if (NT_ERROR(status)) {
        goto ExitResetCard2WBP;
    }

    if (bBuffer[1] != 5) {
        status = !STATUS_SUCCESS;
        goto ExitResetCard2WBP;
    }

   /*-----------------------------------------------------------------------*/
   // read ATR
   /*-----------------------------------------------------------------------*/
    status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                  5, &ulBytesRead, bBuffer, sizeof(bBuffer));

    if (NT_ERROR(status)) {
        goto ExitResetCard2WBP;
    }

    SmartcardDebug(DEBUG_ATR,("%s!Card Reset ATR : %02x %02x %02x %02x\n",
                              DRIVER_NAME,bBuffer[0],bBuffer[1],bBuffer[2],bBuffer[3]));

    ExitResetCard2WBP:
    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!ResetCard2WBP: Exit %lx\n",
                    DRIVER_NAME,status)
                  );
    return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_Transmit3WBP(PSMARTCARD_EXTENSION pSmartcardExtension)
{
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR    bWriteBuffer [128];
    UCHAR    bReadBuffer [128];
    UCHAR    bTxControlByte;
    UCHAR    bTxLengthByte;
    UCHAR    bRxControlByte;
    UCHAR    bRxLengthByte;
    ULONG    ulBytesToWrite;
    ULONG    ulBytesToRead;
    ULONG    ulBitsToWrite;
    ULONG    ulBitsToRead;
    ULONG    ulBytesRead;
//   ULONG    ulBitsRead;
    ULONG    ulBytesStillToRead;
    ULONG    ulMaxIFSD;
    PCHAR    pbInData;



    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!Transmit3WBP: Enter\n",
                    DRIVER_NAME)
                  );
//   DBGBreakPoint();

   /*-----------------------------------------------------------------------*/
   /** Power smartcard - if smartcard was removed and reinserted           **/
   /*-----------------------------------------------------------------------*/
    if (pSmartcardExtension->ReaderExtension->SyncParameters.fCardPowerRequested == TRUE) {
        status = SCCMN50M_SyncCardPowerOn (pSmartcardExtension);
        if (status != STATUS_SUCCESS) {
            goto ExitTransmit3WBP;
        }
    }


    pbInData       = pSmartcardExtension->IoRequest.RequestBuffer + sizeof(SYNC_TRANSFER);
    ulBitsToWrite  = ((PSYNC_TRANSFER)(pSmartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToWrite;
    ulBitsToRead   = ((PSYNC_TRANSFER)(pSmartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToRead;
    ulBytesToWrite = ulBitsToWrite/8;
    ulBytesToRead  = ulBitsToRead/8 + (ulBitsToRead % 8 ? 1 : 0);

   /*-----------------------------------------------------------------------*/
   // check buffer sizes
   /*-----------------------------------------------------------------------*/
    ulMaxIFSD = ATTR_MAX_IFSD_CARDMAN_II;


    if (ulBytesToRead > ulMaxIFSD                                         ||
        ulBytesToRead > pSmartcardExtension->SmartcardReply.BufferSize) {
        status = STATUS_BUFFER_OVERFLOW;
        goto ExitTransmit3WBP;
    }

    if (ulBytesToWrite > pSmartcardExtension->SmartcardRequest.BufferSize) {
        status = STATUS_BUFFER_OVERFLOW;
        goto ExitTransmit3WBP;
    }

    pSmartcardExtension->SmartcardRequest.BufferLength = ulBytesToWrite;

   /*-----------------------------------------------------------------------*/
   // copy data to the Smartcard Request Buffer
   /*-----------------------------------------------------------------------*/
    MemCpy(pSmartcardExtension->SmartcardRequest.Buffer,
           pSmartcardExtension->SmartcardRequest.BufferSize,
           pbInData,
           ulBytesToWrite);

   /*-----------------------------------------------------------------------*/
   // copy data to the write buffer
   /*-----------------------------------------------------------------------*/
    MemCpy(bWriteBuffer,
           sizeof(bWriteBuffer),
           pSmartcardExtension->SmartcardRequest.Buffer,
           ulBytesToWrite);



   /*-----------------------------------------------------------------------*/
   // set SYNC protocol flag for CardMan
   /*-----------------------------------------------------------------------*/
    SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_SYN);

   /*-----------------------------------------------------------------------*/
   // build cardman header
   /*-----------------------------------------------------------------------*/
    bTxControlByte = SCCMN50M_CalcTxControlByte(pSmartcardExtension,ulBitsToWrite);
    bTxLengthByte =  SCCMN50M_CalcTxLengthByte(pSmartcardExtension,ulBitsToWrite);
    bRxControlByte = SCCMN50M_CalcRxControlByte(pSmartcardExtension,ulBitsToRead);
    bRxLengthByte =  SCCMN50M_CalcRxLengthByte(pSmartcardExtension,ulBitsToRead);

    SCCMN50M_SetCardManHeader(pSmartcardExtension,
                              bTxControlByte,
                              bTxLengthByte,
                              bRxControlByte,
                              bRxLengthByte);


   /*-----------------------------------------------------------------------*/
   /** write data to card                                                  **/
   /*-----------------------------------------------------------------------*/
    status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                    ulBytesToWrite,
                                    bWriteBuffer);
    if (NT_ERROR(status)) {
        goto ExitTransmit3WBP;
    }

   /*-----------------------------------------------------------------------*/
   /** read CardMan Header                                                 **/
   /*-----------------------------------------------------------------------*/
    pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;
    status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
    if (NT_ERROR(status)) {
        goto ExitTransmit3WBP;
    }

   /*-----------------------------------------------------------------------*/
   // calc data length to receive
   /*-----------------------------------------------------------------------*/
    ulBytesStillToRead = (ULONG)(bReadBuffer[1]);
    if (bReadBuffer[0] & RECEIVE_A8)
        ulBytesStillToRead += 256;


   // read data from card
    status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                  ulBytesStillToRead,
                                  &ulBytesRead,
                                  bReadBuffer,
                                  sizeof(bReadBuffer));
    if (NT_ERROR(status)) {
        goto ExitTransmit3WBP;
    }

   /*-----------------------------------------------------------------------*/
   // calculate data length in bits  -  this value is not used
   /*-----------------------------------------------------------------------*/
// ulBitsRead = ((ulBytesRead-1) * 8) + ((ulBitsToRead-1 ) & 0x00000007) + 1;

   /*-----------------------------------------------------------------------*/
   // shift the bits in the last byte to the correct position
   /*-----------------------------------------------------------------------*/
    bReadBuffer[ulBytesRead-1]  >>= (7 - ((ulBitsToRead-1) & 0x00000007));


   /*-----------------------------------------------------------------------*/
   // copy received bytes to Smartcard Reply Buffer
   /*-----------------------------------------------------------------------*/
    MemCpy(pSmartcardExtension->SmartcardReply.Buffer,
           pSmartcardExtension->SmartcardReply.BufferSize,
           bReadBuffer,
           ulBytesRead);

    pSmartcardExtension->SmartcardReply.BufferLength = ulBytesRead;

   /*-----------------------------------------------------------------------*/
   // copy received bytes to IoReply Buffer
   // this Memcpy should respond to SmartcardRawReply function
   /*-----------------------------------------------------------------------*/
    MemCpy(pSmartcardExtension->IoRequest.ReplyBuffer,
           pSmartcardExtension->IoRequest.ReplyBufferLength,
           pSmartcardExtension->SmartcardReply.Buffer,
           ulBytesRead);

    *pSmartcardExtension->IoRequest.Information = ulBytesRead;


    ExitTransmit3WBP:
    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!Transmit3WBP: Exit %lx\n",
                    DRIVER_NAME,status)
                  );
    return status;
}



/*****************************************************************************
Routine Description:

   This function powers a synchronous smart card.


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_UseSyncStrategy  (
                          IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                          OUT   PULONG pulAtrLength,
                          OUT   PUCHAR pbAtrBuffer,
                          IN    ULONG  ulAtrBufferSize
                          )
{
    NTSTATUS status;
    NTSTATUS DebugStatus;
    UCHAR  bReadBuffer[SCARD_ATR_LENGTH];
    ULONG  ulBytesRead;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!UseSyncStrategy: Enter\n",
                    DRIVER_NAME)
                  );
   //DBGBreakPoint();

    SCCMN50M_SetCardManHeader(pSmartcardExtension,0,0,SYNC_ATR_RX_CONTROL,ATR_LEN_SYNC);
    pSmartcardExtension->ReaderExtension->CardManConfig.ResetDelay   = SYNC_RESET_DELAY;
    pSmartcardExtension->ReaderExtension->CardManConfig.CardStopBits = 0x02;

    SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ALL_FLAGS);
    SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY );

    SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_SYN);

    status = SCCMN50M_ResyncCardManII(pSmartcardExtension);
    if (status != STATUS_SUCCESS) {
        goto ExitPowerSynchronousCard;
    }


   // write config + header
    status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
    if (status != STATUS_SUCCESS) {
        goto ExitPowerSynchronousCard;
    }


    pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;
   // read state and length
    status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
    if (status != STATUS_SUCCESS) {
        goto ExitPowerSynchronousCard;
    }

    if (bReadBuffer[1] < MIN_ATR_LEN ) {
      // read all remaining bytes from the CardMan
        DebugStatus = SCCMN50M_ReadCardMan(pSmartcardExtension,bReadBuffer[1],&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
        status = STATUS_UNRECOGNIZED_MEDIA;
        goto ExitPowerSynchronousCard;
    }

    if (bReadBuffer[1] > ulAtrBufferSize) {
        status = STATUS_BUFFER_OVERFLOW;
        goto ExitPowerSynchronousCard;
    }

   // read ATR
    status = SCCMN50M_ReadCardMan(pSmartcardExtension,bReadBuffer[1],pulAtrLength,pbAtrBuffer,ulAtrBufferSize);
    if (status != STATUS_SUCCESS) {
        goto ExitPowerSynchronousCard;
    }

    if (pbAtrBuffer[0] == 0x00   ||
        pbAtrBuffer[0] == 0xff       ) {
        status = STATUS_UNRECOGNIZED_MEDIA;
        goto ExitPowerSynchronousCard;
    }
    pSmartcardExtension->ReaderExtension->fRawModeNecessary = TRUE;


    ExitPowerSynchronousCard:
    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!UseSyncStrategy: Exit %lx\n",
                    DRIVER_NAME,status)
                  );
    SCCMN50M_ClearSCRControlFlags(pSmartcardExtension,IGNORE_PARITY | CM2_GET_ATR);
    SCCMN50M_ClearCardManHeader(pSmartcardExtension);
    return status;
}


/*****************************************************************************
Routine Description:

 This function checks if the inserted card is a synchronous one


Arguments:



Return Value:

*****************************************************************************/
BOOLEAN
SCCMN50M_IsAsynchronousSmartCard(
                                IN PSMARTCARD_EXTENSION pSmartcardExtension
                                )
{
    NTSTATUS status;
    UCHAR  ReadBuffer[3];
    ULONG  ulBytesRead;
    BOOLEAN   fIsAsynchronousSmartCard = TRUE;
    UCHAR  abATR[33];

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!IsAsynchronousSmartcard: Enter \n",
                    DRIVER_NAME)
                  );

    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = 200;

   // 3MHz smart card ?
    SCCMN50M_SetCardManHeader(pSmartcardExtension,0,0,0,1);

    SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ALL_FLAGS);

    SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY | CM2_GET_ATR);

    SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ);

   // write config + header
    status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
    if (status != STATUS_SUCCESS) {
        goto ExitIsAsynchronousSmartCard;
    }

    pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;

   // read state and length
    status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,ReadBuffer,sizeof(ReadBuffer));
    if (status == STATUS_SUCCESS    &&
        ReadBuffer[1] == 0x01          ) {
        goto ExitIsAsynchronousSmartCard;
    }



   // ---------------------------------------
   // power off card
   // ---------------------------------------
    status = SCCMN50M_PowerOff(pSmartcardExtension);
    if (status != STATUS_SUCCESS) {
        goto ExitIsAsynchronousSmartCard;
    }


   // 5MHz smart card ?
    SCCMN50M_SetCardManHeader(pSmartcardExtension,0,0,0,1);

    SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ALL_FLAGS);

    SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY | CM2_GET_ATR);

    SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ);

   // write config + header
    status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
    if (status != STATUS_SUCCESS) {
        goto ExitIsAsynchronousSmartCard;
    }

    pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;

   // read state and length
    status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,ReadBuffer,sizeof(ReadBuffer));
    if (status == STATUS_SUCCESS    &&
        ReadBuffer[1] == 0x01          ) {
        goto ExitIsAsynchronousSmartCard;
    }

   // now we assume that it is a synchronous smart card
    fIsAsynchronousSmartCard = FALSE;
   // ---------------------------------------
   // power off card
   // ---------------------------------------
    status = SCCMN50M_PowerOff(pSmartcardExtension);
    if (status != STATUS_SUCCESS) {
        goto ExitIsAsynchronousSmartCard;
    }



    ExitIsAsynchronousSmartCard:
    pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant    = DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT;
    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!IsAsynchronousSmartcard: Exit \n",
                    DRIVER_NAME)
                  );
    return fIsAsynchronousSmartCard;
}



/*****************************************************************************
* History:
* $Log: sccmcb.c $
* Revision 1.7  2001/01/22 08:39:41  WFrischauf
* No comment given
*
* Revision 1.6  2000/09/25 10:46:22  WFrischauf
* No comment given
*
* Revision 1.5  2000/08/24 09:05:44  TBruendl
* No comment given
*
* Revision 1.4  2000/08/16 08:24:04  TBruendl
* warning :uninitialized memory removed
*
* Revision 1.3  2000/07/28 09:24:12  TBruendl
* Changes for OMNIKEY on Whistler CD
*
* Revision 1.16  2000/06/27 11:56:28  TBruendl
* workaraound for SAMOR smart cards with invalid ATR (ITSEC)
*
* Revision 1.15  2000/06/08 10:08:47  TBruendl
* bug fix : warm reset for ScfW
*
* Revision 1.14  2000/05/23 09:58:26  TBruendl
* OMNIKEY 3.0.0.1
*
* Revision 1.13  2000/04/13 08:07:22  TBruendl
* PPS bug fix for SCfW
*
* Revision 1.12  2000/04/04 07:52:18  TBruendl
* problem with the new WfsC fixed
*
* Revision 1.11  2000/03/03 09:50:50  TBruendl
* No comment given
*
* Revision 1.10  2000/03/01 09:32:04  TBruendl
* R02.20.0
*
* Revision 1.9  2000/01/04 10:40:33  TBruendl
* bug fix: status instead of DebugStatus used
*
* Revision 1.8  1999/12/16 14:10:16  TBruendl
* After transparent mode has been left, the status is read from the CardMan to be sure that
* the new settings are effective.
*
* Revision 1.6  1999/12/13 07:55:38  TBruendl
* Bug fix for P+ druing initialization
* PTS for 4.9 mhz smartcards added
*
* Revision 1.5  1999/11/04 07:53:21  WFrischauf
* bug fixes due to error reports 2 - 7
*
* Revision 1.4  1999/07/12 12:49:04  TBruendl
* Bug fix: Resync after GET_DEVICE_DESCRIPTION
*               Power On SLE4428
*
* Revision 1.3  1999/06/10 09:03:57  TBruendl
* No comment given
*
* Revision 1.2  1999/02/25 10:12:22  TBruendl
* No comment given
*
* Revision 1.1  1999/02/02 13:34:37  TBruendl
* This is the first release (R01.00) of the IFD handler for CardMan running under NT5.0.
*
*
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\sccmn50m\makefile.inc ===
sccmlog.h sccmlog.rc msg00001.bin: sccmlog.mc
    mc sccmlog.mc

sccmn50m.rc: sccmlog.rc

sccmlog.rc: msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\sccmn50m\sccmnt5.c ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbs0/sw/sccmn50m.ms/rcs/sccmnt5.c $
* $Revision: 1.7 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  OMNIKEY AG
******************************************************************************/

#include <stdio.h>
#include "sccmn50m.h"

//
// We do not need these functions after init anymore
//
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGEABLE, SCCMN50M_AddDevice)
#pragma alloc_text(PAGEABLE, SCCMN50M_CreateDevice)

#if DBG
   #pragma optimize ("", off)
#endif

BOOLEAN DeviceSlot[MAXIMUM_SMARTCARD_READERS];

/*****************************************************************************
Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.
    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS          - We could initialize at least one device.
    STATUS_NO_SUCH_DEVICE   - We could not initialize even one device.

*****************************************************************************/
NTSTATUS
DriverEntry(
           IN  PDRIVER_OBJECT  DriverObject,
           IN  PUNICODE_STRING RegistryPath
           )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG device;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!DriverEntry: Enter - %s %s\n",
                   DRIVER_NAME,
                   __DATE__,
                   __TIME__)
                  )






   // Initialize the Driver Object with driver's entry points
    DriverObject->DriverUnload = SCCMN50M_DriverUnload;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = SCCMN50M_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = SCCMN50M_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = SCCMN50M_Cleanup;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SCCMN50M_DeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SCCMN50M_SystemControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]   =  SCCMN50M_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER] = SCCMN50M_Power;
    DriverObject->DriverExtension->AddDevice =  SCCMN50M_AddDevice;

    return status;
}


/*****************************************************************************
Routine Description:
    Creates a new device without starting it.



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_AddDevice (
                   IN PDRIVER_OBJECT DriverObject,
                   IN PDEVICE_OBJECT PhysicalDeviceObject
                   )
{
    NTSTATUS status;
    PDEVICE_OBJECT DeviceObject = NULL;
    UCHAR PropertyBuffer[1024];
    ULONG ResultLength;

    PAGED_CODE();

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!AddDevice: Enter\n",
                    DRIVER_NAME)
                  );

    try {
        PDEVICE_EXTENSION deviceExtension;

      // create a device instance
        status = SCCMN50M_CreateDevice(
                                      DriverObject,
                                      PhysicalDeviceObject,
                                      &DeviceObject
                                      );

        if (status != STATUS_SUCCESS) {
            leave;
        }

        deviceExtension = DeviceObject->DeviceExtension;

      // and attach to the PDO
        ATTACHED_DEVICE_OBJECT = IoAttachDeviceToDeviceStack(
                                                            DeviceObject,
                                                            PhysicalDeviceObject
                                                            );

        ASSERT(ATTACHED_DEVICE_OBJECT != NULL);

        if (ATTACHED_DEVICE_OBJECT == NULL) {
            SmartcardLogError(
                             DriverObject,
                             SCCMN50M_CANT_CONNECT_TO_ASSIGNED_PORT,
                             NULL,
                             status
                             );

            status = STATUS_UNSUCCESSFUL;
            leave;
        }

      // register our new device
        status = IoRegisterDeviceInterface(
                                          PhysicalDeviceObject,
                                          &SmartCardReaderGuid,
                                          NULL,
                                          &deviceExtension->PnPDeviceName
                                          );
        ASSERT(status == STATUS_SUCCESS);

        DeviceObject->Flags |= DO_BUFFERED_IO;
        DeviceObject->Flags |= DO_POWER_PAGABLE;
        DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    } finally {
        if (status != STATUS_SUCCESS) {
            SCCMN50M_RemoveDevice(DeviceObject);
        }
    }


    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!AddDevice: Exit %x\n",
                    DRIVER_NAME,
                    status)
                  );

    return status;
}


/*****************************************************************************
Routine Description:
   Trys to read the reader name from the registry

Arguments:
   DriverObject context of call
   SmartcardExtension   ptr to smartcard extension

Return Value:
   none

******************************************************************************/
VOID SCCMN50M_SetVendorAndIfdName(
                                 IN  PDEVICE_OBJECT PhysicalDeviceObject,
                                 IN  PSMARTCARD_EXTENSION SmartcardExtension
                                 )
{

    RTL_QUERY_REGISTRY_TABLE   parameters[3];
    UNICODE_STRING             vendorNameU;
    ANSI_STRING                vendorNameA;
    UNICODE_STRING             ifdTypeU;
    ANSI_STRING                ifdTypeA;
    HANDLE                     regKey = NULL;

    RtlZeroMemory (parameters, sizeof(parameters));
    RtlZeroMemory (&vendorNameU, sizeof(vendorNameU));
    RtlZeroMemory (&vendorNameA, sizeof(vendorNameA));
    RtlZeroMemory (&ifdTypeU, sizeof(ifdTypeU));
    RtlZeroMemory (&ifdTypeA, sizeof(ifdTypeA));

    try {
      //
      // try to read the reader name from the registry
      // if that does not work, we will use the default
      // (hardcoded) name
      //
        if (IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                    PLUGPLAY_REGKEY_DEVICE,
                                    KEY_READ,
                                    &regKey) != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s!SetVendorAndIfdName: IoOpenDeviceRegistryKey failed\n",DRIVER_NAME));
            leave;
        }

        parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[0].Name = L"VendorName";
        parameters[0].EntryContext = &vendorNameU;
        parameters[0].DefaultType = REG_SZ;
        parameters[0].DefaultData = &vendorNameU;
        parameters[0].DefaultLength = 0;

        parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[1].Name = L"IfdType";
        parameters[1].EntryContext = &ifdTypeU;
        parameters[1].DefaultType = REG_SZ;
        parameters[1].DefaultData = &ifdTypeU;
        parameters[1].DefaultLength = 0;

        if (RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                   (PWSTR) regKey,
                                   parameters,
                                   NULL,
                                   NULL) != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s!SetVendorAndIfdName: RtlQueryRegistryValues failed\n",DRIVER_NAME));
            leave;
        }

        if (RtlUnicodeStringToAnsiString(&vendorNameA,&vendorNameU,TRUE) != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s!SetVendorAndIfdName: RtlUnicodeStringToAnsiString failed\n",DRIVER_NAME));
            leave;
        }

        if (RtlUnicodeStringToAnsiString(&ifdTypeA,&ifdTypeU,TRUE) != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s!SetVendorAndIfdName: RtlUnicodeStringToAnsiString failed\n",DRIVER_NAME));
            leave;
        }

        if (vendorNameA.Length == 0 ||
            vendorNameA.Length > MAXIMUM_ATTR_STRING_LENGTH ||
            ifdTypeA.Length == 0 ||
            ifdTypeA.Length > MAXIMUM_ATTR_STRING_LENGTH) {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s!SetVendorAndIfdName: vendor name or ifdtype not found or to long\n",DRIVER_NAME));
            leave;
        }

        RtlCopyMemory(SmartcardExtension->VendorAttr.VendorName.Buffer,
                      vendorNameA.Buffer,
                      vendorNameA.Length);
        SmartcardExtension->VendorAttr.VendorName.Length = vendorNameA.Length;

        RtlCopyMemory(SmartcardExtension->VendorAttr.IfdType.Buffer,
                      ifdTypeA.Buffer,
                      ifdTypeA.Length);
        SmartcardExtension->VendorAttr.IfdType.Length = ifdTypeA.Length;

        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!SetVendorAndIfdName: overwritting vendor name and ifdtype\n",DRIVER_NAME));

    }

    finally {
        if (vendorNameU.Buffer != NULL) {
            RtlFreeUnicodeString(&vendorNameU);
        }
        if (vendorNameA.Buffer != NULL) {
            RtlFreeAnsiString(&vendorNameA);
        }
        if (ifdTypeU.Buffer != NULL) {
            RtlFreeUnicodeString(&ifdTypeU);
        }
        if (ifdTypeA.Buffer != NULL) {
            RtlFreeAnsiString(&ifdTypeA);
        }
        if (regKey != NULL) {
            ZwClose (regKey);
        }
    }

}


/*****************************************************************************
Routine Description:

    This routine creates an object for the physical device specified and
    sets up the deviceExtension.


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_CreateDevice(
                     IN  PDRIVER_OBJECT DriverObject,
                     IN  PDEVICE_OBJECT PhysicalDeviceObject,
                     OUT PDEVICE_OBJECT *DeviceObject
                     )
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG deviceInstance;
    PREADER_EXTENSION readerExtension;
    PSMARTCARD_EXTENSION smartcardExtension;
    UNICODE_STRING DriverID;
    RTL_QUERY_REGISTRY_TABLE   ParamTable[2];
    UNICODE_STRING             RegistryPath;
    DWORD                      dwStart;
    UNICODE_STRING             Tmp;
    WCHAR                      Buffer[64];

   // this is a list of our supported data rates


    PAGED_CODE();

    *DeviceObject = NULL;

    for ( deviceInstance = 0;deviceInstance < MAXIMUM_SMARTCARD_READERS;deviceInstance++ ) {
        if (DeviceSlot[deviceInstance] == FALSE) {
            DeviceSlot[deviceInstance] = TRUE;
            break;
        }
    }

    if (deviceInstance == MAXIMUM_SMARTCARD_READERS) {
        SmartcardLogError(
                         DriverObject,
                         SCCMN50M_CANT_CREATE_MORE_DEVICES,
                         NULL,
                         0
                         );

        return STATUS_INSUFFICIENT_RESOURCES;
    }

   //
   //   construct the device name
   //
    DriverID.Buffer = Buffer;
    DriverID.MaximumLength = sizeof(Buffer);
    DriverID.Length = 0;
    RtlInitUnicodeString(&Tmp,CARDMAN_DEVICE_NAME);
    RtlCopyUnicodeString(&DriverID,&Tmp);
    DriverID.Buffer[(DriverID.Length)/sizeof(WCHAR)-1] = L'0' + (WCHAR)deviceInstance;

   // Create the device object
    status = IoCreateDevice(
                           DriverObject,
                           sizeof(DEVICE_EXTENSION),
                           &DriverID,
                           FILE_DEVICE_SMARTCARD,
                           0,
                           FALSE,
                           DeviceObject
                           );

    if (status != STATUS_SUCCESS) {
        SmartcardLogError(
                         DriverObject,
                         SCCMN50M_CANT_CREATE_DEVICE,
                         NULL,
                         0
                         );

        return status;
    }



    SmartcardDebug(
                  DEBUG_DRIVER,
                  ( "%s!CreateDevice: Device created\n",
                    DRIVER_NAME)
                  );

   //   set up the device extension.
    deviceExtension = (*DeviceObject)->DeviceExtension;
    deviceExtension->DeviceInstance =  deviceInstance;
    smartcardExtension = &deviceExtension->SmartcardExtension;




   // Used for stop / start notification
    KeInitializeEvent(
                     &deviceExtension->ReaderStarted,
                     NotificationEvent,
                     FALSE
                     );

   // This event signals that the serial driver has been closed
    KeInitializeEvent(
                     &deviceExtension->SerialCloseDone,
                     NotificationEvent,
                     TRUE
                     );

   // Used to keep track of open close calls
    KeInitializeEvent(
                     &deviceExtension->ReaderClosed,
                     NotificationEvent,
                     TRUE
                     );


    KeInitializeSpinLock(&deviceExtension->SpinLock);


   // Allocate data struct space for smart card reader
    smartcardExtension->ReaderExtension = ExAllocatePool(
                                                        NonPagedPool,
                                                        sizeof(READER_EXTENSION)
                                                        );

    if (smartcardExtension->ReaderExtension == NULL) {

        SmartcardLogError(
                         DriverObject,
                         SCCMN50M_NO_MEMORY,
                         NULL,
                         0
                         );

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    readerExtension = smartcardExtension->ReaderExtension;
    RtlZeroMemory(readerExtension, sizeof(READER_EXTENSION));

   // ----------------------------------------------
   //   initialize mutex
   // ----------------------------------------------
    KeInitializeMutex(&smartcardExtension->ReaderExtension->CardManIOMutex,0L);


   // Write the version of the lib we use to the smartcard extension
    smartcardExtension->Version = SMCLIB_VERSION;
    smartcardExtension->SmartcardRequest.BufferSize =
    smartcardExtension->SmartcardReply.BufferSize = MIN_BUFFER_SIZE;

   //
   // Now let the lib allocate the buffer for data transmission
   // We can either tell the lib how big the buffer should be
   // by assigning a value to BufferSize or let the lib
   // allocate the default size
   //
    status = SmartcardInitialize(smartcardExtension);

    if (status != STATUS_SUCCESS) {

        SmartcardLogError(
                         DriverObject,
                         (smartcardExtension->OsData ? SCCMN50M_WRONG_LIB_VERSION : SCCMN50M_NO_MEMORY),
                         NULL,
                         0
                         );

        return status;
    }

   // Save deviceObject
    smartcardExtension->OsData->DeviceObject = *DeviceObject;

   // Set up call back functions
    smartcardExtension->ReaderFunction[RDF_TRANSMIT] =      SCCMN50M_Transmit;
    smartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] =  SCCMN50M_SetProtocol;
    smartcardExtension->ReaderFunction[RDF_CARD_POWER] =    SCCMN50M_CardPower;
    smartcardExtension->ReaderFunction[RDF_CARD_TRACKING] = SCCMN50M_CardTracking;
    smartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR] =  SCCMN50M_IoCtlVendor;


    SCCMN50M_InitializeSmartcardExtension(smartcardExtension,deviceInstance);

   // try to overwrite with registry values
    SCCMN50M_SetVendorAndIfdName(PhysicalDeviceObject, smartcardExtension);


   // save the current power state of the reader
    readerExtension->ReaderPowerState = PowerReaderWorking;



    return STATUS_SUCCESS;
}

/*****************************************************************************
Routine Description:
   Open the serial device, start card tracking and register our
    device interface. If any of the calls here fails we don't care
    to rollback since a stop will be called later which we then
    use to clean up.



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_StartDevice(
                    IN PDEVICE_OBJECT DeviceObject
                    )
{
    NTSTATUS status;
    PIRP irp;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!StartDevice: Enter\n",
                    DRIVER_NAME)
                  );


    irp = IoAllocateIrp(
                       (CCHAR) (DeviceObject->StackSize + 1),
                       FALSE
                       );

    ASSERT(irp != NULL);

    if (irp == NULL) {

        return STATUS_NO_MEMORY;
    }

    _try {

        PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
        PSMARTCARD_EXTENSION pSmartcardExtension = &deviceExtension->SmartcardExtension;
        PIO_STACK_LOCATION irpStack;
        HANDLE handle = 0;
        IO_STATUS_BLOCK ioStatusBlock;

      //
      // Open the underlying serial driver.
      // This is necessary for two reasons:
      // a) The serial driver can't be used without opening it
      // b) The call will go through serenum first which informs
      //    it to stop looking/polling for new devices.
      //
        irp->UserIosb = &ioStatusBlock;
        IoSetNextIrpStackLocation(irp);
        irpStack = IoGetCurrentIrpStackLocation(irp);

        irpStack->MajorFunction = IRP_MJ_CREATE;
        irpStack->Parameters.Create.Options = 0;
        irpStack->Parameters.Create.ShareAccess = 0;
        irpStack->Parameters.Create.FileAttributes = 0;
        irpStack->Parameters.Create.EaLength = 0;

        status = SCCMN50M_CallSerialDriver(
                                          ATTACHED_DEVICE_OBJECT,
                                          irp
                                          );
        if (status != STATUS_SUCCESS) {

            leave;
        }

        KeClearEvent(&deviceExtension->SerialCloseDone);

        pSmartcardExtension->SmartcardReply.BufferLength = pSmartcardExtension->SmartcardReply.BufferSize;
        pSmartcardExtension->SmartcardRequest.BufferLength = 0;

        pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERENUM_GET_PORT_NAME;
        status =  SCCMN50M_SerialIo(pSmartcardExtension);



      //
      // Channel id which the reader is using,
      // in our case the Portnumber
      // WCHAR are used. e.g. COM3
        pSmartcardExtension->ReaderCapabilities.Channel =
        pSmartcardExtension->SmartcardReply.Buffer[6] -'0';






        status = SCCMN50M_InitializeCardMan(&deviceExtension->SmartcardExtension);
        if (status != STATUS_SUCCESS) {

            leave;
        }


        status = SCCMN50M_StartCardTracking(deviceExtension);

        if (status != STATUS_SUCCESS) {

            leave;
        }

        status = IoSetDeviceInterfaceState(
                                          &deviceExtension->PnPDeviceName,
                                          TRUE
                                          );

        if (status != STATUS_SUCCESS) {

            leave;
        }

        deviceExtension->IoCount = 0;
        KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!Event ReaderStarted was set\n",DRIVER_NAME));

    }
    _finally {

        if (status == STATUS_SHARED_IRQ_BUSY) {

            SmartcardLogError(
                             DeviceObject,
                             SCCMN50M_IRQ_BUSY,
                             NULL,
                             status
                             );
        }

        IoFreeIrp(irp);
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!StartDevice: Exit\n",
                    DRIVER_NAME)
                  );

    return status;
}

/*****************************************************************************
Routine Description:

    Finishes card tracking requests and closes the connection to the
    serial driver.


Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_StopDevice(
                   IN PDEVICE_EXTENSION DeviceExtension
                   )
{
    NTSTATUS status;
    PUCHAR requestBuffer;
    PSMARTCARD_EXTENSION smartcardExtension;


    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!StopDevice: Enter\n",
                    DRIVER_NAME)
                  );

    if (KeReadStateEvent(&DeviceExtension->SerialCloseDone) == 0l) {

        smartcardExtension = &DeviceExtension->SmartcardExtension;


        SCCMN50M_StopCardTracking(DeviceExtension);


        SCCMN50M_CloseSerialDriver (smartcardExtension->OsData->DeviceObject);



      // now wait until the connetion to serial is closed
        status = KeWaitForSingleObject(
                                      &DeviceExtension->SerialCloseDone,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL
                                      );
        ASSERT(status == STATUS_SUCCESS);
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!StopDevice: Exit\n",
                    DRIVER_NAME)
                  );
}

NTSTATUS
SCCMN50M_SystemControl(
                      PDEVICE_OBJECT DeviceObject,
                      PIRP        Irp
                      )
/*++

--*/
{
    PDEVICE_EXTENSION DeviceExtension; 
    NTSTATUS status = STATUS_SUCCESS;

    DeviceExtension      = DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject, Irp);

    return status;

}


/*****************************************************************************
Routine Description:

    This is our IOCTL dispatch function


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_DeviceControl(
                      PDEVICE_OBJECT DeviceObject,
                      PIRP Irp
                      )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    KIRQL irql;
    PIO_STACK_LOCATION            irpSp;


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!DeviceIoControl: Enter\n",DRIVER_NAME));

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();


#if DBG
    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_SMARTCARD_EJECT:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_EJECT"));
        break;
    case IOCTL_SMARTCARD_GET_ATTRIBUTE:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_ATTRIBUTE"));
        break;
    case IOCTL_SMARTCARD_GET_LAST_ERROR:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_LAST_ERROR"));
        break;
    case IOCTL_SMARTCARD_GET_STATE:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_STATE"));
        break;
    case IOCTL_SMARTCARD_IS_ABSENT:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_IS_ABSENT"));
        break;
    case IOCTL_SMARTCARD_IS_PRESENT:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_IS_PRESENT"));
        break;
    case IOCTL_SMARTCARD_POWER:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_POWER"));
        break;
    case IOCTL_SMARTCARD_SET_ATTRIBUTE:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SET_ATTRIBUTE"));
        break;
    case IOCTL_SMARTCARD_SET_PROTOCOL:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SET_PROTOCOL"));
        break;
    case IOCTL_SMARTCARD_SWALLOW:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SWALLOW"));
        break;
    case IOCTL_SMARTCARD_TRANSMIT:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_TRANSMIT"));
        break;
    default:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceControl: %s\n", DRIVER_NAME, "Vendor specific or unexpected IOCTL"));
        break;
    }
#endif


    if (KeReadStateEvent(&deviceExtension->SerialCloseDone) != 0l) {
      // Device has been removed
      // fail the call
        status = STATUS_DEVICE_REMOVED;
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    status = SmartcardAcquireRemoveLock(&deviceExtension->SmartcardExtension);
    if (status != STATUS_SUCCESS) {

      // the device has been removed. Fail the call
        status = STATUS_DEVICE_REMOVED;
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        SmartcardDebug(DEBUG_TRACE,
                       ("%s!DeviceIoControl: Exit %x\n",DRIVER_NAME,status));

        return status;
    }


    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    if (deviceExtension->IoCount < 0) {

        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!waiting for Event ReaderStarted\n",DRIVER_NAME));
        KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
        status = KeWaitForSingleObject(
                                      &deviceExtension->ReaderStarted,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL
                                      );
        ASSERT(status == STATUS_SUCCESS);

        KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    }
    ASSERT(deviceExtension->IoCount >= 0);


    deviceExtension->IoCount++;
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);


   // wait for update thread
    KeWaitForSingleObject(
                         &deviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL
                         );

    status = SCCMN50M_UpdateCurrentState(&(deviceExtension->SmartcardExtension));

    status = SmartcardDeviceControl(
                                   &(deviceExtension->SmartcardExtension),
                                   Irp
                                   );

   // release for update thread
    KeReleaseMutex(
                  &deviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                  FALSE
                  );


    SmartcardReleaseRemoveLock(&deviceExtension->SmartcardExtension);

    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    deviceExtension->IoCount--;
    ASSERT(deviceExtension->IoCount >= 0);
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!DeviceIoControl: Exit %x\n",DRIVER_NAME,status));

    return status;
}

/*****************************************************************************
Routine Description:

    This function closes the connection to the serial driver when the reader
    has been removed (unplugged). This function runs as a system thread at
    IRQL == PASSIVE_LEVEL. It waits for the remove event that is set by
    the IoCompletionRoutine


Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_CloseSerialDriver(
                          IN PDEVICE_OBJECT DeviceObject
                          )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    IO_STATUS_BLOCK ioStatusBlock;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!CloseSerialDriver: Enter\n",
                    DRIVER_NAME)
                  );
   //
   // first mark this device as 'gone'.
   // This will prevent that someone can re-open the device
   //
    status = IoSetDeviceInterfaceState(
                                      &deviceExtension->PnPDeviceName,
                                      FALSE
                                      );

    irp = IoAllocateIrp(
                       (CCHAR) (DeviceObject->StackSize + 1),
                       FALSE
                       );

    ASSERT(irp != NULL);

    if (irp) {

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ( "%s!CloseSerialDriver: Sending IRP_MJ_CLOSE\n",
                        DRIVER_NAME)
                      );

        IoSetNextIrpStackLocation(irp);

      //
      // We send down a close to the serial driver. This close goes
      // through serenum first which will trigger it to start looking
      // for changes on the com-port. Since our device is gone it will
      // call the device removal event of our PnP dispatch.
      //
        irp->UserIosb = &ioStatusBlock;
        irpStack = IoGetCurrentIrpStackLocation( irp );
        irpStack->MajorFunction = IRP_MJ_CLOSE;

        status = SCCMN50M_CallSerialDriver(
                                          ATTACHED_DEVICE_OBJECT,
                                          irp
                                          );

        ASSERT(status == STATUS_SUCCESS);

        IoFreeIrp(irp);
    }


   // now 'signal' that we closed the serial driver
    KeSetEvent(&deviceExtension->SerialCloseDone, 0, FALSE);

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!CloseSerialDriver: Exit\n",
                    DRIVER_NAME)
                  );
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_IoCompletion (
                      IN PDEVICE_OBJECT DeviceObject,
                      IN PIRP Irp,
                      IN PKEVENT Event
                      )
{
    UNREFERENCED_PARAMETER (DeviceObject);

    if (Irp->Cancel) {

        Irp->IoStatus.Status = STATUS_CANCELLED;

    } else {

        Irp->IoStatus.Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    KeSetEvent (Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

/*****************************************************************************
Routine Description:

   Send an Irp to the serial driver.


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_CallSerialDriver(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp
                         )
{

    NTSTATUS status = STATUS_SUCCESS;
    KEVENT Event;

   // Copy our stack location to the next.
    IoCopyCurrentIrpStackLocationToNext(Irp);

   //
   // initialize an event for process synchronization. The event is passed
   // to our completion routine and will be set when the serial driver is done
   //
    KeInitializeEvent(
                     &Event,
                     NotificationEvent,
                     FALSE
                     );

   // Our IoCompletionRoutine sets only our event
    IoSetCompletionRoutine (
                           Irp,
                           SCCMN50M_IoCompletion,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER) {

        status = PoCallDriver(DeviceObject, Irp);

    } else {

      // Call the serial driver
        status = IoCallDriver(DeviceObject, Irp);
    }

   // Wait until the serial driver has processed the Irp
    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject(
                                      &Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL
                                      );

        ASSERT (STATUS_SUCCESS == status);
        status = Irp->IoStatus.Status;
    }

    return status;
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_PnP(
            IN PDEVICE_OBJECT DeviceObject,
            IN PIRP Irp
            )
{

    PUCHAR requestBuffer;
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PREADER_EXTENSION readerExtension = smartcardExtension->ReaderExtension;
    PDEVICE_OBJECT AttachedDeviceObject;
    PIO_STACK_LOCATION irpStack;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOLEAN deviceRemoved = FALSE, irpSkipped = FALSE;
    KIRQL irql;
    PDEVICE_CAPABILITIES DeviceCapabilities;


    PAGED_CODE();

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!PnPDeviceControl: Enter\n",
                    DRIVER_NAME)
                  );

    status = SmartcardAcquireRemoveLock(smartcardExtension);
    ASSERT(status == STATUS_SUCCESS);

    if (status != STATUS_SUCCESS) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;


    irpStack = IoGetCurrentIrpStackLocation(Irp);

   // Now look what the PnP manager wants...
    switch (irpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!PnPDeviceControl: IRP_MN_START_DEVICE\n",
                       DRIVER_NAME)
                      );

         // We have to call the underlying driver first
        status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);
        ASSERT(NT_SUCCESS(status));

        if (NT_SUCCESS(status)) {

            status = SCCMN50M_StartDevice(DeviceObject);
        }



        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!PnPDeviceControl: IRP_MN_QUERY_STOP_DEVICE\n",
                       DRIVER_NAME)
                      );

        KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
        if (deviceExtension->IoCount > 0) {

            // we refuse to stop if we have pending io
            KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
            status = STATUS_DEVICE_BUSY;

        } else {

            // stop processing requests
            deviceExtension->IoCount = -1;
            KeClearEvent(&deviceExtension->ReaderStarted);
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!Event ReaderStarted was cleared\n",DRIVER_NAME));
            KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
            status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!PnPDeviceControl: IRP_MN_CANCEL_STOP_DEVICE\n",
                       DRIVER_NAME)
                      );

        status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);

        if (status == STATUS_SUCCESS) {

            // we can continue to process requests
            deviceExtension->IoCount = 0;
            KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!Event ReaderStarted was set\n",DRIVER_NAME));
        }
        break;

    case IRP_MN_STOP_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!PnPDeviceControl: IRP_MN_STOP_DEVICE\n",
                       DRIVER_NAME)
                      );

        SCCMN50M_StopDevice(deviceExtension);

         //
         // we don't do anything since a stop is only used
         // to reconfigure hw-resources like interrupts and io-ports
         //
        status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!PnPDeviceControl: IRP_MN_QUERY_REMOVE_DEVICE\n",
                       DRIVER_NAME)
                      );

         // disable the interface (and ignore possible errors)
        IoSetDeviceInterfaceState(&deviceExtension->PnPDeviceName,
                                  FALSE);

         // now look if someone is currently connected to us
        if (KeReadStateEvent(&deviceExtension->ReaderClosed) == 0l) {
            //
            // someone is connected, fail the call
            // we will enable the device interface in
            // IRP_MN_CANCEL_REMOVE_DEVICE again
            //
            status = STATUS_UNSUCCESSFUL;
            break;
        }

         // pass the call to the next driver in the stack
        status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!PnPDeviceControl: IRP_MN_CANCEL_REMOVE_DEVICE\n",
                       DRIVER_NAME)
                      );

        status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);

        if (status == STATUS_SUCCESS) {
            status = IoSetDeviceInterfaceState(&deviceExtension->PnPDeviceName,
                                               TRUE);
            ASSERT(status == STATUS_SUCCESS);
        }
        break;

    case IRP_MN_REMOVE_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!PnPDeviceControl: IRP_MN_REMOVE_DEVICE\n",
                       DRIVER_NAME)
                      );

        SCCMN50M_RemoveDevice(DeviceObject);
        status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);
        deviceRemoved = TRUE;
        break;

         // ---------------------
         // IRP_MN_QUERY_CAPABILITIES
         // ---------------------
    case IRP_MN_QUERY_CAPABILITIES:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!PnPDeviceControl: IRP_MN_QUERY_CAPABILITIES\n",
                       DRIVER_NAME));

         //
         // Get the packet.
         //
        DeviceCapabilities=irpStack->Parameters.DeviceCapabilities.Capabilities;

        if (DeviceCapabilities->Version == 1 &&
            DeviceCapabilities->Size == sizeof(DEVICE_CAPABILITIES)) {
            //
            // Set the capabilities.
            //

            // We cannot wake the system.
            DeviceCapabilities->SystemWake = PowerSystemUnspecified;
            DeviceCapabilities->DeviceWake = PowerDeviceUnspecified;

            // We have no latencies
            DeviceCapabilities->D1Latency = 0;
            DeviceCapabilities->D2Latency = 0;
            DeviceCapabilities->D3Latency = 0;

            // No locking or ejection
            DeviceCapabilities->LockSupported = FALSE;
            DeviceCapabilities->EjectSupported = FALSE;

            // Device can be physically removed.
            DeviceCapabilities->Removable = TRUE;

            // No docking device
            DeviceCapabilities->DockDevice = FALSE;

            // Device can not be removed any time
            // it has a removable media
            DeviceCapabilities->SurpriseRemovalOK = FALSE;
        }

         //
         // Pass the IRP down
         //
        status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);

        break; // end, case IRP_MN_QUERY_CAPABILITIES

    default:
#if DBG
        switch (irpStack->MinorFunction) {
        case IRP_MN_QUERY_DEVICE_RELATIONS       :
               // This is an Irp that is only useful for underlying drivers
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!PnPDeviceControl: IRP_MN_QUERY_DEVICE_RELATIONS\n",
                           DRIVER_NAME));
            break;
        case IRP_MN_QUERY_INTERFACE              :
               // This is an Irp that is only useful for underlying drivers
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!PnPDeviceControl: IRP_MN_QUERY_INTERFACE\n",
                           DRIVER_NAME));
            break;
        case IRP_MN_QUERY_CAPABILITIES           :
               // This is an Irp that is only useful for underlying drivers
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!PnPDeviceControl: IRP_MN_QUERY_CAPABILITIES\n",
                           DRIVER_NAME));
            break;
        case IRP_MN_QUERY_RESOURCES              :
               // This is an Irp that is only useful for underlying drivers
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!PnPDeviceControl: IRP_MN_QUERY_RESOURCES\n",
                           DRIVER_NAME));
            break;
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS  :
               // This is an Irp that is only useful for underlying drivers
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!PnPDeviceControl: IRP_MN_QUERY_RESOURCE_REQUIEREMENTS\n",
                           DRIVER_NAME));
            break;
        case IRP_MN_QUERY_DEVICE_TEXT            :
               // This is an Irp that is only useful for underlying drivers
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!PnPDeviceControl: IRP_MN_QUERY_DEVICE_TEXT\n",
                           DRIVER_NAME));
            break;
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS :
               // This is an Irp that is only useful for underlying drivers
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!PnPDeviceControl: IRP_MN_FILTER_RESOURCE_REQUIREMENTS\n",
                           DRIVER_NAME));
            break;
        default :
        case IRP_MN_READ_CONFIG :
               // This is an Irp that is only useful for underlying drivers
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!PnPDeviceControl: IRP_MN_READ_CONFIG\n",
                           DRIVER_NAME));
            break;

               // This is an Irp that is only useful for underlying drivers
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!PnPDeviceControl: IRP_MN_...%lx\n",
                           DRIVER_NAME,
                           irpStack->MinorFunction));
            break;
        }
#endif



        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(AttachedDeviceObject, Irp);
        irpSkipped = TRUE;
        break;
    }

    if (irpSkipped == FALSE) {

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    if (deviceRemoved == FALSE) {

        SmartcardReleaseRemoveLock(smartcardExtension);
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!PnPDeviceControl: Exit %lx\n",
                    DRIVER_NAME,
                    status)
                  );

    return status;
}

/*****************************************************************************
Routine Description:

    This function is called when the underlying stacks
    completed the power transition.


Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_SystemPowerCompletion(
                              IN PDEVICE_OBJECT DeviceObject,
                              IN UCHAR MinorFunction,
                              IN POWER_STATE PowerState,
                              IN PKEVENT Event,
                              IN PIO_STATUS_BLOCK IoStatus
                              )
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (PowerState);
    UNREFERENCED_PARAMETER (IoStatus);

    KeSetEvent(Event, 0, FALSE);
}

/*****************************************************************************
Routine Description:

    This routine is called after the underlying stack powered
    UP the serial port, so it can be used again.


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_DevicePowerCompletion (
                               IN PDEVICE_OBJECT DeviceObject,
                               IN PIRP Irp,
                               IN PSMARTCARD_EXTENSION SmartcardExtension
                               )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    UCHAR  pbAtrBuffer[MAXIMUM_ATR_LENGTH];
    ULONG  ulAtrLength;
    ULONG  ulOldState;
    NTSTATUS status;
    KIRQL irql;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!DevicePowerCompletion: Enter\n",DRIVER_NAME));




   // We have to remember the old card state because
   // it is overwritten by SCCMN50M_InitializeCardMan
    ulOldState=SmartcardExtension->ReaderExtension->ulOldCardState;
    status = SCCMN50M_InitializeCardMan(SmartcardExtension);
   // Set back the previous state
    SmartcardExtension->ReaderExtension->ulOldCardState = ulOldState;
    if (status != STATUS_SUCCESS) {
        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!InitializeCardMan failed ! %lx\n",DRIVER_NAME,status));
    }

   //
   // We issue a power request in because
   // we powered down the card before
   //
   //SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
   //status = SCCMN50M_PowerOn (SmartcardExtension,&ulAtrLength,pbAtrBuffer,sizeof(pbAtrBuffer));

   //
   // If a card was present before power down or now there is
   // a card in the reader, we complete any pending card monitor
   // request, since we do not really know what card is now in the
   // reader.
   //

    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);

    if (SmartcardExtension->ReaderExtension->CardPresent ||
        SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT) {
        deviceExtension->SmartcardExtension.ReaderExtension->ulOldCardState = UNKNOWN;
        deviceExtension->SmartcardExtension.ReaderExtension->ulNewCardState = UNKNOWN;
    }

    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                      irql);


    status = SCCMN50M_StartCardTracking(deviceExtension);
    if (status != STATUS_SUCCESS) {
        SmartcardDebug(DEBUG_ERROR,
                       ("%s!StartCardTracking failed ! %lx\n",DRIVER_NAME,status));
    }

   // save the current power state of the reader
    SmartcardExtension->ReaderExtension->ReaderPowerState =  PowerReaderWorking;

    SmartcardReleaseRemoveLock(SmartcardExtension);

   // inform the power manager of our state.
    PoSetPowerState (DeviceObject,
                     DevicePowerState,
                     irpStack->Parameters.Power.State);

    PoStartNextPowerIrp(Irp);

   // signal that we can process ioctls again
    deviceExtension->IoCount = 0;
    KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!Event ReaderStarted was set\n",DRIVER_NAME));




    SmartcardDebug(DEBUG_TRACE,
                   ("%s!DevicePowerCompletion: Exit\n",DRIVER_NAME));
    return STATUS_SUCCESS;
}

/*****************************************************************************
Routine Description:
    The power dispatch routine.
    This driver is the power policy owner of the device stack,
    because this driver knows about the connected reader.
    Therefor this driver will translate system power states
    to device power states.

Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT status code

*****************************************************************************/
typedef enum _ACTION {

    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending

} ACTION;

NTSTATUS
SCCMN50M_Power (
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
               )
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PDEVICE_OBJECT AttachedDeviceObject;
    POWER_STATE powerState;
    ACTION action = SkipRequest;
    KEVENT event;
    KIRQL irql;

    PAGED_CODE();

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!Power: Enter\n",
                   DRIVER_NAME)
                  );

    status = SmartcardAcquireRemoveLock(smartcardExtension);
    ASSERT(status == STATUS_SUCCESS);

    if (!NT_SUCCESS(status)) {
        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;

    if (irpStack->Parameters.Power.Type == DevicePowerState &&
        irpStack->MinorFunction == IRP_MN_SET_POWER) {

        switch (irpStack->Parameters.Power.State.DeviceState) {
        
        case PowerDeviceD0:
            // Turn on the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Power: PowerDevice D0\n",
                           DRIVER_NAME)
                          );





            //
            // First, we send down the request to the bus, in order
            // to power on the port. When the request completes,
            // we turn on the reader
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine (
                                   Irp,
                                   SCCMN50M_DevicePowerCompletion,
                                   smartcardExtension,
                                   TRUE,
                                   TRUE,
                                   TRUE
                                   );

            action = WaitForCompletion;
            break;
                                                               
        case PowerDeviceD3:



            SCCMN50M_StopCardTracking(deviceExtension);
            // Turn off the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Power: PowerDevice D3\n",
                           DRIVER_NAME)
                          );

            PoSetPowerState (
                            DeviceObject,
                            DevicePowerState,
                            irpStack->Parameters.Power.State
                            );

            // save the current card state
            KeAcquireSpinLock(&smartcardExtension->OsData->SpinLock,
                              &irql);

            smartcardExtension->ReaderExtension->CardPresent = smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;

            if (smartcardExtension->ReaderExtension->CardPresent) {
                KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                  irql);

                smartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
                status = SCCMN50M_PowerOff(smartcardExtension);
                ASSERT(status == STATUS_SUCCESS);
            } else {
                KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                  irql);
            }


            // save the current power state of the reader
            smartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderOff;

            action = SkipRequest;
            break;

        default:
            action = SkipRequest;
            break;
        }
    }

    if (irpStack->Parameters.Power.Type == SystemPowerState) {

      //
      // The system wants to change the power state.
      // We need to translate the system power state to
      // a corresponding device power state.
      //

        POWER_STATE_TYPE powerType = DevicePowerState;

        ASSERT(smartcardExtension->ReaderExtension->ReaderPowerState !=
               PowerReaderUnspecified);

        switch (irpStack->MinorFunction) {
        KIRQL irql;

        case IRP_MN_QUERY_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Power: Query Power\n",
                           DRIVER_NAME)
                          );

            switch (irpStack->Parameters.Power.State.SystemState) {
            
            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
                action = SkipRequest;
                break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:
                KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
                if (deviceExtension->IoCount == 0) {
                     // Block any further ioctls
                    deviceExtension->IoCount = -1;
                    KeClearEvent(&deviceExtension->ReaderStarted);
                    SmartcardDebug(DEBUG_DRIVER,
                                   ("%s!Event ReaderStarted was cleared\n",DRIVER_NAME));
                    action = SkipRequest;
                } else {
                     // can't go to sleep mode since the reader is busy.
                    status = STATUS_DEVICE_BUSY;
                    action = CompleteRequest;
                }
                KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
                break;
            }
            break;

        case IRP_MN_SET_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Power: PowerSystem S%d\n",
                           DRIVER_NAME,
                           irpStack->Parameters.Power.State.SystemState - 1)
                          );

            switch (irpStack->Parameters.Power.State.SystemState) {
            
            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:

                if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                    PowerReaderWorking) {

                     // We're already in the right state
                    action = SkipRequest;
                    break;
                }

                  // wake up the underlying stack...
                powerState.DeviceState = PowerDeviceD0;
                action = MarkPending;
                break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:

                KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
                if (deviceExtension->IoCount == 0) {
                     // Block any further ioctls
                    deviceExtension->IoCount = -1;
                    KeClearEvent(&deviceExtension->ReaderStarted);
                    SmartcardDebug(DEBUG_DRIVER,
                                   ("%s!Event ReaderStarted was cleared\n",DRIVER_NAME));
                    action = SkipRequest;
                } else {
                     // can't go to sleep mode since the reader is busy.
                    status = STATUS_DEVICE_BUSY;
                    action = CompleteRequest;
                }
                KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

                if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                    PowerReaderOff) {
                     // We're already in the right state
                    action = SkipRequest;
                    break;
                }

                powerState.DeviceState = PowerDeviceD3;

                  // first, inform the power manager of our new state.
                PoSetPowerState (
                                DeviceObject,
                                SystemPowerState,
                                powerState
                                );

                action = MarkPending;
                break;

            default:

                action = SkipRequest;
                break;
            }
        }
    }

    switch (action) {
    case CompleteRequest:
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;

        SmartcardReleaseRemoveLock(smartcardExtension);
        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    case MarkPending:
         // initialize the event we need in the completion function
        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE);
         // request the device power irp
        status = PoRequestPowerIrp (DeviceObject,
                                    IRP_MN_SET_POWER,
                                    powerState,
                                    SCCMN50M_SystemPowerCompletion,
                                    &event,
                                    NULL);
        ASSERT(status == STATUS_PENDING);
        if (status == STATUS_PENDING) {
            // wait until the device power irp completed
            status = KeWaitForSingleObject(&event,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL);

            SmartcardReleaseRemoveLock(smartcardExtension);

            if (powerState.SystemState == PowerSystemWorking) {
                PoSetPowerState (DeviceObject,
                                 SystemPowerState,
                                 powerState);
            }

            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(AttachedDeviceObject, Irp);

        } else {
            SmartcardReleaseRemoveLock(smartcardExtension);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        break;

    case SkipRequest:
        SmartcardReleaseRemoveLock(smartcardExtension);
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        status = PoCallDriver(AttachedDeviceObject, Irp);
        break;

    case WaitForCompletion:
        status = PoCallDriver(AttachedDeviceObject, Irp);
        break;

    default:
        ASSERT(FALSE);
        SmartcardReleaseRemoveLock(smartcardExtension);
        break;
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!Power: Exit %lx\n",
                   DRIVER_NAME,
                   status)
                  );

    return status;
}

/*****************************************************************************
Routine Description:

    This routine is called by the I/O system when the device is opened or closed.

Arguments:

    DeviceObject    - Pointer to device object for this miniport
    Irp             - IRP involved.

Return Value:

    STATUS_SUCCESS.

*****************************************************************************/
NTSTATUS
SCCMN50M_CreateClose(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
                    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    if (irpStack->MajorFunction == IRP_MJ_CREATE) {
        status = SmartcardAcquireRemoveLock(&deviceExtension->SmartcardExtension);


        if (status != STATUS_SUCCESS) {
            status = STATUS_DEVICE_REMOVED;
        } else {

            LARGE_INTEGER timeout;

            timeout.QuadPart = 0;

         // test if the device has been opened already
            status = KeWaitForSingleObject(
                                          &deviceExtension->ReaderClosed,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          &timeout
                                          );

            if (status == STATUS_SUCCESS) {

                KeClearEvent(&deviceExtension->ReaderClosed);
                SmartcardDebug(
                              DEBUG_DRIVER,
                              ("%s!CreateClose: Open\n",
                               DRIVER_NAME)
                              );

            } else {

            // the device is already in use
                status = STATUS_UNSUCCESSFUL;
                SmartcardReleaseRemoveLock(&deviceExtension->SmartcardExtension);


            }
        }

    } else {

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!CreateClose: Close\n",
                       DRIVER_NAME)
                      );

        SmartcardReleaseRemoveLock(&deviceExtension->SmartcardExtension);
        KeSetEvent(&deviceExtension->ReaderClosed, 0, FALSE);
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

/*****************************************************************************
Routine Description:

    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject    - Pointer to device object for this miniport
    Irp             - IRP involved.

Return Value:

    STATUS_CANCELLED

*****************************************************************************/
NTSTATUS
SCCMN50M_Cancel(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
               )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!Cancel: Enter\n",
                   DRIVER_NAME)
                  );

    ASSERT(Irp == smartcardExtension->OsData->NotificationIrp);

    IoReleaseCancelSpinLock(
                           Irp->CancelIrql
                           );

    SCCMN50M_CompleteCardTracking(smartcardExtension);

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!Cancel: Exit\n",
                   DRIVER_NAME)
                  );

    return STATUS_CANCELLED;
}

/*****************************************************************************
Routine Description:

    This routine is called when the calling application terminates.
    We can actually only have the notification irp that we have to cancel.


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_Cleanup(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN fCancelIrp = FALSE;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!Cleanup: Enter\n",
                   DRIVER_NAME)
                  );


    if (Irp != smartcardExtension->OsData->NotificationIrp)
        fCancelIrp = TRUE;


   // We need to complete the notification irp
    SCCMN50M_CompleteCardTracking(smartcardExtension);

    if (fCancelIrp == TRUE) {
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!Cleanup: Completing IRP %lx\n",
                       DRIVER_NAME,
                       Irp)
                      );

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_SUCCESS;

        IoCompleteRequest(
                         Irp,
                         IO_NO_INCREMENT
                         );
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!Cleanup: Exit\n",
                   DRIVER_NAME)
                  );

    return STATUS_SUCCESS;
}

/*****************************************************************************
Routine Description:
    Remove the device from the system.



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_RemoveDevice(
                     PDEVICE_OBJECT DeviceObject
                     )
{
    PDEVICE_EXTENSION deviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension;
    NTSTATUS status;

    PAGED_CODE();

    if (DeviceObject == NULL) {

        return;
    }

    deviceExtension = DeviceObject->DeviceExtension;
    smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!RemoveDevice: Enter\n",
                    DRIVER_NAME)
                  );

    if (smartcardExtension->OsData) {
      // complete pending card tracking requests (if any)
        SCCMN50M_CompleteCardTracking(smartcardExtension);
        ASSERT(smartcardExtension->OsData->NotificationIrp == NULL);
    }

   // Wait until we can safely unload the device
    SmartcardReleaseRemoveLockAndWait(smartcardExtension);

    ASSERT(deviceExtension->DeviceInstance < MAXIMUM_SMARTCARD_READERS);
    ASSERT(DeviceSlot[deviceExtension->DeviceInstance] == TRUE);

   // Mark this slot as available
    DeviceSlot[deviceExtension->DeviceInstance] = FALSE;

    SCCMN50M_StopDevice(deviceExtension);

    if (ATTACHED_DEVICE_OBJECT) {

        IoDetachDevice(ATTACHED_DEVICE_OBJECT);
    }

    if (deviceExtension->PnPDeviceName.Buffer != NULL) {

        RtlFreeUnicodeString(&deviceExtension->PnPDeviceName);
    }

    if (smartcardExtension->OsData != NULL) {

        SmartcardExit(smartcardExtension);
    }

    if (smartcardExtension->ReaderExtension != NULL) {

        ExFreePool(smartcardExtension->ReaderExtension);
    }

    IoDeleteDevice(DeviceObject);

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!RemoveDevice: Exit\n",
                    DRIVER_NAME)
                  );
}

/*****************************************************************************
Routine Description:
    The driver unload routine.  This is called by the I/O system
    when the device is unloaded from memory.

Arguments:
    DriverObject - Pointer to driver object created by system.

Return Value:
    STATUS_SUCCESS.

*****************************************************************************/
VOID
SCCMN50M_DriverUnload(
                     IN PDRIVER_OBJECT DriverObject
                     )
{
    PAGED_CODE();

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!DriverUnload\n",
                   DRIVER_NAME)
                  );
}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_CompleteCardTracking(
                             IN PSMARTCARD_EXTENSION SmartcardExtension
                             )
{
    KIRQL ioIrql, keIrql;
    PIRP notificationIrp;

    IoAcquireCancelSpinLock(&ioIrql);
    KeAcquireSpinLock(
                     &SmartcardExtension->OsData->SpinLock,
                     &keIrql
                     );

    notificationIrp = SmartcardExtension->OsData->NotificationIrp;
    SmartcardExtension->OsData->NotificationIrp = NULL;

    KeReleaseSpinLock(
                     &SmartcardExtension->OsData->SpinLock,
                     keIrql
                     );

    if (notificationIrp) {
        IoSetCancelRoutine(
                          notificationIrp,
                          NULL
                          );
    }

    IoReleaseCancelSpinLock(ioIrql);

    if (notificationIrp) {

      //    finish the request
        if (notificationIrp->Cancel) {
            notificationIrp->IoStatus.Status = STATUS_CANCELLED;
        } else {
            notificationIrp->IoStatus.Status = STATUS_SUCCESS;
        }

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!CompleteCardTracking: Completing NotificationIrp %lxh IoStatus=%lxh\n",
                       DRIVER_NAME,
                       notificationIrp,
                       notificationIrp->IoStatus.Status
                      )
                      );
        notificationIrp->IoStatus.Information = 0;

        IoCompleteRequest(
                         notificationIrp,
                         IO_NO_INCREMENT
                         );
    }
}

/*****************************************************************************
* History:
* $Log: sccmnt5.c $
* Revision 1.7  2001/01/22 08:39:42  WFrischauf
* No comment given
*
* Revision 1.6  2000/09/25 10:46:24  WFrischauf
* No comment given
*
* Revision 1.5  2000/08/24 09:05:45  TBruendl
* No comment given
*
* Revision 1.4  2000/08/14 12:41:06  TBruendl
* bug fix in CreateDevice
*
* Revision 1.3  2000/07/28 09:24:15  TBruendl
* Changes for OMNIKEY on Whistler CD
*
* Revision 1.6  2000/03/03 09:50:51  TBruendl
* No comment given
*
* Revision 1.5  2000/03/01 09:32:07  TBruendl
* R02.20.0
*
* Revision 1.4  1999/12/13 07:57:18  TBruendl
* bug fixes for hiberantion tests of MS test suite
*
* Revision 1.3  1999/11/04 07:53:24  WFrischauf
* bug fixes due to error reports 2 - 7
*
* Revision 1.2  1999/06/10 09:03:59  TBruendl
* No comment given
*
* Revision 1.1  1999/02/02 13:34:41  TBruendl
* This is the first release (R01.00) of the IFD handler for CardMan running under NT5.0.
*
*
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\sccmusbm\pcsc_cm.h ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmapiifd/sw/sccmusbm.ms/rcs/pcsc_cm.h $
* $Revision: 1.1 $
*-----------------------------------------------------------------------------
* $Author: TBruendl $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright (c) 1996-99 Utimaco Safeware AG
******************************************************************************/

#ifndef _INC_PCSC_CM
#define _INC_PCSC_CM

/*****************************************************************************/
/** includes                                                                **/
/*****************************************************************************/

#include <winsmcrd.h>
#include <devioctl.h>

/*****************************************************************************/
/** constants                                                               **/
/*****************************************************************************/

#define CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED           SCARD_CTL_CODE (3000)
#define CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED_OLD       SCARD_CTL_CODE (0x8100)

#define CM_IOCTL_GET_FW_VERSION                       SCARD_CTL_CODE (3001)
#define CM_IOCTL_GET_FW_VERSION_OLD                   SCARD_CTL_CODE (0x8101)

//#define CM_SPE_SECURE_PIN_ENTRY                    SCARD_CTL_CODE (0x8102)
//#define CM_IOCTL_IS_SPE_SUPPORTED                   SCARD_CTL_CODE (3003)
//#define CM_IOCTL_IS_SPE_SUPPORTED_OLD               SCARD_CTL_CODE (0x8103)

#define CM_IOCTL_READ_DEVICE_DESCRIPTION              SCARD_CTL_CODE (3004)

#define CM_IOCTL_SET_SYNC_PARAMETERS                  SCARD_CTL_CODE (3010)
#define CM_IOCTL_2WBP_RESET_CARD                      SCARD_CTL_CODE (3011)
#define CM_IOCTL_2WBP_TRANSFER                        SCARD_CTL_CODE (3012)
#define CM_IOCTL_3WBP_TRANSFER                        SCARD_CTL_CODE (3013)
#define CM_IOCTL_SYNC_CARD_POWERON                    SCARD_CTL_CODE (3014)

#define CM_IOCTL_SET_READER_38400_BAUD                SCARD_CTL_CODE (3020)
#define CM_IOCTL_SET_READER_9600_BAUD                 SCARD_CTL_CODE (3021)

#define CM_IOCTL_OPEN_CT_INTERFACE                    SCARD_CTL_CODE (3022)
#define CM_IOCTL_CLOSE_CT_INTERFACE                   SCARD_CTL_CODE (3023)
#define CM_IOCTL_GET_CT_STATE                         SCARD_CTL_CODE (3024)


//****************************************************************************
//* SYNCHRONOUS SMART CARDS
//****************************************************************************
#define SCARD_RESET_LINE_HIGH      0x00000001
#define SCARD_RESET_LINE_LOW       0x00000000

#define SCARD_PROTOCOL_2WBP        0x00000001
#define SCARD_PROTOCOL_3WBP        0x00000002

//#define CLOCK_FORDCED_2WBP         0x00000040

//----------------------------------------------------------------------------
// structure for "CM_IOCTL_SET_SYNC_PARAMETERS" IO-Control (CrasControl)
//----------------------------------------------------------------------------
#ifndef BOOL
   #define BOOL unsigned int
#endif

typedef struct _SYNC_PARAMETERS {
   ULONG  ulProtocol;
   ULONG  ulStateResetLineWhileReading;
   ULONG  ulStateResetLineWhileWriting;
   ULONG  ulWriteDummyClocks;
   ULONG  ulHeaderLen;
   BOOL   fCardResetRequested;
   BOOL   fCardPowerRequested;
} SYNC_PARAMETERS, *PSYNC_PARAMETERS;


//----------------------------------------------------------------------------
//  structure for CM_IOCTL_2WBP_TRANSFER and  CM_IOCTL_3WBP_TRANSFER
//  IO-Control (CRASControl)
//----------------------------------------------------------------------------
typedef struct _SYNC_TRANSFER
{
   ULONG ulSyncBitsToWrite;
   ULONG ulSyncBitsToRead;
}SYNC_TRANSFER, *PSYNC_TRANSFER;

#endif /* _INC_PCSC_CM */


/*****************************************************************************
* History:
* $Log: pcsc_cm.h $
* Revision 1.1  2000/03/29 06:08:13  TBruendl
* No comment given
*
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\sccmusbm\sccmusbm.h ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmeu0/sw/sccmusbm.ms/rcs/sccmusbm.h $
* $Revision: 1.5 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/

#ifndef CMUSB_INC
   #define CMUSB_INC


/*****************************************************************************
*                         Defines
******************************************************************************/
   #define DRIVER_NAME "CMUSB"
   #define SMARTCARD_POOL_TAG 'CUCS'

   #include "smclib.h"
   #include "pcsc_cm.h"

   #define CARDMAN_USB_DEVICE_NAME  L"\\Device\\CM_2020_"



   #define MAXIMUM_USB_READERS    10
   #define MAXIMUM_OEM_NAMES          4


   #define VERSIONMAJOR_CARDMAN_USB  3
   #define VERSIONMINOR_CARDMAN_USB  2
   #define BUILDNUMBER_CARDMAN_USB   1

   #define CM2020_VENDOR_NAME       "OMNIKEY"
   #define CM2020_PRODUCT_NAME  "CardMan 2020"

   #define ATTR_MAX_IFSD_CARDMAN_USB  35
   #define ATTR_MAX_IFSD_SYNCHRON_USB  48


   #define UNKNOWN    0xFFFFFFFF
   #define REMOVED    0x00000001
   #define INSERTED   0x00000002
   #define POWERED    0x00000004



   #define CMUSB_BUFFER_SIZE   300
   #define CMUSB_REPLY_BUFFER_SIZE 512
   #define CMUSB_SYNCH_BUFFER_SIZE   64



// defines for CMUSB_SetCardParameters

   #define CMUSB_SMARTCARD_SYNCHRONOUS       0x80
   #define CMUSB_SMARTCARD_ASYNCHRONOUS      0x00

   #define CMUSB_BAUDRATE_9600               0x01
   #define CMUSB_BAUDRATE_19200              0x02
//#define CMUSB_BAUDRATE_28800              0x03
   #define CMUSB_BAUDRATE_38400              0x04
//#define CMUSB_BAUDRATE_57600              0x06
   #define CMUSB_BAUDRATE_76800              0x08
   #define CMUSB_BAUDRATE_115200             0x0C

   #define CMUSB_FREQUENCY_3_72MHZ           0x00
   #define CMUSB_FREQUENCY_5_12MHZ           0x10

   #define CMUSB_ODD_PARITY                 0x80
   #define CMUSB_EVEN_PARITY                0x00


   #define SMARTCARD_COLD_RESET        0x00
   #define SMARTCARD_WARM_RESET        0x01




   #define DEFAULT_TIMEOUT_P1          1000

// own IOCTLs
//#define CMUSB_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED           SCARD_CTL_CODE (3000)
//#define CMUSB_IOCTL_GET_FW_VERSION                       SCARD_CTL_CODE (3001)
// #define CMUSB_IOCTL_SPE_SECURE_PIN_ENTRY              SCARD_CTL_CODE (0x3102)
//#define CMUSB_IOCTL_IS_SPE_SUPPORTED                     SCARD_CTL_CODE (3003)
//#define CMUSB_IOCTL_READ_DEVICE_DESCRIPTION              SCARD_CTL_CODE (3004)
//#define CMUSB_IOCTL_SET_SYNC_PARAMETERS                  SCARD_CTL_CODE (3010)
//#define CMUSB_IOCTL_2WBP_RESET_CARD                      SCARD_CTL_CODE (3011)
//#define CMUSB_IOCTL_2WBP_TRANSFER                        SCARD_CTL_CODE (3012)
//#define CMUSB_IOCTL_3WBP_TRANSFER                        SCARD_CTL_CODE (3013)
//#define CMUSB_IOCTL_SYNC_CARD_POWERON                    SCARD_CTL_CODE (3014)


   #define SLE4442_WRITE            0x38        /* write without protect bit    */
   #define SLE4442_WRITE_PROT_MEM   0x3C        /* write protection memory      */
   #define SLE4442_READ             0x30        /* read without protect bit     */
   #define SLE4442_READ_PROT_MEM    0x34        /* read protection memory       */
   #define SLE4442_READ_SEC_MEM     0x31        /* read security memory         */
   #define SLE4442_COMPARE_PIN      0x33        /* compare one PIN byte         */
   #define SLE4442_UPDATE_SEC_MEM   0x39        /* update security memory       */

   #define SLE4428_WRITE            0x33        /* write without protect bit     */
   #define SLE4428_WRITE_PROT       0x31        /* write with protect bit        */
   #define SLE4428_READ             0x0E        /* read without protect bit      */
   #define SLE4428_READ_PROT        0x0C        /* read with protect bit         */
   #define SLE4428_COMPARE          0x30        /* compare and write prot. bit   */
   #define SLE4428_SET_COUNTER      0xF2        /* write error counter           */
   #define SLE4428_COMPARE_PIN      0xCD        /* compare one PIN byte          */


   #if DBG


static const PCHAR szIrpMajFuncDesc[] =
{  // note this depends on corresponding values to the indexes in wdm.h
   "IRP_MJ_CREATE",
   "IRP_MJ_CREATE_NAMED_PIPE",
   "IRP_MJ_CLOSE",
   "IRP_MJ_READ",
   "IRP_MJ_WRITE",
   "IRP_MJ_QUERY_INFORMATION",
   "IRP_MJ_SET_INFORMATION",
   "IRP_MJ_QUERY_EA",
   "IRP_MJ_SET_EA",
   "IRP_MJ_FLUSH_BUFFERS",
   "IRP_MJ_QUERY_VOLUME_INFORMATION",
   "IRP_MJ_SET_VOLUME_INFORMATION",
   "IRP_MJ_DIRECTORY_CONTROL",
   "IRP_MJ_FILE_SYSTEM_CONTROL",
   "IRP_MJ_DEVICE_CONTROL",
   "IRP_MJ_INTERNAL_DEVICE_CONTROL",
   "IRP_MJ_SHUTDOWN",
   "IRP_MJ_LOCK_CONTROL",
   "IRP_MJ_CLEANUP",
   "IRP_MJ_CREATE_MAILSLOT",
   "IRP_MJ_QUERY_SECURITY",
   "IRP_MJ_SET_SECURITY",
   "IRP_MJ_POWER",
   "IRP_MJ_SYSTEM_CONTROL",
   "IRP_MJ_DEVICE_CHANGE",
   "IRP_MJ_QUERY_QUOTA",
   "IRP_MJ_SET_QUOTA",
   "IRP_MJ_PNP"
};
//IRP_MJ_MAXIMUM_FUNCTION defined in wdm.h


static const PCHAR szPnpMnFuncDesc[] =
{  // note this depends on corresponding values to the indexes in wdm.h

   "IRP_MN_START_DEVICE",
   "IRP_MN_QUERY_REMOVE_DEVICE",
   "IRP_MN_REMOVE_DEVICE",
   "IRP_MN_CANCEL_REMOVE_DEVICE",
   "IRP_MN_STOP_DEVICE",
   "IRP_MN_QUERY_STOP_DEVICE",
   "IRP_MN_CANCEL_STOP_DEVICE",
   "IRP_MN_QUERY_DEVICE_RELATIONS",
   "IRP_MN_QUERY_INTERFACE",
   "IRP_MN_QUERY_CAPABILITIES",
   "IRP_MN_QUERY_RESOURCES",
   "IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
   "IRP_MN_QUERY_DEVICE_TEXT",
   "IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
   "IRP_MN_READ_CONFIG",
   "IRP_MN_WRITE_CONFIG",
   "IRP_MN_EJECT",
   "IRP_MN_SET_LOCK",
   "IRP_MN_QUERY_ID",
   "IRP_MN_QUERY_PNP_DEVICE_STATE",
   "IRP_MN_QUERY_BUS_INFORMATION",
   "IRP_MN_PAGING_NOTIFICATION"
};

      #define IRP_PNP_MN_FUNCMAX    IRP_MN_PAGING_NOTIFICATION



static const PCHAR szSystemPowerState[] =
{
   "PowerSystemUnspecified",
   "PowerSystemWorking",
   "PowerSystemSleeping1",
   "PowerSystemSleeping2",
   "PowerSystemSleeping3",
   "PowerSystemHibernate",
   "PowerSystemShutdown",
   "PowerSystemMaximum"
};

static const PCHAR szDevicePowerState[] =
{
   "PowerDeviceUnspecified",
   "PowerDeviceD0",
   "PowerDeviceD1",
   "PowerDeviceD2",
   "PowerDeviceD3",
   "PowerDeviceMaximum"
};




      #define CMUSB_ASSERT( cond ) ASSERT( cond )

      #define CMUSB_StringForDevState( devState )  szDevicePowerState[ devState ]

      #define CMUSB_StringForSysState( sysState )  szSystemPowerState[ sysState ]

      #define CMUSB_StringForPnpMnFunc( mnfunc ) szPnpMnFuncDesc[ mnfunc ]

      #define CMUSB_StringForIrpMjFunc(  mjfunc ) szIrpMajFuncDesc[ mjfunc ]


   #else // if not DBG

// dummy definitions that go away in the retail build

      #define CMUSB_ASSERT( cond )
      #define CMUSB_StringForDevState( devState )
      #define CMUSB_StringForSysState( sysState )
      #define CMUSB_StringForPnpMnFunc( mnfunc )
      #define CMUSB_StringForIrpMjFunc(  mjfunc )


   #endif //DBG

/*****************************************************************************
*                       Types, Structures
******************************************************************************/

// used to track driver-generated io irps for staged read/write processing
typedef struct _CMUSB_RW_CONTEXT
   {
   PURB Urb;
   PDEVICE_OBJECT DeviceObject;
   PIRP  Irp;
   } CMUSB_RW_CONTEXT, *PCMUSB_RW_CONTEXT;


typedef struct _CARD_PARAMETERS
   {
   UCHAR bCardType;
   UCHAR bBaudRate;
   UCHAR bStopBits;
   } CARD_PARAMETERS, *PCARD_PARAMETERS;

//
// A structure representing the instance information associated with
// this particular device.
//

typedef struct _DEVICE_EXTENSION
   {
   //
   // The dos device name of our smart card reader
   //
   UNICODE_STRING DosDeviceName;

   // The pnp device name of our smart card reader
   UNICODE_STRING PnPDeviceName;

   // Our smart card extension
   SMARTCARD_EXTENSION SmartcardExtension;

   // The current number of io-requests
   LONG IoCount;


   ULONG DeviceInstance;


   KSPIN_LOCK SpinLock;

   // Device object we call when submitting Urbs
   PDEVICE_OBJECT TopOfStackDeviceObject;

   // The bus driver object
   PDEVICE_OBJECT PhysicalDeviceObject;

   DEVICE_POWER_STATE CurrentDevicePowerState;

   // USB configuration handle and ptr for the configuration the
   // device is currently in
   USBD_CONFIGURATION_HANDLE UsbConfigurationHandle;
   PUSB_CONFIGURATION_DESCRIPTOR UsbConfigurationDescriptor;


   // ptr to the USB device descriptor
   // for this device
   PUSB_DEVICE_DESCRIPTOR UsbDeviceDescriptor;

   // we support one interface
   // this is a copy of the info structure
   // returned from select_configuration or
   // select_interface
   PUSBD_INTERFACE_INFORMATION UsbInterface;

   //Bus drivers set the appropriate values in this structure in response
   //to an IRP_MN_QUERY_CAPABILITIES IRP. Function and filter drivers might
   //alter the capabilities set by the bus driver.
   DEVICE_CAPABILITIES DeviceCapabilities;

   // used to save the currently-being-handled system-requested power irp request
   PIRP PowerIrp;

   // Used to signal that update thread can run
   KEVENT               CanRunUpdateThread;

   // Blocks IOCtls during hibernate mode
   KEVENT               ReaderEnabled;

   // set when PendingIoCount goes to 0; flags device can be removed
   KEVENT RemoveEvent;

   // set when PendingIoCount goes to 1 ( 1st increment was on add device )
   // this indicates no IO requests outstanding, either user, system, or self-staged
   KEVENT NoPendingIoEvent;

   // set to signal driver-generated power request is finished
   KEVENT SelfRequestedPowerIrpEvent;

   KEVENT ReadP1Completed;

   // incremented when device is added and any IO request is received;
   // decremented when any io request is completed or passed on, and when device is removed
   ULONG PendingIoCount;

   // Name buffer for our named Functional device object link
   // The name is generated based on the driver's class GUID
   WCHAR DeviceLinkNameBuffer[ MAXIMUM_FILENAME_LENGTH ];  // MAXIMUM_FILENAME_LENGTH defined in wdm.h

   //device is opened by application (ScardSrv, CT-API)
   LONG lOpenCount;

   // flag set when processing IRP_MN_REMOVE_DEVICE
   BOOLEAN DeviceRemoved;

   // flag set when processing IRP_MN_SURPRISE_REMOVAL
   BOOLEAN DeviceSurpriseRemoval;

   // flag set when driver has answered success to IRP_MN_QUERY_REMOVE_DEVICE
   BOOLEAN RemoveDeviceRequested;

   // flag set when driver has answered success to IRP_MN_QUERY_STOP_DEVICE
   BOOLEAN StopDeviceRequested;

   // flag set when device has been successfully started
   BOOLEAN DeviceStarted;

   // flag set when IRP_MN_WAIT_WAKE is received and we're in a power state
   // where we can signal a wait
   BOOLEAN EnabledForWakeup;

   // used to flag that we're currently handling a self-generated power request
   BOOLEAN  SelfPowerIrp;

   BOOLEAN  fPnPResourceManager;

   // default power state to power down to on self-suspend
   ULONG PowerDownLevel;


   } DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// Define the reader specific portion of the smart card extension
//
typedef struct _READER_EXTENSION
   {
   KTIMER  WaitTimer;
   KTIMER  P1Timer;

   // at least one info byte must be received within this timeout
   ULONG   ulTimeoutP1;


   ULONG                ulDeviceInstance;
   ULONG                ulOemNameIndex;
   ULONG                ulOemDeviceInstance;

   UCHAR   T0ReadBuffer [520];
   LONG    T0ReadBuffer_OffsetLastByte;
   LONG    T0ReadBuffer_OffsetLastByteRead;

   // Flag that indicates that the caller requests a power-down or a reset
   BOOLEAN  PowerRequest;

   // Saved card state for hibernation/sleeping modes.
   BOOLEAN CardPresent;

   // Current reader power state.
   //READER_POWER_STATE ReaderPowerState;

   CARD_PARAMETERS     CardParameters;


   BOOLEAN              TimeToTerminateThread;
   BOOLEAN              fThreadTerminated;

   KMUTEX               CardManIOMutex;

   // Handle of the UpdateCurrentState thread
   PVOID                ThreadObjectPointer;

   ULONG                ulOldCardState;
   ULONG                ulNewCardState;
   BOOLEAN              fRawModeNecessary;
   ULONG                ulFWVersion;
   BOOLEAN              fSPESupported;
   BOOLEAN              fInverseAtr;
   UCHAR                abDeviceDescription[42];
   BOOLEAN              fP1Stalled;

   } READER_EXTENSION, *PREADER_EXTENSION;



/*****************************************************************************
*                   Function Prototypes
******************************************************************************/
NTSTATUS CMUSB_ResetT0ReadBuffer (
                                 IN PSMARTCARD_EXTENSION smartcardExtension
                                 );

NTSTATUS CMUSB_AbortPipes (
                          IN PDEVICE_OBJECT DeviceObject
                          );

NTSTATUS CMUSB_AsyncReadWrite_Complete (
                                       IN PDEVICE_OBJECT DeviceObject,
                                       IN PIRP Irp,
                                       IN PVOID Context
                                       );

PURB CMUSB_BuildAsyncRequest (
                             IN PDEVICE_OBJECT DeviceObject,
                             IN PIRP Irp,
                             IN PUSBD_PIPE_INFORMATION pipeInformation
                             );

NTSTATUS CMUSB_CallUSBD (
                        IN PDEVICE_OBJECT DeviceObject,
                        IN PURB Urb
                        );

BOOLEAN CMUSB_CanAcceptIoRequests (
                                  IN PDEVICE_OBJECT DeviceObject
                                  );

NTSTATUS CMUSB_CancelCardTracking (
                                  IN PDEVICE_OBJECT DeviceObject,
                                  IN PIRP Irp
                                  );



NTSTATUS CMUSB_CardPower (
                         IN PSMARTCARD_EXTENSION pSmartcardExtension
                         );

NTSTATUS CMUSB_CardTracking (
                            PSMARTCARD_EXTENSION SmartcardExtension
                            );

NTSTATUS CMUSB_Cleanup (
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp
                       );


VOID CMUSB_CompleteCardTracking (
                                IN PSMARTCARD_EXTENSION SmartcardExtension
                                );

NTSTATUS CMUSB_ConfigureDevice (
                               IN  PDEVICE_OBJECT DeviceObject
                               );


NTSTATUS CMUSB_CreateClose (
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PIRP Irp
                           );

NTSTATUS CMUSB_CreateDeviceObject(
                                 IN PDRIVER_OBJECT DriverObject,
                                 IN PDEVICE_OBJECT PhysicalDeviceObject,
                                 IN PDEVICE_OBJECT *DeviceObject
                                 );

VOID CMUSB_DecrementIoCount (
                            IN PDEVICE_OBJECT DeviceObject
                            );

NTSTATUS CMUSB_GetFWVersion (
                            IN PSMARTCARD_EXTENSION smartcardExtension
                            );

VOID CMUSB_IncrementIoCount (
                            IN PDEVICE_OBJECT DeviceObject
                            );

VOID CMUSB_InitializeSmartcardExtension (
                                        IN PSMARTCARD_EXTENSION pSmartcardExtension
                                        ) ;
VOID CMUSB_InverseBuffer (
                         IN PUCHAR pbBuffer,
                         IN ULONG  ulBufferSize
                         ) ;

NTSTATUS CMUSB_IoCtlVendor (
                           PSMARTCARD_EXTENSION SmartcardExtension
                           );

NTSTATUS CMUSB_IrpCompletionRoutine (
                                    IN PDEVICE_OBJECT DeviceObject,
                                    IN PIRP Irp,
                                    IN PVOID Context
                                    );

NTSTATUS CMUSB_IsSPESupported (
                              IN PSMARTCARD_EXTENSION smartcardExtension
                              );

NTSTATUS CMUSB_PnPAddDevice (
                            IN PDRIVER_OBJECT DriverObject,
                            IN PDEVICE_OBJECT PhysicalDeviceObject
                            );

NTSTATUS CMUSB_PoSelfRequestCompletion (
                                       IN PDEVICE_OBJECT       DeviceObject,
                                       IN UCHAR                MinorFunction,
                                       IN POWER_STATE          PowerState,
                                       IN PVOID                Context,
                                       IN PIO_STATUS_BLOCK     IoStatus
                                       );

NTSTATUS CMUSB_PoRequestCompletion(
                                  IN PDEVICE_OBJECT       DeviceObject,
                                  IN UCHAR                MinorFunction,
                                  IN POWER_STATE          PowerState,
                                  IN PVOID                Context,
                                  IN PIO_STATUS_BLOCK     IoStatus
                                  );

NTSTATUS CMUSB_PowerIrp_Complete (
                                 IN PDEVICE_OBJECT NullDeviceObject,
                                 IN PIRP Irp,
                                 IN PVOID Context
                                 );

NTSTATUS CMUSB_PowerOffCard (
                            IN PSMARTCARD_EXTENSION smartcardExtension
                            );

NTSTATUS CMUSB_PowerOnCard (
                           IN  PSMARTCARD_EXTENSION smartcardExtension,
                           IN  PUCHAR pbATR,
                           OUT PULONG pulATRLength
                           );
NTSTATUS CMUSB_ProcessIOCTL (
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp
                            );

NTSTATUS CMUSB_ProcessPowerIrp (
                               IN PDEVICE_OBJECT DeviceObject,
                               IN PIRP           Irp
                               );

NTSTATUS CMUSB_ProcessPnPIrp (
                             IN PDEVICE_OBJECT DeviceObject,
                             IN PIRP           Irp
                             );

NTSTATUS CMUSB_ProcessSysControlIrp (
                                    IN PDEVICE_OBJECT DeviceObject,
                                    IN PIRP           Irp
                                    );

NTSTATUS CMUSB_ReadT0 (
                      IN PSMARTCARD_EXTENSION smartcardExtension
                      );
NTSTATUS CMUSB_ReadP1 (
                      IN PDEVICE_OBJECT DeviceObject
                      );
NTSTATUS CMUSB_ReadP1_T0 (
                         IN PDEVICE_OBJECT DeviceObject
                         );
NTSTATUS CMUSB_ReadP0 (
                      IN PDEVICE_OBJECT DeviceObject
                      );

NTSTATUS CMUSB_ReadStateAfterP1Stalled(
                                      IN PDEVICE_OBJECT DeviceObject
                                      );

NTSTATUS CMUSB_ResetPipe(
                        IN PDEVICE_OBJECT DeviceObject,
                        IN PUSBD_PIPE_INFORMATION PipeInfo
                        );

NTSTATUS CMUSB_QueryCapabilities (
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN PDEVICE_CAPABILITIES DeviceCapabilities
                                 );

NTSTATUS CMUSB_ReadDeviceDescription (
                                     IN PSMARTCARD_EXTENSION smartcardExtension
                                     );

NTSTATUS CMUSB_RemoveDevice (
                            IN  PDEVICE_OBJECT DeviceObject
                            );

NTSTATUS CMUSB_SelfSuspendOrActivate (
                                     IN PDEVICE_OBJECT DeviceObject,
                                     IN BOOLEAN fSuspend
                                     );

NTSTATUS CMUSB_SelectInterface (
                               IN PDEVICE_OBJECT DeviceObject,
                               IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
                               );

NTSTATUS CMUSB_SelfRequestPowerIrp (
                                   IN PDEVICE_OBJECT DeviceObject,
                                   IN POWER_STATE PowerState
                                   );

BOOLEAN CMUSB_SetDevicePowerState (
                                  IN PDEVICE_OBJECT DeviceObject,
                                  IN DEVICE_POWER_STATE DeviceState
                                  );

NTSTATUS CMUSB_SetCardParameters (
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN UCHAR bCardType,
                                 IN UCHAR bBaudRate,
                                 IN UCHAR bStopBits
                                 );

NTSTATUS CMUSB_SetHighSpeed_CR80S_SAMOS (
                                        IN PSMARTCARD_EXTENSION smartcardExtension
                                        );

NTSTATUS CMUSB_SetProtocol (
                           PSMARTCARD_EXTENSION pSmartcardExtension
                           );

NTSTATUS CMUSB_SetReader_9600Baud (
                                  IN PSMARTCARD_EXTENSION SmartcardExtension
                                  );

NTSTATUS CMUSB_SetReader_38400Baud (
                                   IN PSMARTCARD_EXTENSION SmartcardExtension
                                   );

NTSTATUS CMUSB_SetVendorAndIfdName(
                                  IN  PDEVICE_OBJECT PhysicalDeviceObject,
                                  IN  PSMARTCARD_EXTENSION SmartcardExtension
                                  );

NTSTATUS CMUSB_StartCardTracking (
                                 IN PDEVICE_OBJECT deviceObject
                                 );

NTSTATUS CMUSB_StartDevice (
                           IN  PDEVICE_OBJECT DeviceObject
                           );

VOID CMUSB_StopCardTracking (
                            IN PDEVICE_OBJECT deviceObject
                            );

NTSTATUS CMUSB_StopDevice (
                          IN  PDEVICE_OBJECT DeviceObject
                          );

NTSTATUS CMUSB_Transmit (
                        IN PSMARTCARD_EXTENSION smartcardExtension
                        );

NTSTATUS CMUSB_TransmitT0 (
                          IN PSMARTCARD_EXTENSION smartcardExtension
                          );

NTSTATUS CMUSB_TransmitT1 (
                          IN PSMARTCARD_EXTENSION smartcardExtension
                          );

VOID CMUSB_Unload (
                  IN PDRIVER_OBJECT DriverObject
                  );

VOID CMUSB_UpdateCurrentStateThread (
                                    IN PVOID Context
                                    );

NTSTATUS CMUSB_UpdateCurrentState(
                                 IN PDEVICE_OBJECT DeviceObject
                                 );

NTSTATUS CMUSB_Wait (
                    IN ULONG ulMilliseconds
                    );


NTSTATUS CMUSB_WriteP0 (
                       IN PDEVICE_OBJECT DeviceObject,
                       IN UCHAR bRequest,
                       IN UCHAR bValueLo,
                       IN UCHAR bValueHi,
                       IN UCHAR bIndexLo,
                       IN UCHAR bIndexHi
                       );


VOID CMUSB_CheckAtrModified (
                            IN OUT PUCHAR pbBuffer,
                            IN ULONG  ulBufferSize
                            );

// ----------------------------------------------------------------
// SYNCHRONOUS SMART CARDS
// ----------------------------------------------------------------

NTSTATUS
CMUSB_PowerOnSynchronousCard  (
                              IN  PSMARTCARD_EXTENSION smartcardExtension,
                              IN  PUCHAR pbATR,
                              OUT PULONG pulATRLength
                              );

NTSTATUS
CMUSB_Transmit2WBP  (
                    IN  PSMARTCARD_EXTENSION smartcardExtension
                    );

NTSTATUS
CMUSB_Transmit3WBP  (
                    IN  PSMARTCARD_EXTENSION smartcardExtension
                    );

NTSTATUS
CMUSB_SendCommand2WBP (
                      IN  PSMARTCARD_EXTENSION smartcardExtension,
                      IN  PUCHAR pbCommandData
                      );

NTSTATUS
CMUSB_SendCommand3WBP (
                      IN  PSMARTCARD_EXTENSION smartcardExtension,
                      IN  PUCHAR pbCommandData
                      );
__inline UCHAR
CMUSB_CalcSynchControl  (
                        IN UCHAR bStateReset1,         //0 -> low
                        IN UCHAR bStateClock1,         //0 -> low
                        IN UCHAR bStateDirection1,     //0 -> from card to pc
                        IN UCHAR bStateIO1,            //0 -> low
                        IN UCHAR bStateReset2,         //0 -> low
                        IN UCHAR bStateClock2,         //0 -> low
                        IN UCHAR bStateDirection2,     //0 -> from card to pc
                        IN UCHAR bStateIO2             //0 -> low
                        )
{
   return((UCHAR)( ((bStateReset1==0)?0:128) + ((bStateClock1==0)?0:64) +
                   ((bStateDirection1==0)?0:32) + ((bStateIO1==0)?0:16) +
                   ((bStateReset2==0)?0:8) + ((bStateClock2==0)?0:4) +
                   ((bStateDirection2==0)?0:2) + ((bStateIO2==0)?0:1) ));
};





#endif  // CMUSBM_INC


/*****************************************************************************
* History:
* $Log: sccmusbm.h $
* Revision 1.5  2000/09/25 13:38:21  WFrischauf
* No comment given
*
* Revision 1.4  2000/08/16 14:35:02  WFrischauf
* No comment given
*
* Revision 1.3  2000/07/24 11:34:57  WFrischauf
* No comment given
*
* Revision 1.1  2000/07/20 11:50:13  WFrischauf
* No comment given
*
*
******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\sccmusbm\scusbcb.c ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmeu0/sw/sccmusbm.ms/rcs/scusbcb.c $
* $Revision: 1.9 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/
#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usbdi.h"
#include "usbdlib.h"


#include "sccmusbm.h"


ULONG dataRatesSupported[]    = { 9600, 19200, 38400, 76800, 115200};
ULONG CLKFrequenciesSupported[] = {3571};


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_StartCardTracking(
                                IN PDEVICE_OBJECT DeviceObject
                                )
{
    NTSTATUS NTStatus;
    HANDLE hThread;
    PDEVICE_EXTENSION    DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;
    

    DeviceExtension = DeviceObject->DeviceExtension;
    SmartcardExtension = &DeviceExtension->SmartcardExtension;


   // settings for thread synchronization
    SmartcardExtension->ReaderExtension->TimeToTerminateThread = FALSE;
    SmartcardExtension->ReaderExtension->fThreadTerminated     = FALSE;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!StartCardTracking: Enter\n",DRIVER_NAME));

    KeWaitForSingleObject(&SmartcardExtension->ReaderExtension->CardManIOMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

   // create thread for updating current state
    NTStatus = PsCreateSystemThread(&hThread,
                                    THREAD_ALL_ACCESS,
                                    NULL,
                                    NULL,
                                    NULL,
                                    CMUSB_UpdateCurrentStateThread,
                                    DeviceObject);
   if (!NT_ERROR(NTStatus))
      {
      //
      // We've got the thread.  Now get a pointer to it.
      //

      NTStatus = ObReferenceObjectByHandle(hThread,
                                           THREAD_ALL_ACCESS,
                                           NULL,
                                           KernelMode,
                                           &SmartcardExtension->ReaderExtension->ThreadObjectPointer,
                                           NULL);

      if (NT_ERROR(NTStatus))
         {
         SmartcardExtension->ReaderExtension->TimeToTerminateThread = TRUE;
         }
      else
         {
         //
         // Now that we have a reference to the thread
         // we can simply close the handle.
         //
         ZwClose(hThread);
         }
      }


    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!StartCardTracking: -----------------------------------------------------------\n",DRIVER_NAME));
    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!StartCardTracking: STARTING THREAD\n",DRIVER_NAME));
    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!StartCardTracking: -----------------------------------------------------------\n",DRIVER_NAME));
    KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,
                   FALSE);


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!StartCardTracking: Exit %lx\n",DRIVER_NAME,NTStatus));

    return NTStatus;
}




/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID CMUSB_StopCardTracking(
                           IN PDEVICE_OBJECT DeviceObject
                           )
{
    PDEVICE_EXTENSION    DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!StopCardTracking: Enter\n",DRIVER_NAME));

    DeviceExtension = DeviceObject->DeviceExtension;
    SmartcardExtension = &DeviceExtension->SmartcardExtension;

    if (SmartcardExtension->ReaderExtension->fThreadTerminated == FALSE) {

        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!StopCardTracking: waiting for mutex\n",DRIVER_NAME));

      // kill thread
        KeWaitForSingleObject(&SmartcardExtension->ReaderExtension->CardManIOMutex,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        SmartcardExtension->ReaderExtension->TimeToTerminateThread = TRUE;

        KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);

        KeWaitForSingleObject(SmartcardExtension->ReaderExtension->ThreadObjectPointer,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ObDereferenceObject(SmartcardExtension->ReaderExtension->ThreadObjectPointer);

    }

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!StopCardTracking: Exit\n",DRIVER_NAME));

}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID CMUSB_UpdateCurrentStateThread(
                                   IN PVOID Context
                                   )

{
    PDEVICE_OBJECT DeviceObject  = Context;
    PDEVICE_EXTENSION    DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;
    NTSTATUS NTStatus,DebugStatus;
    ULONG ulInterval;

    DeviceExtension = DeviceObject->DeviceExtension;
    SmartcardExtension = &DeviceExtension->SmartcardExtension;

    KeWaitForSingleObject(&DeviceExtension->CanRunUpdateThread,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!UpdateCurrentStateThread started\n",DRIVER_NAME));

    do {
      // every 500 ms  the s NTStatus request is sent
        ulInterval = 500;
        KeWaitForSingleObject(&SmartcardExtension->ReaderExtension->CardManIOMutex,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        if ( SmartcardExtension->ReaderExtension->TimeToTerminateThread ) {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!UpdateCurrentStateThread: -----------------------------------------\n",DRIVER_NAME));
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!UpdateCurrentStateThread: STOPPING THREAD\n",DRIVER_NAME));
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!UpdateCurrentStateThread: -----------------------------------------\n",DRIVER_NAME));

            KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);
            SmartcardExtension->ReaderExtension->fThreadTerminated = TRUE;
            PsTerminateSystemThread( STATUS_SUCCESS );
        }

        NTStatus = CMUSB_UpdateCurrentState (DeviceObject);
        if (NTStatus == STATUS_DEVICE_DATA_ERROR) {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!setting update interval to 1ms\n",DRIVER_NAME));

            ulInterval = 1;
        } else if (NTStatus != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!NO STATUS RECEIVED\n",DRIVER_NAME));
        }

        KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);

        CMUSB_Wait (ulInterval);
    }
    while (TRUE);
}



NTSTATUS CMUSB_UpdateCurrentState(
                                 IN PDEVICE_OBJECT DeviceObject
                                 )
{
    NTSTATUS             NTStatus;
    PDEVICE_EXTENSION    DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;
    BOOLEAN              fCardStateChanged = FALSE;
    ULONG                ulBytesRead;
    KIRQL                irql;

    DeviceExtension = DeviceObject->DeviceExtension;
    SmartcardExtension = &DeviceExtension->SmartcardExtension;


    SmartcardExtension->SmartcardRequest.BufferLength = 0;
    NTStatus = CMUSB_WriteP0(DeviceObject,
                             0x20,         //bRequest,
                             0x00,         //bValueLo,
                             0x00,         //bValueHi,
                             0x00,         //bIndexLo,
                             0x00          //bIndexHi,
                            );

    if (NTStatus == STATUS_SUCCESS) {
        SmartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
        SmartcardExtension->SmartcardReply.BufferLength = 1;

        NTStatus = CMUSB_ReadP1(DeviceObject);

        ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;
        if (NTStatus == STATUS_SUCCESS && ulBytesRead == 1) { /* we got the NTStatus information */

            if ((SmartcardExtension->SmartcardReply.Buffer[0] & 0x40) == 0x40) {
                if ((SmartcardExtension->SmartcardReply.Buffer[0] & 0x80) == 0x80) {
                    SmartcardExtension->ReaderExtension->ulNewCardState = POWERED;
                } else {
                    SmartcardExtension->ReaderExtension->ulNewCardState = INSERTED;
                }
            } else {
                SmartcardExtension->ReaderExtension->ulNewCardState = REMOVED;
            }

            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);

            if (SmartcardExtension->ReaderExtension->ulNewCardState == INSERTED &&
                SmartcardExtension->ReaderExtension->ulOldCardState == POWERED ) {
            // card has been removed and reinserted
                SmartcardExtension->ReaderExtension->ulNewCardState = REMOVED;
            }

            if (SmartcardExtension->ReaderExtension->ulNewCardState  == INSERTED &&
                (SmartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN ||
                 SmartcardExtension->ReaderExtension->ulOldCardState == REMOVED )) {
            // card has been inserted
                SmartcardDebug(DEBUG_DRIVER,( "%s!UpdateCurrentStateThread Smartcard inserted\n",DRIVER_NAME));
                fCardStateChanged = TRUE;
                SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
                SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            }


         // state after reset of the PC
            if (SmartcardExtension->ReaderExtension->ulNewCardState == POWERED &&
                SmartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN    ) {
            // card has been inserted
                SmartcardDebug(DEBUG_DRIVER,( "%s!UpdateCurrentStateThread Smartcard inserted (and powered)\n",DRIVER_NAME));
                fCardStateChanged = TRUE;
                SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
                SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            }


            if (SmartcardExtension->ReaderExtension->ulNewCardState == REMOVED      &&
                (SmartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN  ||
                 SmartcardExtension->ReaderExtension->ulOldCardState == INSERTED ||
                 SmartcardExtension->ReaderExtension->ulOldCardState == POWERED    )   ) {
            // card has been removed
                fCardStateChanged = TRUE;
                SmartcardDebug(DEBUG_DRIVER,( "%s!UpdateCurrentStateThread Smartcard removed\n",DRIVER_NAME));

                SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
                SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
                SmartcardExtension->CardCapabilities.ATR.Length        = 0;


                RtlFillMemory((PVOID)&SmartcardExtension->ReaderExtension->CardParameters,
                              sizeof(CARD_PARAMETERS),
                              0x00);
            }

            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

         // complete IOCTL_SMARTCARD_IS_ABSENT or IOCTL_SMARTCARD_IS_PRESENT
            if (fCardStateChanged == TRUE &&
                SmartcardExtension->OsData->NotificationIrp != NULL) {
                SmartcardDebug(DEBUG_DRIVER,("%s!UpdateCurrentStateThread: completing IRP\n",DRIVER_NAME));
                CMUSB_CompleteCardTracking(SmartcardExtension);
            }

         // save old state
            SmartcardExtension->ReaderExtension->ulOldCardState = SmartcardExtension->ReaderExtension->ulNewCardState;

        }
    }

    return NTStatus;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID CMUSB_CompleteCardTracking(
                               IN PSMARTCARD_EXTENSION SmartcardExtension
                               )
{
    KIRQL ioIrql, keIrql;
    PIRP notificationIrp;

    IoAcquireCancelSpinLock(&ioIrql);
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock, &keIrql);

    notificationIrp = SmartcardExtension->OsData->NotificationIrp;
    SmartcardExtension->OsData->NotificationIrp = NULL;

    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock, keIrql);

    if (notificationIrp) {
        IoSetCancelRoutine(notificationIrp,NULL);
    }

    IoReleaseCancelSpinLock(ioIrql);

    if (notificationIrp) {
        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!CompleteCardTracking: Completing NotificationIrp %lxh\n",DRIVER_NAME,notificationIrp));

      //    finish the request
        if (notificationIrp->Cancel) {
            notificationIrp->IoStatus.Status = STATUS_CANCELLED;
        } else {
            notificationIrp->IoStatus.Status = STATUS_SUCCESS;
        }

        notificationIrp->IoStatus.Information = 0;

        IoCompleteRequest(notificationIrp, IO_NO_INCREMENT);
    }
}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_Wait (ULONG ulMilliseconds)
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    LARGE_INTEGER   WaitTime;

   // -10000 indicates 1ms relativ
    WaitTime = RtlConvertLongToLargeInteger(ulMilliseconds * -10000);
    KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);

    return NTStatus;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_CreateClose(
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp
                          )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension;
    PSMARTCARD_EXTENSION  SmartcardExtension;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CreateClose: Enter\n",DRIVER_NAME));

    DeviceExtension = DeviceObject->DeviceExtension;
    SmartcardExtension = &DeviceExtension->SmartcardExtension;

   //
   //   dispatch major function
   //
    switch (IrpStack->MajorFunction) {
    case IRP_MJ_CREATE:
        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!CreateClose: IRP_MJ_CREATE\n",DRIVER_NAME));
        if (DeviceExtension->RemoveDeviceRequested) {
            NTStatus = STATUS_DEVICE_BUSY;
        } else {
            if (InterlockedIncrement(&DeviceExtension->lOpenCount) > 1) {
                InterlockedDecrement(&DeviceExtension->lOpenCount);
                NTStatus = STATUS_ACCESS_DENIED;
            }
        }
        break;

    case IRP_MJ_CLOSE:
        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!CreateClose: IRP_MJ_CLOSE\n",DRIVER_NAME));
        if (InterlockedDecrement(&DeviceExtension->lOpenCount) < 0) {
            InterlockedIncrement(&DeviceExtension->lOpenCount);
        }

         // check if the device has been removed
         // if so free the resources
        if (DeviceExtension->DeviceRemoved == TRUE) {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!CreateClose: freeing resources\n",DRIVER_NAME));

            if (DeviceExtension->fPnPResourceManager == FALSE) {
               //
               // Free all allocated buffer
               //
                ExFreePool(DeviceExtension->DosDeviceName.Buffer);
            }

            ExFreePool(SmartcardExtension->ReaderExtension);
            SmartcardExtension->ReaderExtension = NULL;
            //
            // Let the lib free the send/receive buffers
            //
            SmartcardExit(SmartcardExtension);
        }

        break;


    default:
         //
         // unrecognized command
         //
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = NTStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CreateClose: Exit %lx\n",DRIVER_NAME,NTStatus));
    return NTStatus;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_Transmit(
                       IN PSMARTCARD_EXTENSION SmartcardExtension
                       )
{
    NTSTATUS NTStatus;

   //this seems to make problems in Windows 98
   //KeSetPriorityThread(KeGetCurrentThread(),HIGH_PRIORITY);


    switch (SmartcardExtension->CardCapabilities.Protocol.Selected) {
    case SCARD_PROTOCOL_RAW:
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case SCARD_PROTOCOL_T0:

        NTStatus = CMUSB_TransmitT0(SmartcardExtension);

        break;

    case SCARD_PROTOCOL_T1:
        NTStatus = CMUSB_TransmitT1(SmartcardExtension);
        break;

    default:
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        break;

    }
   //KeSetPriorityThread(KeGetCurrentThread(),LOW_REALTIME_PRIORITY);

    return NTStatus;

}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_ResetT0ReadBuffer(
                                PSMARTCARD_EXTENSION SmartcardExtension
                                )
{

    SmartcardExtension->ReaderExtension->T0ReadBuffer_OffsetLastByte     = -1;
    SmartcardExtension->ReaderExtension->T0ReadBuffer_OffsetLastByteRead = -1;

    return STATUS_SUCCESS;
}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_ReadT0(
                     PSMARTCARD_EXTENSION SmartcardExtension
                     )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    NTSTATUS DebugStatus;
    LONG  lBytesToRead;
    LONG  lBytesRead;
    LONG  lLastByte;
    LONG  lLastByteRead;
    PDEVICE_EXTENSION DeviceExtension;
    PUSBD_PIPE_INFORMATION pipeHandle = NULL;
    PUSBD_INTERFACE_INFORMATION interface;


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!ReadT0: Enter\n",DRIVER_NAME));


    DeviceExtension =  SmartcardExtension->OsData->DeviceObject->DeviceExtension;
    interface       = DeviceExtension->UsbInterface;
    pipeHandle      =  &interface->Pipes[0];

    lBytesToRead = (LONG)SmartcardExtension->SmartcardReply.BufferLength;
    lLastByte     = SmartcardExtension->ReaderExtension->T0ReadBuffer_OffsetLastByte;
    lLastByteRead = SmartcardExtension->ReaderExtension->T0ReadBuffer_OffsetLastByteRead;

   // check if further bytes must be read from pipe 1
    while (lLastByteRead + lBytesToRead > lLastByte) {
        SmartcardExtension->SmartcardReply.BufferLength = 1;
        SmartcardExtension->ReaderExtension->ulTimeoutP1 = 1000 +
                                                           (ULONG)((SmartcardExtension->CardCapabilities.T0.WT/1000) * lBytesToRead);
        NTStatus = CMUSB_ReadP1(SmartcardExtension->OsData->DeviceObject);
        if (NTStatus == STATUS_DEVICE_DATA_ERROR) {
            DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
            goto ExitReadT0;
        } else if (NTStatus != STATUS_SUCCESS) {
            goto ExitReadT0;
        }


        lBytesRead = (LONG)SmartcardExtension->SmartcardReply.BufferLength;

        RtlCopyBytes((PVOID)(SmartcardExtension->ReaderExtension->T0ReadBuffer + (lLastByte +1)),
                     (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                     lBytesRead);

        lLastByte  += lBytesRead;


    } // end of while

   // copy bytes
    SmartcardExtension->SmartcardReply.BufferLength  = lBytesToRead;
    RtlCopyBytes ((PVOID)SmartcardExtension->SmartcardReply.Buffer,
                  (PVOID)(SmartcardExtension->ReaderExtension->T0ReadBuffer + (lLastByteRead +1)),
                  lBytesToRead);

    lLastByteRead  += lBytesToRead;

/*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!lBytesToRead=%ld lLastByte=%ld lLastByteRead=%ld\n",
                   DRIVER_NAME,
                   lBytesToRead,
                   lLastByte,
                   lLastByteRead)
                 );
*/


    SmartcardExtension->ReaderExtension->T0ReadBuffer_OffsetLastByte     = lLastByte;
    SmartcardExtension->ReaderExtension->T0ReadBuffer_OffsetLastByteRead = lLastByteRead;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!ReadT0: Exit %lx\n",DRIVER_NAME,NTStatus));

    ExitReadT0:
    return NTStatus;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
#define T0_HEADER_LEN               0x05
#define T0_STATE_LEN                0x02
#define TIMEOUT_CANCEL_READ_P1     30000

NTSTATUS CMUSB_TransmitT0(
                         PSMARTCARD_EXTENSION SmartcardExtension
                         )
{
    NTSTATUS NTStatus;
    NTSTATUS DebugStatus;
    UCHAR    bWriteBuffer[CMUSB_BUFFER_SIZE];
    UCHAR    bReadBuffer [CMUSB_BUFFER_SIZE];
    ULONG    ulWriteBufferOffset;
    ULONG    ulReadBufferOffset;
    ULONG    ulBytesToWrite;
    ULONG    ulBytesToRead;
    ULONG    ulBytesToWriteThisStep;
    ULONG    ulBytesToReadThisStep;
    ULONG    ulBytesStillToWrite;
    ULONG    ulBytesRead;
    ULONG    ulBytesStillToRead;
    BOOLEAN  fDataDirectionFromCard;
    BYTE     bProcedureByte;
    BYTE     bINS;
    BOOLEAN  fT0TransferToCard;
    BOOLEAN  fT0TransferFromCard;
    BOOLEAN  fSW1SW2Sent;
    ULONG    ulUsedCWT;
    UCHAR    bUsedCWTHi;
    LARGE_INTEGER liTimeout;
    PDEVICE_EXTENSION DeviceExtension;
    UCHAR    bTmp;
    ULONG    i;
    PUSBD_PIPE_INFORMATION pipeHandle = NULL;
    PUSBD_INTERFACE_INFORMATION interface;


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!TransmitT0 : Enter\n",DRIVER_NAME));

    fT0TransferToCard = FALSE;
    fT0TransferFromCard = FALSE;
    fSW1SW2Sent = FALSE;

   // resync CardManUSB by reading the NTStatus byte
    SmartcardExtension->SmartcardRequest.BufferLength = 0;
    NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                             0x20,         //bRequest,
                             0x00,         //bValueLo,
                             0x00,         //bValueHi,
                             0x00,         //bIndexLo,
                             0x00          //bIndexHi,
                            );

    if (NTStatus != STATUS_SUCCESS) {
      // if we can't read the NTStatus there must be a serious error
        goto ExitTransmitT0;
    }

    SmartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
    SmartcardExtension->SmartcardReply.BufferLength = 1;
    NTStatus = CMUSB_ReadP1(SmartcardExtension->OsData->DeviceObject);
    if (NTStatus == STATUS_DEVICE_DATA_ERROR) {
        DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
        goto ExitTransmitT0;
    } else if (NTStatus != STATUS_SUCCESS) {
      // if we can't read the NTStatus there must be a serious error
        goto ExitTransmitT0;
    }



    DeviceExtension =  SmartcardExtension->OsData->DeviceObject->DeviceExtension;
    interface       = DeviceExtension->UsbInterface;
    pipeHandle      =  &interface->Pipes[0];

    SmartcardExtension->ReaderExtension->ulTimeoutP1 = (ULONG)(SmartcardExtension->CardCapabilities.T0.WT/1000);


   //
   // Let the lib build a T=0 packet
   //

    SmartcardExtension->SmartcardRequest.BufferLength = 0;  // no bytes additionally needed
    NTStatus = SmartcardT0Request(SmartcardExtension);
    if (NTStatus != STATUS_SUCCESS) {
      //
      // This lib detected an error in the data to send.
      //
        goto ExitTransmitT0;
    }


    ulBytesStillToWrite = ulBytesToWrite = T0_HEADER_LEN + SmartcardExtension->T0.Lc;
    ulBytesStillToRead  = ulBytesToRead  = SmartcardExtension->T0.Le;
    if (SmartcardExtension->T0.Lc)
        fT0TransferToCard = TRUE;
    if (SmartcardExtension->T0.Le)
        fT0TransferFromCard = TRUE;



   // ----------------------------
   // smart card ==> CardMan USB
   // ----------------------------
    if (fT0TransferFromCard) {
        SmartcardDebug(DEBUG_PROTOCOL,
                       ("%s!TransmitT0: MODE 3\n",DRIVER_NAME));

      // granularity 256 ms
        ulUsedCWT = (ULONG)(SmartcardExtension->CardCapabilities.T0.WT/1000);
        SmartcardDebug(DEBUG_PROTOCOL,
                       ("%s!TransmitT0: ulUsedCWT= %ld\n",DRIVER_NAME,ulUsedCWT));

        bUsedCWTHi = (UCHAR)(((ulUsedCWT & 0x0000FF00)>>8) + 1 + 5) ;

      // copy data to the write buffer
        SmartcardDebug(DEBUG_PROTOCOL,
                       ("%s!TransmitT0: CLA = %x INS = %x P1 = %x P2 = %x L = %x\n", DRIVER_NAME,
                        SmartcardExtension->SmartcardRequest.Buffer[0],
                        SmartcardExtension->SmartcardRequest.Buffer[1],
                        SmartcardExtension->SmartcardRequest.Buffer[2],
                        SmartcardExtension->SmartcardRequest.Buffer[3],
                        SmartcardExtension->SmartcardRequest.Buffer[4]));


        RtlCopyBytes((PVOID)bWriteBuffer,
                     (PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                     ulBytesToWrite);

        bINS = bWriteBuffer[1];

        ulWriteBufferOffset = 0;
        ulReadBufferOffset = 0;


      // STEP 1 : write CLA INS P1 P2 Lc

        ulBytesToWriteThisStep = 5;
        RtlCopyBytes((PVOID)(SmartcardExtension->SmartcardRequest.Buffer),
                     (PVOID)(bWriteBuffer+ulWriteBufferOffset),
                     ulBytesToWriteThisStep);

        if (SmartcardExtension->ReaderExtension->fInverseAtr == TRUE) {
            CMUSB_InverseBuffer(SmartcardExtension->SmartcardRequest.Buffer,
                                SmartcardExtension->SmartcardRequest.BufferLength);
        }

        SmartcardExtension->SmartcardReply.BufferLength = 512;
        NTStatus = CMUSB_ReadP1_T0(SmartcardExtension->OsData->DeviceObject);
        if (NTStatus != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s!TransmitT0: CMUSB_ReadP1_T0 returned = %x\n",DRIVER_NAME,NTStatus));
            goto ExitTransmitT0;
        }


        SmartcardExtension->SmartcardRequest.BufferLength = ulBytesToWriteThisStep;
        NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                                 0x03,                       // mode 3
                                 bUsedCWTHi,                 //bValueLo,
                                 0x00,                       //bValueHi,
                                 (UCHAR)(ulBytesToRead%256), //bIndexLo,
                                 (UCHAR)(SmartcardExtension->SmartcardRequest.Buffer[1]) //bIndexHi,
                                );
        if (NTStatus != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s!TransmitT0: CMUSB_WriteP0 returned %x\n",DRIVER_NAME,NTStatus));
            goto ExitTransmitT0;
        }




        liTimeout = RtlConvertLongToLargeInteger(TIMEOUT_CANCEL_READ_P1 * -10000);

        SmartcardDebug(DEBUG_PROTOCOL,
                       ("%s!TransmitT0: waiting for P1 event\n",DRIVER_NAME,NTStatus));

        NTStatus = KeWaitForSingleObject(&DeviceExtension->ReadP1Completed,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         &liTimeout);

      // -----------------------------
      // check if P1 has been stalled
      // -----------------------------
        if (SmartcardExtension->ReaderExtension->fP1Stalled == TRUE) {
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s!STransmitT0: TATUS_DEVICE_DATA_ERROR\n",DRIVER_NAME));
            NTStatus = STATUS_DEVICE_DATA_ERROR;

         // P1 has been stalled ==> we must reset the pipe and send a NTStatus to enable it again
            DebugStatus = CMUSB_ResetPipe(SmartcardExtension->OsData->DeviceObject,
                                          pipeHandle);

            DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);

            SmartcardExtension->SmartcardReply.BufferLength = 0;
            goto ExitTransmitT0;
        }
      // -------------------------------
      // check if a timeout has occured
      // -------------------------------
        else if (NTStatus == STATUS_TIMEOUT) {
         // probably the smart card does not work
         // cancel T0 read operation by sending any P0 command
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s!TransmitT0: cancelling read operation\n",DRIVER_NAME));
            SmartcardExtension->SmartcardRequest.BufferLength = 0;
            NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                                     0x20,         //bRequest,
                                     0x00,         //bValueLo,
                                     0x00,         //bValueHi,
                                     0x00,         //bIndexLo,
                                     0x00          //bIndexHi,
                                    );

            NTStatus = STATUS_IO_TIMEOUT;
            goto ExitTransmitT0;
        }
      // -------------------------------------------
      // check if at least 9 bytes have been sent
      // -------------------------------------------
        else if (SmartcardExtension->SmartcardReply.BufferLength < 9) {
            NTStatus = STATUS_UNSUCCESSFUL;
            goto ExitTransmitT0;
        } else {


#if DBG
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s!<==[P1] ",DRIVER_NAME));
            for (i=0;i< SmartcardExtension->SmartcardReply.BufferLength;i++) {
                bTmp =  SmartcardExtension->SmartcardReply.Buffer[i];
                if (SmartcardExtension->ReaderExtension->fInverseAtr &&
                    SmartcardExtension->ReaderExtension->ulTimeoutP1 != DEFAULT_TIMEOUT_P1) {
               //CMUSB_InverseBuffer(&bTmp,1);
                    SmartcardDebug(DEBUG_PROTOCOL,("%x ",bTmp));
                } else {
                    SmartcardDebug(DEBUG_PROTOCOL,("%x ",bTmp));
                }
            }
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("(%ld)\n",SmartcardExtension->SmartcardReply.BufferLength));
#endif


         // ignore the first 8 dummy bytes
            SmartcardExtension->SmartcardReply.BufferLength -= 8;
            RtlCopyBytes((PVOID)(bReadBuffer),
                         (PVOID)(SmartcardExtension->SmartcardReply.Buffer+8),
                         SmartcardExtension->SmartcardReply.BufferLength);

            RtlCopyBytes((PVOID)(SmartcardExtension->SmartcardReply.Buffer),
                         (PVOID)(bReadBuffer),
                         SmartcardExtension->SmartcardReply.BufferLength);

            if (SmartcardExtension->ReaderExtension->fInverseAtr) {
                CMUSB_InverseBuffer(SmartcardExtension->SmartcardReply.Buffer,
                                    SmartcardExtension->SmartcardReply.BufferLength);
            }

        }
    }

   // -----------------------------
   // CardMan USB ==> smart card or
   // no transfer
   // -----------------------------
    else {


        SmartcardDebug(DEBUG_PROTOCOL,
                       ("%s!TransmitT0: MODE 2\n",DRIVER_NAME));

      // copy data to the write buffer
        SmartcardDebug(DEBUG_PROTOCOL,
                       ("%s!TransmitT0: CLA = %x INS = %x P1 = %x P2 = %X L = %x\n",DRIVER_NAME,
                        SmartcardExtension->SmartcardRequest.Buffer[0],
                        SmartcardExtension->SmartcardRequest.Buffer[1],
                        SmartcardExtension->SmartcardRequest.Buffer[2],
                        SmartcardExtension->SmartcardRequest.Buffer[3],
                        SmartcardExtension->SmartcardRequest.Buffer[4]));


        RtlCopyBytes((PVOID)bWriteBuffer,
                     (PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                     ulBytesToWrite);




      // SendingToCard:

        ulWriteBufferOffset = 0;
        ulReadBufferOffset = 0;
        bINS = bWriteBuffer[1];



      // STEP 1 : write CLA INS P1 P2 Lc

        ulBytesToWriteThisStep = 5;
        RtlCopyBytes((PVOID)(SmartcardExtension->SmartcardRequest.Buffer),
                     (PVOID)(bWriteBuffer+ulWriteBufferOffset),
                     ulBytesToWriteThisStep);
        SmartcardExtension->SmartcardRequest.BufferLength = ulBytesToWriteThisStep;

        if (SmartcardExtension->ReaderExtension->fInverseAtr == TRUE) {
            CMUSB_InverseBuffer(SmartcardExtension->SmartcardRequest.Buffer,
                                SmartcardExtension->SmartcardRequest.BufferLength);
        }


        NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                                 0x02,         //T=0
                                 0x00,         //bValueLo,
                                 0x00,         //bValueHi,
                                 0x00,         //bIndexLo,
                                 0x00          //bIndexHi,
                                );
        if (NTStatus != STATUS_SUCCESS) {
            goto ExitTransmitT0;
        }


        ulWriteBufferOffset += ulBytesToWriteThisStep;
        ulBytesStillToWrite -= ulBytesToWriteThisStep;

        NTStatus = CMUSB_ResetT0ReadBuffer(SmartcardExtension);

      // STEP 2 : read procedure byte
        do {
            do {
                SmartcardExtension->SmartcardReply.BufferLength = 1;
                NTStatus = CMUSB_ReadT0(SmartcardExtension);
                if (NTStatus != STATUS_SUCCESS) {
                    goto ExitTransmitT0;
                }
                ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;
                bProcedureByte = SmartcardExtension->SmartcardReply.Buffer[0];

                if (SmartcardExtension->ReaderExtension->fInverseAtr) {
                    CMUSB_InverseBuffer(&bProcedureByte,1);
                }

                SmartcardDebug(DEBUG_PROTOCOL,
                               ("%s!TransmitT0: procedure byte = %x\n",
                                DRIVER_NAME,
                                bProcedureByte));
                if (bProcedureByte == 0x60) {
               // wait work waitung time;
               // we just try to read again
                }
            } while (bProcedureByte == 0x60);


         // check for ACK
            if ((bProcedureByte & 0xFE) ==  (bINS & 0xFE) ) {
                ulBytesToWriteThisStep = ulBytesStillToWrite;
                if (ulBytesToWriteThisStep > 0) { // at least one byte must be sent to the card
                    RtlCopyBytes((PVOID)(SmartcardExtension->SmartcardRequest.Buffer),
                                 (PVOID)(bWriteBuffer+ulWriteBufferOffset),
                                 ulBytesToWriteThisStep);

                    SmartcardExtension->SmartcardRequest.BufferLength = ulBytesToWriteThisStep;
                    if (SmartcardExtension->ReaderExtension->fInverseAtr == TRUE) {
                        CMUSB_InverseBuffer(SmartcardExtension->SmartcardRequest.Buffer,
                                            SmartcardExtension->SmartcardRequest.BufferLength);
                    }
                    NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                                             0x02,         //bRequest,
                                             0x00,         //bValueLo,
                                             0x00,         //bValueHi,
                                             0x00,         //bIndexLo,
                                             0x00          //bIndexHi,
                                            );
                    if (NTStatus != STATUS_SUCCESS) {
                        goto ExitTransmitT0;
                    }
                    ulWriteBufferOffset += ulBytesToWriteThisStep;
                    ulBytesStillToWrite -= ulBytesToWriteThisStep;
                }
            }
         // check for NAK
            else if ( (~bProcedureByte & 0xFE) == (bINS & 0xFE)) {
                ulBytesToWriteThisStep = 1;
                RtlCopyBytes((PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                             (PVOID)(bWriteBuffer+ulWriteBufferOffset),
                             ulBytesToWriteThisStep);

                SmartcardExtension->SmartcardRequest.BufferLength = ulBytesToWriteThisStep;
                if (SmartcardExtension->ReaderExtension->fInverseAtr == TRUE) {
                    CMUSB_InverseBuffer(SmartcardExtension->SmartcardRequest.Buffer,
                                        SmartcardExtension->SmartcardRequest.BufferLength);
                }
                NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                                         0x02,         //bRequest,
                                         0x00,         //bValueLo,
                                         0x00,         //bValueHi,
                                         0x00,         //bIndexLo,
                                         0x00          //bIndexHi,
                                        );
                if (NTStatus != STATUS_SUCCESS) {
                    goto ExitTransmitT0;
                }
                ulWriteBufferOffset += ulBytesToWriteThisStep;
                ulBytesStillToWrite -= ulBytesToWriteThisStep;

            }
         // check for SW1
            else if ( (bProcedureByte > 0x60 && bProcedureByte <= 0x6F) ||
                      (bProcedureByte >= 0x90 && bProcedureByte <= 0x9F)   ) {
                bReadBuffer[ulReadBufferOffset] = SmartcardExtension->SmartcardReply.Buffer[0];
                ulReadBufferOffset++;

                SmartcardExtension->SmartcardReply.BufferLength = 1;
                NTStatus = CMUSB_ReadT0(SmartcardExtension);
                if (NTStatus != STATUS_SUCCESS) {
                    goto ExitTransmitT0;
                }
                ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;
                RtlCopyBytes((PVOID)(bReadBuffer + ulReadBufferOffset),
                             (PVOID)(SmartcardExtension->SmartcardReply.Buffer),
                             SmartcardExtension->SmartcardReply.BufferLength);
                ulReadBufferOffset += ulBytesRead;

                fSW1SW2Sent = TRUE;
            } else {
                NTStatus =  STATUS_UNSUCCESSFUL;
                goto ExitTransmitT0;
            }

        }while (!fSW1SW2Sent);

        if (SmartcardExtension->ReaderExtension->fInverseAtr) {
            CMUSB_InverseBuffer(bReadBuffer,
                                ulReadBufferOffset);
        }

      // copy received bytes
        RtlCopyBytes((PVOID)SmartcardExtension->SmartcardReply.Buffer,
                     (PVOID)bReadBuffer,
                     ulReadBufferOffset);
        SmartcardExtension->SmartcardReply.BufferLength = ulReadBufferOffset;

    }


   // let the lib copy the received bytes to the user buffer
    NTStatus = SmartcardT0Reply(SmartcardExtension);



    ExitTransmitT0:

   // ------------------------------------------
   // ITSEC E2 requirements: clear write buffers
   // ------------------------------------------
    RtlFillMemory((PVOID)bWriteBuffer,sizeof(bWriteBuffer),0x00);
    RtlFillMemory((PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                  SmartcardExtension->SmartcardRequest.BufferSize,0x00);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!TransmitT0 : Exit %lx\n",DRIVER_NAME,NTStatus));

    return NTStatus;
}
#undef T0_HEADER_LEN
#undef T0_STATE_LEN
#undef TIMEOUT_CANCEL_READ_P1






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_TransmitT1(
                         PSMARTCARD_EXTENSION SmartcardExtension
                         )
{
    NTSTATUS NTStatus;
    NTSTATUS DebugStatus;
    ULONG  ulBytesToRead;
    ULONG  ulCurrentWaitTime;
    ULONG  ulWTXWaitTime;
    LARGE_INTEGER   waitTime;
    BOOLEAN         fStateTimer;
    ULONG   ulTemp;
    PDEVICE_EXTENSION DeviceExtension;
    PUSBD_INTERFACE_INFORMATION interface;
    PUSBD_PIPE_INFORMATION pipeHandle = NULL;
    BOOLEAN   fCancelTimer = FALSE;
    BYTE bTemp;
    BYTE  bMultiplier;


    SmartcardDebug(DEBUG_PROTOCOL,
                   ("%s!TransmitT1: CWT = %ld(ms)\n",DRIVER_NAME,
                    SmartcardExtension->CardCapabilities.T1.CWT/1000));
    SmartcardDebug(DEBUG_PROTOCOL,
                   ("%s!TransmitT1: BWT = %ld(ms)\n",DRIVER_NAME,
                    SmartcardExtension->CardCapabilities.T1.BWT/1000));


    DeviceExtension = SmartcardExtension->OsData->DeviceObject->DeviceExtension;
    interface       = DeviceExtension->UsbInterface;
    pipeHandle      =  &interface->Pipes[0];


    ulCurrentWaitTime = (ULONG)(1000 + SmartcardExtension->CardCapabilities.T1.BWT/1000);
    ulWTXWaitTime     = 0;

    do {


        SmartcardExtension->SmartcardRequest.BufferLength = 0;


        NTStatus = SmartcardT1Request(SmartcardExtension);
        if (NTStatus != STATUS_SUCCESS) {
         // this should never happen, so we return immediately
            goto ExitTransmitT1;
        }



        NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                                 0x01,         //T=1
                                 0x00,         //bValueLo,
                                 0x00,         //bValueHi,
                                 0x00,         //bIndexLo,
                                 0x00          //bIndexHi,
                                );

        if (NTStatus != STATUS_SUCCESS)
            break;  // there must be severe error

        if (ulWTXWaitTime ==  0 ) { // use BWT
            waitTime = RtlConvertLongToLargeInteger(ulCurrentWaitTime * -10000);
        } else { // use WTX time
            waitTime = RtlConvertLongToLargeInteger(ulWTXWaitTime * -10000);
        }
        KeSetTimer(&SmartcardExtension->ReaderExtension->WaitTimer,
                   waitTime,
                   NULL);
      // timer is now in the queue
        fCancelTimer = TRUE;
        ulTemp = 0;
        do {
            NTStatus = CMUSB_ReadP1(SmartcardExtension->OsData->DeviceObject);
            if (NTStatus == STATUS_DEVICE_DATA_ERROR) {
                DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
                goto ExitTransmitT1;
            }

            fStateTimer = KeReadStateTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
            if (fStateTimer == TRUE) {
            // timer has been removed from the queue
                fCancelTimer = FALSE;
                SmartcardDebug(DEBUG_PROTOCOL,
                               ("%s!TransmitT1: T1 card does not respond in time\n",DRIVER_NAME));
                NTStatus = STATUS_IO_TIMEOUT;
                break;
            }

            if (SmartcardExtension->SmartcardReply.Buffer[0] >= 3) {
                if (SmartcardExtension->SmartcardReply.Buffer[1] > ulTemp) {
               // restart CWT for 32 bytes
                    ulCurrentWaitTime = (ULONG)(100 + 32*(SmartcardExtension->CardCapabilities.T1.CWT/1000));
                    waitTime = RtlConvertLongToLargeInteger(ulCurrentWaitTime * -10000);
                    KeSetTimer(&SmartcardExtension->ReaderExtension->WaitTimer,
                               waitTime,
                               NULL);
               // timer is in the queue
                    fCancelTimer = TRUE;
                    ulTemp = SmartcardExtension->SmartcardReply.Buffer[1];
                } else {
               // CardMan USB has not received further bytes
               // do nothing
                }

            }


        } while (SmartcardExtension->SmartcardReply.Buffer[0] < 3   ||
                 (SmartcardExtension->SmartcardReply.Buffer[0] !=
                  SmartcardExtension->SmartcardReply.Buffer[1] + 4 )  );


      // cancel timer now
        if (fCancelTimer == TRUE) {
            fCancelTimer = FALSE;
            KeCancelTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
         // timer is removed from the queue
        }




        if (NTStatus != STATUS_SUCCESS) {
            SmartcardExtension->SmartcardReply.BufferLength = 0L;
        } else {
            ulBytesToRead = SmartcardExtension->SmartcardReply.Buffer[0];

            SmartcardExtension->SmartcardReply.BufferLength = SmartcardExtension->SmartcardReply.Buffer[0];
            NTStatus = CMUSB_ReadP0(SmartcardExtension->OsData->DeviceObject);

        }


        bTemp = SmartcardExtension->SmartcardReply.Buffer[1];
        bMultiplier = SmartcardExtension->SmartcardReply.Buffer[3];
        if (SmartcardExtension->ReaderExtension->fInverseAtr == TRUE) {
            CMUSB_InverseBuffer(&bTemp,1);
            CMUSB_InverseBuffer(&bMultiplier,1);
        }


        if (bTemp == T1_WTX_REQUEST) {
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s!TransmitT1: T1_WTX_REQUEST received\n",DRIVER_NAME));

            ulWTXWaitTime = (ULONG)(1000 +
                                    bMultiplier * (SmartcardExtension->CardCapabilities.T1.BWT/1000));
        } else {
            ulWTXWaitTime = 0;
        }




      // bug fix for smclib
        if (SmartcardExtension->T1.State         == T1_IFS_RESPONSE &&
            SmartcardExtension->T1.OriginalState == T1_I_BLOCK) {
            SmartcardExtension->T1.State = T1_I_BLOCK;
        }

        NTStatus = SmartcardT1Reply(SmartcardExtension);
    }
    while (NTStatus == STATUS_MORE_PROCESSING_REQUIRED);



    ExitTransmitT1:
   // ------------------------------------------
   // ITSEC E2 requirements: clear write buffers
   // ------------------------------------------
    RtlFillMemory((PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                  SmartcardExtension->SmartcardRequest.BufferSize,0x00);

   // timer will be cancelled here if there was an error
    if (fCancelTimer == TRUE) {
        KeCancelTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
      // timer is removed from the queue
    }
    return NTStatus;
}


/*****************************************************************************
Routine Description:
This function sets the desired protocol . If necessary a PTS is performed


Arguments:  pointer to SMARTCARD_EXTENSION



Return Value: NT NTStatus

*****************************************************************************/
NTSTATUS CMUSB_SetProtocol(
                          PSMARTCARD_EXTENSION SmartcardExtension
                          )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    NTSTATUS DebugStatus;
    ULONG ulNewProtocol;
    UCHAR abPTSRequest[4];
    UCHAR abReadBuffer[6];
    UCHAR abPTSReply [4];
    ULONG ulBytesRead;
    LARGE_INTEGER   liWaitTime;
    BOOLEAN         fStateTimer;
    ULONG           ulWaitTime;
    PDEVICE_EXTENSION DeviceExtension;
    PUSBD_PIPE_INFORMATION pipeHandle = NULL;
    PUSBD_INTERFACE_INFORMATION interface;
    UCHAR bTemp;
    BOOLEAN fCancelTimer = FALSE;
    KIRQL    irql;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetProtocol : Enter\n",DRIVER_NAME));

    DeviceExtension =  SmartcardExtension->OsData->DeviceObject->DeviceExtension;
    interface       = DeviceExtension->UsbInterface;
    pipeHandle      =  &interface->Pipes[0];


   //
   // Check if the card is already in specific state
   // and if the caller wants to have the already selected protocol.
   // We return success if this is the case.
   //

    if ((SmartcardExtension->CardCapabilities.Protocol.Selected & SmartcardExtension->MinorIoControlCode)) {
        NTStatus = STATUS_SUCCESS;
        goto ExitSetProtocol;
    }

    ulNewProtocol = SmartcardExtension->MinorIoControlCode;



    while (TRUE) {

      // set initial character of PTS
        abPTSRequest[0] = 0xFF;

      // set the format character
        if (SmartcardExtension->CardCapabilities.Protocol.Supported &
            ulNewProtocol &
            SCARD_PROTOCOL_T1) {
         // select T=1 and indicate that PTS1 follows
            abPTSRequest[1] = 0x11;
            SmartcardExtension->CardCapabilities.Protocol.Selected =
            SCARD_PROTOCOL_T1;
        } else if (SmartcardExtension->CardCapabilities.Protocol.Supported &
                   ulNewProtocol &
                   SCARD_PROTOCOL_T0) {
         // select T=1 and indicate that PTS1 follows
            abPTSRequest[1] = 0x10;
            SmartcardExtension->CardCapabilities.Protocol.Selected =
            SCARD_PROTOCOL_T0;
        } else {
            NTStatus = STATUS_INVALID_DEVICE_REQUEST;
            goto ExitSetProtocol;
        }


      // CardMan USB support higher baudrates only for T=1
      // ==> Dl=1
        if (abPTSRequest[1] == 0x10) {
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s! overwriting PTS1 for T=0\n",DRIVER_NAME));
            SmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
        }

      // set pts1 which codes Fl and Dl
        bTemp = (BYTE) (SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                        SmartcardExtension->CardCapabilities.PtsData.Dl);

        switch (bTemp) {
        case 0x11:
        case 0x12:
        case 0x13:
        case 0x14:
        case 0x18:
        case 0x91:
        case 0x92:
        case 0x93:
        case 0x94:
        case 0x98:
            // do nothing
            // we support these Fl/Dl parameters
            break ;

        default:
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s! overwriting PTS1(0x%x)\n",DRIVER_NAME,bTemp));
            // we must correct Fl/Dl
            SmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
            SmartcardExtension->CardCapabilities.PtsData.Fl = 0x01;
            bTemp = (BYTE) (SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                            SmartcardExtension->CardCapabilities.PtsData.Dl);
            break;


        }

        abPTSRequest[2] = bTemp;

      // set pck (check character)
        abPTSRequest[3] = (BYTE)(abPTSRequest[0] ^ abPTSRequest[1] ^ abPTSRequest[2]);

        SmartcardDebug(DEBUG_PROTOCOL,
                       ("%s! writing PTS request\n",DRIVER_NAME));

        RtlCopyBytes((PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                     (PVOID)abPTSRequest,
                     4);
        SmartcardExtension->SmartcardRequest.BufferLength = 4;
        NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                                 0x01,         //we can use T=1 setting for direct communication
                                 0x00,         //bValueLo,
                                 0x00,         //bValueHi,
                                 0x00,         //bIndexLo,
                                 0x00);        //bIndexHi,
        if (NTStatus != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s! writing PTS request failed\n",DRIVER_NAME));
            goto ExitSetProtocol;
        }


      // read back pts data
        SmartcardDebug(DEBUG_PROTOCOL,
                       ("%s! reading PTS reply\n",DRIVER_NAME));
      // maximim initial waiting time is 9600 * etu
      // => 1 sec is sufficient
        ulWaitTime = 1000;
        liWaitTime = RtlConvertLongToLargeInteger(ulWaitTime * -10000);
        KeSetTimer(&SmartcardExtension->ReaderExtension->WaitTimer,
                   liWaitTime,
                   NULL);
      // timer is now in the queue
        fCancelTimer = TRUE;

        do {
            SmartcardExtension->ReaderExtension->ulTimeoutP1 = ulWaitTime;
            DebugStatus = CMUSB_ReadP1(SmartcardExtension->OsData->DeviceObject);
         // -----------------------------
         // check if P1 has been stalled
         // -----------------------------
            if (SmartcardExtension->ReaderExtension->fP1Stalled == TRUE) {
                DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);

                SmartcardExtension->SmartcardReply.BufferLength = 0;
                goto ExitSetProtocol;
            }

            fStateTimer = KeReadStateTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
            if (fStateTimer == TRUE) {
            // timer has timed out and has been removed from the queue
                fCancelTimer = FALSE;
                SmartcardDebug(DEBUG_PROTOCOL,
                               ("%s! Timeout while PTS reply\n",DRIVER_NAME));
                NTStatus = STATUS_IO_TIMEOUT;
                break;
            }



        } while (SmartcardExtension->SmartcardReply.Buffer[0] < 4 );


        if (fCancelTimer == TRUE) {
            fCancelTimer = FALSE;
         // timer is still in the queue, remove it
            KeCancelTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
        }

        if (NTStatus == STATUS_IO_TIMEOUT) {
            if (SmartcardExtension->SmartcardReply.Buffer[0] == 3) {
                SmartcardExtension->SmartcardReply.BufferLength = 3;
            } else {
                if (SmartcardExtension->CardCapabilities.PtsData.Type !=
                    PTS_TYPE_DEFAULT) {
                    SmartcardDebug(DEBUG_PROTOCOL,
                                   ("%s! PTS failed : Trying default parameters\n",DRIVER_NAME));

               // the card did either not reply or it replied incorrectly
               // so try default values
                    SmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_DEFAULT;

                    SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
                    NTStatus = CMUSB_CardPower(SmartcardExtension);
                    continue;
                }
                goto ExitSetProtocol;
            }
        } else {
            SmartcardExtension->SmartcardReply.BufferLength = 4;
        }

        NTStatus = CMUSB_ReadP0(SmartcardExtension->OsData->DeviceObject);
        ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;
        if (NTStatus != STATUS_SUCCESS ||
            !(ulBytesRead == 4 || ulBytesRead == 3)) {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s! reading PTS reply failed\n",DRIVER_NAME));
            goto ExitSetProtocol;
        }

        RtlCopyBytes((PVOID)abPTSReply,
                     (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                     ulBytesRead);


        if (ulBytesRead == 4 &&
            abPTSReply[0] == abPTSRequest[0] &&
            abPTSReply[1] == abPTSRequest[1] &&
            abPTSReply[2] == abPTSRequest[2] &&
            abPTSReply[3] == abPTSRequest[3] ) {
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s! PTS request and reply match\n",DRIVER_NAME));

            NTStatus = STATUS_SUCCESS;

            switch (abPTSRequest[2]) {
            // Fl/Dl
            case 0x11:
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
                CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_9600;
                break ;

            case 0x12:
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
                CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_19200;
                break ;


            case 0x13:
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
                CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_38400;
                break ;

            case 0x14:
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
                CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_76800;
                break ;

            case 0x18:
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
                CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_115200;
                break ;


            case 0x91:
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
                CMUSB_FREQUENCY_5_12MHZ + CMUSB_BAUDRATE_9600;
                break ;

            case 0x92:
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
                CMUSB_FREQUENCY_5_12MHZ + CMUSB_BAUDRATE_19200;
                break ;

            case 0x93:
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
                CMUSB_FREQUENCY_5_12MHZ + CMUSB_BAUDRATE_38400;
                break ;

            case 0x94:
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
                CMUSB_FREQUENCY_5_12MHZ + CMUSB_BAUDRATE_76800;
                break ;

            case 0x98:
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
                CMUSB_FREQUENCY_5_12MHZ + CMUSB_BAUDRATE_115200;
                break ;
            }

            break;
        }

        if (ulBytesRead == 3 &&
            abPTSReply[0] == abPTSRequest[0] &&
            (abPTSReply[1] & 0x7F) == (abPTSRequest[1] & 0x0F) &&
            abPTSReply[2] == (BYTE)(abPTSReply[0] ^ abPTSReply[1] )) {
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s! short PTS reply received\n",DRIVER_NAME));

            NTStatus = STATUS_SUCCESS;

            if ((abPTSRequest[2] & 0x90) == 0x90) {
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
                CMUSB_FREQUENCY_5_12MHZ + CMUSB_BAUDRATE_9600;
            } else {
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
                CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_9600;
            }

            break ;
        }


        if (SmartcardExtension->CardCapabilities.PtsData.Type !=
            PTS_TYPE_DEFAULT) {
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s! PTS failed : Trying default parameters\n",DRIVER_NAME));

         // the card did either not reply or it replied incorrectly
         // so try default values
            SmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_DEFAULT;

            SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
            NTStatus = CMUSB_CardPower(SmartcardExtension);
            continue;
        }

      // the card failed the pts request
        NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
        goto ExitSetProtocol;
    }


    ExitSetProtocol:
    switch (NTStatus) {
    case STATUS_IO_TIMEOUT:
        SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
        *SmartcardExtension->IoRequest.Information = 0;
        break;


    case STATUS_SUCCESS:

         // now indicate that we're in specific mode
        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);

         // return the selected protocol to the caller
        *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer =
        SmartcardExtension->CardCapabilities.Protocol.Selected;

        *SmartcardExtension->IoRequest.Information =
        sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);
        SmartcardDebug(DEBUG_PROTOCOL,
                       ("%s! Selected protocol: T=%ld\n",DRIVER_NAME,
                        SmartcardExtension->CardCapabilities.Protocol.Selected-1));

         // -----------------------
         // set parameters
         // -----------------------
        if (SmartcardExtension->CardCapabilities.N != 0xff) {
            SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 2 + SmartcardExtension->CardCapabilities.N;

        } else {
            // N = 255
            if (SmartcardExtension->CardCapabilities.Protocol.Selected & SCARD_PROTOCOL_T0) {
               // 12 etu for T=0;
                SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 2;
            } else {
               // 11 etu for T=1
                SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 1;
            }
        }


        NTStatus = CMUSB_SetCardParameters (SmartcardExtension->OsData->DeviceObject,
                                            SmartcardExtension->ReaderExtension->CardParameters.bCardType,
                                            SmartcardExtension->ReaderExtension->CardParameters.bBaudRate,
                                            SmartcardExtension->ReaderExtension->CardParameters.bStopBits);



        break;

    default :
        SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
        *SmartcardExtension->IoRequest.Information = 0;
        break;
    }



    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetProtocol : Exit %lx\n",DRIVER_NAME,NTStatus));
    return NTStatus;

}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_CardPower(IN PSMARTCARD_EXTENSION SmartcardExtension)
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    NTSTATUS DebugStatus = STATUS_SUCCESS;
    UCHAR  pbAtrBuffer[MAXIMUM_ATR_LENGTH];
    ULONG  ulAtrLength;
    KIRQL  irql;
#if DBG
    ULONG i;
#endif;


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CardPower: Enter\n",DRIVER_NAME));

#if DBG
    switch (SmartcardExtension->MinorIoControlCode) {
    case SCARD_WARM_RESET:
        SmartcardDebug(DEBUG_ATR,
                       ("%s!CardPower: SCARD_WARM_RESTART\n",DRIVER_NAME));
        break;
    case SCARD_COLD_RESET:
        SmartcardDebug(DEBUG_ATR,
                       ("%s!CardPower: SCARD_COLD_RESTART\n",DRIVER_NAME));
        break;
    case SCARD_POWER_DOWN:
        SmartcardDebug(DEBUG_ATR,
                       ("%s!CardPower: SCARD_POWER_DOWN\n",DRIVER_NAME));
        break;
    }
#endif

   //DbgBreakPoint();

    switch (SmartcardExtension->MinorIoControlCode) {
    case SCARD_WARM_RESET:
    case SCARD_COLD_RESET:

         // try asynchronous cards first
         // because some asynchronous cards
         // do not return 0xFF in the first byte
        NTStatus = CMUSB_PowerOnCard(SmartcardExtension,
                                     pbAtrBuffer,
                                     &ulAtrLength);

        if (NTStatus != STATUS_SUCCESS && NTStatus!= STATUS_NO_MEDIA) {
            NTStatus = CMUSB_PowerOnSynchronousCard(SmartcardExtension,
                                                    pbAtrBuffer,
                                                    &ulAtrLength);
        }

        if (NTStatus != STATUS_SUCCESS) {
            goto ExitCardPower;
        }

        if (SmartcardExtension->ReaderExtension->fRawModeNecessary == FALSE) {
            // copy ATR to smart card structure
            // the lib needs the ATR for evaluation of the card parameters

            RtlCopyBytes((PVOID)SmartcardExtension->CardCapabilities.ATR.Buffer,
                         (PVOID)pbAtrBuffer,
                         ulAtrLength);

            SmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)ulAtrLength;

            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);

            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_NEGOTIABLE;

            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);


            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

            NTStatus = SmartcardUpdateCardCapabilities(SmartcardExtension);
            if (NTStatus != STATUS_SUCCESS) {
                goto ExitCardPower;
            }

            // -----------------------
            // set parameters
            // -----------------------
            if (SmartcardExtension->CardCapabilities.N != 0xff) {
               // 0 <= N <= 254
                SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 2 + SmartcardExtension->CardCapabilities.N;
            } else {
               // N = 255
                if (SmartcardExtension->CardCapabilities.Protocol.Selected & SCARD_PROTOCOL_T0) {
                  // 12 etu for T=0;
                    SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 2;
                } else {
                  // 11 etu for T=1
                    SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 1;
                }
            }


            NTStatus = CMUSB_SetCardParameters (SmartcardExtension->OsData->DeviceObject,
                                                SmartcardExtension->ReaderExtension->CardParameters.bCardType,
                                                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate,
                                                SmartcardExtension->ReaderExtension->CardParameters.bStopBits);


#if DBG
            SmartcardDebug(DEBUG_ATR,("%s!CardPower: ATR : ",DRIVER_NAME));
            for (i = 0;i < ulAtrLength;i++)
                SmartcardDebug(DEBUG_ATR,("%2.2x ",SmartcardExtension->CardCapabilities.ATR.Buffer[i]));
            SmartcardDebug(DEBUG_ATR,("\n"));

#endif

        } else {
            SmartcardExtension->CardCapabilities.ATR.Buffer[0] = 0x3B;
            SmartcardExtension->CardCapabilities.ATR.Buffer[1] = 0x04;

            if (ulAtrLength > 62) {
                NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
                goto ExitCardPower;
            }
            RtlCopyBytes((PVOID)&SmartcardExtension->CardCapabilities.ATR.Buffer[2],
                         (PVOID)pbAtrBuffer,
                         ulAtrLength);

            ulAtrLength += 2;
            SmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)ulAtrLength;

            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);

            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;

            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;

            NTStatus = SmartcardUpdateCardCapabilities(SmartcardExtension);
            if (NTStatus != STATUS_SUCCESS) {
                goto ExitCardPower;
            }

            SmartcardDebug(DEBUG_ATR,("CardPower: ATR of synchronous smart card : %2.2x %2.2x %2.2x %2.2x\n",
                                      pbAtrBuffer[0],pbAtrBuffer[1],pbAtrBuffer[2],pbAtrBuffer[3]));

            // copied from serial CardMan
            //SmartcardExtension->ReaderExtension->SyncParameters.fCardResetRequested = TRUE;

        }

         // copy ATR to user space

        if (SmartcardExtension->IoRequest.ReplyBufferLength >= SmartcardExtension->CardCapabilities.ATR.Length) {
        
            RtlCopyBytes((PVOID)SmartcardExtension->IoRequest.ReplyBuffer,
                         (PVOID)SmartcardExtension->CardCapabilities.ATR.Buffer,
                         SmartcardExtension->CardCapabilities.ATR.Length);

            *SmartcardExtension->IoRequest.Information = ulAtrLength;

        } else {
            // Called from SET_PROTOCOL, so we don't want to copy the ATR.
        }
        break;

    case SCARD_POWER_DOWN:
        NTStatus = CMUSB_PowerOffCard(SmartcardExtension);
        if (NTStatus != STATUS_SUCCESS) {
            goto ExitCardPower;
        }


        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                  &irql);

        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
        SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);

        break;
    }



    ExitCardPower:

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CardPower: Exit %lx\n",DRIVER_NAME,NTStatus));
    return NTStatus;

}




/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_PowerOffCard (
                            IN PSMARTCARD_EXTENSION SmartcardExtension
                            )
{
    NTSTATUS NTStatus;
    NTSTATUS DebugStatus;
    PDEVICE_OBJECT DeviceObject;
    ULONG ulBytesRead;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!PowerOffCard: Enter\n",DRIVER_NAME));

    DeviceObject = SmartcardExtension->OsData->DeviceObject;

    SmartcardExtension->SmartcardRequest.BufferLength = 0;
    NTStatus = CMUSB_WriteP0(DeviceObject,
                             0x11,         //bRequest,
                             0x00,         //bValueLo,
                             0x00,         //bValueHi,
                             0x00,         //bIndexLo,
                             0x00          //bIndexHi,
                            );


   // now read the NTStatus
    SmartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
    NTStatus = CMUSB_ReadP1(DeviceObject);
    if (NTStatus == STATUS_DEVICE_DATA_ERROR) {
        DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
        goto ExitPowerOff;
    }



    ExitPowerOff:

   // set card state for update thread
   // otherwise a card removal/insertion would be recognized
    if (SmartcardExtension->ReaderExtension->ulOldCardState == POWERED)
        SmartcardExtension->ReaderExtension->ulOldCardState = INSERTED;


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!PowerOffCard: Exit %lx\n",DRIVER_NAME,NTStatus));
    return NTStatus;
}

/*****************************************************************************
Routine Description:


Arguments:


Return Value:


*****************************************************************************/
NTSTATUS CMUSB_ReadStateAfterP1Stalled(
                                      IN PDEVICE_OBJECT DeviceObject
                                      )
{
    NTSTATUS NTStatus;
    PSMARTCARD_EXTENSION SmartcardExtension;
    PDEVICE_EXTENSION DeviceExtension;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!ReadStateAfterP1Stalled: Enter\n",DRIVER_NAME));

    DeviceExtension = DeviceObject->DeviceExtension;
    SmartcardExtension = &DeviceExtension->SmartcardExtension;

    SmartcardExtension->SmartcardRequest.BufferLength = 0;
    NTStatus = CMUSB_WriteP0(DeviceObject,
                             0x20,         //bRequest,
                             0x00,         //bValueLo,
                             0x00,         //bValueHi,
                             0x00,         //bIndexLo,
                             0x00          //bIndexHi,
                            );

    if (NTStatus != STATUS_SUCCESS) {
      // if we can't read the NTStatus there must be a serious error
        goto ExitReadState;
    }
    SmartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
    SmartcardExtension->SmartcardReply.BufferLength = 1;
    NTStatus = CMUSB_ReadP1(DeviceObject);
    if (NTStatus != STATUS_SUCCESS) {
      // if we can't read the NTStatus there must be a serious error
        goto ExitReadState;
    }

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!ReadStateAfterP1Stalled: Exit %lx\n",DRIVER_NAME,NTStatus));

    ExitReadState:
    return NTStatus;

}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_PowerOnCard  (
                            IN  PSMARTCARD_EXTENSION SmartcardExtension,
                            IN  PUCHAR pbATR,
                            OUT PULONG pulATRLength
                            )
{
    UCHAR  abMaxAtrBuffer[SCARD_ATR_LENGTH];
    ULONG  ulCurrentLengthOfAtr;
    ULONG  ulPtrToCurrentAtrByte;
    ULONG  ulExpectedLengthOfAtr;
    BOOLEAN fTryNextCard;
    BOOLEAN fValidAtrReceived = FALSE;
    ULONG  ulBytesRead;
    NTSTATUS NTStatus;
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS DebugStatus;
    BOOLEAN   fInverseAtr = FALSE;
    ULONG  ulHistoricalBytes;
    ULONG  i;
    BOOLEAN   fTDxSent;
    BOOLEAN   fOnlyT0;
    UCHAR  bResetMode;
    UCHAR  abFrequency[2] = {CMUSB_FREQUENCY_3_72MHZ,
        CMUSB_FREQUENCY_5_12MHZ};
    ULONG ulCardType;
    UCHAR bCardType;
    UCHAR bStopBits;
    UCHAR bBaudRate;


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!PowerOnCard: Enter\n",DRIVER_NAME));

    DeviceObject = SmartcardExtension->OsData->DeviceObject;
    if (SmartcardExtension->MinorIoControlCode == SCARD_COLD_RESET)
        bResetMode = SMARTCARD_COLD_RESET;
    else
        bResetMode = SMARTCARD_WARM_RESET;


   // clear card parameters
    SmartcardExtension->ReaderExtension->CardParameters.bBaudRate = 0;
    SmartcardExtension->ReaderExtension->CardParameters.bCardType = 0;
    SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 0;



   // set default card parameters
   // asnyc, 9600 baud, even parity
    bStopBits = 2;
    bBaudRate = CMUSB_BAUDRATE_9600;
    bCardType = CMUSB_SMARTCARD_ASYNCHRONOUS;



    for (ulCardType = 0;ulCardType < 2;ulCardType++) {
#if DBG
        switch (ulCardType) {
        case 0:
            SmartcardDebug(DEBUG_ATR,
                           ("%s!PowerOnCard: trying 3.72 Mhz smart card\n",DRIVER_NAME));
            break;

        case 1:
            SmartcardDebug(DEBUG_ATR,
                           ("%s!PowerOnCard: trying 5.12 Mhz smart card\n",DRIVER_NAME));
            break;

        }
#endif
        bBaudRate |= abFrequency[ulCardType];

        NTStatus = CMUSB_SetCardParameters (SmartcardExtension->OsData->DeviceObject,
                                            bCardType,
                                            bBaudRate,
                                            bStopBits);
        if (NTStatus != STATUS_SUCCESS) {
         // if we can't set the card parameters there must be a serious error
            goto ExitPowerOnCard;
        }

        ulCurrentLengthOfAtr  = 0L;
        ulPtrToCurrentAtrByte = 0L;
        fOnlyT0 = TRUE;
        fTryNextCard = FALSE;
        fValidAtrReceived = FALSE;
        RtlFillMemory((PVOID)abMaxAtrBuffer,
                      sizeof(abMaxAtrBuffer),
                      0x00);


      // resync CardManUSB by reading the NTStatus byte
        SmartcardExtension->SmartcardRequest.BufferLength = 0;
        NTStatus = CMUSB_WriteP0(DeviceObject,
                                 0x20,         //bRequest,
                                 0x00,         //bValueLo,
                                 0x00,         //bValueHi,
                                 0x00,         //bIndexLo,
                                 0x00          //bIndexHi,
                                );

        if (NTStatus != STATUS_SUCCESS) {
         // if we can't read the NTStatus there must be a serious error
            goto ExitPowerOnCard;
        }

        SmartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
        SmartcardExtension->SmartcardReply.BufferLength = 1;
        NTStatus = CMUSB_ReadP1(DeviceObject);
        if (NTStatus == STATUS_DEVICE_DATA_ERROR) {
            DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
            goto ExitPowerOnCard;
        } else if (NTStatus != STATUS_SUCCESS) {
         // if we can't read the NTStatus there must be a serious error
            goto ExitPowerOnCard;
        }


      // check if card is really inserted
        if (SmartcardExtension->SmartcardReply.Buffer[0] == 0x00) {
            NTStatus = STATUS_NO_MEDIA;
            goto ExitPowerOnCard;
        }



      // issue power on command
        NTStatus = CMUSB_WriteP0(DeviceObject,
                                 0x10,         //bRequest,
                                 bResetMode,   //bValueLo,
                                 0x00,         //bValueHi,
                                 0x00,         //bIndexLo,
                                 0x00          //bIndexHi,
                                );
        if (NTStatus != STATUS_SUCCESS) {
         // if we can't issue the power on command there must be a serious error
            goto ExitPowerOnCard;
        }


        SmartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
        NTStatus = CMUSB_ReadP1(DeviceObject);
        if (NTStatus == STATUS_DEVICE_DATA_ERROR) {
            DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
            goto ExitPowerOnCard;
        } else if (NTStatus != STATUS_SUCCESS) {
            continue;
        }


        ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;

        RtlCopyBytes((PVOID)(abMaxAtrBuffer+ulCurrentLengthOfAtr),
                     (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                     ulBytesRead);

      // check if inverse convention used
        if (abMaxAtrBuffer[0] == 0x03) {
            fInverseAtr = TRUE;
        }

        if (fInverseAtr) {
            CMUSB_InverseBuffer(abMaxAtrBuffer+ulCurrentLengthOfAtr,
                                ulBytesRead);
        }

        if (abMaxAtrBuffer[0] != 0x3B &&
            abMaxAtrBuffer[0] != 0x3F    ) {
            continue; // try next card
        }


        ulCurrentLengthOfAtr += ulBytesRead;


      // ---------------------
      // TS character
      // ---------------------
        SmartcardDebug(DEBUG_ATR,("PowerOnCard: TS = %2.2x\n",abMaxAtrBuffer[0]));
        if (abMaxAtrBuffer[ulPtrToCurrentAtrByte] != 0x3B &&
            abMaxAtrBuffer[ulPtrToCurrentAtrByte] != 0x3F    ) {
            continue;
        }


      // ---------------------
      // T0 character
      // ---------------------
        ulExpectedLengthOfAtr = 2;
        if (ulCurrentLengthOfAtr < ulExpectedLengthOfAtr) {
            NTStatus = CMUSB_ReadP1(DeviceObject);
            if (NTStatus == STATUS_DEVICE_DATA_ERROR) {
                DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
                goto ExitPowerOnCard;
            } else if (NTStatus != STATUS_SUCCESS) {
                continue;
            }
            ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;

            RtlCopyBytes((PVOID)(abMaxAtrBuffer+ulCurrentLengthOfAtr),
                         (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                         ulBytesRead);
            if (fInverseAtr) {
                CMUSB_InverseBuffer(abMaxAtrBuffer+ulCurrentLengthOfAtr,
                                    ulBytesRead);
            }
            ulCurrentLengthOfAtr += ulBytesRead;
        }

        SmartcardDebug(DEBUG_ATR,("PowerOnCard: T0 = %2.2x\n",abMaxAtrBuffer[1]));
        ulHistoricalBytes = abMaxAtrBuffer[1] & 0x0F;

        do {
            ulPtrToCurrentAtrByte = ulExpectedLengthOfAtr - 1;
            fTDxSent = FALSE;

            if (abMaxAtrBuffer[ulPtrToCurrentAtrByte] & 0x10)
                ulExpectedLengthOfAtr++;
            if (abMaxAtrBuffer[ulPtrToCurrentAtrByte] & 0x20)
                ulExpectedLengthOfAtr++;
            if (abMaxAtrBuffer[ulPtrToCurrentAtrByte] & 0x40)
                ulExpectedLengthOfAtr++;
            if (abMaxAtrBuffer[ulPtrToCurrentAtrByte] & 0x80) {
                ulExpectedLengthOfAtr++;
                fTDxSent = TRUE;
            }

            if (fOnlyT0 == TRUE                                &&
                ulPtrToCurrentAtrByte != 1                     &&   // check if not T0
                (abMaxAtrBuffer[ulPtrToCurrentAtrByte ] & 0x0f)  ) {
                fOnlyT0 = FALSE;
            }

         // TA1, TB1, TC1 , TD1
            while (ulCurrentLengthOfAtr < ulExpectedLengthOfAtr) {
                NTStatus = CMUSB_ReadP1(DeviceObject);
                if (NTStatus == STATUS_DEVICE_DATA_ERROR) {
                    DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
                    goto ExitPowerOnCard;
                } else if (NTStatus != STATUS_SUCCESS) {
                    fTryNextCard = TRUE;
                    break;
                }
                ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;

                RtlCopyBytes((PVOID)(abMaxAtrBuffer+ulCurrentLengthOfAtr),
                             (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                             ulBytesRead);
                if (fInverseAtr) {
                    CMUSB_InverseBuffer(abMaxAtrBuffer+ulCurrentLengthOfAtr,
                                        ulBytesRead);
                }

                ulCurrentLengthOfAtr += ulBytesRead;
            } // end of while


            if (fTryNextCard == TRUE) {
                break;
            }


#ifdef DBG
            SmartcardDebug(DEBUG_ATR,("PowerOnCard: ATR read bytes: "));
            for (i = 0;i < ulExpectedLengthOfAtr;i++)
                SmartcardDebug(DEBUG_ATR,("%2.2x ",abMaxAtrBuffer[i]));
            SmartcardDebug(DEBUG_ATR,("\n"));
#endif

        } while (fTDxSent == TRUE);

        if (fTryNextCard == TRUE) {
            continue;
        }


      // read historical bytes

      // bug fix : old SAMOS cards have a damaged ATR
        if (abMaxAtrBuffer[0] == 0x3b   &&
            abMaxAtrBuffer[1] == 0xbf   &&
            abMaxAtrBuffer[2] == 0x11   &&
            abMaxAtrBuffer[3] == 0x00   &&
            abMaxAtrBuffer[4] == 0x81   &&
            abMaxAtrBuffer[5] == 0x31   &&
            abMaxAtrBuffer[6] == 0x90   &&
            abMaxAtrBuffer[7] == 0x73      ) {
            ulHistoricalBytes = 4;
        }




        ulExpectedLengthOfAtr += ulHistoricalBytes;
        if (fOnlyT0 == FALSE) {
            ulExpectedLengthOfAtr ++;
        }

        while (ulCurrentLengthOfAtr < ulExpectedLengthOfAtr) {
            NTStatus = CMUSB_ReadP1(DeviceObject);
            if (NTStatus == STATUS_DEVICE_DATA_ERROR) {
                DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
                goto ExitPowerOnCard;
            } else if (NTStatus != STATUS_SUCCESS) {
                fTryNextCard = TRUE;
                break;
            }
            ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;

            RtlCopyBytes((PVOID)(abMaxAtrBuffer+ulCurrentLengthOfAtr),
                         (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                         ulBytesRead);
            if (fInverseAtr) {
                CMUSB_InverseBuffer(abMaxAtrBuffer+ulCurrentLengthOfAtr,
                                    ulBytesRead);
            }
            ulCurrentLengthOfAtr += ulBytesRead;
        }
        if (fTryNextCard == TRUE) {
            continue;
        }


      // check ATR
        if (ulCurrentLengthOfAtr < 3                ||
            ulCurrentLengthOfAtr > SCARD_ATR_LENGTH   ) {
            goto ExitPowerOnCard;
        }


      // check if the ATR of a SAMOS card with damaged ATR msut be corrected
        CMUSB_CheckAtrModified(abMaxAtrBuffer,ulCurrentLengthOfAtr);

        NTStatus = STATUS_SUCCESS;
        fValidAtrReceived = TRUE;
        RtlCopyBytes((PVOID)pbATR,
                     (PVOID)abMaxAtrBuffer,
                     ulCurrentLengthOfAtr);
        *pulATRLength = ulCurrentLengthOfAtr;

        if (fInverseAtr) {
            SmartcardExtension->ReaderExtension->fInverseAtr = TRUE;
        } else {
            SmartcardExtension->ReaderExtension->fInverseAtr = FALSE;
        }
        SmartcardExtension->ReaderExtension->fRawModeNecessary = FALSE;

      // -------------------
      // set card parameters
      // -------------------
        if (SmartcardExtension->ReaderExtension->fInverseAtr) {
            SmartcardExtension->ReaderExtension->CardParameters.bBaudRate |= CMUSB_ODD_PARITY;
        }
        SmartcardExtension->ReaderExtension->CardParameters.bBaudRate |= abFrequency[ulCardType];
        SmartcardExtension->ReaderExtension->CardParameters.bBaudRate |= CMUSB_BAUDRATE_9600;
        SmartcardExtension->ReaderExtension->CardParameters.bCardType = CMUSB_SMARTCARD_ASYNCHRONOUS;
        break;
    }



    ExitPowerOnCard:
   // return correct error code
    if (NTStatus != STATUS_NO_MEDIA && fValidAtrReceived == FALSE) {
        SmartcardDebug(DEBUG_ATR,
                       ("%s!PowerOnCard: no valid ATR received\n",DRIVER_NAME));
        NTStatus = STATUS_UNRECOGNIZED_MEDIA;
    }

    if (NTStatus!=STATUS_SUCCESS) {
      // turn off VCC again
        CMUSB_PowerOffCard (SmartcardExtension );
      // ignor NTStatus
    }

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!PowerOnCard: Exit %lx\n",DRIVER_NAME,NTStatus));

    return NTStatus;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_CardTracking(
                           PSMARTCARD_EXTENSION pSmartcardExtension
                           )
{
    KIRQL oldIrql;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CardTracking: Enter\n",DRIVER_NAME ));

   //
   // Set cancel routine for the notification irp
   //
    IoAcquireCancelSpinLock(&oldIrql);
    IoSetCancelRoutine(pSmartcardExtension->OsData->NotificationIrp,
                       CMUSB_CancelCardTracking);
    IoReleaseCancelSpinLock(oldIrql);

   //
   // Mark notification irp pending
   //
    IoMarkIrpPending(pSmartcardExtension->OsData->NotificationIrp);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CardTracking: Exit\n",DRIVER_NAME ));

    return STATUS_PENDING;
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_Cleanup(
                      IN PDEVICE_OBJECT DeviceObject,
                      IN PIRP Irp
                      )
{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &DeviceExtension->SmartcardExtension;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!Cleanup: Enter\n",DRIVER_NAME));

    if (SmartcardExtension->OsData->NotificationIrp != NULL &&
       // test if there is a pending IRP at all
        SmartcardExtension->ReaderExtension != NULL &&
       // if the device has been removed ReaderExtension == NULL
        DeviceExtension->lOpenCount == 1 )
    // complete card tracking only if this is the the last close call
    // otherwise the card tracking of the resource manager is canceled
    {
      //
      // We need to complete the notification irp
      //
        CMUSB_CompleteCardTracking(SmartcardExtension);
    }

    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!Cleanup: Completing IRP %lx\n",DRIVER_NAME,Irp));

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!Cleanup: Exit\n",DRIVER_NAME));

    return STATUS_SUCCESS;
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_CancelCardTracking(
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN PIRP Irp)
{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &DeviceExtension->SmartcardExtension;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CancelCardTracking: Enter\n",DRIVER_NAME));

    ASSERT(Irp == SmartcardExtension->OsData->NotificationIrp);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    CMUSB_CompleteCardTracking(SmartcardExtension);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CancelCardTracking: Exit\n",DRIVER_NAME));

    return STATUS_CANCELLED;
}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_IoCtlVendor(
                          PSMARTCARD_EXTENSION SmartcardExtension
                          )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    NTSTATUS DebugStatus;
    UCHAR  pbAtrBuffer[MAXIMUM_ATR_LENGTH];
    ULONG  ulAtrLength;


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!IoCtlVendor : Enter\n",DRIVER_NAME));

    switch (SmartcardExtension->MajorIoControlCode) {
    case CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED:
        NTStatus = CMUSB_SetHighSpeed_CR80S_SAMOS(SmartcardExtension);
        break;

    case CM_IOCTL_GET_FW_VERSION:
        NTStatus = CMUSB_GetFWVersion(SmartcardExtension);
        break;

    case CM_IOCTL_READ_DEVICE_DESCRIPTION:
        NTStatus = CMUSB_ReadDeviceDescription(SmartcardExtension);
        break;

    case CM_IOCTL_SET_READER_9600_BAUD:
        NTStatus = CMUSB_SetReader_9600Baud(SmartcardExtension);
        break;

    case CM_IOCTL_SET_READER_38400_BAUD:
        NTStatus = CMUSB_SetReader_38400Baud(SmartcardExtension);
        break;

    case CM_IOCTL_SET_SYNC_PARAMETERS:
         // in case of CardManUSB do nothing
        NTStatus = STATUS_SUCCESS;
        break;

    case CM_IOCTL_SYNC_CARD_POWERON:
        NTStatus = CMUSB_PowerOnSynchronousCard(SmartcardExtension,
                                                pbAtrBuffer,
                                                &ulAtrLength);
        break;

    case CM_IOCTL_2WBP_RESET_CARD:
        SmartcardExtension->MinorIoControlCode = SMARTCARD_WARM_RESET;
        NTStatus = CMUSB_PowerOnSynchronousCard(SmartcardExtension,
                                                pbAtrBuffer,
                                                &ulAtrLength);
        break;

    case CM_IOCTL_2WBP_TRANSFER:
        NTStatus = CMUSB_Transmit2WBP(SmartcardExtension);
        break;

    case CM_IOCTL_3WBP_TRANSFER:
        NTStatus = CMUSB_Transmit3WBP(SmartcardExtension);
        break;


    default:
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }





    SmartcardDebug(DEBUG_TRACE,
                   ("%s!IoCtlVendor : Exit %lx\n",DRIVER_NAME,NTStatus));

    return NTStatus;

}

/*****************************************************************************
Routine Description:



Arguments:



Return Value: STATUS_UNSUCCESSFUL
              STATUS_SUCCESS

*****************************************************************************/
NTSTATUS CMUSB_SetHighSpeed_CR80S_SAMOS (
                                        IN PSMARTCARD_EXTENSION SmartcardExtension
                                        )
{
    NTSTATUS NTStatus;
    NTSTATUS DebugStatus;
    UCHAR abReadBuffer[16];
    ULONG ulBytesRead;
    BYTE abCR80S_SAMOS_SET_HIGH_SPEED[4] = {0xFF,0x11,0x94,0x7A};
    ULONG ulAtrLength;
    BYTE abAtr[MAXIMUM_ATR_LENGTH];
    LARGE_INTEGER   liWaitTime;
    BOOLEAN         fStateTimer;
    ULONG           ulWaitTime;
    BOOLEAN         fCancelTimer = FALSE;


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetHighSpeed_CR80S_SAMOS: Enter\n",DRIVER_NAME));

    SmartcardDebug(DEBUG_PROTOCOL,
                   ("%s!SetHighSpeed_CR80S_SAMOS: writing high speed command\n",DRIVER_NAME));


    RtlCopyBytes((PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                 (PVOID)abCR80S_SAMOS_SET_HIGH_SPEED,
                 sizeof(abCR80S_SAMOS_SET_HIGH_SPEED));
    SmartcardExtension->SmartcardRequest.BufferLength = 4;
    NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                             0x01,         //we can use T=1 setting for direct communication
                             0x00,         //bValueLo,
                             0x00,         //bValueHi,
                             0x00,         //bIndexLo,
                             0x00);        //bIndexHi,
    if (NTStatus != STATUS_SUCCESS) {
        SmartcardDebug(DEBUG_ERROR,
                       ("%s!SetHighSpeed_CR80S_SAMOS: writing high speed command failed\n",DRIVER_NAME));
        goto ExitSetHighSpeed;
    }

   // read back pts data
    SmartcardDebug(DEBUG_PROTOCOL,
                   ("%s!SetHighSpeed_CR80S_SAMOS: reading echo\n",DRIVER_NAME));

   // maximim initial waiting time is 9600 * etu
   // => 1 sec is sufficient
    ulWaitTime = 1000;
    liWaitTime = RtlConvertLongToLargeInteger(ulWaitTime * -10000);
    KeSetTimer(&SmartcardExtension->ReaderExtension->WaitTimer,
               liWaitTime,
               NULL);

    fCancelTimer = TRUE;


    do {
        SmartcardExtension->ReaderExtension->ulTimeoutP1 = ulWaitTime;
        NTStatus = CMUSB_ReadP1(SmartcardExtension->OsData->DeviceObject);
        if (NTStatus == STATUS_DEVICE_DATA_ERROR) {
            DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
            break;
        }

        fStateTimer = KeReadStateTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
        if (fStateTimer == TRUE) {
            fCancelTimer =FALSE;
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s!SetHighSpeed_CR80S_SAMOS: timeout while reading echo\n",DRIVER_NAME));
            break;
        }



    } while (SmartcardExtension->SmartcardReply.Buffer[0] < 4 );

    if (NTStatus != STATUS_SUCCESS) {
        goto ExitSetHighSpeed;
    }


    SmartcardExtension->SmartcardReply.BufferLength = 4;
    NTStatus = CMUSB_ReadP0(SmartcardExtension->OsData->DeviceObject);
    if (NTStatus != STATUS_SUCCESS) {
        SmartcardDebug(DEBUG_ERROR,
                       ("%s!SetHighSpeed_CR80S_SAMOS: reading echo failed\n",DRIVER_NAME));
        goto ExitSetHighSpeed;
    }
    ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;

    RtlCopyBytes((PVOID)abReadBuffer,
                 (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                 ulBytesRead);



   // if the card has accepted this string , the string is echoed
    if (abReadBuffer[0] == abCR80S_SAMOS_SET_HIGH_SPEED[0]  &&
        abReadBuffer[1] == abCR80S_SAMOS_SET_HIGH_SPEED[1]  &&
        abReadBuffer[2] == abCR80S_SAMOS_SET_HIGH_SPEED[2]  &&
        abReadBuffer[3] == abCR80S_SAMOS_SET_HIGH_SPEED[3]      ) {
        SmartcardExtension->ReaderExtension->CardParameters.bBaudRate = 0;

        SmartcardExtension->ReaderExtension->CardParameters.bBaudRate |= CMUSB_FREQUENCY_5_12MHZ;
        SmartcardExtension->ReaderExtension->CardParameters.bBaudRate |= CMUSB_BAUDRATE_76800;
        SmartcardExtension->ReaderExtension->CardParameters.bCardType  = CMUSB_SMARTCARD_ASYNCHRONOUS;


        NTStatus = CMUSB_SetCardParameters (SmartcardExtension->OsData->DeviceObject,
                                            SmartcardExtension->ReaderExtension->CardParameters.bCardType,
                                            SmartcardExtension->ReaderExtension->CardParameters.bBaudRate,
                                            SmartcardExtension->ReaderExtension->CardParameters.bStopBits);


    } else {
        DebugStatus = CMUSB_PowerOffCard(SmartcardExtension);

      // a cold reset is necessary now
        SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
        DebugStatus = CMUSB_PowerOnCard(SmartcardExtension,abAtr,&ulAtrLength);
        NTStatus = STATUS_UNSUCCESSFUL;
    }




    ExitSetHighSpeed:
    if (fCancelTimer == TRUE) {
        KeCancelTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
    }

    *SmartcardExtension->IoRequest.Information = 0L;
    if (NTStatus != STATUS_SUCCESS)
        NTStatus = STATUS_UNSUCCESSFUL;
    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetHighSpeed_CR80S_SAMOS: Exit %lx\n",DRIVER_NAME,NTStatus));
    return NTStatus;
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_GetFWVersion (
                            IN PSMARTCARD_EXTENSION SmartcardExtension
                            )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!GetFWVersion : Enter\n",DRIVER_NAME));


    if (SmartcardExtension->IoRequest.ReplyBufferLength  < sizeof (ULONG)) {
        NTStatus = STATUS_BUFFER_OVERFLOW;
        goto ExitGetFWVersion;
    } else {
        *(PULONG)(SmartcardExtension->IoRequest.ReplyBuffer) =
        SmartcardExtension->ReaderExtension->ulFWVersion;
    }


    ExitGetFWVersion:
    *SmartcardExtension->IoRequest.Information = sizeof(ULONG);
    SmartcardDebug(DEBUG_TRACE,
                   ("%s!GetFWVersion : Exit %lx\n",DRIVER_NAME,NTStatus));
    return NTStatus;
}

/*****************************************************************************
Routine Description:


Arguments:


Return Value: STATUS_UNSUCCESSFUL
              STATUS_SUCCESS

*****************************************************************************/
NTSTATUS CMUSB_SetReader_9600Baud (
                                  IN PSMARTCARD_EXTENSION SmartcardExtension
                                  )
{
    NTSTATUS    NTStatus = STATUS_SUCCESS;
    KIRQL       irql;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetReader_9600Baud: Enter\n",DRIVER_NAME));

   // check if card is already in specific mode
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);
    if (SmartcardExtension->ReaderCapabilities.CurrentState != SCARD_SPECIFIC) {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        goto ExitSetReader9600;
    } else {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
    }

   // set 9600 Baud for 3.58 MHz
    SmartcardExtension->ReaderExtension->CardParameters.bBaudRate = CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_9600;
    SmartcardExtension->ReaderExtension->CardParameters.bCardType  = CMUSB_SMARTCARD_ASYNCHRONOUS;
    NTStatus = CMUSB_SetCardParameters (SmartcardExtension->OsData->DeviceObject,
                                        SmartcardExtension->ReaderExtension->CardParameters.bCardType,
                                        SmartcardExtension->ReaderExtension->CardParameters.bBaudRate,
                                        SmartcardExtension->ReaderExtension->CardParameters.bStopBits);

    ExitSetReader9600:
    *SmartcardExtension->IoRequest.Information = 0L;
    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetReader_9600Baud: Exit %lx\n",DRIVER_NAME,NTStatus));

    return(NTStatus);
}


/*****************************************************************************
Routine Description:


Arguments:


Return Value: STATUS_UNSUCCESSFUL
              STATUS_SUCCESS

*****************************************************************************/
NTSTATUS CMUSB_SetReader_38400Baud (
                                   IN PSMARTCARD_EXTENSION SmartcardExtension
                                   )
{
    NTSTATUS    NTStatus = STATUS_SUCCESS;
    KIRQL       irql;
    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetReader_38400Baud: Enter\n",DRIVER_NAME));

   // check if card is already in specific mode
    
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);
    if (SmartcardExtension->ReaderCapabilities.CurrentState != SCARD_SPECIFIC) {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        goto ExitSetReader38400;
    } else {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
    }



   // set 384000 Baud for 3.58 MHz card
    SmartcardExtension->ReaderExtension->CardParameters.bBaudRate = CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_38400;
    SmartcardExtension->ReaderExtension->CardParameters.bCardType  = CMUSB_SMARTCARD_ASYNCHRONOUS;
    NTStatus = CMUSB_SetCardParameters (SmartcardExtension->OsData->DeviceObject,
                                        SmartcardExtension->ReaderExtension->CardParameters.bCardType,
                                        SmartcardExtension->ReaderExtension->CardParameters.bBaudRate,
                                        SmartcardExtension->ReaderExtension->CardParameters.bStopBits);

    ExitSetReader38400:
    *SmartcardExtension->IoRequest.Information = 0L;
    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetReader_38400Baud: Exit %lx\n",DRIVER_NAME,NTStatus));

    return(NTStatus);
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
CMUSB_InitializeSmartcardExtension(
                                  IN PSMARTCARD_EXTENSION SmartcardExtension
                                  )
{
   // ==================================
   // Fill the Vendor_Attr structure
   // ==================================
    RtlCopyBytes((PVOID)SmartcardExtension->VendorAttr.VendorName.Buffer,
                 (PVOID)CM2020_VENDOR_NAME,
                 sizeof(CM2020_VENDOR_NAME)
                );

   //
   // Length of vendor name
   //
    SmartcardExtension->VendorAttr.VendorName.Length = sizeof(CM2020_VENDOR_NAME);


   //
   // Reader name
   //
    RtlCopyBytes((PVOID)SmartcardExtension->VendorAttr.IfdType.Buffer,
                 (PVOID)CM2020_PRODUCT_NAME,
                 sizeof(CM2020_PRODUCT_NAME));

   //
   // Length of reader name
   //
    SmartcardExtension->VendorAttr.IfdType.Length = sizeof(CM2020_PRODUCT_NAME);



   //
   // Version number
   //
    SmartcardExtension->VendorAttr.IfdVersion.BuildNumber  = BUILDNUMBER_CARDMAN_USB;
    SmartcardExtension->VendorAttr.IfdVersion.VersionMinor = VERSIONMINOR_CARDMAN_USB;
    SmartcardExtension->VendorAttr.IfdVersion.VersionMajor = VERSIONMAJOR_CARDMAN_USB;


   //
   // Unit number which is zero based
   //
    SmartcardExtension->VendorAttr.UnitNo = SmartcardExtension->ReaderExtension->ulDeviceInstance;



   // ================================================
   // Fill the SCARD_READER_CAPABILITIES structure
   // ===============================================
   //
   // Supported protoclols by the reader
   //

    SmartcardExtension->ReaderCapabilities.SupportedProtocols = SCARD_PROTOCOL_T1 | SCARD_PROTOCOL_T0;




   //
   // Reader type serial, keyboard, ....
   //
    SmartcardExtension->ReaderCapabilities.ReaderType = SCARD_READER_TYPE_USB;

   //
   // Mechanical characteristics like swallows etc.
   //
    SmartcardExtension->ReaderCapabilities.MechProperties = 0;


   //
   // Current state of the reader
   //
    SmartcardExtension->ReaderExtension->ulOldCardState = UNKNOWN;
    SmartcardExtension->ReaderExtension->ulNewCardState = UNKNOWN;
    SmartcardExtension->ReaderCapabilities.CurrentState  = SCARD_UNKNOWN;



   //
   // Data Rate
   //
    SmartcardExtension->ReaderCapabilities.DataRate.Default =
    SmartcardExtension->ReaderCapabilities.DataRate.Max =
    dataRatesSupported[0];


   // reader could support higher data rates
    SmartcardExtension->ReaderCapabilities.DataRatesSupported.List =
    dataRatesSupported;
    SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
    sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);


   //
   // CLK Frequency
   //


    SmartcardExtension->ReaderCapabilities.CLKFrequency.Default =
    SmartcardExtension->ReaderCapabilities.CLKFrequency.Max =
    CLKFrequenciesSupported[0];

   // reader could support higher frequencies
    SmartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.List =
    CLKFrequenciesSupported;
    SmartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.Entries =
    sizeof(CLKFrequenciesSupported) / sizeof(CLKFrequenciesSupported[0]);


   //
   // MaxIFSD
   //
    SmartcardExtension->ReaderCapabilities.MaxIFSD = ATTR_MAX_IFSD_CARDMAN_USB;





}


/*****************************************************************************
Routine Description:
This function always returns 'CardManUSB'.


Arguments:     pointer to SMARTCARD_EXTENSION



Return Value:  NT NTStatus

*****************************************************************************/
NTSTATUS
CMUSB_ReadDeviceDescription(IN PSMARTCARD_EXTENSION SmartcardExtension )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    BYTE abDeviceDescription[] = "CardManUSB";

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!ReadDeviceDescription : Enter\n",DRIVER_NAME));

    if (SmartcardExtension->IoRequest.ReplyBufferLength  < sizeof(abDeviceDescription)) {
        NTStatus = STATUS_BUFFER_OVERFLOW;
        *SmartcardExtension->IoRequest.Information = 0L;
        goto ExitReadDeviceDescription;
    } else {
        RtlCopyBytes((PVOID)SmartcardExtension->IoRequest.ReplyBuffer,
                     (PVOID)abDeviceDescription,
                     sizeof(abDeviceDescription));
        *SmartcardExtension->IoRequest.Information = sizeof(abDeviceDescription);
    }



    ExitReadDeviceDescription:
    SmartcardDebug(DEBUG_TRACE,
                   ("%s!ReadDeviceDescription : Exit %lx\n",DRIVER_NAME,NTStatus));
    return NTStatus;
}



/*****************************************************************************
Routine Description:

This routine always returns FALSE.

Arguments:    pointer to SMARDCARD_EXTENSION


Return Value: NT NTStatus


*****************************************************************************/
NTSTATUS
CMUSB_IsSPESupported (IN PSMARTCARD_EXTENSION SmartcardExtension )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!IsSPESupported: Enter\n",DRIVER_NAME));

    if (SmartcardExtension->IoRequest.ReplyBufferLength  < sizeof (ULONG)) {
        NTStatus = STATUS_BUFFER_OVERFLOW;
        *SmartcardExtension->IoRequest.Information = 0;
        goto ExitIsSPESupported;
    } else {
        *(PULONG)(SmartcardExtension->IoRequest.ReplyBuffer) = FALSE;
        *SmartcardExtension->IoRequest.Information = sizeof(ULONG);
    }



    ExitIsSPESupported:
    SmartcardDebug(DEBUG_TRACE,
                   ("%s!IsSPESupported: Exit %lx\n",DRIVER_NAME,NTStatus));
    return NTStatus;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_SetCardParameters (
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN UCHAR bCardType,
                                 IN UCHAR bBaudRate,
                                 IN UCHAR bStopBits
                                 )
{
    NTSTATUS NTStatus;
    PDEVICE_EXTENSION    DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;




    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetCardParameters: Enter\n",DRIVER_NAME));

    SmartcardDebug(DEBUG_PROTOCOL,
                   ("%s!SetCardParameters: ##################################################\n",DRIVER_NAME));
    SmartcardDebug(DEBUG_PROTOCOL,
                   ("%s!SetCardParameters: bCardType = %x bBaudRate = %x bStopBits = %x\n",DRIVER_NAME,
                    bCardType,bBaudRate,bStopBits));
    SmartcardDebug(DEBUG_PROTOCOL,
                   ("%s!SetCardParameters: ##################################################\n",DRIVER_NAME));

    DeviceExtension = DeviceObject->DeviceExtension;
    SmartcardExtension = &DeviceExtension->SmartcardExtension;

    SmartcardExtension->SmartcardRequest.BufferLength = 0;
    NTStatus = CMUSB_WriteP0(DeviceObject,
                             0x30,         //bRequest,
                             bCardType,    //bValueLo,
                             bBaudRate,    //bValueHi,
                             bStopBits,    //bIndexLo,
                             0x00          //bIndexHi,
                            );



    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetCardParameters: Exit %lx\n",DRIVER_NAME,NTStatus));
    return NTStatus;
}

/*****************************************************************************
Routine Description:

 Bit0 -> Bit 7
 Bit1 -> Bit 6
 Bit2 -> Bit 5
 Bit3 -> Bit 4
 Bit4 -> Bit 3
 Bit5 -> Bit 2
 Bit6 -> Bit 1
 Bit7 -> Bit 0

Arguments:



Return Value:

*****************************************************************************/
VOID CMUSB_InverseBuffer (
                         PUCHAR pbBuffer,
                         ULONG  ulBufferSize
                         )
{
    ULONG i;
    ULONG j;
    ULONG m;
    ULONG n;

    for (i=0; i<ulBufferSize; i++) {
        n = 0;
        for (j=1; j<=8; j++) {
            m  = (pbBuffer[i] << j);
            m &= 0x00000100;
            n  |= (m >> (9-j));
        }
        pbBuffer[i] = (UCHAR)~n;
    }

    return;
}

/*****************************************************************************
Routine Description:

 This function checks if an incorrect ATR has been received.
 It corrects the number of historical bytes and the checksum byte

Arguments:  pointer to current ATR
            length of ATR


Return Value: none

*****************************************************************************/
VOID CMUSB_CheckAtrModified (
                            PUCHAR pbBuffer,
                            ULONG  ulBufferSize
                            )
{
    UCHAR bNumberHistoricalBytes;
    UCHAR bXorChecksum;
    ULONG i;

    if (ulBufferSize < 0x09)  // mininmum length of a modified ATR
        return ;               // ATR is ok


   // variant 2
    if (pbBuffer[0] == 0x3b   &&
        pbBuffer[1] == 0xbf   &&
        pbBuffer[2] == 0x11   &&
        pbBuffer[3] == 0x00   &&
        pbBuffer[4] == 0x81   &&
        pbBuffer[5] == 0x31   &&
        pbBuffer[6] == 0x90   &&
        pbBuffer[7] == 0x73   &&
        ulBufferSize == 13   ) {
      // correct number of historical bytes
        bNumberHistoricalBytes = 4;

        pbBuffer[1] &= 0xf0;
        pbBuffer[1] |= bNumberHistoricalBytes;

      // correct checksum byte
        bXorChecksum = pbBuffer[1];
        for (i=2;i<ulBufferSize-1;i++)
            bXorChecksum ^= pbBuffer[i];

        pbBuffer[ulBufferSize -1 ] = bXorChecksum;
        SmartcardDebug(DEBUG_ATR,
                       ("%s!CheckAtrModified: correcting SAMOS ATR (variant 2)\n",
                        DRIVER_NAME));
    }




   // variant 1
    if (pbBuffer[0] == 0x3b   &&
        pbBuffer[1] == 0xb4   &&
        pbBuffer[2] == 0x11   &&
        pbBuffer[3] == 0x00   &&
        pbBuffer[4] == 0x81   &&
        pbBuffer[5] == 0x31   &&
        pbBuffer[6] == 0x90   &&
        pbBuffer[7] == 0x73   &&
        ulBufferSize == 13      ) {
      // correct checksum byte
        bXorChecksum = pbBuffer[1];
        for (i=2;i<ulBufferSize-1;i++)
            bXorChecksum ^= pbBuffer[i];


        if (pbBuffer[ulBufferSize -1 ] != bXorChecksum ) {
            pbBuffer[ulBufferSize -1 ] = bXorChecksum;
            SmartcardDebug(DEBUG_ATR,
                           ("%s!CheckAtrModified: correcting SAMOS ATR (variant 1)\n",
                            DRIVER_NAME));

        }
    }



   // variant 3
    if (pbBuffer[0] == 0x3b   &&
        pbBuffer[1] == 0xbf   &&
        pbBuffer[2] == 0x11   &&
        pbBuffer[3] == 0x00   &&
        pbBuffer[4] == 0x81   &&
        pbBuffer[5] == 0x31   &&
        pbBuffer[6] == 0x90   &&
        pbBuffer[7] == 0x73   &&
        ulBufferSize ==  9      ) {
      // correct number of historical bytes
        bNumberHistoricalBytes = 0;

        pbBuffer[1] &= 0xf0;
        pbBuffer[1] |= bNumberHistoricalBytes;

      // correct checksum byte
        bXorChecksum = pbBuffer[1];
        for (i=2;i<ulBufferSize-1;i++)
            bXorChecksum ^= pbBuffer[i];

        pbBuffer[ulBufferSize -1 ] = bXorChecksum;
        SmartcardDebug(DEBUG_ATR,
                       ("%s!CheckAtrModified: correcting SAMOS ATR (variant 3)\n",
                        DRIVER_NAME));
    }



}

/*****************************************************************************
* History:
* $Log: scusbcb.c $
* Revision 1.9  2001/01/17 12:36:04  WFrischauf
* No comment given
*
* Revision 1.8  2000/09/25 13:38:21  WFrischauf
* No comment given
*
* Revision 1.7  2000/08/24 09:04:38  TBruendl
* No comment given
*
* Revision 1.6  2000/08/16 14:35:03  WFrischauf
* No comment given
*
* Revision 1.5  2000/08/16 08:25:06  TBruendl
* warning :uninitialized memory removed
*
* Revision 1.4  2000/07/24 11:34:59  WFrischauf
* No comment given
*
* Revision 1.1  2000/07/20 11:50:14  WFrischauf
* No comment given
*
*
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\cbhndlr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       cbhndlr.h
//
//--------------------------------------------------------------------------

#if !defined( __CB_HANDLER_H__ )
#define __CB_HANDLER_H__

NTSTATUS
CBCardPower(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBSetProtocol(		
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBTransmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBCardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

VOID
CBUpdateCardState(
	PSMARTCARD_EXTENSION SmartcardExtension,
    ULONG CardState
	);
//
//	LOCAL PROTOTYPES (not part of the callback handler interface )
//
NTSTATUS
CBT0Transmit(		
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBT1Transmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBRawTransmit(		
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBSynchronizeSTC(
	PSMARTCARD_EXTENSION SmartcardExtension 
	);

#endif // __CB_HANDLER_H__

//	------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\drivernt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       drivernt.h
//
//--------------------------------------------------------------------------

#if !defined( __DRIVER_NT_H__ )
#define __DRIVER_NT_H__

#include <NTDDK.H>
#include "STCLog.h"
#include "SMCLIB.h"
#include "WINSMCRD.h"
#include "SerialNT.h"

#define SMARTCARD_POOL_TAG '3BCS'

#if !defined( STATUS_DEVICE_REMOVED	)
#define STATUS_DEVICE_REMOVED	STATUS_UNSUCCESSFUL
#endif

void SystemTime( void );
void DataOut( PUCHAR p, ULONG l );

#define LOBYTE( any )	((UCHAR)( any & 0xFF ) )
#define HIBYTE( any )	((UCHAR)( ( any >> 8) & 0xFF ))

#define SysCompareMemory( p1, p2, Len )			( RtlCompareMemory( p1,p2, Len ) != Len )
#define SysCopyMemory( pDest, pSrc, Len )		RtlCopyMemory( pDest, pSrc, Len )
#define SysFillMemory( pDest, Value, Len )		RtlFillMemory( pDest, Len, Value )

typedef struct _DEVICE_EXTENSION
{
	SMARTCARD_EXTENSION		SmartcardExtension;

#if defined( __NT4__ )
	BOOLEAN					OpenFlag;
	UNICODE_STRING			LinkID;
#else
    KEVENT					ReaderStarted;		    //	Used to signal that the reader is able to process reqeusts
    LONG					ReaderOpen;				//  Used to signal the the reader has been closed
	KSPIN_LOCK				SpinLock;
	UNICODE_STRING			PnPDeviceName;			//	The pnp device name of our smart card reader
	PVOID					RemoveLock;
    ULONG					DeviceInstance;
    LONG					PowerState;				//	Used to keep track of the current power state the reader is in
    LONG					IoCount;			    //	The current number of io-requests
#endif



} DEVICE_EXTENSION, *PDEVICE_EXTENSION;
		
#define IOCTL_SR_COMMAND		SCARD_CTL_CODE( 0x800 )
#define IOCTL_GET_VERSIONS		SCARD_CTL_CODE( 0x801 )

typedef struct _VERSION_CONTROL
{
	ULONG	SmclibVersion;
	UCHAR	DriverMajor,
			DriverMinor,
			FirmwareMajor, 
			FirmwareMinor;

} VERSION_CONTROL, *PVERSION_CONTROL;

#define MAX_READERS				4

NTSTATUS
DriverEntry(
	PDRIVER_OBJECT	DriverObject,
	PUNICODE_STRING	RegistryPath
	);


NTSTATUS 
DrvGetConfiguration(
	PDRIVER_OBJECT	DriverObject,
	PUNICODE_STRING	RegistryPath,
	PULONG			pComPort
	);

NTSTATUS
DrvInitDeviceObject(
	PDRIVER_OBJECT	DriverObject,
	ULONG			ComPort
	);

VOID
DrvUnloadDevice( 
	PDEVICE_OBJECT	DeviceObject
	);

VOID
DrvUnloadDriver( 
	PDRIVER_OBJECT	DriverObject
	);

NTSTATUS 
DrvOpenClose(
	PDEVICE_OBJECT	DeviceObject,
	PIRP			Irp
	);

NTSTATUS 
DrvDeviceIoControl(
	PDEVICE_OBJECT	DeviceObject,
	PIRP			Irp
	);

NTSTATUS
DrvGenericIOCTL(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

void
DrvSetupSmartcardExtension(
	PSMARTCARD_EXTENSION	SmartcardExtension
	);

NTSTATUS
DrvCancel(
	PDEVICE_OBJECT DeviceObject,
	PIRP Irp
    );

void
SysDelay(
	ULONG Timeout
	);

#endif	// !__DRIVER_NT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\cbhndlr.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       cbhndlr.c
//
//--------------------------------------------------------------------------

#if defined( SMCLIB_VXD )
#include "Driver98.h"
#else
#include "DriverNT.h"
#endif

#include "SerialIF.h"
#include "STCCmd.h"
#include "CBHndlr.h"
#include "T0Hndlr.h"

NTSTATUS
CBCardPower(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

CBCardPower:
    callback handler for SMCLIB RDF_CARD_POWER

Arguments:
    SmartcardExtension  context of call

Return Value:
    STATUS_SUCCESS
    STATUS_NO_MEDIA
    STATUS_TIMEOUT
    STATUS_BUFFER_TOO_SMALL

--*/
{
    NTSTATUS            NTStatus = STATUS_SUCCESS;
    UCHAR               ATRBuffer[ ATR_SIZE ];
    ULONG               ATRLength;
    PREADER_EXTENSION   ReaderExtension;
    KIRQL               irql;
    SERIAL_TIMEOUTS Timeouts;

    SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBCardPower Enter\n" ));

    ReaderExtension = SmartcardExtension->ReaderExtension;

    //  discard old ATR
    SmartcardExtension->CardCapabilities.ATR.Length = 0;
    SmartcardExtension->CardCapabilities.Protocol.Selected = 
        SCARD_PROTOCOL_UNDEFINED;

    // set standard timeouts for the worker thread
    Timeouts.ReadIntervalTimeout = SR_READ_INTERVAL_TIMEOUT;
    Timeouts.ReadTotalTimeoutConstant = SR_READ_TOTAL_TIMEOUT_CONSTANT;
    Timeouts.ReadTotalTimeoutMultiplier = 0;
    Timeouts.WriteTotalTimeoutConstant = SR_WRITE_TOTAL_TIMEOUT_CONSTANT;
    Timeouts.WriteTotalTimeoutMultiplier = 0;

    NTStatus = IFSerialIoctl(
        ReaderExtension,
        IOCTL_SERIAL_SET_TIMEOUTS,
        &Timeouts,
        sizeof(Timeouts),
        NULL,
        0
        );
    ASSERT(NTStatus == STATUS_SUCCESS);

    // set the ATR timeout in milli sec
    ReaderExtension->ReadTimeout = 1500;

    switch (SmartcardExtension->MinorIoControlCode)
    {
        case SCARD_WARM_RESET:

            //  if the card was not powerd, fall through to cold reset
            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);

            if( SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_SWALLOWED )
            {
                KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                  irql);

                //  reset the card
                ATRLength = ATR_SIZE;
                NTStatus = STCReset(
                    ReaderExtension,
                    0,                  // not used: ReaderExtension->Device,
                    TRUE,               // warm reset
                    ATRBuffer,
                    &ATRLength
                    );

                break;
            } else {
                KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                  irql);

            }
            //  warm reset not possible because card was not powerd

        case SCARD_COLD_RESET:
            //  reset the card
            ATRLength = ATR_SIZE;
            NTStatus = STCReset(
                ReaderExtension,
                0,                      // not used: ReaderExtension->Device,
                FALSE,                  // cold reset
                ATRBuffer,
                &ATRLength
                );
            break;

        case SCARD_POWER_DOWN:

            //  discard old card status
            ATRLength = 0;
            STCPowerOff( ReaderExtension );
            NTStatus = STATUS_SUCCESS;
            CBUpdateCardState( SmartcardExtension, SCARD_PRESENT );
            break;
    }

    //  finish the request
    if( NTStatus == STATUS_SUCCESS )
    {
        //  update all neccessary data if an ATR was received
        if( ATRLength > 2 )
        {
            //  copy ATR to user buffer buffer
            if( ATRLength <= SmartcardExtension->IoRequest.ReplyBufferLength )
            {
                SysCopyMemory(
                    SmartcardExtension->IoRequest.ReplyBuffer,
                    ATRBuffer,
                    ATRLength
                    );
                *SmartcardExtension->IoRequest.Information = ATRLength;
            }
            else
            {
                NTStatus = STATUS_BUFFER_TOO_SMALL;
            }

            //  copy ATR to card capability buffer
            if( ATRLength <= MAXIMUM_ATR_LENGTH )
            {
                SysCopyMemory(
                    SmartcardExtension->CardCapabilities.ATR.Buffer,
                    ATRBuffer,
                    ATRLength
                    );

                SmartcardExtension->CardCapabilities.ATR.Length = 
                    (UCHAR)ATRLength;

                //  let the lib update the card capabilities
                NTStatus = SmartcardUpdateCardCapabilities( 
                    SmartcardExtension
                    );
            }
            else
            {
                NTStatus = STATUS_BUFFER_TOO_SMALL;
            }

            if( NTStatus == STATUS_SUCCESS )
            {
                ULONG minWaitTime;

                //  set the stc registers
                CBSynchronizeSTC( SmartcardExtension );

                // now set the new - card specific - timeouts
                if( SmartcardExtension->CardCapabilities.Protocol.Selected == 
                    SCARD_PROTOCOL_T1 )
                {
                    ReaderExtension->ReadTimeout = 
                    Timeouts.ReadTotalTimeoutConstant = 
                        SmartcardExtension->CardCapabilities.T1.BWT / 1000;

                    Timeouts.ReadIntervalTimeout = 
                        SmartcardExtension->CardCapabilities.T1.CWT / 1000;
                }
                else 
                {
                    ReaderExtension->ReadTimeout = 
                    Timeouts.ReadIntervalTimeout = 
                    Timeouts.ReadTotalTimeoutConstant = 
                        SmartcardExtension->CardCapabilities.T0.WT / 1000 * 5;
                }
                minWaitTime = (KeQueryTimeIncrement() / 10000) * 5;

                if (Timeouts.ReadTotalTimeoutConstant < minWaitTime) {

                    Timeouts.ReadTotalTimeoutConstant = minWaitTime;            
                }

                if (Timeouts.ReadIntervalTimeout < minWaitTime) {

                    Timeouts.ReadIntervalTimeout = minWaitTime;             
                }

                if (ReaderExtension->ReadTimeout < minWaitTime) {

                    ReaderExtension->ReadTimeout = minWaitTime;
                }

                // set standard timeouts for the worker thread
                Timeouts.ReadTotalTimeoutMultiplier = 0;

                NTStatus = IFSerialIoctl(
                    ReaderExtension,
                    IOCTL_SERIAL_SET_TIMEOUTS,
                    &Timeouts,
                    sizeof(Timeouts),
                    NULL,
                    0
                    );
                ASSERT(NTStatus == STATUS_SUCCESS);
            }
        }
    }

    SmartcardDebug( 
        DEBUG_TRACE,
        ( "SCMSTCS!CBCardPower Exit: %X\n", 
        NTStatus )
        );

    return( NTStatus );
}

NTSTATUS
CBSetProtocol(      
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

CBSetProtocol:
    callback handler for SMCLIB RDF_SET_PROTOCOL

Arguments:
    SmartcardExtension  context of call

Return Value:
    STATUS_SUCCESS
    STATUS_NO_MEDIA
    STATUS_TIMEOUT
    STATUS_BUFFER_TOO_SMALL
    STATUS_INVALID_DEVICE_STATE
    STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS            NTStatus = STATUS_PENDING;
    UCHAR               PTSRequest[5], PTSReply[5];
    ULONG               NewProtocol;
    PREADER_EXTENSION   ReaderExtension;
    KIRQL               irql;

    SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBSetProtocol Enter\n" ));

    ReaderExtension = SmartcardExtension->ReaderExtension;
    NewProtocol     = SmartcardExtension->MinorIoControlCode;

    //  check if the card is already in specific state
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);
    if( ( SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC )  &&
        ( SmartcardExtension->CardCapabilities.Protocol.Selected & NewProtocol ))
    {
        NTStatus = STATUS_SUCCESS;  
    }
    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                      irql);

    //  protocol supported?
    if( !( SmartcardExtension->CardCapabilities.Protocol.Supported & NewProtocol ) || 
        !( SmartcardExtension->ReaderCapabilities.SupportedProtocols & NewProtocol ))
    {
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;   
    }
    
    //  send PTS
    while( NTStatus == STATUS_PENDING )
    {
        // set initial character of PTS
        PTSRequest[0] = 0xFF;

        // set the format character
        if( NewProtocol & SCARD_PROTOCOL_T1 )
        {
            PTSRequest[1] = 0x11;
            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T1;
        }
        else
        {
            PTSRequest[1] = 0x10;
            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;
        }

        //  PTS1 codes Fl and Dl
        PTSRequest[2] = 
            SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
            SmartcardExtension->CardCapabilities.PtsData.Dl;

        //  check character
        PTSRequest[3] = PTSRequest[0] ^ PTSRequest[1] ^ PTSRequest[2];   

        //  write PTSRequest
        NTStatus = STCWriteICC1( ReaderExtension, PTSRequest, 4 );

        //  get response
        if( NTStatus == STATUS_SUCCESS )
        {
            ULONG BufferLength = sizeof(PTSReply);
            NTStatus = STCReadICC1( 
                ReaderExtension, 
                PTSReply, 
                &BufferLength,
                4
                );

            if(( NTStatus == STATUS_SUCCESS ) && !SysCompareMemory( PTSRequest, PTSReply, 4))
            {
                //  set the stc registers
                SmartcardExtension->CardCapabilities.Dl =
                    SmartcardExtension->CardCapabilities.PtsData.Dl;
                SmartcardExtension->CardCapabilities.Fl = 
                    SmartcardExtension->CardCapabilities.PtsData.Fl;

                CBSynchronizeSTC( SmartcardExtension );

                // the card replied correctly to the PTS-request
                break;
            }
        }

        //
        //  The card did either NOT reply or it replied incorrectly
        //  so try default values
        //
        SmartcardExtension->CardCapabilities.PtsData.Type   = PTS_TYPE_DEFAULT;
        SmartcardExtension->MinorIoControlCode              = SCARD_COLD_RESET;
        NTStatus = CBCardPower( SmartcardExtension );

        if( NTStatus == STATUS_SUCCESS )
        {
            NTStatus = STATUS_PENDING;
        }
        else
        {
            NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
        }
    }

    if( NTStatus == STATUS_TIMEOUT )
    {
        NTStatus = STATUS_IO_TIMEOUT;           
    }

    if( NTStatus == STATUS_SUCCESS )
    {
        ULONG minWaitTime;
        SERIAL_TIMEOUTS Timeouts;

        if( SmartcardExtension->CardCapabilities.Protocol.Selected == 
            SCARD_PROTOCOL_T1 )
        {
            ReaderExtension->ReadTimeout = 
            Timeouts.ReadTotalTimeoutConstant = 
                SmartcardExtension->CardCapabilities.T1.BWT / 1000;

            Timeouts.ReadIntervalTimeout = 
                SmartcardExtension->CardCapabilities.T1.CWT / 1000;
        }
        else 
        {
            ReaderExtension->ReadTimeout = 
            Timeouts.ReadIntervalTimeout = 
            Timeouts.ReadTotalTimeoutConstant = 
                SmartcardExtension->CardCapabilities.T0.WT / 1000 * 5;
        }

        minWaitTime = (KeQueryTimeIncrement() / 10000) * 5;

        if (Timeouts.ReadTotalTimeoutConstant < minWaitTime) {

            Timeouts.ReadTotalTimeoutConstant = minWaitTime;            
        }

        if (Timeouts.ReadIntervalTimeout < minWaitTime) {

            Timeouts.ReadIntervalTimeout = minWaitTime;             
        }

        if (ReaderExtension->ReadTimeout < minWaitTime) {

            ReaderExtension->ReadTimeout = minWaitTime;
        }

        Timeouts.WriteTotalTimeoutConstant = SR_WRITE_TOTAL_TIMEOUT_CONSTANT;
        Timeouts.WriteTotalTimeoutMultiplier = 0;
        Timeouts.ReadTotalTimeoutMultiplier = 0;

        NTStatus = IFSerialIoctl(
            ReaderExtension,
            IOCTL_SERIAL_SET_TIMEOUTS,
            &Timeouts,
            sizeof(Timeouts),
            NULL,
            0
            );
        ASSERT(NTStatus == STATUS_SUCCESS);

        //  indicate that the card is in specific mode 
        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);
        SmartcardExtension->ReaderCapabilities.CurrentState = 
            SCARD_SPECIFIC;

        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);

        // return the selected protocol to the caller
        *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = 
            SmartcardExtension->CardCapabilities.Protocol.Selected;
        *SmartcardExtension->IoRequest.Information = 
            sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);
    }
    else
    {
        SmartcardExtension->CardCapabilities.Protocol.Selected = 
            SCARD_PROTOCOL_UNDEFINED;
        *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = 0;
        *SmartcardExtension->IoRequest.Information = 0;
    }

    SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBSetProtocol: Exit %X\n", NTStatus ));

    return( NTStatus ); 
}

NTSTATUS
CBTransmit(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

CBTransmit:
    callback handler for SMCLIB RDF_TRANSMIT

Arguments:
    SmartcardExtension  context of call

Return Value:
    STATUS_SUCCESS
    STATUS_NO_MEDIA
    STATUS_TIMEOUT
    STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS  NTStatus = STATUS_SUCCESS;

    SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBTransmit Enter\n" ));

    //  dispatch on the selected protocol
    switch( SmartcardExtension->CardCapabilities.Protocol.Selected )
    {
        case SCARD_PROTOCOL_T0:
            NTStatus = CBT0Transmit( SmartcardExtension );
            break;

        case SCARD_PROTOCOL_T1:
            NTStatus = CBT1Transmit( SmartcardExtension );
            break;

        case SCARD_PROTOCOL_RAW:
            NTStatus = CBRawTransmit( SmartcardExtension );
            break;

        default:
            NTStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBTransmit Exit: %X\n", NTStatus ));

    return( NTStatus );
}

NTSTATUS
CBT0Transmit(       
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

CBT0Transmit:
    finishes the callback RDF_TRANSMIT for the T0 protocol

Arguments:
    SmartcardExtension  context of call

Return Value:
    STATUS_SUCCESS
    STATUS_NO_MEDIA
    STATUS_TIMEOUT
    STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS                NTStatus = STATUS_SUCCESS;

    SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBT0Transmit Enter\n" ));

    SmartcardExtension->SmartcardRequest.BufferLength = 0;
    SmartcardExtension->SmartcardReply.BufferLength = 
        SmartcardExtension->SmartcardReply.BufferSize;

    //  let the lib setup the T=1 APDU & check for errors
    NTStatus = SmartcardT0Request( SmartcardExtension );

    if( NTStatus == STATUS_SUCCESS )
    {
        NTStatus = T0_ExchangeData(
            SmartcardExtension->ReaderExtension,
            SmartcardExtension->SmartcardRequest.Buffer,
            SmartcardExtension->SmartcardRequest.BufferLength,
            SmartcardExtension->SmartcardReply.Buffer,
            &SmartcardExtension->SmartcardReply.BufferLength
            );

        if( NTStatus == STATUS_SUCCESS )
        {
            //  let the lib evaluate the result & tansfer the data
            NTStatus = SmartcardT0Reply( SmartcardExtension );
        }
    }

    SmartcardDebug( DEBUG_TRACE,("SCMSTCS!CBT0Transmit Exit: %X\n", NTStatus ));

    return( NTStatus );
}

NTSTATUS
CBT1Transmit(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

CBT1Transmit:
    finishes the callback RDF_TRANSMIT for the T1 protocol

Arguments:
    SmartcardExtension  context of call

Return Value:
    STATUS_SUCCESS
    STATUS_NO_MEDIA
    STATUS_TIMEOUT
    STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS    NTStatus = STATUS_SUCCESS;
    ULONG       BufferLength,AlreadyRead;

    SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBT1Transmit Enter\n" ));

    //KJ
    RtlZeroMemory( SmartcardExtension->SmartcardReply.Buffer, 
                   sizeof(SmartcardExtension->SmartcardReply.Buffer));

    //  use the lib support to construct the T=1 packets
    do {
        //  no header for the T=1 protocol
        SmartcardExtension->SmartcardRequest.BufferLength = 0;
        
        SmartcardExtension->T1.NAD = 0;

        //  let the lib setup the T=1 APDU & check for errors
        NTStatus = SmartcardT1Request( SmartcardExtension );
        if( NTStatus == STATUS_SUCCESS )
        {
            //  send command (don't calculate LRC because CRC may be used!)
            NTStatus = STCWriteICC1(
                SmartcardExtension->ReaderExtension,
                SmartcardExtension->SmartcardRequest.Buffer,
                SmartcardExtension->SmartcardRequest.BufferLength
                );

            //
            //  extend the timeout if a Wtx request was sent by the card. if the 
            //  card responds before the waiting time extension expires, the data are
            //  buffered in the reader. A delay without polling the reader status
            //  slows down the performance of the driver, but wtx is an exeption,
            //  not the rule.
            //
            if (SmartcardExtension->T1.Wtx)
            {

                    SysDelay(
                    (( SmartcardExtension->T1.Wtx * 
                    SmartcardExtension->CardCapabilities.T1.BWT + 999L )/
                    1000L) 
                    );

            }

            //  get response
            SmartcardExtension->SmartcardReply.BufferLength = 0;

            if( NTStatus == STATUS_SUCCESS )
            {
                BufferLength = SmartcardExtension->SmartcardReply.BufferSize;
                NTStatus = STCReadICC1(
                    SmartcardExtension->ReaderExtension,
                    SmartcardExtension->SmartcardReply.Buffer,
                    &BufferLength,
                    3
                    );
                // if we have read more then 3 bytes
                if(BufferLength > 3)
                {
                    AlreadyRead = BufferLength - 3;
                }
                else
                {
                    AlreadyRead = 0;
                }

                if( NTStatus == STATUS_SUCCESS )
                {
                    ULONG Length;

                    Length = (ULONG)SmartcardExtension->SmartcardReply.Buffer[ LEN_IDX ] + 1;

                    if( Length + 3 < MIN_BUFFER_SIZE )
                    {
                        BufferLength = 
                            SmartcardExtension->SmartcardReply.BufferSize - 
                            AlreadyRead - DATA_IDX;

                        NTStatus = STCReadICC1(
                            SmartcardExtension->ReaderExtension,
                            (&SmartcardExtension->SmartcardReply.Buffer[ DATA_IDX ]) + AlreadyRead,
                            &BufferLength,
                            Length-AlreadyRead
                            );

                        SmartcardExtension->SmartcardReply.BufferLength = Length + 3;
                    }
                    else
                    {
                        NTStatus = STATUS_BUFFER_TOO_SMALL;
                    }
                }
                //
                //  if STCRead detects an LRC error, ignore it (maybe CRC used). Timeouts will
                //  be detected by the lib if len=0
                //
                if(( NTStatus == STATUS_CRC_ERROR ) || ( NTStatus == STATUS_IO_TIMEOUT ))
                {
                    NTStatus = STATUS_SUCCESS;
                }

                if( NTStatus == STATUS_SUCCESS )
                {
                    //  let the lib evaluate the result & setup the next APDU
                    NTStatus = SmartcardT1Reply( SmartcardExtension );
                }
            }
        }

    //  continue if the lib wants to send the next packet
    } while( NTStatus == STATUS_MORE_PROCESSING_REQUIRED );

    if( NTStatus == STATUS_IO_TIMEOUT )
    {
        NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
    }

    SmartcardDebug( DEBUG_TRACE,( "SCMSTCS!CBT1Transmit Exit: %X\n", NTStatus ));

    return ( NTStatus );
}

NTSTATUS
CBRawTransmit(      
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

CBRawTransmit:
    finishes the callback RDF_TRANSMIT for the RAW protocol

Arguments:
    SmartcardExtension  context of call

Return Value:
    STATUS_SUCCESS
    STATUS_NO_MEDIA
    STATUS_TIMEOUT
    STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS            NTStatus = STATUS_SUCCESS;

    NTStatus = STATUS_UNSUCCESSFUL;
    SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBRawTransmit Exit: %X\n", NTStatus ));
    return ( NTStatus );
}

NTSTATUS
CBCardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

CBCardTracking:
    callback handler for SMCLIB RDF_CARD_TRACKING. the requested event was 
    validated by the smclib (i.e. a card removal request will only be passed 
    if a card is present).
    for a win95 build STATUS_PENDING will be returned without any other action. 
    for NT the cancel routine for the irp will be set to the drivers cancel
    routine.

Arguments:
    SmartcardExtension  context of call

Return Value:
    STATUS_PENDING

--*/
{
    SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBCardTracking Enter\n" ));

#if defined( SMCLIB_VXD )

#else

    {
        KIRQL       CurrentIrql;

        //  set cancel routine
        IoAcquireCancelSpinLock( &CurrentIrql );
        IoSetCancelRoutine(
            SmartcardExtension->OsData->NotificationIrp, 
            DrvCancel
            );

        IoReleaseCancelSpinLock( CurrentIrql );
    }

#endif

    SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!CBCardTracking Exit\n" ));

    return( STATUS_PENDING );

}

VOID
CBUpdateCardState(
    PSMARTCARD_EXTENSION SmartcardExtension,
    ULONG RequestedState
    )
/*++

CBUpdateCardState:
    updates the variable CurrentState in SmartcardExtension

Arguments:
    SmartcardExtension  context of call

Return Value:
    STATUS_SUCCESS

--*/
{
    NTSTATUS    NTStatus = STATUS_SUCCESS;
    UCHAR       Status;
    KIRQL       Irql;
    BOOLEAN     StateChanged = FALSE;
    ULONG       NewState = RequestedState;

    if (RequestedState == SCARD_UNKNOWN) {
        
        //  read card state from reader
        NTStatus = STCReadSTCRegister(
            SmartcardExtension->ReaderExtension,
            ADR_IO_CONFIG,
            1,
            &Status
            );

        ASSERT(NTStatus == STATUS_SUCCESS);

        if (NTStatus == STATUS_SUCCESS) {

            if ((Status & M_SD) == 0) {

                NewState = SCARD_ABSENT;

            } else {

                NewState = SCARD_SWALLOWED;             
            }
        }
    } 

    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock, &Irql);
    
    if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_UNKNOWN ||
        SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT && 
        NewState <= SCARD_ABSENT ||
        SmartcardExtension->ReaderCapabilities.CurrentState <= SCARD_ABSENT && 
        NewState > SCARD_ABSENT) {

        StateChanged = TRUE;    
    }


    if(RequestedState != SCARD_UNKNOWN || 
       NTStatus == STATUS_SUCCESS && StateChanged)
    {
        SmartcardExtension->ReaderCapabilities.CurrentState = NewState;
    }


    if(StateChanged && SmartcardExtension->OsData->NotificationIrp != NULL)
    {
        KIRQL CurrentIrql;
        IoAcquireCancelSpinLock( &CurrentIrql );

        IoSetCancelRoutine( SmartcardExtension->OsData->NotificationIrp, NULL );
        IoReleaseCancelSpinLock( CurrentIrql );

        SmartcardExtension->OsData->NotificationIrp->IoStatus.Status = 
            STATUS_SUCCESS;
        SmartcardExtension->OsData->NotificationIrp->IoStatus.Information = 0;

        IoCompleteRequest( 
            SmartcardExtension->OsData->NotificationIrp, 
            IO_NO_INCREMENT 
            );

        SmartcardExtension->OsData->NotificationIrp = NULL;
    }

    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock, Irql);

}

NTSTATUS
CBSynchronizeSTC(
    PSMARTCARD_EXTENSION SmartcardExtension 
    )
/*++

CBSynchronizeSTC:
    updates the card dependend data of the stc (wait times, ETU...)

Arguments:
    SmartcardExtension  context of call

Return Value:
    STATUS_SUCCESS

--*/

{
    NTSTATUS                NTStatus = STATUS_SUCCESS;
    PREADER_EXTENSION       ReaderExtension;
    ULONG                   CWT,
                            BWT,
                            CGT,
                            ETU;
    UCHAR                   Dl,
                            Fl,
                            N;

    PCLOCK_RATE_CONVERSION  ClockRateConversion;
    PBIT_RATE_ADJUSTMENT    BitRateAdjustment;

    ReaderExtension     = SmartcardExtension->ReaderExtension;
    ClockRateConversion = SmartcardExtension->CardCapabilities.ClockRateConversion;
    BitRateAdjustment   = SmartcardExtension->CardCapabilities.BitRateAdjustment;

    //  cycle length
    Dl = SmartcardExtension->CardCapabilities.Dl;
    Fl = SmartcardExtension->CardCapabilities.Fl;

    ETU = ClockRateConversion[Fl & 0x0F].F;

    ETU /= BitRateAdjustment[ Dl & 0x0F ].DNumerator;
    ETU *= BitRateAdjustment[ Dl & 0x0F ].DDivisor;

    // ETU += (ETU % 2 == 0) ? 0 : 1;

    //  a extra guard time of 0xFF means minimum delay in both directions
    N = SmartcardExtension->CardCapabilities.N;
    if( N == 0xFF )
    {
        N = 0;
    }

    //  set character waiting & guard time
    switch ( SmartcardExtension->CardCapabilities.Protocol.Selected )
    {
        case SCARD_PROTOCOL_T0:
            CWT = 960 * SmartcardExtension->CardCapabilities.T0.WI;
            CGT =  14 + N;
            break;

        case SCARD_PROTOCOL_T1:
            CWT = 1000 + ( 0x01 << SmartcardExtension->CardCapabilities.T1.CWI );
            BWT = 11 + ( 0x01 << SmartcardExtension->CardCapabilities.T1.BWI ) * 960;

            CGT = 15 + N;   //  12 + N;     sicrypt error

            NTStatus = STCSetBWT( ReaderExtension, BWT * ETU );

            break;

        default:
            NTStatus = STATUS_UNSUCCESSFUL;
            break;
    }

    if(( NTStatus == STATUS_SUCCESS ) && ETU )
    {
        NTStatus = STCSetETU( ReaderExtension, ETU );

        if( NTStatus == STATUS_SUCCESS )
        {
            NTStatus = STCSetCGT( ReaderExtension, CGT );

            if( NTStatus == STATUS_SUCCESS )
            {
                NTStatus = STCSetCWT( ReaderExtension, CWT * ETU );
            }
        }
    }
    return( NTStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\sccmusbm\scusbsyn.c ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmeu0/sw/sccmusbm.ms/rcs/scusbsyn.c $
* $Revision: 1.3 $
*-----------------------------------------------------------------------------
* $Author: TBruendl $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/



#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usbdi.h"
#include "usbdlib.h"
#include "sccmusbm.h"




/*****************************************************************************
Routine Description: Powers a synchronous card and reads the ATR

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_PowerOnSynchronousCard  (
                              IN  PSMARTCARD_EXTENSION smartcardExtension,
                              IN  PUCHAR pbATR,
                              OUT PULONG pulATRLength
                              )
{
   PDEVICE_OBJECT deviceObject;
   NTSTATUS       status = STATUS_SUCCESS;
   NTSTATUS       DebugStatus;
   UCHAR          abMaxAtrBuffer[SCARD_ATR_LENGTH];
   UCHAR          abSendBuffer[CMUSB_SYNCH_BUFFER_SIZE];
   UCHAR          bResetMode;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!PowerOnSynchronousCard: Enter\n",DRIVER_NAME));

   deviceObject = smartcardExtension->OsData->DeviceObject;

   // in case of warm reset we have to power off the card first
   if (smartcardExtension->MinorIoControlCode != SCARD_COLD_RESET)
      {
      status = CMUSB_PowerOffCard (smartcardExtension );
      if (status != STATUS_SUCCESS)
         {
         // if we can't turn off power there must be a serious error
         goto ExitPowerOnSynchronousCard;
         }
      }

   // set card parameters
   smartcardExtension->ReaderExtension->CardParameters.bBaudRate = 0;
   smartcardExtension->ReaderExtension->CardParameters.bCardType = CMUSB_SMARTCARD_SYNCHRONOUS;
   smartcardExtension->ReaderExtension->CardParameters.bStopBits = 0;

   status = CMUSB_SetCardParameters (deviceObject,
                                     smartcardExtension->ReaderExtension->CardParameters.bCardType,
                                     smartcardExtension->ReaderExtension->CardParameters.bBaudRate,
                                     smartcardExtension->ReaderExtension->CardParameters.bStopBits);
   if (status != STATUS_SUCCESS)
      {
      // if we can't set the card parameters there must be a serious error
      goto ExitPowerOnSynchronousCard;
      }

   RtlFillMemory((PVOID)abMaxAtrBuffer,
                 sizeof(abMaxAtrBuffer),
                 0x00);

   // resync CardManUSB by reading the status byte
   // still necessary with synchronous cards ???
   smartcardExtension->SmartcardRequest.BufferLength = 0;
   status = CMUSB_WriteP0(deviceObject,
                          0x20,         //bRequest,
                          0x00,         //bValueLo,
                          0x00,         //bValueHi,
                          0x00,         //bIndexLo,
                          0x00          //bIndexHi,
                         );

   if (status != STATUS_SUCCESS)
      {
      // if we can't read the status there must be a serious error
      goto ExitPowerOnSynchronousCard;
      }

   smartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
   status = CMUSB_ReadP1(deviceObject);
   if (status == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
      goto ExitPowerOnSynchronousCard;
      }
   else if (status != STATUS_SUCCESS)
      {
      // if we can't read the status there must be a serious error
      goto ExitPowerOnSynchronousCard;
      }

   // check if card is really inserted
   if (smartcardExtension->SmartcardReply.Buffer[0] == 0x00)
      {
      status = STATUS_NO_MEDIA;
      goto ExitPowerOnSynchronousCard;
      }


   // issue power on command
   // according to WZ nothing is sent back
   smartcardExtension->SmartcardRequest.BufferLength = 0;
   status = CMUSB_WriteP0(deviceObject,
                          0x10,                    //bRequest,
                          SMARTCARD_COLD_RESET,    //bValueLo,
                          0x00,                    //bValueHi,
                          0x00,                    //bIndexLo,
                          0x00                     //bIndexHi,
                         );
   if (status != STATUS_SUCCESS)
      {
      // if we can't issue the power on command there must be a serious error
      goto ExitPowerOnSynchronousCard;
      }


   // build control code for ATR
   abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 1,0,0,0);
   abSendBuffer[1]=CMUSB_CalcSynchControl(1,1,0,0, 1,0,0,0);
   abSendBuffer[2]=CMUSB_CalcSynchControl(0,0,0,0, 0,0,0,0);
   // fill memory so that we can discard first byte
   RtlFillMemory((PVOID)&abSendBuffer[3],5,abSendBuffer[2]);

   // now get 4 bytes ATR -> 32 bytes to send
   abSendBuffer[8]=CMUSB_CalcSynchControl(0,0,0,0, 0,1,0,0);
   RtlFillMemory((PVOID)&abSendBuffer[9],31,abSendBuffer[8]);

   //now set clock to low to finish operation
   //and of course additional fill bytes
   abSendBuffer[40]=CMUSB_CalcSynchControl(0,0,0,0, 0,0,0,0);
   RtlFillMemory((PVOID)&abSendBuffer[41],7,abSendBuffer[40]);

   // now send command type 08 to CardManUSB
   smartcardExtension->SmartcardRequest.BufferLength = 48;
   RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                (PVOID) abSendBuffer,
                smartcardExtension->SmartcardRequest.BufferLength);
   status = CMUSB_WriteP0(deviceObject,
                          0x08,         //bRequest,
                          0x00,         //bValueLo,
                          0x00,         //bValueHi,
                          0x00,         //bIndexLo,
                          0x00          //bIndexHi,
                         );
   if (status != STATUS_SUCCESS)
      {
      // if we can't write ATR command there must be a serious error
      if (status == STATUS_DEVICE_DATA_ERROR)
         {
         //error mapping necessary because there are CardManUSB
         //which have no support for synchronous cards
         status = STATUS_UNRECOGNIZED_MEDIA;
         }
      goto ExitPowerOnSynchronousCard;
      }

   status = CMUSB_ReadP1(deviceObject);
   if (status == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
      goto ExitPowerOnSynchronousCard;
      }
   else if (status != STATUS_SUCCESS)
      {
      // if we can't read the ATR -> there must be a serious error
      goto ExitPowerOnSynchronousCard;
      }

   if (smartcardExtension->SmartcardReply.BufferLength!=6)
      {
      // 48 bytes sent but not 6 bytes received
      // -> something went wrong
      status=STATUS_DEVICE_DATA_ERROR;
      goto ExitPowerOnSynchronousCard;
      }

   // now bytes 1-4 in SmartcardReply.Buffer should be ATR
   SmartcardDebug(DEBUG_ATR,
                  ("%s!ATR = %02x %02x %02x %02x\n",DRIVER_NAME,
                   smartcardExtension->SmartcardReply.Buffer[1],
                   smartcardExtension->SmartcardReply.Buffer[2],
                   smartcardExtension->SmartcardReply.Buffer[3],
                   smartcardExtension->SmartcardReply.Buffer[4]));

   // check if ATR != 0xFF -> synchronous card
   if (smartcardExtension->SmartcardReply.Buffer[1]==0xFF &&
       smartcardExtension->SmartcardReply.Buffer[2]==0xFF &&
       smartcardExtension->SmartcardReply.Buffer[3]==0xFF &&
       smartcardExtension->SmartcardReply.Buffer[4]==0xFF )
      {
      status = STATUS_UNRECOGNIZED_MEDIA;
      *pulATRLength = 0;
      goto ExitPowerOnSynchronousCard;
      }

   //it seems we have a synchronous smart card and a valid ATR
   //lets set the variables
   smartcardExtension->ReaderExtension->fRawModeNecessary = TRUE;
   *pulATRLength = 4;
   RtlCopyBytes((PVOID) pbATR,
                (PVOID) &(smartcardExtension->SmartcardReply.Buffer[1]),
                *pulATRLength );



   ExitPowerOnSynchronousCard:

   if (status!=STATUS_SUCCESS)
      {
      // turn off VCC again
      CMUSB_PowerOffCard (smartcardExtension );
      // ignor status
      }

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!PowerOnSynchronousCard: Exit %lx\n",DRIVER_NAME,status));

   return status;
}


/*****************************************************************************
Routine Description: Data transfer to synchronous cards SLE 4442/4432

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_Transmit2WBP  (
                    IN  PSMARTCARD_EXTENSION smartcardExtension
                    )
{
   PDEVICE_OBJECT deviceObject;
   NTSTATUS       status = STATUS_SUCCESS;
   NTSTATUS       DebugStatus;
   PCHAR          pbInData;
   ULONG          ulBytesToRead;
   ULONG          ulBitsToRead;
   ULONG          ulBytesToReadThisStep;
   ULONG          ulBytesRead;
   UCHAR          abSendBuffer[CMUSB_SYNCH_BUFFER_SIZE];
   int            i;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Transmit2WBP: Enter\n",DRIVER_NAME));


   deviceObject = smartcardExtension->OsData->DeviceObject;

   // resync CardManUSB by reading the status byte
   // still necessary with synchronous cards ???
   smartcardExtension->SmartcardRequest.BufferLength = 0;
   status = CMUSB_WriteP0(deviceObject,
                          0x20,         //bRequest,
                          0x00,         //bValueLo,
                          0x00,         //bValueHi,
                          0x00,         //bIndexLo,
                          0x00          //bIndexHi,
                         );

   if (status != STATUS_SUCCESS)
      {
      // if we can't read the status there must be a serious error
      goto ExitTransmit2WBP;
      }

   smartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
   status = CMUSB_ReadP1(deviceObject);
   if (status == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
      goto ExitTransmit2WBP;
      }
   else if (status != STATUS_SUCCESS)
      {
      // if we can't read the status there must be a serious error
      goto ExitTransmit2WBP;
      }

   // check if card is really inserted
   if (smartcardExtension->SmartcardReply.Buffer[0] == 0x00)
      {
      // it is not sure, which error messages are accepted
      // status = STATUS_NO_MEDIA_IN_DEVICE;
      status = STATUS_UNRECOGNIZED_MEDIA;
      goto ExitTransmit2WBP;
      }



   pbInData       = smartcardExtension->IoRequest.RequestBuffer + sizeof(SYNC_TRANSFER);
   ulBitsToRead   = ((PSYNC_TRANSFER)(smartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToRead;
   ulBytesToRead  = ulBitsToRead/8 + (ulBitsToRead % 8 ? 1 : 0);
//   ulBitsToWrite  = ((PSYNC_TRANSFER)(smartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToWrite;
//   ulBytesToWrite = ulBitsToWrite/8;

   if (smartcardExtension->IoRequest.ReplyBufferLength  < ulBytesToRead)
      {
      status = STATUS_BUFFER_OVERFLOW;
      goto ExitTransmit2WBP;
      }


   // send command
   status=CMUSB_SendCommand2WBP(smartcardExtension, pbInData);
   if (status != STATUS_SUCCESS)
      {
      // if we can't send the command -> proceeding is sensless
      goto ExitTransmit2WBP;
      }


   // now we have to differenciate, wheter card is in
   // outgoing data mode (after read command) or
   // in processing mode (after write/erase command)
   switch (*pbInData)
      {
      case SLE4442_READ:
      case SLE4442_READ_PROT_MEM:
      case SLE4442_READ_SEC_MEM:
         // outgoing data mode

         //now read data
         abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 0,1,0,0);
         RtlFillMemory((PVOID)&abSendBuffer[1],ATTR_MAX_IFSD_SYNCHRON_USB-1,abSendBuffer[0]);

         //read data in 6 byte packages
         ulBytesRead=0;
         do
            {
            if ((ulBytesToRead - ulBytesRead) > ATTR_MAX_IFSD_SYNCHRON_USB/8)
               ulBytesToReadThisStep = ATTR_MAX_IFSD_SYNCHRON_USB/8;
            else
               ulBytesToReadThisStep = ulBytesToRead - ulBytesRead;

            // now send command type 08 to CardManUSB
            smartcardExtension->SmartcardRequest.BufferLength = ulBytesToReadThisStep*8;
            RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                         (PVOID) abSendBuffer,
                         smartcardExtension->SmartcardRequest.BufferLength);
            status = CMUSB_WriteP0(deviceObject,
                                   0x08,         //bRequest,
                                   0x00,         //bValueLo,
                                   0x00,         //bValueHi,
                                   0x00,         //bIndexLo,
                                   0x00          //bIndexHi,
                                  );
            if (status != STATUS_SUCCESS)
               {
               // if we can't write command there must be a serious error
               goto ExitTransmit2WBP;
               }

            status = CMUSB_ReadP1(deviceObject);
            if (status == STATUS_DEVICE_DATA_ERROR)
               {
               DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
               goto ExitTransmit2WBP;
               }
            else if (status != STATUS_SUCCESS)
               {
               // if we can't read there must be a serious error
               goto ExitTransmit2WBP;
               }

            if (smartcardExtension->SmartcardReply.BufferLength!=ulBytesToReadThisStep)
               {
               // wrong number of bytes read
               // -> something went wrong
               status=STATUS_DEVICE_DATA_ERROR;
               goto ExitTransmit2WBP;
               }


            RtlCopyBytes((PVOID) &(smartcardExtension->IoRequest.ReplyBuffer[ulBytesRead]),
                         (PVOID) smartcardExtension->SmartcardReply.Buffer,
                         smartcardExtension->SmartcardReply.BufferLength);

            ulBytesRead+=smartcardExtension->SmartcardReply.BufferLength;
            }
         while ((status == STATUS_SUCCESS) && (ulBytesToRead > ulBytesRead));
         *(smartcardExtension->IoRequest.Information)=ulBytesRead;

         if (status!=STATUS_SUCCESS)
            {
            goto ExitTransmit2WBP;
            }

         // according to datasheet, clock should be set to low now
         // this is not necessary, because this is done before next command
         // or card is reseted respectivly

         break;
      case SLE4442_WRITE:
      case SLE4442_WRITE_PROT_MEM:
      case SLE4442_COMPARE_PIN:
      case SLE4442_UPDATE_SEC_MEM:
         // processing mode

         abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 0,1,0,0);
         RtlFillMemory((PVOID)&abSendBuffer[1],ATTR_MAX_IFSD_SYNCHRON_USB-1,abSendBuffer[0]);

         do
            {

            // now send command type 08 to CardManUSB
            smartcardExtension->SmartcardRequest.BufferLength = ATTR_MAX_IFSD_SYNCHRON_USB;
            RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                         (PVOID) abSendBuffer,
                         smartcardExtension->SmartcardRequest.BufferLength);
            status = CMUSB_WriteP0(deviceObject,
                                   0x08,         //bRequest,
                                   0x00,         //bValueLo,
                                   0x00,         //bValueHi,
                                   0x00,         //bIndexLo,
                                   0x00          //bIndexHi,
                                  );
            if (status != STATUS_SUCCESS)
               {
               // if we can't write command there must be a serious error
               goto ExitTransmit2WBP;
               }

            status = CMUSB_ReadP1(deviceObject);
            if (status == STATUS_DEVICE_DATA_ERROR)
               {
               DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
               goto ExitTransmit2WBP;
               }
            else if (status != STATUS_SUCCESS)
               {
               // if we can't read there must be a serious error
               goto ExitTransmit2WBP;
               }

            if (smartcardExtension->SmartcardReply.BufferLength!=ATTR_MAX_IFSD_SYNCHRON_USB/8)
               {
               // wrong number of bytes read
               // -> something went wrong
               status=STATUS_DEVICE_DATA_ERROR;
               goto ExitTransmit2WBP;
               }

            /* not necessary this way, check last byte only
            ulReplySum=0;
            for (i=0;i<(int)smartcardExtension->SmartcardReply.BufferLength;i++)
               {
               ulReplySum+=smartcardExtension->SmartcardReply.Buffer[i];
               }
            */
            }
         while ((status == STATUS_SUCCESS) &&
                (smartcardExtension->SmartcardReply.Buffer[smartcardExtension->SmartcardReply.BufferLength-1]==0));
         *(smartcardExtension->IoRequest.Information)=0;

         if (status!=STATUS_SUCCESS)
            {
            goto ExitTransmit2WBP;
            }

         // according to datasheet, clock should be set to low now
         // this is not necessary, because this is done before next command
         // or card is reseted respectivly


         break;
      default:
         // should not happen
         status=STATUS_ILLEGAL_INSTRUCTION;
         goto ExitTransmit2WBP;
      }

   ExitTransmit2WBP:


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Transmit2WBP: Exit %lx\n",DRIVER_NAME,status));

   return status;
}


/*****************************************************************************
Routine Description: Transmits a command (3 Bytes) to a SLE 4442/4432

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_SendCommand2WBP (
                      IN  PSMARTCARD_EXTENSION smartcardExtension,
                      IN  PUCHAR pbCommandData
                      )
{
   PDEVICE_OBJECT deviceObject;
   NTSTATUS       status = STATUS_SUCCESS;
   NTSTATUS       DebugStatus;
   UCHAR          abSendBuffer[CMUSB_SYNCH_BUFFER_SIZE];
   UCHAR*         pByte;
   UCHAR          bValue;
   int            i,j;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SendCommand2WBP: Enter\n",DRIVER_NAME));

   SmartcardDebug(DEBUG_PROTOCOL,
                  ("%s!SendCommand2WBP: 4442 Command = %02x %02x %02x\n",DRIVER_NAME,
                   pbCommandData[0],
                   pbCommandData[1],
                   pbCommandData[2]));

   deviceObject = smartcardExtension->OsData->DeviceObject;

   // build control code for command to send
   // command is in first 3 Bytes of pbInData
   abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 0,0,0,0);
   abSendBuffer[1]=CMUSB_CalcSynchControl(0,0,1,1, 0,1,1,1);
   abSendBuffer[2]=CMUSB_CalcSynchControl(0,1,1,0, 0,1,1,0);

   pByte=&abSendBuffer[3];
   for (j=0;j<3;j++)
      {
      for (i=0;i<8;i++)
         {
         bValue=(pbCommandData[j]&(1<<i));
         *pByte=CMUSB_CalcSynchControl(0,0,1,bValue, 0,1,1,bValue);
         pByte++;
         }
      }
   abSendBuffer[27]=CMUSB_CalcSynchControl(0,0,1,0, 0,1,1,0);
   abSendBuffer[28]=CMUSB_CalcSynchControl(0,1,1,0, 0,1,1,0);
   RtlFillMemory((PVOID)&abSendBuffer[29],2,abSendBuffer[28]);
   abSendBuffer[31]=CMUSB_CalcSynchControl(0,1,1,0, 0,1,1,1);

   // now send command type 08 to CardManUSB
   smartcardExtension->SmartcardRequest.BufferLength = 32;
   RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                (PVOID) abSendBuffer,
                smartcardExtension->SmartcardRequest.BufferLength);
   status = CMUSB_WriteP0(deviceObject,
                          0x08,         //bRequest,
                          0x00,         //bValueLo,
                          0x00,         //bValueHi,
                          0x00,         //bIndexLo,
                          0x00          //bIndexHi,
                         );
   if (status != STATUS_SUCCESS)
      {
      // if we can't write command there must be a serious error
      goto ExitSendCommand2WBP;
      }

   status = CMUSB_ReadP1(deviceObject);
   if (status == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
      goto ExitSendCommand2WBP;
      }
   else if (status != STATUS_SUCCESS)
      {
      // if we can't read there must be a serious error
      goto ExitSendCommand2WBP;
      }

   if (smartcardExtension->SmartcardReply.BufferLength!=4)
      {
      // 32 bytes sent but not 4 bytes received
      // -> something went wrong
      status=STATUS_DEVICE_DATA_ERROR;
      goto ExitSendCommand2WBP;
      }


   ExitSendCommand2WBP:

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SendCommand2WBP: Exit %lx\n",DRIVER_NAME,status));

   return status;
}


/*****************************************************************************
Routine Description: Data transfer to synchronous cards SLE 4428/4418

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_Transmit3WBP  (
                    IN  PSMARTCARD_EXTENSION smartcardExtension
                    )
{
   PDEVICE_OBJECT deviceObject;
   NTSTATUS       status = STATUS_SUCCESS;
   NTSTATUS       DebugStatus;
   PCHAR          pbInData;
   ULONG          ulBytesToRead;
   ULONG          ulBitsToRead;
   ULONG          ulBytesToReadThisStep;
   ULONG          ulBytesRead;
   UCHAR          abSendBuffer[CMUSB_SYNCH_BUFFER_SIZE];
   int            i;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Transmit3WBP: Enter\n",DRIVER_NAME));


   deviceObject = smartcardExtension->OsData->DeviceObject;

   // resync CardManUSB by reading the status byte
   // still necessary with synchronous cards ???
   smartcardExtension->SmartcardRequest.BufferLength = 0;
   status = CMUSB_WriteP0(deviceObject,
                          0x20,         //bRequest,
                          0x00,         //bValueLo,
                          0x00,         //bValueHi,
                          0x00,         //bIndexLo,
                          0x00          //bIndexHi,
                         );

   if (status != STATUS_SUCCESS)
      {
      // if we can't read the status there must be a serious error
      goto ExitTransmit3WBP;
      }

   smartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
   status = CMUSB_ReadP1(deviceObject);
   if (status == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
      goto ExitTransmit3WBP;
      }
   else if (status != STATUS_SUCCESS)
      {
      // if we can't read the status there must be a serious error
      goto ExitTransmit3WBP;
      }

   // check if card is really inserted
   if (smartcardExtension->SmartcardReply.Buffer[0] == 0x00)
      {
      // it is not sure, which error messages are accepted
      // status = STATUS_NO_MEDIA_IN_DEVICE;
      status = STATUS_UNRECOGNIZED_MEDIA;
      goto ExitTransmit3WBP;
      }



   pbInData       = smartcardExtension->IoRequest.RequestBuffer + sizeof(SYNC_TRANSFER);
   ulBitsToRead   = ((PSYNC_TRANSFER)(smartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToRead;
   ulBytesToRead  = ulBitsToRead/8 + (ulBitsToRead % 8 ? 1 : 0);
//   ulBitsToWrite  = ((PSYNC_TRANSFER)(smartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToWrite;
//   ulBytesToWrite = ulBitsToWrite/8;

   if (smartcardExtension->IoRequest.ReplyBufferLength  < ulBytesToRead)
      {
      status = STATUS_BUFFER_OVERFLOW;
      goto ExitTransmit3WBP;
      }


   // send command
   status=CMUSB_SendCommand3WBP(smartcardExtension, pbInData);
   if (status != STATUS_SUCCESS)
      {
      // if we can't send the command -> proceeding is useless
      goto ExitTransmit3WBP;
      }


   // now we have to differenciate, wheter card is in
   // outgoing data mode (after read command) or
   // in processing mode (after write/erase command)
   switch (*pbInData & 0x3F)
      {
      case SLE4428_READ:
      case SLE4428_READ_PROT:
         // outgoing data mode

         //now read data
         abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 0,1,0,0);
         RtlFillMemory((PVOID)&abSendBuffer[1],ATTR_MAX_IFSD_SYNCHRON_USB-1,abSendBuffer[0]);

         //read data in 6 byte packages
         ulBytesRead=0;
         do
            {
            if ((ulBytesToRead - ulBytesRead) > ATTR_MAX_IFSD_SYNCHRON_USB/8)
               ulBytesToReadThisStep = ATTR_MAX_IFSD_SYNCHRON_USB/8;
            else
               ulBytesToReadThisStep = ulBytesToRead - ulBytesRead;

            // now send command type 08 to CardManUSB
            smartcardExtension->SmartcardRequest.BufferLength = ulBytesToReadThisStep*8;
            RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                         (PVOID) abSendBuffer,
                         smartcardExtension->SmartcardRequest.BufferLength);
            status = CMUSB_WriteP0(deviceObject,
                                   0x08,         //bRequest,
                                   0x00,         //bValueLo,
                                   0x00,         //bValueHi,
                                   0x00,         //bIndexLo,
                                   0x00          //bIndexHi,
                                  );
            if (status != STATUS_SUCCESS)
               {
               // if we can't write command there must be a serious error
               goto ExitTransmit3WBP;
               }

            status = CMUSB_ReadP1(deviceObject);
            if (status == STATUS_DEVICE_DATA_ERROR)
               {
               DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
               goto ExitTransmit3WBP;
               }
            else if (status != STATUS_SUCCESS)
               {
               // if we can't read there must be a serious error
               goto ExitTransmit3WBP;
               }

            if (smartcardExtension->SmartcardReply.BufferLength!=ulBytesToReadThisStep)
               {
               // wrong number of bytes read
               // -> something went wrong
               status=STATUS_DEVICE_DATA_ERROR;
               goto ExitTransmit3WBP;
               }


            RtlCopyBytes((PVOID) &(smartcardExtension->IoRequest.ReplyBuffer[ulBytesRead]),
                         (PVOID) smartcardExtension->SmartcardReply.Buffer,
                         smartcardExtension->SmartcardReply.BufferLength);

            ulBytesRead+=smartcardExtension->SmartcardReply.BufferLength;
            }
         while ((status == STATUS_SUCCESS) && (ulBytesToRead > ulBytesRead));
         *(smartcardExtension->IoRequest.Information)=ulBytesRead;

         if (status!=STATUS_SUCCESS)
            {
            goto ExitTransmit3WBP;
            }

         // according to datasheet, clock should be set to low now
         // this is not necessary, because this is done before next command
         // or card is reseted respectivly

         break;
      case SLE4428_WRITE:
      case SLE4428_WRITE_PROT:
      case SLE4428_COMPARE:
      case SLE4428_SET_COUNTER&0x3F:
      case SLE4428_COMPARE_PIN&0x3F:
         // processing mode

         abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 0,1,0,0);
         RtlFillMemory((PVOID)&abSendBuffer[1],ATTR_MAX_IFSD_SYNCHRON_USB-1,abSendBuffer[0]);

         do
            {

            // now send command type 08 to CardManUSB
            smartcardExtension->SmartcardRequest.BufferLength = ATTR_MAX_IFSD_SYNCHRON_USB;
            RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                         (PVOID) abSendBuffer,
                         smartcardExtension->SmartcardRequest.BufferLength);
            status = CMUSB_WriteP0(deviceObject,
                                   0x08,         //bRequest,
                                   0x00,         //bValueLo,
                                   0x00,         //bValueHi,
                                   0x00,         //bIndexLo,
                                   0x00          //bIndexHi,
                                  );
            if (status != STATUS_SUCCESS)
               {
               // if we can't write command there must be a serious error
               goto ExitTransmit3WBP;
               }

            status = CMUSB_ReadP1(deviceObject);
            if (status == STATUS_DEVICE_DATA_ERROR)
               {
               DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
               goto ExitTransmit3WBP;
               }
            else if (status != STATUS_SUCCESS)
               {
               // if we can't read there must be a serious error
               goto ExitTransmit3WBP;
               }

            if (smartcardExtension->SmartcardReply.BufferLength!=ATTR_MAX_IFSD_SYNCHRON_USB/8)
               {
               // wrong number of bytes read
               // -> something went wrong
               status=STATUS_DEVICE_DATA_ERROR;
               goto ExitTransmit3WBP;
               }

            }
         while ((status == STATUS_SUCCESS) &&
                (smartcardExtension->SmartcardReply.Buffer[smartcardExtension->SmartcardReply.BufferLength-1]==0xFF));
         *(smartcardExtension->IoRequest.Information)=0;

         if (status!=STATUS_SUCCESS)
            {
            goto ExitTransmit3WBP;
            }

         // according to datasheet, clock should be set to low now
         // this is not necessary, because this is done before next command
         // or card is reseted respectivly


         break;
      default:
         // should not happen
         status=STATUS_ILLEGAL_INSTRUCTION;
         goto ExitTransmit3WBP;
      }

   ExitTransmit3WBP:


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Transmit3WBP: Exit %lx\n",DRIVER_NAME,status));

   return status;
}


/*****************************************************************************
Routine Description: Transmits a command (3 Bytes) to a SLE 4428/4418

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_SendCommand3WBP (
                      IN  PSMARTCARD_EXTENSION smartcardExtension,
                      IN  PUCHAR pbCommandData
                      )
{
   PDEVICE_OBJECT deviceObject;
   NTSTATUS       status = STATUS_SUCCESS;
   NTSTATUS       DebugStatus;
   UCHAR          abSendBuffer[CMUSB_SYNCH_BUFFER_SIZE];
   UCHAR*         pByte;
   UCHAR          bValue;
   int            i,j;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SendCommand3WBP: Enter\n",DRIVER_NAME));

   SmartcardDebug(DEBUG_PROTOCOL,
                  ("%s!SendCommand3WBP: 4442 Command = %02x %02x %02x\n",DRIVER_NAME,
                   pbCommandData[0],
                   pbCommandData[1],
                   pbCommandData[2]));

   deviceObject = smartcardExtension->OsData->DeviceObject;

   // build control code for command to send
   // command is in first 3 Bytes of pbInData
   abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 0,0,0,0);

   pByte=&abSendBuffer[1];
   for (j=0;j<3;j++)
      {
      for (i=0;i<8;i++)
         {
         bValue=(pbCommandData[j]&(1<<i));
         *pByte=CMUSB_CalcSynchControl(1,0,1,bValue, 1,1,1,bValue);
         pByte++;
         }
      }
   abSendBuffer[25]=CMUSB_CalcSynchControl(1,0,1,0, 0,0,0,0);
   // one additional clock cycle, because
   // first bit is only read back after second clock
   // for write it has no influence
   abSendBuffer[26]=CMUSB_CalcSynchControl(0,0,0,0, 0,1,0,0);
   // fill rest with zeros
   abSendBuffer[27]=CMUSB_CalcSynchControl(0,0,0,0, 0,0,0,0);
   RtlFillMemory((PVOID)&abSendBuffer[28],4,abSendBuffer[27]);

   // now send command type 08 to CardManUSB
   smartcardExtension->SmartcardRequest.BufferLength = 32;
   RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                (PVOID) abSendBuffer,
                smartcardExtension->SmartcardRequest.BufferLength);
   status = CMUSB_WriteP0(deviceObject,
                          0x08,         //bRequest,
                          0x00,         //bValueLo,
                          0x00,         //bValueHi,
                          0x00,         //bIndexLo,
                          0x00          //bIndexHi,
                         );
   if (status != STATUS_SUCCESS)
      {
      // if we can't write command there must be a serious error
      goto ExitSendCommand3WBP;
      }

   status = CMUSB_ReadP1(deviceObject);
   if (status == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
      goto ExitSendCommand3WBP;
      }
   else if (status != STATUS_SUCCESS)
      {
      // if we can't read there must be a serious error
      goto ExitSendCommand3WBP;
      }

   if (smartcardExtension->SmartcardReply.BufferLength!=4)
      {
      // 32 bytes sent but not 4 bytes received
      // -> something went wrong
      status=STATUS_DEVICE_DATA_ERROR;
      goto ExitSendCommand3WBP;
      }


   ExitSendCommand3WBP:

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SendCommand3WBP: Exit %lx\n",DRIVER_NAME,status));

   return status;
}


/*****************************************************************************
* History:
* $Log: scusbsyn.c $
* Revision 1.3  2000/08/24 09:04:39  TBruendl
* No comment given
*
* Revision 1.2  2000/07/24 11:35:00  WFrischauf
* No comment given
*
* Revision 1.1  2000/07/20 11:50:16  WFrischauf
* No comment given
*
*
******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\serialif.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       serialif.h
//
//--------------------------------------------------------------------------

#if !defined( __SERIAL_IF_H__ )
#define __SERIAL_IF_H__

#if defined( SMCLIB_VXD )
#include "Driver98.h"
#else
#include "DriverNT.h"
#endif

typedef void ( *PTRACKING_COMPLETION )( PVOID TrackingContext, USHORT SW );

NTSTATUS
IFRead(
	PREADER_EXTENSION		ReaderExtension,
	PUCHAR					InData,
	ULONG					InDataLen
	);

NTSTATUS
IFWrite(
	PREADER_EXTENSION		ReaderExtension,
	PUCHAR					OutData,
	ULONG					OutDataLen
	);

NTSTATUS
IFInitializeInterface(
	PREADER_EXTENSION		ReaderExtension,
	PVOID					ConfigData
	);

UCHAR
IFCalcLRC(
	PUCHAR	IOData,
	ULONG	IODataLen
	);

#endif	//	!__SERIAL_IF_H__


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\drvnt5.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       drvnt5.h
//
//--------------------------------------------------------------------------

#if !defined( __DRIVER_NT5_H__ )
#define __DRIVER_NT5_H__

#define MAXIMUM_SERIAL_READERS      10

// Prototypes
NTSTATUS
DrvAddDevice(
    PDRIVER_OBJECT          DriverObject,
    PDEVICE_OBJECT          PhysicalDeviceObject
    );


NTSTATUS
DrvCreateDevice(
    PDRIVER_OBJECT          DriverObject,
    PDEVICE_OBJECT          *DeviceObject
    );

NTSTATUS
DrvStartDevice(
    PDEVICE_OBJECT          DeviceObject
    );

VOID
DrvStopDevice(
    PDEVICE_EXTENSION       DeviceExtension
    );

VOID 
DrvCloseSerialDriver(
    PDEVICE_OBJECT          DeviceObject
    );

NTSTATUS
DrvSerialCallComplete(
    PDEVICE_OBJECT          DeviceObject,
    PIRP                    Irp,
    PKEVENT                 Event
    );

NTSTATUS 
DrvCallSerialDriver(
    IN PDEVICE_OBJECT       DeviceObject, 
    IN PIRP                 Irp
    );

NTSTATUS
DrvSystemControl(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
DrvGenericIOCTL(
    PSMARTCARD_EXTENSION    SmartcardExtension
    );

NTSTATUS
DrvPnPHandler(
    PDEVICE_OBJECT          DeviceObject, 
    PIRP                    Irp
    );

NTSTATUS
DrvPowerHandler(
    PDEVICE_OBJECT          DeviceObject,
    PIRP                    Irp
    );

NTSTATUS
DrvCreateClose(
    PDEVICE_OBJECT          DeviceObject,
    PIRP                    Irp
    );

NTSTATUS
DrvCleanup(
    PDEVICE_OBJECT          DeviceObject,
    PIRP                    Irp
    );

VOID
DrvRemoveDevice( 
    PDEVICE_OBJECT          DeviceObject
    );

VOID
DrvDriverUnload(
    PDRIVER_OBJECT          DriverObject
    );

VOID 
DrvWaitForDeviceRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

#endif  //  !__DRIVER_NT5_H__


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\sccmusbm\scusbwdm.c ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmeu0/sw/sccmusbm.ms/rcs/scusbwdm.c $
* $Revision: 1.9 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/



#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usbdi.h"
#include "usbdlib.h"
#include "sccmusbm.h"

BOOLEAN DeviceSlot[MAXIMUM_USB_READERS];

STRING   OemName[MAXIMUM_OEM_NAMES];
CHAR     OemNameBuffer[MAXIMUM_OEM_NAMES][64];
BOOLEAN  OemDeviceSlot[MAXIMUM_OEM_NAMES][MAXIMUM_USB_READERS];


/*****************************************************************************
Routine Description:

Arguments:


Return Value:

*****************************************************************************/
PURB CMUSB_BuildAsyncRequest(
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp,
                            IN PUSBD_PIPE_INFORMATION PipeHandle
                            )
{
   ULONG siz;
   ULONG length;
   PURB urb = NULL;
   PDEVICE_EXTENSION DeviceExtension;
   PUSBD_INTERFACE_INFORMATION interface;
   PUSBD_PIPE_INFORMATION pipeHandle = NULL;
   PSMARTCARD_EXTENSION SmartcardExtension;


   siz = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
   urb = ExAllocatePool(NonPagedPool, siz);

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;


   if (urb != NULL)
      {
      RtlZeroMemory(urb, siz);

      urb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT) siz;
      urb->UrbBulkOrInterruptTransfer.Hdr.Function =
      URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
      urb->UrbBulkOrInterruptTransfer.PipeHandle =
      PipeHandle->PipeHandle;
      urb->UrbBulkOrInterruptTransfer.TransferFlags =
      USBD_TRANSFER_DIRECTION_IN;

      // short packet is not treated as an error.
      urb->UrbBulkOrInterruptTransfer.TransferFlags |=
      USBD_SHORT_TRANSFER_OK;

      //
      // not using linked urb's
      //
      urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

      urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;

      urb->UrbBulkOrInterruptTransfer.TransferBufferLength =
      SmartcardExtension->SmartcardReply.BufferLength;

      urb->UrbBulkOrInterruptTransfer.TransferBuffer =
      SmartcardExtension->SmartcardReply.Buffer;

      }


   return urb;
}


/*****************************************************************************
Routine Description:

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS CMUSB_AsyncReadComplete(
                                IN PDEVICE_OBJECT DeviceObject,
                                IN PIRP Irp,
                                IN PVOID Context
                                )
{
   PURB                 urb;
   PCMUSB_RW_CONTEXT context = Context;
   PIO_STACK_LOCATION   irpStack;
   PDEVICE_OBJECT       deviceObject;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;

   urb = context->Urb;
   deviceObject = context->DeviceObject;
   DeviceExtension = deviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   //
   // set the length based on the TransferBufferLength
   // value in the URB
   //
   if (Irp->IoStatus.Status  == STATUS_SUCCESS)
      {
      SmartcardExtension->SmartcardReply.BufferLength = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
      SmartcardExtension->ReaderExtension->fP1Stalled = FALSE;
      }
   else
      {
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!Irp->IoStatus.Status = %lx\n",DRIVER_NAME,Irp->IoStatus.Status));

      SmartcardExtension->SmartcardReply.BufferLength = 0;
      SmartcardExtension->ReaderExtension->fP1Stalled = TRUE;
      }


   SmartcardExtension->SmartcardReply.BufferLength = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;


   CMUSB_DecrementIoCount(deviceObject);


   ExFreePool(context);
   ExFreePool(urb);
   IoFreeIrp(Irp);

   /*
   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!AsyncReadWriteComplete <%ld>\n",
                   DRIVER_NAME,SmartcardExtension->SmartcardReply.BufferLength)
                 );
   */
   KeSetEvent(&DeviceExtension->ReadP1Completed,0,FALSE);

   return STATUS_MORE_PROCESSING_REQUIRED;
}



/*****************************************************************************
Routine Description:

Arguments:


Return Value:
        NT NTStatus

*****************************************************************************/
#define TIMEOUT_P1_RESPONSE       100
NTSTATUS CMUSB_ReadP1(
                     IN PDEVICE_OBJECT DeviceObject
                     )
{
   NTSTATUS NTStatus;
   NTSTATUS DebugStatus;
   PIO_STACK_LOCATION nextStack;
   PURB urb;
   PCMUSB_RW_CONTEXT context = NULL;
   PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   PUSBD_INTERFACE_INFORMATION interface;
   PUSBD_PIPE_INFORMATION pipeHandle = NULL;
   CHAR cStackSize;
   PIRP IrpToUSB = NULL;
   ULONG ulBytesToRead;
   ULONG i;
   LARGE_INTEGER   liTimeoutP1;
   LARGE_INTEGER   liTimeoutP1Response;
   BOOLEAN         fStateTimer;
   UCHAR           bTmp;
   LONG            lNullPackets;
   BOOLEAN         fCancelTimer = FALSE;

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadP1: Enter\n",DRIVER_NAME)
                 );
   */

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;
   interface       = DeviceExtension->UsbInterface;
   pipeHandle      =  &interface->Pipes[0];
   if (pipeHandle == NULL)
      {
      NTStatus = STATUS_INVALID_HANDLE;
      goto ExitCMUSB_ReadP1;
      }




   liTimeoutP1 = RtlConvertLongToLargeInteger(SmartcardExtension->ReaderExtension->ulTimeoutP1 * -10000);
   KeSetTimer(&SmartcardExtension->ReaderExtension->P1Timer,
              liTimeoutP1,
              NULL);
   fCancelTimer = TRUE;


   // we will always read a whole packet (== 8 bytes)
   ulBytesToRead = 8;

   cStackSize = (CCHAR)(DeviceExtension->TopOfStackDeviceObject->StackSize+1);

   lNullPackets = -1;
   do
      {
      fStateTimer = KeReadStateTimer(&SmartcardExtension->ReaderExtension->P1Timer);
      if (fStateTimer == TRUE)
         {
         fCancelTimer = FALSE;
         NTStatus = STATUS_IO_TIMEOUT;
         SmartcardExtension->SmartcardReply.BufferLength = 0L;
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s!Timeout (%ld)while reading from P1\n",
                         DRIVER_NAME,SmartcardExtension->ReaderExtension->ulTimeoutP1)
                       );
         break;
         }



      SmartcardExtension->SmartcardReply.BufferLength = ulBytesToRead;

      IrpToUSB = IoAllocateIrp(cStackSize,FALSE);
      if (IrpToUSB==NULL)
         {
         SmartcardExtension->SmartcardReply.BufferLength = 0L;
         NTStatus = STATUS_INSUFFICIENT_RESOURCES;
         goto ExitCMUSB_ReadP1;
         }


      urb = CMUSB_BuildAsyncRequest(DeviceObject,
                                    IrpToUSB,
                                    pipeHandle
                                   );


      if (urb != NULL)
         {
         context = ExAllocatePool(NonPagedPool, sizeof(CMUSB_RW_CONTEXT));
         }

      if (urb != NULL && context != NULL)
         {
         context->Urb = urb;
         context->DeviceObject = DeviceObject;
         context->Irp =  IrpToUSB;

         nextStack = IoGetNextIrpStackLocation(IrpToUSB);
         ASSERT(nextStack != NULL);
         ASSERT(DeviceObject->StackSize>1);

         nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
         nextStack->Parameters.Others.Argument1 = urb;
         nextStack->Parameters.DeviceIoControl.IoControlCode =
         IOCTL_INTERNAL_USB_SUBMIT_URB;


         IoSetCompletionRoutine(IrpToUSB,
                                CMUSB_AsyncReadComplete,
                                context,
                                TRUE,
                                TRUE,
                                TRUE);


         ASSERT(DeviceExtension->TopOfStackDeviceObject);
         ASSERT(IrpToUSB);


         KeClearEvent(&DeviceExtension->ReadP1Completed);

         CMUSB_IncrementIoCount(DeviceObject);

         NTStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject,
                                 IrpToUSB);


         liTimeoutP1Response = RtlConvertLongToLargeInteger(TIMEOUT_P1_RESPONSE * -10000);


         NTStatus = KeWaitForSingleObject(&DeviceExtension->ReadP1Completed,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          &liTimeoutP1Response);
         if (NTStatus == STATUS_TIMEOUT)
            {
            // probably the device has been removed
            // there must be at least a null packet received during liTimeoutReponse
            SmartcardExtension->SmartcardReply.BufferLength = 0L;
            break;
            }

         // -----------------------------
         // check if P1 has been stalled
         // -----------------------------
         if (SmartcardExtension->ReaderExtension->fP1Stalled == TRUE)
            {
            break;
            }
         }
      else
         {
         if (urb != NULL) {

             ExFreePool(urb);

         }
         if (IrpToUSB != NULL) {
             IoFreeIrp(IrpToUSB);
         }
         SmartcardExtension->SmartcardReply.BufferLength = 0L;
         NTStatus = STATUS_INSUFFICIENT_RESOURCES;
         break;
         }


      lNullPackets++;
      } while (SmartcardExtension->SmartcardReply.BufferLength == 0L);



   // -----------------------------
   // check if P1 has been stalled
   // -----------------------------
   if (SmartcardExtension->ReaderExtension->fP1Stalled == TRUE)
      {
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!P1 stalled \n",DRIVER_NAME));
      NTStatus = STATUS_DEVICE_DATA_ERROR;

      // wait to be sure that we have a stable card state
      CMUSB_Wait (50);

      // P1 has been stalled ==> we must reset the pipe and send a NTStatus to enable it again
      DebugStatus = CMUSB_ResetPipe(DeviceObject,pipeHandle);

      }
   else
      {
      // if no bytes have been received , NTStatus has already been set
      // to STATUS_TIMEOUT
      if (SmartcardExtension->SmartcardReply.BufferLength > 0 )
         {
         NTStatus = STATUS_SUCCESS;

#if DBG
         SmartcardDebug(DEBUG_PROTOCOL,("%s!<==[P1] <%ld> ",DRIVER_NAME,lNullPackets));

         for (i=0;i< SmartcardExtension->SmartcardReply.BufferLength;i++)
            {
            bTmp =  SmartcardExtension->SmartcardReply.Buffer[i];
            if (SmartcardExtension->ReaderExtension->fInverseAtr &&
                SmartcardExtension->ReaderExtension->ulTimeoutP1 != DEFAULT_TIMEOUT_P1)
               {
               //CMUSB_InverseBuffer(&bTmp,1);
               SmartcardDebug(DEBUG_PROTOCOL,("%x ",bTmp));
               }
            else
               {
               SmartcardDebug(DEBUG_PROTOCOL,("%x ",bTmp));
               }
            }

         SmartcardDebug(DEBUG_PROTOCOL,("(%ld)\n",SmartcardExtension->SmartcardReply.BufferLength));
#endif

         }
      }



   ExitCMUSB_ReadP1:
   if (fCancelTimer == TRUE)
      {
      // cancel timer
      // TRUE if the timer is in the queue
      // FALSE if the timer is not in queue
      KeCancelTimer(&SmartcardExtension->ReaderExtension->P1Timer);
      }

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadP1: Exit %lx\n",DRIVER_NAME,NTStatus));
   */

   return NTStatus;

}


/*****************************************************************************
Routine Description:

Arguments:


Return Value:
        NT NTStatus

*****************************************************************************/
NTSTATUS CMUSB_ReadP1_T0(
                        IN PDEVICE_OBJECT DeviceObject
                        )
{
   NTSTATUS NTStatus;
   PIO_STACK_LOCATION nextStack;
   PURB urb;
   PCMUSB_RW_CONTEXT context = NULL;
   PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   PUSBD_INTERFACE_INFORMATION interface;
   PUSBD_PIPE_INFORMATION pipeHandle = NULL;
   CHAR cStackSize;
   PIRP IrpToUSB = NULL;
   ULONG ulBytesToRead;

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadP1_T0: Enter\n",DRIVER_NAME));
   */


   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;
   interface       = DeviceExtension->UsbInterface;
   pipeHandle      =  &interface->Pipes[0];
   if (pipeHandle == NULL)
      {
      NTStatus = STATUS_INVALID_HANDLE;
      goto ExitCMUSB_ReadP1;
      }


   ulBytesToRead = SmartcardExtension->SmartcardReply.BufferLength;
   cStackSize = (CCHAR)(DeviceExtension->TopOfStackDeviceObject->StackSize+1);


   IrpToUSB = IoAllocateIrp(cStackSize,FALSE);
   if (IrpToUSB==NULL)
      {
      SmartcardExtension->SmartcardReply.BufferLength = 0L;
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      goto ExitCMUSB_ReadP1;
      }

   urb = CMUSB_BuildAsyncRequest(DeviceObject,IrpToUSB,pipeHandle);

   if (urb != NULL)
      {
      context = ExAllocatePool(NonPagedPool, sizeof(CMUSB_RW_CONTEXT));
      }

   if (urb != NULL && context != NULL)
      {
      context->Urb = urb;
      context->DeviceObject = DeviceObject;
      context->Irp =  IrpToUSB;

      nextStack = IoGetNextIrpStackLocation(IrpToUSB);
      ASSERT(nextStack != NULL);
      ASSERT(DeviceObject->StackSize>1);

      nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
      nextStack->Parameters.Others.Argument1 = urb;
      nextStack->Parameters.DeviceIoControl.IoControlCode =
      IOCTL_INTERNAL_USB_SUBMIT_URB;


      IoSetCompletionRoutine(IrpToUSB,
                             CMUSB_AsyncReadComplete,
                             context,
                             TRUE,
                             TRUE,
                             TRUE);


      ASSERT(DeviceExtension->TopOfStackDeviceObject);
      ASSERT(IrpToUSB);


      KeClearEvent(&DeviceExtension->ReadP1Completed);

      CMUSB_IncrementIoCount(DeviceObject);
      NTStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject,
                              IrpToUSB);
      if (NTStatus == STATUS_PENDING)
         NTStatus = STATUS_SUCCESS;

      }
   else
      {
       if (urb != NULL) {
           ExFreePool(urb);
       }
       if (IrpToUSB != NULL) {
           IoFreeIrp(IrpToUSB);
       }
      SmartcardExtension->SmartcardReply.BufferLength = 0L;
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      }



   ExitCMUSB_ReadP1:
   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadP1_T0: Exit %lx\n",DRIVER_NAME,NTStatus));
   */
   return NTStatus;

}



/*****************************************************************************
Routine Description:

    Dispatch table routine for IRP_MJ_PNP.
    Process the Plug and Play IRPs sent to this device.

Arguments:

    DeviceObject - pointer to our FDO (Functional Device Object)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS CMUSB_ProcessPnPIrp(
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP           Irp
                            )
{
   PIO_STACK_LOCATION irpStack;
   PDEVICE_EXTENSION DeviceExtension;
   NTSTATUS NTStatus = STATUS_SUCCESS;
   NTSTATUS waitStatus;
   NTSTATUS DebugStatus;
   PDEVICE_OBJECT stackDeviceObject;
   KEVENT startDeviceEvent;
   PDEVICE_CAPABILITIES DeviceCapabilities;
   KEVENT               event;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ProcessPnPIrp: Enter\n",DRIVER_NAME));

   //
   // Get a pointer to the device extension
   //
   DeviceExtension = DeviceObject->DeviceExtension;
   stackDeviceObject = DeviceExtension->TopOfStackDeviceObject;

   //
   // Acquire remove lock,
   // so that device can not be removed while
   // this function is executed
   //
   NTStatus = SmartcardAcquireRemoveLock(&DeviceExtension->SmartcardExtension);
   ASSERT(NTStatus == STATUS_SUCCESS);
   if (NTStatus != STATUS_SUCCESS)
      {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = NTStatus;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return NTStatus;
      }

   //
   // Get a pointer to the current location in the Irp. This is where
   // the function codes and parameters are located.
   //
   irpStack = IoGetCurrentIrpStackLocation (Irp);

   // inc the FDO device extension's pending IO count for this Irp
   CMUSB_IncrementIoCount(DeviceObject);

   CMUSB_ASSERT( IRP_MJ_PNP == irpStack->MajorFunction );

   switch (irpStack->MinorFunction)
      {
      // ---------------------
      // IRP_MN_START_DEVICE
      // ---------------------
      case IRP_MN_START_DEVICE:
         // The PnP Manager sends this IRP after it has assigned resources,
         // if any, to the device. The device may have been recently enumerated
         // and is being started for the first time, or the device may be
         // restarting after being stopped for resource reconfiguration.

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_START_DEVICE received\n",DRIVER_NAME));

         // Initialize an event we can wait on for the PDO to be done with this irp
         KeInitializeEvent(&startDeviceEvent, NotificationEvent, FALSE);
         IoCopyCurrentIrpStackLocationToNext(Irp);

         // Set a completion routine so it can signal our event when
         // the PDO is done with the Irp
         IoSetCompletionRoutine(Irp,
                                CMUSB_IrpCompletionRoutine,
                                &startDeviceEvent,  // pass the event to the completion routine as the Context
                                TRUE,    // invoke on success
                                TRUE,    // invoke on error
                                TRUE);   // invoke on cancellation


         // let the PDO process the IRP
         NTStatus = IoCallDriver(stackDeviceObject,Irp);

         // if PDO is not done yet, wait for the event to be set in our completion routine
         if (NTStatus == STATUS_PENDING)
            {
            // wait for irp to complete

            waitStatus = KeWaitForSingleObject(&startDeviceEvent,
                                               Suspended,
                                               KernelMode,
                                               FALSE,
                                               NULL);

            NTStatus = Irp->IoStatus.Status;
            }

         if (NT_SUCCESS(NTStatus))
            {
            // Now we're ready to do our own startup processing.
            // USB client drivers such as us set up URBs (USB Request Packets) to send requests
            // to the host controller driver (HCD). The URB structure defines a format for all
            // possible commands that can be sent to a USB device.
            // Here, we request the device descriptor and store it,
            // and configure the device.
            NTStatus = CMUSB_StartDevice(DeviceObject);

            Irp->IoStatus.Status = NTStatus;
            }

         IoCompleteRequest (Irp,IO_NO_INCREMENT);
         CMUSB_DecrementIoCount(DeviceObject);

         // Release the remove lock
         SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

         return NTStatus;  // end, case IRP_MN_START_DEVICE


         // ------------------------
         // IRP_MN_QUERY_STOP_DEVICE
         // ------------------------
      case IRP_MN_QUERY_STOP_DEVICE:
         // The IRP_MN_QUERY_STOP_DEVICE/IRP_MN_STOP_DEVICE sequence only occurs
         // during "polite" shutdowns, such as the user explicitily requesting the
         // service be stopped in, or requesting unplug from the Pnp tray icon.
         // This sequence is NOT received during "impolite" shutdowns,
         // such as someone suddenly yanking the USB cord or otherwise
         // unexpectedly disabling/resetting the device.

         // If a driver sets STATUS_SUCCESS for this IRP,
         // the driver must not start any operations on the device that
         // would prevent that driver from successfully completing an IRP_MN_STOP_DEVICE
         // for the device.
         // For mass storage devices such as disk drives, while the device is in the
         // stop-pending state,the driver holds IRPs that require access to the device,
         // but for most USB devices, there is no 'persistent storage', so we will just
         // refuse any more IO until restarted or the stop is cancelled

         // If a driver in the device stack determines that the device cannot be
         // stopped for resource reconfiguration, the driver is not required to pass
         // the IRP down the device stack. If a query-stop IRP fails,
         // the PnP Manager sends an IRP_MN_CANCEL_STOP_DEVICE to the device stack,
         // notifying the drivers for the device that the query has been cancelled
         // and that the device will not be stopped.


         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_QUERY_STOP_DEVICE\n",DRIVER_NAME));

         // It is possible to receive this irp when the device has not been started
         //  ( as on a boot device )
         if (DeviceExtension->DeviceStarted == FALSE)  // if get when never started, just pass on
            {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!ProcessPnPIrp: IRP_MN_QUERY_STOP_DEVICE when device not started\n",DRIVER_NAME));
            IoSkipCurrentIrpStackLocation (Irp);
            NTStatus = IoCallDriver (DeviceExtension->TopOfStackDeviceObject, Irp);
            CMUSB_DecrementIoCount(DeviceObject);

            // Release the remove lock
            SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

            return NTStatus;
            }

         // We'll not veto it; pass it on and flag that stop was requested.
         // Once StopDeviceRequested is set no new IOCTL or read/write irps will be passed
         // down the stack to lower drivers; all will be quickly failed
         DeviceExtension->StopDeviceRequested = TRUE;

         break; // end, case IRP_MN_QUERY_STOP_DEVICE


         // -------------------------
         // IRP_MN_CANCEL_STOP_DEVICE
         // -------------------------
      case IRP_MN_CANCEL_STOP_DEVICE:
         // The PnP Manager uses this IRP to inform the drivers for a device
         // that the device will not be stopped for resource reconfiguration.
         // This should only be received after a successful IRP_MN_QUERY_STOP_DEVICE.

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_CANCEL_STOP_DEVICE received\n",DRIVER_NAME));

         // It is possible to receive this irp when the device has not been started
         if (DeviceExtension->DeviceStarted == FALSE)  // if get when never started, just pass on
            {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!ProcessPnPIrp: IRP_MN_CANCEL_STOP_DEVICE when device not started\n",DRIVER_NAME));
            IoSkipCurrentIrpStackLocation (Irp);
            NTStatus = IoCallDriver (DeviceExtension->TopOfStackDeviceObject, Irp);
            CMUSB_DecrementIoCount(DeviceObject);

            // Release the remove lock
            SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

            return NTStatus;
            }

         // Reset this flag so new IOCTL and IO Irp processing will be re-enabled
         DeviceExtension->StopDeviceRequested = FALSE;
         Irp->IoStatus.Status = STATUS_SUCCESS;
         break; // end, case IRP_MN_CANCEL_STOP_DEVICE

         // -------------------
         // IRP_MN_STOP_DEVICE
         // -------------------
      case IRP_MN_STOP_DEVICE:
         // The PnP Manager sends this IRP to stop a device so it can reconfigure
         // its hardware resources. The PnP Manager only sends this IRP if a prior
         // IRP_MN_QUERY_STOP_DEVICE completed successfully.

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_STOP_DEVICE received\n",DRIVER_NAME));

         // Cancel any pending io requests.  (there shouldn't be any)
         //CMUSB_CancelPendingIo( DeviceObject );

         //
         // Send the select configuration urb with a NULL pointer for the configuration
         // handle, this closes the configuration and puts the device in the 'unconfigured'
         // state.
         //
         NTStatus = CMUSB_StopDevice(DeviceObject);
         Irp->IoStatus.Status = NTStatus;

         break; // end, case IRP_MN_STOP_DEVICE


         // --------------------------
         // IRP_MN_QUERY_REMOVE_DEVICE
         // --------------------------
      case IRP_MN_QUERY_REMOVE_DEVICE:
         //  In response to this IRP, drivers indicate whether the device can be
         //  removed without disrupting the system.
         //  If a driver determines it is safe to remove the device,
         //  the driver completes any outstanding I/O requests, arranges to hold any subsequent
         //  read/write requests, and sets Irp->IoStatus.Status to STATUS_SUCCESS. Function
         //  and filter drivers then pass the IRP to the next-lower driver in the device stack.
         //  The underlying bus driver calls IoCompleteRequest.

         //  If a driver sets STATUS_SUCCESS for this IRP, the driver must not start any
         //  operations on the device that would prevent that driver from succesfully completing
         //  an IRP_MN_REMOVE_DEVICE for the device. If a driver in the device stack determines
         //  that the device cannot be removed, the driver is not required to pass the
         //  query-remove IRP down the device stack. If a query-remove IRP fails, the PnP Manager
         //  sends an IRP_MN_CANCEL_REMOVE_DEVICE to the device stack, notifying the drivers for
         //  the device that the query has been cancelled and that the device will not be removed.

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_QUERY_REMOVE_DEVICE received\n",DRIVER_NAME));

         // It is possible to receive this irp when the device has not been started
         if (DeviceExtension->DeviceStarted == FALSE)  // if get when never started, just pass on
            {
            SmartcardDebug( DEBUG_DRIVER,
                            ("%s!ProcessPnPIrp: IRP_MN_QUERY_STOP_DEVICE when device not started\n",
                             DRIVER_NAME)
                          );
            IoSkipCurrentIrpStackLocation (Irp);
            NTStatus = IoCallDriver (DeviceExtension->TopOfStackDeviceObject, Irp);
            CMUSB_DecrementIoCount(DeviceObject);

            // Release the remove lock
            SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

            return NTStatus;
            }


         if (DeviceExtension->fPnPResourceManager == TRUE)
            {
            // disable the reader
            DebugStatus = IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,FALSE);
            ASSERT(DebugStatus == STATUS_SUCCESS);
            }

         // Once RemoveDeviceRequested is set no new IOCTL or read/write irps will be passed
         // down the stack to lower drivers; all will be quickly failed
         DeviceExtension->RemoveDeviceRequested = TRUE;

         // Wait for any io request pending in our driver to
         // complete before returning success.
         // This  event is set when DeviceExtension->PendingIoCount goes to 1
         waitStatus = KeWaitForSingleObject(&DeviceExtension->NoPendingIoEvent,
                                            Suspended,
                                            KernelMode,
                                            FALSE,
                                            NULL);

         Irp->IoStatus.Status = STATUS_SUCCESS;
         break; // end, case IRP_MN_QUERY_REMOVE_DEVICE

         // ---------------------------
         // IRP_MN_CANCEL_REMOVE_DEVICE
         // ---------------------------
      case IRP_MN_CANCEL_REMOVE_DEVICE:

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_CANCEL_REMOVE_DEVICE received\n",DRIVER_NAME));
         // The PnP Manager uses this IRP to inform the drivers
         // for a device that the device will not be removed.
         // It is sent only after a successful IRP_MN_QUERY_REMOVE_DEVICE.

         if (DeviceExtension->DeviceStarted == FALSE) // if get when never started, just pass on
            {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!ProcessPnPIrp: IRP_MN_CANCEL_REMOVE_DEVICE when device not started\n",DRIVER_NAME));
            IoSkipCurrentIrpStackLocation (Irp);
            NTStatus = IoCallDriver (DeviceExtension->TopOfStackDeviceObject, Irp);
            CMUSB_DecrementIoCount(DeviceObject);

            // Release the remove lock
            SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

            return NTStatus;
            }

         if (DeviceExtension->fPnPResourceManager == TRUE)
            {
            DebugStatus = IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,
                                                    TRUE);
            ASSERT(DebugStatus == STATUS_SUCCESS);
            }

         // Reset this flag so new IOCTL and IO Irp processing will be re-enabled
         DeviceExtension->RemoveDeviceRequested = FALSE;
         Irp->IoStatus.Status = STATUS_SUCCESS;

         break; // end, case IRP_MN_CANCEL_REMOVE_DEVICE

         // ---------------------
         // IRP_MN_SURPRISE_REMOVAL
         // ---------------------
      case IRP_MN_SURPRISE_REMOVAL:
         // For a surprise-style device removal ( i.e. sudden cord yank ),
         // the physical device has already been removed so the PnP Manager sends
         // the remove IRP without a prior query-remove. A device can be in any state
         // when it receives a remove IRP as a result of a surprise-style removal.

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_SURPRISE_REMOVAL received\n",DRIVER_NAME));

         // match the inc at the begining of the dispatch routine
         CMUSB_DecrementIoCount(DeviceObject);

         if (DeviceExtension->fPnPResourceManager == TRUE)
            {
            // disable the reader
            DebugStatus = IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,FALSE);
            ASSERT(DebugStatus == STATUS_SUCCESS);
            }

         // Once RemoveDeviceRequested is set no new IOCTL or read/write irps will be passed
         // down the stack to lower drivers; all will be quickly failed
         DeviceExtension->DeviceSurpriseRemoval = TRUE;


         //
         // Mark this handled
         //
         Irp->IoStatus.Status = STATUS_SUCCESS;

         // We don't explicitly wait for the below driver to complete, but just make
         // the call and go on, finishing cleanup
         IoCopyCurrentIrpStackLocationToNext(Irp);

         NTStatus = IoCallDriver(stackDeviceObject,Irp);

         // Release the remove lock
         SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

         return NTStatus;

         // ---------------------
         // IRP_MN_REMOVE_DEVICE
         // ---------------------
      case IRP_MN_REMOVE_DEVICE:
         // The PnP Manager uses this IRP to direct drivers to remove a device.
         // For a "polite" device removal, the PnP Manager sends an
         // IRP_MN_QUERY_REMOVE_DEVICE prior to the remove IRP. In this case,
         // the device is in the remove-pending state when the remove IRP arrives.
         // For a surprise-style device removal ( i.e. sudden cord yank ),
         // the physical device has already been removed so the PnP Manager sends
         // the remove IRP without a prior query-remove. A device can be in any state
         // when it receives a remove IRP as a result of a surprise-style removal.

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_REMOVE_DEVICE received\n",DRIVER_NAME));

         // match the inc at the begining of the dispatch routine
         CMUSB_DecrementIoCount(DeviceObject);

         //
         // Once DeviceRemoved is set no new IOCTL or read/write irps will be passed
         // down the stack to lower drivers; all will be quickly failed
         //
         DeviceExtension->DeviceRemoved = TRUE;

         // Cancel any pending io requests; we may not have gotten a query first!
         //CMUSB_CancelPendingIo( DeviceObject );

         // It is possible to receive this irp when the device has not been started
         if (DeviceExtension->DeviceStarted == TRUE)  // if get when never started, just pass on
            {
            // If any pipes are still open, call USBD with URB_FUNCTION_ABORT_PIPE
            // This call will also close the pipes; if any user close calls get through,
            // they will be noops
            CMUSB_AbortPipes( DeviceObject );
            }


         //
         // The final decrement to device extension PendingIoCount == 0
         // will set DeviceExtension->RemoveEvent, enabling device removal.

         // If there is no pending IO at this point, the below decrement will be it.
         // If there is still pending IO,
         // the following CancelPendingIo() call will handle it.
         //
         CMUSB_DecrementIoCount(DeviceObject);


         // wait for any io request pending in our driver to
         // complete for finishing the remove
         KeWaitForSingleObject(&DeviceExtension->RemoveEvent,
                               Suspended,
                               KernelMode,
                               FALSE,
                               NULL);

         //
         // Delete the link and FDO we created
         //
         CMUSB_RemoveDevice(DeviceObject);

         // We don't explicitly wait for the below driver to complete, but just make
         // the call and go on, finishing cleanup
         IoCopyCurrentIrpStackLocationToNext(Irp);

         NTStatus = IoCallDriver(stackDeviceObject,Irp);


         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!ProcessPnPIrp: Detaching from %08X\n",DRIVER_NAME,
                         DeviceExtension->TopOfStackDeviceObject));

         IoDetachDevice(DeviceExtension->TopOfStackDeviceObject);

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!ProcessPnPIrp: Deleting %08X\n",DRIVER_NAME,DeviceObject));

         IoDeleteDevice (DeviceObject);

         // don't release remove lock here
         // because it's relesed in RemoveDevice
         return NTStatus; // end, case IRP_MN_REMOVE_DEVICE



         // ---------------------
         // IRP_MN_QUERY_CAPABILITIES
         // ---------------------
      case IRP_MN_QUERY_CAPABILITIES:

         //
         // Get the packet.
         //
         DeviceCapabilities=irpStack->Parameters.DeviceCapabilities.Capabilities;

         if (DeviceCapabilities->Version < 1 ||
             DeviceCapabilities->Size < sizeof(DEVICE_CAPABILITIES))
            {
            //
            // We don't support this version. Fail the requests
            //
            NTStatus = STATUS_UNSUCCESSFUL;
            break;
            }


         //
         // Prepare to pass the IRP down
         //

         // init an event to tell us when the completion routine's been called
         KeInitializeEvent(&event, NotificationEvent, FALSE);

         IoCopyCurrentIrpStackLocationToNext(Irp);
         IoSetCompletionRoutine (Irp,
                                 CMUSB_IrpCompletionRoutine,
                                 &event,  // pass the event as Context to completion routine
                                 TRUE,    // invoke on success
                                 TRUE,    // invoke on error
                                 TRUE);   // invoke on cancellation of the Irp


         NTStatus = IoCallDriver(stackDeviceObject,Irp);
         if (NTStatus == STATUS_PENDING)
            {
            // wait for irp to complete
            NTStatus = KeWaitForSingleObject(&event,
                                             Suspended,
                                             KernelMode,
                                             FALSE,
                                             NULL);
            }

         // We cannot wake the system.
         DeviceCapabilities->SystemWake = PowerSystemUnspecified;
         DeviceCapabilities->DeviceWake = PowerDeviceUnspecified;

         // We have no latencies
         DeviceCapabilities->D1Latency = 0;
         DeviceCapabilities->D2Latency = 0;
         DeviceCapabilities->D3Latency = 0;

         // No locking or ejection
         DeviceCapabilities->LockSupported = FALSE;
         DeviceCapabilities->EjectSupported = FALSE;

         // Device can be physically removed.
         // Technically there is no physical device to remove, but this bus
         // driver can yank the PDO from the PlugPlay system, when ever it
         // receives an IOCTL_GAMEENUM_REMOVE_PORT device control command.
         DeviceCapabilities->Removable = TRUE;

         // Docking device
         DeviceCapabilities->DockDevice = FALSE;

         // Device can not be removed any time
         // it has a removeable media!!
         DeviceCapabilities->SurpriseRemovalOK  = FALSE;

         Irp->IoStatus.Status = NTStatus;
         IoCompleteRequest (Irp,IO_NO_INCREMENT);

         // Decrement IO count
         CMUSB_DecrementIoCount(DeviceObject);
         // Release the remove lock
         SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

         return NTStatus; // end, case IRP_MN_QUERY_CAPABILITIES




         // ---------------------
         // IRP_MN_ not handled
         // ---------------------
      default:
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!ProcessPnPIrp: Minor PnP IOCTL not handled\n",DRIVER_NAME));
      } /* case MinorFunction  */


   if (!NT_SUCCESS(NTStatus))
      {

      // if anything went wrong, return failure  without passing Irp down
      Irp->IoStatus.Status = NTStatus;
      IoCompleteRequest (Irp,IO_NO_INCREMENT);
      CMUSB_DecrementIoCount(DeviceObject);

      // Release the remove lock
      SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

      SmartcardDebug(DEBUG_TRACE,
                     ("%s!ProcessPnPIrp: Exit %lx\n",DRIVER_NAME,NTStatus));
      return NTStatus;
      }

   IoCopyCurrentIrpStackLocationToNext(Irp);

   //
   // All PNP_POWER messages get passed to the TopOfStackDeviceObject
   // we were given in PnPAddDevice
   //
   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!ProcessPnPIrp: Passing PnP Irp down, NTStatus = %x\n",DRIVER_NAME,NTStatus));

   NTStatus = IoCallDriver(stackDeviceObject,Irp);
   CMUSB_DecrementIoCount(DeviceObject);

   // Release the remove lock
   SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ProcessPnPIrp: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}



/*****************************************************************************
Routine Description:

    This routine is called to create and initialize our Functional Device Object (FDO).
    For monolithic drivers, this is done in DriverEntry(), but Plug and Play devices
    wait for a PnP event

Arguments:

    DriverObject - pointer to the driver object for this instance of CMUSB

    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

*****************************************************************************/
NTSTATUS CMUSB_PnPAddDevice(
                           IN PDRIVER_OBJECT DriverObject,
                           IN PDEVICE_OBJECT PhysicalDeviceObject
                           )
{
   NTSTATUS                NTStatus = STATUS_SUCCESS;
   PDEVICE_OBJECT          deviceObject = NULL;
   PDEVICE_EXTENSION       DeviceExtension;
   USBD_VERSION_INFORMATION versionInformation;
   ULONG i;



   SmartcardDebug(DEBUG_TRACE,
                  ("%s!PnPAddDevice: Enter\n",DRIVER_NAME));



   //
   // create our funtional device object (FDO)
   //

   NTStatus = CMUSB_CreateDeviceObject(DriverObject,
                                       PhysicalDeviceObject,
                                       &deviceObject);

   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!PnPAddDevice: DeviceObject = %p\n",DRIVER_NAME,deviceObject));


   if (NT_SUCCESS(NTStatus))
      {
      DeviceExtension = deviceObject->DeviceExtension;

      deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

      //
      // we support direct io for read/write
      //
      deviceObject->Flags |= DO_DIRECT_IO;

      //Set this flag causes the driver to not receive a IRP_MN_STOP_DEVICE
      //during suspend and also not get an IRP_MN_START_DEVICE during resume.
      //This is neccesary because during the start device call,
      // the GetDescriptors() call  will be failed by the USB stack.
      deviceObject->Flags |= DO_POWER_PAGABLE;


      // initialize our device extension
      //
      // remember the Physical device Object
      //
      DeviceExtension->PhysicalDeviceObject=PhysicalDeviceObject;

      //
      // Attach to the PDO
      //

      DeviceExtension->TopOfStackDeviceObject =
      IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

      // Get a copy of the physical device's capabilities into a
      // DEVICE_CAPABILITIES struct in our device extension;
      // We are most interested in learning which system power states
      // are to be mapped to which device power states for handling
      // IRP_MJ_SET_POWER Irps.
      CMUSB_QueryCapabilities(PhysicalDeviceObject,
                              &DeviceExtension->DeviceCapabilities);


      // We want to determine what level to auto-powerdown to; This is the lowest
      // sleeping level that is LESS than D3;
      // If all are set to D3, auto powerdown/powerup will be disabled.

      DeviceExtension->PowerDownLevel = PowerDeviceUnspecified; // init to disabled
      for (i=PowerSystemSleeping1; i<= PowerSystemSleeping3; i++)
         {
         if ( DeviceExtension->DeviceCapabilities.DeviceState[i] < PowerDeviceD3 )
            DeviceExtension->PowerDownLevel = DeviceExtension->DeviceCapabilities.DeviceState[i];
         }

#if DBG

      //
      // display the device  caps
      //

      SmartcardDebug( DEBUG_DRIVER,("%s!PnPAddDevice: ----------- DeviceCapabilities ------------\n",
                                    DRIVER_NAME));
      SmartcardDebug( DEBUG_DRIVER,  ("%s!PnPAddDevice: SystemWake  = %s\n",
                                      DRIVER_NAME,
                                      CMUSB_StringForSysState( DeviceExtension->DeviceCapabilities.SystemWake ) ));
      SmartcardDebug( DEBUG_DRIVER,  ("%s!PnPAddDevice: DeviceWake  = %s\n",
                                      DRIVER_NAME,
                                      CMUSB_StringForDevState( DeviceExtension->DeviceCapabilities.DeviceWake) ));

      for (i=PowerSystemUnspecified; i< PowerSystemMaximum; i++)
         {
         SmartcardDebug(DEBUG_DRIVER,("%s!PnPAddDevice: sysstate %s = devstate %s\n",
                                      DRIVER_NAME,
                                      CMUSB_StringForSysState( i ),
                                      CMUSB_StringForDevState( DeviceExtension->DeviceCapabilities.DeviceState[i] ))
                       );
         }
      SmartcardDebug( DEBUG_DRIVER,("PnPAddDevice: ---------------------------------------------\n"));
#endif

      // We keep a pending IO count ( extension->PendingIoCount )  in the device extension.
      // The first increment of this count is done on adding the device.
      // Subsequently, the count is incremented for each new IRP received and
      // decremented when each IRP is completed or passed on.

      // Transition to 'one' therefore indicates no IO is pending and signals
      // DeviceExtension->NoPendingIoEvent. This is needed for processing
      // IRP_MN_QUERY_REMOVE_DEVICE

      // Transition to 'zero' signals an event ( DeviceExtension->RemoveEvent )
      // to enable device removal. This is used in processing for IRP_MN_REMOVE_DEVICE
      //
      CMUSB_IncrementIoCount(deviceObject);

      }

   USBD_GetUSBDIVersion(&versionInformation);



   SmartcardDebug(DEBUG_TRACE,
                  ("%s!PnPAddDevice: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}


/*****************************************************************************
Routine Description:

    Called from CMUSB_ProcessPnPIrp, the dispatch routine for IRP_MJ_PNP.
    Initializes a given instance of the device on the USB.
    USB client drivers such as us set up URBs (USB Request Packets) to send requests
    to the host controller driver (HCD). The URB structure defines a format for all
    possible commands that can be sent to a USB device.
    Here, we request the device descriptor and store it, and configure the device.


Arguments:

    DeviceObject - pointer to the FDO (Functional Device Object)

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS CMUSB_StartDevice(
                          IN  PDEVICE_OBJECT DeviceObject
                          )
{
   PDEVICE_EXTENSION DeviceExtension;
   NTSTATUS NTStatus;
   PUSB_DEVICE_DESCRIPTOR deviceDescriptor = NULL;
   PURB urb;
   ULONG siz;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!StartDevice: Enter\n",DRIVER_NAME));

   DeviceExtension = DeviceObject->DeviceExtension;

   urb = ExAllocatePool(NonPagedPool,
                        sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

   if (urb != NULL)
      {
      siz = sizeof(USB_DEVICE_DESCRIPTOR);

      deviceDescriptor = ExAllocatePool(NonPagedPool,siz);
      if (deviceDescriptor != NULL)
         {
         UsbBuildGetDescriptorRequest(urb,
                                      (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                      USB_DEVICE_DESCRIPTOR_TYPE,
                                      0,
                                      0,
                                      deviceDescriptor,
                                      NULL,
                                      siz,
                                      NULL);

         NTStatus = CMUSB_CallUSBD(DeviceObject, urb);

         if (NT_SUCCESS(NTStatus))
            {
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: Device Descriptor = %x, len %x\n",DRIVER_NAME,deviceDescriptor,
                                          urb->UrbControlDescriptorRequest.TransferBufferLength));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: CardMan USB Device Descriptor:\n",DRIVER_NAME));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: -------------------------\n",DRIVER_NAME));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bLength %d\n",DRIVER_NAME,deviceDescriptor->bLength));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bDescriptorType 0x%x\n",DRIVER_NAME,deviceDescriptor->bDescriptorType));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bcdUSB 0x%x\n",DRIVER_NAME,deviceDescriptor->bcdUSB));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bDeviceClass 0x%x\n",DRIVER_NAME,deviceDescriptor->bDeviceClass));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bDeviceSubClass 0x%x\n",DRIVER_NAME,deviceDescriptor->bDeviceSubClass));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bDeviceProtocol 0x%x\n",DRIVER_NAME,deviceDescriptor->bDeviceProtocol));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bMaxPacketSize0 0x%x\n",DRIVER_NAME,deviceDescriptor->bMaxPacketSize0));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: idVendor 0x%x\n",DRIVER_NAME,deviceDescriptor->idVendor));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: idProduct 0x%x\n",DRIVER_NAME,deviceDescriptor->idProduct));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bcdDevice 0x%x\n",DRIVER_NAME,deviceDescriptor->bcdDevice));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: iManufacturer 0x%x\n",DRIVER_NAME,deviceDescriptor->iManufacturer));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: iProduct 0x%x\n",DRIVER_NAME,deviceDescriptor->iProduct));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: iSerialNumber 0x%x\n",DRIVER_NAME,deviceDescriptor->iSerialNumber));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bNumConfigurations 0x%x\n",DRIVER_NAME,deviceDescriptor->bNumConfigurations));
            }
         }
      else
         {
         // if we got here we failed to allocate deviceDescriptor
         SmartcardDebug(DEBUG_ERROR,
                        ( "%s!StartDevice: ExAllocatePool for deviceDescriptor failed\n",DRIVER_NAME));
         NTStatus = STATUS_INSUFFICIENT_RESOURCES;
         }

      if (NT_SUCCESS(NTStatus))
         {
         DeviceExtension->UsbDeviceDescriptor = deviceDescriptor;
         // -------------------------------------------------------------
         // copy the firmware version to the reader extension structure
         // -------------------------------------------------------------
         DeviceExtension->SmartcardExtension.ReaderExtension->ulFWVersion =
         (ULONG)(((DeviceExtension->UsbDeviceDescriptor->bcdDevice/256)*100)+
                 (DeviceExtension->UsbDeviceDescriptor->bcdDevice&0x00FF));
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!StartDevice: FW version = %ld\n",DRIVER_NAME,DeviceExtension->SmartcardExtension.ReaderExtension->ulFWVersion));
         }
      else if (deviceDescriptor != NULL)
         {
         ExFreePool(deviceDescriptor);
         }

      ExFreePool(urb);

      }
   else
      {
      // if we got here we failed to allocate the urb
      SmartcardDebug(DEBUG_ERROR,
                     ("%s!StartDevice: ExAllocatePool for usb failed\n",DRIVER_NAME));
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      }

   if (NT_SUCCESS(NTStatus))
      {
      NTStatus = CMUSB_ConfigureDevice(DeviceObject);
      }


   if (NT_SUCCESS(NTStatus))
      {
      NTStatus = CMUSB_StartCardTracking(DeviceObject);
      }

   if (NT_SUCCESS(NTStatus) && DeviceExtension->fPnPResourceManager == TRUE)
      {
      // enable interface
      NTStatus = IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,TRUE);
      }

   if (NT_SUCCESS(NTStatus))
      {
      DeviceExtension->DeviceStarted = TRUE;
      }

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!StartDevice: Exit %ld\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}





/*****************************************************************************

Routine Description:

   Called from CMUSB_ProcessPnPIrp: to
   clean up our device instance's allocated buffers; free symbolic links

Arguments:

    DeviceObject - pointer to the FDO

Return Value:

    NT NTStatus code from free symbolic link operation

*****************************************************************************/
NTSTATUS CMUSB_RemoveDevice(
                           IN  PDEVICE_OBJECT DeviceObject
                           )
{
   PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION  SmartcardExtension;
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UNICODE_STRING deviceLinkUnicodeString;
   KIRQL irql;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!RemoveDevice: Enter\n",DRIVER_NAME));

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;


   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!RemoveDevice: DeviceStarted=%ld\n",DRIVER_NAME,DeviceExtension->DeviceStarted));
   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!RemoveDevice: DeviceOpened=%ld\n",DRIVER_NAME,DeviceExtension->lOpenCount));

   if (SmartcardExtension->OsData != NULL)
      {
      // complete pending card tracking requests (if any)
      if (SmartcardExtension->OsData->NotificationIrp != NULL)
         {
         CMUSB_CompleteCardTracking(SmartcardExtension);
         }
      ASSERT(SmartcardExtension->OsData->NotificationIrp == NULL);
      }

   // Wait until we can safely unload the device
   SmartcardReleaseRemoveLockAndWait(SmartcardExtension);

   if (DeviceExtension->DeviceStarted == TRUE)
      {
      if (DeviceExtension->fPnPResourceManager == FALSE)
         {
         KeWaitForSingleObject(&SmartcardExtension->ReaderExtension->CardManIOMutex,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

         // issue a card removal event for the resource manager
         if (SmartcardExtension->ReaderExtension->ulOldCardState == INSERTED  ||
             SmartcardExtension->ReaderExtension->ulOldCardState == POWERED     )
            {
            // card has been removed

            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!RemoveDevice: Smartcard removed\n",DRIVER_NAME));

            CMUSB_CompleteCardTracking(SmartcardExtension);

            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);

            SmartcardExtension->ReaderExtension->ulOldCardState = UNKNOWN;
            SmartcardExtension->ReaderExtension->ulNewCardState = UNKNOWN;
            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            SmartcardExtension->CardCapabilities.ATR.Length        = 0;
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

            RtlFillMemory((PVOID)&SmartcardExtension->ReaderExtension->CardParameters,
                          sizeof(CARD_PARAMETERS),0x00);

            }
         KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);
         }

      CMUSB_StopDevice(DeviceObject);
      }

   if (DeviceExtension->fPnPResourceManager == TRUE)
      {
      // disable interface

      NTStatus = IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,
                                           FALSE);

      if (DeviceExtension->PnPDeviceName.Buffer != NULL)
         {
         RtlFreeUnicodeString(&DeviceExtension->PnPDeviceName);
         DeviceExtension->PnPDeviceName.Buffer = NULL;
         }

      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!RemoveDevice: PnPDeviceName.Buffer  = %lx\n",DRIVER_NAME,
                      DeviceExtension->PnPDeviceName.Buffer));
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!RemoveDevice: PnPDeviceName.BufferLength  = %lx\n",DRIVER_NAME,
                      DeviceExtension->PnPDeviceName.Length));
      }
   else
      {
      //
      // Delete the symbolic link of the smart card reader
      //
      IoDeleteSymbolicLink(&DeviceExtension->DosDeviceName);
      }

   DeviceSlot[SmartcardExtension->ReaderExtension->ulDeviceInstance] = FALSE;
   OemDeviceSlot[SmartcardExtension->ReaderExtension->ulOemNameIndex][SmartcardExtension->ReaderExtension->ulOemDeviceInstance] = FALSE;

   if (DeviceExtension->lOpenCount == 0)
      {
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!RemoveDevice: freeing resources\n",DRIVER_NAME));

      if (DeviceExtension->fPnPResourceManager == FALSE)
         {
         //
         // Free all allocated buffer
         //
         ExFreePool(DeviceExtension->DosDeviceName.Buffer);
         }

      ExFreePool(SmartcardExtension->ReaderExtension);
      SmartcardExtension->ReaderExtension = NULL;
      //
      // Let the lib free the send/receive buffers
      //
      SmartcardExit(SmartcardExtension);
      }

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!RemoveDevice: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}




/*****************************************************************************

Routine Description:

    Stops a given instance of a 82930 device on the USB.
    We basically just tell USB this device is now 'unconfigured'

Arguments:

    DeviceObject - pointer to the device object for this instance of a 82930

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS CMUSB_StopDevice(
                         IN  PDEVICE_OBJECT DeviceObject
                         )
{
   PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION  SmartcardExtension;
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PURB urb;
   ULONG siz;


   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!StopDevice: Enter\n",DRIVER_NAME));

   DeviceExtension = DeviceObject->DeviceExtension;


   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!StopDevice: DeviceStarted=%ld\n",DRIVER_NAME,
                   DeviceExtension->DeviceStarted));
   SmartcardDebug( DEBUG_DRIVER,
                   ("%s!StopDevice: DeviceOpened=%ld\n",DRIVER_NAME,
                    DeviceExtension->lOpenCount));

   // stop update thread
   CMUSB_StopCardTracking(DeviceObject);

   // power down the card for saftey reasons
   if (DeviceExtension->SmartcardExtension.ReaderExtension->ulOldCardState == POWERED)
      {
      // we have to wait for the mutex before
      KeWaitForSingleObject(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL);
      CMUSB_PowerOffCard(&DeviceExtension->SmartcardExtension);
      KeReleaseMutex(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                     FALSE);
      }


   //
   // Send the select configuration urb with a NULL pointer for the configuration
   // handle. This closes the configuration and puts the device in the 'unconfigured'
   // state.
   //
   siz = sizeof(struct _URB_SELECT_CONFIGURATION);
   urb = ExAllocatePool(NonPagedPool,siz);
   if (urb != NULL)
      {
      UsbBuildSelectConfigurationRequest(urb,
                                         (USHORT) siz,
                                         NULL);
      NTStatus = CMUSB_CallUSBD(DeviceObject, urb);
      ExFreePool(urb);
      }
   else
      {
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      }

   // now clear the flag whcih indicates if the device is started
   DeviceExtension->DeviceStarted = FALSE;

   DeviceExtension->StopDeviceRequested = FALSE;


   //
   // Free device descriptor structure
   //
   if (DeviceExtension->UsbDeviceDescriptor != NULL)
      {
      SmartcardDebug( DEBUG_DRIVER,
                      ("%s!StopDevice: freeing UsbDeviceDescriptor\n",DRIVER_NAME,NTStatus));
      ExFreePool(DeviceExtension->UsbDeviceDescriptor);
      DeviceExtension->UsbDeviceDescriptor = NULL;
      }

   //
   // Free up the UsbInterface structure
   //
   if (DeviceExtension->UsbInterface != NULL)
      {
      SmartcardDebug( DEBUG_DRIVER,
                      ("%s!StopDevice: freeing UsbInterface\n",DRIVER_NAME,NTStatus));
      ExFreePool(DeviceExtension->UsbInterface);
      DeviceExtension->UsbInterface = NULL;
      }

   // free up the USB config discriptor
   if (DeviceExtension->UsbConfigurationDescriptor != NULL)
      {
      SmartcardDebug( DEBUG_DRIVER,
                      ("%s!StopDevice: freeing UsbConfiguration\n",DRIVER_NAME,NTStatus));
      ExFreePool(DeviceExtension->UsbConfigurationDescriptor);
      DeviceExtension->UsbConfigurationDescriptor = NULL;
      }


   SmartcardDebug( DEBUG_TRACE,
                   ("%s!StopDevice: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}



/*****************************************************************************

Routine Description:

    Used as a general purpose completion routine so it can signal an event,
    passed as the Context, when the next lower driver is done with the input Irp.
    This routine is used by both PnP and Power Management logic.

    Even though this routine does nothing but set an event, it must be defined and
    prototyped as a completetion routine for use as such


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context, in this case a pointer to an event.

Return Value:

    The function value is the final NTStatus from the operation.

*****************************************************************************/
NTSTATUS CMUSB_IrpCompletionRoutine(
                                   IN PDEVICE_OBJECT DeviceObject,
                                   IN PIRP Irp,
                                   IN PVOID Context
                                   )
{
   PKEVENT event = Context;

   // Set the input event
   KeSetEvent(event,
              1,       // Priority increment  for waiting thread.
              FALSE);  // Flag this call is not immediately followed by wait.

   // This routine must return STATUS_MORE_PROCESSING_REQUIRED because we have not yet called
   // IoFreeIrp() on this IRP.
   return STATUS_MORE_PROCESSING_REQUIRED;

}



/*****************************************************************************

Routine Description:

    This is our FDO's dispatch table function for IRP_MJ_POWER.
    It processes the Power IRPs sent to the PDO for this device.

    For every power IRP, drivers must call PoStartNextPowerIrp and use PoCallDriver
    to pass the IRP all the way down the driver stack to the underlying PDO.


Arguments:

    DeviceObject - pointer to our device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS CMUSB_ProcessPowerIrp(
                              IN PDEVICE_OBJECT DeviceObject,
                              IN PIRP           Irp
                              )
{
   PIO_STACK_LOCATION irpStack;
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PDEVICE_EXTENSION DeviceExtension;
   BOOLEAN fGoingToD0 = FALSE;
   POWER_STATE sysPowerState, desiredDevicePowerState;
   KEVENT event;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ProcessPowerIrp Enter\n",DRIVER_NAME));

   DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
   irpStack = IoGetCurrentIrpStackLocation (Irp);
   CMUSB_IncrementIoCount(DeviceObject);

   switch (irpStack->MinorFunction)
      {
      // ----------------
      // IRP_MN_WAIT_WAKE
      // ----------------
      case IRP_MN_WAIT_WAKE:
         // A driver sends IRP_MN_WAIT_WAKE to indicate that the system should
         // wait for its device to signal a wake event. The exact nature of the event
         // is device-dependent.
         // Drivers send this IRP for two reasons:
         // 1) To allow a device to wake the system
         // 2) To wake a device that has been put into a sleep state to save power
         //    but still must be able to communicate with its driver under certain circumstances.
         // When a wake event occurs, the driver completes the IRP and returns
         // STATUS_SUCCESS. If the device is sleeping when the event occurs,
         // the driver must first wake up the device before completing the IRP.
         // In a completion routine, the driver calls PoRequestPowerIrp to send a
         // PowerDeviceD0 request. When the device has powered up, the driver can
         //  handle the IRP_MN_WAIT_WAKE request.

         SmartcardDebug( DEBUG_DRIVER,
                         ("%s!IRP_MN_WAIT_WAKE received\n",DRIVER_NAME));

         // DeviceExtension->DeviceCapabilities.DeviceWake specifies the lowest device power state (least powered)
         // from which the device can signal a wake event
         DeviceExtension->PowerDownLevel = DeviceExtension->DeviceCapabilities.DeviceWake;


         if ( ( PowerDeviceD0 == DeviceExtension->CurrentDevicePowerState )  ||
              ( DeviceExtension->DeviceCapabilities.DeviceWake > DeviceExtension->CurrentDevicePowerState ) )
            {
            //    STATUS_INVALID_DEVICE_STATE is returned if the device in the PowerD0 state
            //    or a state below which it can support waking, or if the SystemWake state
            //    is below a state which can be supported. A pending IRP_MN_WAIT_WAKE will complete
            //    with this error if the device's state is changed to be incompatible with the wake
            //    request.

            //  If a driver fails this IRP, it should complete the IRP immediately without
            //  passing the IRP to the next-lower driver.
            NTStatus = STATUS_INVALID_DEVICE_STATE;
            Irp->IoStatus.Status = NTStatus;
            IoCompleteRequest (Irp,IO_NO_INCREMENT );
            SmartcardDebug( DEBUG_DRIVER,
                            ("%s!ProcessPowerIrp Exit %lx\n",DRIVER_NAME,NTStatus));
            CMUSB_DecrementIoCount(DeviceObject);
            return NTStatus;
            }

         // flag we're enabled for wakeup
         DeviceExtension->EnabledForWakeup = TRUE;

         // init an event for our completion routine to signal when PDO is done with this Irp
         KeInitializeEvent(&event, NotificationEvent, FALSE);

         // If not failing outright, pass this on to our PDO for further handling
         IoCopyCurrentIrpStackLocationToNext(Irp);

         // Set a completion routine so it can signal our event when
         //  the PDO is done with the Irp
         IoSetCompletionRoutine(Irp,
                                CMUSB_IrpCompletionRoutine,
                                &event,  // pass the event to the completion routine as the Context
                                TRUE,    // invoke on success
                                TRUE,    // invoke on error
                                TRUE);   // invoke on cancellation

         PoStartNextPowerIrp(Irp);
         NTStatus = PoCallDriver(DeviceExtension->TopOfStackDeviceObject,
                                 Irp);

         // if PDO is not done yet, wait for the event to be set in our completion routine
         if (NTStatus == STATUS_PENDING)
            {
            // wait for irp to complete

            NTSTATUS waitStatus = KeWaitForSingleObject(&event,
                                                        Suspended,
                                                        KernelMode,
                                                        FALSE,
                                                        NULL);

            SmartcardDebug( DEBUG_DRIVER,
                            ("%s!waiting for PDO to finish IRP_MN_WAIT_WAKE completed\n",DRIVER_NAME));
            }

         // now tell the device to actually wake up
         CMUSB_SelfSuspendOrActivate( DeviceObject, FALSE );

         // flag we're done with wakeup irp
         DeviceExtension->EnabledForWakeup = FALSE;

         CMUSB_DecrementIoCount(DeviceObject);

         break;


         // ------------------
         // IRP_MN_SET_POWER
         // ------------------
      case IRP_MN_SET_POWER:
         // The system power policy manager sends this IRP to set the system power state.
         // A device power policy manager sends this IRP to set the device power state for a device.
         // Set Irp->IoStatus.Status to STATUS_SUCCESS to indicate that the device
         // has entered the requested state. Drivers cannot fail this IRP.

         SmartcardDebug( DEBUG_DRIVER,
                         ("%s!IRP_MN_SET_POWER\n",DRIVER_NAME));

         switch (irpStack->Parameters.Power.Type)
            {
            // +++++++++++++++++++
            // SystemPowerState
            // +++++++++++++++++++
            case SystemPowerState:
               // Get input system power state
               sysPowerState.SystemState = irpStack->Parameters.Power.State.SystemState;

               SmartcardDebug( DEBUG_DRIVER,
                               ("%s!SystemPowerState = %s\n",DRIVER_NAME,
                                CMUSB_StringForSysState( sysPowerState.SystemState)));

               // If system is in working state always set our device to D0
               // regardless of the wait state or system-to-device state power map
               if (sysPowerState.SystemState ==  PowerSystemWorking)
                  {
                  desiredDevicePowerState.DeviceState = PowerDeviceD0;

                  SmartcardDebug( DEBUG_DRIVER,
                                  ("%s!PowerSystemWorking, will set D0, not use state map\n",DRIVER_NAME));
                  }
               else
                  {
                  // set to corresponding system state if IRP_MN_WAIT_WAKE pending
                  if ( DeviceExtension->EnabledForWakeup )  // got a WAIT_WAKE IRP pending?
                     {
                     // Find the device power state equivalent to the given system state.
                     // We get this info from the DEVICE_CAPABILITIES struct in our device
                     // extension (initialized in CMUSB_PnPAddDevice() )
                     desiredDevicePowerState.DeviceState =
                     DeviceExtension->DeviceCapabilities.DeviceState[ sysPowerState.SystemState ];

                     SmartcardDebug(DEBUG_DRIVER,
                                    ("%s!IRP_MN_WAIT_WAKE pending, will use state map\n",DRIVER_NAME));
                     }
                  else
                     {
                     // if no wait pending and the system's not in working state, just turn off
                     desiredDevicePowerState.DeviceState = PowerDeviceD3;

                     SmartcardDebug(DEBUG_DRIVER,
                                    ("%s!Not EnabledForWakeup and the system's not in working state,\n            settting PowerDeviceD3 (off)\n",DRIVER_NAME));
                     }

                  if (sysPowerState.SystemState ==  PowerSystemShutdown)
                     {
                     // power down the card for saftey reasons
                     if (DeviceExtension->SmartcardExtension.ReaderExtension->ulOldCardState == POWERED)
                        {
                        // we have to wait for the mutex before
                        KeWaitForSingleObject(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL);
                        CMUSB_PowerOffCard(&DeviceExtension->SmartcardExtension);
                        KeReleaseMutex(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                                       FALSE);
                        }
                     }
                  }

               //
               // We've determined the desired device state; are we already in this state?
               //

               SmartcardDebug(DEBUG_DRIVER,
                              ("%s!desiredDevicePowerState = %s\n",DRIVER_NAME,CMUSB_StringForDevState(desiredDevicePowerState.DeviceState)));

               if (desiredDevicePowerState.DeviceState != DeviceExtension->CurrentDevicePowerState)
                  {
                  CMUSB_IncrementIoCount(DeviceObject);

                  // No, request that we be put into this state
                  // by requesting a new Power Irp from the Pnp manager
                  DeviceExtension->PowerIrp = Irp;
                  IoMarkIrpPending(Irp);
                  NTStatus = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject,
                                               IRP_MN_SET_POWER,
                                               desiredDevicePowerState,
                                               // completion routine will pass the Irp down to the PDO
                                               CMUSB_PoRequestCompletion,
                                               DeviceObject,
                                               NULL);
                  }
               else
                  {
                  // Yes, just pass it on to PDO (Physical Device Object)
                  IoCopyCurrentIrpStackLocationToNext(Irp);
                  PoStartNextPowerIrp(Irp);
                  NTStatus = PoCallDriver(DeviceExtension->TopOfStackDeviceObject,Irp);

                  CMUSB_DecrementIoCount(DeviceObject);
                  }
               break;

               // ++++++++++++++++++
               // DevicePowerState
               // ++++++++++++++++++
            case DevicePowerState:
               // For requests to D1, D2, or D3 ( sleep or off states ),
               // sets DeviceExtension->CurrentDevicePowerState to DeviceState immediately.
               // This enables any code checking state to consider us as sleeping or off
               // already, as this will imminently become our state.

               SmartcardDebug(DEBUG_DRIVER,
                              ("%s!DevicePowerState = %s\n",DRIVER_NAME,
                               CMUSB_StringForDevState(irpStack->Parameters.Power.State.DeviceState)));

               // For requests to DeviceState D0 ( fully on ), sets fGoingToD0 flag TRUE
               // to flag that we must set a completion routine and update
               // DeviceExtension->CurrentDevicePowerState there.
               // In the case of powering up to fully on, we really want to make sure
               // the process is completed before updating our CurrentDevicePowerState,
               // so no IO will be attempted or accepted before we're really ready.

               fGoingToD0 = CMUSB_SetDevicePowerState(DeviceObject,
                                                      irpStack->Parameters.Power.State.DeviceState); // returns TRUE for D0

               IoCopyCurrentIrpStackLocationToNext(Irp);

               if (fGoingToD0 == TRUE)
                  {
                  SmartcardDebug( DEBUG_DRIVER,("%s!going to D0\n",DRIVER_NAME));

                  IoSetCompletionRoutine(Irp,
                                         CMUSB_PowerIrp_Complete,
                                         // Always pass FDO to completion routine as its Context;
                                         // This is because the DriverObject passed by the system to the routine
                                         // is the Physical Device Object ( PDO ) not the Functional Device Object ( FDO )
                                         DeviceObject,
                                         TRUE,            // invoke on success
                                         TRUE,            // invoke on error
                                         TRUE);           // invoke on cancellation of the Irp
                  }

               PoStartNextPowerIrp(Irp);
               NTStatus = PoCallDriver(DeviceExtension->TopOfStackDeviceObject,
                                       Irp);

               if (fGoingToD0 == FALSE) // completion routine will decrement
                  CMUSB_DecrementIoCount(DeviceObject);

               break;
            } /* case irpStack->Parameters.Power.Type */
         break; /* IRP_MN_SET_POWER */

         // ------------------
         // IRP_MN_QUERY_POWER
         // ------------------
      case IRP_MN_QUERY_POWER:
         //
         // A power policy manager sends this IRP to determine whether it can change
         // the system or device power state, typically to go to sleep.
         //

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_QUERY_POWER received\n",DRIVER_NAME));

         switch (irpStack->Parameters.Power.Type)
            {
            // +++++++++++++++++++
            // SystemPowerState
            // +++++++++++++++++++
            case SystemPowerState:
               SmartcardDebug( DEBUG_DRIVER,
                               ("%s!SystemPowerState = %s\n",DRIVER_NAME,
                                CMUSB_StringForSysState(irpStack->Parameters.Power.State.SystemState)));
               break;

               // ++++++++++++++++++
               // DevicePowerState
               // ++++++++++++++++++
            case DevicePowerState:
               // For requests to D1, D2, or D3 ( sleep or off states ),
               // sets DeviceExtension->CurrentDevicePowerState to DeviceState immediately.
               // This enables any code checking state to consider us as sleeping or off
               // already, as this will imminently become our state.

               SmartcardDebug(DEBUG_DRIVER,
                              ("%s!DevicePowerState = %s\n",DRIVER_NAME,
                               CMUSB_StringForDevState(irpStack->Parameters.Power.State.DeviceState)));
               break;
            }

         // we do nothing special here, just let the PDO handle it
         IoCopyCurrentIrpStackLocationToNext(Irp);
         PoStartNextPowerIrp(Irp);
         NTStatus = PoCallDriver(DeviceExtension->TopOfStackDeviceObject,
                                 Irp);
         CMUSB_DecrementIoCount(DeviceObject);

         break; /* IRP_MN_QUERY_POWER */

      default:

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!unknown POWER IRP received\n",DRIVER_NAME));

         //
         // All unhandled power messages are passed on to the PDO
         //

         IoCopyCurrentIrpStackLocationToNext(Irp);
         PoStartNextPowerIrp(Irp);
         NTStatus = PoCallDriver(DeviceExtension->TopOfStackDeviceObject, Irp);

         CMUSB_DecrementIoCount(DeviceObject);

      } /* irpStack->MinorFunction */

   SmartcardDebug( DEBUG_TRACE,
                   ("%s!ProcessPowerIrp Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}


/*****************************************************************************

Routine Description:

   This is the completion routine set in a call to PoRequestPowerIrp()
   that was made in CMUSB_ProcessPowerIrp() in response to receiving
   an IRP_MN_SET_POWER of type 'SystemPowerState' when the device was
   not in a compatible device power state. In this case, a pointer to
   the IRP_MN_SET_POWER Irp is saved into the FDO device extension
   (DeviceExtension->PowerIrp), and then a call must be
   made to PoRequestPowerIrp() to put the device into a proper power state,
   and this routine is set as the completion routine.

    We decrement our pending io count and pass the saved IRP_MN_SET_POWER Irp
   on to the next driver

Arguments:

    DeviceObject - Pointer to the device object for the class device.
        Note that we must get our own device object from the Context

    Context - Driver defined context, in this case our own functional device object ( FDO )

Return Value:

    The function value is the final NTStatus from the operation.

*****************************************************************************/
NTSTATUS CMUSB_PoRequestCompletion(
                                  IN PDEVICE_OBJECT   DeviceObject,
                                  IN UCHAR            MinorFunction,
                                  IN POWER_STATE      PowerState,
                                  IN PVOID            Context,
                                  IN PIO_STATUS_BLOCK IoStatus
                                  )
{
   PIRP irp;
   PDEVICE_EXTENSION DeviceExtension;
   PDEVICE_OBJECT deviceObject = Context;
   NTSTATUS NTStatus;

   SmartcardDebug(DEBUG_TRACE,("%s!PoRequestCompletion Enter\n",DRIVER_NAME));

   DeviceExtension = deviceObject->DeviceExtension;

   // Get the Irp we saved for later processing in CMUSB_ProcessPowerIrp()
   // when we decided to request the Power Irp that this routine
   // is the completion routine for.
   irp = DeviceExtension->PowerIrp;

   // We will return the NTStatus set by the PDO for the power request we're completing
   NTStatus = IoStatus->Status;


   // we should not be in the midst of handling a self-generated power irp
   CMUSB_ASSERT( !DeviceExtension->SelfPowerIrp );

   // we must pass down to the next driver in the stack
   IoCopyCurrentIrpStackLocationToNext(irp);

   // Calling PoStartNextPowerIrp() indicates that the driver is finished
   // with the previous power IRP, if any, and is ready to handle the next power IRP.
   // It must be called for every power IRP.Although power IRPs are completed only once,
   // typically by the lowest-level driver for a device, PoStartNextPowerIrp must be called
   // for every stack location. Drivers must call PoStartNextPowerIrp while the current IRP
   // stack location points to the current driver. Therefore, this routine must be called
   // before IoCompleteRequest, IoSkipCurrentStackLocation, and PoCallDriver.

   PoStartNextPowerIrp(irp);

   // PoCallDriver is used to pass any power IRPs to the PDO instead of IoCallDriver.
   // When passing a power IRP down to a lower-level driver, the caller should use
   // IoSkipCurrentIrpStackLocation or IoCopyCurrentIrpStackLocationToNext to copy the IRP to
   // the next stack location, then call PoCallDriver. Use IoCopyCurrentIrpStackLocationToNext
   // if processing the IRP requires setting a completion routine, or IoSkipCurrentStackLocation
   // if no completion routine is needed.

   PoCallDriver(DeviceExtension->TopOfStackDeviceObject,irp);

   CMUSB_DecrementIoCount(deviceObject);


   DeviceExtension->PowerIrp = NULL;

   SmartcardDebug(DEBUG_TRACE,("%s!PoRequestCompletion Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}




/*****************************************************************************

Routine Description:

    This routine is called when An IRP_MN_SET_POWER of type 'DevicePowerState'
    has been received by CMUSB_ProcessPowerIrp(), and that routine has  determined
        1) the request is for full powerup ( to PowerDeviceD0 ), and
        2) We are not already in that state
    A call is then made to PoRequestPowerIrp() with this routine set as the completion routine.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final NTStatus from the operation.

*****************************************************************************/
NTSTATUS CMUSB_PowerIrp_Complete(
                                IN PDEVICE_OBJECT NullDeviceObject,
                                IN PIRP           Irp,
                                IN PVOID          Context
                                )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PDEVICE_OBJECT deviceObject;
   PIO_STACK_LOCATION irpStack;
   PDEVICE_EXTENSION DeviceExtension;

   SmartcardDebug(DEBUG_TRACE,("%s!PowerIrp_Complete Enter\n",DRIVER_NAME));

   deviceObject = (PDEVICE_OBJECT) Context;

   DeviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;


   // if there was a card in the reader set the state to unknown,
   // because we dont know if the card instered is the same as before power down
   if (DeviceExtension->SmartcardExtension.ReaderExtension->ulNewCardState == INSERTED ||
       DeviceExtension->SmartcardExtension.ReaderExtension->ulNewCardState == POWERED    )
      {
      DeviceExtension->SmartcardExtension.ReaderExtension->ulOldCardState = UNKNOWN;
      DeviceExtension->SmartcardExtension.ReaderExtension->ulNewCardState = UNKNOWN;
      }
   KeSetEvent(&DeviceExtension->CanRunUpdateThread, 0, FALSE);


   //  If the lower driver returned PENDING, mark our stack location as pending also.
   if (Irp->PendingReturned == TRUE)
      {
      IoMarkIrpPending(Irp);
      }

   irpStack = IoGetCurrentIrpStackLocation (Irp);

   // We can assert that we're a  device powerup-to D0 request,
   // because that was the only type of request we set a completion routine
   // for in the first place
   CMUSB_ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
   CMUSB_ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
   CMUSB_ASSERT(irpStack->Parameters.Power.Type==DevicePowerState);
   CMUSB_ASSERT(irpStack->Parameters.Power.State.DeviceState==PowerDeviceD0);

   // Now that we know we've let the lower drivers do what was needed to power up,
   //  we can set our device extension flags accordingly
   DeviceExtension->CurrentDevicePowerState = PowerDeviceD0;

   Irp->IoStatus.Status = NTStatus;

   CMUSB_DecrementIoCount(deviceObject);

   KeSetEvent(&DeviceExtension->ReaderEnabled, 0, FALSE);

   SmartcardDebug(DEBUG_TRACE,("%s!PowerIrp_Complete Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}



/*****************************************************************************

Routine Description:

        Called on CMUSB_PnPAddDevice() to power down until needed (i.e., till a pipe is actually opened).
        Called on CMUSB_Create() to power up device to D0 before opening 1st pipe.
        Called on CMUSB_Close() to power down device if this is the last pipe.

Arguments:

    DeviceObject - Pointer to the device object

    fSuspend; TRUE to Suspend, FALSE to acivate.


Return Value:

    If the operation is not attemtped, SUCCESS is returned.
    If the operation is attemtped, the value is the final NTStatus from the operation.


*****************************************************************************/
NTSTATUS CMUSB_SelfSuspendOrActivate(
                                    IN PDEVICE_OBJECT DeviceObject,
                                    IN BOOLEAN fSuspend
                                    )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;

   POWER_STATE PowerState;
   PDEVICE_EXTENSION DeviceExtension;


   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardDebug( DEBUG_TRACE,("%s!SelfSuspendOrActivate: Enter, fSuspend = %d\n",DRIVER_NAME,fSuspend));


   // Can't accept request if:
   //  1) device is removed,
   //  2) has never been started,
   //  3) is stopped,
   //  4) has a remove request pending,
   //  5) has a stop device pending
   if (CMUSB_CanAcceptIoRequests( DeviceObject ) == FALSE)
      {
      NTStatus = STATUS_DELETE_PENDING;

      SmartcardDebug( DEBUG_TRACE,("%s!SelfSuspendOrActivate: ABORTING\n",DRIVER_NAME));
      return NTStatus;
      }


   // don't do anything if any System-generated Device Pnp irps are pending
   if ( DeviceExtension->PowerIrp != NULL)
      {
      SmartcardDebug( DEBUG_TRACE,("%s!SelfSuspendOrActivate: Exit, refusing on pending DeviceExtension->PowerIrp 0x%x\n",DRIVER_NAME,DeviceExtension->PowerIrp));
      return NTStatus;
      }

   // don't do anything if any self-generated Device Pnp irps are pending
   if ( DeviceExtension->SelfPowerIrp == TRUE)
      {
      SmartcardDebug( DEBUG_TRACE,("%s!SelfSuspendOrActivate: Exit, refusing on pending DeviceExtension->SelfPowerIrp\n",DRIVER_NAME));
      return NTStatus;
      }


   // dont do anything if registry CurrentControlSet\Services\CMUSB\Parameters\PowerDownLevel
   //  has been set to  zero, PowerDeviceD0 ( 1 ), or a bogus high value
   if ( ( DeviceExtension->PowerDownLevel == PowerDeviceD0 )         ||
        ( DeviceExtension->PowerDownLevel == PowerDeviceUnspecified) ||
        ( DeviceExtension->PowerDownLevel >= PowerDeviceMaximum )      )
      {
      SmartcardDebug( DEBUG_TRACE,("%s!SelfSuspendOrActivate: Exit, refusing on DeviceExtension->PowerDownLevel == %d\n",DRIVER_NAME,DeviceExtension->PowerDownLevel));
      return NTStatus;
      }

   if ( fSuspend == TRUE)
      PowerState.DeviceState = DeviceExtension->PowerDownLevel;
   else
      PowerState.DeviceState = PowerDeviceD0;  // power up all the way; we're probably just about to do some IO

   NTStatus = CMUSB_SelfRequestPowerIrp( DeviceObject, PowerState );

   SmartcardDebug( DEBUG_TRACE,("%s!SelfSuspendOrActivate: Exit, NTStatus 0x%x on setting dev state %s\n",DRIVER_NAME,NTStatus, CMUSB_StringForDevState(PowerState.DeviceState ) ));

   return NTStatus;

}


/*****************************************************************************

Routine Description:

    This routine is called by CMUSB_SelfSuspendOrActivate() to
    actually make the system request for a powerdown/up to PowerState.
    It first checks to see if we are already in Powerstate and immediately
    returns  SUCCESS with no further processing if so


Arguments:

    DeviceObject - Pointer to the device object

    PowerState. power state requested, e.g PowerDeviceD0.


Return Value:

    The function value is the final NTStatus from the operation.

*****************************************************************************/
NTSTATUS CMUSB_SelfRequestPowerIrp(
                                  IN PDEVICE_OBJECT DeviceObject,
                                  IN POWER_STATE PowerState
                                  )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   NTSTATUS waitStatus;
   PDEVICE_EXTENSION DeviceExtension;
   PIRP pIrp = NULL;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SelfRequestPowerIrp: request power irp to state %s\n",DRIVER_NAME));

   DeviceExtension =  DeviceObject->DeviceExtension;

   // This should have been reset in completion routine
   CMUSB_ASSERT( !DeviceExtension->SelfPowerIrp );

   if (  DeviceExtension->CurrentDevicePowerState ==  PowerState.DeviceState )
      return STATUS_SUCCESS;  // nothing to do

   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!SelfRequestPowerIrp: request power irp to state %s\n",DRIVER_NAME,
                   CMUSB_StringForDevState( PowerState.DeviceState )));

   CMUSB_IncrementIoCount(DeviceObject);

   // flag we're handling a self-generated power irp
   DeviceExtension->SelfPowerIrp = TRUE;

   // actually request the Irp
   NTStatus = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject,
                                IRP_MN_SET_POWER,
                                PowerState,
                                CMUSB_PoSelfRequestCompletion,
                                DeviceObject,
                                NULL);


   if ( NTStatus == STATUS_PENDING )
      {
      // NTStatus pending is the return code we wanted

      // We only need to wait for completion if we're powering up
      if ( (ULONG) PowerState.DeviceState < DeviceExtension->PowerDownLevel )
         {
         waitStatus = KeWaitForSingleObject(&DeviceExtension->SelfRequestedPowerIrpEvent,
                                            Suspended,
                                            KernelMode,
                                            FALSE,
                                            NULL);
         }

      NTStatus = STATUS_SUCCESS;

      DeviceExtension->SelfPowerIrp = FALSE;
      }
   else
      {
      // The return NTStatus was not STATUS_PENDING; any other codes must be considered in error here;
      //  i.e., it is not possible to get a STATUS_SUCCESS  or any other non-error return from this call;
      }


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SelfRequestPowerIrp: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}



/*****************************************************************************

Routine Description:

    This routine is called when the driver completes a self-originated power IRP
   that was generated by a call to CMUSB_SelfSuspendOrActivate().
    We power down whenever the last pipe is closed and power up when the first pipe is opened.

    For power-up , we set an event in our FDO extension to signal this IRP done
    so the power request can be treated as a synchronous call.
    We need to know the device is powered up before opening the first pipe, for example.
    For power-down, we do not set the event, as no caller waits for powerdown complete.

Arguments:

    DeviceObject - Pointer to the device object for the class device. ( Physical Device Object )

    Context - Driver defined context, in this case our FDO ( functional device object )

Return Value:

    The function value is the final NTStatus from the operation.

*****************************************************************************/
NTSTATUS CMUSB_PoSelfRequestCompletion(
                                      IN PDEVICE_OBJECT       DeviceObject,
                                      IN UCHAR                MinorFunction,
                                      IN POWER_STATE          PowerState,
                                      IN PVOID                Context,
                                      IN PIO_STATUS_BLOCK     IoStatus
                                      )
{
   PDEVICE_OBJECT deviceObject = Context;
   PDEVICE_EXTENSION DeviceExtension = deviceObject->DeviceExtension;
   NTSTATUS NTStatus = IoStatus->Status;

   // we should not be in the midst of handling a system-generated power irp
   CMUSB_ASSERT( NULL == DeviceExtension->PowerIrp );

   // We only need to set the event if we're powering up;
   // No caller waits on power down complete
   if ( (ULONG) PowerState.DeviceState < DeviceExtension->PowerDownLevel )
      {
      // Trigger Self-requested power irp completed event;
      //  The caller is waiting for completion
      KeSetEvent(&DeviceExtension->SelfRequestedPowerIrpEvent, 1, FALSE);
      }

   CMUSB_DecrementIoCount(deviceObject);


   return NTStatus;
}


/*****************************************************************************

Routine Description:

    This routine is called when An IRP_MN_SET_POWER of type 'DevicePowerState'
    has been received by CMUSB_ProcessPowerIrp().


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    DeviceState - Device specific power state to set the device in to.


Return Value:

    For requests to DeviceState D0 ( fully on ), returns TRUE to signal caller
    that we must set a completion routine and finish there.

*****************************************************************************/
BOOLEAN CMUSB_SetDevicePowerState(
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN DEVICE_POWER_STATE DeviceState
                                 )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PDEVICE_EXTENSION DeviceExtension;
   BOOLEAN fRes = FALSE;

   SmartcardDebug(DEBUG_TRACE,("%s!SetDevicePowerState Enter\n",DRIVER_NAME));

   DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

   switch (DeviceState)
      {
      case PowerDeviceD3:
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!SetDevicePowerState PowerDeviceD3 \n",DRIVER_NAME));


         DeviceExtension->CurrentDevicePowerState = DeviceState;

         KeClearEvent(&DeviceExtension->ReaderEnabled);

         CMUSB_StopCardTracking(DeviceObject);

         break;

      case PowerDeviceD1:
      case PowerDeviceD2:
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!SetDevicePowerState PowerDeviceD1/2 \n",DRIVER_NAME));
         //
         // power states D1,D2 translate to USB suspend


         DeviceExtension->CurrentDevicePowerState = DeviceState;
         break;

      case PowerDeviceD0:
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!SetDevicePowerState PowerDeviceD0 \n",DRIVER_NAME));


         // We'll need to finish the rest in the completion routine;
         //   signal caller we're going to D0 and will need to set a completion routine
         fRes = TRUE;

         // Caller will pass on to PDO ( Physical Device object )

         //
         // start update thread be signal that it should not run now
         // this thread should be started in completion rourine
         // but there we have a wrong IRQL for creating a thread
         //
         KeClearEvent(&DeviceExtension->CanRunUpdateThread);
         NTStatus = CMUSB_StartCardTracking(DeviceObject);

         break;

      default:
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!SetDevicePowerState Inalid device power state \n",DRIVER_NAME));

      }

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetDevicePowerState Exit\n",DRIVER_NAME));
   return fRes;
}



/*****************************************************************************

Routine Description:

    This routine generates an internal IRP from this driver to the PDO
    to obtain information on the Physical Device Object's capabilities.
    We are most interested in learning which system power states
    are to be mapped to which device power states for honoring IRP_MJ_SET_POWER Irps.

    This is a blocking call which waits for the IRP completion routine
    to set an event on finishing.

Arguments:

    DeviceObject        - Physical DeviceObject for this USB controller.

Return Value:

    NTSTATUS value from the IoCallDriver() call.

*****************************************************************************/
NTSTATUS CMUSB_QueryCapabilities(
                                IN PDEVICE_OBJECT PdoDeviceObject,
                                IN PDEVICE_CAPABILITIES DeviceCapabilities
                                )
{
   PIO_STACK_LOCATION nextStack;
   PIRP irp;
   NTSTATUS NTStatus;
   KEVENT event;


   // This is a DDK-defined DBG-only macro that ASSERTS we are not running pageable code
   // at higher than APC_LEVEL.
   PAGED_CODE();


   // Build an IRP for us to generate an internal query request to the PDO
   irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);

   if (irp == NULL)
      {
      return STATUS_INSUFFICIENT_RESOURCES;
      }


   //
   // Preinit the device capability structures appropriately.
   //
   RtlZeroMemory( DeviceCapabilities, sizeof(DEVICE_CAPABILITIES) );
   DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
   DeviceCapabilities->Version = 1;
   DeviceCapabilities->Address = -1;
   DeviceCapabilities->UINumber = -1;

   // IoGetNextIrpStackLocation gives a higher level driver access to the next-lower
   // driver's I/O stack location in an IRP so the caller can set it up for the lower driver.
   nextStack = IoGetNextIrpStackLocation(irp);
   CMUSB_ASSERT(nextStack != NULL);
   nextStack->MajorFunction= IRP_MJ_PNP;
   nextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;

   // init an event to tell us when the completion routine's been called
   KeInitializeEvent(&event, NotificationEvent, FALSE);

   // Set a completion routine so it can signal our event when
   //  the next lower driver is done with the Irp
   IoSetCompletionRoutine(irp,
                          CMUSB_IrpCompletionRoutine,
                          &event,  // pass the event as Context to completion routine
                          TRUE,    // invoke on success
                          TRUE,    // invoke on error
                          TRUE);   // invoke on cancellation of the Irp


   // set our pointer to the DEVICE_CAPABILITIES struct
   nextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

   // preset the irp to report not supported
   irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

   NTStatus = IoCallDriver(PdoDeviceObject,
                           irp);


   if (NTStatus == STATUS_PENDING)
      {
      // wait for irp to complete

      KeWaitForSingleObject(&event,
                            Suspended,
                            KernelMode,
                            FALSE,
                            NULL);

      NTStatus = irp->IoStatus.Status;
      }


   IoFreeIrp(irp);

   return NTStatus;
}





/*****************************************************************************
Routine Description:

  Installable driver initialization entry point.
  This entry point is called directly by the I/O system.

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS DriverEntry(
                    IN PDRIVER_OBJECT DriverObject,
                    IN PUNICODE_STRING RegistryPath
                    )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PDEVICE_OBJECT deviceObject = NULL;
   BOOLEAN fRes;
   ULONG ulIndex;

//#if DBG
//   SmartcardSetDebugLevel(DEBUG_ALL);
//#endif

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!DriverEntry: Enter - %s %s\n",DRIVER_NAME,__DATE__,__TIME__));

   //
   // Create dispatch points for create, close, unload
   DriverObject->MajorFunction[IRP_MJ_CREATE]  = CMUSB_CreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLOSE]   = CMUSB_CreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP] = CMUSB_Cleanup;
   DriverObject->DriverUnload                  = CMUSB_Unload;

   // User mode DeviceIoControl() calls will be routed here
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = CMUSB_ProcessIOCTL;

   // routines for handling system PNP and power management requests
   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = CMUSB_ProcessSysControlIrp;
   DriverObject->MajorFunction[IRP_MJ_PNP] = CMUSB_ProcessPnPIrp;
   DriverObject->MajorFunction[IRP_MJ_POWER] = CMUSB_ProcessPowerIrp;

   // The Functional Device Object (FDO) will not be created for PNP devices until
   // this routine is called upon device plug-in.
   DriverObject->DriverExtension->AddDevice = CMUSB_PnPAddDevice;

   for (ulIndex = 0;ulIndex < MAXIMUM_OEM_NAMES;ulIndex++)
      {
      OemName[ulIndex].Buffer = OemNameBuffer[ulIndex];
      OemName[ulIndex].MaximumLength = sizeof(OemNameBuffer[ulIndex]);
      }

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!DriverEntry: Exit\n",DRIVER_NAME));
   return NTStatus;
}





/*****************************************************************************
Routine Description:

   Main dispatch table routine for IRP_MJ_SYSTEM_CONTROL
   We basically just pass these down to the PDO

Arguments:

    DeviceObject - pointer to FDO device object

    Irp          - pointer to an I/O Request Packet

Return Value:

   Status returned from lower driver
*****************************************************************************/
NTSTATUS CMUSB_ProcessSysControlIrp(
                                   IN PDEVICE_OBJECT DeviceObject,
                                   IN PIRP           Irp
                                   )
{

   PIO_STACK_LOCATION irpStack;
   PDEVICE_EXTENSION DeviceExtension;
   NTSTATUS NTStatus = STATUS_SUCCESS;
   NTSTATUS waitStatus;
   PDEVICE_OBJECT stackDeviceObject;

   //
   // Get a pointer to the current location in the Irp. This is where
   //     the function codes and parameters are located.
   //

   irpStack = IoGetCurrentIrpStackLocation (Irp);

   //
   // Get a pointer to the device extension
   //

   DeviceExtension = DeviceObject->DeviceExtension;
   stackDeviceObject = DeviceExtension->TopOfStackDeviceObject;


   CMUSB_IncrementIoCount(DeviceObject);

   CMUSB_ASSERT( IRP_MJ_SYSTEM_CONTROL == irpStack->MajorFunction );

   IoCopyCurrentIrpStackLocationToNext(Irp);


   NTStatus = IoCallDriver(stackDeviceObject,
                           Irp);

   CMUSB_DecrementIoCount(DeviceObject);

   return NTStatus;
}


/*****************************************************************************
Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:

*****************************************************************************/
VOID CMUSB_Unload(
                 IN PDRIVER_OBJECT DriverObject
                 )
{

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Unload enter\n",DRIVER_NAME));

   //
   // Free any global resources allocated
   // in DriverEntry.
   // We have few or none because for a PNP device, almost all
   // allocation is done in PnpAddDevice() and all freeing
   // while handling IRP_MN_REMOVE_DEVICE:
   //


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Unload exit\n",DRIVER_NAME));
}


/*****************************************************************************
Routine Description:
   Trys to read the reader name from the registry

Arguments:
   DriverObject context of call
   SmartcardExtension   ptr to smartcard extension

Return Value:
   none

******************************************************************************/
NTSTATUS CMUSB_SetVendorAndIfdName(
                                  IN  PDEVICE_OBJECT PhysicalDeviceObject,
                                  IN  PSMARTCARD_EXTENSION SmartcardExtension
                                  )
{

   RTL_QUERY_REGISTRY_TABLE   parameters[3];
   UNICODE_STRING             vendorNameU;
   ANSI_STRING                vendorNameA;
   UNICODE_STRING             ifdTypeU;
   ANSI_STRING                ifdTypeA;
   HANDLE                     regKey = NULL;
   ULONG                      ulIndex;
   ULONG                      ulInstance;
   CHAR                       strBuffer[64];
   USHORT                     usStrLength;

   RtlZeroMemory (parameters, sizeof(parameters));
   RtlZeroMemory (&vendorNameU, sizeof(vendorNameU));
   RtlZeroMemory (&vendorNameA, sizeof(vendorNameA));
   RtlZeroMemory (&ifdTypeU, sizeof(ifdTypeU));
   RtlZeroMemory (&ifdTypeA, sizeof(ifdTypeA));

   try
      {
      //
      // try to read the reader name from the registry
      // if that does not work, we will use the default
      // (hardcoded) name
      //
      if (IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                  PLUGPLAY_REGKEY_DEVICE,
                                  KEY_READ,
                                  &regKey) != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: IoOpenDeviceRegistryKey failed\n",DRIVER_NAME));
         leave;
         }

      parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[0].Name = L"VendorName";
      parameters[0].EntryContext = &vendorNameU;
      parameters[0].DefaultType = REG_SZ;
      parameters[0].DefaultData = &vendorNameU;
      parameters[0].DefaultLength = 0;

      parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[1].Name = L"IfdType";
      parameters[1].EntryContext = &ifdTypeU;
      parameters[1].DefaultType = REG_SZ;
      parameters[1].DefaultData = &ifdTypeU;
      parameters[1].DefaultLength = 0;

      if (RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                 (PWSTR) regKey,
                                 parameters,
                                 NULL,
                                 NULL) != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: RtlQueryRegistryValues failed\n",DRIVER_NAME));
         leave;
         }

      if (RtlUnicodeStringToAnsiString(&vendorNameA,&vendorNameU,TRUE) != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: RtlUnicodeStringToAnsiString failed\n",DRIVER_NAME));
         leave;
         }

      if (RtlUnicodeStringToAnsiString(&ifdTypeA,&ifdTypeU,TRUE) != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: RtlUnicodeStringToAnsiString failed\n",DRIVER_NAME));
         leave;
         }

      if (vendorNameA.Length == 0 ||
          vendorNameA.Length > MAXIMUM_ATTR_STRING_LENGTH ||
          ifdTypeA.Length == 0 ||
          ifdTypeA.Length > MAXIMUM_ATTR_STRING_LENGTH)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: vendor name or ifdtype not found or to long\n",DRIVER_NAME));
         leave;
         }

      RtlCopyMemory(SmartcardExtension->VendorAttr.VendorName.Buffer,
                    vendorNameA.Buffer,
                    vendorNameA.Length);
      SmartcardExtension->VendorAttr.VendorName.Length = vendorNameA.Length;

      RtlCopyMemory(SmartcardExtension->VendorAttr.IfdType.Buffer,
                    ifdTypeA.Buffer,
                    ifdTypeA.Length);
      SmartcardExtension->VendorAttr.IfdType.Length = ifdTypeA.Length;

      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!SetVendorAndIfdName: overwritting vendor name and ifdtype\n",DRIVER_NAME));

      }

   finally
      {
      if (vendorNameU.Buffer != NULL)
         {
         RtlFreeUnicodeString(&vendorNameU);
         }
      if (vendorNameA.Buffer != NULL)
         {
         RtlFreeAnsiString(&vendorNameA);
         }
      if (ifdTypeU.Buffer != NULL)
         {
         RtlFreeUnicodeString(&ifdTypeU);
         }
      if (ifdTypeA.Buffer != NULL)
         {
         RtlFreeAnsiString(&ifdTypeA);
         }
      if (regKey != NULL)
         {
         ZwClose (regKey);
         }
      }

   // correct the unit number
   ifdTypeA.Buffer=strBuffer;
   ifdTypeA.MaximumLength=sizeof(strBuffer);
   usStrLength = (SmartcardExtension->VendorAttr.IfdType.Length < ifdTypeA.MaximumLength) ? SmartcardExtension->VendorAttr.IfdType.Length : ifdTypeA.MaximumLength;
   RtlCopyMemory(ifdTypeA.Buffer,
                 SmartcardExtension->VendorAttr.IfdType.Buffer,
                 usStrLength);
   ifdTypeA.Length = usStrLength;

   ulIndex=0;
   while (ulIndex < MAXIMUM_OEM_NAMES &&
          OemName[ulIndex].Length > 0 &&
          RtlCompareMemory (ifdTypeA.Buffer, OemName[ulIndex].Buffer, OemName[ulIndex].Length) != OemName[ulIndex].Length)
      {
      ulIndex++;
      }

   if (ulIndex == MAXIMUM_OEM_NAMES)
      {
      // maximum number of OEM names reached
      return STATUS_INSUFFICIENT_RESOURCES;
      }

   if (OemName[ulIndex].Length == 0)
      {
      // new OEM reader name
      usStrLength = (ifdTypeA.Length < OemName[ulIndex].MaximumLength) ? ifdTypeA.Length : OemName[ulIndex].MaximumLength;
      RtlCopyMemory(OemName[ulIndex].Buffer,
                    ifdTypeA.Buffer,
                    usStrLength);
      OemName[ulIndex].Length = usStrLength;
      }

   for (ulInstance = 0;ulInstance < MAXIMUM_USB_READERS;ulInstance++)
      {
      if (OemDeviceSlot[ulIndex][ulInstance] == FALSE)
         {
         OemDeviceSlot[ulIndex][ulInstance] = TRUE;
         break;
         }
      }

   if (ulInstance == MAXIMUM_USB_READERS)
      {
      return STATUS_INSUFFICIENT_RESOURCES;
      }

   SmartcardExtension->VendorAttr.UnitNo = ulInstance;
   SmartcardExtension->ReaderExtension->ulOemDeviceInstance = ulInstance;
   SmartcardExtension->ReaderExtension->ulOemNameIndex = ulIndex;

   return STATUS_SUCCESS;
}


/*****************************************************************************
Routine Description:

    Creates a Functional DeviceObject

Arguments:

    DriverObject - pointer to the driver object for device

    DeviceObject - pointer to DeviceObject pointer to return
                    created device object.

    Instance - instance of the device create.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

*****************************************************************************/
NTSTATUS CMUSB_CreateDeviceObject(
                                 IN PDRIVER_OBJECT DriverObject,
                                 IN PDEVICE_OBJECT PhysicalDeviceObject,
                                 IN PDEVICE_OBJECT *DeviceObject
                                 )
{
   UNICODE_STRING             deviceNameUnicodeString;
   UNICODE_STRING             Tmp;
   NTSTATUS                   NTStatus = STATUS_SUCCESS;
   ULONG                      deviceInstance;
   PDEVICE_EXTENSION          DeviceExtension;
   PREADER_EXTENSION          readerExtension;
   PSMARTCARD_EXTENSION       SmartcardExtension;
   WCHAR                      Buffer[64];


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CreateDeviceObject: Enter\n",DRIVER_NAME));

   for ( deviceInstance = 0;deviceInstance < MAXIMUM_USB_READERS;deviceInstance++ )
      {
      if (DeviceSlot[deviceInstance] == FALSE)
         {
         DeviceSlot[deviceInstance] = TRUE;
         break;
         }
      }

   if (deviceInstance == MAXIMUM_USB_READERS)
      {
      return STATUS_INSUFFICIENT_RESOURCES;
      }

   //
   //   construct the device name
   //
   deviceNameUnicodeString.Buffer = Buffer;
   deviceNameUnicodeString.MaximumLength = sizeof(Buffer);
   deviceNameUnicodeString.Length = 0;
   RtlInitUnicodeString(&Tmp,CARDMAN_USB_DEVICE_NAME);
   RtlCopyUnicodeString(&deviceNameUnicodeString,&Tmp);
   Tmp.Buffer =  deviceNameUnicodeString.Buffer + deviceNameUnicodeString.Length / sizeof(WCHAR);
   Tmp.MaximumLength = 2 * sizeof(WCHAR);
   Tmp.Length = 0;
   RtlIntegerToUnicodeString(deviceInstance,10,&Tmp);
   deviceNameUnicodeString.Length = (USHORT)( deviceNameUnicodeString.Length+Tmp.Length);



   // Create the device object
   NTStatus = IoCreateDevice(DriverObject,
                             sizeof(DEVICE_EXTENSION),
                             &deviceNameUnicodeString,
                             FILE_DEVICE_SMARTCARD,
                             0,
                             TRUE,
                             DeviceObject);

   if (NTStatus != STATUS_SUCCESS)
      {
      return NTStatus;
      }


   // ----------------------------------------------
   //   initialize device extension
   // ----------------------------------------------

   DeviceExtension = (*DeviceObject)->DeviceExtension;
   DeviceExtension->DeviceInstance =  deviceInstance;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;


   // Used for reading from pipe 1
   KeInitializeEvent(&DeviceExtension->ReadP1Completed,
                     NotificationEvent,
                     FALSE);

   // Used to keep track of open close calls
   KeInitializeEvent(&DeviceExtension->RemoveEvent,
                     NotificationEvent,
                     TRUE);

   KeInitializeSpinLock(&DeviceExtension->SpinLock);
   
   // this event is triggered when self-requested power irps complete
   KeInitializeEvent(&DeviceExtension->SelfRequestedPowerIrpEvent, NotificationEvent, FALSE);

   // this event is triggered when there is no pending io  (pending io count == 1 )
   KeInitializeEvent(&DeviceExtension->NoPendingIoEvent, NotificationEvent, FALSE);


   // Used for update thread notification after hibernation
   KeInitializeEvent(&DeviceExtension->CanRunUpdateThread,
                     NotificationEvent,
                     TRUE);

   // Blocks IOControls during hibernation
   KeInitializeEvent(&DeviceExtension->ReaderEnabled,
                     NotificationEvent,
                     TRUE);



   // ----------------------------------------------
   //   create reader extension
   // ----------------------------------------------
   SmartcardExtension->ReaderExtension = ExAllocatePool(NonPagedPool,
                                                        sizeof(READER_EXTENSION));

   if (SmartcardExtension->ReaderExtension == NULL)
      {
      return STATUS_INSUFFICIENT_RESOURCES;
      }

   readerExtension = SmartcardExtension->ReaderExtension;
   RtlZeroMemory(readerExtension, sizeof(READER_EXTENSION));


   // ----------------------------------------------
   //   initialize timers
   // ----------------------------------------------
   KeInitializeTimer(&SmartcardExtension->ReaderExtension->WaitTimer);

   KeInitializeTimer(&SmartcardExtension->ReaderExtension->P1Timer);

   // ----------------------------------------------
   //   initialize mutex
   // ----------------------------------------------
   KeInitializeMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,0L);

   // ----------------------------------------------
   //   create smartcard extension
   // ----------------------------------------------
   // write the version of the lib we use to the smartcard extension
   SmartcardExtension->Version = SMCLIB_VERSION;
   SmartcardExtension->SmartcardRequest.BufferSize = CMUSB_BUFFER_SIZE;
   SmartcardExtension->SmartcardReply.BufferSize   = CMUSB_REPLY_BUFFER_SIZE; 

   //
   // Now let the lib allocate the buffer for data transmission
   // We can either tell the lib how big the buffer should be
   // by assigning a value to BufferSize or let the lib
   // allocate the default size
   //
   NTStatus = SmartcardInitialize(SmartcardExtension);

   if (NTStatus != STATUS_SUCCESS)
      {
      // free reader extension
      ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension);
      SmartcardExtension->ReaderExtension = NULL;
      return NTStatus;
      }

   // ----------------------------------------------
   //   initialize smartcard extension
   // ----------------------------------------------
   // Save deviceObject
   SmartcardExtension->OsData->DeviceObject = *DeviceObject;

   // Set up call back functions

   SmartcardExtension->ReaderFunction[RDF_TRANSMIT] =      CMUSB_Transmit;
   SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] =  CMUSB_SetProtocol;
   SmartcardExtension->ReaderFunction[RDF_CARD_POWER] =    CMUSB_CardPower;
   SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] = CMUSB_CardTracking;
   SmartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR] =  CMUSB_IoCtlVendor;


   SmartcardExtension->ReaderExtension->ulDeviceInstance = deviceInstance;
   CMUSB_InitializeSmartcardExtension(SmartcardExtension);

   // try to overwrite with registry values
   NTStatus = CMUSB_SetVendorAndIfdName(PhysicalDeviceObject, SmartcardExtension);
   if (NTStatus != STATUS_SUCCESS)
      {
      // free reader extension
      ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension);
      SmartcardExtension->ReaderExtension = NULL;
      return NTStatus;
      }


   // W2000 is till now the only OS which supports WDM version 1.10
   // So check this to determine if we have an Plug&Play able resource manager
   DeviceExtension->fPnPResourceManager = IoIsWdmVersionAvailable (1,10);
   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!CreateDeviceObject: fPnPManager=%ld\n",DRIVER_NAME,DeviceExtension->fPnPResourceManager));

   if (DeviceExtension->fPnPResourceManager == TRUE)
      {
      if (DeviceExtension->PnPDeviceName.Buffer == NULL)
         {
         // register our new device
         NTStatus = IoRegisterDeviceInterface(PhysicalDeviceObject,
                                              &SmartCardReaderGuid,
                                              NULL,
                                              &DeviceExtension->PnPDeviceName);

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!CreateDeviceObject: PnPDeviceName.Buffer  = %lx\n",DRIVER_NAME,
                         DeviceExtension->PnPDeviceName.Buffer));
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!CreateDeviceObject: PnPDeviceName.BufferLength  = %lx\n",DRIVER_NAME,
                         DeviceExtension->PnPDeviceName.Length));

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!CreateDeviceObject: IoRegisterDeviceInterface returned=%lx\n",DRIVER_NAME,NTStatus));
         }
      else
         {
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!CreateDeviceObject: Interface already exists\n",DRIVER_NAME));
         }
      }
   else
      {
      // ----------------------------------------------
      //    create symbolic link
      // ----------------------------------------------

      NTStatus = SmartcardCreateLink(&DeviceExtension->DosDeviceName,&deviceNameUnicodeString);

      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!CreateDeviceObject: SmartcardCreateLink returned=%lx\n",DRIVER_NAME,NTStatus));
      }


   if (NTStatus != STATUS_SUCCESS)
      {
      ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension);
      SmartcardExtension->ReaderExtension = NULL;
      SmartcardExit(&DeviceExtension->SmartcardExtension);
      IoDeleteDevice(*DeviceObject);
      }


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CreateDeviceObject: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}



/*****************************************************************************
Routine Description:

   Passes a URB to the USBD class driver
   The client device driver passes USB request block (URB) structures
   to the class driver as a parameter in an IRP with Irp->MajorFunction
   set to IRP_MJ_INTERNAL_DEVICE_CONTROL and the next IRP stack location
   Parameters.DeviceIoControl.IoControlCode field set to
   IOCTL_INTERNAL_USB_SUBMIT_URB.

Arguments:

    DeviceObject - pointer to the physical device object (PDO)

    Urb - pointer to an already-formatted Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

*****************************************************************************/
NTSTATUS
CMUSB_CallUSBD(
              IN PDEVICE_OBJECT DeviceObject,
              IN PURB Urb
              )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   NTSTATUS DebugStatus;
   PDEVICE_EXTENSION DeviceExtension;
   PIRP irp;
   KEVENT event;
   IO_STATUS_BLOCK ioStatus;
   PIO_STACK_LOCATION nextStack;


   DeviceExtension = DeviceObject->DeviceExtension;

   //
   // issue a synchronous request
   //

   KeInitializeEvent(&event, NotificationEvent, FALSE);

   irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB,
                                       DeviceExtension->TopOfStackDeviceObject, //Points to the next-lower driver's device object
                                       NULL,       // optional input bufer; none needed here
                                       0,          // input buffer len if used
                                       NULL,       // optional output bufer; none needed here
                                       0,          // output buffer len if used
                                       TRUE,       // If InternalDeviceControl is TRUE the target driver's Dispatch
                                       //  outine for IRP_MJ_INTERNAL_DEVICE_CONTROL or IRP_MJ_SCSI
                                       // is called; otherwise, the Dispatch routine for
                                       // IRP_MJ_DEVICE_CONTROL is called.
                                       &event,     // event to be signalled on completion
                                       &ioStatus); // Specifies an I/O NTStatus block to be set when the request is completed the lower driver.

   if (irp == NULL)
      {
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      goto ExitCallUSBD;
      }


   //
   // Call the class driver to perform the operation.  If the returned NTStatus
   // is PENDING, wait for the request to complete.
   //

   nextStack = IoGetNextIrpStackLocation(irp);
   CMUSB_ASSERT(nextStack != NULL);

   //
   // pass the URB to the USB driver stack
   //
   nextStack->Parameters.Others.Argument1 = Urb;


   NTStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject, irp);


   if (NTStatus == STATUS_PENDING)
      {
      DebugStatus = KeWaitForSingleObject(&event,
                                          Suspended,
                                          KernelMode,
                                          FALSE,
                                          NULL);
      }
   else
      {
      ioStatus.Status = NTStatus;
      }
   /*
   SmartcardDebug( DEBUG_TRACE,("CMUSB_CallUSBD() URB NTStatus = %x NTStatus = %x irp NTStatus %x\n",
       Urb->UrbHeader.Status, NTStatus, ioStatus.Status));
   */
   //
   // USBD maps the error code for us
   //
   NTStatus = ioStatus.Status;

   ExitCallUSBD:
   return NTStatus;
}



/*****************************************************************************
Routine Description:

    Initializes a given instance of the device on the USB and
   selects and saves the configuration.

Arguments:

    DeviceObject - pointer to the physical device object for this instance of the 82930
                    device.


Return Value:

    NT NTStatus code
*****************************************************************************/
NTSTATUS
CMUSB_ConfigureDevice(
                     IN  PDEVICE_OBJECT DeviceObject
                     )
{
   PDEVICE_EXTENSION DeviceExtension;
   NTSTATUS NTStatus;
   PURB urb;
   ULONG siz;


   DeviceExtension = DeviceObject->DeviceExtension;

   CMUSB_ASSERT( DeviceExtension->UsbConfigurationDescriptor == NULL );

   urb = ExAllocatePool(NonPagedPool,
                        sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
   if (urb == NULL)
      return STATUS_INSUFFICIENT_RESOURCES;

   // When USB_CONFIGURATION_DESCRIPTOR_TYPE is specified for DescriptorType
   // in a call to UsbBuildGetDescriptorRequest(),
   // all interface, endpoint, class-specific, and vendor-specific descriptors
   // for the configuration also are retrieved.
   // The caller must allocate a buffer large enough to hold all of this
   // information or the data is truncated without error.
   // Therefore the 'siz' set below is just a 'good guess', and we may have to retry

   siz = sizeof(USB_CONFIGURATION_DESCRIPTOR) + 512;

   // We will break out of this 'retry loop' when UsbBuildGetDescriptorRequest()
   // has a big enough DeviceExtension->UsbConfigurationDescriptor buffer not to truncate
   while ( 1 )
      {

      DeviceExtension->UsbConfigurationDescriptor = ExAllocatePool(NonPagedPool, siz);

      if (DeviceExtension->UsbConfigurationDescriptor == NULL)
         {
         ExFreePool(urb);
         return STATUS_INSUFFICIENT_RESOURCES;
         }

      UsbBuildGetDescriptorRequest(urb,
                                   (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                   USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                   0,
                                   0,
                                   DeviceExtension->UsbConfigurationDescriptor,
                                   NULL,
                                   siz,
                                   NULL);

      NTStatus = CMUSB_CallUSBD(DeviceObject, urb);

      //
      // if we got some data see if it was enough.
      // NOTE: we may get an error in URB because of buffer overrun
      if (urb->UrbControlDescriptorRequest.TransferBufferLength>0 &&
          DeviceExtension->UsbConfigurationDescriptor->wTotalLength > siz)
         {

         siz = DeviceExtension->UsbConfigurationDescriptor->wTotalLength;
         ExFreePool(DeviceExtension->UsbConfigurationDescriptor);
         DeviceExtension->UsbConfigurationDescriptor = NULL;
         }
      else
         {
         break;  // we got it on the first try
         }

      } // end, while (retry loop )

   ExFreePool(urb);
   CMUSB_ASSERT( DeviceExtension->UsbConfigurationDescriptor );

   //
   // We have the configuration descriptor for the configuration we want.
   // Now we issue the select configuration command to get
   // the  pipes associated with this configuration.
   //



   NTStatus = CMUSB_SelectInterface(DeviceObject,
                                    DeviceExtension->UsbConfigurationDescriptor);




   return NTStatus;
}

/*****************************************************************************
Routine Description:

   Initializes an CardMan USB
   This minidriver only supports one interface with one endpoint

Arguments:

    DeviceObject - pointer to the device object for this instance of the
                   CardMan USB device

    ConfigurationDescriptor - pointer to the USB configuration
                    descriptor containing the interface and endpoint
                    descriptors.

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS
CMUSB_SelectInterface(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
                     )
{
   PDEVICE_EXTENSION DeviceExtension;
   NTSTATUS NTStatus;
   PURB urb = NULL;
   ULONG i;
   PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor = NULL;
   PUSBD_INTERFACE_INFORMATION Interface = NULL;
   USHORT siz;


   DeviceExtension = DeviceObject->DeviceExtension;


   //
   // CMUSB driver only supports one interface, we must parse
   // the configuration descriptor for the interface
   // and remember the pipes.
   //

   urb = USBD_CreateConfigurationRequest(ConfigurationDescriptor, &siz);

   if (urb != NULL)
      {

      //
      // USBD_ParseConfigurationDescriptorEx searches a given configuration
      // descriptor and returns a pointer to an interface that matches the
      //  given search criteria. We only support one interface on this device
      //
      interfaceDescriptor =
      USBD_ParseConfigurationDescriptorEx(ConfigurationDescriptor,
                                          ConfigurationDescriptor, //search from start of config  descriptro
                                          -1, // interface number not a criteria; we only support one interface
                                          -1,   // not interested in alternate setting here either
                                          -1,   // interface class not a criteria
                                          -1,   // interface subclass not a criteria
                                          -1    // interface protocol not a criteria
                                         );

      if (interfaceDescriptor == NULL)
         {
         ExFreePool(urb);
         return STATUS_INSUFFICIENT_RESOURCES;
         }

      Interface = &urb->UrbSelectConfiguration.Interface;

      for (i=0; i< Interface->NumberOfPipes; i++)
         {
         //
         // perform any pipe initialization here
         //
         Interface->Pipes[i].MaximumTransferSize = 1000;
         Interface->Pipes[i].PipeFlags = 0;
         }

      UsbBuildSelectConfigurationRequest(urb,
                                         (USHORT) siz,
                                         ConfigurationDescriptor);


      NTStatus = CMUSB_CallUSBD(DeviceObject, urb);

      DeviceExtension->UsbConfigurationHandle =
      urb->UrbSelectConfiguration.ConfigurationHandle;

      }
   else
      {
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      }


   if (NT_SUCCESS(NTStatus))
      {

      //
      // Save the configuration handle for this device
      //

      DeviceExtension->UsbConfigurationHandle =
      urb->UrbSelectConfiguration.ConfigurationHandle;

      DeviceExtension->UsbInterface = ExAllocatePool(NonPagedPool,
                                                     Interface->Length);

      if (DeviceExtension->UsbInterface != NULL)
         {
         ULONG j;

         //
         // save a copy of the interface information returned
         //
         RtlCopyMemory(DeviceExtension->UsbInterface, Interface, Interface->Length);



         //
         // Dump the interface to the debugger
         //
         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: ---------\n",
                                       DRIVER_NAME));
         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: NumberOfPipes 0x%x\n",
                                       DRIVER_NAME,
                                       DeviceExtension->UsbInterface->NumberOfPipes));
         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: Length 0x%x\n",
                                       DRIVER_NAME,
                                       DeviceExtension->UsbInterface->Length));
         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: Alt Setting 0x%x\n",
                                       DRIVER_NAME,
                                       DeviceExtension->UsbInterface->AlternateSetting));
         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: Interface Number 0x%x\n",
                                       DRIVER_NAME,
                                       DeviceExtension->UsbInterface->InterfaceNumber));
         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: Class, subclass, protocol 0x%x 0x%x 0x%x\n",
                                       DRIVER_NAME,
                                       DeviceExtension->UsbInterface->Class,
                                       DeviceExtension->UsbInterface->SubClass,
                                       DeviceExtension->UsbInterface->Protocol));

         // Dump the pipe info

         for (j=0; j<Interface->NumberOfPipes; j++)
            {
            PUSBD_PIPE_INFORMATION pipeInformation;

            pipeInformation = &DeviceExtension->UsbInterface->Pipes[j];

            pipeInformation->MaximumTransferSize = 256;
            pipeInformation->PipeFlags = TRUE;

            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: ---------\n",
                                          DRIVER_NAME));
            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: PipeType 0x%x\n",
                                          DRIVER_NAME,
                                          pipeInformation->PipeType));
            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: EndpointAddress 0x%x\n",
                                          DRIVER_NAME,
                                          pipeInformation->EndpointAddress));
            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: MaxPacketSize 0x%x\n",
                                          DRIVER_NAME,
                                          pipeInformation->MaximumPacketSize));
            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: Interval 0x%x\n",
                                          DRIVER_NAME,
                                          pipeInformation->Interval));
            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: Handle 0x%x\n",
                                          DRIVER_NAME,
                                          pipeInformation->PipeHandle));
            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: MaximumTransferSize 0x%x\n",
                                          DRIVER_NAME,
                                          pipeInformation->MaximumTransferSize));
            }

         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: ---------\n",
                                       DRIVER_NAME));
         }
      }

   if (urb != NULL)
      {
      ExFreePool(urb);
      }

   return NTStatus;
}


/*****************************************************************************
Routine Description:

    Reset a given USB pipe.

    NOTES:

    This will reset the host to Data0 and should also reset the device to Data0

Arguments:

    Ptrs to our FDO and a USBD_PIPE_INFORMATION struct

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS
CMUSB_ResetPipe(
               IN PDEVICE_OBJECT DeviceObject,
               IN PUSBD_PIPE_INFORMATION PipeInfo
               )


{
   NTSTATUS NTStatus;
   PURB urb;
   PDEVICE_EXTENSION DeviceExtension;

   DeviceExtension = DeviceObject->DeviceExtension;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!ResetPipe : Enter\n",
                   DRIVER_NAME)
                 );

   urb = ExAllocatePool(NonPagedPool,
                        sizeof(struct _URB_PIPE_REQUEST));

   if (urb != NULL)
      {

      urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
      urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
      urb->UrbPipeRequest.PipeHandle =
      PipeInfo->PipeHandle;

      NTStatus = CMUSB_CallUSBD(DeviceObject, urb);

      ExFreePool(urb);

      }
   else
      {
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      }


   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!ResetPipe : Exit %lx\n",
                   DRIVER_NAME,NTStatus)
                 );
   return NTStatus;
}




/*****************************************************************************
Routine Description:

        We keep a pending IO count ( extension->PendingIoCount )  in the device extension.
        The first increment of this count is done on adding the device.
        Subsequently, the count is incremented for each new IRP received and
        decremented when each IRP is completed or passed on.

        Transition to 'one' therefore indicates no IO is pending and signals
        DeviceExtension->NoPendingIoEvent. This is needed for processing
        IRP_MN_QUERY_REMOVE_DEVICE

        Transition to 'zero' signals an event ( DeviceExtension->RemoveEvent )
        to enable device removal. This is used in processing for IRP_MN_REMOVE_DEVICE

Arguments:

        DeviceObject -- ptr to our FDO

Return Value:

        DeviceExtension->PendingIoCount
*****************************************************************************/
VOID
CMUSB_DecrementIoCount(
                      IN PDEVICE_OBJECT DeviceObject
                      )
{
   PDEVICE_EXTENSION DeviceExtension;
   LONG ioCount;

   DeviceExtension = DeviceObject->DeviceExtension;

   ioCount = InterlockedDecrement(&DeviceExtension->PendingIoCount);

   if (ioCount==1)
      {
      // trigger no pending io
      KeSetEvent(&DeviceExtension->NoPendingIoEvent,
                 1,
                 FALSE);
      }


   if (ioCount==0)
      {
      // trigger remove-device event

      SmartcardDebug( DEBUG_DRIVER,
                      ("%s!DecrementIoCount: setting RemoveEvent\n",
                       DRIVER_NAME
                      )
                    );


      KeSetEvent(&DeviceExtension->RemoveEvent,
                 1,
                 FALSE);
      }

   return ;
}


/*****************************************************************************
Routine Description:

        We keep a pending IO count ( extension->PendingIoCount )  in the device extension.
        The first increment of this count is done on adding the device.
        Subsequently, the count is incremented for each new IRP received and
        decremented when each IRP is completed or passed on.


Arguments:

        DeviceObject -- ptr to our FDO

Return Value:

        None
*****************************************************************************/
VOID
CMUSB_IncrementIoCount(
                      IN PDEVICE_OBJECT DeviceObject
                      )
{
   PDEVICE_EXTENSION DeviceExtension;

   DeviceExtension = DeviceObject->DeviceExtension;

   InterlockedIncrement(&DeviceExtension->PendingIoCount);

}





/*****************************************************************************
Routine Description:

    Dispatch table handler for IRP_MJ_DEVICE_CONTROL;
    Handle DeviceIoControl() calls  from User mode


Arguments:

    DeviceObject - pointer to the FDO for this instance of the 82930 device.


Return Value:

    NT NTStatus code
*****************************************************************************/
NTSTATUS
CMUSB_ProcessIOCTL(
                  IN PDEVICE_OBJECT DeviceObject,
                  IN PIRP Irp
                  )
{
   NTSTATUS             NTStatus;
   PDEVICE_EXTENSION    DeviceExtension = DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION   irpSL;

   irpSL = IoGetCurrentIrpStackLocation(Irp);

#if DBG
   switch (irpSL->Parameters.DeviceIoControl.IoControlCode)
      {
      case IOCTL_SMARTCARD_EJECT:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_EJECT"));
         break;
      case IOCTL_SMARTCARD_GET_ATTRIBUTE:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_ATTRIBUTE"));
         break;
      case IOCTL_SMARTCARD_GET_LAST_ERROR:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_LAST_ERROR"));
         break;
      case IOCTL_SMARTCARD_GET_STATE:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_STATE"));
         break;
      case IOCTL_SMARTCARD_IS_ABSENT:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_IS_ABSENT"));
         break;
      case IOCTL_SMARTCARD_IS_PRESENT:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_IS_PRESENT"));
         break;
      case IOCTL_SMARTCARD_POWER:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_POWER"));
         break;
      case IOCTL_SMARTCARD_SET_ATTRIBUTE:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SET_ATTRIBUTE"));
         break;
      case IOCTL_SMARTCARD_SET_PROTOCOL:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SET_PROTOCOL"));
         break;
      case IOCTL_SMARTCARD_SWALLOW:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SWALLOW"));
         break;
      case IOCTL_SMARTCARD_TRANSMIT:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_TRANSMIT"));
         break;
      default:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "Vendor specific or unexpected IOCTL"));
         break;
      }
#endif

   CMUSB_IncrementIoCount(DeviceObject);

   NTStatus = KeWaitForSingleObject(&DeviceExtension->ReaderEnabled,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);

   ASSERT(NTStatus == STATUS_SUCCESS);

   // Can't accept a new io request if:
   //  1) device is removed,
   //  2) has never been started,
   //  3) is stopped,
   //  4) has a remove request pending,
   //  5) has a stop device pending
   if (CMUSB_CanAcceptIoRequests( DeviceObject ) == FALSE )
      {
      NTStatus = STATUS_DELETE_PENDING;

      Irp->IoStatus.Status = NTStatus;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest( Irp, IO_NO_INCREMENT );

      CMUSB_DecrementIoCount(DeviceObject);
      return NTStatus;
      }

   NTStatus = SmartcardAcquireRemoveLock(&DeviceExtension->SmartcardExtension);
   if (NTStatus != STATUS_SUCCESS)
      {
      // the device has been removed. Fail the call
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_DELETE_PENDING;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);

      return STATUS_DELETE_PENDING;
      }

   KeWaitForSingleObject(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL);

   NTStatus = CMUSB_UpdateCurrentState (DeviceObject);

   NTStatus = SmartcardDeviceControl(&DeviceExtension->SmartcardExtension,Irp);

   KeReleaseMutex(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                  FALSE);

   SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

   CMUSB_DecrementIoCount(DeviceObject);
   return NTStatus;
}






/*****************************************************************************
Routine Description:

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_ReadP0(
            IN PDEVICE_OBJECT DeviceObject
            )
{
   PURB urb = NULL;
   NTSTATUS NTStatus;
   ULONG i;
   PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadP0: Enter\n",
                  DRIVER_NAME)
                  );
   */
   urb = ExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));


   if (urb != NULL)
      {
      RtlZeroMemory(urb, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));


      UsbBuildVendorRequest(urb,
                            URB_FUNCTION_VENDOR_ENDPOINT,
                            (USHORT)sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
                            USBD_TRANSFER_DIRECTION_IN,
                            0,
                            0,
                            0,
                            0,
                            SmartcardExtension->SmartcardReply.Buffer,
                            NULL,
                            SmartcardExtension->SmartcardReply.BufferLength,
                            NULL);


      NTStatus = CMUSB_CallUSBD(DeviceObject,urb);


      if (NTStatus == STATUS_SUCCESS)
         {
         SmartcardExtension->SmartcardReply.BufferLength = urb->UrbControlVendorClassRequest.TransferBufferLength;

#if DBG
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s!<==[P0] ",
                         DRIVER_NAME)
                       )
         for (i=0;i<SmartcardExtension->SmartcardReply.BufferLength;i++)
            {
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%x ",
                            SmartcardExtension->SmartcardReply.Buffer[i]
                           )
                          );
            }
         SmartcardDebug(DEBUG_PROTOCOL,("\n"));
#endif

         }
      ExFreePool(urb);
      }
   else
      {
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      }


   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadP0  Exit %lx\n",
                  DRIVER_NAME,
                  NTStatus)
                  );
   */

   return NTStatus;
}








/*****************************************************************************
Routine Description:

    Write data through the control pipe to the CardMan USB


Arguments:



Return Value:

    NT NTStatus code
*****************************************************************************/
NTSTATUS
CMUSB_WriteP0(
             IN PDEVICE_OBJECT DeviceObject,
             IN UCHAR bRequest,
             IN UCHAR bValueLo,
             IN UCHAR bValueHi,
             IN UCHAR bIndexLo,
             IN UCHAR bIndexHi
             )
{
   PURB urb = NULL;
   NTSTATUS NTStatus = STATUS_UNSUCCESSFUL;
   USHORT usValue;
   USHORT usIndex;
   ULONG length;
   PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   ULONG ulBytesToWrite;
   ULONG i;

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!WriteP0: Enter\n",
                    DRIVER_NAME)
                  );
   */

#if DBG
   SmartcardDebug(DEBUG_PROTOCOL,
                  ("%s!==>[P0] ",DRIVER_NAME));

   for (i=0;i< SmartcardExtension->SmartcardRequest.BufferLength;i++)
      {
      SmartcardDebug(DEBUG_PROTOCOL,
                     ("%x ",SmartcardExtension->SmartcardRequest.Buffer[i]));
      }

   SmartcardDebug(DEBUG_PROTOCOL,
                  ("(%ld)\n",SmartcardExtension->SmartcardRequest.BufferLength));
#endif
   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ulBytesToWrite = %ld\n",
                  DRIVER_NAME,SmartcardExtension->SmartcardRequest.BufferLength)
                  );
   */


   ulBytesToWrite = SmartcardExtension->SmartcardRequest.BufferLength;

   urb = ExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));


   if (urb != NULL)
      {
      RtlZeroMemory(urb, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));

      usValue  = bValueHi * 256 + bValueLo;
      usIndex  = bIndexHi * 256 + bIndexLo;

      if (ulBytesToWrite != 0)
         {
         UsbBuildVendorRequest (urb,
                                URB_FUNCTION_VENDOR_ENDPOINT,
                                (USHORT)sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
                                0,
                                0,
                                bRequest,
                                usValue,
                                usIndex,
                                SmartcardExtension->SmartcardRequest.Buffer,
                                NULL,
                                ulBytesToWrite,
                                NULL);
         }
      else
         {
         UsbBuildVendorRequest (urb,
                                URB_FUNCTION_VENDOR_ENDPOINT,
                                (USHORT)sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
                                0,
                                0,
                                bRequest,
                                usValue,
                                usIndex,
                                NULL,
                                NULL,
                                0L,
                                NULL);
         }
      NTStatus = CMUSB_CallUSBD(DeviceObject,urb);
      ExFreePool(urb);
      }

   if (NTStatus != STATUS_SUCCESS)
      {
      SmartcardDebug(DEBUG_PROTOCOL,
                     ("%s!WriteP0: Error on exit %lx\n",DRIVER_NAME,NTStatus));
      }

   return NTStatus;
}








/*****************************************************************************
/*++

Routine Description:

   Called as part of sudden device removal handling.
   Cancels any pending transfers for all open pipes.
   If any pipes are still open, call USBD with URB_FUNCTION_ABORT_PIPE
   Also marks the pipe 'closed' in our saved  configuration info.

Arguments:

    Ptrs to our FDO

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS
CMUSB_AbortPipes(
                IN PDEVICE_OBJECT DeviceObject
                )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PURB urb;
   PDEVICE_EXTENSION DeviceExtension;
   PUSBD_INTERFACE_INFORMATION interface;
   PUSBD_PIPE_INFORMATION PipeInfo;

   SmartcardDebug(DEBUG_TRACE,
                  ( "%s!AbortPipes: Enter\n",DRIVER_NAME));

   DeviceExtension = DeviceObject->DeviceExtension;
   interface = DeviceExtension->UsbInterface;

   PipeInfo =  &interface->Pipes[0];

   if (PipeInfo->PipeFlags == TRUE) // we set this if open, clear if closed
      {
      urb = ExAllocatePool(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST));
      if (urb != NULL)
         {

         urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
         urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
         urb->UrbPipeRequest.PipeHandle = PipeInfo->PipeHandle;

         NTStatus = CMUSB_CallUSBD(DeviceObject, urb);

         ExFreePool(urb);
         }
      else
         {
         NTStatus = STATUS_INSUFFICIENT_RESOURCES;
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!AbortPipes: ExAllocatePool failed\n",DRIVER_NAME));
         }


      if (NTStatus == STATUS_SUCCESS)
         {
         PipeInfo->PipeFlags = FALSE; // mark the pipe 'closed'
         }

      } // end, if pipe open


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!AbortPipes: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}



/*****************************************************************************
Routine Description:

  Check device extension NTStatus flags;

     Can't accept a new io request if device:
      1) is removed,
      2) has never been started,
      3) is stopped,
      4) has a remove request pending, or
      5) has a stop device pending


Arguments:

    DeviceObject - pointer to the device object for this instance of the 82930
                    device.


Return Value:

    return TRUE if can accept new io requests, else FALSE
*****************************************************************************/
BOOLEAN
CMUSB_CanAcceptIoRequests(
                         IN PDEVICE_OBJECT DeviceObject
                         )
{
   PDEVICE_EXTENSION DeviceExtension;
   BOOLEAN fCan = FALSE;

   DeviceExtension = DeviceObject->DeviceExtension;

   //flag set when processing IRP_MN_REMOVE_DEVICE
   if ( DeviceExtension->DeviceRemoved == FALSE &&
        // device must be started( enabled )
        DeviceExtension->DeviceStarted == TRUE &&
        // flag set when driver has answered success to IRP_MN_QUERY_REMOVE_DEVICE
        DeviceExtension->RemoveDeviceRequested == FALSE&&
        //flag set when processing IRP_MN_SURPRISE_REMOVAL
        DeviceExtension->DeviceSurpriseRemoval == FALSE&&
        // flag set when driver has answered success to IRP_MN_QUERY_STOP_DEVICE
        DeviceExtension->StopDeviceRequested == FALSE)
      {
      fCan = TRUE;
      }

#if DBG
   if (fCan == FALSE)
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!CanAcceptIoRequests: return FALSE \n",DRIVER_NAME));
#endif

   return fCan;
}




/*****************************************************************************
* History:
* $Log: scusbwdm.c $
* Revision 1.9  2001/01/17 12:36:06  WFrischauf
* No comment given
*
* Revision 1.8  2000/09/25 13:38:23  WFrischauf
* No comment given
*
* Revision 1.7  2000/08/24 09:04:39  TBruendl
* No comment given
*
* Revision 1.6  2000/08/16 08:25:23  TBruendl
* warning :uninitialized memory removed
*
* Revision 1.5  2000/07/24 11:35:01  WFrischauf
* No comment given
*
* Revision 1.1  2000/07/20 11:50:16  WFrischauf
* No comment given
*
*
******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\drvnt5.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       drvnt5.c
//
//--------------------------------------------------------------------------

#include "DriverNT.h"
#include "DrvNT5.h"
#include "CBHndlr.h"
#include "STCCmd.h"
#include "SRVers.h"

// declare pageable/initialization code
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGEABLE, DrvAddDevice )
#pragma alloc_text( PAGEABLE, DrvCreateDevice )
#pragma alloc_text( PAGEABLE, DrvRemoveDevice )
#pragma alloc_text( PAGEABLE, DrvDriverUnload )


//________________________________ D R I V E R   E N T R Y ________________________________________

NTSTATUS
DriverEntry(
   IN  PDRIVER_OBJECT  DriverObject,
   IN  PUNICODE_STRING RegistryPath
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   
   SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DriverEntry: Enter\n"));

   // initialization of the drivers entry points
   DriverObject->DriverUnload                   = DrvDriverUnload;
   DriverObject->MajorFunction[IRP_MJ_CREATE]         = DrvCreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLOSE]       = DrvCreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = DrvCleanup;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DrvDeviceIoControl;
   DriverObject->MajorFunction[IRP_MJ_PNP]            = DrvPnPHandler;
   DriverObject->MajorFunction[IRP_MJ_POWER]       = DrvPowerHandler;
   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = DrvSystemControl;
   DriverObject->DriverExtension->AddDevice        = DrvAddDevice;

   SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DriverEntry: Exit\n"));

   return( NTStatus );
}

//________________________________ I N I T I A L I Z A T I O N ____________________________________

NTSTATUS
DrvAddDevice(
   IN PDRIVER_OBJECT DriverObject,
   IN PDEVICE_OBJECT PhysicalDeviceObject
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   PDEVICE_OBJECT DeviceObject = NULL;
   NTSTATUS NTStatus = STATUS_SUCCESS;
   ULONG deviceInstance;
   UNICODE_STRING vendorNameU, ifdTypeU;
   ANSI_STRING vendorNameA, ifdTypeA;
   HANDLE regKey = NULL;

    // this is a list of our supported data rates
    static ULONG dataRatesSupported[] = {
      9600, 19200, 28800, 38400, 48000, 57600, 67200, 76800, 86400, 96000, 115200
      };

   PAGED_CODE();

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvAddDevice: Enter\n" ));

   __try
   {
      PDEVICE_EXTENSION DeviceExtension;
      PSMARTCARD_EXTENSION SmartcardExtension;
      PREADER_EXTENSION ReaderExtension;
      RTL_QUERY_REGISTRY_TABLE parameters[3];

      RtlZeroMemory(parameters, sizeof(parameters));
      RtlZeroMemory(&vendorNameU, sizeof(vendorNameU));
      RtlZeroMemory(&ifdTypeU, sizeof(ifdTypeU));
      RtlZeroMemory(&vendorNameA, sizeof(vendorNameA));
      RtlZeroMemory(&ifdTypeA, sizeof(ifdTypeA));

      // create the device object
      NTStatus = IoCreateDevice(
         DriverObject,
         sizeof( DEVICE_EXTENSION ),
         NULL,
         FILE_DEVICE_SMARTCARD,
         0,
         TRUE,
         &DeviceObject
         );

      if( NTStatus != STATUS_SUCCESS )
      {
         SmartcardLogError( DriverObject, STC_CANT_CREATE_DEVICE, NULL, 0 );
         __leave;
      }

      // initialize device extension
      DeviceExtension   = DeviceObject->DeviceExtension;
      SmartcardExtension = &DeviceExtension->SmartcardExtension;

      KeInitializeEvent(
            &DeviceExtension->ReaderStarted,
            NotificationEvent,
            FALSE
            );
      // Used to keep track of open close calls
      DeviceExtension->ReaderOpen = FALSE;

      KeInitializeSpinLock(&DeviceExtension->SpinLock);

      // initialize smartcard extension - version & callbacks

      SmartcardExtension->Version = SMCLIB_VERSION;

      SmartcardExtension->ReaderFunction[RDF_TRANSMIT] = CBTransmit;
      SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] = CBSetProtocol;
      SmartcardExtension->ReaderFunction[RDF_CARD_POWER] = CBCardPower;
      SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] = CBCardTracking;

      // initialize smartcard extension - vendor attribute
      RtlCopyMemory(
         SmartcardExtension->VendorAttr.VendorName.Buffer,
         SR_VENDOR_NAME,
         sizeof( SR_VENDOR_NAME )
         );

      SmartcardExtension->VendorAttr.VendorName.Length =
            sizeof( SR_VENDOR_NAME );

      RtlCopyMemory(
         SmartcardExtension->VendorAttr.IfdType.Buffer,
         SR_PRODUCT_NAME,
         sizeof( SR_PRODUCT_NAME )
         );

      SmartcardExtension->VendorAttr.IfdType.Length =
            sizeof( SR_PRODUCT_NAME );

      SmartcardExtension->VendorAttr.UnitNo = MAXULONG;

      for (deviceInstance = 0; deviceInstance < MAXULONG; deviceInstance++) {

         PDEVICE_OBJECT devObj;

         for (devObj = DeviceObject;
             devObj != NULL;
             devObj = devObj->NextDevice) {

             PDEVICE_EXTENSION devExt = devObj->DeviceExtension;
             PSMARTCARD_EXTENSION smcExt = &devExt->SmartcardExtension;

             if (deviceInstance == smcExt->VendorAttr.UnitNo) {

                break;
             }
         }
         if (devObj == NULL) {

            SmartcardExtension->VendorAttr.UnitNo = deviceInstance;
            break;
         }
      }

      SmartcardExtension->VendorAttr.IfdVersion.BuildNumber = 0;

      // initialize smartcard extension - reader capabilities
      SmartcardExtension->ReaderCapabilities.SupportedProtocols =
            SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
      SmartcardExtension->ReaderCapabilities.ReaderType =
            SCARD_READER_TYPE_SERIAL;
      SmartcardExtension->ReaderCapabilities.MechProperties = 0;
      SmartcardExtension->ReaderCapabilities.Channel = 0;
      SmartcardExtension->ReaderCapabilities.MaxIFSD =
         STC_BUFFER_SIZE - PACKET_OVERHEAD;

      SmartcardExtension->ReaderCapabilities.CLKFrequency.Default = 3571;
      SmartcardExtension->ReaderCapabilities.CLKFrequency.Max = 3571;

      SmartcardExtension->ReaderCapabilities.DataRate.Default =
      SmartcardExtension->ReaderCapabilities.DataRate.Max =
          dataRatesSupported[0];

      // reader could support higher data rates
      SmartcardExtension->ReaderCapabilities.DataRatesSupported.List =
         dataRatesSupported;
      SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
         sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);

      SmartcardExtension->ReaderCapabilities.CurrentState   = (ULONG) SCARD_UNKNOWN;

      SmartcardExtension->SmartcardRequest.BufferSize = MIN_BUFFER_SIZE;
      SmartcardExtension->SmartcardReply.BufferSize = MIN_BUFFER_SIZE;

      // allocate & initialize reader extension
      SmartcardExtension->ReaderExtension = ExAllocatePool(
            NonPagedPool,
            sizeof( READER_EXTENSION )
            );

      if( SmartcardExtension->ReaderExtension == NULL )
      {
         SmartcardLogError( DriverObject, STC_NO_MEMORY, NULL, 0 );
         NTStatus = STATUS_INSUFFICIENT_RESOURCES;
         __leave;
      }

      ReaderExtension = SmartcardExtension->ReaderExtension;

      ASSERT( ReaderExtension != NULL );

      RtlZeroMemory(ReaderExtension, sizeof( READER_EXTENSION ));

        ReaderExtension->SmartcardExtension = SmartcardExtension;
        ReaderExtension->ReadTimeout = 5000;

      KeInitializeEvent(
         &ReaderExtension->SerialCloseDone,
         NotificationEvent,
         TRUE
         );

      ReaderExtension->CloseSerial = IoAllocateWorkItem(
         DeviceObject
         );

      ReaderExtension->ReadWorkItem = IoAllocateWorkItem(
         DeviceObject
         );

      if (ReaderExtension->CloseSerial == NULL ||
         ReaderExtension->ReadWorkItem == NULL) {

         NTStatus = STATUS_INSUFFICIENT_RESOURCES;
         __leave;
      }

      KeInitializeEvent(
         &ReaderExtension->DataAvailable,
         NotificationEvent,
         FALSE
         );

      KeInitializeEvent(
         &ReaderExtension->IoEvent,
         NotificationEvent,
         FALSE
         );

      NTStatus = SmartcardInitialize( SmartcardExtension );

      if( NTStatus != STATUS_SUCCESS )
      {
         SmartcardLogError(
            DriverObject,
            (SmartcardExtension->OsData ? STC_WRONG_LIB_VERSION : STC_NO_MEMORY ),
            NULL,
            0
            );
         __leave;
      }
      // Save deviceObject
      SmartcardExtension->OsData->DeviceObject = DeviceObject;

      // save the current Power state of the reader
      SmartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderWorking;

      DeviceExtension   = DeviceObject->DeviceExtension;
      ReaderExtension   = DeviceExtension->SmartcardExtension.ReaderExtension;

      // attach the device object to the physical device object
      ReaderExtension->SerialDeviceObject =
         IoAttachDeviceToDeviceStack(
         DeviceObject,
         PhysicalDeviceObject
         );

      ASSERT( ReaderExtension->SerialDeviceObject != NULL );

      if( ReaderExtension->SerialDeviceObject == NULL )
      {
         SmartcardLogError(
            DriverObject,
            STC_CANT_CONNECT_TO_ASSIGNED_PORT,
            NULL,
            NTStatus
            );
         NTStatus = STATUS_UNSUCCESSFUL;
         __leave;
      }

      // register our new device
      NTStatus = IoRegisterDeviceInterface(
         PhysicalDeviceObject,
         &SmartCardReaderGuid,
         NULL,
         &DeviceExtension->PnPDeviceName
         );

      ASSERT( NTStatus == STATUS_SUCCESS );

      DeviceObject->Flags |= DO_BUFFERED_IO;
      DeviceObject->Flags |= DO_POWER_PAGABLE;
      DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

      //
      // try to read the reader name from the registry
      // if that does not work, we will use the default
      // (hardcoded) name
      //
      if (IoOpenDeviceRegistryKey(
         PhysicalDeviceObject,
         PLUGPLAY_REGKEY_DEVICE,
         KEY_READ,
         &regKey
         ) != STATUS_SUCCESS) {

         __leave;
      }

      parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[0].Name = L"VendorName";
      parameters[0].EntryContext = &vendorNameU;
      parameters[0].DefaultType = REG_SZ;
      parameters[0].DefaultData = &vendorNameU;
      parameters[0].DefaultLength = 0;

      parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[1].Name = L"IfdType";
      parameters[1].EntryContext = &ifdTypeU;
      parameters[1].DefaultType = REG_SZ;
      parameters[1].DefaultData = &ifdTypeU;
      parameters[1].DefaultLength = 0;

      if (RtlQueryRegistryValues(
          RTL_REGISTRY_HANDLE,
          (PWSTR) regKey,
          parameters,
          NULL,
          NULL
          ) != STATUS_SUCCESS) {

         __leave;
      }

      if (RtlUnicodeStringToAnsiString(
         &vendorNameA,
         &vendorNameU,
         TRUE
         ) != STATUS_SUCCESS) {

         __leave;
      }

      if (RtlUnicodeStringToAnsiString(
         &ifdTypeA,
         &ifdTypeU,
         TRUE
         ) != STATUS_SUCCESS) {

         __leave;
      }

      if (vendorNameA.Length == 0 ||
         vendorNameA.Length > MAXIMUM_ATTR_STRING_LENGTH ||
         ifdTypeA.Length == 0 ||
         ifdTypeA.Length > MAXIMUM_ATTR_STRING_LENGTH) {

         __leave;
      }

      RtlCopyMemory(
         SmartcardExtension->VendorAttr.VendorName.Buffer,
         vendorNameA.Buffer,
         vendorNameA.Length
         );
      SmartcardExtension->VendorAttr.VendorName.Length =
         vendorNameA.Length;

      RtlCopyMemory(
         SmartcardExtension->VendorAttr.IfdType.Buffer,
         ifdTypeA.Buffer,
         ifdTypeA.Length
         );
      SmartcardExtension->VendorAttr.IfdType.Length =
         ifdTypeA.Length;
   }
   __finally
   {
      if (vendorNameU.Buffer) {

         RtlFreeUnicodeString(&vendorNameU);
      }

      if (ifdTypeU.Buffer) {

         RtlFreeUnicodeString(&ifdTypeU);
      }

      if (vendorNameA.Buffer) {

         RtlFreeAnsiString(&vendorNameA);
      }

      if (ifdTypeA.Buffer) {

         RtlFreeAnsiString(&ifdTypeA);
      }

      if (regKey != NULL) {

         ZwClose(regKey);
      }

      if (NTStatus != STATUS_SUCCESS) {

         DrvRemoveDevice( DeviceObject );
      }

      SmartcardDebug(
         DEBUG_TRACE,
         ( "SCMSTCS!DrvAddDevice: Exit (%lx)\n", NTStatus )
         );
   }
    return NTStatus;
}

NTSTATUS
DrvStartDevice(
   IN PDEVICE_OBJECT DeviceObject
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS NTStatus;
   PIRP     Irp;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvStartDevice: Enter\n" ));

   Irp = IoAllocateIrp((CCHAR)( DeviceObject->StackSize + 1 ), FALSE );

   ASSERT( Irp != NULL );

   if( Irp != NULL )
   {
      PDEVICE_EXTENSION    DeviceExtension;
      PIO_STACK_LOCATION      IrpStack;
      IO_STATUS_BLOCK         IoStatusBlock;
      PSMARTCARD_EXTENSION SmartcardExtension;
      PREADER_EXTENSION    ReaderExtension;

      DeviceExtension      = DeviceObject->DeviceExtension;
      SmartcardExtension   = &DeviceExtension->SmartcardExtension;
      ReaderExtension      = SmartcardExtension->ReaderExtension;

      ASSERT( DeviceExtension != NULL );
      ASSERT( SmartcardExtension != NULL );
      ASSERT( ReaderExtension != NULL );

      KeClearEvent( &ReaderExtension->SerialCloseDone );

      //
      // send MJ_CREATE to the serial driver. a side effect of this call is that the serial
      // enumerator will be informed about the device and not longer poll the interface
      //
      Irp->UserIosb = &IoStatusBlock;

      IoSetNextIrpStackLocation( Irp );
      IrpStack = IoGetCurrentIrpStackLocation( Irp );

      IrpStack->MajorFunction                = IRP_MJ_CREATE;
      IrpStack->Parameters.Create.Options       = 0;
      IrpStack->Parameters.Create.ShareAccess      = 0;
      IrpStack->Parameters.Create.FileAttributes   = 0;
      IrpStack->Parameters.Create.EaLength      = 0;

      NTStatus = DrvCallSerialDriver(
            ReaderExtension->SerialDeviceObject,
            Irp
            );

      if( NTStatus == STATUS_SUCCESS )
      {
         SERIAL_PORT_CONFIG      COMConfig;

         // configure the serial port
         COMConfig.BaudRate.BaudRate         = SR_BAUD_RATE;
         COMConfig.LineControl.StopBits      = SR_STOP_BITS;
         COMConfig.LineControl.Parity     = SR_PARITY;
         COMConfig.LineControl.WordLength = SR_DATA_LENGTH;

         // timeouts
         COMConfig.Timeouts.ReadIntervalTimeout =
                SR_READ_INTERVAL_TIMEOUT;
         COMConfig.Timeouts.ReadTotalTimeoutConstant  =
                SR_READ_TOTAL_TIMEOUT_CONSTANT;
         COMConfig.Timeouts.ReadTotalTimeoutMultiplier = 0;

         COMConfig.Timeouts.WriteTotalTimeoutConstant =
            SR_WRITE_TOTAL_TIMEOUT_CONSTANT;
         COMConfig.Timeouts.WriteTotalTimeoutMultiplier = 0;

         // special characters
         COMConfig.SerialChars.ErrorChar     = 0;
         COMConfig.SerialChars.EofChar    = 0;
         COMConfig.SerialChars.EventChar     = 0;
         COMConfig.SerialChars.XonChar    = 0;
         COMConfig.SerialChars.XoffChar      = 0;
         COMConfig.SerialChars.BreakChar     = 0;

         // handflow
         COMConfig.HandFlow.XonLimit         = 0;
         COMConfig.HandFlow.XoffLimit     = 0;
         COMConfig.HandFlow.ControlHandShake = 0;
         COMConfig.HandFlow.FlowReplace      =
              SERIAL_XOFF_CONTINUE;

         // miscellenaeous
         COMConfig.WaitMask               = SR_NOTIFICATION_EVENT;
         COMConfig.Purge                  = SR_PURGE;

         NTStatus = IFInitializeInterface( ReaderExtension, &COMConfig );

         if( NTStatus == STATUS_SUCCESS )
         {
            // configure the reader & initialize the card state
            NTStatus = STCConfigureSTC(
                    ReaderExtension,
                    ( PSTC_REGISTER ) STCInitialize
                    );

            CBUpdateCardState( SmartcardExtension, SCARD_UNKNOWN );
            //
            // store firmware revision in ifd version
            //
            STCGetFirmwareRevision( ReaderExtension );
            SmartcardExtension->VendorAttr.IfdVersion.VersionMajor =
               ReaderExtension->FirmwareMajor;
            SmartcardExtension->VendorAttr.IfdVersion.VersionMinor =
               ReaderExtension->FirmwareMinor;
            SmartcardExtension->VendorAttr.IfdSerialNo.Length     = 0;

            if( NTStatus == STATUS_SUCCESS )
            {
               NTStatus = IoSetDeviceInterfaceState(
                        &DeviceExtension->PnPDeviceName,
                        TRUE
                        );

               if( NTStatus == STATUS_SUCCESS )
               {
                  KeSetEvent( &DeviceExtension->ReaderStarted, 0, FALSE );
               }
            }
            else
            {
               SmartcardLogError( DeviceObject, STC_NO_READER_FOUND, NULL, 0 );
            }
         }
         else
         {
            SmartcardLogError( DeviceObject, STC_ERROR_INIT_INTERFACE, NULL, 0 );
         }
      }
      else
      {
         SmartcardLogError( DeviceObject, STC_CONNECT_FAILS, NULL, 0 );
      }
      IoFreeIrp( Irp );
   }
   else
   {
      SmartcardLogError( DeviceObject, STC_NO_MEMORY, NULL, 0 );
      NTStatus = STATUS_NO_MEMORY;
   }

    if (NTStatus != STATUS_SUCCESS) {

        DrvStopDevice(DeviceObject->DeviceExtension);
    }

   SmartcardDebug(
        (NTStatus == STATUS_SUCCESS ? DEBUG_TRACE : DEBUG_ERROR),
        ( "SCMSTCS!DrvStartDevice: Exit %lx\n",
        NTStatus )
        );

   return( NTStatus );
}

//________________________________________ U N L O A D ____________________________________________

VOID
DrvStopDevice(
   IN PDEVICE_EXTENSION DeviceExtension
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
   PSMARTCARD_EXTENSION SmartcardExtension;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvStopDevice: Enter\n" ));

   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   if( KeReadStateEvent( &SmartcardExtension->ReaderExtension->SerialCloseDone ) == 0l )
   {
      NTSTATUS NTStatus;
      ULONG    WaitMask;

      SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvStopDevice: Power Down\n" ));

      // power down the reader
      STCConfigureSTC(
            SmartcardExtension->ReaderExtension,
            ( PSTC_REGISTER ) STCClose
            );

      // the following delay is neccessary to make sure the last read operation is completed
      // and a IOCTL_SERIAL_WAIT_ON_MASK is started
      SysDelay( 2 * SR_READ_TOTAL_TIMEOUT_CONSTANT );

      //
      // no more event notification neccessary. a side effect is the
      // finishing of all pending notification irp's by the serial driver,
      // so the callback will complete the irp & initiate the close of the
      // connection to the serial driver
      //
      WaitMask = 0;
      SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!Set Wait Mask\n" ));

      NTStatus = IFSerialIoctl(
         SmartcardExtension->ReaderExtension,
         IOCTL_SERIAL_SET_WAIT_MASK,
         &WaitMask,
         sizeof( ULONG ),
         NULL,
         0
         );

      SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!Wait For Done\n" ));

      // wait until the connetion to the serial driver is closed
      NTStatus = KeWaitForSingleObject(
         &SmartcardExtension->ReaderExtension->SerialCloseDone,
         Executive,
         KernelMode,
         FALSE,
         NULL
         );

   }

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvStopDevice: Exit\n" ));
}


VOID
DrvRemoveDevice(
   PDEVICE_OBJECT DeviceObject
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS          NTStatus;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvRemoveDevice: Enter\n" ));

   PAGED_CODE();

   if( DeviceObject != NULL )
   {
      DeviceExtension      = DeviceObject->DeviceExtension;
      SmartcardExtension   = &DeviceExtension->SmartcardExtension;

      DrvStopDevice( DeviceExtension );

      if( SmartcardExtension->OsData )
      {
         ASSERT( SmartcardExtension->OsData->NotificationIrp == NULL );

         // Wait until we can safely unload the device
         SmartcardReleaseRemoveLockAndWait( SmartcardExtension );
      }

      if( SmartcardExtension->ReaderExtension->SerialDeviceObject )
      {
         IoDetachDevice( SmartcardExtension->ReaderExtension->SerialDeviceObject );
      }

      if( DeviceExtension->PnPDeviceName.Buffer != NULL )
      {
         RtlFreeUnicodeString( &DeviceExtension->PnPDeviceName );
      }

      if( SmartcardExtension->OsData != NULL )
      {
         SmartcardExit( SmartcardExtension );
      }

      if( SmartcardExtension->ReaderExtension != NULL )
      {
         if (SmartcardExtension->ReaderExtension->CloseSerial != NULL) {

            IoFreeWorkItem(SmartcardExtension->ReaderExtension->CloseSerial);
         }

         if (SmartcardExtension->ReaderExtension->ReadWorkItem != NULL) {

            IoFreeWorkItem(SmartcardExtension->ReaderExtension->ReadWorkItem);
         }

         ExFreePool( SmartcardExtension->ReaderExtension );
      }

      IoDeleteDevice( DeviceObject );
   }
   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvRemoveDevice: Exit\n" ));
}

VOID
DrvDriverUnload(
   IN PDRIVER_OBJECT DriverObject
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   PDEVICE_OBJECT DeviceObject;
   NTSTATUS    NTStatus;

   PAGED_CODE();

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvDriverUnload: Enter\n" ));

   // just make sure that all device instances have been unloaded
   while( DeviceObject = DriverObject->DeviceObject )
   {
      DrvRemoveDevice( DeviceObject );

   } while( DeviceObject = DriverObject->DeviceObject );

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvDriverUnload: Exit\n" ));
}

NTSTATUS
DrvSystemControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )

/*++

Routine Description:

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/
{
   
   PDEVICE_EXTENSION DeviceExtension; 
   PSMARTCARD_EXTENSION SmartcardExtension; 
   PREADER_EXTENSION ReaderExtension; 
   NTSTATUS status = STATUS_SUCCESS;

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;
   ReaderExtension      = SmartcardExtension->ReaderExtension;

   IoSkipCurrentIrpStackLocation(Irp);
   status = IoCallDriver(ReaderExtension->SerialDeviceObject, Irp);
      
   return status;

} 



//______________________________ D E V I C E   I O   C O N T R O L ________________________________



NTSTATUS
DrvCreateClose(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )

/*++

Routine Description:

    This routine is called by the I/O system when the device is opened or closed.

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

   __try {

      if (irpStack->MajorFunction == IRP_MJ_CREATE) {

         status = SmartcardAcquireRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );

         if (status != STATUS_SUCCESS) {

            status = STATUS_DEVICE_REMOVED;
            __leave;
         }

         // test if the device has been opened already
         if (InterlockedCompareExchange(
            &deviceExtension->ReaderOpen,
            TRUE,
            FALSE) == FALSE) {

            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!DrvCreateClose: Open\n",
               DRIVER_NAME)
               );

         } else {

            // the device is already in use
            status = STATUS_UNSUCCESSFUL;

            // release the lock
            SmartcardReleaseRemoveLockWithTag(
               &deviceExtension->SmartcardExtension,
               'lCrC'
               );

         }

      } else {

         SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!DrvCreateClose: Close\n",
            DRIVER_NAME)
            );

         SmartcardReleaseRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );
         deviceExtension->ReaderOpen = FALSE;
      }
   }
   __finally {

      Irp->IoStatus.Status = status;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
   }

    return status;
}

NTSTATUS
DrvDeviceIoControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS          NTStatus=STATUS_SUCCESS;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   KIRQL             CurrentIrql;

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;

   if (KeReadStateEvent(&(SmartcardExtension->ReaderExtension->SerialCloseDone))) {

      //
      // we have no connection to serial, the device was either
      // surprise-removed or politely removed
      //
      NTStatus = STATUS_DEVICE_REMOVED;
   }
   if (NTStatus == STATUS_SUCCESS)
   {
      KeAcquireSpinLock( &DeviceExtension->SpinLock, &CurrentIrql );

      // make sure that the reader is already started
      if( DeviceExtension->IoCount == 0 )
      {
         KeReleaseSpinLock( &DeviceExtension->SpinLock, CurrentIrql );

         // wait until the pnp manager has started the device
         NTStatus = KeWaitForSingleObject(
            &DeviceExtension->ReaderStarted,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );


         KeAcquireSpinLock( &DeviceExtension->SpinLock, &CurrentIrql );
      }


      DeviceExtension->IoCount++;

      KeReleaseSpinLock( &DeviceExtension->SpinLock, CurrentIrql );

      NTStatus = SmartcardAcquireRemoveLockWithTag(SmartcardExtension, 'tcoI');
   }
   if( NTStatus != STATUS_SUCCESS )
   {
      // if no remove lock can be acquired, the device has been removed
      Irp->IoStatus.Information  = 0;
      Irp->IoStatus.Status    = STATUS_DEVICE_REMOVED;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      NTStatus = STATUS_DEVICE_REMOVED;
      SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvDeviceIoControl: the device has been removed\n" ));

   }
   else
   {
      // let the lib process the call
      NTStatus = SmartcardDeviceControl( SmartcardExtension, Irp );

       SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'tcoI');

      KeAcquireSpinLock( &DeviceExtension->SpinLock, &CurrentIrql );

      DeviceExtension->IoCount--;

      KeReleaseSpinLock(&DeviceExtension->SpinLock, CurrentIrql);
   }
   return( NTStatus );
}


NTSTATUS
DrvGenericIOCTL(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

DrvGenericIOCTL:
   Performs generic callbacks to the reader

Arguments:
   SmartcardExtension   context of the call

Return Value:
   STATUS_SUCCESS

--*/
{
   NTSTATUS          NTStatus;
   PIRP              Irp;
   PIO_STACK_LOCATION      IrpStack;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvGenericIOCTL: Enter\n" ));

   // get pointer to current IRP stack location
   Irp         = SmartcardExtension->OsData->CurrentIrp;
   IrpStack = IoGetCurrentIrpStackLocation( Irp );

   // assume error
   NTStatus = STATUS_INVALID_DEVICE_REQUEST;
   Irp->IoStatus.Information = 0;

   // dispatch IOCTL
   switch( IrpStack->Parameters.DeviceIoControl.IoControlCode )
   {
      case IOCTL_GET_VERSIONS:

         if( IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof( VERSION_CONTROL ))
         {
            NTStatus = STATUS_BUFFER_TOO_SMALL;
         }
         else
         {
            PVERSION_CONTROL  VersionControl;

            VersionControl = (PVERSION_CONTROL)Irp->AssociatedIrp.SystemBuffer;

            VersionControl->SmclibVersion = SmartcardExtension->Version;
            VersionControl->DriverMajor      = SCMSTCS_MAJOR_VERSION;
            VersionControl->DriverMinor      = SCMSTCS_MINOR_VERSION;

            // update firmware version
            STCGetFirmwareRevision( SmartcardExtension->ReaderExtension );

            VersionControl->FirmwareMajor =
               SmartcardExtension->ReaderExtension->FirmwareMajor;

            VersionControl->FirmwareMinor =
               SmartcardExtension->ReaderExtension->FirmwareMinor;

            Irp->IoStatus.Information = sizeof( VERSION_CONTROL );
            NTStatus = STATUS_SUCCESS;
         }
         break;

      default:
         break;
   }

   // set status of the packet
   Irp->IoStatus.Status = NTStatus;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvGenericIOCTL: Exit\n" ));

   return( NTStatus );
}

NTSTATUS
DrvCancel(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )

/*++

Routine Description:
    This function is called whenever the caller wants to
    cancel a pending irp.

Arguments:
    DeviceObject - Our device object
    Irp - the pending irp that we should cancel
--*/
{
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvCancel: Enter\n" ));

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;

   ASSERT( Irp == SmartcardExtension->OsData->NotificationIrp );

   Irp->IoStatus.Information  = 0;
   Irp->IoStatus.Status    = STATUS_CANCELLED;

   SmartcardExtension->OsData->NotificationIrp = NULL;
   IoReleaseCancelSpinLock( Irp->CancelIrql );

   SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!Cancel Irp %lx\n", Irp ));
   IoCompleteRequest( Irp, IO_NO_INCREMENT );

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvCancel: Exit\n" ));

   return( STATUS_CANCELLED );
}

NTSTATUS
DrvCleanup(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )

/*++

Routine Description:
    This function is called, when the 'calling app' terminates (unexpectedly).
    We have to clean up all pending irps. In our case it can only be the
    notification irp.

--*/
{
   NTSTATUS          NTStatus = STATUS_SUCCESS;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
    KIRQL                   CancelIrql;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvCleanup: Enter\n" ));

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;

   IoAcquireCancelSpinLock(&CancelIrql);

   ASSERT( Irp != SmartcardExtension->OsData->NotificationIrp );

   // cancel pending notification irps
   if( SmartcardExtension->OsData->NotificationIrp )
   {
        // reset the cancel function so that it won't be called anymore
        IoSetCancelRoutine(
            SmartcardExtension->OsData->NotificationIrp,
            NULL
            );
        SmartcardExtension->OsData->NotificationIrp->CancelIrql =
            CancelIrql;

        // DrvCancel will release the cancel spin lock
      DrvCancel(
            DeviceObject,
            SmartcardExtension->OsData->NotificationIrp
            );

   } else {

        IoReleaseCancelSpinLock(CancelIrql);
    }

   SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!Completing Irp %lx\n", Irp ));

    // complete the irp that was passed to this function
   Irp->IoStatus.Information  = 0;
   Irp->IoStatus.Status    = STATUS_SUCCESS;
   IoCompleteRequest( Irp, IO_NO_INCREMENT );

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvCleanup: Exit\n" ));

   return( STATUS_SUCCESS );
}

VOID
DrvWaitForDeviceRemoval(
   IN PDEVICE_OBJECT DeviceObject,
   IN PVOID Context
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS       NTStatus;
   PDEVICE_EXTENSION DeviceExtension;
   PREADER_EXTENSION ReaderExtension;
   PIRP           Irp;
   PIO_STACK_LOCATION   IrpStack;
   IO_STATUS_BLOCK      IoStatusBlock;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvWaitForDeviceRemoval: Enter\n" ));

   DeviceExtension = DeviceObject->DeviceExtension;
   ReaderExtension = DeviceExtension->SmartcardExtension.ReaderExtension;

   ASSERT( DeviceExtension != NULL );
   ASSERT( ReaderExtension != NULL );

   // mark the device as invalid, so no application can re-open it
   IoSetDeviceInterfaceState( &DeviceExtension->PnPDeviceName, FALSE );

   // close the connection to the serial driver
   Irp = IoAllocateIrp( (CCHAR)( DeviceObject->StackSize + 1 ), FALSE );

   ASSERT( Irp != NULL );

   if( Irp != NULL )
   {
      SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DrvWaitForDeviceRemoval: Sending IRP_MJ_CLOSE\n" ));

      IoSetNextIrpStackLocation( Irp );
      //
      // send MJ_CLOSE to the serial driver. a side effect of this call is that the serial
      // enumerator will be informed about changes at the COM port, so it will trigger the
      // appropriate pnp calls
      //
      Irp->UserIosb        = &IoStatusBlock;
      IrpStack          = IoGetCurrentIrpStackLocation( Irp );
      IrpStack->MajorFunction = IRP_MJ_CLOSE;

      NTStatus = DrvCallSerialDriver( ReaderExtension->SerialDeviceObject, Irp );

      IoFreeIrp( Irp );
   }

   // inform waiting threads that the close to the serial driver has finished
   KeSetEvent( &ReaderExtension->SerialCloseDone, 0, FALSE );

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvWaitForDeviceRemoval: Exit\n" ));

   return;
}

NTSTATUS
DrvIoCompletion (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp,
   IN PKEVENT        Event
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   UNREFERENCED_PARAMETER( DeviceObject );

   if( Irp->Cancel )
   {

      Irp->IoStatus.Status = STATUS_CANCELLED;
   }
   else
   {
      Irp->IoStatus.Status = STATUS_MORE_PROCESSING_REQUIRED;
   }

   KeSetEvent( Event, 0, FALSE );

   return( STATUS_MORE_PROCESSING_REQUIRED );
}

NTSTATUS
DrvCallSerialDriver(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   KEVENT      Event;

   // copy the stack location of the actual call to the next position
   IoCopyCurrentIrpStackLocationToNext( Irp );

   // this event will be passed to the completion routine & signaled if the call
   // is finished
   KeInitializeEvent( &Event, NotificationEvent, FALSE );

   // the DrvIoCompletion signals the event & keeps the irp alive by setting the
   // status to STATUS_MORE_PROCESSING_REQUIRED
   IoSetCompletionRoutine (
      Irp,
      DrvIoCompletion,
      &Event,
      TRUE,
      TRUE,
      TRUE
      );

   // call the appropriate driver
   if( IoGetCurrentIrpStackLocation( Irp )->MajorFunction == IRP_MJ_POWER )
   {
      NTStatus = PoCallDriver( DeviceObject, Irp );
   }
   else
   {
      NTStatus = IoCallDriver( DeviceObject, Irp );
   }

   // wait until the irp was processed
   if( NTStatus == STATUS_PENDING )
   {
      NTStatus = KeWaitForSingleObject(
            &Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

      NTStatus = Irp->IoStatus.Status;
   }
   return( NTStatus );
}

//__________________________________ P L U G ' N ' P L A Y ________________________________________

NTSTATUS
DrvPnPHandler(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS          NTStatus = STATUS_SUCCESS;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   PREADER_EXTENSION    ReaderExtension;

   PAGED_CODE();

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvPnPDeviceControl: Enter\n" ));

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;
   ReaderExtension      = SmartcardExtension->ReaderExtension;

   NTStatus = SmartcardAcquireRemoveLockWithTag(SmartcardExtension, ' PnP');

   if( NTStatus != STATUS_SUCCESS )
   {
      Irp->IoStatus.Information  = 0;
      Irp->IoStatus.Status    = NTStatus;
      IoCompleteRequest( Irp, IO_NO_INCREMENT );
   }
   else
   {
      PDEVICE_OBJECT AttachedDeviceObject;
      BOOLEAN        DeviceRemoved,
                  IrpSkipped;

      AttachedDeviceObject = ReaderExtension->SerialDeviceObject;

      DeviceRemoved  = FALSE,
      IrpSkipped     = FALSE;


      // dispatch on pnp minor function
      switch(  IoGetCurrentIrpStackLocation( Irp )->MinorFunction )
      {
         case IRP_MN_START_DEVICE:

            SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!IRP_MN_START_DEVICE\n" ));

            // call the serial driver first to make sure the interface is ready
            NTStatus = DrvCallSerialDriver(AttachedDeviceObject, Irp );

            if( NT_SUCCESS(NTStatus))
            {
               NTStatus = DrvStartDevice(DeviceObject);
            }
            break;

         case IRP_MN_QUERY_STOP_DEVICE:
         {
            KIRQL CurrentIrql;

            SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!IRP_MN_QUERY_STOP_DEVICE\n" ));

            KeAcquireSpinLock(&DeviceExtension->SpinLock, &CurrentIrql );

            if( DeviceExtension->IoCount > 0 )
            {
               // don't stop if any io requests are pending
               KeReleaseSpinLock(&DeviceExtension->SpinLock, CurrentIrql );
               NTStatus = STATUS_DEVICE_BUSY;

            }
            else
            {
               // don't allow further io requests
               KeClearEvent( &DeviceExtension->ReaderStarted );
               KeReleaseSpinLock( &DeviceExtension->SpinLock, CurrentIrql );
               NTStatus = DrvCallSerialDriver( AttachedDeviceObject, Irp );
            }
            break;
         }

         case IRP_MN_CANCEL_STOP_DEVICE:

            SmartcardDebug( DEBUG_DRIVER,  ( "SCMSTCS!IRP_MN_CANCEL_STOP_DEVICE\n" ));

            NTStatus = DrvCallSerialDriver( AttachedDeviceObject, Irp );

            if( NTStatus == STATUS_SUCCESS )
            {
               // driver is ready to process io requests
               KeSetEvent( &DeviceExtension->ReaderStarted, 0, FALSE );
            }
            break;

         case IRP_MN_STOP_DEVICE:

            SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!IRP_MN_STOP_DEVICE\n" ));

            DrvStopDevice( DeviceExtension );

            NTStatus = DrvCallSerialDriver(AttachedDeviceObject, Irp );
            break;

         case IRP_MN_QUERY_REMOVE_DEVICE:

            SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!IRP_MN_QUERY_REMOVE_DEVICE\n" ));

            // disable the reader (and ignore possibles errors)
            IoSetDeviceInterfaceState(
               &DeviceExtension->PnPDeviceName,
               FALSE
               );

               // check if the reader is in use
               if(DeviceExtension->ReaderOpen)
               {
                  //
                  // someone is connected, fail the call
                  // we will enable the device interface in
                  // IRP_MN_CANCEL_REMOVE_DEVICE again
                  //
                  NTStatus = STATUS_UNSUCCESSFUL;
               }
               else
               {
                  // ready to remove the device
                  NTStatus = DrvCallSerialDriver(AttachedDeviceObject, Irp );
               }
            break;

         case IRP_MN_CANCEL_REMOVE_DEVICE:

            SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!IRP_MN_CANCEL_REMOVE_DEVICE\n" ));

            NTStatus = DrvCallSerialDriver( AttachedDeviceObject, Irp );

            //
            // reenable the interface only in case that the reader is
            // still connected. This covers the following case:
            // hibernate machine, disconnect reader, wake up, stop device
            // (from task bar) and stop fails since an app. holds the device open
            //
            if(( NTStatus == STATUS_SUCCESS )&&
               (KeReadStateEvent(&(ReaderExtension->SerialCloseDone))!= TRUE))
            {
               // enable the reader
               SmartcardDebug( DEBUG_DRIVER, ( "IoSetDeviceInterfaceState( &DeviceExtension->PnPDeviceName, TRUE )\n" ));

               NTStatus = IoSetDeviceInterfaceState( &DeviceExtension->PnPDeviceName, TRUE );
            }
            break;

         case IRP_MN_REMOVE_DEVICE:

            SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!IRP_MN_REMOVE_DEVICE\n" ));

            DrvRemoveDevice( DeviceObject );
            NTStatus    = DrvCallSerialDriver( AttachedDeviceObject, Irp );
            DeviceRemoved  = TRUE;
            break;

         default:

            // the irp is not handled by the driver, so pass it to theserial driver
            SmartcardDebug(
               DEBUG_DRIVER,
               ( "SCMSTCS!IRP_MN_%lx\n",  IoGetCurrentIrpStackLocation( Irp )->MinorFunction )
               );

            IoSkipCurrentIrpStackLocation( Irp );
            NTStatus = IoCallDriver( AttachedDeviceObject, Irp );
            IrpSkipped  = TRUE;
            break;
      }

      if( IrpSkipped == FALSE)
      {
         Irp->IoStatus.Status = NTStatus;
         IoCompleteRequest( Irp, IO_NO_INCREMENT );
      }

      if( DeviceRemoved == FALSE)
      {
           SmartcardReleaseRemoveLockWithTag(SmartcardExtension, ' PnP');
      }
   }

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvPnPDeviceControl: Exit %X\n", NTStatus ));
   return( NTStatus );
}

//__________________________________________ P O W E R ____________________________________________


VOID
DrvSystemPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    This function is called when the underlying stacks
    completed the power transition.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (PowerState);
    UNREFERENCED_PARAMETER (IoStatus);

    KeSetEvent(Event, 0, FALSE);
}

NTSTATUS
DrvDevicePowerCompletion(
   IN PDEVICE_OBJECT    DeviceObject,
   IN PIRP              Irp,
   IN PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS NTStatus;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    BOOLEAN CardPresent;
    KIRQL   irql;
    if(Irp->PendingReturned) {
       IoMarkIrpPending(Irp);
    }

   // re-initialize the the reader & get the current card state
   NTStatus = STCConfigureSTC(
      SmartcardExtension->ReaderExtension,
      ( PSTC_REGISTER ) STCInitialize
      );

    // Save the state of the card BEFORE stand by / hibernation
   KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                     &irql);
    CardPresent =
        SmartcardExtension->ReaderCapabilities.CurrentState >= SCARD_ABSENT;
    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                      irql);

    // get the current state of the card
    CBUpdateCardState(SmartcardExtension, SCARD_UNKNOWN);

    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);
    
    if (CardPresent ||
        SmartcardExtension->ReaderCapabilities.CurrentState >= SCARD_ABSENT) {

        //
        // If a card was present before power down or now there is
        // a card in the reader, we complete any pending card monitor
        // request, since we do not really know what card is now in the
        // reader.
        //
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
        
        CBUpdateCardState(SmartcardExtension, SCARD_UNKNOWN);
    } else {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);

    }


   // save the current Power state of the reader
   SmartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderWorking;

    SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');

   // inform the Power manager of our state.
   PoSetPowerState (
      DeviceObject,
      DevicePowerState,
      IoGetCurrentIrpStackLocation( Irp )->Parameters.Power.State
      );

   PoStartNextPowerIrp( Irp );

    // signal that we can process ioctls again
    KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);

   return( STATUS_SUCCESS );
}

typedef enum _ACTION
{
   Undefined = 0,
   SkipRequest,
   WaitForCompletion,
   CompleteRequest,
   MarkPending

} ACTION;


NTSTATUS
DrvPowerHandler(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS          NTStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION      IrpStack;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   PDEVICE_OBJECT       AttachedDeviceObject;
   POWER_STATE           PowerState;
   ACTION               Action;
   KEVENT               event;
   KIRQL                irql;

   PAGED_CODE();

   SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DrvPowerHandler: Enter\n" ));

   IrpStack       = IoGetCurrentIrpStackLocation( Irp );
   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;
   AttachedDeviceObject = SmartcardExtension->ReaderExtension->SerialDeviceObject;

    NTStatus = SmartcardAcquireRemoveLockWithTag(SmartcardExtension, 'rwoP');

   if( !NT_SUCCESS( NTStatus ))
   {
      PoStartNextPowerIrp( Irp );
      Irp->IoStatus.Status = NTStatus;
      IoCompleteRequest( Irp, IO_NO_INCREMENT );
   }
   else
   {

      switch (IrpStack->Parameters.Power.Type) {
      case DevicePowerState:

         if (IrpStack->MinorFunction == IRP_MN_SET_POWER ) {
            switch ( IrpStack->Parameters.Power.State.DeviceState ) {
            case PowerDeviceD0:

               // turn the reader on
               SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DrvPowerHandler: PowerDevice D0\n" ));
               //
               // send the request to the serial driver to power up the port.
               // the reader will be powered from our completion routine
               //
               IoCopyCurrentIrpStackLocationToNext( Irp );
               IoSetCompletionRoutine (
                                      Irp,
                                      DrvDevicePowerCompletion,
                                      SmartcardExtension,
                                      TRUE,
                                      TRUE,
                                      TRUE
                                      );

               Action = WaitForCompletion;
               break;

            case PowerDeviceD3:

               // turn the reader off
               SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DrvPowerHandler: PowerDevice D3\n" ));

               PoSetPowerState (
                               DeviceObject,
                               DevicePowerState,
                               IrpStack->Parameters.Power.State
                               );

               //
               // check if we're still connected to the reader
               // someone might have pulled the plug without re-scanning for hw/changes
               //
               if (KeReadStateEvent( &SmartcardExtension->ReaderExtension->SerialCloseDone ) == 0l) {

                  //   power down the card
                   KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                                     &irql);

                  if ( SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT ) {

                      KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                        irql);

                     SmartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
                     NTStatus = CBCardPower( SmartcardExtension );
                     //
                     // This will trigger the card monitor, since we do not really
                     // know if the user will remove / re-insert a card while the
                     // system is asleep
                     //
                  } else {
                      KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                        irql);
                  }

                  //   power down the reader
                  STCConfigureSTC(
                                 SmartcardExtension->ReaderExtension,
                                 ( PSTC_REGISTER ) STCClose
                                 );
               }

               // wait until the last read is finished to make sure we go to power
               // down with a pending tracking irp
               SysDelay( 2 * SR_READ_TOTAL_TIMEOUT_CONSTANT );

               // save the current Power state of the reader
               SmartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderOff;

               Action = SkipRequest;
               break;

            default:
               Action = SkipRequest;
               break;
            }
         } else {
            Action = SkipRequest;
            break;
         }
         break;

      case SystemPowerState: {
            //
            // The system wants to change the power state.
            // We need to translate the system power state to
            // a corresponding device power state.
            //
            POWER_STATE_TYPE  PowerType = DevicePowerState;

            ASSERT(SmartcardExtension->ReaderExtension->ReaderPowerState !=
                   PowerReaderUnspecified);

            switch ( IrpStack->MinorFunction ) {

            case IRP_MN_QUERY_POWER:

               SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DrvPowerHandler: Query Power\n" ));

               switch (IrpStack->Parameters.Power.State.SystemState) {

               case PowerSystemMaximum:
               case PowerSystemWorking:
               case PowerSystemSleeping1:
               case PowerSystemSleeping2:
                  Action = SkipRequest;
                  break;

               case PowerSystemSleeping3:
               case PowerSystemHibernate:
               case PowerSystemShutdown:
                  KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);
                  if (DeviceExtension->IoCount == 0) {

                     // Block any further ioctls
                     KeClearEvent(&DeviceExtension->ReaderStarted);
                     Action = SkipRequest;

                  } else {

                     // can't go to sleep mode since the reader is busy.
                     NTStatus = STATUS_DEVICE_BUSY;
                     Action = CompleteRequest;
                  }
                  KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
                  break;
               }
               break;

            case IRP_MN_SET_POWER:

               SmartcardDebug(
                             DEBUG_DRIVER,
                             ( "SCMSTCS!DrvPowerHandler: PowerSystem S%d\n", IrpStack->Parameters.Power.State.SystemState - 1 )
                             );

               switch (IrpStack->Parameters.Power.State.SystemState) {
               case PowerSystemMaximum:
               case PowerSystemWorking:
               case PowerSystemSleeping1:
               case PowerSystemSleeping2:

                  if ( SmartcardExtension->ReaderExtension->ReaderPowerState ==
                       PowerReaderWorking) {
                     // We're already in the right state
                     KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);
                     Action = SkipRequest;
                     break;
                  }

                  PowerState.DeviceState = PowerDeviceD0;

                  // wake up the underlying stack...
                  Action = MarkPending;
                  break;

               case PowerSystemSleeping3:
               case PowerSystemHibernate:
               case PowerSystemShutdown:

                  if ( SmartcardExtension->ReaderExtension->ReaderPowerState == PowerReaderOff ) {
                     // We're already in the right state
                     Action = SkipRequest;
                     break;
                  }

                  PowerState.DeviceState = PowerDeviceD3;

                  // first, inform the Power manager of our new state.
                  PoSetPowerState (
                                  DeviceObject,
                                  SystemPowerState,
                                  PowerState
                                  );
                  Action = MarkPending;
                  break;

               default:
                  Action = CompleteRequest;
                  break;
               }
               break;

            default:
               Action = SkipRequest;
               break;
            }
         }
         break;

      default:
         Action = CompleteRequest;
         break;
      }


      switch( Action )
      {
         case CompleteRequest:
            Irp->IoStatus.Status    = NTStatus;
            Irp->IoStatus.Information  = 0;

            SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');

            PoStartNextPowerIrp( Irp );

            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            break;

         case MarkPending:

            // initialize the event we need in the completion function
            KeInitializeEvent(
               &event,
               NotificationEvent,
               FALSE
               );

            // request the device power irp
            NTStatus = PoRequestPowerIrp (
               DeviceObject,
               IRP_MN_SET_POWER,
               PowerState,
               DrvSystemPowerCompletion,
               &event,
               NULL
               );

            if (NTStatus == STATUS_PENDING) {

               // wait until the device power irp completed
               NTStatus = KeWaitForSingleObject(
                  &event,
                  Executive,
                  KernelMode,
                  FALSE,
                  NULL
                  );

               SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');

               if (PowerState.SystemState == PowerSystemWorking) {

                  PoSetPowerState (
                     DeviceObject,
                     SystemPowerState,
                     PowerState
                     );
               }

               PoStartNextPowerIrp(Irp);
               IoSkipCurrentIrpStackLocation(Irp);
               NTStatus = PoCallDriver(AttachedDeviceObject, Irp);

            } else {

               SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');
               Irp->IoStatus.Status = NTStatus;
               IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }

            break;

         case SkipRequest:
            SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');

            PoStartNextPowerIrp( Irp );
            IoSkipCurrentIrpStackLocation( Irp );
            NTStatus = PoCallDriver( AttachedDeviceObject, Irp );
            break;

         case WaitForCompletion:
            NTStatus = PoCallDriver( AttachedDeviceObject, Irp );
            break;

         default:
            break;
      }
   }
   SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DrvPowerHandler: Exit %X\n", NTStatus ));

   return( NTStatus );
}



void
SysDelay(
   ULONG Timeout
   )
/*++

SysDelay:
   performs a required delay

Arguments:
   Timeout     delay in milliseconds

--*/
{

   if( KeGetCurrentIrql() >= DISPATCH_LEVEL )
   {
      ULONG Cnt = 20 * Timeout;
      while( Cnt-- )
      {
         // KeStallExecutionProcessor: counted in us
         KeStallExecutionProcessor( 50 );
      }
   }
   else
   {
      LARGE_INTEGER SysTimeout;

      SysTimeout.QuadPart =
         (LONGLONG) Timeout * -10 * 1000;

      // KeDelayExecutionThread: counted in 100 ns
      KeDelayExecutionThread( KernelMode, FALSE, &SysTimeout );
   }
   return;
}

//_________________________________________ END OF FILE _________________________________________
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\srvers.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       srvers.h
//
//--------------------------------------------------------------------------

/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

    SRVers.h

Abstract:

	header file for version information

Author:

	Andreas Straub

Environment:

	Win 95, Win NT

Revision History:

	AS	1.00		2/06/1998	Initial Version

--*/
#if !defined( __SRVERS_H__ )
#define __SRVERS_H__

#define SCMSTCS_VERSION_STR		"1.06"
#define SCMSTCS_MAJOR_VERSION	1
#define SCMSTCS_MINOR_VERSION	6

#endif	//	__SRVERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\serialnt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       serialnt.h
//
//--------------------------------------------------------------------------

#if !defined( __SERIAL_NT_H__ )
#define __SERIAL_NT_H__

#include "DriverNT.h"
#include <ntddser.h>

#include "SerialIF.h"

#define STC_BUFFER_SIZE		32
#define TPDU_STACK_SIZE		2048

typedef struct _SERIAL_PORT_CONFIG
{
    SERIAL_HANDFLOW		HandFlow;           // flow control
    SERIAL_CHARS		SerialChars;        // special characters
    SERIAL_TIMEOUTS		Timeouts;           // read/write timeouts
    SERIAL_BAUD_RATE	BaudRate;          	// Baudrate for reader
    SERIAL_LINE_CONTROL	LineControl;    	// Stop bits, parity configuration
    ULONG				WaitMask,           // notification events
						Purge;
} SERIAL_PORT_CONFIG, *PSERIAL_PORT_CONFIG;

typedef struct _READER_EXTENSION
{
	//
	//	serial port driver data
	//
	ULONG				SerialPortNumber;
	PDEVICE_OBJECT		SerialDeviceObject;
	PFILE_OBJECT		SerialFileObject;
	PIO_WORKITEM		CloseSerial;		//	worker thread that closes the serial driver

	//	back pointer to smart card extension
    PSMARTCARD_EXTENSION    SmartcardExtension;

	//	read thread data
	UCHAR				IOData[ 2 * STC_BUFFER_SIZE ];
	UCHAR				TPDUStack[ TPDU_STACK_SIZE ];
	ULONG				Available;
	ULONG				Expected;

	ULONG				EventMask;
	ULONG				ReadTimeout;			//	read timeout in ms

	IO_STATUS_BLOCK		IoStatus;
	KEVENT				IoEvent;
	KEVENT				DataAvailable;

	PIO_WORKITEM		ReadWorkItem;
	KSPIN_LOCK			ReadSpinLock;

	//	miscellaneous
	ULONG				ReaderPowerState;
	BOOLEAN				PowerRequest;
	UCHAR				FirmwareMajor,
						FirmwareMinor;

    BOOLEAN             CardPresent;

	KEVENT				SerialCloseDone;		//	signaled if the connection to the serial driver has been closed

} READER_EXTENSION, *PREADER_EXTENSION;

typedef enum _READER_POWER_STATE
{
    PowerReaderUnspecified = 0,
    PowerReaderWorking,
    PowerReaderOff
} READER_POWER_STATE, *PREADER_POWER_STATE;

//
//	CONSTANTS
//
#define SR_VENDOR_NAME			"STCS"
#define SR_PRODUCT_NAME			"Serial Reader"
//
//	serial communication defines
//
#define SR_BAUD_RATE						115200
#define SR_STOP_BITS						STOP_BIT_1
#define SR_PARITY							NO_PARITY
#define SR_DATA_LENGTH						SERIAL_DATABITS_8
//
//	COM timeout values in ms
//
#define SR_READ_TOTAL_TIMEOUT_CONSTANT		2000
#define SR_READ_INTERVAL_TIMEOUT			2000

#define SR_WRITE_TOTAL_TIMEOUT_CONSTANT		2000
#define SR_WRITE_TOTAL_TIMEOUT_MULTIPLIER	0

#define SR_FLOW_REPLACE						0       
#define SR_HAND_SHAKE						0
#define SR_XON_LIMIT						0
#define SR_XOFF_LIMIT						0

#define SR_ON_CHAR							0x11
#define SR_OFF_CHAR							0x13

#define SR_NOTIFICATION_EVENT				( SERIAL_EV_RXCHAR | SERIAL_EV_DSR )

#define SR_PURGE							( SERIAL_PURGE_RXCLEAR | SERIAL_PURGE_TXCLEAR )

//
//	not clear, how these ctl codes are interpreted; the actual command is passed by the IrpStack.MajorFunction
//
#define SERIAL_READ							SCARD_CTL_CODE( 0x1000 )
#define SERIAL_WRITE						SCARD_CTL_CODE( 0x2000 )

//
//	READ THREAD
//
#define RT_FINISH				0x00
#define RT_READ_HEAD			0x01
#define RT_READ_TAIL			0x02
#define RT_READ_MORE			0x03
#define RT_GET_MODEM_STATUS		0x04
#define RT_WAIT_EMPTY			0x05
#define RT_WAIT_DATA			0x06

NTSTATUS
IFReadThreadCallback(
	PDEVICE_OBJECT			DeviceObject,
	PIRP					Irp,
	PREADER_EXTENSION		ReaderExtension
	);

//
//	LOCAL PROTOTYPES
//
NTSTATUS
IFSerialIoctl(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				IoctlCode,
	PVOID				OutData,
	ULONG				OutDataLen,
	PVOID				InData,
	ULONG				InDataLen
	);

NTSTATUS
IFSerialRead(
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				InData,
	ULONG				InDataLen
	);

NTSTATUS 
IFSerialWaitOnMask(
	PREADER_EXTENSION		ReaderExtension
	);

VOID
IFReadWorkRoutine(
	IN PDEVICE_OBJECT DeviceObject,
	IN PREADER_EXTENSION ReaderExtension 
	);


#endif	//	!__SERIAL_NT_H__


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\serialnt.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       serialnt.c
//
//--------------------------------------------------------------------------

#include "drivernt.h"
#include "stc.h"
#include "cbhndlr.h"
#include "drvnt5.h"

const ULONG ConfigTable[] =
{
    IOCTL_SERIAL_SET_BAUD_RATE,
    IOCTL_SERIAL_SET_LINE_CONTROL,
    IOCTL_SERIAL_SET_CHARS,
    IOCTL_SERIAL_SET_TIMEOUTS,
    IOCTL_SERIAL_SET_HANDFLOW,
#if !defined( __NT4__ )
    IOCTL_SERIAL_PURGE,
#endif
    IOCTL_SERIAL_SET_BREAK_OFF,
    IOCTL_SERIAL_SET_WAIT_MASK,
    0
};

NTSTATUS
IFInitializeInterface(
    PREADER_EXTENSION   ReaderExtension,
    PVOID               ConfigData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS            NTStatus = STATUS_SUCCESS;
    ULONG               OutDataLen;
    PVOID               OutData;
    PULONG              ActIoctl;
    PSERIAL_PORT_CONFIG SerialPortConfig = (PSERIAL_PORT_CONFIG) ConfigData;
    //
    //  set all parameters defined in config table
    //

    ActIoctl = (PULONG) ConfigTable;
    do
    {
        switch( *ActIoctl )
        {
            case IOCTL_SERIAL_SET_BAUD_RATE:
                OutData     = &SerialPortConfig->BaudRate;
                OutDataLen  = sizeof( SERIAL_BAUD_RATE );
                break;

            case IOCTL_SERIAL_SET_LINE_CONTROL:
                OutData     = &SerialPortConfig->LineControl;
                OutDataLen  = sizeof( SERIAL_LINE_CONTROL );
                break;

            case IOCTL_SERIAL_SET_CHARS:
                OutData     = &SerialPortConfig->SerialChars;
                OutDataLen  = sizeof( SERIAL_CHARS );
                break;

            case IOCTL_SERIAL_SET_TIMEOUTS:
                OutData     = &SerialPortConfig->Timeouts;
                OutDataLen  = sizeof( SERIAL_TIMEOUTS );
                break;

            case IOCTL_SERIAL_SET_HANDFLOW:
                OutData     = &SerialPortConfig->HandFlow;
                OutDataLen  = sizeof( SERIAL_HANDFLOW );
                break;

            case IOCTL_SERIAL_SET_WAIT_MASK:
                OutData     = &SerialPortConfig->WaitMask;
                OutDataLen  = sizeof( ULONG );
                break;

            case IOCTL_SERIAL_PURGE:
                OutData     = &SerialPortConfig->Purge;
                OutDataLen  = sizeof( ULONG );
                break;

            case IOCTL_SERIAL_SET_BREAK_OFF:
                OutData     = NULL;
                OutDataLen  = 0;
                break;
        }

        NTStatus = IFSerialIoctl(
            ReaderExtension,
            *ActIoctl,
            OutData,
            OutDataLen,
            NULL,
            0
            );

        SysDelay(25);

    } while( *(++ActIoctl) && ( NTStatus == STATUS_SUCCESS ));

    if( NTStatus == STATUS_SUCCESS )
    {
        //  initialize the read thread
        NTStatus = IFSerialWaitOnMask( ReaderExtension );
    }

    return( NTStatus );
}

NTSTATUS
IFWrite(
    PREADER_EXTENSION   ReaderExtension,
    PUCHAR              OutData,
    ULONG               OutDataLen
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
    IO_STATUS_BLOCK     IoStatus;
    KEVENT              Event;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpStack;

    if (KeReadStateEvent(&(ReaderExtension->SerialCloseDone))) {

        //
        // we have no connection to serial, fail the call
        // this could be the case if the reader was removed 
        // during stand by / hibernation
        //
        return STATUS_UNSUCCESSFUL;
    }
    ReaderExtension->Available = 0;
    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  build irp to be send to serial driver
    //
    Irp = IoBuildDeviceIoControlRequest(
        SERIAL_WRITE,
        ReaderExtension->SerialDeviceObject, 
        OutData,
        OutDataLen,
        NULL,
        0,
        FALSE,
        &Event,
        &IoStatus
        );

    if( Irp != NULL )
    {
        IrpStack = IoGetNextIrpStackLocation( Irp );

        IrpStack->MajorFunction = IRP_MJ_WRITE;
        IrpStack->Parameters.Write.Length = OutDataLen;
        IrpStack->Parameters.Write.ByteOffset.QuadPart = 0;

        NTStatus = IoCallDriver( ReaderExtension->SerialDeviceObject, Irp );

        if( NTStatus == STATUS_PENDING )
        {
            KeWaitForSingleObject( 
                &Event, 
                Executive, 
                KernelMode, 
                FALSE, 
                NULL
                );
            NTStatus = IoStatus.Status;
        }
    }
    return( NTStatus );
}

NTSTATUS
IFRead(
    PREADER_EXTENSION   ReaderExtension,
    PUCHAR              InData,
    ULONG               InDataLen
    )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    NTSTATUS NTStatus = STATUS_UNSUCCESSFUL;
    KIRQL CurrentIrql;                                    

    //  acquire spinlock to protect buffer/flag manipulation
    KeAcquireSpinLock( &ReaderExtension->ReadSpinLock, &CurrentIrql );

    //  check if data already available
    if( ReaderExtension->Available >= InDataLen )
    {
        
        NTStatus = STATUS_SUCCESS;

    }
    else
    {
        LARGE_INTEGER Timeout;

        //  setup read thread
        ReaderExtension->Expected = InDataLen;
        KeClearEvent( &ReaderExtension->DataAvailable );

        KeReleaseSpinLock( &ReaderExtension->ReadSpinLock, CurrentIrql );

        // setup wait time (in 100 ns)
        Timeout.QuadPart = 
            (LONGLONG) ReaderExtension->ReadTimeout * -10L * 1000;

        NTStatus = KeWaitForSingleObject(
            &ReaderExtension->DataAvailable,
            Executive,          
            KernelMode,
            FALSE,
            &Timeout
            );

        KeAcquireSpinLock(&ReaderExtension->ReadSpinLock, &CurrentIrql);

        //  reset the read queue
        KeClearEvent(&ReaderExtension->DataAvailable);
    }

    if( NTStatus == STATUS_SUCCESS )
    {

        if (ReaderExtension->Available >= InDataLen) {

            SysCopyMemory( 
                InData,
                &ReaderExtension->TPDUStack[0],
                InDataLen
                );

            ReaderExtension->Available -= InDataLen;

            SysCopyMemory(
                &ReaderExtension->TPDUStack[ 0 ],
                &ReaderExtension->TPDUStack[ InDataLen ],
                ReaderExtension->Available
                );

        } else {

            //
            // oops, that should not happen.
            // InDataLen should not be bigger than 
            // the number of bytes available
            //

            ASSERT(FALSE);
            NTStatus = STATUS_IO_TIMEOUT;
        }
    }
    else
    {
        // ReaderExtension->Available = 0;;
        NTStatus = STATUS_IO_TIMEOUT;
    }

    if( NTStatus != STATUS_SUCCESS )
    {

        NTStatus = STATUS_IO_TIMEOUT;
    }

    ReaderExtension->Expected = 0;

    KeReleaseSpinLock( &ReaderExtension->ReadSpinLock, CurrentIrql );

    return( NTStatus );
}

NTSTATUS
IFSerialIoctl(
    PREADER_EXTENSION   ReaderExtension,
    ULONG               IoctlCode,
    PVOID               OutData,
    ULONG               OutDataLen,
    PVOID               InData,
    ULONG               InDataLen
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
    IO_STATUS_BLOCK     IoStatus;
    KEVENT              Event;
    PIRP                Irp;



    if (KeReadStateEvent(&(ReaderExtension->SerialCloseDone))) {

        //
        // we have no connection to serial, fail the call
        // this could be the case if the reader was removed 
        // during stand by / hibernation
        //
        return STATUS_UNSUCCESSFUL;
    }

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    //
    //  build irp to be send to serial driver
    //
    Irp = IoBuildDeviceIoControlRequest(
        IoctlCode,
        ReaderExtension->SerialDeviceObject, 
        OutData,
        OutDataLen,
        InData,
        InDataLen,
        FALSE,
        &Event,
        &IoStatus
        );

    if( Irp != NULL )
    {
        NTStatus = IoCallDriver( ReaderExtension->SerialDeviceObject, Irp );

        if( NTStatus == STATUS_PENDING )
        {
            LARGE_INTEGER Timeout;

            Timeout.QuadPart = 
                (LONGLONG) ReaderExtension->ReadTimeout * -10 * 1000;

            KeWaitForSingleObject( 
                &Event, 
                Executive, 
                KernelMode, 
                FALSE, 
                &Timeout
                );

            NTStatus = IoStatus.Status;
        }
    }

    return( NTStatus );
}



NTSTATUS
IFSerialRead(
    PREADER_EXTENSION   ReaderExtension,
    PUCHAR              InData,
    ULONG               InDataLen
    )
{
    NTSTATUS            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
    IO_STATUS_BLOCK     IoStatus;
    KEVENT              Event;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpStack;

    if (KeReadStateEvent(&(ReaderExtension->SerialCloseDone))) {

        //
        // we have no connection to serial, fail the call
        // this could be the case if the reader was removed 
        // during stand by / hibernation
        //
        return STATUS_UNSUCCESSFUL;
    }
    //  build irp to be send to serial driver
    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest(
        SERIAL_READ,
        ReaderExtension->SerialDeviceObject, 
        NULL,
        0,
        InData,
        InDataLen,
        FALSE,
        &Event,
        &IoStatus
        );

    if( Irp != NULL )
    {
        IrpStack = IoGetNextIrpStackLocation( Irp );

        IrpStack->MajorFunction = IRP_MJ_READ;
        IrpStack->Parameters.Read.Length = InDataLen;

        NTStatus = IoCallDriver( ReaderExtension->SerialDeviceObject, Irp );

        if( NTStatus == STATUS_PENDING )
        {
            KeWaitForSingleObject( 
                &Event, 
                Executive, 
                KernelMode, 
                FALSE, 
                NULL
                );
            NTStatus = IoStatus.Status;

        }
    }

    return( NTStatus );
}

NTSTATUS 
IFSerialWaitOnMask( PREADER_EXTENSION ReaderExtension )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS NTStatus;


    if (KeReadStateEvent(&(ReaderExtension->SerialCloseDone))) {

        //
        // we have no connection to serial, fail the call
        // this could be the case if the reader was removed 
        // during stand by / hibernation
        //
        return STATUS_UNSUCCESSFUL;
    }

    irp = IoAllocateIrp(
        (CCHAR) (ReaderExtension->SerialDeviceObject->StackSize + 1),
        FALSE
        );

    ASSERT(irp != NULL);

    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

    irpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 
        sizeof(ReaderExtension->EventMask);
    irpSp->Parameters.DeviceIoControl.IoControlCode = 
        IOCTL_SERIAL_WAIT_ON_MASK;
    
    irp->AssociatedIrp.SystemBuffer = &ReaderExtension->EventMask;

    //  set completion routine & start io
    IoSetCompletionRoutine( 
        irp, 
        IFReadThreadCallback, 
        ReaderExtension, 
        TRUE, 
        TRUE, 
        TRUE 
        );

    NTStatus = IoCallDriver( ReaderExtension->SerialDeviceObject, irp );

    return (NTStatus == STATUS_PENDING ? STATUS_SUCCESS : NTStatus);
}

NTSTATUS
IFReadThreadCallback(
    PDEVICE_OBJECT          DeviceObject,
    PIRP                    Irp,
    PREADER_EXTENSION       ReaderExtension
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    KIRQL   irql;

    //  event_rx?
    if( ReaderExtension->EventMask & SERIAL_EV_RXCHAR )
    {
        IoQueueWorkItem(
            ReaderExtension->ReadWorkItem,
            (PIO_WORKITEM_ROUTINE) IFReadWorkRoutine,
            CriticalWorkQueue,
            ReaderExtension
            );
    }
    else 
    {
        SmartcardDebug( 
            DEBUG_TRACE, 
            ("SCMSTCS!IFReadThreadCallback: Device removed\n" )
            );
        KeAcquireSpinLock(&ReaderExtension->SmartcardExtension->OsData->SpinLock,
                          &irql);

        ReaderExtension->SmartcardExtension->ReaderCapabilities.CurrentState = 
            (ULONG) SCARD_UNKNOWN;

        KeReleaseSpinLock(&ReaderExtension->SmartcardExtension->OsData->SpinLock,
                          irql);

        //  last call: disconnect from the serial driver 
        IoQueueWorkItem(
            ReaderExtension->CloseSerial,
            (PIO_WORKITEM_ROUTINE) DrvWaitForDeviceRemoval,
            DelayedWorkQueue,
            NULL
            );
    }

    IoFreeIrp(Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
IFReadWorkRoutine( 
    IN PDEVICE_OBJECT DeviceObject,
    IN PREADER_EXTENSION ReaderExtension 
    )
{
    NTSTATUS            NTStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION  IrpStack;
    PIRP                Irp;
    SERIAL_STATUS       CommStatus;
    PUCHAR              IOData;
    BOOLEAN             purgePort = FALSE;
    BOOLEAN             bUpdatCardState = FALSE;
    USHORT              shrtBuf;
    
    ASSERT( ReaderExtension != NULL );


    if (ReaderExtension == NULL) {

        return;
    }

    __try {

        IOData = &ReaderExtension->IOData[0];

        while (NTStatus == STATUS_SUCCESS) {

            //  read head
            NTStatus = IFSerialRead( 
                ReaderExtension, 
                &IOData[0], 
                3 
                );

            if (NTStatus != STATUS_SUCCESS) {
            
                __leave;
            }

            if ((IOData[NAD_IDX] & 0x20) != 0x20) {

                SmartcardDebug( 
                    DEBUG_ERROR, 
                    ("SCMSTCS!IFReadWorkRoutine: Invalid packet received\n" )
                    );

                purgePort = TRUE;
                __leave;
            }


            if (IOData[LEN_IDX] > STC_BUFFER_SIZE - 4) {

                purgePort = TRUE;
                __leave;
            }

            //  read tail
            NTStatus = IFSerialRead(
                ReaderExtension,
                &IOData[DATA_IDX],
                IOData[LEN_IDX] + 1
                );

            ASSERT(NTStatus == STATUS_SUCCESS);

            if (NTStatus != STATUS_SUCCESS) {

                purgePort = TRUE;
                __leave;
            }

            if (IOData[LEN_IDX] == 0) {

                purgePort = TRUE;
                __leave;
            }

            //  check for card insertion / removal
            RtlRetrieveUshort(&shrtBuf, &IOData[DATA_IDX]);

            if( ( IOData[NAD_IDX] == STC1_TO_HOST ) &&
                ( IOData[LEN_IDX] == 2 ) &&
                ( (shrtBuf == SW_INSERTED) ||
                  (shrtBuf == SW_REMOVED))) {
                   
               CBUpdateCardState(
                  ReaderExtension->SmartcardExtension,
                  (shrtBuf == SW_INSERTED ? SCARD_PRESENT : SCARD_ABSENT)
                  );
                

            } else {

                KIRQL   CurrentIrql;


                //  acquire spinlock to protect buffer/flag manipulation
                KeAcquireSpinLock( 
                    &ReaderExtension->ReadSpinLock, 
                    &CurrentIrql 
                    );

                //  check size & copy data to TPDU stack
                ASSERT(
                    ReaderExtension->Available+IOData[LEN_IDX] + 4 < 
                    TPDU_STACK_SIZE
                    );

                if (ReaderExtension->Available + IOData[LEN_IDX] + 4 < 
                    TPDU_STACK_SIZE ) {

                    SysCopyMemory( 
                        &ReaderExtension->TPDUStack[ReaderExtension->Available],
                        &IOData[ 0 ],
                        IOData[ LEN_IDX ] + 4
                        );

                    ReaderExtension->Available += 
                        IOData[LEN_IDX] + 4;

                    if(ReaderExtension->Available >= ReaderExtension->Expected ) {
                      
                        KeSetEvent( 
                            &ReaderExtension->DataAvailable, 
                            IO_SERIAL_INCREMENT, 
                            FALSE
                            );
                    }
                }

                KeReleaseSpinLock( &ReaderExtension->ReadSpinLock, CurrentIrql );
            }
        } 
    }
    __finally { 


        if (purgePort) {

            ULONG   request;
            KIRQL   CurrentIrql;

            //  acquire spinlock to protect buffer/flag manipulation
            KeAcquireSpinLock( 
                &ReaderExtension->ReadSpinLock, 
                &CurrentIrql 
                );

            ReaderExtension->Available = 0;

            KeReleaseSpinLock( 
                &ReaderExtension->ReadSpinLock, 
                CurrentIrql 
                );

            // we got an error and need to clean up the port
            request = SR_PURGE;
            NTStatus = IFSerialIoctl(
                ReaderExtension,
                IOCTL_SERIAL_PURGE,
                &request,
                sizeof(request),
                NULL,
                0
                );

            ASSERT(NTStatus == STATUS_SUCCESS);
        }

        IFSerialWaitOnMask( ReaderExtension );
    }
}

UCHAR IFCalcLRC( PUCHAR IOData, ULONG IODataLen )
{
    ULONG   Idx = 0;
    UCHAR   CS = 0;

    do  CS ^= IOData[ Idx ];
    while( ++Idx < IODataLen );

    return( CS );
}


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\stccmd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       stccmd.h
//
//--------------------------------------------------------------------------

#if !defined( __STC_COMMAND_H__ )
#define __STC_COMMAND_H__

#include "STC.h"

NTSTATUS
STCReset( 
    PREADER_EXTENSION   ReaderExtension,
    UCHAR               Device,
    BOOLEAN             WarmReset,
    PUCHAR              pATR,
    PULONG              pATRLength
    );

NTSTATUS 
STCReadATR(
    PREADER_EXTENSION   ReaderExtension, 
    PUCHAR              pATR, 
    PULONG              pATRLength
    );

NTSTATUS
STCPowerOff(
    PREADER_EXTENSION   ReaderExtension
    );

NTSTATUS
STCPowerOn(
    PREADER_EXTENSION   ReaderExtension
    );

NTSTATUS
STCSetRST(
    PREADER_EXTENSION   ReaderExtension,
    BOOLEAN             On
    );

NTSTATUS
STCConfigureSTC(    
    PREADER_EXTENSION   ReaderExtension,
    PSTC_REGISTER       pConfiguration
    );

NTSTATUS
STCWriteICC1 (
    PREADER_EXTENSION   ReaderExtension,
    PUCHAR              APDU,
    ULONG               APDULen
    );

NTSTATUS
STCReadICC1(
    PREADER_EXTENSION       ReaderExtension,
    PUCHAR                  InData,
    PULONG                  InDataLen,
    ULONG                   BytesRead
    );

NTSTATUS
STCReadSTCRegister(
    PREADER_EXTENSION   ReaderExtension,
    UCHAR               Address,
    ULONG               Size,
    PUCHAR              pValue
    );
    
NTSTATUS
STCWriteSTCRegister(
    PREADER_EXTENSION   ReaderExtension,
    UCHAR               Address,
    ULONG               Size,
    PUCHAR              pValue
    );

NTSTATUS
STCSetETU(
    PREADER_EXTENSION   ReaderExtension,
    ULONG               NewETU
    );

NTSTATUS
STCSetCGT(
    PREADER_EXTENSION   ReaderExtension,
    ULONG               NewCGT
    );

NTSTATUS
STCSetCWT(
    PREADER_EXTENSION   ReaderExtension,
    ULONG               NewCWT
    );

NTSTATUS
STCSetBWT(
    PREADER_EXTENSION   ReaderExtension,
    ULONG               NewBWT
    );

NTSTATUS
STCSetFDIV(
    PREADER_EXTENSION   ReaderExtension,
    ULONG               Factor
    );


NTSTATUS 
STCInitUART(
    PREADER_EXTENSION   ReaderExtension,
    BOOLEAN             AutoLearn
    );

NTSTATUS
STCGetFirmwareRevision(
    PREADER_EXTENSION   ReaderExtension
    );

extern const STC_REGISTER STCInitialize[];
extern const STC_REGISTER STCClose[];

#endif  //  !__STC_COMMAND_H__


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\stc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       stc.h
//
//--------------------------------------------------------------------------

#if !defined( __STC_H__ )

#define __STC_H__

#define	NAD_IDX				0x00
#define PCB_IDX				0x01
#define LEN_IDX				0x02
#define DATA_IDX			0x03
#define PROLOGUE_LEN		0x03
#define EPILOGUE_LEN		0x01
#define PACKET_OVERHEAD		4

#define OSC					16000
#define FREQ				3580
#define CYC_TO_MS( cyc )	((ULONG)( cyc / FREQ ))

#define SW_SUCCESS			0x0090
#define SW_OE				0x0020
#define SW_FE				0x0040
#define SW_INSERTED			0xA064
#define SW_REMOVED			0xA164

//	register addresses
#define ADR_ETULENGTH15			0x00
#define ADR_ETULENGTH7			0x01
#define ADR_CGT8				0x02
#define ADR_CGT7				0x03
#define ADR_CWT31				0x04
#define ADR_CWT23				0x05
#define ADR_CWT15				0x06
#define ADR_CWT7				0x07
#define	ADR_BGT8				0x08
#define ADR_BGT7				0x09
#define ADR_BWT31				0x0A
#define ADR_BWT23				0x0B
#define ADR_BWT15				0x0C
#define ADR_BWT7				0x0D
#define ADR_TCON				0x0E
#define ADR_UART_CONTROL		0x0F
#define ADR_FIFO_CONFIG			0x10
#define ADR_INT_CONTROL			0x11
#define ADR_INT_STATUS			0x12
#define ADR_DATA				0x13
#define ADR_IO_CONFIG			0x14
#define ADR_SC_CONTROL			0x15
#define ADR_CLOCK_CONTROL		0x16
		

//	clock control register
#define M_CKE				0x01
#define M_OEN				0x02

//	ETU length register
#define M_ETU_RST			0x80
#define M_DIV				0x30
#define M_DIV1				0x20
#define M_DIV0				0x10
#define M_ETUH				0x0F

#define M_ETUL				0xFF

//	CGT length register 
#define M_CGTH				0x01
#define M_CGTL				0XFF

//	BGT length register
#define M_BGTH				0x01
#define M_BGTL				0xFF

//	CWT register
#define M_CWT4				0xFF
#define M_CWT3				0xFF
#define M_CWT2				0xFF
#define M_CWT1				0xFF

//	TCON register
#define M_MGT				0x80
#define M_MWT				0x40
#define M_WTR				0x04
#define M_GT				0x02
#define M_WT				0x01

//	UART control register
#define M_UEN				0x40
#define M_UART_RST			0x20
#define M_CONV				0x10
#define	M_TS				0x08
#define	M_PE				0x04
#define	M_R					0x03

//	FIFO config register
#define M_RFP				0x80
#define M_LD				0x0F

//	INT control register
#define	M_SSL				0x20
#define M_DRM				0x10
#define M_DSM				0x08
#define M_WTE				0x04
#define M_SIM				0x02
#define M_MEM				0x01
#define M_DRM_MEM			0x11

//	INT status register
#define M_FNE				0x80
#define M_FE				0x40
#define M_OE				0x20
#define M_DR				0x10
#define M_TRE				0x08
#define M_WTOVF				0x04
#define M_SENSE				0x02
#define M_MOV				0x01

//	SMART card interface
#define M_ALT1				0x20
#define M_ALT2				0x10
#define M_ALT0				0x08
#define M_SDE				0x04
#define M_SL				0x02
#define M_SD				0x01

//	SMART card control register
#define M_IO				0x80
#define M_VCE				0x40
#define M_SC_RST			0x20
#define M_SCE				0x10
#define M_SCK				0x08
#define M_C8				0x04
#define M_C4				0x02
#define M_VPE				0x01


//	Nad
#define HOST_TO_STC1				0x12	  
#define HOST_TO_STC2				0x52	  
#define HOST_TO_ICC1				0x02
#define HOST_TO_ICC2				0x42
#define STC1_TO_HOST				0x21
#define STC2_TO_HOST				0x25
#define ICC1_TO_HOST				0x20
#define ICC2_TO_HOST				0x24

//	PCB
#define PCB							0x00	 


#define CLA_READ_REGISTER			0x00
#define INS_READ_REGISTER			0xB0

#define CLA_WRITE_REGISTER			0x00
#define INS_WRITE_REGISTER			0xD0

#define CLA_READ_FIRMWARE_REVISION	0x00
#define INS_READ_FIRMWARE_REVISION	0xB1

#define PCB_DEFAULT					0x00
#define TLV_BUFFER_SIZE				0x20
#define ATR_SIZE					0x40	//	TS + 32 + SW + PROLOGUE + EPILOGUE...

#define MAX_T1_BLOCK_SIZE			270

//	ATR interface byte coding in TS
#define TAx							0x01
#define TBx							0x02
#define TCx							0x04
#define TDx							0x08


#define FREQ_DIV		1	//	3,58 MHz XTAL -> SC Clock = 3.58MHz
//#define FREQ_DIV	0x08	/* 30MHz XTAL -> SC Clock = 3.75MHz */ 

#define PROTOCOL_TO 		0
#define PROTOCOL_T1			1
#define PROTOCOL_T14		14
#define PROTOCOL_T15		15

//
//	DATA TYPES
//
typedef struct _STC_REGISTER
{
	UCHAR	Register;
	UCHAR	Size;
	ULONG	Value;

} STC_REGISTER, *PSTC_REGISTER;

#endif	//	! __STC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\stccmd.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       stccmd.c
//
//--------------------------------------------------------------------------


#if defined( SMCLIB_VXD )
#include "Driver98.h"
#include "Serial98.h"
#else
#include "DriverNT.h"
#include "SerialNT.h"
#endif  //      SMCLIB_VXD

#include "SerialIF.h"
#include "STCCmd.h"
#include "STC.h"

const STC_REGISTER STCInitialize[] = 
{
        { ADR_SC_CONTROL,               0x01,   0x00            },              //      reset
        { ADR_CLOCK_CONTROL,    0x01,   0x01            },
        { ADR_CLOCK_CONTROL,    0x01,   0x03            },
        { ADR_UART_CONTROL,             0x01,   0x27            },
        { ADR_UART_CONTROL,             0x01,   0x4F            },
        { ADR_IO_CONFIG,                0x01,   0x02            },              //      0x10 eva board
        { ADR_FIFO_CONFIG,              0x01,   0x81            },
        { ADR_INT_CONTROL,              0x01,   0x11            },
        { 0x0E,                                 0x01,   0xC0            },
        { 0x00,                                 0x00,   0x00            },
};

const STC_REGISTER STCClose[] = 
{
        { ADR_INT_CONTROL,              0x01,   0x00            },
        { ADR_SC_CONTROL,               0x01,   0x00            },              //      reset
        { ADR_UART_CONTROL,             0x01,   0x40            },
        { ADR_CLOCK_CONTROL,    0x01,   0x01            },
        { ADR_CLOCK_CONTROL,    0x01,   0x00            },
        { 0x00,                                 0x00,   0x00            },
};



NTSTATUS
STCReset( 
        PREADER_EXTENSION       ReaderExtension,
        UCHAR                           Device,
        BOOLEAN                         WarmReset,
        PUCHAR                          pATR,
        PULONG                          pATRLength
        )
/*++
STCReset:
        performs a reset of ICC

Arguments:
        ReaderExtension         context of call
        Device                          device requested ( ICC_1, ICC_2, PSCR )
        WarmReset                       kind of ICC reset
        pATR                            ptr to ATR buffer, NULL if no ATR required
        pATRLength                      size of ATR buffer / length of ATR

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_UNRECOGNIZED_MEDIA
        error values from IFRead / IFWrite

--*/
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;

        //      set UART to autolearn mode
        NTStatus = STCInitUART( ReaderExtension, TRUE );        

        if( NTStatus == STATUS_SUCCESS)
        {
                //
                //      set default frequency for ATR
                //
                NTStatus = STCSetFDIV( ReaderExtension, FREQ_DIV );     

                if( NTStatus == STATUS_SUCCESS && ( !WarmReset ))
                {
                        //
                        //      deactivate contacts
                        //
                        NTStatus = STCPowerOff( ReaderExtension );
                }

                if( NTStatus == STATUS_SUCCESS)
                {
                        
                        //
                        //      set power to card
                        //
                        if( NTStatus == STATUS_SUCCESS)
                        {
                                NTStatus = STCPowerOn( ReaderExtension );

                                if( NTStatus == STATUS_SUCCESS)
                                {
                                        NTStatus = STCReadATR( ReaderExtension, pATR, pATRLength );
                                }
                        }
                }
        }
        
        if( NTStatus != STATUS_SUCCESS )
        {
                STCPowerOff( ReaderExtension );
        }
        return( NTStatus );
}

NTSTATUS 
STCReadATR(
        PREADER_EXTENSION       ReaderExtension, 
        PUCHAR                          pATR, 
        PULONG                          pATRLen
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           T0_Yx, T0_K, Protocol;
        ULONG           ATRLen, BufferLength;

    ReaderExtension->ReadTimeout = 250;

        //      read TS if active low reset
        BufferLength = *pATRLen;
        NTStatus = STCReadICC1( 
        ReaderExtension, 
        pATR, 
        &BufferLength,
        1
        );

        if( NTStatus == STATUS_IO_TIMEOUT )
        {
                NTStatus = STCSetRST( ReaderExtension, TRUE );

                if( NTStatus == STATUS_SUCCESS )
                {
            BufferLength = *pATRLen;
                        NTStatus = STCReadICC1( 
                ReaderExtension, 
                pATR, 
                &BufferLength,
                1
                );
                }
        }

    ReaderExtension->ReadTimeout = 1200;
        Protocol = PROTOCOL_TO;
        ATRLen = 1;

        if( NTStatus == STATUS_SUCCESS )
        {
        BufferLength = *pATRLen - ATRLen;
                NTStatus = STCReadICC1( 
            ReaderExtension, 
            pATR + ATRLen, 
            &BufferLength,
            1
            );
                ATRLen++;
        
                if ( pATR[0] == 0x03 )          /* Direct convention */
                {
                        pATR[0] = 0x3F;
                }

                if ( ( pATR[0] != 0x3F ) && ( pATR[0] != 0x3B ) )
                {
                        NTStatus = STATUS_DATA_ERROR;
                }
                        
                if( NTStatus == STATUS_SUCCESS )
                {
                        ULONG   Request;

                        //      number of historical bytes
                        T0_K = (UCHAR) ( pATR[ATRLen-1] & 0x0F );

                        //      coding of TA, TB, TC, TD
                        T0_Yx = (UCHAR) ( pATR[ATRLen-1] & 0xF0 ) >> 4; 

                        while(( NTStatus == STATUS_SUCCESS ) && T0_Yx ) 
                        {       
                                UCHAR Mask;

                                //      evaluate presence of TA, TB, TC, TD 
                                Mask    = T0_Yx;
                                Request = 0;
                                while( Mask )
                                {
                                        if( Mask & 1 )
                                        {
                                                Request++;
                                        }
                                        Mask >>= 1;
                                }

                BufferLength = *pATRLen - ATRLen;
                                NTStatus = STCReadICC1( 
                    ReaderExtension, 
                    pATR + ATRLen, 
                    &BufferLength,
                    Request
                    );
                                ATRLen += Request;

                                if( T0_Yx & TDx )
                                {
                                        //      high nibble of TD codes the next set of TA, TB, TC, TD
                                        T0_Yx = ( pATR[ATRLen-1] & 0xF0 ) >> 4;
                                        //      low nibble of TD codes the protocol
                                        Protocol = pATR[ATRLen-1] & 0x0F;
                                }
                                else
                                {
                                        break;
                                }
                        }

                        if( NTStatus == STATUS_SUCCESS )
                        {
                                //      historical bytes
                BufferLength = *pATRLen - ATRLen;
                                NTStatus = STCReadICC1( 
                    ReaderExtension, 
                    pATR + ATRLen, 
                                        &BufferLength,
                    T0_K
                    );

                                //      check sum
                                if( NTStatus == STATUS_SUCCESS )
                                {
                                        ATRLen += T0_K;

                                        if( Protocol == PROTOCOL_T1 )
                                        {
                        BufferLength = *pATRLen - ATRLen;
                                                NTStatus = STCReadICC1( 
                            ReaderExtension, 
                            pATR + ATRLen, 
                                                        &BufferLength,
                            1
                            );
                                                if( NTStatus == STATUS_SUCCESS )
                                                {
                                                        ATRLen++;
                                                }
                                                else if( NTStatus == STATUS_IO_TIMEOUT )
                                                {
                                                        //      some cards don't support the TCK
                                                        NTStatus = STATUS_SUCCESS;
                                                }
                                        }
                                }
                        }
                }
        }

        if( NTStatus == STATUS_IO_TIMEOUT )
        {
                NTStatus = STATUS_UNRECOGNIZED_MEDIA;
        }

        if(NTStatus == STATUS_SUCCESS && pATRLen != NULL)
        {
                *pATRLen = ATRLen;
        }
        return( NTStatus );
}

NTSTATUS
STCWriteICC1(
        PREADER_EXTENSION       ReaderExtension,
        PUCHAR                          Data,
        ULONG                           DataLen
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        ULONG           BytesWritten = 0, Partial;      
        USHORT          SW = 0;
        UCHAR           IOData[STC_BUFFER_SIZE + 10];

        do
        {
                if(DataLen - BytesWritten > STC_BUFFER_SIZE - PACKET_OVERHEAD)
                {
                        Partial = STC_BUFFER_SIZE - PACKET_OVERHEAD;
                }
                else
                {
                        Partial = DataLen - BytesWritten;
                }

                IOData[NAD_IDX] = HOST_TO_ICC1;
                IOData[PCB_IDX] = PCB;
                IOData[LEN_IDX] = (UCHAR) Partial;

                SysCopyMemory( 
                        &IOData[DATA_IDX], 
                        Data + BytesWritten, 
                        Partial 
                        );

                IOData[Partial + 3] = IFCalcLRC(IOData, Partial + 3);

                NTStatus = IFWrite( 
                        ReaderExtension, 
                        IOData, 
                        Partial + 4 
                        );

                if( NTStatus == STATUS_SUCCESS )
                {
                        // read the status back from the reader
                        NTStatus = IFRead( 
                                ReaderExtension, 
                                IOData, 
                                6
                                );

                        if(NTStatus == STATUS_SUCCESS && 
                           *(PUSHORT) &IOData[DATA_IDX] != SW_SUCCESS ) {

                                SmartcardDebug( 
                                        DEBUG_ERROR,
                                        ("SCMSTCS!STCWriteICC1: Reader reported error %x\n", 
                                         *(PUSHORT) &IOData[DATA_IDX])
                                        );

                                NTStatus = STATUS_UNSUCCESSFUL;
                        }
                }

                BytesWritten += Partial;

        } while(BytesWritten < DataLen && NTStatus == STATUS_SUCCESS);

        return NTStatus;
}

NTSTATUS
STCReadICC1(
        PREADER_EXTENSION               ReaderExtension,
        PUCHAR                                  InData,
        PULONG                                  InDataLen,
    ULONG                   BytesRead
        )
{

        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           IOData[ STC_BUFFER_SIZE ];
        ULONG           Total = 0;

        while(NTStatus == STATUS_SUCCESS && Total < BytesRead)
        {
                //      read head
                NTStatus = IFRead( ReaderExtension, &IOData[0], 3 );

                if(NTStatus == STATUS_SUCCESS && IOData[LEN_IDX] < STC_BUFFER_SIZE - 4)
                {
                        //      read tail
                        NTStatus = IFRead( 
                                ReaderExtension, 
                                &IOData[DATA_IDX], 
                                IOData[LEN_IDX] + 1 
                                );

                        if( NTStatus == STATUS_SUCCESS )
                        {
                                if (IOData[NAD_IDX] == STC1_TO_HOST) {

                                        //
                                        // this is not good. We want to read smart card data, 
                                        // but the reader sent us a status packet, which can
                                        // only mean that something went wrong
                                        //
                                        SmartcardDebug( 
                                                DEBUG_ERROR,
                                                ( "SCMSTCS!STCReadICC1: Reader reported error %x\n",
                                                *(PUSHORT) &IOData[DATA_IDX])
                                                );

                                        NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
                                        break;
                                }

                if (Total + IOData[LEN_IDX] > *InDataLen) {

                    NTStatus = STATUS_BUFFER_TOO_SMALL;
                    break;                      
                }

                                SysCopyMemory( &InData[ Total ], &IOData[ DATA_IDX ], IOData[ LEN_IDX ] );
                                Total += IOData[ LEN_IDX ];
                        }
                }
        }

    *InDataLen = Total;

        return NTStatus;
}

NTSTATUS
STCPowerOff( PREADER_EXTENSION  ReaderExtension )
/*++
STCPowerOff:
        Deactivates the requested device

Arguments:
        ReaderExtension         context of call

Return Value:
        STATUS_SUCCESS
        error values from IFRead / IFWrite

--*/
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           SCCtrl;

        SCCtrl = 0x00;
        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1, &SCCtrl );

        return( NTStatus );
}

NTSTATUS
STCPowerOn( PREADER_EXTENSION ReaderExtension )
/*++
STCPowerOn:
        Deactivates the requested device

Arguments:
        ReaderExtension         context of call

Return Value:
        STATUS_SUCCESS
        error values from IFRead / IFWrite

--*/
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           SCCtrl;

        SCCtrl = 0x40;                  //      vcc
        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1, &SCCtrl );

        if( NTStatus == STATUS_SUCCESS )
        {
                SCCtrl = 0x41;          //      vpp
                NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1, &SCCtrl );

                if( NTStatus == STATUS_SUCCESS )
                {
                        SCCtrl=0xD1;    //       vcc, clk, io
                        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1, &SCCtrl );
                }
        }
        return( NTStatus );
}


NTSTATUS
STCSetRST(
        PREADER_EXTENSION       ReaderExtension,
        BOOLEAN                         On
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           SCCtrl;

        NTStatus = STCReadSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1,&SCCtrl );
        if( NTStatus == STATUS_SUCCESS )
        {
                if( On )
                {
                        SCCtrl |= 0x20;
                }
                else
                {
                        SCCtrl &= ~0x20;
                }

                NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1,&SCCtrl );
        }
        return(NTStatus);
}

NTSTATUS
STCConfigureSTC(        
        PREADER_EXTENSION       ReaderExtension,
        PSTC_REGISTER           pConfiguration
        )
{
        NTSTATUS                        NTStatus = STATUS_SUCCESS;
        UCHAR                           Value;

        do
        {

                if( pConfiguration->Register == ADR_INT_CONTROL )
                {
                        // Read interrupt status register to acknoledge wrong states
                        NTStatus = STCReadSTCRegister( ReaderExtension,ADR_INT_STATUS,1,&Value );
                }

                Value = (UCHAR)pConfiguration->Value;
                NTStatus = STCWriteSTCRegister(
                        ReaderExtension,
                        pConfiguration->Register,
                        pConfiguration->Size,
                        (PUCHAR)&pConfiguration->Value
                        );

                // delay to stabilize the oscilator clock:
                if( pConfiguration->Register == ADR_CLOCK_CONTROL )
                {
                        SysDelay( 50 );
                }
                pConfiguration++;

        } while(( NTStatus == STATUS_SUCCESS ) && ( pConfiguration->Size ));

        return (NTStatus);      
}

NTSTATUS STCReadSTCRegister(
        PREADER_EXTENSION       ReaderExtension,
        UCHAR                           Address,
        ULONG                           Size,
        PUCHAR                          pValue
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           IOData[ STC_BUFFER_SIZE ] =
        {
                HOST_TO_STC1,
                PCB,
                6,
                CLA_READ_REGISTER,
                INS_READ_REGISTER,
                0x00,
                Address,
                0x00,
                (UCHAR) Size
        };

        IOData[ 9 ] = IFCalcLRC( IOData, 9 );

        NTStatus = IFWrite( ReaderExtension, IOData, 10 );
        ASSERT(NTStatus == STATUS_SUCCESS);

        if( NTStatus == STATUS_SUCCESS )
        {
                NTStatus = IFRead( ReaderExtension, IOData, Size + 2 + 4 );

                if( NTStatus == STATUS_SUCCESS )
                {
                        //
                        //      check return code & size
                        //
                        USHORT shrtBuf;

                        RtlRetrieveUshort(&shrtBuf, &IOData[DATA_IDX + Size]);

                        if( shrtBuf == SW_SUCCESS )
                        {
                                SysCopyMemory( pValue, &IOData[ DATA_IDX ] , Size );
                        }
                        else
                        {
                                ASSERT(FALSE);
                                NTStatus = STATUS_DATA_ERROR;
                        }
                }
        }
        return( NTStatus );
}


NTSTATUS
STCWriteSTCRegister(
        PREADER_EXTENSION       ReaderExtension,
        UCHAR                           Address,
        ULONG                           Size,
        PUCHAR                          pValue
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           IOData[STC_BUFFER_SIZE] =
        {
                HOST_TO_STC1,
                PCB,
                (UCHAR)( 5+Size ),
                CLA_WRITE_REGISTER,
                INS_WRITE_REGISTER,
                0x00,
                Address,
                (UCHAR) Size
        };

        SysCopyMemory( &IOData[ 8 ], pValue, Size );

        IOData[ 8+Size ] = IFCalcLRC( IOData, 8 + Size );

        NTStatus = IFWrite( ReaderExtension, IOData, 9 + Size );

        if( NTStatus == STATUS_SUCCESS )
        {
                NTStatus = IFRead( ReaderExtension, IOData, 6 );

                if(( NTStatus == STATUS_SUCCESS ) && ( *(PUSHORT)&IOData[ DATA_IDX ] != 0x0090 ))
                {
                        NTStatus = STATUS_DATA_ERROR;
                }
        }
        return( NTStatus );
}

NTSTATUS
STCSetETU(
        PREADER_EXTENSION       ReaderExtension,
        ULONG                           NewETU
        )
{
        NTSTATUS        NTStatus = STATUS_DATA_ERROR;
        UCHAR           ETU[2];

        if( NewETU < 0x0FFF )
        {
                NTStatus = STCReadSTCRegister(
                        ReaderExtension,
                        ADR_ETULENGTH15,
                        1,
                        ETU
                        );

                if( NTStatus == STATUS_SUCCESS )
                {
                        //
                        //      save all RFU bits
                        //
                        ETU[1]  = (UCHAR) NewETU;
                        ETU[0]  = (UCHAR)(( ETU[0] & 0xF0 ) | ( NewETU >> 8 ));

                        NTStatus = STCWriteSTCRegister(
                                ReaderExtension,
                                ADR_ETULENGTH15,
                                2,
                                ETU
                                );
                }
        }
        return(NTStatus);
}

NTSTATUS
STCSetCGT(
        PREADER_EXTENSION       ReaderExtension,
        ULONG                           NewCGT
        )
{
        NTSTATUS        NTStatus = STATUS_DATA_ERROR;
        UCHAR           CGT[2];
        
        if( NewCGT < 0x01FF )
        {
                NTStatus = STCReadSTCRegister(
                        ReaderExtension,
                        ADR_CGT8,
                        2,
                        CGT
                        );

                if( NTStatus == STATUS_SUCCESS )
                {
                        //
                        //      save all RFU bits
                        //
                        CGT[1] = ( UCHAR )NewCGT;
                        CGT[0] = (UCHAR)(( CGT[0] & 0xFE ) | ( NewCGT >> 8 ));
                                
                        NTStatus = STCWriteSTCRegister(
                                ReaderExtension,
                                ADR_CGT8,
                                2,
                                CGT
                                );
                }
        }
        return(NTStatus);
}

NTSTATUS
STCSetCWT(
        PREADER_EXTENSION       ReaderExtension,
        ULONG                           NewCWT
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           CWT[4];

        //      little indians...
        CWT[0] = (( PUCHAR )&NewCWT )[3];
        CWT[1] = (( PUCHAR )&NewCWT )[2];
        CWT[2] = (( PUCHAR )&NewCWT )[1];
        CWT[3] = (( PUCHAR )&NewCWT )[0];
        
        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_CWT31, 4, CWT );
        return(NTStatus);
}

NTSTATUS
STCSetBWT(
        PREADER_EXTENSION       ReaderExtension,
        ULONG                           NewBWT
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           BWT[4];

        //      little indians...
        BWT[0] = (( PUCHAR )&NewBWT )[3];
        BWT[1] = (( PUCHAR )&NewBWT )[2];
        BWT[2] = (( PUCHAR )&NewBWT )[1];
        BWT[3] = (( PUCHAR )&NewBWT )[0];
        
        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_BWT31, 4, BWT );

        return(NTStatus);
}


NTSTATUS
STCSetFDIV(
        PREADER_EXTENSION       ReaderExtension,
        ULONG                           Factor
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           DIV;
        
        NTStatus = STCReadSTCRegister( ReaderExtension, ADR_ETULENGTH15, 1, &DIV );

        if( NTStatus == STATUS_SUCCESS ) 
        {
                switch( Factor )
                {
                        case 1:
                                DIV &= ~M_DIV0;
                                DIV &= ~M_DIV1;
                                break;
                        
                        case 2:
                                DIV |= M_DIV0;
                                DIV &= ~M_DIV1;
                                break;
                        
                        case 4  :
                                DIV &= ~M_DIV0;
                                DIV |= M_DIV1;
                                break;
                        
                        case 8  :
                                DIV |= M_DIV0;
                                DIV |= M_DIV1;
                                break;

                        default :
                                NTStatus = STATUS_DATA_ERROR;
                }
                if( NTStatus == STATUS_SUCCESS ) 
                {
                        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_ETULENGTH15, 1, &DIV );
                }
        }
        return(NTStatus);       
}

NTSTATUS 
STCInitUART(
        PREADER_EXTENSION       ReaderExtension,
        BOOLEAN                         AutoLearn
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           Value;

        Value = AutoLearn ? 0x6F : 0x66;

        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_UART_CONTROL, 1, &Value );

        return( NTStatus );
}

NTSTATUS
STCGetFirmwareRevision(
        PREADER_EXTENSION       ReaderExtension
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           IOData[ STC_BUFFER_SIZE ] =
        {
                HOST_TO_STC1,
                PCB,
                6,
                CLA_READ_FIRMWARE_REVISION,
                INS_READ_FIRMWARE_REVISION,
                0x00,
                0x00,
                0x00,
                0x02
        };

        IOData[ 9 ] = IFCalcLRC( IOData, 9 );

        NTStatus = IFWrite( ReaderExtension, IOData, 10 );

        if( NTStatus == STATUS_SUCCESS )
        {
                NTStatus = IFRead( ReaderExtension, IOData, 6 );

                if( NTStatus == STATUS_SUCCESS )
                {
                        ReaderExtension->FirmwareMajor = IOData[ DATA_IDX ];
                        ReaderExtension->FirmwareMinor = IOData[ DATA_IDX + 1 ];
                }
        }
        return( STATUS_SUCCESS );
}

//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\t0hndlr.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       t0hndlr.c
//
//--------------------------------------------------------------------------

#if defined( SMCLIB_VXD )
#include "Driver98.h"
#else
#include "DriverNT.h"
#endif	//	SMCLIB_VXD

#include "SerialIF.h"
#include "STCCmd.h"
#include "T0Hndlr.h"

NTSTATUS
T0_ExchangeData(
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pRequest,
	ULONG				RequestLen,
	PUCHAR				pReply,
	PULONG				pReplyLen
	)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
	NTSTATUS	NTStatus = STATUS_SUCCESS;
    BOOLEAN     restartWorkWaitingTime = FALSE;
    ULONG       bytesWritten, totalBytesToWrite, totalBytesToRead;
    ULONG       bytesToWrite, bytesRead, ioBufferLen;
    UCHAR       ioBuffer[512];

    totalBytesToWrite = RequestLen;
    totalBytesToRead = ReaderExtension->SmartcardExtension->T0.Le + 2;
    bytesRead = 0;

    // start with writing the header of the request
    bytesToWrite = 5;
    bytesWritten = 0;

    __try {

        do {

            if (restartWorkWaitingTime == FALSE) {

                NTStatus = STCWriteICC1( 
                    ReaderExtension, 
                    pRequest + bytesWritten, 
                    bytesToWrite
                    );
                ASSERT(NTStatus != STATUS_BUFFER_TOO_SMALL);

                if (NTStatus != STATUS_SUCCESS) {

                    __leave;
                }

                bytesWritten += bytesToWrite;
                totalBytesToWrite -= bytesToWrite;
            }

            //
            // try to read the pcb, the card could 
            // also answer with a status word
            //
            ioBufferLen = sizeof(ioBuffer);
	        NTStatus = STCReadICC1( 
                ReaderExtension, 
                ioBuffer, 
				&ioBufferLen,
                1
                );
            ASSERT(NTStatus != STATUS_BUFFER_TOO_SMALL);

            restartWorkWaitingTime = FALSE;

            if (NTStatus != STATUS_SUCCESS) {

                __leave;
            }

            if (ioBuffer[0] == 0x60) {

                //
                // Set flag that we only should read the proc byte
                // without writing data to the card
                //
                restartWorkWaitingTime = TRUE;
                continue;
            }

            if ((ioBuffer[0] & 0xFE) == pRequest[1]) {
        
                // we can send all remaining bytes at once.
                bytesToWrite = totalBytesToWrite;

            } else if(ioBuffer[0] == (UCHAR) ~pRequest[1]) {
                
                // we can only send the next byte
                bytesToWrite = 1;

            } else {

                // this must be a status word

                totalBytesToWrite = 0;
                totalBytesToRead = 0;

                pReply[0] = ioBuffer[0];

                if (ioBufferLen == 2) {
                 	
                    //
                    // the reader returned already the 
                    // 2nd byte of the status word
                    //
                    pReply[1] = ioBuffer[1];

                } else {
                 	
                    // we have to read the 2nd byte of the status word
                    ioBufferLen = sizeof(ioBuffer);
	                NTStatus = STCReadICC1( 
                        ReaderExtension, 
                        ioBuffer, 
						&ioBufferLen,
                        1
                        );
                    ASSERT(NTStatus != STATUS_BUFFER_TOO_SMALL);

                    if (NTStatus != STATUS_SUCCESS) {

                        __leave;
                    }
                    if (ioBufferLen != 1) {

                        NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
                        __leave;
                    }
                    pReply[1] = ioBuffer[0];
                }

                *pReplyLen = 2;
            }

        } while (totalBytesToWrite || restartWorkWaitingTime);

        if (totalBytesToRead != 0) {

            ioBufferLen = *pReplyLen;
	        NTStatus = STCReadICC1( 
                ReaderExtension, 
                pReply, 
				&ioBufferLen,
                totalBytesToRead
                );

            if (NTStatus != STATUS_SUCCESS) {

                __leave;
            }

            *pReplyLen = ioBufferLen;
        }
    }
    __finally {

    }

	return NTStatus;		
}

//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scmstcs\t0hndlr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       t0hndlr.h
//
//--------------------------------------------------------------------------

#if !defined( __T0_HANDLER_H__ )
#define __T0_HANDLER_H__

NTSTATUS
T0_ExchangeData(
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pRequest,
	ULONG				RequestLen,
	PUCHAR				pReply,
	PULONG				pReplyLen
	);

#endif	//	!__T0_HANDLER_H__


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scutil\irplist.c ===
#include <pch.h>
#include "irplist.h"

void
IrpList_InitEx(
    PIRP_LIST IrpList,
    PKSPIN_LOCK ListLock,
    PDRIVER_CANCEL CancelRoutine,
    PIRP_COMPLETION_ROUTINE IrpCompletionRoutine
    )
/*++

Routine Description:
   
    Initialize the IrpList

Arguments:

    IrpList - Pointer to the IrpList structure
    
    ListLock - Pointer to the spinlock for the IrpList
    
    CancelRoutine - Routine to be called when an Irp on the IrpList 
                    is cancelled
                    
    IrpCompletionRoutine - Optional Completion routine for an Irp on the IrpList

Return Value:

    VOID
    
--*/
{
    LockedList_Init(&IrpList->LockedList, ListLock);

    ASSERT(CancelRoutine != NULL);
    IrpList->CancelRoutine = CancelRoutine;
    IrpList->IrpCompletionRoutine = IrpCompletionRoutine;
}

NTSTATUS
IrpList_EnqueueLocked(
    PIRP_LIST IrpList,
    PIRP Irp,
    BOOLEAN StoreListInIrp,
    BOOLEAN InsertTail
    )
/*++

Routine Description:
   
    Enqueues an Irp on the IrpList. 
    Assumes the caller has acquired the IrpList Spinlock.

Arguments:

    IrpList - Pointer to the IrpList structure
    
    Irp - Pointer to the Irp to Enqueue
    
    StoreListInIrp - Set to TRUE is the Irp will be used to store the 
                    list entry
    
    InsertTail - Set to TRUE if Irp is to be enqueued at
                the tail of the IrpList.

Return Value:

    NTSTATUS - STATUS_SUCCESS or appropriate error code
    
--*/
{
    PDRIVER_CANCEL oldCancelRoutine;
    NTSTATUS status;

    //
    // must set a cancel routine before checking the Cancel flag
    //
    oldCancelRoutine = IoSetCancelRoutine(Irp, IrpList->CancelRoutine);
    ASSERT(oldCancelRoutine == NULL);

    if (Irp->Cancel) {
        //
        // This IRP has already been cancelled, so complete it now.
        // We must clear the cancel routine before completing the IRP.
        // We must release the spinlock before calling out of the driver.
        //
        oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
        if (oldCancelRoutine != NULL) {
            //
            // The cancel routine was NOT called
            //
            ASSERT(oldCancelRoutine == IrpList->CancelRoutine);
            status = STATUS_CANCELLED;
        }
        else {
            //
            // The cancel routine was called.  As soon as we drop the spinlock, 
            // it will dequeue and complete the IRP.  Increase the count because
            // the cancel routine will decrement it.
            //
            IrpList->LockedList.Count++;

            InitializeListHead(&Irp->Tail.Overlay.ListEntry);
            IoMarkIrpPending(Irp);
            status = Irp->IoStatus.Status = STATUS_PENDING;

            //
            // save a ptr to this structure in the Irp for the cancel routine.
            //
            if (StoreListInIrp) {
                Irp->Tail.Overlay.DriverContext[IRP_LIST_INDEX] = IrpList;
            }
        }
    }
    else {
        if (InsertTail) {
            LL_ADD_TAIL(&IrpList->LockedList, &Irp->Tail.Overlay.ListEntry);
        }
        else {
            LL_ADD_HEAD(&IrpList->LockedList, &Irp->Tail.Overlay.ListEntry);
        }
        IoMarkIrpPending(Irp);
        status = Irp->IoStatus.Status = STATUS_PENDING;

        //
        // save a ptr to this structure in the Irp for the cancel routine.
        //
        if (StoreListInIrp) {
            Irp->Tail.Overlay.DriverContext[IRP_LIST_INDEX] = IrpList;
        }
    }

    return status;
}

NTSTATUS
IrpList_EnqueueEx(
    PIRP_LIST IrpList,
    PIRP Irp,
    BOOLEAN StoreListInIrp
    )
/*++

Routine Description:
   
    Enqueues an Irp on the IrpList. 

Arguments:

    IrpList - Pointer to the IrpList structure
    
    Irp - Pointer to the Irp to Enqueue
    
    StoreListInIrp - Set to TRUE is the Irp will be used to store the 
                    list entry

Return Value:

    NTSTATUS - STATUS_SUCCESS or appropriate error code
    
--*/
{
    NTSTATUS status;
    KIRQL irql;

    LL_LOCK(&IrpList->LockedList, &irql);
    status = IrpList_EnqueueLocked(IrpList, Irp, StoreListInIrp, TRUE);
    LL_UNLOCK(&IrpList->LockedList, irql);

    return status;
}

BOOLEAN 
IrpList_MakeNonCancellable(
    PIRP_LIST   IrpList,
    PIRP        Irp
    )
/*++

Routine Description:
   
    Sets the Irp Cancel routine to NULL, making it non-cancellable. 

Arguments:

    IrpList - Pointer to the IrpList structure
    
    Irp - Pointer to the Irp to Enqueue
    

Return Value:

    BOOLEAN - TRUE if we succeeded in making the Irp non-cancellable.
    
    
--*/
{
    PDRIVER_CANCEL oldCancelRoutine;
    BOOLEAN result;
    
    result = FALSE;
    oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);

    //
    // IoCancelIrp() could have just been called on this IRP.
    // What we're interested in is not whether IoCancelIrp() was called
    // (ie, nextIrp->Cancel is set), but whether IoCancelIrp() called (or
    // is about to call) our cancel routine. To check that, check the result
    // of the test-and-set macro IoSetCancelRoutine.
    //
    if (oldCancelRoutine != NULL) {
        //
        //  Cancel routine not called for this IRP.  Return this IRP.
        //
        ASSERT (oldCancelRoutine == IrpList->CancelRoutine);
        Irp->Tail.Overlay.DriverContext[IRP_LIST_INDEX] = NULL;
        result = TRUE;        
    }
    else {
        //
        // This IRP was just cancelled and the cancel routine was (or will
        // be) called. The cancel routine will complete this IRP as soon as
        // we drop the spinlock. So don't do anything with the IRP.
        //
        // Also, the cancel routine will try to dequeue the IRP, so make the
        // IRP's listEntry point to itself.
        //
        ASSERT(Irp->Cancel);

        InitializeListHead(&Irp->Tail.Overlay.ListEntry);
        result = FALSE;
    }

    return result;
}
 
PIRP
IrpList_DequeueLocked(
    PIRP_LIST IrpList
    )
{
/*++

Routine Description:
   
    Dequeue an IRP from the head of the IrpList.
    Assumes the caller has acquired the IrpList SpinLock.

Arguments:

    IrpList - Pointer to the IrpList structure
    

Return Value:

    PIRP - Pointer to the Irp dequeued form the IrpList. 
            NULL if no IRP is avaliable.
    
--*/
    PIRP nextIrp = NULL;
    PLIST_ENTRY ple;

    nextIrp = NULL;
    while (nextIrp == NULL && !IsListEmpty(&IrpList->LockedList.ListHead)){
        ple = LL_REMOVE_HEAD(&IrpList->LockedList);

        //
        // Get the next IRP off the queue and clear the cancel routine
        //
        nextIrp = CONTAINING_RECORD(ple, IRP, Tail.Overlay.ListEntry);
        if (IrpList_MakeNonCancellable(IrpList, nextIrp) == FALSE) {
            nextIrp = NULL;        
        }
    }

    return nextIrp;
}

PIRP 
IrpList_Dequeue(
    PIRP_LIST IrpList
    )
/*++

Routine Description:
   
    Dequeue an IRP from the head of the IrpList.

Arguments:

    IrpList - Pointer to the IrpList structure
    

Return Value:

    PIRP - Pointer to the Irp dequeued form the IrpList. 
            NULL if no IRP is avaliable.
    
--*/
{
    PIRP irp;
    KIRQL irql;

    LL_LOCK(&IrpList->LockedList, &irql);
    irp = IrpList_DequeueLocked(IrpList);
    LL_UNLOCK(&IrpList->LockedList, irql);

    return irp;
}

BOOLEAN
IrpList_DequeueIrp(
    PIRP_LIST   IrpList,
    PIRP        Irp
    )
/*++

Routine Description:
   
    Dequeue a specific IRP from the IrpList.

Arguments:

    IrpList - Pointer to the IrpList structure
    
    Irp - Pointer to an IRP contained in the IrpList.
    

Return Value:

    BOOLEAN - TRUE is the IRP was successfully removed off the IrpList
    
--*/
{
    KIRQL irql;
    BOOLEAN result;
        
    LL_LOCK(&IrpList->LockedList, &irql);
    result = IrpList_DequeueIrpLocked(IrpList, Irp);
    LL_UNLOCK(&IrpList->LockedList, irql);
    
    return result;
}

BOOLEAN 
IrpList_DequeueIrpLocked(
    PIRP_LIST IrpList,
    PIRP Irp
    )
/*++

Routine Description:
   
    Dequeue a specific IRP from the IrpList
    Assumes the caller has acquired the IrpList spinlock

Arguments:

    IrpList - Pointer to the IrpList structure
    
    Irp - Pointer to an IRP contained in the IrpList.
    

Return Value:

    BOOLEAN - TRUE is the IRP was successfully removed off the IrpList
    
--*/
{
    PLIST_ENTRY ple;
    PIRP pIrp;
    BOOLEAN result;
    
    result = FALSE;
                
    for (ple = IrpList->LockedList.ListHead.Flink;
         ple != &IrpList->LockedList.ListHead;
         ple = ple->Flink) {
        pIrp = CONTAINING_RECORD(ple, IRP, Tail.Overlay.ListEntry);

        if (pIrp == Irp) {
            RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
            IrpList->LockedList.Count--;
            
            result = IrpList_MakeNonCancellable(IrpList, pIrp);
            break;
        }
    }

    return result;
}

ULONG 
IrpList_ProcessAndDrain(
    PIRP_LIST       IrpList,
    PFNPROCESSIRP   FnProcessIrp,
    PVOID           Context,
    PLIST_ENTRY     DrainHead
    )
/*++

Routine Description:
        
    Remove all cancellable Irps from the IrpList and process.   

Arguments:

    IrpList - Pointer to the IrpList structure
    
    FnProcessIrp - Function to process the Irp
    
    Context - Context to pass into the FnProcessIrp
    
    DrainHead - Pointer to LIST_ENTRY to hold dequeued IRPs
    

Return Value:
    
    ULONG - Number of IRPs processed
    
--*/
{
    ULONG count;
    KIRQL irql;
        
    LL_LOCK(&IrpList->LockedList, &irql);
    count = IrpList_ProcessAndDrainLocked(
        IrpList, FnProcessIrp, Context, DrainHead);
    LL_UNLOCK(&IrpList->LockedList, irql);

    return count;
}

ULONG 
IrpList_ProcessAndDrainLocked(
    PIRP_LIST       IrpList,
    PFNPROCESSIRP   FnProcessIrp,
    PVOID           Context,
    PLIST_ENTRY     DrainHead
    )
/*++

Routine Description:
        
    Remove all cancellable Irps from the IrpList and process
    Assumes that the caller has acquired the IrpList Spinlock.   

Arguments:

    IrpList - Pointer to the IrpList structure
    
    FnProcessIrp - Function to process the Irp
    
    Context - Context to pass into the FnProcessIrp
    
    DrainHead - Pointer to LIST_ENTRY to hold dequeued IRPs
    

Return Value:
    
    ULONG - Number of IRPs processed
    
--*/
{
    PLIST_ENTRY ple;
    PIRP pIrp;
    NTSTATUS status;
    ULONG count;
    
    count = 0;    
    ASSERT(FnProcessIrp != NULL);
        
    for (ple = IrpList->LockedList.ListHead.Flink;
         ple != &IrpList->LockedList.ListHead;
         /* ple = ple->Flink */) {
        
        pIrp = CONTAINING_RECORD(ple, IRP, Tail.Overlay.ListEntry);

        //
        // Advance immediately so we don't lose the next link in the list in 
        // case we remove the current irp.
        //
        ple = ple->Flink;
        
        if (FnProcessIrp(Context, pIrp)) { 
            RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
            IrpList->LockedList.Count--;
            
            if (IrpList_MakeNonCancellable(IrpList, pIrp)) {            
                InsertTailList(DrainHead, &pIrp->Tail.Overlay.ListEntry);
                count++;
            }
        }
    }
        
    return count;
}
  
ULONG
IrpList_DrainLocked(
    PIRP_LIST IrpList,
    PLIST_ENTRY DrainHead
    )
/*++

Routine Description:
        
    Remove all cancellable Irps from the IrpList and queue to the DrainHead

Arguments:

    IrpList - Pointer to the IrpList structure
    
    DrainHead - Pointer to LIST_ENTRY to hold dequeued IRPs

Return Value:
    
    ULONG - Number of IRPs processed
    
--*/
{
    PIRP irp;
    ULONG count;

    count = 0;

    while (TRUE) {
        irp = IrpList_DequeueLocked(IrpList);
        if (irp != NULL) {
            InsertTailList(DrainHead, &irp->Tail.Overlay.ListEntry);
            count++;
        }
        else {
            break;
        }
    }
    ASSERT(LL_GET_COUNT(&IrpList->LockedList) == 0);

    return count;
}

ULONG
IrpList_DrainLockedByFileObject(
    PIRP_LIST IrpList,
    PLIST_ENTRY DrainHead,
    PFILE_OBJECT FileObject
    )
/*++

Routine Description:
        
    Remove all cancellable Irps for specified FileObject
    from the IrpList and queue to the DrainHead

Arguments:

    IrpList - Pointer to the IrpList structure
    
    DrainHead - Pointer to LIST_ENTRY to hold dequeued IRPs
    
    FileObject - Pointer to specified FILE_OBJECT 

Return Value:
    
    ULONG - Number of IRPs processed
    
--*/
{
    PIRP pIrp;
    PDRIVER_CANCEL pOldCancelRoutine;
    PIO_STACK_LOCATION pStack;
    ULONG count;
    PLIST_ENTRY ple;

    count = 0;
    ASSERT(FileObject != NULL);

    for (ple = IrpList->LockedList.ListHead.Flink;
         ple != &IrpList->LockedList.ListHead;
         /* ple = ple->Flink */) {
        
        pIrp = CONTAINING_RECORD(ple, IRP, Tail.Overlay.ListEntry);

        //
        // Advance immediately so we don't lose the next link in the list in 
        // case we remove the current irp.
        //
        ple = ple->Flink;

        pStack = IoGetCurrentIrpStackLocation(pIrp);
        if (pStack->FileObject == FileObject) {
            RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
            IrpList->LockedList.Count--;

            if (IrpList_MakeNonCancellable(IrpList, pIrp)) {
                InsertTailList(DrainHead, &pIrp->Tail.Overlay.ListEntry);
                count++;
            }
        }
    }

    return count;
}

ULONG
IrpList_Drain(
    PIRP_LIST IrpList,
    PLIST_ENTRY DrainHead
    )
/*++

Routine Description:
        
    Remove all cancellable IRPs and queue to DrainHead

Arguments:

    IrpList - Pointer to the IrpList structure
    
    DrainHead - Pointer to LIST_ENTRY to hold dequeued IRPs
    
Return Value:
    
    ULONG - Number of IRPs processed
    
--*/
{
    ULONG count;
    KIRQL irql;

    LL_LOCK(&IrpList->LockedList, &irql);
    count = IrpList_DrainLocked(IrpList, DrainHead);
    LL_UNLOCK(&IrpList->LockedList, irql);

    return count;
}

void
IrpList_HandleCancel(
    PIRP_LIST IrpList,
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:
        
    Cancel Routine for IRPs on the IrpList
    
Arguments:

    IrpList - Pointer to the IrpList structure
    
    DeviceObject - Device Object, used for IrpCompletionRoutine 
    
Return Value:
    
    VOID
    
--*/
{
    KIRQL irql;

    //
    //  Release the global cancel spinlock.  
    //  Do this while not holding any other spinlocks so that we exit at the
    //  right IRQL.
    //
    IoReleaseCancelSpinLock (Irp->CancelIrql);  

    //
    // Dequeue and complete the IRP.  The enqueue and dequeue functions
    // synchronize properly so that if this cancel routine is called, 
    // the dequeue is safe and only the cancel routine will complete the IRP.
    //
    LL_LOCK(&IrpList->LockedList, &irql);
    if (!IsListEmpty(&Irp->Tail.Overlay.ListEntry)) {
        RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
        IrpList->LockedList.Count--;
    }
    LL_UNLOCK(&IrpList->LockedList, irql);

    if (IrpList->IrpCompletionRoutine != NULL) {
        (void) IrpList->IrpCompletionRoutine(
            DeviceObject, Irp, STATUS_CANCELLED);
    }
    else {
        //
        // Complete the IRP.  This is a call outside the driver, so all
        // spinlocks must be released by this point.
        //
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
}



void
IrpList_CancelRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )
{

    PSCUTIL_EXTENSION pExt;
    KIRQL oldIrql;
    PIO_STACK_LOCATION irpSp;

    pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);

    irpSp = IoGetNextIrpStackLocation(Irp);
    if (irpSp->CompletionRoutine) {
        Irp->IoStatus.Status = STATUS_CANCELLED;
        irpSp->CompletionRoutine(DeviceObject,
                                 Irp,
                                 irpSp->Context);
    }

    IoReleaseRemoveLock(pExt->RemoveLock,
                        Irp);
    
    DecIoCount(pExt);

    IrpList_HandleCancel(IRP_LIST_FROM_IRP(Irp),
                         DeviceObject,
                         Irp);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scutil\irplist.h ===
/***************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:

        irplist.H

Abstract:

        Private interface for Smartcard Driver Utility Library

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        05/14/2002 : created

Authors:

        Randy Aull


****************************************************************************/


#ifndef __IRPLIST_H__
#define __IRPLIST_H__

typedef struct _LOCKED_LIST {
    LIST_ENTRY ListHead;
    KSPIN_LOCK SpinLock;
    PKSPIN_LOCK ListLock;
    LONG Count;
} LOCKED_LIST, *PLOCKED_LIST;
                      
typedef BOOLEAN (*PFNLOCKED_LIST_PROCESS)(PVOID Context, PLIST_ENTRY ListEntry);

#define INIT_LOCKED_LIST(l)                 \
{                                           \
    InitializeListHead(&(l)->ListHead);     \
    KeInitializeSpinLock(&(l)->SpinLock);   \
    (l)->ListLock = &(l)->SpinLock;         \
    (l)->Count = 0;                         \
}

void
LockedList_Init(
    PLOCKED_LIST LockedList,
    PKSPIN_LOCK ListLock
    );

void
LockedList_EnqueueHead(
    PLOCKED_LIST LockedList,
    PLIST_ENTRY ListEntry
    );

void
LockedList_EnqueueTail(
    PLOCKED_LIST LockedList,
    PLIST_ENTRY ListEntry
    );

void
LockedList_EnqueueAfter(
    PLOCKED_LIST LockedList,
    PLIST_ENTRY Entry,
    PLIST_ENTRY Location
    );

PLIST_ENTRY
LockedList_RemoveHead(
    PLOCKED_LIST LockedList
    );

PLIST_ENTRY
LockedList_RemoveEntryLocked(
    PLOCKED_LIST    LockedList,
    PLIST_ENTRY     Entry
    );

PLIST_ENTRY
LockedList_RemoveEntry(
    PLOCKED_LIST LockedList,
    PLIST_ENTRY Entry
    );

LONG
LockedList_GetCount(
    PLOCKED_LIST LockedList
    );

LONG
LockedList_Drain(
    PLOCKED_LIST LockedList,
    PLIST_ENTRY DrainListHead
    );

BOOLEAN
List_Process(
    PLIST_ENTRY ListHead,
    PFNLOCKED_LIST_PROCESS Process,
    PVOID ProcessContext
    );

BOOLEAN
LockedList_ProcessLocked(
    PLOCKED_LIST LockedList,
    PFNLOCKED_LIST_PROCESS Process,
    PVOID ProcessContext
    );

BOOLEAN
LockedList_Process(
    PLOCKED_LIST LockedList,
    BOOLEAN LockAtPassive,
    PFNLOCKED_LIST_PROCESS Process,
    PVOID ProcessContext
    );


#define LL_LOCK(l, k)   KeAcquireSpinLock((l)->ListLock, (k))
#define LL_UNLOCK(l, k) KeReleaseSpinLock((l)->ListLock, (k))

#define LL_LOCK_AT_DPC(l)     KeAcquireSpinLockAtDpcLevel((l)->ListLock)
#define LL_UNLOCK_FROM_DPC(l) KeReleaseSpinLockFromDpcLevel((l)->ListLock)

#define LL_GET_COUNT(l) (l)->Count

#define LL_ADD_TAIL(l, e)               \
{                                       \
    InsertTailList(&(l)->ListHead, (e));\
    (l)->Count++;                       \
}

#define LL_ADD_TAIL_REF(l, e, r)    \
{                                   \
    LL_ADD_TAIL(l, e);              \
    RefObj_AddRef(r);               \
}

#define LL_ADD_HEAD(l, e)               \
{                                       \
    InsertHeadList(&(l)->ListHead, (e));\
    (l)->Count++;                       \
}

#define LL_ADD_HEAD_REF(l, e, r)    \
{                                   \
    LL_ADD_HEAD(l, e);              \
    RefObj_AddRef(r);               \
}

#define LL_REMOVE_HEAD(l)   RemoveHeadList(&(l)->ListHead); (l)->Count--
#define LL_REMOVE_TAIL(l)   RemoveTailList(&(l)->ListHead); (l)->Count--

#define IRP_LIST_INDEX      (3)

typedef
NTSTATUS
(*PIRP_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS Status
    );

typedef struct _IRP_LIST {

    LOCKED_LIST LockedList;

    PDRIVER_CANCEL CancelRoutine;

    //
    // Routiune to call from the CancelRoutine when the IRP is cancelled
    //
    PIRP_COMPLETION_ROUTINE IrpCompletionRoutine;

    //
    // IRP_LIST assumes that the remove lock logic is done outside of enqueue /
    // dequeue / cancel because the caller of XXX_Enqueue will have no way of
    // knowing if the remlock was acquired if it returns !NT_SUCCESS()
    //
    // PIO_REMOVE_LOCK IoRemoveLock;

} IRP_LIST, *PIRP_LIST;

#define IRP_LIST_FROM_IRP(irp)  \
    (PIRP_LIST) ((irp)->Tail.Overlay.DriverContext[IRP_LIST_INDEX])

//
// void
// IrpList_Init(
//     PIRP_LIST IrpList,
//     PDRIVER_CANCEL CancelRoutine,
//     PIRP_COMPLETION_ROUTINE  IrpCompletionRoutine
//     );
//
#define IrpList_Init(i, c, r) IrpList_InitEx(i, &(i)->LockedList.SpinLock, c, r)

void
IrpList_InitEx(
    PIRP_LIST IrpList,
    PKSPIN_LOCK ListLock,
    PDRIVER_CANCEL CancelRoutine,
    PIRP_COMPLETION_ROUTINE  IrpCompletionRoutine
    );

//
// Return values:
// STATUS_PENDING:  Irp has been enqueued (not the current irp) and cannot be
//                  touched
//
// !NT_SUCCESS(status):  (includes STATUS_CANCELLED) Remove lock could not be
//                       acquired or the Irp was cancelled, complete the IRP
//
NTSTATUS
IrpList_EnqueueEx(
    PIRP_LIST IrpList,
    PIRP Irp,
    BOOLEAN StoreListInIrp
    );

//
// NTSTATUS
// IrpList_Enqueue(
//     PIRP_LIST IrpList,
//     PIRP Irp
//     );
//
#define IrpList_Enqueue(list, irp) \
        IrpList_EnqueueEx(list, irp, TRUE)

//
// IrpList_IsEmptyLocked(PIRP_LIST list)
//
// Returns TRUE or FALSE
//
#define IrpList_IsEmptyLocked(list) \
    ((list)->LockedList.ListHead.Flink == (&(list)->LockedList.ListHead))

//
// Enqueue an irp while the IRP_LIST's spin lock is being held.  This function
// will not use the remove lock to acquire or release the irp.  Same return
// values as IrpList_EnqueueEx.
//
NTSTATUS
IrpList_EnqueueLocked(
    PIRP_LIST IrpList,
    PIRP Irp,
    BOOLEAN StoreListInIrp,
    BOOLEAN InsertTail
    );

PIRP
IrpList_Dequeue(
    PIRP_LIST IrpList
    );

PIRP
IrpList_DequeueLocked(
    PIRP_LIST IrpList
    );

BOOLEAN
IrpList_DequeueIrpLocked(
    PIRP_LIST IrpList,
    PIRP Irp
    );

BOOLEAN
IrpList_DequeueIrp(
    PIRP_LIST IrpList,
    PIRP Irp
    );

typedef
BOOLEAN
(*PFNPROCESSIRP)(
    PVOID Context,
    PIRP  Irp
 );

ULONG
IrpList_ProcessAndDrainLocked(
    PIRP_LIST       IrpList,
    PFNPROCESSIRP   FnProcessIrp,
    PVOID           Context,
    PLIST_ENTRY     DrainHead
    );

ULONG
IrpList_ProcessAndDrain(
    PIRP_LIST       IrpList,
    PFNPROCESSIRP   FnProcessIrp,
    PVOID           Context,
    PLIST_ENTRY     DrainHead
    );

ULONG
IrpList_ProcessAndDrainLocked(
    PIRP_LIST       IrpList,
    PFNPROCESSIRP   FnProcessIrp,
    PVOID           Context,
    PLIST_ENTRY     DrainHead
    );


ULONG
IrpList_Drain(
    PIRP_LIST IrpList,
    PLIST_ENTRY DrainHead
    );

ULONG
IrpList_DrainLocked(
    PIRP_LIST IrpList,
    PLIST_ENTRY DrainHead
    );

ULONG
IrpList_DrainLockedByFileObject(
    PIRP_LIST IrpList,
    PLIST_ENTRY DrainHead,
    PFILE_OBJECT FileObject
    );

void
IrpList_HandleCancel(
    PIRP_LIST IrpList,
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

void
IrpList_CancelRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scutil\pch.h ===
/***************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:

        PCH.H

Abstract:

        Precompiled header files
        
Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        01/08/2001 : created

Authors:

        Tom Green


****************************************************************************/

#ifndef __PCH_H__
#define __PCH_H__

             
#include <wdm.h>
#include <ntdef.h>
#include <smclib.h>
#include "irplist.h"
#include "scutil.h"
#include "scpriv.h"
#include "power.h"
#include "pnp.h"

#endif // __PCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scutil\pnp.h ===
/***************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:

        pnp.h

Abstract:

        PnP Routines for Smartcard Driver Utility Library

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        05/14/2002 : created

Authors:

        Randy Aull


****************************************************************************/

#ifndef __PNP_H__
#define __PNP_H__

NTSTATUS
ScUtilStartDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
ScUtilStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
ScUtilQueryRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
ScUtilCancelRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
ScUtilRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
ScUtilSurpriseRemoval(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
ScUtilQueryStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
ScUtilCancelStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

PNPSTATE
SetPnPState(
    PSCUTIL_EXTENSION pExt,
    PNPSTATE State
    );








      
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scutil\locklist.c ===
/***************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:

        locklist.H

Abstract:

        Private interface for Smartcard Driver Utility Library

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        05/14/2002 : created

Authors:

        Randy Aull


****************************************************************************/

#include "pch.h"
#include "irplist.h"

void
LockedList_Init(
    PLOCKED_LIST LockedList,
    PKSPIN_LOCK ListLock
    )
/*++

Routine Description:
    
    Initializes a LOCKED_LIST structure

Arguments:

    LockedList - Pointer to a LOCKED_LIST structure

    ListLock -  Pointer to a SPIN_LOCK for the locked list

Return Value:

    VOID

--*/
{
    InitializeListHead(&LockedList->ListHead);
    KeInitializeSpinLock(&LockedList->SpinLock);
    LockedList->ListLock = ListLock;
    LockedList->Count = 0;
}

void
LockedList_EnqueueHead(
    PLOCKED_LIST LockedList, 
    PLIST_ENTRY ListEntry
    )
/*++

Routine Description:
    
    Enqueue a List entry at the head of the locked list.

Arguments:

    LockedList - Pointer to a LOCKED_LIST structure

    ListEntry - Pointer to a LIST_ENTRY structure

Return Value:

    VOID

--*/
{
    KIRQL irql;

    LL_LOCK(LockedList, &irql);
    InsertHeadList(&LockedList->ListHead, ListEntry);
    LockedList->Count++;
    LL_UNLOCK(LockedList, irql) ;
}

void
LockedList_EnqueueTail(
    PLOCKED_LIST LockedList, 
    PLIST_ENTRY ListEntry
    )
/*++

Routine Description:
    
    Enqueue a List entry at the tail of the locked list.

Arguments:

    LockedList - Pointer to a LOCKED_LIST structure

    ListEntry - Pointer to a LIST_ENTRY structure

Return Value:

    VOID

--*/
{
    KIRQL irql;

    LL_LOCK(LockedList, &irql);

    InsertTailList(&LockedList->ListHead, ListEntry);
    LockedList->Count++;
    LL_UNLOCK(LockedList, irql) ;
}

void
LockedList_EnqueueAfter(
    PLOCKED_LIST LockedList, 
    PLIST_ENTRY Entry,
    PLIST_ENTRY Location
    )
/*++

Routine Description:
    
    Enqueue a List entry at a specific point in the LockedList.

Arguments:

    LockedList - Pointer to a LOCKED_LIST structure

    Entry - Pointer to a LIST_ENTRY structure
    
    Location - Pointer to a LIST_ENTRY already contained in the LockedList

Return Value:

    VOID
    
Notes:

    It the Location is NULL, the entry is added to the tail of the list

--*/
{
    if (Location == NULL) {
        LL_ADD_TAIL(LockedList, Entry);
    }
    else {
        Entry->Flink = Location->Flink;
        Location->Flink->Blink = Entry;

        Location->Flink = Entry;
        Entry->Blink = Location; 

        LockedList->Count++;
    }
}

PLIST_ENTRY
LockedList_RemoveHead(
    PLOCKED_LIST LockedList
    )
/*++

Routine Description:
    
    Remove the head LIST_ENTRY from a LockedList.

Arguments:

    LockedList - Pointer to a LOCKED_LIST structure

Return Value:

    PLIST_ENTRY - Pointer to the head list of the Locked List
    
    NULL - if the Locked List is empty
    
--*/
{
    PLIST_ENTRY ple;
    KIRQL irql;

    ple = NULL;

    LL_LOCK(LockedList, &irql);

    if (!IsListEmpty(&LockedList->ListHead)) {
        ple = RemoveHeadList(&LockedList->ListHead);
        LockedList->Count--;
    }

    LL_UNLOCK(LockedList, irql);

    return ple;
}

PLIST_ENTRY
LockedList_RemoveEntryLocked(
    PLOCKED_LIST    LockedList,
    PLIST_ENTRY     Entry)
/*++

Routine Description:
    
    Remove a specific entry from the LockedList. Assumes that the caller has 
    acquired the spinlock

Arguments:

    LockedList - Pointer to a LOCKED_LIST structure
    
    Entry - Pointer to a LIST_ENTRY structure


Return Value:

    PLIST_ENTRY - Pointer to the Entry.
        
--*/
{

    ASSERT(!IsListEmpty(&LockedList->ListHead));
    ASSERT(LockedList->Count > 0);

    RemoveEntryList(Entry);
    LockedList->Count--;

    return Entry;    
}

PLIST_ENTRY
LockedList_RemoveEntry(
    PLOCKED_LIST LockedList,
    PLIST_ENTRY Entry
    )
/*++

Routine Description:
    
    Remove a specific entry from the LockedList
    
Arguments:

    LockedList - Pointer to a LOCKED_LIST structure
    
    Entry - Pointer to a LIST_ENTRY structure


Return Value:

    PLIST_ENTRY - Pointer to the Entry.
        
--*/
{
    PLIST_ENTRY ple;
    KIRQL irql;
        
    LL_LOCK(LockedList, &irql);
    ple = LockedList_RemoveEntryLocked(LockedList, Entry);
    LL_UNLOCK(LockedList, irql);

    return ple;
}

LONG
LockedList_GetCount(
    PLOCKED_LIST LockedList
    )
/*++

Routine Description:
    
    Obtains the number of Entries in the LockedList
    
Arguments:

    LockedList - Pointer to a LOCKED_LIST structure
    

Return Value:

    LONG - Number of elements in the LockedList
        
--*/
{
    LONG count;
    KIRQL irql;

    LL_LOCK(LockedList, &irql);
    count = LockedList->Count;
    LL_UNLOCK(LockedList, irql) ;

    return count;
}

LONG
LockedList_Drain(
    PLOCKED_LIST LockedList,
    PLIST_ENTRY DrainListHead
    )
/*++

Routine Description:
    
    Drains the elements from the LockedList into the DrainListHead and
    returns the number of elements
    
Arguments:

    LockedList - Pointer to a LOCKED_LIST structure
    
    DrainListHead - Pointer to a LIST_ENTRY
    

Return Value:

    LONG - Number of elements drained from LockedList into the DrainListHead
        
--*/
{
    PLIST_ENTRY ple;
    LONG count;
    KIRQL irql;

    count = 0;

    InitializeListHead(DrainListHead);

    LL_LOCK(LockedList, &irql);

    while (!IsListEmpty(&LockedList->ListHead)) {
        ple = RemoveHeadList(&LockedList->ListHead);
        LockedList->Count--;

        InsertTailList(DrainListHead, ple);
        count++;
    }

    ASSERT(LockedList->Count == 0);
    ASSERT(IsListEmpty(&LockedList->ListHead));

    LL_UNLOCK(LockedList, irql) ;

    return count;
}

BOOLEAN 
List_Process(
    PLIST_ENTRY ListHead,
    PFNLOCKED_LIST_PROCESS Process,
    PVOID ProcessContext
    )
/*++

Routine Description:

    Iterate over the list, call the process function for each element.
    
Arguments:

    ListHead - Pointer to a LIST_ENTRY
    
    Process - Callback function for each element in the list. If the callback
    returns FALSE we break out of the iteration.
    
    ProcessContext - Context for the callback, supplied by the caller
    

Return Value:

    TRUE - Walked over the entire list
    FALSE - Process function returned FALSE and stopped iteration
        
--*/
{
    PLIST_ENTRY ple;
    BOOLEAN result;

    //
    // We return if we iterated over the entire list.
    //
    result = TRUE;

    for (ple = ListHead->Flink; ple != ListHead; ple = ple->Flink) {
        //
        // If the Process callback wants to stop iterating over the list, then
        // it will return FALSE.
        //
        result = Process(ProcessContext, ple);
        if (result == FALSE) {
            break;
        }
    }

    return result;
}

BOOLEAN
LockedList_ProcessLocked(
    PLOCKED_LIST LockedList,
    PFNLOCKED_LIST_PROCESS Process,
    PVOID ProcessContext
    )
/*++

Routine Description:

    Iterate over the list, call the process function for each element. Assumes 
    the LockedList spinlock is acquired by the caller
    
Arguments:

    LockedList - Pointer to the LOCKED_LIST
    
    Process - Callback function for each element in the list. If the callback
    returns FALSE we break out of the iteration.
    
    ProcessContext - Context for the callback, supplied by the caller
    

Return Value:

    TRUE - Walked over the entire list
    FALSE - Process function returned FALSE and stopped iteration
        
--*/
{
    return List_Process(&LockedList->ListHead, Process, ProcessContext);
}

BOOLEAN
LockedList_Process(
    PLOCKED_LIST LockedList,
    BOOLEAN LockAtPassive,
    PFNLOCKED_LIST_PROCESS Process,
    PVOID ProcessContext
    )
/*++

Routine Description:

    Iterate over the list, call the process function for each element. 
        
Arguments:

    LockedList - Pointer to the LOCKED_LIST

    LockAtPassive - If 
        
    Process - Callback function for each element in the list. If the callback
    returns FALSE we break out of the iteration.
    
    ProcessContext - Context for the callback, supplied by the caller
    

Return Value:

    TRUE - Walked over the entire list
    FALSE - Process function returned FALSE and stopped iteration
        
--*/
{
    KIRQL irql;
    BOOLEAN result;

    if (LockAtPassive) {
        LL_LOCK(LockedList, &irql);
    }
    else {
        LL_LOCK_AT_DPC(LockedList);
    }

    result = List_Process(&LockedList->ListHead, Process, ProcessContext);

    if (LockAtPassive) {
        LL_UNLOCK(LockedList, irql);
    }
    else {
        LL_UNLOCK_FROM_DPC(LockedList);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scutil\power.h ===
/***************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:

        power.h
        
Abstract:

        Power Routines for Smartcard Driver Utility Library

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        05/14/2002 : created

Authors:

        Randy Aull


****************************************************************************/

#ifndef __POWER_H__
#define __POWER_H__

            
NTSTATUS
ScUtilDevicePower(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
ScUtilSystemPower(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
ScUtilSystemPowerCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    );

VOID
ScUtilDeviceRequestCompletion(
    PDEVICE_OBJECT  DeviceObject,
    UCHAR           MinorFunction,
    POWER_STATE     PowerState,
    PVOID           Context,
    PIO_STATUS_BLOCK    IoStatus
    );

NTSTATUS
ScUtilDevicePowerUpCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scutil\scpriv.h ===
/***************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:

        SCPRIV.H

Abstract:

        Private interface for Smartcard Driver Utility Library

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        05/14/2002 : created

Authors:

        Randy Aull


****************************************************************************/

#ifndef __SCPRIV_H__
#define __SCPRIV_H__


typedef ULONG QUEUE_STATE; 

#define PASS_IOCTLS 1
#define QUEUE_IOCTLS 2
#define FAIL_IOCTLS 3
#define INVALID_STATE 0xff

#define SMARTCARD_POOL_TAG 'TUCS'


typedef enum _PNPSTATE {
                    DEVICE_STATE_INITIALIZED = 1,
                    DEVICE_STATE_STARTING,
                    DEVICE_STATE_START_SUCCESS,
                    DEVICE_STATE_START_FAILURE,
                    DEVICE_STATE_STOPPING,
                    DEVICE_STATE_STOPPED,
                    DEVICE_STATE_SUPRISE_REMOVING,
                    DEVICE_STATE_REMOVING,
                    DEVICE_STATE_REMOVED
} PNPSTATE;


typedef struct _SCUTIL_EXTENSION {

    PDEVICE_OBJECT          LowerDeviceObject;
    PDEVICE_OBJECT          PhysicalDeviceObject;
    
    PSMARTCARD_EXTENSION    SmartcardExtension;

    ULONG                   ReaderOpen;
    
    IRP_LIST                PendingIrpQueue;
    QUEUE_STATE             IoctlQueueState;
    ULONG                   IoCount;
    
    PIO_REMOVE_LOCK         RemoveLock;
    
    DEVICE_CAPABILITIES     DeviceCapabilities;
    UNICODE_STRING          DeviceName;

    PNP_CALLBACK            StartDevice;
    PNP_CALLBACK            StopDevice;
    PNP_CALLBACK            RemoveDevice;
    PNP_CALLBACK            FreeResources;
    POWER_CALLBACK          SetPowerState;

    KEVENT                  OkToStop;
    ULONG                   RestartIoctls;
    PNPSTATE                PnPState;
    PNPSTATE                PrevState;
    DEVICE_POWER_STATE      PowerState;

} SCUTIL_EXTENSION, *PSCUTIL_EXTENSION;


VOID
StartIoctls(
    PSCUTIL_EXTENSION pExt
    );

VOID
StopIoctls(
    PSCUTIL_EXTENSION pExt
    );

VOID
FailIoctls(
    PSCUTIL_EXTENSION pExt
    );


QUEUE_STATE 
GetIoctlQueueState(
    PSCUTIL_EXTENSION pExt
    );

VOID
IncIoCount(
    PSCUTIL_EXTENSION pExt
    );

VOID
DecIoCount(
    PSCUTIL_EXTENSION pExt
    );



#endif // __SCPRIV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scutil\scutil.c ===
/***************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:

        SCUTIL.C

Abstract:

        Routines for Smartcard Driver Utility Library

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        05/14/2002 : created

Authors:

        Randy Aull


****************************************************************************/

#include "pch.h"

VOID
IncIoCount(
    PSCUTIL_EXTENSION pExt
    )
{
    ULONG count;
    
    count = InterlockedIncrement(&pExt->IoCount);

    KeClearEvent(&pExt->OkToStop);

}

VOID
DecIoCount(
    PSCUTIL_EXTENSION pExt
    )
{
    ULONG count;

    count = InterlockedDecrement(&pExt->IoCount);

    if (count == 0) {
        KeSetEvent(&pExt->OkToStop,
                   0,
                   FALSE);
    }

}
         
VOID
StartIoctls(
    PSCUTIL_EXTENSION pExt
    )
{

    LIST_ENTRY head;

    InterlockedExchange(&pExt->IoctlQueueState,
                        PASS_IOCTLS);

    pExt->RestartIoctls = TRUE;
    
    // Now drain the queued list
    InitializeListHead(&head);
    IrpList_Drain(&pExt->PendingIrpQueue,
                  &head);
    
    while (!IsListEmpty(&head)) {
        PLIST_ENTRY ple;
        PIRP pIrp;
        
        ple = RemoveHeadList(&head);
        pIrp = CONTAINING_RECORD(ple, IRP, Tail.Overlay.ListEntry);


        IncIoCount(pExt);
        SmartcardDeviceControl(pExt->SmartcardExtension,
                               pIrp);
        DecIoCount(pExt);

        IoReleaseRemoveLock(pExt->RemoveLock,
                            pIrp);
        
    }
                        
}

VOID
StopIoctls(
    PSCUTIL_EXTENSION pExt
    )
{
    InterlockedExchange(&pExt->IoctlQueueState,
                        QUEUE_IOCTLS);

}

VOID
FailIoctls(
    PSCUTIL_EXTENSION pExt
    )
{

    LIST_ENTRY head;

    InterlockedExchange(&pExt->IoctlQueueState,
                        FAIL_IOCTLS);

    InitializeListHead(&head);
    IrpList_Drain(&pExt->PendingIrpQueue,
                  &head);

    while (!IsListEmpty(&head)) {

        PLIST_ENTRY ple;
        PIRP pIrp;

        ple = RemoveHeadList(&head);
        pIrp = CONTAINING_RECORD(ple, IRP, Tail.Overlay.ListEntry);

        IoReleaseRemoveLock(pExt->RemoveLock,
                            pIrp);

        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(pIrp,
                          IO_NO_INCREMENT);
    }




}

QUEUE_STATE 
GetIoctlQueueState(
    PSCUTIL_EXTENSION pExt
    )
{

    return InterlockedCompareExchange(&pExt->IoctlQueueState,
                                      PASS_IOCTLS,
                                      INVALID_STATE);

}

NTSTATUS
ScUtil_SystemControl(
   PDEVICE_OBJECT   DeviceObject,
   PIRP             Irp
   )
/*++

Routine Description:
    forwards IRP_MJ_SYSTEM_CONTROL   

Arguments:

Return Value:

--*/
{
   PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
   NTSTATUS status = STATUS_SUCCESS;

   __try
   {
       SmartcardDebug( DEBUG_TRACE, ("ScUtilSystemControl Enter\n"));

       IoSkipCurrentIrpStackLocation(Irp);
       status = IoCallDriver(pExt->LowerDeviceObject, Irp);


   }

   __finally
   {
       SmartcardDebug( DEBUG_TRACE, ("ScUtilSystemControl Exit : 0x%x\n",status ));

   }

   return status;
   
}

NTSTATUS 
OnRequestComplete(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PKEVENT         Event
    )
/*++

Routine Description:
    Completion routine for UsbScForwardAndWait

Arguments:

Return Value:

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("OnRequestComplete Enter\n"));
        KeSetEvent(Event,
                   0,
                   FALSE);

        status = STATUS_MORE_PROCESSING_REQUIRED;

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("OnRequestComplete Exit : 0x%x\n",status ));

    }

    return status;

}



NTSTATUS
ScUtil_ForwardAndWait(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Sends an irp down the stack and waits for its completion.

Arguments:

Return Value:

--*/
{
    KEVENT  event;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilForwardAndWait Enter\n"));

        KeInitializeEvent(&event, 
                          NotificationEvent, 
                          FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               (PIO_COMPLETION_ROUTINE) OnRequestComplete,
                               (PVOID) &event,
                               TRUE,
                               TRUE,
                               TRUE);
        ASSERT(pExt->LowerDeviceObject);
        IoCallDriver(pExt->LowerDeviceObject,
                     Irp);
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = Irp->IoStatus.Status;


    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilForwardAndWait Exit : 0x%x\n",status));

    }

    return status;

    

}


NTSTATUS
ScUtil_Cancel(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{

    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL irql;

    __try
    {
        SmartcardDebug( DEBUG_TRACE, ("ScUtil_Cancel Enter\n"));

        Irp->IoStatus.Information  = 0;
        Irp->IoStatus.Status    = STATUS_CANCELLED;

        KeAcquireSpinLock(&pExt->SmartcardExtension->OsData->SpinLock,
                          &irql);

        pExt->SmartcardExtension->OsData->NotificationIrp = NULL;

        KeReleaseSpinLock(&pExt->SmartcardExtension->OsData->SpinLock,
                          irql);


        IoReleaseCancelSpinLock(Irp->CancelIrql);

        IoReleaseRemoveLock(pExt->RemoveLock,
                            Irp);

        IoCompleteRequest(
           Irp,
           IO_NO_INCREMENT);

                            
        
    }

    __finally
    {
        SmartcardDebug( DEBUG_TRACE, ("ScUtil_Cancel Exit : 0x%x\n",status ));

    }

    return status;

}


NTSTATUS
ScUtil_CancelTrackingIrp(
    PSCUTIL_EXTENSION pExt
    )
{

    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PSMARTCARD_EXTENSION pSmartcardExtension = pExt->SmartcardExtension;
    PIRP     notificationIrp = NULL;    
    KIRQL    irql;
    KIRQL    cancelIrql;

    __try
    {
        SmartcardDebug(DEBUG_TRACE, 
                       ("Enter: ScUtil_CancelTrackingIrp\n"));


        IoAcquireCancelSpinLock(&cancelIrql);

        // cancel pending notification irps
        KeAcquireSpinLock(&pSmartcardExtension->OsData->SpinLock,
                                  &irql);

        if ( pSmartcardExtension->OsData->NotificationIrp ) {

            // reset the cancel function so that it won't be called anymore
            IoSetCancelRoutine(pSmartcardExtension->OsData->NotificationIrp,
                               NULL);

            pSmartcardExtension->OsData->NotificationIrp->CancelIrql = cancelIrql;

            notificationIrp = pSmartcardExtension->OsData->NotificationIrp;
            pSmartcardExtension->OsData->NotificationIrp = NULL;

        }

        KeReleaseSpinLock(&pSmartcardExtension->OsData->SpinLock,
                          irql);

        if (notificationIrp) {

            IoSetCancelRoutine(notificationIrp,
                               NULL);

        }

        IoReleaseCancelSpinLock(cancelIrql);

        if (notificationIrp) {

            notificationIrp->IoStatus.Information  = 0;
            notificationIrp->IoStatus.Status    = STATUS_CANCELLED;
            
            status = STATUS_CANCELLED;

            IoReleaseRemoveLock(pExt->RemoveLock,
                                notificationIrp);

            IoCompleteRequest(notificationIrp,
                              IO_NO_INCREMENT);

        }

    }

    __finally
    {
        SmartcardDebug(DEBUG_TRACE, 
                       ("Exit:  ScUtil_CancelTrackingIrp (0x%x)\n", status));
    }

    return status;
 
}


NTSTATUS
ScUtil_Initialize(
    SCUTIL_HANDLE           *UtilHandle,
    PDEVICE_OBJECT          PhysicalDeviceObject,
    PDEVICE_OBJECT          LowerDeviceObject,
    PSMARTCARD_EXTENSION    SmartcardExtension,
    PIO_REMOVE_LOCK         RemoveLock,
    PNP_CALLBACK            StartDevice,
    PNP_CALLBACK            StopDevice,
    PNP_CALLBACK            RemoveDevice,
    PNP_CALLBACK            FreeResources,
    POWER_CALLBACK          SetPowerState
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    PSCUTIL_EXTENSION pExt = (PSCUTIL_EXTENSION) ExAllocatePool(NonPagedPool, 
                                                                sizeof(SCUTIL_EXTENSION));

    *UtilHandle = pExt;

    PAGED_CODE();

    __try
    {
        SmartcardDebug(DEBUG_TRACE, 
                       ("Enter: ScUtil_Initialize\n"));

        pExt->LowerDeviceObject = LowerDeviceObject;
        pExt->PhysicalDeviceObject = PhysicalDeviceObject;
        pExt->SmartcardExtension = SmartcardExtension;
        pExt->RemoveLock = RemoveLock;
        pExt->StartDevice = StartDevice;
        pExt->StopDevice = StopDevice;
        pExt->RemoveDevice = RemoveDevice;
        pExt->FreeResources = FreeResources;
        pExt->SetPowerState = SetPowerState;

        IoInitializeRemoveLock(RemoveLock,
                               'LUCS',
                               0,
                               20);

        KeInitializeEvent(&pExt->OkToStop,
                          NotificationEvent,
                          TRUE);

        pExt->IoCount = 0;
        pExt->ReaderOpen = 0;

        pExt->PowerState = PowerDeviceUnspecified;
        
        IrpList_Init(&pExt->PendingIrpQueue,
                     IrpList_CancelRoutine,
                     NULL);

        pExt->RestartIoctls = FALSE;
        
        
        SetPnPState(pExt,
                    DEVICE_STATE_INITIALIZED);
        

        // register our new device
        status = IoRegisterDeviceInterface(PhysicalDeviceObject,
                                           &SmartCardReaderGuid,
                                           NULL,
                                           &pExt->DeviceName);

    }

    __finally
    {
        SmartcardDebug(DEBUG_TRACE, 
                       ("Exit:  ScUtil_Initialize (0x%x)\n", status));
    }

    return status;

}

NTSTATUS
ScUtil_DeviceIOControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
    QUEUE_STATE     state;
    BOOLEAN         complete = FALSE;

    ASSERT(pExt);

    __try
    {
        SmartcardDebug(DEBUG_TRACE, 
                       ("Enter: ScUtil_DeviceIOControl\n"));

        status = IoAcquireRemoveLock(pExt->RemoveLock,
                                     Irp);

        if (!NT_SUCCESS(status)) {

            // the device has been removed. Fail the call
            
            status = STATUS_DEVICE_REMOVED;
            complete = TRUE;
            __leave;

        }
        
        state = GetIoctlQueueState(pExt);
        if ( state == QUEUE_IOCTLS) {
            // 
            // Need to queue Irp
            //
            status = IrpList_EnqueueEx(&pExt->PendingIrpQueue,
                                       Irp,
                                       TRUE);
            if (!NT_SUCCESS(status)) {
                // the irp couldn't be queued.
                IoReleaseRemoveLock(pExt->RemoveLock,
                                    Irp);

                complete = TRUE;
                       
            }

            __leave;

        } else if (state == FAIL_IOCTLS) {

            status = STATUS_DEVICE_REMOVED;
            complete = TRUE;
            __leave;

        }
           
        IncIoCount(pExt);

        status = SmartcardDeviceControl(pExt->SmartcardExtension,
                                        Irp);

        IoReleaseRemoveLock(pExt->RemoveLock, 
                            Irp);

        DecIoCount(pExt);

    }

    __finally
    {
        
        if (complete) {

            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            
        }
        SmartcardDebug(DEBUG_TRACE, 
                       ("Exit:  ScUtil_DeviceIOControl (0x%x)\n", status));
      
    }

    return status;

}


NTSTATUS
ScUtil_Cleanup(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
    PSMARTCARD_EXTENSION pSmartcardExtension = pExt->SmartcardExtension;
    KIRQL cancelIrql;
    
    ASSERT(pExt);
    
    __try
    {
        SmartcardDebug(DEBUG_TRACE, 
                       ("Enter: ScUtil_Cleanup\n"));
    

        ScUtil_CancelTrackingIrp(pExt);


        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_SUCCESS;

        IoCompleteRequest(Irp,
                          IO_NO_INCREMENT);

        status = STATUS_SUCCESS;

    }

    __finally
    {
        SmartcardDebug(DEBUG_TRACE, 
                       ("Exit:  ScUtil_Cleanup (0x%x)\n", status));
    }

    return status;

}


NTSTATUS
ScUtil_UnloadDriver(
    PDRIVER_OBJECT DriverObject
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    
    
    PAGED_CODE();

    __try
    {
        SmartcardDebug(DEBUG_TRACE, 
                       ("Enter: ScUtil_UnloadDriver\n"));
    }

    __finally
    {
        SmartcardDebug(DEBUG_TRACE, 
                       ("Exit:  ScUtil_UnloadDriver (0x%x)\n", status));
    }

    return status;

}


NTSTATUS
ScUtil_CreateClose(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(pExt);

    PAGED_CODE();

    __try
    {
        SmartcardDebug(DEBUG_TRACE, 
                       ("Enter: ScUtil_CreateClose\n"));

        if ( pIrpStack->MajorFunction == IRP_MJ_CREATE ) {

            status = IoAcquireRemoveLock(pExt->RemoveLock,
                                         DeviceObject);

            if (!NT_SUCCESS(status)) {

                status = STATUS_DEVICE_REMOVED;
                __leave;

            }

            // test if the device has been opened already
            if ( InterlockedCompareExchange(&pExt->ReaderOpen,
                                            1,
                                            0) == 0 ) {
                //
                //

            } else {

                // the device is already in use
                status = STATUS_UNSUCCESSFUL;

                // release the lock
                IoReleaseRemoveLock(pExt->RemoveLock,
                                    DeviceObject);

            }

        } else {

            if (InterlockedCompareExchange(&pExt->ReaderOpen,
                                           0,
                                           1) == 1) {
                IoReleaseRemoveLock(pExt->RemoveLock,
                                    DeviceObject);

            }
            
        }

    }

    __finally
    {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        SmartcardDebug(DEBUG_TRACE, 
                       ("Exit:  ScUtil_CreateClose (0x%x)\n", status));
    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scutil\power.c ===
/***************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:

        power.C

Abstract:

        Power Routines for Smartcard Driver Utility Library

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        05/14/2002 : created

Authors:

        Randy Aull


****************************************************************************/

#include "pch.h"

NTSTATUS
ScUtil_Power(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
    PIO_STACK_LOCATION irpStack;

    ASSERT(pExt);

    PAGED_CODE();

    __try
    {
        SmartcardDebug(DEBUG_TRACE, 
                       ("Enter: ScUtil_Power\n"));
            
        irpStack = IoGetCurrentIrpStackLocation(Irp);

        status = IoAcquireRemoveLock(pExt->RemoveLock,
                                     Irp);


        if (!NT_SUCCESS(status)) {

            PoStartNextPowerIrp(Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            __leave;

        }

        if ((irpStack->MinorFunction != IRP_MN_QUERY_POWER)
            && (irpStack->MinorFunction != IRP_MN_SET_POWER) ) {
            // We don't handle these irps
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);

            status = PoCallDriver(pExt->LowerDeviceObject,
                                  Irp);

            IoReleaseRemoveLock(pExt->RemoveLock,
                                Irp);


            __leave;
        }


        switch (irpStack->Parameters.Power.Type) {
        case DevicePowerState:
            status = ScUtilDevicePower(DeviceObject,
                                      Irp);
            break;
        case SystemPowerState:

            status = ScUtilSystemPower(DeviceObject,
                                      Irp);
            break;
        default:
            break;
        

        }

    }

    __finally
    {
        SmartcardDebug(DEBUG_TRACE, 
                       ("Exit:  ScUtil_Power (0x%x)\n", status));
    }

    return status;

}
                      

NTSTATUS
ScUtilDevicePower(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Handles Device Power Irps

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
    PIO_STACK_LOCATION  stack;
    BOOLEAN             postWaitWake;
    POWER_STATE  state;



    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilDevicePower Enter\n"));

        stack = IoGetCurrentIrpStackLocation(Irp);
        state.DeviceState = stack->Parameters.Power.State.DeviceState;

        switch (stack->MinorFunction) {
        case IRP_MN_QUERY_POWER:

            // 
            // Since we can always wait for our irps to complete, so we just always succeed
            //

            StopIoctls(pExt);
            IoReleaseRemoveLock(pExt->RemoveLock,
                                Irp);

            PoStartNextPowerIrp(Irp);


            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(pExt->LowerDeviceObject,
                                  Irp);



            
            break;

        case IRP_MN_SET_POWER:

            if (state.DeviceState < pExt->PowerState) {

                //
                // We are coming up!!  We must let lower drivers power up before we do
                //

                SmartcardDebug( DEBUG_TRACE, ("ScUtilDevicePower Coming Up!\n"));
                IoMarkIrpPending(Irp);
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       ScUtilDevicePowerUpCompletion,
                                       pExt,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                status = PoCallDriver(pExt->LowerDeviceObject,
                                      Irp);

                status = STATUS_PENDING;

            } else {

                //
                // We are moving to a lower power state, so we handle it before
                // passing it down
                //

                SmartcardDebug( DEBUG_TRACE, ("ScUtilDevicePower Going Down!\n"));

                StopIoctls(pExt);
                DecIoCount(pExt);

                KeWaitForSingleObject(&pExt->OkToStop,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);

                status = pExt->SetPowerState(DeviceObject,
                                             state.DeviceState,
                                             &postWaitWake);
                
                PoSetPowerState(DeviceObject,
                                DevicePowerState,
                                state);

                pExt->PowerState = state.DeviceState;


                PoStartNextPowerIrp(Irp);
                IoSkipCurrentIrpStackLocation(Irp);

                status = PoCallDriver(pExt->LowerDeviceObject,
                                      Irp);

                IoReleaseRemoveLock(pExt->RemoveLock,
                                    Irp);



            }
            break;
        default:
            // We shouldn't be here
            ASSERT(FALSE);
            break;
        }

        

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilDevicePower Exit : 0x%x\n", status ));

    }

    return status;


}

NTSTATUS
ScUtilSystemPower(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Handles system power irps

Arguments:

Return Value:

--*/
{

    NTSTATUS            status = STATUS_SUCCESS;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilSystemPower Enter\n" ));

        IoMarkIrpPending(Irp);
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               ScUtilSystemPowerCompletion,
                               pExt,
                               TRUE,
                               TRUE,
                               TRUE);

        status = PoCallDriver(pExt->LowerDeviceObject,
                              Irp);

        status = STATUS_PENDING;



    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilSystemPower Exit : 0x%x\n", status ));

    }

    return status;


}

NTSTATUS
ScUtilSystemPowerCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    )
/*++

Routine Description:
    Completion routine called after system power irp has been passed down the stack.
    handles mapping system state to device state and requests the device power irp.

Arguments:

Return Value:

--*/
{

    NTSTATUS            status = STATUS_SUCCESS;
    PSCUTIL_EXTENSION   pExt = (PSCUTIL_EXTENSION) Context;
    PIO_STACK_LOCATION  irpStack;
    POWER_STATE         state;
    POWER_STATE         systemState;


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilSystemPowerCompletion Enter\n" ));
        
        if (!NT_SUCCESS(Irp->IoStatus.Status)) {
            SmartcardDebug( DEBUG_TRACE, ("ScUtilSystemPowerCompletion SIRP failed by lower driver\n" ));

            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp,
                              IO_NO_INCREMENT);
            status = Irp->IoStatus.Status;
            IoReleaseRemoveLock(pExt->RemoveLock,
                                Irp);

            __leave;
        }

        irpStack = IoGetCurrentIrpStackLocation(Irp);

        systemState = irpStack->Parameters.Power.State;
        state.DeviceState = pExt->DeviceCapabilities.DeviceState[systemState.SystemState];

        if (systemState.DeviceState != PowerSystemWorking) {
           
            // Wait for D IRP completion
            status = PoRequestPowerIrp(DeviceObject,
                                       irpStack->MinorFunction,
                                       state,
                                       ScUtilDeviceRequestCompletion,
                                       (PVOID) Irp,
                                       NULL);

            if (!NT_SUCCESS(status)) {
                PoStartNextPowerIrp(Irp);
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                IoReleaseRemoveLock(pExt->RemoveLock,
                                    Irp);

                status = STATUS_PENDING;
                
                __leave;

            }
            status = STATUS_MORE_PROCESSING_REQUIRED;

        } else {

            // Don't wait for completion of D irp to speed up resume time
            status = PoRequestPowerIrp(DeviceObject,
                                       irpStack->MinorFunction,
                                       state,
                                       NULL,
                                       NULL,
                                       NULL);

            if (!NT_SUCCESS(status)) {

                Irp->IoStatus.Status = status;
                status = STATUS_PENDING;

                PoStartNextPowerIrp(Irp);
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                
            } else {
                
                PoStartNextPowerIrp(Irp);

            }

            
            IoReleaseRemoveLock(pExt->RemoveLock,
                                Irp);

            
        }

        
    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilSystemPowerCompletion Exit : 0x%x\n", status ));


    }

    return status;

}



VOID
ScUtilDeviceRequestCompletion(
    PDEVICE_OBJECT  DeviceObject,
    UCHAR           MinorFunction,
    POWER_STATE     PowerState,
    PVOID           Context,
    PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:
    Completion routine called after device power irp completes.
    Completes the system power irp.

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
    PIRP                irp;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilDeviceRequestCompletion Enter\n" ));

        irp = (PIRP) Context;

        PoStartNextPowerIrp(irp);
        irp->IoStatus.Status = IoStatus->Status;
        IoCompleteRequest(irp,
                          IO_NO_INCREMENT);

        IoReleaseRemoveLock(pExt->RemoveLock,
                            irp);

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilDeviceRequestCompletion Exit : 0x%x\n", status ));

    }

    return;


}


NTSTATUS
ScUtilDevicePowerUpCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    )
/*++

Routine Description:
    Completion routine called after device irp for higher power state has been
    passed down the stack.

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
    PIO_STACK_LOCATION  irpStack;
    BOOLEAN             postWaitWake; // We don't really care about this



    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilDevicePowerUpCompletion Enter\n" ));

        irpStack = IoGetCurrentIrpStackLocation(Irp);
        
        status = pExt->SetPowerState(DeviceObject,
                                     irpStack->Parameters.Power.State.DeviceState,
                                     &postWaitWake);
                                          
        pExt->PowerState = irpStack->Parameters.Power.State.DeviceState;
        IncIoCount(pExt);
        StartIoctls(pExt);

        

        PoSetPowerState(DeviceObject,
                        DevicePowerState,
                        irpStack->Parameters.Power.State);

        PoStartNextPowerIrp(Irp);
 
    }

    __finally
    {

        IoReleaseRemoveLock(pExt->RemoveLock,
                            Irp);

        SmartcardDebug( DEBUG_TRACE, ("ScUtilDevicePowerUpCompletion Exit : 0x%x\n", status ));

    }

    return status;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\scutil\pnp.c ===
/***************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:

        pnp.C

Abstract:

        PnP Routines for Smartcard Driver Utility Library

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        05/14/2002 : created

Authors:

        Randy Aull


****************************************************************************/
#include "pch.h"
#include "pnp.h"
#include "irplist.h"
#include "scutil.h"
#include "scpriv.h"



PNPSTATE
SetPnPState(
    PSCUTIL_EXTENSION pExt,
    PNPSTATE State
    )
{
    PNPSTATE prevState;

    prevState = pExt->PrevState;
    pExt->PrevState = pExt->PnPState;
    pExt->PnPState = State;

    return prevState;
}

NTSTATUS
ScUtilDefaultPnpHandler(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Passes IRP_MJ_PNP to next lower driver

Arguments:

Return Value:

--*/
{

    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
    NTSTATUS status = STATUS_SUCCESS;

    __try
    {
        SmartcardDebug( DEBUG_TRACE, ("ScUtilDefaultPnpHandler Enter\n"));

        IoSkipCurrentIrpStackLocation(Irp);
        ASSERT(pExt->LowerDeviceObject);
        status = IoCallDriver(pExt->LowerDeviceObject, Irp);

    }

    __finally
    {
        SmartcardDebug( DEBUG_TRACE, ("ScUtilDefaultPnpHandler Exit : 0x%x\n",status ));

    }

    return status;


}

             
NTSTATUS
ScUtil_PnP(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
    PIO_STACK_LOCATION      irpStack;
    BOOLEAN                 deviceRemoved = FALSE;


    PSMARTCARD_EXTENSION smartcardExtension = pExt->SmartcardExtension;

    ASSERT(pExt);

    PAGED_CODE();

    __try
    {
        SmartcardDebug(DEBUG_TRACE, 
                       ("Enter: ScUtil_PnP\n"));
                          
        status = IoAcquireRemoveLock(pExt->RemoveLock,
                                     Irp);


        if (!NT_SUCCESS(status)) {

            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            __leave;

        }

        irpStack = IoGetCurrentIrpStackLocation(Irp);

        switch (irpStack->MinorFunction) {
        case IRP_MN_START_DEVICE:
            SmartcardDebug( DEBUG_DRIVER, ("ScUtil_PnP: IRP_MN_START_DEVICE \n"));

            SetPnPState(pExt,
                        DEVICE_STATE_STARTING);

            status = ScUtil_ForwardAndWait(DeviceObject,
                                           Irp);
            if (NT_SUCCESS(status)) {
                
                status = ScUtilStartDevice(DeviceObject,
                                           Irp);
            
            }

            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
            SmartcardDebug( DEBUG_DRIVER, ("ScUtil_PnP: IRP_MN_QUERY_REMOVE_DEVICE\n"));

            status = ScUtilQueryRemoveDevice(DeviceObject,
                                             Irp);

            if (!NT_SUCCESS(status)) {

                break;
                
            }

            Irp->IoStatus.Status = STATUS_SUCCESS;
            status = ScUtilDefaultPnpHandler(DeviceObject,
                                            Irp);
            __leave;
            
        case IRP_MN_REMOVE_DEVICE:
            SmartcardDebug( DEBUG_DRIVER, ("ScUtil_PnP: IRP_MN_REMOVE_DEVICE\n"));

            status = ScUtilRemoveDevice(DeviceObject,
                                        Irp);

            if (NT_SUCCESS(status)) {

                deviceRemoved = TRUE;

                __leave;

            }
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            SmartcardDebug( DEBUG_DRIVER, ("ScUtil_PnP: IRP_MN_SUPRISE_REMOVE\n"));

            status = ScUtilSurpriseRemoval(DeviceObject,
                                           Irp);

            if (!NT_SUCCESS(status)) {

                break;

            }

            Irp->IoStatus.Status = STATUS_SUCCESS;
            status = ScUtilDefaultPnpHandler(DeviceObject,
                                            Irp);
            __leave;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            SmartcardDebug( DEBUG_DRIVER, ("ScUtil_PnP: IRP_MN_CANCEL_REMOVE_DEVICE\n"));

            status = ScUtil_ForwardAndWait(DeviceObject,
                                         Irp);
            if (NT_SUCCESS(status)) {
                
                status = ScUtilCancelRemoveDevice(DeviceObject,
                                                  Irp);

            }
            break;

        case IRP_MN_STOP_DEVICE:
            SmartcardDebug( DEBUG_DRIVER, ("ScUtil_PnP: IRP_MN_STOP_DEVICE\n"));
            status = ScUtilStopDevice(DeviceObject,
                                      Irp);
            
            if (NT_SUCCESS(status)) {

                Irp->IoStatus.Status = STATUS_SUCCESS;
                status = ScUtilDefaultPnpHandler(DeviceObject,
                                                Irp);
                __leave;

            }

            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            SmartcardDebug( DEBUG_DRIVER, ("ScUtil_PnP: IRP_MN_QUERY_STOP_DEVICE\n"));


            status = ScUtilQueryStopDevice(DeviceObject,
                                           Irp);

            if (!NT_SUCCESS(status)) {
                break;
            }
            Irp->IoStatus.Status = STATUS_SUCCESS;
            status = ScUtilDefaultPnpHandler(DeviceObject,
                                             Irp);



            __leave; // We don't need to complete this so just skip it.

        case IRP_MN_CANCEL_STOP_DEVICE:
            SmartcardDebug( DEBUG_DRIVER, ("ScUtil_PnP: IRP_MN_CANCEL_STOP_DEVICE\n"));

            // Lower drivers must handle this irp first
            status = ScUtil_ForwardAndWait(DeviceObject,
                                         Irp);

            if (NT_SUCCESS(status)) {

                status = ScUtilCancelStopDevice(DeviceObject,
                                                Irp);


            }
    
            
            break;

        case IRP_MN_QUERY_CAPABILITIES:
            SmartcardDebug( DEBUG_DRIVER, ("ScUtil_PnP: IRP_MN_QUERY_CAPABILITIES\n"));

            status = ScUtil_ForwardAndWait(DeviceObject,
                                         Irp);
            if (NT_SUCCESS(status)) {

                pExt->DeviceCapabilities = *irpStack->Parameters.DeviceCapabilities.Capabilities;

            }

    

            break;

        default:
            SmartcardDebug( DEBUG_DRIVER, ("ScUtil_PnP: IRP_MN_...%lx\n", irpStack->MinorFunction ));

            status = ScUtilDefaultPnpHandler(DeviceObject,
                                            Irp);
            __leave; // We don't need to complete this so just skip it.
            
        }

        Irp->IoStatus.Status = status;

        IoCompleteRequest(Irp,
                          IO_NO_INCREMENT);

    }

    __finally
    {

        if (deviceRemoved == FALSE) {

             IoReleaseRemoveLock(pExt->RemoveLock,
                                 Irp);
        
        }

        SmartcardDebug(DEBUG_TRACE, 
                       ("Exit:  ScUtil_PnP (0x%x)\n", status));
    }

    return status;

}
                   

NTSTATUS
ScUtilStartDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Handles the IRP_MN_START_DEVICE
    Gets the usb descriptors from the reader and configures it.
    Also starts "polling" the interrupt pipe

Arguments:

Return Value:

--*/
{

    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
    
    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilStartDevice Enter\n" ));

        status = pExt->StartDevice(DeviceObject,
                          Irp);

        if (!NT_SUCCESS(status)) {
            SetPnPState(pExt,
                        DEVICE_STATE_START_FAILURE);
            __leave;
        }
        
        SetPnPState(pExt,
                    DEVICE_STATE_START_SUCCESS);

        StartIoctls(pExt);
        IncIoCount(pExt);

        status = IoSetDeviceInterfaceState(&pExt->DeviceName,
                                           TRUE);

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilStartDevice Exit : 0x%x\n", status ));

    }

    return status;

}

NTSTATUS
ScUtilStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Handles IRP_MN_STOP_DEVICE
    Stops "polling" the interrupt pipe and frees resources allocated in StartDevice

Arguments:

Return Value:

--*/
{

    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilStopDevice Enter\n" ));

        

        if (!DeviceObject) {
            __leave;
        }

        
        pExt->StopDevice(DeviceObject,
                         Irp);

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilStopDevice Exit : 0x%x\n", status ));

    }

    return status;

}


NTSTATUS
ScUtilQueryRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Handles IRP_MN_QUERY_REMOVE
    Disables the reader and prepares it for the IRP_MN_REMOVE

Arguments:

Return Value:

--*/
{

    NTSTATUS                status = STATUS_SUCCESS;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilQueryRemoveDevice Enter\n" ));

        
        // check if the reader has been opened
        if (pExt->ReaderOpen) {
        
            status = STATUS_UNSUCCESSFUL;
            __leave;

        }

        SetPnPState(pExt,
                    DEVICE_STATE_REMOVING);

        StopIoctls(pExt);
            
    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilQueryRemoveDevice Exit : 0x%x\n", status ));

    }

    return status;

}


NTSTATUS
ScUtilCancelRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    handles IRP_MN_CANCEL_REMOVE
    undoes actions in QueryRemove

Arguments:

Return Value:
    STATUS_SUCCESS

--*/
{

    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilCancelRemoveDevice Enter\n" ));


        if (pExt->PnPState != DEVICE_STATE_REMOVING) {
            status = STATUS_SUCCESS;
            __leave;
        }

        if (pExt->PrevState == DEVICE_STATE_START_SUCCESS) {


            StartIoctls(pExt);
            
        }

        SetPnPState(pExt,
                    pExt->PrevState);

        status = STATUS_SUCCESS;

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilCancelRemoveDevice Exit : 0x%x\n", status ));

    }

    return status;

}


NTSTATUS
ScUtilRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    handles IRP_MN_REMOVE_DEVICE
    stops and unloads the device.

Arguments:

Return Value:

--*/
{

    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);
    
    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilRemoveDevice Enter\n" ));

        if (pExt->PnPState != DEVICE_STATE_SUPRISE_REMOVING) {

            FailIoctls(pExt);   

            status = IoSetDeviceInterfaceState(&pExt->DeviceName,
                                               FALSE);

            if (pExt->FreeResources) {
                pExt->FreeResources(DeviceObject,
                                    Irp);
            }
            
        }

        IoReleaseRemoveLockAndWait(pExt->RemoveLock,
                                   Irp);

        SetPnPState(pExt,
                    DEVICE_STATE_REMOVED);


        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (pExt->LowerDeviceObject, Irp);

        pExt->RemoveDevice(DeviceObject,
                           Irp);

        // delete the symbolic link
        if( pExt->DeviceName.Buffer != NULL ) {

           RtlFreeUnicodeString(&pExt->DeviceName);
           pExt->DeviceName.Buffer = NULL;

        }

        if( pExt->SmartcardExtension->OsData != NULL ) {

           SmartcardExit(pExt->SmartcardExtension);

        }

         if (pExt->SmartcardExtension->ReaderExtension != NULL) {

             ExFreePool(pExt->SmartcardExtension->ReaderExtension);
             pExt->SmartcardExtension->ReaderExtension = NULL;

         }

         // Detach from the usb driver
         if (pExt->LowerDeviceObject) {

             IoDetachDevice(pExt->LowerDeviceObject);
             pExt->LowerDeviceObject = NULL;

         }

         ExFreePool(pExt);

        // delete the device object
        IoDeleteDevice(DeviceObject);
    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilRemoveDevice Exit : 0x%x\n", status ));

    }

    return status;

}


NTSTATUS
ScUtilSurpriseRemoval(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    handles IRP_MN_SUPRISE_REMOVE
    Does the same as QueryRemove
    
Arguments:

Return Value:

--*/
{

    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilSurpriseRemoval Enter\n" ));
   
        FailIoctls(pExt);
        SetPnPState(pExt,
                    DEVICE_STATE_REMOVING);
        status = IoSetDeviceInterfaceState(&pExt->DeviceName,
                                           FALSE);

        if (pExt->FreeResources) {
            pExt->FreeResources(DeviceObject,
                                Irp);
        }


        status = STATUS_SUCCESS;

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilSurpriseRemoval Exit : 0x%x\n", status ));

    }

    return status;

}


NTSTATUS
ScUtilQueryStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    handles IRP_MN_QUERY_STOP
    Stops interrupt "polling" and waits for I/O to complete

Arguments:

Return Value:

--*/
{

    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilQueryStopDevice Enter\n"));

        if (!NT_SUCCESS(status)) {

            __leave;

        }

        SetPnPState(pExt,
                    DEVICE_STATE_STOPPING);

        StopIoctls(pExt);
        DecIoCount(pExt);

        // Wait for all IO to complete before stopping
        status = KeWaitForSingleObject(&pExt->OkToStop,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);

        if (!NT_SUCCESS(status)) {

            __leave;

        }
           
    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilQueryStopDevice Exit : 0x%x\n", status ));

    }

    return status;

}


NTSTATUS
ScUtilCancelStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Restarts Interrupt polling

Arguments:

Return Value:

--*/
{

    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    PSCUTIL_EXTENSION pExt = *((PSCUTIL_EXTENSION*) DeviceObject->DeviceExtension);

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilCancelStopDevice Enter\n"));

        SetPnPState(pExt,
                    pExt->PrevState);

        IncIoCount(pExt);

        StartIoctls(pExt);
        
        status = STATUS_SUCCESS;


    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("ScUtilCancelStopDevice Exit : 0x%x\n", status ));

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\smclib\smcprot.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    smcprot.c

Author:

    Klaus U. Schutz 

Environment:

    Kernel mode only.

Revision History:

    - Dec. 96:  Initial version
    - Nov. 97:  Release 1.0
    - Feb. 98:  T=1 uses now the min of IFSC, IFSD for SmartcardT1Request
                T=1 fixed number of bytes to invert for inverse convention cards
                

--*/

#ifdef SMCLIB_VXD

#define try 
#define leave goto __label
#define finally __label:

#else

#ifndef SMCLIB_CE
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <ntddk.h>
#endif // SMCLIB_CE
#endif

#include "smclib.h"
#define SMARTCARD_POOL_TAG 'bLCS'

#ifdef DEBUG_INTERFACE
BOOLEAN
DebugT1Reply(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

void
DebugGetT1Request(
    PSMARTCARD_EXTENSION SmartcardExtension,
    NTSTATUS Status
    );

BOOLEAN
DebugSetT1Request(
    PSMARTCARD_EXTENSION SmartcardExtension
    );
#endif // DEBUG_INTERFACE

void
DumpData(
    const ULONG DebugLevel,
    PUCHAR Data,
    ULONG DataLen
    );

//
// Usually an io-request consists only of the SCARD_IO_REQUEST header
// followed by the data to be transmitted. To allow modification of 
// protocol data, it is possible to pass down the data to be modified.
// These data are ASN1 encoded.
//
typedef struct _IO_HEADER {
    SCARD_IO_REQUEST ScardIoRequest;
    UCHAR Asn1Data[1];      
} IO_HEADER, *PIO_HEADER;

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardRawRequest(
#else
SmartcardRawRequest(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
    
/*++

Routine Description:

Arguments:

Return Value:

   -

--*/
{
    PSMARTCARD_REQUEST smartcardRequest = &(SmartcardExtension->SmartcardRequest);

    if ((smartcardRequest->BufferSize < smartcardRequest->BufferLength) ||
        (smartcardRequest->BufferSize - smartcardRequest->BufferLength 
         <= SmartcardExtension->IoRequest.RequestBufferLength)) {
        
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    //
    // Copy request data to the buffer
    //        
    RtlCopyMemory(
        &smartcardRequest->Buffer[smartcardRequest->BufferLength],
        SmartcardExtension->IoRequest.RequestBuffer,
        SmartcardExtension->IoRequest.RequestBufferLength
        );
        
    //
    // If the card uses invers convention invert the data
    // 
    if (SmartcardExtension->CardCapabilities.InversConvention) {

        SmartcardInvertData(
            &smartcardRequest->Buffer[smartcardRequest->BufferLength],
            SmartcardExtension->IoRequest.RequestBufferLength
            );
    }

    //
    // number of bytes to send to the reader 
    //    
    smartcardRequest->BufferLength += 
        SmartcardExtension->IoRequest.RequestBufferLength;

    return STATUS_SUCCESS;
}    

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardRawReply(
#else
SmartcardRawReply(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
    
/*++

Routine Description:

Arguments:

Return Value:

   -

--*/
{
    if (SmartcardExtension->IoRequest.ReplyBufferLength <
        SmartcardExtension->SmartcardReply.BufferLength) {
        
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    //
    // Copy data to user buffer
    //
    RtlCopyMemory(
        SmartcardExtension->IoRequest.ReplyBuffer,
        SmartcardExtension->SmartcardReply.Buffer,
        SmartcardExtension->SmartcardReply.BufferLength
        );

    // 
    // Length of data to return
    //        
    *SmartcardExtension->IoRequest.Information = 
        SmartcardExtension->SmartcardReply.BufferLength;
              
    return STATUS_SUCCESS;
}   

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardT0Request(
#else
SmartcardT0Request(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
    
/*++

Routine Description:

    Prepares the buffer SmartcardExtension->SmartcardRequest.Buffer 
    to send data to the smart card

Arguments:

    NOTE: On input SmartcardExtension->SmartcardRequest.BufferLenght indicates
          the offset where we should copy the data to. This is usually
          used by readers that needs to have some bytes as header bytes
          to send to the reader before the data bytes for the card

Return Value:

   -

--*/
{
    PSMARTCARD_REQUEST smartcardRequest = &SmartcardExtension->SmartcardRequest;
    PSCARD_IO_REQUEST scardIoRequest;
    PUCHAR ioRequestData;
    ULONG ioRequestDataLength, headerSize;
    
    if ((smartcardRequest->BufferSize < smartcardRequest->BufferLength) ||
        (smartcardRequest->BufferSize - smartcardRequest->BufferLength 
         <= SmartcardExtension->IoRequest.RequestBufferLength)) {

        SmartcardDebug(
            DEBUG_ERROR,
            (TEXT("%s!SmartcardT0Request: IoRequest.RequestBuffer too big\n"),
            DRIVER_NAME)
            );

        return STATUS_BUFFER_OVERFLOW;
    }

    scardIoRequest = (PSCARD_IO_REQUEST) 
        SmartcardExtension->IoRequest.RequestBuffer;

    ioRequestData = 
        SmartcardExtension->IoRequest.RequestBuffer + 
        sizeof(SCARD_IO_REQUEST);

    ioRequestDataLength = 
        SmartcardExtension->IoRequest.RequestBufferLength - 
        sizeof(SCARD_IO_REQUEST);

    //
    // Copy T=0 protocol-info into buffer
    //
    RtlCopyMemory(
        &smartcardRequest->Buffer[smartcardRequest->BufferLength],
        ioRequestData,
        ioRequestDataLength
        );
        
    //
    // Remember number of bytes for the header offset
    //
    headerSize = 
        smartcardRequest->BufferLength;

    //
    // Number of bytes to send to the reader 
    //    
    smartcardRequest->BufferLength += 
        ioRequestDataLength;

    if (ioRequestDataLength < 4) {

        //
        // A T=0 request needs at least 4 bytes
        //
        SmartcardDebug(
            DEBUG_ERROR,
            (TEXT("%s!SmartcardT0Request: TPDU is too short (%d). Must be at least 4 bytes\n"),
            DRIVER_NAME,
            ioRequestDataLength)
            );

        return STATUS_INVALID_PARAMETER;

    } else {

        PUCHAR requestBuffer = SmartcardExtension->SmartcardRequest.Buffer;

        if (ioRequestDataLength <= 5) {

            //
            // We request to read data from the card
            //
            SmartcardExtension->T0.Lc = 0;

            if (ioRequestDataLength == 4) {

                //
                // This is a special case where a 4 byte APDU is mapped to 
                // a 5 byte TPDU (ISO 7816 - Part 4, Annex A, A.1 Case 1)
                // This case requires that we append a 0 to the 
                // APDU to make it a TPDU
                //
                SmartcardExtension->T0.Le = 0;
                smartcardRequest->Buffer[headerSize + 4] = 0;
                smartcardRequest->BufferLength += 1;

            } else {
                
                SmartcardExtension->T0.Le = 
                    (requestBuffer[headerSize + 4] ? requestBuffer[headerSize + 4] : 256);
            }

        } else {
            
            //
            // We want to send data to the card
            //
            SmartcardExtension->T0.Lc = requestBuffer[headerSize + 4];
            SmartcardExtension->T0.Le = 0;

            if (SmartcardExtension->T0.Lc != ioRequestDataLength - 5) {

                SmartcardDebug(
                    DEBUG_ERROR,
                    (TEXT("%s!SmartcardT0Request: Lc(%d) in TPDU doesn't match number of bytes to send(%d).\n"),
                    DRIVER_NAME,
                    SmartcardExtension->T0.Lc,
                    ioRequestDataLength - 5)
                    );

                return STATUS_INVALID_PARAMETER;
            }
        }

#if DEBUG
        {
            PUCHAR T0Data = requestBuffer + headerSize;

            SmartcardDebug(
                DEBUG_PROTOCOL,
                (TEXT(" CLA:  %02X\n INS:  %02X\n P1:   %02X\n P2:   %02X\n Lc:   %02X\n Le:   %02X\n"), 
                T0Data[0], T0Data[1], T0Data[2], T0Data[3],
                SmartcardExtension->T0.Lc,
                SmartcardExtension->T0.Le)
                );

            if (SmartcardExtension->T0.Lc) {

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT(" Data: "))
                    );

                DumpData(
                    DEBUG_PROTOCOL,
                    T0Data + 5, 
                    SmartcardExtension->T0.Lc
                    );
            }
        }
#endif 

        //
        // If the card uses invers convention invert the data
        // 
        if (SmartcardExtension->CardCapabilities.InversConvention) {

            SmartcardInvertData(
                &smartcardRequest->Buffer[headerSize], 
                smartcardRequest->BufferLength - headerSize
                );
        }

        return STATUS_SUCCESS;

#ifdef APDU_SUPPORT
        ULONG requestLength = SmartcardExtension->SmartcardRequest.BufferLength;
        ULONG L;

        //
        // Figure out Lc and Le
        // (See 'Decoding of the command APDUs' in ISO Part 4, 5.3.2)
        // (Variable names used are according to ISO designations)
        //
        L = requestLength - 4;

        if (L > 65536) {

            return STATUS_INVALID_PARAMETER;
        }

        if (L == 0) {

            //
            // Lc = 0, No Data, Le = 0;
            //
            SmartcardExtension->T0.Lc = 0;
            SmartcardExtension->T0.Le = 0;

        } else if (L == 1) {
            
            //
            // Case 2S, Lc = 0, Le = B1
            //
            SmartcardExtension->T0.Lc = 0;
            SmartcardExtension->T0.Le = requestBuffer[4];

        } else {

            UCHAR B1 = requestBuffer[4];

            if (B1 != 0) {

                //
                // Short form
                //
                if (L == (ULONG) (1 + B1)) {

                    //
                    // Case 3S, Lc = B1, Le = 0
                    //
                    SmartcardExtension->T0.Lc = B1;
                    SmartcardExtension->T0.Le = 0;

                } else {
                    
                    //
                    // Case 4S, Lc = B1, Le = BL
                    // 
                    SmartcardExtension->T0.Lc = B1;
                    SmartcardExtension->T0.Le = requestBuffer[L - 1];
                }

            } else {
                
                //
                // Extended form
                //
                if (L == 3) {

                    //
                    // Case 2E, Lc = 0, Le = B(L - 1, L)
                    //
                    LENGTH length;

                    length.l.l0 = 0;
                    length.b.b0 = requestBuffer[L - 1];
                    length.b.b1 = requestBuffer[L - 2];

                    SmartcardExtension->T0.Lc = 0;
                    SmartcardExtension->T0.Le = (length.l.l0 ? length.l.l0 : 65536);

                } else {

                    LENGTH length;
                    
                    length.l.l0 = 0;
                    length.b.b0 = requestBuffer[6];
                    length.b.b1 = requestBuffer[5];

                    SmartcardExtension->T0.Lc = length.l.l0;

                    if (L == 3 + length.l.l0) {

                        //
                        // Case 3E, Lc = B(2,3)
                        //
                        SmartcardExtension->T0.Le = 0;

                    } else {

                        //
                        // Case 4E, Lc = B(2,3), Le = B(L - 1, L)
                        //
                        LENGTH length;
                        
                        length.l.l0 = 0;
                        length.b.b0 = requestBuffer[L - 1];
                        length.b.b1 = requestBuffer[L - 2];

                        SmartcardExtension->T0.Le = (length.l.l0 ? length.l.l0 : 65536);
                    }
                }
            }
        }
#endif
    }

    return STATUS_SUCCESS;
}    

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardT0Reply(
#else
SmartcardT0Reply(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

Arguments:

Return Value:

   -

--*/
{
    PSMARTCARD_REPLY smartcardReply = &SmartcardExtension->SmartcardReply;

    //
    // The reply must be at least to 2 bytes long. These 2 bytes are
    // the return value (StatusWord) from the smart card
    //
    if (smartcardReply->BufferLength < 2) {

        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    
    if (SmartcardExtension->IoRequest.ReplyBufferLength < 
        smartcardReply->BufferLength + sizeof(SCARD_IO_REQUEST)) {
        
        SmartcardDebug(
            DEBUG_ERROR,
            (TEXT("%s!SmartcardT0Request: ReplyBuffer too small\n"),
            DRIVER_NAME)
            );

        return STATUS_BUFFER_TOO_SMALL;
    }

    // Copy protocol header to user buffer
    RtlCopyMemory(
        SmartcardExtension->IoRequest.ReplyBuffer,
        SmartcardExtension->IoRequest.RequestBuffer,
        sizeof(SCARD_IO_REQUEST)
        );
        
    // If the card uses invers convention invert the data
    if (SmartcardExtension->CardCapabilities.InversConvention) {

        SmartcardInvertData(
            smartcardReply->Buffer,
            smartcardReply->BufferLength
            );
    }

    // Copy all data to user buffer
    RtlCopyMemory(
        SmartcardExtension->IoRequest.ReplyBuffer + sizeof(SCARD_IO_REQUEST),
        smartcardReply->Buffer,
        smartcardReply->BufferLength
        );
              
    // Length of answer
    *SmartcardExtension->IoRequest.Information = 
        smartcardReply->BufferLength + 
        sizeof(SCARD_IO_REQUEST);

    return STATUS_SUCCESS;
}    

BOOLEAN
SmartcardT1Chksum(
    PUCHAR Block,
    UCHAR Edc,
    BOOLEAN Verify
    )
/*++

Routine Description:

    This routine calculates the epilogue field for a T1 block. It calculates the LRC
    for all the data in the IBlock.

Arguments:

    Block - T1 Information block, to be sent, or just read, from the card.
    Edc - ErrorDetectionCode as described in ISO 
    Verify - If this is a block that was recieved form the card, TRUE will cause this routine
              to check the epilogue field, included with this buffer, against the calculated one

Return Value:

    TRUE if Verify = TRUE and epilogue fields match or Verify = FALSE
    FALSE if Verify = TRUE and an error was detected (mismatch)


--*/

{
    USHORT i;
    UCHAR lrc;
    USHORT crc = 0;
    USHORT offset = Block[2] + SCARD_T1_PROLOGUE_LENGTH;

    unsigned short crc16a[] = {
        0000000,  0140301,  0140601,  0000500,
        0141401,  0001700,  0001200,  0141101,
        0143001,  0003300,  0003600,  0143501,
        0002400,  0142701,  0142201,  0002100,
    };
    unsigned short crc16b[] = {
        0000000,  0146001,  0154001,  0012000,
        0170001,  0036000,  0024000,  0162001,
        0120001,  0066000,  0074000,  0132001,
        0050000,  0116001,  0104001,  0043000,
    };

    if (Edc & T1_CRC_CHECK) {

        UCHAR tmp;

        // Calculate CRC using tables.
        for ( i = 0; i < offset;  i++) {

             tmp = Block[i] ^ (UCHAR) crc;
             crc = (crc >> 8) ^ crc16a[tmp & 0x0f] ^ crc16b[tmp >> 4];
        }

        if (Verify) {

            if (crc == (Block[offset + 1] | (Block[offset] << 8))) {

                return TRUE;

            } else {

                return FALSE;
            }

        } else {

            Block[offset] = (UCHAR) (crc >> 8 );       //MSB of crc
            Block[offset + 1] = (UCHAR) (crc & 0x00ff);  //LSB of crc
            return TRUE;
        }

    } else {

        // Calculate LRC by X-Oring all the bytes.
        lrc = Block[0];

        for(i = 1; i < offset; i++){

            lrc ^= Block[i];
        }

        if (Verify) {

            return (lrc == Block[offset] ? TRUE : FALSE);

        } else {

            Block[offset] = lrc;
            return TRUE;
        }
    }
    return TRUE;
}

#if (DEBUG)
static 
void
DumpT1Block(
    PUCHAR Buffer,
    UCHAR Edc
    )
{

    SmartcardDebug(
        DEBUG_PROTOCOL,
        (TEXT("   NAD: %02X\n   PCB: %02X\n   LEN: %02X\n   INF: "), 
        Buffer[0], Buffer[1], Buffer[2])
        );

    if (Buffer[2] == 0) {
        
        SmartcardDebug(
            DEBUG_PROTOCOL,
            (TEXT("- "))
            );
    }

    DumpData(
        DEBUG_PROTOCOL,
        Buffer + 3,
        Buffer[2]
        );

    if (Edc & T1_CRC_CHECK) {
        
        SmartcardDebug(
            DEBUG_PROTOCOL,
            (TEXT("\n   CRC: %02X %02X"),
            Buffer[Buffer[2] + 3],
            Buffer[Buffer[2] + 4])
            );

    } else {
        
        SmartcardDebug(
            DEBUG_PROTOCOL,
            (TEXT("\n   LRC: %02X"),
            Buffer[Buffer[2] + 3])
            );
    }

    SmartcardDebug(
        DEBUG_PROTOCOL,
        (TEXT("\n"))
        );
}   
#endif

#if DEBUG
#pragma optimize( "", off )
#endif

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardT1Request(
#else
SmartcardT1Request(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++                     
                         
 Routine Description:
 
 Arguments:
 
    SmartcardExtension - Supplies a pointer to the smart card data
    
 Return Value:
                         
--*/
    
{
    PSMARTCARD_REQUEST smartcardRequest = &(SmartcardExtension->SmartcardRequest);
    PIO_HEADER IoHeader = (PIO_HEADER) SmartcardExtension->IoRequest.RequestBuffer;
    T1_BLOCK_FRAME t1SendFrame;
    NTSTATUS status = STATUS_SUCCESS;

#if (DEBUG)
    ULONG headerSize = smartcardRequest->BufferLength;
#endif

#ifdef DEBUG_INTERFACE
    if (DebugSetT1Request(SmartcardExtension)) {
        
        //
        // the debugger gave us a new packet that we have to 
        // send instead of the original packet which will be sent later
        //
        return STATUS_SUCCESS;
    }
#endif

    if (SmartcardExtension->T1.WaitForReply) {

        // we did not get an answer to our last request
        SmartcardExtension->T1.State = T1_INIT;
    }
    SmartcardExtension->T1.WaitForReply = TRUE;

    __try {
        
        switch (SmartcardExtension->T1.State) {

            case T1_INIT:
                SmartcardExtension->T1.State = T1_IFS_REQUEST;

                // NO break here !!!

            case T1_START:
                //
                // Since this is the very first block in a 
                // transmission we reset the resynch counter
                //
                SmartcardExtension->T1.Resynch = 0;

                //
                // Allocate a buffer that receives the result.
                // This is necessary since we otherwise overwite our
                // request data which we might wish to resend in case
                // of an error
                //
                if (SmartcardExtension->T1.ReplyData != NULL) {

#ifdef SMCLIB_VXD
                    _HeapFree(SmartcardExtension->T1.ReplyData, 0);
#elif defined(SMCLIB_CE)
                    LocalFree(SmartcardExtension->T1.ReplyData);
#else                
                    ExFreePool(SmartcardExtension->T1.ReplyData);
#endif
                    SmartcardExtension->T1.ReplyData = NULL;
                }

                if (SmartcardExtension->IoRequest.ReplyBufferLength <
                    IoHeader->ScardIoRequest.cbPciLength + 2) {

                    //
                    // We should at least be able to store 
                    // the io-header plus SW1 and SW2
                    //
                    status = STATUS_BUFFER_TOO_SMALL;               
                    __leave;
                }
#ifdef SMCLIB_VXD
                SmartcardExtension->T1.ReplyData = (PUCHAR) _HeapAllocate(
                    SmartcardExtension->IoRequest.ReplyBufferLength, 
                    0
                    );
#elif defined(SMCLIB_CE)
                SmartcardExtension->T1.ReplyData = (PUCHAR) LocalAlloc(LPTR,
                    SmartcardExtension->IoRequest.ReplyBufferLength 
                    );

#else
                SmartcardExtension->T1.ReplyData = ExAllocatePool(
                    NonPagedPool,
                    SmartcardExtension->IoRequest.ReplyBufferLength
                    );
#endif
                ASSERT(SmartcardExtension->T1.ReplyData != NULL);

                if (SmartcardExtension->T1.ReplyData == NULL) {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    __leave;
                }

                // No break here !!!

            case T1_RESTART:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: T1_%s\n"),
                    DRIVER_NAME,
                    (SmartcardExtension->T1.State == T1_START ? TEXT("START") : TEXT("RESTART")))
                    );

                // Copy protocol header back to user buffer
                RtlCopyMemory(
                    SmartcardExtension->T1.ReplyData,
                    SmartcardExtension->IoRequest.RequestBuffer,
                    IoHeader->ScardIoRequest.cbPciLength
                    );

                //
                // Check for the special case where the io-header is followed 
                // by asn1 data that contains the NAD value to be used.
                // This was done for VISA, because they need access to the NAD.
                // The NAD is ASN1 encoded as 81h 00h NAD 00h
                //
                if (IoHeader->ScardIoRequest.cbPciLength > sizeof(SCARD_IO_REQUEST) &&
                    IoHeader->Asn1Data[0] == 0x81 &&
                    IoHeader->Asn1Data[1] == 0x01 &&
                    IoHeader->Asn1Data[3] == 0x00) {

                    SmartcardExtension->T1.NAD = IoHeader->Asn1Data[2]; 

                    SmartcardDebug(
                        DEBUG_PROTOCOL,
                        (TEXT("%s!SmartcardT1Request: NAD set to %02xh\n"),
                        DRIVER_NAME,
                        SmartcardExtension->T1.NAD)
                        );
                } 

                // Initialize the T1 protocol data 
                SmartcardExtension->T1.BytesToSend = 
                    SmartcardExtension->IoRequest.RequestBufferLength - 
                    IoHeader->ScardIoRequest.cbPciLength;
                
                SmartcardExtension->T1.BytesSent = 0;
                SmartcardExtension->T1.BytesReceived = 0;
                //
                // This is the maximum number of bytes that the smartcard can
                // accept in a single block. The smartcard can extend this size
                // during the transmission
                //
                SmartcardExtension->T1.IFSC = 
                    SmartcardExtension->CardCapabilities.T1.IFSC;
                
                //
                // Since this is the first block in a transmission we reset 
                // the re-transmission counter. 
                //
                SmartcardExtension->T1.Resend = 0;
                SmartcardExtension->T1.OriginalState = 0;
            
                SmartcardExtension->T1.MoreData = FALSE;
                //
                // NO break here !!!
                //
                // After a card reset we first send an IFS-Request to the card.
                // Otherwise we start with an I-Block
                //

            case T1_IFS_REQUEST:
                if (SmartcardExtension->T1.State == T1_IFS_REQUEST) {
                    
                    SmartcardDebug(
                        DEBUG_PROTOCOL,
                        (TEXT("%s!SmartcardT1Request: T1_IFSD_REQUEST\n"),
                        DRIVER_NAME)
                        );

                    SmartcardExtension->T1.State = 
                        T1_IFS_REQUEST;

                    t1SendFrame.Nad = SmartcardExtension->T1.NAD;
                    //
                    // IFS request.
                    // Send our IFSD size to the card
                    //
                    t1SendFrame.Pcb = 0xC1;
                    t1SendFrame.Len = 1;
                    t1SendFrame.Inf = &SmartcardExtension->T1.IFSD;

                    break;

                } else {
                    
                    SmartcardExtension->T1.State = T1_I_BLOCK;
                }

                // No break here !!
            
            case T1_I_BLOCK:
                SmartcardExtension->T1.State = T1_I_BLOCK;

                //
                // Set the number of bytes we will transmit to the card.
                // This is the lesser of IFSD and IFSC
                //
                SmartcardExtension->T1.InfBytesSent = SmartcardExtension->T1.IFSC;
    
                if (SmartcardExtension->T1.InfBytesSent > SmartcardExtension->T1.IFSD) {

                    SmartcardExtension->T1.InfBytesSent = SmartcardExtension->T1.IFSD;
                }

                // Send either max frame size or remaining bytes
                if (SmartcardExtension->T1.BytesToSend > SmartcardExtension->T1.InfBytesSent) {
                    
                    SmartcardExtension->T1.MoreData = TRUE;
                    t1SendFrame.Len = SmartcardExtension->T1.InfBytesSent;

                } else {

                    SmartcardExtension->T1.MoreData = FALSE;                
                    t1SendFrame.Len = (UCHAR) SmartcardExtension->T1.BytesToSend;
                }
                
                t1SendFrame.Nad = SmartcardExtension->T1.NAD;

                //
                // ProtocolControlByte:
                //      b7 - SendSequenceNumber
                //      b6 - MoreDatatBit
                //
                t1SendFrame.Pcb = 
                    (SmartcardExtension->T1.SSN) << 6 |
                    (SmartcardExtension->T1.MoreData ? T1_MORE_DATA : 0);
            
                t1SendFrame.Inf = 
                    SmartcardExtension->IoRequest.RequestBuffer + 
                    IoHeader->ScardIoRequest.cbPciLength +
                    SmartcardExtension->T1.BytesSent;

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: I(%d.%d) ->\n"),
                    DRIVER_NAME,
                    SmartcardExtension->T1.SSN,
                    (SmartcardExtension->T1.MoreData ? 1 : 0))
                    );
                break; 
            
            case T1_R_BLOCK:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: R(%d) ->\n"),
                    DRIVER_NAME,
                    SmartcardExtension->T1.RSN)
                    );

                t1SendFrame.Nad = SmartcardExtension->T1.NAD;
                //
                // ProtocolControlByte:
                //      b5 -    SequenceNumber
                //      b1-4 -  ErrorCode
                //
                t1SendFrame.Pcb = 
                    0x80 | 
                    (SmartcardExtension->T1.RSN) << 4 |
                    (SmartcardExtension->T1.LastError);
            
                //
                // If this R-Block is a response to an error
                // we have to restore to the original state we had before 
                //
                if (SmartcardExtension->T1.LastError) {

                    SmartcardExtension->T1.LastError = 0;

                    //
                    // We must have a defined original state here
                    //
                    ASSERT(SmartcardExtension->T1.OriginalState != 0);

                    if (SmartcardExtension->T1.OriginalState == 0) {

                        SmartcardExtension->T1.State = T1_START;
                        status = STATUS_INTERNAL_ERROR;                     
                        __leave;
                    }

                    SmartcardExtension->T1.State = 
                        SmartcardExtension->T1.OriginalState;
                }
                
                t1SendFrame.Len = 0;
                t1SendFrame.Inf = NULL;
                break;    

            case T1_IFS_RESPONSE:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: T1_IFSD_RESPONSE\n"),
                    DRIVER_NAME)
                    );
                
                // Restore to the original state we had before
                ASSERT(SmartcardExtension->T1.OriginalState != 0);

                SmartcardExtension->T1.State = 
                    SmartcardExtension->T1.OriginalState;

                t1SendFrame.Nad = SmartcardExtension->T1.NAD;

                // Send IFS response
                t1SendFrame.Pcb = 0xE1;
                t1SendFrame.Len = 1;

                // New length of INF-Field
                t1SendFrame.Inf = &SmartcardExtension->T1.IFSC;
                break;    
            
            case T1_RESYNCH_REQUEST:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: T1_RESYNCH_REQUEST\n"),
                    DRIVER_NAME)
                    );

                t1SendFrame.Nad = SmartcardExtension->T1.NAD;

                // Resynch request
                t1SendFrame.Pcb = 0xC0;
                t1SendFrame.Len = 0;
                t1SendFrame.Inf = NULL;

                // Set the send sequence number to 0
                SmartcardExtension->T1.SSN = 0;    
                break;
            
            case T1_ABORT_REQUEST:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: T1_ABORT_REQUEST\n"),
                    DRIVER_NAME)
                    );
                
                t1SendFrame.Nad = SmartcardExtension->T1.NAD;

                // Send ABORT request
                t1SendFrame.Pcb = 0xC2;
                t1SendFrame.Len = 0;
                t1SendFrame.Inf = NULL;
                break;    
            
            case T1_ABORT_RESPONSE:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: T1_ABORT_RESPONSE\n"),
                    DRIVER_NAME)
                    );
                SmartcardExtension->T1.State = T1_START;
                
                t1SendFrame.Nad = SmartcardExtension->T1.NAD;

                // Send ABORT response
                t1SendFrame.Pcb = 0xE2;
                t1SendFrame.Len = 0;
                t1SendFrame.Inf = NULL;
                break;    
            
            case T1_WTX_RESPONSE:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: T1_WTX_RESPONSE\n"),
                    DRIVER_NAME)
                    );

                // Restore to the original state we had before
                ASSERT(SmartcardExtension->T1.OriginalState != 0);

                SmartcardExtension->T1.State = 
                    SmartcardExtension->T1.OriginalState;

                SmartcardExtension->T1.OriginalState = 0;

                t1SendFrame.Nad = SmartcardExtension->T1.NAD;

                // Send WTX response
                t1SendFrame.Pcb = 0xE3;
                t1SendFrame.Len = 1;
                t1SendFrame.Inf = &SmartcardExtension->T1.Wtx;
                break;    
            
        }

        // Insert Node Address byte
        smartcardRequest->Buffer[smartcardRequest->BufferLength] = 
            t1SendFrame.Nad;
        
        // Insert ProtocolControlByte
        smartcardRequest->Buffer[smartcardRequest->BufferLength + 1] = 
            t1SendFrame.Pcb;
        
        // Length of INF field
        smartcardRequest->Buffer[smartcardRequest->BufferLength + 2] = 
            t1SendFrame.Len;

        // Insert INF field data
        if (t1SendFrame.Len > 0) {
    
            RtlCopyMemory(
                &smartcardRequest->Buffer[smartcardRequest->BufferLength + 3],
                t1SendFrame.Inf,
                t1SendFrame.Len
            );
        }

        // Compute checksum
        SmartcardT1Chksum(
            &smartcardRequest->Buffer[smartcardRequest->BufferLength],
            SmartcardExtension->CardCapabilities.T1.EDC,
            FALSE
            );

#if defined(DEBUG)
#if defined(SMCLIB_NT)
        if (SmartcardGetDebugLevel() & DEBUG_T1_TEST) {
    
            LARGE_INTEGER Ticks;
            UCHAR RandomVal;
            KeQueryTickCount(&Ticks);

            RandomVal = (UCHAR) Ticks.LowPart % 4;

            if (RandomVal == 0) {

                smartcardRequest->Buffer[smartcardRequest->BufferLength - 1] += 1;

                SmartcardDebug(
                    DEBUG_ERROR,
                    (TEXT("%s!SmartcardT1Request: Simulating bad checksum\n"),
                    DRIVER_NAME)
                    );
            }
        }
#endif

        DumpT1Block(
            smartcardRequest->Buffer + headerSize,
            SmartcardExtension->CardCapabilities.T1.EDC
            );
#endif

        //
        // If the card uses invers convention invert the data
        // NOTE: do not invert any header data the reader may use
        //
        if (SmartcardExtension->CardCapabilities.InversConvention) {

            SmartcardInvertData(
                &smartcardRequest->Buffer[smartcardRequest->BufferLength],
                (SmartcardExtension->CardCapabilities.T1.EDC & T1_CRC_CHECK ? 5 : 4) +
                t1SendFrame.Len
                );
        }

        //
        // Update the number of bytes that are in the buffer
        // A T1 block is at least 4 bytes long with LRC check and 5 bytes with CRC check
        //
        smartcardRequest->BufferLength +=
            (SmartcardExtension->CardCapabilities.T1.EDC & T1_CRC_CHECK ? 5 : 4) +
            t1SendFrame.Len;
    }
    __finally {
        
#ifdef DEBUG_INTERFACE
        DebugGetT1Request(SmartcardExtension, status);
#endif
    }

    return status;
}        

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardT1Reply(
#else
SmartcardT1Reply(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++                     
                         
 Routine Description:
 
 Arguments:
 
    DeviceObject - Supplies a pointer to the device object for this request.
    
 Return Value:
                         
--*/
    
{
    T1_BLOCK_FRAME t1RecFrame;
    NTSTATUS status = STATUS_MORE_PROCESSING_REQUIRED;
    PIO_HEADER IoHeader = (PIO_HEADER) SmartcardExtension->T1.ReplyData;
    BOOLEAN packetOk = TRUE, chksumOk = TRUE;

    ASSERT(IoHeader != NULL);

    if (IoHeader == NULL) {

        return STATUS_INTERNAL_ERROR;
    }

#ifdef DEBUG_INTERFACE
    if (DebugT1Reply(SmartcardExtension)) {
        
        // the debugger processed this packet which means
        // that we should not parse it.
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
#endif

    // signal that we received an answer
    SmartcardExtension->T1.WaitForReply = FALSE;

    // Invert the data of an inverse convention card
    if (SmartcardExtension->CardCapabilities.InversConvention) {

        SmartcardInvertData(
            SmartcardExtension->SmartcardReply.Buffer,
            SmartcardExtension->SmartcardReply.BufferLength
            );
    }

    // Clear waiting time extension
    SmartcardExtension->T1.Wtx = 0;

    try {                

        ULONG expectedLength = 
            SCARD_T1_PROLOGUE_LENGTH +
            SmartcardExtension->SmartcardReply.Buffer[2] +
            (SmartcardExtension->CardCapabilities.T1.EDC & T1_CRC_CHECK ? 2 : 1);

        if (SmartcardExtension->SmartcardReply.BufferLength < 4 ||
            SmartcardExtension->SmartcardReply.BufferLength != expectedLength) {

            SmartcardDebug(
                DEBUG_ERROR,
                (TEXT("%s!SmartcardT1Reply: Packet length incorrect\n"),
                DRIVER_NAME)
                );

            packetOk = FALSE;

        } else {
            
            // calculate the checksum
            chksumOk = SmartcardT1Chksum(
                SmartcardExtension->SmartcardReply.Buffer,
                SmartcardExtension->CardCapabilities.T1.EDC,
                TRUE
                );

#if DEBUG
#ifndef SMCLIB_VXD
            if (SmartcardGetDebugLevel() & DEBUG_T1_TEST) {

                // inject some checksum errors

                LARGE_INTEGER Ticks;
                UCHAR RandomVal;
                KeQueryTickCount(&Ticks);

                RandomVal = (UCHAR) Ticks.LowPart % 4;

                if (RandomVal == 0) {

                    chksumOk = FALSE;

                    SmartcardDebug(
                        DEBUG_ERROR,
                        (TEXT("%s!SmartcardT1Reply: Simulating bad checksum\n"),
                        DRIVER_NAME)
                        );
                }
            }
#endif
#endif
        }

        if (chksumOk == FALSE) {

            SmartcardDebug(
                DEBUG_ERROR,
                (TEXT("%s!SmartcardT1Reply: Bad checksum\n"), 
                DRIVER_NAME)
                );
        }

        if (packetOk == FALSE || chksumOk == FALSE) {

            SmartcardExtension->T1.LastError = 
                (chksumOk ? T1_ERROR_OTHER : T1_ERROR_CHKSUM);

            if (SmartcardExtension->T1.OriginalState == 0) {

                SmartcardExtension->T1.OriginalState = 
                    SmartcardExtension->T1.State;
            }
        
            if (SmartcardExtension->T1.Resend++ == T1_MAX_RETRIES) {
        
                SmartcardExtension->T1.Resend = 0;
            
                // Try to resynchronize since the resend requests have failed
                SmartcardExtension->T1.State = T1_RESYNCH_REQUEST;
                __leave;

            } 
            
            // If the last request was a resynch we try again to resynch
            if (SmartcardExtension->T1.State != T1_RESYNCH_REQUEST) {
        
                // Chksum not OK; request resend of last block
                SmartcardExtension->T1.State = T1_R_BLOCK;
            }
            __leave;
        }

        //
        // The checksum of the packet is ok.
        // Now check the rest of the packet
        //

        // Clear the last error
        SmartcardExtension->T1.LastError = 0;

        t1RecFrame.Nad = SmartcardExtension->SmartcardReply.Buffer[0];
        t1RecFrame.Pcb = SmartcardExtension->SmartcardReply.Buffer[1];
        t1RecFrame.Len = SmartcardExtension->SmartcardReply.Buffer[2];
        t1RecFrame.Inf = &SmartcardExtension->SmartcardReply.Buffer[3];

        // 
        // If the last block we sent was a ifs request, 
        // we expect the card to reply with an ifs response.
        //
        if (SmartcardExtension->T1.State == T1_IFS_REQUEST) {

            // Check if the card properly responded to an ifs request
            if (t1RecFrame.Pcb == T1_IFS_RESPONSE) {

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Reply:   T1_IFSC_RESPONSE\n"),
                    DRIVER_NAME)
                    );

                // The smart card acked our ifsd size
                SmartcardExtension->T1.State = T1_I_BLOCK;
                __leave;
            }

            if ((t1RecFrame.Pcb & 0x82) == 0x82) {

                //
                // The card does not support ifs request, so we stop 
                // sending this and continue with a data block
                // (the card is NOT ISO conform)
                //
                SmartcardDebug(
                    DEBUG_ERROR,
                    (TEXT("%s!SmartcardT1Reply:   Card does not support IFS REQUEST\n"),
                    DRIVER_NAME)
                    );

                SmartcardExtension->T1.State = T1_I_BLOCK;
                __leave;
            }

            //
            // The card replied with junk to our ifs request.
            // It doesn't make sense to continue.
            //
            status = STATUS_DEVICE_PROTOCOL_ERROR;
            __leave;
        }
    
        // 
        // If the last block was a resync. request,
        // we expect the card to answer with a resynch response.
        //
        if (SmartcardExtension->T1.State == T1_RESYNCH_REQUEST) {

            // Check if the card properly responded to an resynch request
            if (t1RecFrame.Pcb != T1_RESYNCH_RESPONSE) {
        
                SmartcardDebug(
                    DEBUG_ERROR,
                    (TEXT("%s!SmartcardT1Reply:   Card response is not ISO conform! Aborting...\n"),
                    DRIVER_NAME)
                    );

                status = STATUS_DEVICE_PROTOCOL_ERROR;
                __leave;

            } 
            
            SmartcardDebug(
                DEBUG_PROTOCOL,
                (TEXT("%s!SmartcardT1Reply:   T1_RESYNCH_RESPONSE\n"),
                DRIVER_NAME)
                );

            // Reset error counter
            SmartcardExtension->T1.Resend = 0;

            // The smart card has successfully responded to a resynch request
            SmartcardExtension->T1.RSN = 0;
            SmartcardExtension->T1.SSN = 0;

            //
            // Do a complete restart of the whole transmission
            // but without resetting the resynch counter
            //
            SmartcardExtension->T1.State = T1_RESTART;
            __leave;
        }

        //
        // Now check for other protocol states...
        //
    
        //
        // Copy NAD value back to user buffer if this is an extended io-header
        // containing the nad
        //
        if (IoHeader->ScardIoRequest.cbPciLength > sizeof(SCARD_IO_REQUEST) &&
            IoHeader->Asn1Data[0] == 0x81 &&
            IoHeader->Asn1Data[1] == 0x01 &&
            IoHeader->Asn1Data[3] == 0x00) {

            IoHeader->Asn1Data[2] = t1RecFrame.Nad;             
        }

        if ((t1RecFrame.Pcb & 0x80) == 0) {

            // This is an I-block

            SmartcardDebug(
                DEBUG_PROTOCOL,
                (TEXT("%s!SmartcardT1Reply:   I(%d.%d) <-\n"),
                DRIVER_NAME,
                (t1RecFrame.Pcb & 0x40) >> 6,
                (t1RecFrame.Pcb & 0x20) >> 5)
                );

            if (((t1RecFrame.Pcb & 0x40) >> 6) == SmartcardExtension->T1.RSN) {

                // I-Block with correct sequence number
    
                PUCHAR data;
                ULONG minBufferSize;

                // Reset error counter and error indicator
                SmartcardExtension->T1.Resend = 0;
                SmartcardExtension->T1.OriginalState = 0;

                // We can 'increase' the number of correctly received I-Blocks
                SmartcardExtension->T1.RSN ^= 1;

                if (SmartcardExtension->T1.State == T1_I_BLOCK) {

                    // This I-Block is also an acknowledge for the I-Block we sent 
                    SmartcardExtension->T1.SSN ^= 1;
                }
        
                // Check size of user buffer
                minBufferSize = 
                    IoHeader->ScardIoRequest.cbPciLength +
                    SmartcardExtension->T1.BytesReceived +
                    t1RecFrame.Len;
        
                if (SmartcardExtension->IoRequest.ReplyBufferLength < minBufferSize) {
            
                    status = STATUS_BUFFER_TOO_SMALL;
                    __leave;
                }

                ASSERT(SmartcardExtension->T1.ReplyData);
                //
                // Let data pointer point behind struct.
                // All reply data will be stored there.
                // 
                data = 
                    SmartcardExtension->T1.ReplyData + 
                    IoHeader->ScardIoRequest.cbPciLength +
                    SmartcardExtension->T1.BytesReceived;

                // Copy data to user buffer
                RtlCopyMemory(
                    data,
                    t1RecFrame.Inf,
                    t1RecFrame.Len
                    );
              
                SmartcardExtension->T1.BytesReceived += t1RecFrame.Len;
        
                if (t1RecFrame.Pcb & T1_MORE_DATA) {
    
                    // Ack this block and request the next block
                    SmartcardExtension->T1.State = T1_R_BLOCK;
        
                } else {
        
                    //
                    // This was the last block of the transmission
                    // Set number of bytes returned by this transmission
                    //
                    *SmartcardExtension->IoRequest.Information = 
                        IoHeader->ScardIoRequest.cbPciLength + 
                        SmartcardExtension->T1.BytesReceived;

                    // Copy the result back to the user buffer
                    ASSERT(SmartcardExtension->IoRequest.ReplyBuffer != NULL);

                    RtlCopyMemory(
                        SmartcardExtension->IoRequest.ReplyBuffer,
                        SmartcardExtension->T1.ReplyData,
                        IoHeader->ScardIoRequest.cbPciLength +
                            SmartcardExtension->T1.BytesReceived                        
                        );
        
                    status = STATUS_SUCCESS;
                }
                __leave;
            }

            //
            // I-Block with wrong sequence number
            // We try T1_MAX_RETRIES times to resend the last block.
            // If this is unsuccessfull, we try to resynch.
            // If resynch is unsuccessfull we abort the transmission.
            //
            SmartcardDebug(
                DEBUG_ERROR,
                (TEXT("%s!SmartcardT1Reply: Block number incorrect\n"),
                DRIVER_NAME)
                );

            SmartcardExtension->T1.LastError = T1_ERROR_OTHER;

            if (SmartcardExtension->T1.OriginalState == 0) {
                
                SmartcardExtension->T1.OriginalState = 
                    SmartcardExtension->T1.State;
            }

            if (SmartcardExtension->T1.Resend++ == T1_MAX_RETRIES) {
    
                SmartcardExtension->T1.Resend = 0;
        
                // Try to resynchronize
                SmartcardExtension->T1.State = T1_RESYNCH_REQUEST;
                __leave;
            }

            // request the block again.
            SmartcardExtension->T1.State = T1_R_BLOCK;
            __leave;
        } 
    
        if ((t1RecFrame.Pcb & 0xC0) == 0x80) {

            // This is an R-block

            UCHAR RSN = (t1RecFrame.Pcb & 0x10) >> 4;
    
            SmartcardDebug(
                DEBUG_PROTOCOL,
                (TEXT("%s!SmartcardT1Reply:   R(%d) <-\n"),
                DRIVER_NAME,
                RSN)
                );
    
            if (RSN != SmartcardExtension->T1.SSN &&  
                SmartcardExtension->T1.MoreData) {
    
                // The ICC has acked the last block
                SmartcardExtension->T1.Resend = 0;

                SmartcardExtension->T1.BytesSent += SmartcardExtension->T1.InfBytesSent;
                SmartcardExtension->T1.BytesToSend -= SmartcardExtension->T1.InfBytesSent;
                SmartcardExtension->T1.SSN ^= 1;
                SmartcardExtension->T1.State = T1_I_BLOCK;

                __leave;
            } 

            //
            // We have an error condition...
            //

            ASSERT(t1RecFrame.Pcb & 0x0f);
            
            if ((t1RecFrame.Pcb & 0x02) && 
                SmartcardExtension->T1.State == T1_IFS_REQUEST) {

                //
                // The card does not support ifs request, so 
                // we stop sending this and continue with a data block
                // (the card is NOT ISO conform)
                //
                SmartcardDebug(
                    DEBUG_ERROR,
                    (TEXT("%s!SmartcardT1Reply:   Card does not support IFS REQUEST\n"),
                    DRIVER_NAME)
                    );

                SmartcardExtension->T1.State = T1_I_BLOCK;
                __leave;
            } 

            // We have to resend the last block
            SmartcardDebug(
                DEBUG_ERROR,
                (TEXT("%s!SmartcardT1Reply:   Card reports error\n"),
                DRIVER_NAME)
                );

            if (SmartcardExtension->T1.Resend++ == T1_MAX_RETRIES) {

                SmartcardExtension->T1.Resend = 0;
    
                if (SmartcardExtension->T1.OriginalState == 0) {
                
                    // Save current state
                    SmartcardExtension->T1.OriginalState = 
                        SmartcardExtension->T1.State;
                }

                // Try to resynchronize
                SmartcardExtension->T1.State = T1_RESYNCH_REQUEST;
            } 
            __leave;        
        } 

        //
        // This is an S-block
        // 

        switch (t1RecFrame.Pcb) {

            case T1_IFS_REQUEST:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Reply:   T1_IFSC_REQUEST\n"),
                    DRIVER_NAME)
                    );

                // The smart card wants to exend the IFS - size
                SmartcardExtension->T1.IFSC = 
                    SmartcardExtension->SmartcardReply.Buffer[3];
       
                // Save current state
                ASSERT(SmartcardExtension->T1.OriginalState == 0);

                SmartcardExtension->T1.OriginalState =
                    SmartcardExtension->T1.State;

                SmartcardExtension->T1.State = T1_IFS_RESPONSE;
                break;
        
            case T1_ABORT_REQUEST:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Reply:   T1_ABORT_REQUEST\n"),
                    DRIVER_NAME)
                    );

                SmartcardExtension->T1.State = T1_ABORT_RESPONSE;
                break;
        
            case T1_WTX_REQUEST:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Reply:   T1_WTX_REQUEST\n"),
                    DRIVER_NAME)
                    );
            
                // Smart card needs longer wait time
                SmartcardExtension->T1.Wtx = 
                    SmartcardExtension->SmartcardReply.Buffer[3];

                // Save current state
                ASSERT(SmartcardExtension->T1.OriginalState == 0 ||
                       SmartcardExtension->T1.OriginalState == T1_WTX_RESPONSE);

                SmartcardExtension->T1.OriginalState =
                    SmartcardExtension->T1.State;
            
                SmartcardExtension->T1.State = T1_WTX_RESPONSE;
                break;
        
            case T1_VPP_ERROR:
                SmartcardDebug(
                    DEBUG_ERROR,
                    (TEXT("%s!SmartcardT1Reply:   T1_VPP_ERROR\n"),
                    DRIVER_NAME)
                    );

                status = STATUS_DEVICE_POWER_FAILURE;
                break;

            default:
                ASSERTMSG(
                    TEXT("SmartcardT1Reply: Invalid Pcb "),
                    FALSE
                    );

                status = STATUS_DEVICE_PROTOCOL_ERROR;
                break;
        }
    }
    finally {
        
#if DEBUG
        if (packetOk && chksumOk) {
            
            DumpT1Block(
                SmartcardExtension->SmartcardReply.Buffer,
                SmartcardExtension->CardCapabilities.T1.EDC
                );
        }
#endif

        if (SmartcardExtension->T1.State == T1_RESYNCH_REQUEST && 
            SmartcardExtension->T1.Resynch++ == T1_MAX_RETRIES) {
    
            SmartcardDebug(
                DEBUG_ERROR,
                (TEXT("%s!SmartcardT1Reply: Too many errors! Aborting...\n"),
                DRIVER_NAME)
                );

            status = STATUS_DEVICE_PROTOCOL_ERROR;
        }
            
        if (status != STATUS_MORE_PROCESSING_REQUIRED) {

            if (SmartcardExtension->T1.OriginalState == T1_IFS_REQUEST) {
        
                SmartcardExtension->T1.State = T1_IFS_REQUEST;

            } else {
        
                SmartcardExtension->T1.State = T1_START;
            }

            if (SmartcardExtension->T1.ReplyData) {
                
                // free the reply data buffer
#ifdef SMCLIB_VXD
                _HeapFree(SmartcardExtension->T1.ReplyData, 0);
#elif defined(SMCLIB_CE)
                LocalFree(SmartcardExtension->T1.ReplyData);
#else               
                
                ExFreePool(SmartcardExtension->T1.ReplyData);
#endif
                SmartcardExtension->T1.ReplyData = NULL;                
            }
            SmartcardExtension->T1.OriginalState = 0;
            SmartcardExtension->T1.NAD = 0;
        }

    }
    return status;
}

#if DEBUG
#pragma optimize( "", on )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\smclib\smcioctl.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    smcioctl.c

Abstract:

    This module handles all IOCTL requests to the smart card reader.

Environment:

    Kernel mode only.

Notes:

    This module is shared by Windows NT and Windows 9x

Revision History:

    - Created June 1997 by Klaus Schutz

--*/

#define _ISO_TABLES_

#ifndef SMCLIB_VXD
#ifndef SMCLIB_CE
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <ntddk.h>
#endif
#endif

#include "smclib.h"

#define IOCTL_SMARTCARD_DEBUG        SCARD_CTL_CODE(98) 

#define CheckUserBuffer(_len_) \
    if (SmartcardExtension->IoRequest.ReplyBuffer == NULL || \
        SmartcardExtension->IoRequest.ReplyBufferLength < (_len_)) { \
        status = STATUS_BUFFER_TOO_SMALL; \
        break; \
    }
#define CheckMinCardStatus(_status_) \
    if (SmartcardExtension->ReaderCapabilities.CurrentState < (_status_)) { \
        status = STATUS_INVALID_DEVICE_STATE; \
        break; \
    }
#define ReturnULong(_value_) \
    { \
        CheckUserBuffer(sizeof(ULONG)) \
        *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = (_value_); \
        *SmartcardExtension->IoRequest.Information = sizeof(ULONG); \
    }
#define ReturnUChar(_value_) \
    { \
        CheckUserBuffer(sizeof(UCHAR)) \
        *(PUCHAR) SmartcardExtension->IoRequest.ReplyBuffer = (_value_); \
        *SmartcardExtension->IoRequest.Information = sizeof(UCHAR); \
    }

#define DIM(_array_) (sizeof(_array_) / sizeof(_array_[0]))

PTCHAR 
MapIoControlCodeToString(
    ULONG IoControlCode
    )
{
    ULONG i;

    static struct {

        ULONG   IoControlCode;
        PTCHAR  String;

    } IoControlList[] = {
        
        IOCTL_SMARTCARD_POWER,          TEXT("POWER"),
        IOCTL_SMARTCARD_GET_ATTRIBUTE,  TEXT("GET_ATTRIBUTE"),
        IOCTL_SMARTCARD_SET_ATTRIBUTE,  TEXT("SET_ATTRIBUTE"),
        IOCTL_SMARTCARD_CONFISCATE,     TEXT("CONFISCATE"),
        IOCTL_SMARTCARD_TRANSMIT,       TEXT("TRANSMIT"),
        IOCTL_SMARTCARD_EJECT,          TEXT("EJECT"),
        IOCTL_SMARTCARD_SWALLOW,        TEXT("SWALLOW"),       
        IOCTL_SMARTCARD_IS_PRESENT,     TEXT("IS_PRESENT"),
        IOCTL_SMARTCARD_IS_ABSENT,      TEXT("IS_ABSENT"),
        IOCTL_SMARTCARD_SET_PROTOCOL,   TEXT("SET_PROTOCOL"),
        IOCTL_SMARTCARD_GET_STATE,      TEXT("GET_STATE"),
        IOCTL_SMARTCARD_GET_LAST_ERROR, TEXT("GET_LAST_ERROR")
    };

    for (i = 0; i < DIM(IoControlList); i++) {

        if (IoControlCode == IoControlList[i].IoControlCode) {

            return IoControlList[i].String;
        }
    }

    return TEXT("*** UNKNOWN ***");
}

NTSTATUS
SmartcardDeviceIoControl(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:
    
    This routine handles the smart card lib specific io control requests.
    The driver has to call the function from the driver's io control request.
    It checks the parameters of the call and depending on the type of 
    the call returns the requested value or calls the driver in order
    to perform an operation like POWER or TRANSMIT.

    NOTE: This function is used by Windows NT and VxD driver

Arguments:

    SmartcardExtension - The pointer to the smart card data struct

Return Value:

    NTSTATUS value 

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
#ifdef SMCLIB_NT
    KIRQL Irql;
#endif

    switch (SmartcardExtension->MajorIoControlCode) {

#if DEBUG
        ULONG CurrentDebugLevel, bytesTransferred;
#endif
        PSCARD_IO_REQUEST scardIoRequest;

        case IOCTL_SMARTCARD_GET_ATTRIBUTE:
            //
            // Please refer to the Interoperrability standard for ICC
            //
            switch (SmartcardExtension->MinorIoControlCode) {

                case SCARD_ATTR_VENDOR_NAME:
                    CheckUserBuffer(SmartcardExtension->VendorAttr.VendorName.Length);

                    RtlCopyMemory(
                        SmartcardExtension->IoRequest.ReplyBuffer,
                        SmartcardExtension->VendorAttr.VendorName.Buffer,
                        SmartcardExtension->VendorAttr.VendorName.Length
                        );
                    *SmartcardExtension->IoRequest.Information = 
                        SmartcardExtension->VendorAttr.VendorName.Length;
                    break;

                case SCARD_ATTR_VENDOR_IFD_TYPE:
                    CheckUserBuffer(SmartcardExtension->VendorAttr.IfdType.Length);

                    RtlCopyMemory(
                        SmartcardExtension->IoRequest.ReplyBuffer,
                        SmartcardExtension->VendorAttr.IfdType.Buffer,
                        SmartcardExtension->VendorAttr.IfdType.Length
                        );
                    *SmartcardExtension->IoRequest.Information = 
                        SmartcardExtension->VendorAttr.IfdType.Length;
                    break;

                case SCARD_ATTR_VENDOR_IFD_VERSION:
                    ReturnULong(
                        SmartcardExtension->VendorAttr.IfdVersion.BuildNumber | 
                        SmartcardExtension->VendorAttr.IfdVersion.VersionMinor << 16 | 
                        SmartcardExtension->VendorAttr.IfdVersion.VersionMajor << 24 
                        );
                    break;

                case SCARD_ATTR_VENDOR_IFD_SERIAL_NO:
                    if (SmartcardExtension->VendorAttr.IfdSerialNo.Length == 0) {

                        status = STATUS_NOT_SUPPORTED;
                        
                    } else {
                        
                        CheckUserBuffer(SmartcardExtension->VendorAttr.IfdSerialNo.Length);

                        RtlCopyMemory(
                            SmartcardExtension->IoRequest.ReplyBuffer,
                            SmartcardExtension->VendorAttr.IfdSerialNo.Buffer,
                            SmartcardExtension->VendorAttr.IfdSerialNo.Length
                            );
                        *SmartcardExtension->IoRequest.Information = 
                            SmartcardExtension->VendorAttr.IfdSerialNo.Length;
                    }

                    break;

                case SCARD_ATTR_DEVICE_UNIT:
                    // Return the unit number of this device
                    ReturnULong(SmartcardExtension->VendorAttr.UnitNo);
                    break;

                case SCARD_ATTR_CHANNEL_ID:
                    //
                    // Return reader type / channel id in form
                    // 0xDDDDCCCC where D is reader type and C is channel number
                    //
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.ReaderType << 16l |
                        SmartcardExtension->ReaderCapabilities.Channel
                        );
                    break;

                case SCARD_ATTR_CHARACTERISTICS:
                    // Return mechanical characteristics of the reader
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.MechProperties
                        )
                    break;

                case SCARD_ATTR_CURRENT_PROTOCOL_TYPE:
                    // Return the currently selected protocol
                    CheckMinCardStatus(SCARD_NEGOTIABLE);

                    ReturnULong(
                        SmartcardExtension->CardCapabilities.Protocol.Selected
                        );
                    break;

                case SCARD_ATTR_CURRENT_CLK:
                    //
                    // Return the current ICC clock freq. encoded as little
                    // endian integer value (3.58 MHZ is 3580)
                    //
                    CheckMinCardStatus(SCARD_NEGOTIABLE);

                    if(SmartcardExtension->CardCapabilities.PtsData.CLKFrequency) {
                        ReturnULong(SmartcardExtension->CardCapabilities.PtsData.CLKFrequency);
                    } else {
                        ReturnULong(SmartcardExtension->ReaderCapabilities.CLKFrequency.Default);
                    }
                    break;

                case SCARD_ATTR_CURRENT_F:
                    // Return the current F value encoded as little endian integer
                    CheckMinCardStatus(SCARD_NEGOTIABLE);

                    if (SmartcardExtension->CardCapabilities.Fl >= 
                        DIM(ClockRateConversion)) {

                        status = STATUS_UNRECOGNIZED_MEDIA;
                        break;
                    }
                    ASSERT(SmartcardExtension->CardCapabilities.Fl < 
                        DIM(ClockRateConversion));

                    ReturnULong(
                        SmartcardExtension->CardCapabilities.ClockRateConversion[
                            SmartcardExtension->CardCapabilities.Fl
                            ].F
                        );
                    break;

                case SCARD_ATTR_CURRENT_D:
                    //
                    // Return the current D value encoded as little endian integer
                    // in units of 1/64. So return 1 if D is 1/64.
                    //
                    CheckMinCardStatus(SCARD_NEGOTIABLE);

                    ASSERT(
                        SmartcardExtension->CardCapabilities.Dl < 
                        DIM(BitRateAdjustment)
                        );

                    ASSERT(
                        SmartcardExtension->CardCapabilities.BitRateAdjustment[
                            SmartcardExtension->CardCapabilities.Dl
                            ].DDivisor != 0
                        );

                    //
                    // Check the current value of Dl.
                    // It should definitely not be greater than the array bounds
                    // and the value in the array is not allowed to be zero
                    //
                    if (SmartcardExtension->CardCapabilities.Dl >=
                        DIM(BitRateAdjustment) ||                        
                        SmartcardExtension->CardCapabilities.BitRateAdjustment[
                            SmartcardExtension->CardCapabilities.Dl
                            ].DDivisor == 0) {

                        status = STATUS_UNRECOGNIZED_MEDIA;
                        break;                              
                    }

                    ReturnULong(
                        SmartcardExtension->CardCapabilities.BitRateAdjustment[
                            SmartcardExtension->CardCapabilities.Dl
                            ].DNumerator /
                        SmartcardExtension->CardCapabilities.BitRateAdjustment[
                            SmartcardExtension->CardCapabilities.Dl
                            ].DDivisor
                        );
                    break;

                case SCARD_ATTR_CURRENT_W:
                    // Return the work waiting time (integer) for T=0
                    CheckMinCardStatus(SCARD_NEGOTIABLE);
                    ReturnULong(SmartcardExtension->CardCapabilities.T0.WI);
                    break;

                case SCARD_ATTR_CURRENT_N:
                    // Return extra guard time
                    CheckMinCardStatus(SCARD_NEGOTIABLE);
                    ReturnULong(SmartcardExtension->CardCapabilities.N);
                    break;

                case SCARD_ATTR_CURRENT_IFSC:
                    // Return the current information field size card
                    CheckMinCardStatus(SCARD_NEGOTIABLE);
                    if (SmartcardExtension->T1.IFSC) {
                        ReturnULong(SmartcardExtension->T1.IFSC);
                    } else {
                        ReturnULong(SmartcardExtension->CardCapabilities.T1.IFSC);
                    }
                    break;

                case SCARD_ATTR_CURRENT_IFSD:
                    // Return the current information field size card
                    CheckMinCardStatus(SCARD_NEGOTIABLE);
                    if (SmartcardExtension->T1.IFSD) {
                        ReturnULong(SmartcardExtension->T1.IFSD);
                    } else {
                        ReturnULong(SmartcardExtension->ReaderCapabilities.MaxIFSD);
                    }
                    break;

                case SCARD_ATTR_CURRENT_BWT:
                    // Return the current block waiting time for T=1
                    CheckMinCardStatus(SCARD_NEGOTIABLE);
                    ReturnULong(SmartcardExtension->CardCapabilities.T1.BWI);
                    break;

                case SCARD_ATTR_CURRENT_CWT:
                    // Return the current character waiting time for T=1
                    CheckMinCardStatus(SCARD_NEGOTIABLE);
                    ReturnULong(SmartcardExtension->CardCapabilities.T1.CWI);
                    break;

                case SCARD_ATTR_CURRENT_EBC_ENCODING:
                    // Return the current error checking method
                    CheckMinCardStatus(SCARD_NEGOTIABLE);
                    ReturnULong(SmartcardExtension->CardCapabilities.T1.EDC);
                    break;

                case SCARD_ATTR_DEFAULT_CLK:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.CLKFrequency.Default
                        );
                    break;

                case SCARD_ATTR_MAX_CLK:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.CLKFrequency.Max
                        );
                    break;

                case SCARD_ATTR_DEFAULT_DATA_RATE:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.DataRate.Default
                        );
                    break;

                case SCARD_ATTR_MAX_DATA_RATE:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.DataRate.Max
                        );
                    break;

                case SCARD_ATTR_ATR_STRING:
                    // Return ATR of currently inserted card
                    CheckUserBuffer(MAXIMUM_ATR_LENGTH);
                    CheckMinCardStatus(SCARD_NEGOTIABLE);
                    RtlCopyMemory(
                        SmartcardExtension->IoRequest.ReplyBuffer,
                        SmartcardExtension->CardCapabilities.ATR.Buffer,
                        SmartcardExtension->CardCapabilities.ATR.Length
                        );
                    *SmartcardExtension->IoRequest.Information = 
                        SmartcardExtension->CardCapabilities.ATR.Length;
                    break;

                case SCARD_ATTR_ICC_TYPE_PER_ATR:
                    //
                    // Return ICC type, based on ATR.
                    // We currently support only T=0 and T=1, so return
                    // 1 for those protocols otherwise 0 (unknown ICC type)
                    //
                    CheckMinCardStatus(SCARD_NEGOTIABLE);
                    ReturnUChar(
                        ((SmartcardExtension->CardCapabilities.Protocol.Selected & 
                        (SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1)) ? 1 : 0)
                        );
                    break;

                case SCARD_ATTR_ICC_PRESENCE:
                    // Return the status of the card
                    AccessUnsafeData(&Irql);
                    switch (SmartcardExtension->ReaderCapabilities.CurrentState) {
                        
                        case SCARD_UNKNOWN:
                            status = STATUS_INVALID_DEVICE_STATE;
                            break;

                        case SCARD_ABSENT:
                            ReturnUChar(0);
                            break;

                        case SCARD_PRESENT:
                            ReturnUChar(1);
                            break;

                        default:
                            ReturnUChar(2);
                            break;

                    }
                    EndAccessUnsafeData(Irql);
                    break;

                case SCARD_ATTR_ICC_INTERFACE_STATUS:
                    // Return if card contacts are active 
                    ReturnUChar(
                        (SmartcardExtension->ReaderCapabilities.CurrentState >=
                            SCARD_SWALLOWED ? (UCHAR) -1 : 0)
                        );
                    break;

                case SCARD_ATTR_PROTOCOL_TYPES:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.SupportedProtocols
                        );
                    break;

                case SCARD_ATTR_MAX_IFSD:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.MaxIFSD
                        );
                    break;

                case SCARD_ATTR_POWER_MGMT_SUPPORT:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.PowerMgmtSupport
                        );
                    break;

                default:
                    status = STATUS_NOT_SUPPORTED;
                    break;
            }
            break;

        case IOCTL_SMARTCARD_SET_ATTRIBUTE:
            switch (SmartcardExtension->MinorIoControlCode) {

                case SCARD_ATTR_SUPRESS_T1_IFS_REQUEST:
                    //
                    // The card does not support ifs request, so 
                    // we turn off ifs negotiation
                    //
                    SmartcardExtension->T1.State = T1_START;
                    break;

                default:
                    status = STATUS_NOT_SUPPORTED;
                    break;
            }
            break;

#if defined(DEBUG) && defined(SMCLIB_NT)
        case IOCTL_SMARTCARD_GET_PERF_CNTR:
            switch (SmartcardExtension->MinorIoControlCode) {

                case SCARD_PERF_NUM_TRANSMISSIONS:
                    ReturnULong(SmartcardExtension->PerfInfo->NumTransmissions);
                    break;

                case SCARD_PERF_BYTES_TRANSMITTED:
                    ReturnULong(
                        SmartcardExtension->PerfInfo->BytesSent +
                        SmartcardExtension->PerfInfo->BytesReceived
                        );
                    break;

                case SCARD_PERF_TRANSMISSION_TIME:
                    ReturnULong( 
                        (ULONG) (SmartcardExtension->PerfInfo->IoTickCount.QuadPart *
                        KeQueryTimeIncrement() /
                        10)
                        );
                    break;
            }
            break;
#endif
        case IOCTL_SMARTCARD_CONFISCATE:
            if (SmartcardExtension->ReaderFunction[RDF_CARD_CONFISCATE] == NULL) {

                status = STATUS_NOT_SUPPORTED;
                break;
            }

            status = SmartcardExtension->ReaderFunction[RDF_CARD_CONFISCATE](
                SmartcardExtension
                );

            break;

        case IOCTL_SMARTCARD_EJECT:
            if (SmartcardExtension->ReaderFunction[RDF_CARD_EJECT] == NULL) {

                status = STATUS_NOT_SUPPORTED;
                break;
            }

            status = SmartcardExtension->ReaderFunction[RDF_CARD_EJECT](
                SmartcardExtension
                );
            break;

#ifdef SMCLIB_VXD
        case IOCTL_SMARTCARD_GET_LAST_ERROR:
            //
            // Return error of the last overlapped operation
            // Used for Windows VxD's that can't return the 
            // error code within IoComplete like NT can
            //
            ReturnULong(SmartcardExtension->LastError);
            break;                                            
#endif
            
        case IOCTL_SMARTCARD_GET_STATE:
            // Return current state of the smartcard
            CheckUserBuffer(sizeof(ULONG));

            AccessUnsafeData(&Irql); 

            *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = 
                SmartcardExtension->ReaderCapabilities.CurrentState;

            *SmartcardExtension->IoRequest.Information = 
                sizeof(ULONG);

            EndAccessUnsafeData(Irql);
            break;

        case IOCTL_SMARTCARD_POWER:
            if (SmartcardExtension->ReaderFunction[RDF_CARD_POWER] == NULL) {

                status = STATUS_NOT_SUPPORTED;
                break;
            }

            // Check if a card is present
            if (SmartcardExtension->ReaderCapabilities.CurrentState <= 
                SCARD_ABSENT) {

                status = STATUS_INVALID_DEVICE_STATE;
                break;
            }

            // Initialize the card capabilities struct
            SmartcardInitializeCardCapabilities(
                SmartcardExtension
                );

            switch (SmartcardExtension->MinorIoControlCode) {

                case SCARD_COLD_RESET:
                case SCARD_WARM_RESET:
                    CheckUserBuffer(MAXIMUM_ATR_LENGTH);

                case SCARD_POWER_DOWN:

                    status = SmartcardExtension->ReaderFunction[RDF_CARD_POWER](
                        SmartcardExtension
                        );
                    break;
                    
                default:
                    status = STATUS_INVALID_DEVICE_REQUEST;
                    break;    
            }
            break;

        case IOCTL_SMARTCARD_SET_PROTOCOL:
            //
            // Since we return the selected protocol, the return buffer
            // must be large enough to hold the result
            //
            CheckUserBuffer(sizeof(ULONG));

            // Set the protocol to be used with the current card
            if (SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] == NULL) {

                status = STATUS_NOT_SUPPORTED;
                break;
            }

            // Check if we're already in specific state
            if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC &&
                (SmartcardExtension->CardCapabilities.Protocol.Selected & 
                 SmartcardExtension->MinorIoControlCode)) {

                status = STATUS_SUCCESS;    
                break;
            }

            // Check if a card is present and not already in specific mode
            if (SmartcardExtension->ReaderCapabilities.CurrentState <= 
                SCARD_ABSENT) {

                status = STATUS_INVALID_DEVICE_STATE;
                break;
            }

            // We only check the ATR when the user selects T=0 or T=1 
            if (SmartcardExtension->MinorIoControlCode & (SCARD_PROTOCOL_Tx)) {
                
                if (SmartcardExtension->MinorIoControlCode & SCARD_PROTOCOL_DEFAULT) {

                    // Select default PTS values
                    SmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_DEFAULT;

                } else {
                
                    // Select best possible PTS data
                    SmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_OPTIMAL;
                }

                // Evaluate ATR
                status = SmartcardUpdateCardCapabilities(SmartcardExtension);

            } else {
                
                // caller doesn't want neither T=0 nor T=1 -> force callback
                status = STATUS_UNRECOGNIZED_MEDIA;
            }

            if (status == STATUS_UNRECOGNIZED_MEDIA && 
                SmartcardExtension->ReaderFunction[RDF_ATR_PARSE] != NULL) {

                // let the driver evaluate the ATR, since we don't know it
                status = SmartcardExtension->ReaderFunction[RDF_ATR_PARSE](
                    SmartcardExtension
                    );
            }

            if (status != STATUS_SUCCESS) {

                // Evaluation of the ATR failed It doesn't make sense to continue
                break;
            } 

            // Check if card is now in the right status
            if (SmartcardExtension->ReaderCapabilities.CurrentState <
                SCARD_NEGOTIABLE) {

                status = STATUS_INVALID_DEVICE_STATE;
                break;
            }

            //
            // Check if the user tries to select a protocol that
            // the card doesn't support
            //
            if ((SmartcardExtension->CardCapabilities.Protocol.Supported & 
                 SmartcardExtension->MinorIoControlCode) == 0) {

                //
                // Since the card does not support the request protocol
                // we need to set back any automatic seletions done by
                // SmartcardUpdateCardCapabilities()
                //
                SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_NEGOTIABLE;
                SmartcardExtension->CardCapabilities.Protocol.Selected = 0;

                status = STATUS_NOT_SUPPORTED;
                break;
            }

            status = SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL](
                SmartcardExtension
                );
            break;

        case IOCTL_SMARTCARD_TRANSMIT:
            if (SmartcardExtension->ReaderFunction[RDF_TRANSMIT] == NULL) {

                status = STATUS_NOT_SUPPORTED;
                break;
            }

            //
            // Check if card is in the right status
            //
            if (SmartcardExtension->ReaderCapabilities.CurrentState != 
                SCARD_SPECIFIC) {

                status = STATUS_INVALID_DEVICE_STATE;
                break;
            }

            if (SmartcardExtension->IoRequest.RequestBufferLength < 
                sizeof(SCARD_IO_REQUEST)) {

                status = STATUS_INVALID_PARAMETER;
                break;              
            }

            //
            // Check if the requested io-protocol matches 
            // the prev. seleced protocol
            //
            scardIoRequest = (PSCARD_IO_REQUEST)
                SmartcardExtension->IoRequest.RequestBuffer;

            if (scardIoRequest->dwProtocol != 
                SmartcardExtension->CardCapabilities.Protocol.Selected) {

                status = STATUS_INVALID_DEVICE_STATE;
                break;
            }

            SmartcardExtension->SmartcardRequest.BufferLength = 0;

#if defined(DEBUG) && defined(SMCLIB_NT)

            SmartcardExtension->PerfInfo->NumTransmissions += 1;
            if (SmartcardExtension->IoRequest.RequestBufferLength >= 
                sizeof(SCARD_IO_REQUEST)) {

                bytesTransferred = 
                    SmartcardExtension->IoRequest.RequestBufferLength - 
                    sizeof(SCARD_IO_REQUEST);

                SmartcardExtension->PerfInfo->BytesSent +=
                    bytesTransferred;
            }
            KeQueryTickCount(&SmartcardExtension->PerfInfo->TickStart);
#endif
            status = SmartcardExtension->ReaderFunction[RDF_TRANSMIT](
                SmartcardExtension
                );

#if defined(DEBUG) && defined(SMCLIB_NT)

            KeQueryTickCount(&SmartcardExtension->PerfInfo->TickEnd);

            if (*SmartcardExtension->IoRequest.Information >=
                sizeof(SCARD_IO_REQUEST)) {
                
                SmartcardExtension->PerfInfo->BytesReceived +=
                    *SmartcardExtension->IoRequest.Information - 
                    sizeof(SCARD_IO_REQUEST);

                bytesTransferred += 
                    *SmartcardExtension->IoRequest.Information - 
                    sizeof(SCARD_IO_REQUEST);
            }

            SmartcardExtension->PerfInfo->IoTickCount.QuadPart += 
                SmartcardExtension->PerfInfo->TickEnd.QuadPart - 
                SmartcardExtension->PerfInfo->TickStart.QuadPart;

            if (FALSE) {

                ULONG timeInMilliSec = (ULONG) 
                    ((SmartcardExtension->PerfInfo->TickEnd.QuadPart - 
                     SmartcardExtension->PerfInfo->TickStart.QuadPart) *
                     KeQueryTimeIncrement() /
                     10000);

                // check for a transferrate of < 400 bps
                if (status == STATUS_SUCCESS &&
                    timeInMilliSec > 0 && 
                    bytesTransferred * 5 < timeInMilliSec * 2) {

                    SmartcardDebug(
                        DEBUG_PERF,
                        ("%s!SmartcardDeviceControl: Datarate for reader %*s was %3ld Baud (%3ld)\n",
                        DRIVER_NAME,
                        SmartcardExtension->VendorAttr.VendorName.Length,
                        SmartcardExtension->VendorAttr.VendorName.Buffer,
                        bytesTransferred * 1000 / timeInMilliSec,
                        bytesTransferred)
                        );              
                }
            }
#endif
            break;

        case IOCTL_SMARTCARD_SWALLOW:
            if (SmartcardExtension->ReaderFunction[RDF_READER_SWALLOW] == NULL) {

                status = STATUS_NOT_SUPPORTED;
                break;
            }
            status = SmartcardExtension->ReaderFunction[RDF_READER_SWALLOW](
                SmartcardExtension
                );
            break;
            
#if DEBUG
        case IOCTL_SMARTCARD_DEBUG:
            //
            // Toggle debug bit
            //
            CurrentDebugLevel = 
                SmartcardGetDebugLevel();

            SmartcardSetDebugLevel( 
                SmartcardExtension->MinorIoControlCode ^ CurrentDebugLevel
                );
            break;
#endif

        default:
            //
            // check if the bit for a vendor ioctl is set and if the driver
            // has registered a callback function
            //
            if ((SmartcardExtension->MajorIoControlCode & CTL_CODE(0, 2048, 0, 0)) == 0 ||
                SmartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR] == NULL) {
                
                status = STATUS_INVALID_DEVICE_REQUEST;

            } else {
                
                //
                // Call the driver if it has registered a callback for vendor calls
                //
                status = SmartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR](
                    SmartcardExtension
                    );
            }
            break;

    } // end switch

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\smclib\smcnt.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    smcnt.c

Abstract:

    This module handles all IOCTL requests to the smart card reader.

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 1996 by Klaus Schutz 

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <ntddk.h>
#include <strsafe.h>

#define SMARTCARD_POOL_TAG 'bLCS'
#define _ISO_TABLES_
#include "smclib.h"

typedef struct _TAG_LIST_ENTRY {

    ULONG Tag;
    LIST_ENTRY List;

} TAG_LIST_ENTRY, *PTAG_LIST_ENTRY;

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

void
SmartcardDeleteLink(
    IN PUNICODE_STRING LinkName
    );

#pragma alloc_text(PAGEABLE,DriverEntry)
#pragma alloc_text(PAGEABLE,SmartcardCreateLink)
#pragma alloc_text(PAGEABLE,SmartcardDeleteLink)
#pragma alloc_text(PAGEABLE,SmartcardInitialize)
#pragma alloc_text(PAGEABLE,SmartcardExit)

NTSTATUS
SmartcardDeviceIoControl(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

PUCHAR 
MapIoControlCodeToString(
    ULONG IoControlCode
    );

#if DEBUG_INTERFACE
#include "smcdbg.c"
#else
NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
{
    return STATUS_SUCCESS;  
}
#endif


NTSTATUS
SmartcardCreateLink(
    IN OUT PUNICODE_STRING LinkName,
    IN PUNICODE_STRING DeviceName
    )
/*++

Routine Description:

    This routine creates a symbolic link name for the given device name.
    NOTE: The buffer for the link name will be allocated here. The caller
    is responsible for freeing the buffer. 
    If the function fails no buffer is allocated.

Arguments:

    LinkName    - receives the created link name

    DeviceName  - the device name for which the link should be created

Return Value:

    None

--*/
{
    NTSTATUS status;
    ULONG i;
    PWCHAR buffer;

    ASSERT(LinkName != NULL);
    ASSERT(DeviceName != NULL);

    if (LinkName == NULL) {

        return STATUS_INVALID_PARAMETER_1;              
    }

    if (DeviceName == NULL) {

        return STATUS_INVALID_PARAMETER_2;              
    }

    buffer = ExAllocatePool(
        NonPagedPool,
        32 * sizeof(WCHAR)
        );

    ASSERT(buffer != NULL);
    if (buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;       
    }

    for (i = 0; i < MAXIMUM_SMARTCARD_READERS; i++) {

        StringCchPrintfW(buffer, 
                        32,
                        L"\\DosDevices\\SCReader%d", i);
        RtlInitUnicodeString(
            LinkName,
            buffer
            );

        status = IoCreateSymbolicLink(
            LinkName,
            DeviceName
            );

        if (NT_SUCCESS(status)) {

            SmartcardDebug(
                DEBUG_INFO,
                ("%s!SmartcardCreateLink: %ws linked to %ws\n",
                DRIVER_NAME,
                DeviceName->Buffer,
                LinkName->Buffer)
                );

            return status;
        }
    }

    ExFreePool(LinkName->Buffer);

    return status;
}   

void
SmartcardDeleteLink(
    IN PUNICODE_STRING LinkName
    )
{
    //
    // Delete the symbolic link of the smart card reader
    //
    IoDeleteSymbolicLink(
        LinkName
        );

    // 
    // Free allocated buffer
    // 
    ExFreePool(
        LinkName->Buffer
        );  
}

NTSTATUS
SmartcardInitialize(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This function allocated the send and receive buffers for smart card 
    data. It also sets the pointer to 2 ISO tables to make them accessible 
    to the driver
    
Arguments:

    SmartcardExtension 

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
        DEBUG_INFO,
        ("%s!SmartcardInitialize: Enter. Version %lx, %s %s\n",
        DRIVER_NAME,
        SMCLIB_VERSION,
        __DATE__,
        __TIME__)
        );

    ASSERT(SmartcardExtension != NULL);
    ASSERT(SmartcardExtension->OsData == NULL);

    if (SmartcardExtension == NULL) {

        return STATUS_INVALID_PARAMETER_1;      
    }

    if (SmartcardExtension->Version > SMCLIB_VERSION ||
        SmartcardExtension->Version < SMCLIB_VERSION_REQUIRED) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!SmartcardInitialize: Incompatible version in SMARTCARD_EXTENSION.\n",
            DRIVER_NAME)
            );

        return STATUS_UNSUCCESSFUL;
    }

    if (SmartcardExtension->SmartcardRequest.BufferSize < MIN_BUFFER_SIZE) {

        SmartcardDebug(
            DEBUG_ERROR, 
            ("%s!SmartcardInitialize: WARNING: SmartcardRequest.BufferSize (%ld) < MIN_BUFFER_SIZE (%ld)\n",
            DRIVER_NAME,
            SmartcardExtension->SmartcardRequest.BufferSize,
            MIN_BUFFER_SIZE)
            );
        
        SmartcardExtension->SmartcardRequest.BufferSize = MIN_BUFFER_SIZE;
    }   

    if (SmartcardExtension->SmartcardReply.BufferSize < MIN_BUFFER_SIZE) {

        SmartcardDebug(
            DEBUG_ERROR, 
            ("%s!SmartcardInitialize: WARNING: SmartcardReply.BufferSize (%ld) < MIN_BUFFER_SIZE (%ld)\n",
            DRIVER_NAME,
            SmartcardExtension->SmartcardReply.BufferSize,
            MIN_BUFFER_SIZE)
            );
        
        SmartcardExtension->SmartcardReply.BufferSize = MIN_BUFFER_SIZE;
    }   

    SmartcardExtension->SmartcardRequest.Buffer = ExAllocatePool(
        NonPagedPool,
        SmartcardExtension->SmartcardRequest.BufferSize
        );

    SmartcardExtension->SmartcardReply.Buffer = ExAllocatePool(
        NonPagedPool,
        SmartcardExtension->SmartcardReply.BufferSize
        );

    SmartcardExtension->OsData = ExAllocatePool(
        NonPagedPool,
        sizeof(OS_DEP_DATA)
        );

#if defined(DEBUG) && defined(SMCLIB_NT)
    SmartcardExtension->PerfInfo = ExAllocatePool(
        NonPagedPool,
        sizeof(PERF_INFO)
        );
#endif

    //
    // Check if one of the above allocations failed
    //
    if (SmartcardExtension->SmartcardRequest.Buffer == NULL ||
        SmartcardExtension->SmartcardReply.Buffer == NULL ||
        SmartcardExtension->OsData == NULL 
#if defined(DEBUG) && defined(SMCLIB_NT)
        || SmartcardExtension->PerfInfo == NULL
#endif
        ) {

        status = STATUS_INSUFFICIENT_RESOURCES;

        if (SmartcardExtension->SmartcardRequest.Buffer) {

            ExFreePool(SmartcardExtension->SmartcardRequest.Buffer);        
        }

        if (SmartcardExtension->SmartcardReply.Buffer) {
            
            ExFreePool(SmartcardExtension->SmartcardReply.Buffer);      
        }

        if (SmartcardExtension->OsData) {
            
            ExFreePool(SmartcardExtension->OsData);         
        }
#if defined(DEBUG) && defined(SMCLIB_NT)
        if (SmartcardExtension->PerfInfo) {
            
            ExFreePool(SmartcardExtension->PerfInfo);       
        }
#endif
    }

    if (status != STATUS_SUCCESS) {

        return status;      
    }

    RtlZeroMemory(
        SmartcardExtension->OsData,
        sizeof(OS_DEP_DATA)
        );

#if defined(DEBUG) && defined(SMCLIB_NT)
    RtlZeroMemory(
        SmartcardExtension->PerfInfo,
        sizeof(PERF_INFO)
        );
#endif

    // Initialize the mutex that is used to synch. access to the driver
    KeInitializeMutex(
        &(SmartcardExtension->OsData->Mutex),
        0
        );

    KeInitializeSpinLock(
        &(SmartcardExtension->OsData->SpinLock)
        );

    // initialize the remove lock
    SmartcardExtension->OsData->RemoveLock.Removed = FALSE;
    SmartcardExtension->OsData->RemoveLock.RefCount = 1;
    KeInitializeEvent(
        &SmartcardExtension->OsData->RemoveLock.RemoveEvent,
        SynchronizationEvent,
        FALSE
        );
    InitializeListHead(&SmartcardExtension->OsData->RemoveLock.TagList);

    // Make the 2 ISO tables accessible to the driver
    SmartcardExtension->CardCapabilities.ClockRateConversion = 
        &ClockRateConversion[0];

    SmartcardExtension->CardCapabilities.BitRateAdjustment = 
        &BitRateAdjustment[0];

#ifdef DEBUG_INTERFACE
    SmclibCreateDebugInterface(SmartcardExtension);
#endif

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!SmartcardInitialize: Exit\n",
        DRIVER_NAME)
        );

    return status;
}

VOID 
SmartcardExit(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine frees the send and receive buffer.
    It is usually called when the driver unloads.
    
Arguments:

    SmartcardExtension 

--*/
{
    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!SmartcardExit: Enter\n",
        DRIVER_NAME)
        );

#ifdef DEBUG_INTERFACE
    SmclibDeleteDebugInterface(SmartcardExtension);
#endif

    //
    // Free all allocated buffers
    //
    if (SmartcardExtension->SmartcardRequest.Buffer) {

        ExFreePool(SmartcardExtension->SmartcardRequest.Buffer);
        SmartcardExtension->SmartcardRequest.Buffer = NULL;
    }   

    if (SmartcardExtension->SmartcardReply.Buffer) {

        ExFreePool(SmartcardExtension->SmartcardReply.Buffer);
        SmartcardExtension->SmartcardReply.Buffer = NULL;
    }

    if (SmartcardExtension->OsData) {

        ExFreePool(SmartcardExtension->OsData);
        SmartcardExtension->OsData = NULL;
    }

#if defined(DEBUG) && defined(SMCLIB_NT)
    if (SmartcardExtension->PerfInfo) {
        
        ExFreePool(SmartcardExtension->PerfInfo);
        SmartcardExtension->OsData = NULL;
    }
#endif

    if (SmartcardExtension->T1.ReplyData) {
        
        // free the reply data buffer for T=1 transmissions
        ExFreePool(SmartcardExtension->T1.ReplyData);
        SmartcardExtension->T1.ReplyData = NULL;                
    }

    SmartcardDebug(
        DEBUG_INFO,
        ("%s!SmartcardExit: Exit - Device %.*s\n",
        DRIVER_NAME,
        SmartcardExtension->VendorAttr.VendorName.Length,
        SmartcardExtension->VendorAttr.VendorName.Buffer)
        );
}   

NTSTATUS
SmartcardAcquireRemoveLockWithTag(
    IN PSMARTCARD_EXTENSION SmartcardExtension,
    ULONG Tag
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    LONG refCount;
#ifdef DEBUG
    PTAG_LIST_ENTRY tagListEntry;
#endif

    refCount = InterlockedIncrement(
        &SmartcardExtension->OsData->RemoveLock.RefCount
        );

    ASSERT(refCount > 0);

    if (SmartcardExtension->OsData->RemoveLock.Removed == TRUE) {

        if (InterlockedDecrement (
                &SmartcardExtension->OsData->RemoveLock.RefCount
                ) == 0) {

            KeSetEvent(
                &SmartcardExtension->OsData->RemoveLock.RemoveEvent, 
                0, 
                FALSE
                );
        }
        status = STATUS_DELETE_PENDING;
    }

#ifdef DEBUG
    tagListEntry = (PTAG_LIST_ENTRY) ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(TAG_LIST_ENTRY),
        SMARTCARD_POOL_TAG
        );

    ASSERT(tagListEntry);

    if (tagListEntry == NULL) {

        return status;
    }

    tagListEntry->Tag = Tag;

    InsertHeadList(
        &SmartcardExtension->OsData->RemoveLock.TagList,
        &tagListEntry->List
        );
#endif

    return status;
}

NTSTATUS
SmartcardAcquireRemoveLock(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    return SmartcardAcquireRemoveLockWithTag(
        SmartcardExtension,
        0
        );
}

VOID
SmartcardReleaseRemoveLockWithTag(
    IN PSMARTCARD_EXTENSION SmartcardExtension,
    IN ULONG Tag
    )
{
    LONG refCount;
#ifdef DEBUG
    PLIST_ENTRY entry;
    BOOLEAN tagFound = FALSE;
#endif
    
    refCount = InterlockedDecrement(
        &SmartcardExtension->OsData->RemoveLock.RefCount
        );

    ASSERT(refCount >= 0);

#ifdef DEBUG
    for (entry = SmartcardExtension->OsData->RemoveLock.TagList.Flink;
         entry->Flink != SmartcardExtension->OsData->RemoveLock.TagList.Flink;
         entry = entry->Flink) {

        PTAG_LIST_ENTRY tagListEntry = CONTAINING_RECORD(entry, TAG_LIST_ENTRY, List);

        if (Tag == tagListEntry->Tag) {

            tagFound = TRUE;
            RemoveEntryList(entry);
            ExFreePool(tagListEntry);
            break;
        }
    }

    ASSERTMSG("SmartcardReleaseRemoveLock() called with unknown tag", tagFound == TRUE);
#endif  

    if (refCount == 0) {

        ASSERT (SmartcardExtension->OsData->RemoveLock.Removed);

        //
        // The device needs to be removed.  Signal the remove event
        // that it's safe to go ahead.
        //
        KeSetEvent(
            &SmartcardExtension->OsData->RemoveLock.RemoveEvent,
            IO_NO_INCREMENT,
            FALSE
            );
    }
}

VOID
SmartcardReleaseRemoveLock(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 0);
}

VOID
SmartcardReleaseRemoveLockAndWait(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
{   
    LONG refCount;

    PAGED_CODE ();

    ASSERT(SmartcardExtension->OsData->RemoveLock.Removed == FALSE);

    SmartcardExtension->OsData->RemoveLock.Removed = TRUE;

    refCount = InterlockedDecrement (
        &SmartcardExtension->OsData->RemoveLock.RefCount
        );

    ASSERT (refCount > 0);

    if (InterlockedDecrement (
            &SmartcardExtension->OsData->RemoveLock.RefCount
            ) > 0) {

#ifdef DEBUG
        // walk the tag list and print all currently held locks
        PLIST_ENTRY entry;

        for (entry = SmartcardExtension->OsData->RemoveLock.TagList.Flink;
             entry->Flink != SmartcardExtension->OsData->RemoveLock.TagList.Flink;
             entry = entry->Flink) {

            PTAG_LIST_ENTRY tagListEntry = CONTAINING_RECORD(entry, TAG_LIST_ENTRY, List);

            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!SmartcardReleaseRemoveLockAndWait: Device %.*s holds lock '%.4s'\n",
                DRIVER_NAME,
                SmartcardExtension->VendorAttr.VendorName.Length,
                SmartcardExtension->VendorAttr.VendorName.Buffer,
                &(tagListEntry->Tag))
                );
        }
#endif

        KeWaitForSingleObject (
            &SmartcardExtension->OsData->RemoveLock.RemoveEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

#ifdef DEBUG
        // free all locks.
        entry = SmartcardExtension->OsData->RemoveLock.TagList.Flink;

        while (entry->Flink != 
               SmartcardExtension->OsData->RemoveLock.TagList.Flink) {

            PTAG_LIST_ENTRY tagListEntry = CONTAINING_RECORD(entry, TAG_LIST_ENTRY, List);
            RemoveEntryList(entry);
            ExFreePool(tagListEntry);
            entry = SmartcardExtension->OsData->RemoveLock.TagList.Flink;
        }
#endif
    }

    SmartcardDebug(
        DEBUG_INFO,
        ("%s!SmartcardReleaseRemoveLockAndWait: Exit - Device %.*s\n",
        DRIVER_NAME,
        SmartcardExtension->VendorAttr.VendorName.Length,
        SmartcardExtension->VendorAttr.VendorName.Buffer)
        );
}
    

VOID
SmartcardLogError(
    IN  PVOID Object,
    IN  NTSTATUS ErrorCode,
    IN  PUNICODE_STRING Insertion,
    IN  ULONG DumpData
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DeviceObject -  Supplies a pointer to the device object associated
                    with the device that had the error, early in
                    initialization, one may not yet exist.

    Insertion -     An insertion string that can be used to log
                    additional data. Note that the message file
                    needs %2 for this insertion, since %1
                    is the name of the driver

    ErrorCode -     Supplies the IO status for this particular error.

    DumpData -      One word to dump

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;

    errorLogEntry = IoAllocateErrorLogEntry(
        Object,
        (UCHAR) (
            sizeof(IO_ERROR_LOG_PACKET) + 
            (Insertion ? Insertion->Length + sizeof(WCHAR) : 0)
            )
        );

    ASSERT(errorLogEntry != NULL);

    if (errorLogEntry == NULL) {

        return;
    }

    errorLogEntry->ErrorCode = ErrorCode;
    errorLogEntry->SequenceNumber = 0;
    errorLogEntry->MajorFunctionCode = 0;
    errorLogEntry->RetryCount = 0;
    errorLogEntry->UniqueErrorValue = 0;
    errorLogEntry->FinalStatus = STATUS_SUCCESS;
    errorLogEntry->DumpDataSize = (DumpData ? sizeof(ULONG) : 0);
    errorLogEntry->DumpData[0] = DumpData;

    if (Insertion) {

        errorLogEntry->StringOffset = 
            sizeof(IO_ERROR_LOG_PACKET);

        errorLogEntry->NumberOfStrings = 1;

        RtlCopyMemory(
            ((PCHAR)(errorLogEntry) + errorLogEntry->StringOffset),
            Insertion->Buffer,
            Insertion->Length
            );
    } 

    IoWriteErrorLogEntry(errorLogEntry);
}

NTSTATUS
SmartcardDeviceControl(
    PSMARTCARD_EXTENSION SmartcardExtension,
    PIRP Irp
    )
/*++

Routine Description:

    The routine is the general device control dispatch function. 

Arguments:

    SmartcardExtension  - The pointer to the smart card datae 
    Irp                 - Supplies the Irp making the request.

Return Value:

   NTSTATUS

--*/

{
    PIO_STACK_LOCATION  ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN ClearCurrentIrp = TRUE;
    UNICODE_STRING Message;
    static BOOLEAN logged = FALSE;
    ULONG ioControlCode = ioStackLocation->Parameters.DeviceIoControl.IoControlCode;

    // Check the pointer to the smart card extension
    ASSERT(SmartcardExtension != NULL);

    if (SmartcardExtension == NULL) {
        status = STATUS_INVALID_PARAMETER_1;

        Irp->IoStatus.Status = status;
    
        IoCompleteRequest(
            Irp, 
            IO_NO_INCREMENT
            );

        return status;
    }

    // Check the version that the driver requires
    ASSERT(SmartcardExtension->Version >= SMCLIB_VERSION_REQUIRED);

    if (SmartcardExtension->Version < SMCLIB_VERSION_REQUIRED) {

        status = STATUS_INVALID_PARAMETER;

        Irp->IoStatus.Status = status;
    
        IoCompleteRequest(
            Irp, 
            IO_NO_INCREMENT
            );

        return status;

    }

    //
    // Check the OsData pointer. This can be NULL if SmartcardInit 
    // has not been called or SmartcardExit has already been called
    //
    ASSERT(SmartcardExtension->OsData != NULL);

    // Check that the driver has set the DeviceObject
    ASSERT(SmartcardExtension->OsData->DeviceObject != NULL);

    if (SmartcardExtension->OsData == NULL ||
        SmartcardExtension->OsData->DeviceObject == NULL) {

        status = STATUS_INVALID_PARAMETER;

        Irp->IoStatus.Status = status;
    
        IoCompleteRequest(
            Irp, 
            IO_NO_INCREMENT
            );

        return status;

    }

    // We must run at passive level otherwise IoCompleteRequest won't work properly
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    // check that no one wants us to do unbuffered io
    if (ioControlCode & (METHOD_IN_DIRECT | METHOD_OUT_DIRECT)) {

        status = STATUS_INVALID_PARAMETER;

        Irp->IoStatus.Status = status;
    
        IoCompleteRequest(
            Irp, 
            IO_NO_INCREMENT
            );

        return status;
    }

    //
    // This resource acts as a mutex. We can't use a 'real' mutex here,
    // since a mutex rises the Irql to APC_LEVEL. This leads to some
    // side effects we don't want.
    // E.g. IoCompleteRequest() will not copy requested data at APC_LEVEL
    //
    KeWaitForMutexObject(
        &(SmartcardExtension->OsData->Mutex),
        UserRequest,
        KernelMode,
        FALSE,
        NULL
        );

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);


#ifdef developerversion
#if DEBUG
    if(!logged) {
        
        RtlInitUnicodeString(
            &Message,
            L"Developer version of smclib.sys installed"
            );

        SmartcardLogError(
            SmartcardExtension->OsData->DeviceObject,
            STATUS_LICENSE_VIOLATION, 
            &Message,
            0            
            );

        logged = TRUE;
    }
#endif
#endif

    SmartcardDebug(
        DEBUG_IOCTL,
        ("SMCLIB!SmartcardDeviceControl: Enter <%.*s:%1d>, IOCTL = %s, IRP = %lx\n",
        SmartcardExtension->VendorAttr.VendorName.Length,
        SmartcardExtension->VendorAttr.VendorName.Buffer,
        SmartcardExtension->VendorAttr.UnitNo,
        MapIoControlCodeToString(ioControlCode),
        Irp)
        );

    // Return if device is busy
    if (InterlockedCompareExchangePointer(&SmartcardExtension->OsData->CurrentIrp,
                                          Irp,
                                          NULL)) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!SmartcardDeviceControl: Device %.*s is busy\n",
            DRIVER_NAME,
            SmartcardExtension->VendorAttr.VendorName.Length,
            SmartcardExtension->VendorAttr.VendorName.Buffer)
            );

        // This flag is used to signal that we can't set the current irp to NULL
        ClearCurrentIrp = FALSE;

        status = STATUS_DEVICE_BUSY;    
    }

    if (status == STATUS_SUCCESS) {

        PIRP notificationIrp;
        ULONG currentState;
        KIRQL irql;

        switch (ioControlCode) {

            //
            // We have to check for _IS_ABSENT and _IS_PRESENT first, 
            // since these are (the only allowed) asynchronous requests
            //
            case IOCTL_SMARTCARD_IS_ABSENT:

                ClearCurrentIrp = FALSE;
                InterlockedExchangePointer(&SmartcardExtension->OsData->CurrentIrp,
                                           NULL);

                if (SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] == NULL) {

                    status = STATUS_NOT_SUPPORTED;
                    break;
                }

                AccessUnsafeData(&irql);

                currentState = SmartcardExtension->ReaderCapabilities.CurrentState;

                // Now check if the driver is already processing a notification irp
                if (SmartcardExtension->OsData->NotificationIrp != NULL) {

                    status = STATUS_DEVICE_BUSY;
                    EndAccessUnsafeData(irql);
                    break;                  
                }

                //
                // if the current state is not known, it doesn't make sense 
                // to process this call
                //
                if (currentState == SCARD_UNKNOWN) {

                    status = STATUS_INVALID_DEVICE_STATE;
                    EndAccessUnsafeData(irql);
                    break;
                }

                //
                // If the card is already (or still) absent, we can return immediatly.
                // Otherwise we must statrt event tracking.
                // 
                if (currentState > SCARD_ABSENT) {

                    
                    SmartcardExtension->OsData->NotificationIrp = Irp;
                    SmartcardExtension->MajorIoControlCode = 
                        IOCTL_SMARTCARD_IS_ABSENT;

                    EndAccessUnsafeData(irql);

                    status = SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING](
                        SmartcardExtension
                        );
                } else {
                    EndAccessUnsafeData(irql);
                }

                
                break;
                
            case IOCTL_SMARTCARD_IS_PRESENT:

                ClearCurrentIrp = FALSE;
                InterlockedExchangePointer(&SmartcardExtension->OsData->CurrentIrp,
                                           NULL);


                if (SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] == NULL) {

                    status = STATUS_NOT_SUPPORTED;
                    break;
                }

                AccessUnsafeData(&irql);
                currentState = SmartcardExtension->ReaderCapabilities.CurrentState;

                // Now check if the driver is already processing a notification irp
                if (SmartcardExtension->OsData->NotificationIrp != NULL) {

                    status = STATUS_DEVICE_BUSY;
                    EndAccessUnsafeData(irql);
                    break;                  
                }

                //
                // if the current state is not known, it doesn't make sense 
                // to process this call
                //
                if (currentState == SCARD_UNKNOWN) {

                    status = STATUS_INVALID_DEVICE_STATE;
                    EndAccessUnsafeData(irql);
                    break;
                }

                //
                // If the card is already (or still) present, we can return immediatly.
                // Otherwise we must statrt event tracking.
                // 
                if (currentState <= SCARD_ABSENT) {

#if defined(DEBUG) && defined(SMCLIB_NT)
                    ULONG timeInMilliSec = (ULONG)
                        SmartcardExtension->PerfInfo->IoTickCount.QuadPart *
                        KeQueryTimeIncrement() /
                        10000;

                    ULONG bytesTransferred = 
                        SmartcardExtension->PerfInfo->BytesSent + 
                        SmartcardExtension->PerfInfo->BytesReceived;

                    // to avoid div. errors and to display only useful information
                    // we check for a valid time.
                    if (timeInMilliSec > 0) {
                        
                        SmartcardDebug(
                            DEBUG_PERF,
                            ("%s!SmartcardDeviceControl: I/O statistics for device %.*s:\n    Transferrate: %5ld bps\n     Total bytes: %5ld\n        I/O time: %5ld ms\n   Transmissions: %5ld\n",
                            DRIVER_NAME,
                            SmartcardExtension->VendorAttr.VendorName.Length,
                            SmartcardExtension->VendorAttr.VendorName.Buffer,
                            bytesTransferred * 1000 / timeInMilliSec,
                            bytesTransferred,
                            timeInMilliSec,
                            SmartcardExtension->PerfInfo->NumTransmissions)
                            );                              
                    }
                    // reset performance info
                    RtlZeroMemory(
                        SmartcardExtension->PerfInfo, 
                        sizeof(PERF_INFO)
                        );
#endif              
                    SmartcardExtension->OsData->NotificationIrp = Irp;
                    SmartcardExtension->MajorIoControlCode = 
                        IOCTL_SMARTCARD_IS_PRESENT;

                    EndAccessUnsafeData(irql);

                    status = SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING](
                        SmartcardExtension
                        );
                } else {
                    EndAccessUnsafeData(irql);
                }
                break;

            default:
                // Get major io control code
                SmartcardExtension->MajorIoControlCode = ioControlCode;

                // Check if buffers are properly allocated
                ASSERT(SmartcardExtension->SmartcardRequest.Buffer);
                ASSERT(SmartcardExtension->SmartcardReply.Buffer);

                if (Irp->AssociatedIrp.SystemBuffer && 
                    ioStackLocation->Parameters.DeviceIoControl.InputBufferLength >= 
                    sizeof(ULONG)) {

                    //
                    // Transfer minor io control code, even if it doesn't make sense for
                    // this particular major code
                    //
                    SmartcardExtension->MinorIoControlCode = 
                        *(PULONG) (Irp->AssociatedIrp.SystemBuffer);
                }

                
                // Save pointer to and length of request buffer
                SmartcardExtension->IoRequest.RequestBuffer = 
                    Irp->AssociatedIrp.SystemBuffer;
                SmartcardExtension->IoRequest.RequestBufferLength = 
                    ioStackLocation->Parameters.DeviceIoControl.InputBufferLength,

                // Save pointer to and length of reply buffer
                SmartcardExtension->IoRequest.ReplyBuffer = 
                    Irp->AssociatedIrp.SystemBuffer;
                SmartcardExtension->IoRequest.ReplyBufferLength = 
                    ioStackLocation->Parameters.DeviceIoControl.OutputBufferLength;

                //
                // Pointer to variable that receives the actual number 
                // of bytes returned
                //
                SmartcardExtension->IoRequest.Information = 
                    (PULONG) &Irp->IoStatus.Information;

                // Default number of bytes returned
                Irp->IoStatus.Information = 0;

                // Process the device io-control-request
                status = SmartcardDeviceIoControl(SmartcardExtension);
                if (status == STATUS_PENDING) {
                   IoMarkIrpPending(Irp);
                }
#ifndef NO_LOG
                if (!NT_SUCCESS(status) && status != STATUS_NOT_SUPPORTED) {

                    UNICODE_STRING error;
                    WCHAR buffer[128];

                    swprintf(
                        buffer, 
                        L"IOCTL %S failed with status 0x%lx", 
                        MapIoControlCodeToString(ioControlCode),
                        status
                        );
                        
                    RtlInitUnicodeString(
                        &error,
                        buffer
                        );

                    SmartcardLogError(
                        SmartcardExtension->OsData->DeviceObject,
                        0,
                        &error,
                        0            
                        );
                }
#endif
                break;
        }
    }

    if (status == STATUS_PENDING)  {

        KIRQL irql;
        BOOLEAN pending = FALSE;
        
        //
        // Send command to smartcard. The ISR receives the result and queues a dpc function
        // that handles the completion of the call;
        //
        SmartcardDebug(
            DEBUG_IOCTL,
            ("%s!SmartcardDeviceControl: IoMarkIrpPending. IRP = %x\n",
            DRIVER_NAME,
            Irp)
            );

        //
        // When the driver completes an Irp (Notification or Current) it has 
        // to set either the Irp back to 0 in order to show that it completed 
        // the Irp. 
        // 
        AccessUnsafeData(&irql);

        if (Irp == SmartcardExtension->OsData->NotificationIrp || 
            Irp == SmartcardExtension->OsData->CurrentIrp) {
            
            pending = TRUE;
        }

        EndAccessUnsafeData(irql);

        if (pending && 
            SmartcardExtension->OsData->DeviceObject->DriverObject->DriverStartIo) {

            SmartcardDebug(
                DEBUG_IOCTL,
                ("%s!SmartcardDeviceControl: IoStartPacket. IRP = %x\n",
                DRIVER_NAME,
                Irp)
                );

            // Start io-processing of a lowest level driver
            IoStartPacket(
                SmartcardExtension->OsData->DeviceObject, 
                Irp, 
                NULL, 
                NULL
                );
        }
        
    } else {
    
        SmartcardDebug(
            DEBUG_IOCTL,
            ("%s!SmartcardDeviceControl: IoCompleteRequest. IRP = %x (%lxh)\n",
            DRIVER_NAME,
            Irp,
            status)
            );
            
        Irp->IoStatus.Status = status;
    
        IoCompleteRequest(
            Irp, 
            IO_NO_INCREMENT
            );

        if (ClearCurrentIrp) {

            //
            // If the devcie is not busy, we can set the current irp back to NULL
            //
            InterlockedExchangePointer(&SmartcardExtension->OsData->CurrentIrp,
                                NULL);
            RtlZeroMemory(
                &(SmartcardExtension->IoRequest),
                sizeof(SmartcardExtension->IoRequest)
                );
        }
    }

    SmartcardDebug(
        (NT_SUCCESS(status) ? DEBUG_IOCTL : DEBUG_ERROR),
        ("SMCLIB!SmartcardDeviceControl: Exit. IOCTL = %s, IRP = %x (%lxh)\n",
        MapIoControlCodeToString(ioControlCode),
        Irp,
        status)
        );

    //
    // Release our 'mutex'
    //
    KeReleaseMutex(
        &(SmartcardExtension->OsData->Mutex),
        FALSE
        );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\smclib\smcutil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    smcutil.c

Abstract:

    This module contains some utility fucntions

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 1996 by Klaus Schutz 
    - Nov 97:   Released Version 1.0 
    - Jan 98:   Calc. of GT changed. (Now set to 0 if N = 0 or N = 255)
                Rules for setting card status to SCARD_SPECIFIC changed
                Default clock freq. is now used for initial etu calculation

--*/

#define _ISO_TABLES_
#ifdef SMCLIB_VXD

#define try 
#define leave goto __label
#define finally __label:

#else
#if !defined(SMCLIB_CE)

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <ntddk.h>

#endif
#endif

#ifdef SMCLIB_TEST
#define DbgPrint printf
#define DbgBreakPoint()
#define RtlAssert
#endif


#define _SMCUTIL_
#include "smclib.h"

#define IS_VENDOR(a) (memcmp(SmartcardExtension->VendorAttr.VendorName.Buffer, a, SmartcardExtension->VendorAttr.VendorName.Length) == 0)
#define IS_IFDTYPE(a) (memcmp(SmartcardExtension->VendorAttr.IfdType.Buffer, a, SmartcardExtension->VendorAttr.IfdType.Length) == 0)

void
DumpData(
    const ULONG DebugLevel,
    PUCHAR Data,
    ULONG DataLen
    );

//
// This is the time resolution.
// We calculate all times not in seconds, but in micro seconds
//
#define TR ((ULONG)(1000l * 1000l))

static ULONG 
Pow2(
    UCHAR Exponent
    )
{
    ULONG result = 1;

    while(Exponent--)
        result *= 2;

    return result;
}   

#ifdef _X86_ 
#pragma optimize("", off) 
#endif 

#if (DEBUG && DEBUG_VERBOSE)
#pragma message("Debug Verbose is turned on")
ULONG DebugLevel = DEBUG_PERF | DEBUG_ATR;
#else
ULONG DebugLevel = 0;
#endif

ULONG
#ifdef SMCLIB_VXD
SMCLIB_SmartcardGetDebugLevel(
#else
SmartcardGetDebugLevel(
#endif
    void
    )
{
    return DebugLevel;
}   

void
#ifdef SMCLIB_VXD
SMCLIB_SmartcardSetDebugLevel(
#else
SmartcardSetDebugLevel(
#endif
    ULONG Level
    )
{
    DebugLevel = Level;
}   

#ifdef _X86_ 
#pragma optimize("", on) 
#endif 

#if DEBUG
void
DumpData(
    const ULONG DebugLevel,
    PUCHAR Data,
    ULONG DataLen
    )
{
    ULONG i, line = 0;
    TCHAR buffer[72], *pbuffer;

    while(DataLen) {

        pbuffer = buffer;
        sprintf(pbuffer, "%*s", sizeof(buffer) - 1, "");

        if (line > 0) {

            pbuffer += 8;
        }

        for (i = 0; i < 8 && DataLen; i++, DataLen--, Data++) {

            sprintf(pbuffer + i * 3, "%02X ", *Data);
            sprintf(pbuffer + i + 26, "%c", (isprint(*Data) ? *Data : '.'));
        }

        pbuffer[i * 3] = ' ';
        pbuffer[i + 26] = '\n';
        pbuffer[i + 27] = '\0';

        SmartcardDebug(DebugLevel, (buffer));

        line += 1;
    }
}
#endif

VOID
SmartcardInitializeCardCapabilities(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine initializes all fields in the CardCapabilities structure,
    which can be calculated by the SmartcardUpdateCardCapabilities function.
    
Arguments:

    SmartcardExtension 

Return Value:

    None

--*/
{
    //
    // Save the pointers to the two tables
    //
    PCLOCK_RATE_CONVERSION clockRateConversion = SmartcardExtension->CardCapabilities.ClockRateConversion;
    PBIT_RATE_ADJUSTMENT bitRateAdjustment = SmartcardExtension->CardCapabilities.BitRateAdjustment;

    //
    // Right now it is fine to zero the whole struct
    //
    RtlZeroMemory(
        &SmartcardExtension->CardCapabilities,
        sizeof(SmartcardExtension->CardCapabilities)
        );

    // Restore the pointers
    SmartcardExtension->CardCapabilities.ClockRateConversion = clockRateConversion;
    SmartcardExtension->CardCapabilities.BitRateAdjustment = bitRateAdjustment;

    //
    // Every card has to support the 'raw' protocol
    // It enables the usage of cards that have their own protocol defined
    //
    SmartcardExtension->CardCapabilities.Protocol.Supported = 
        SCARD_PROTOCOL_RAW;

    //
    // Reset T=1 specific data
    //

    // force the T=1 protocol to start with an ifsd request
    SmartcardExtension->T1.State = T1_INIT;

    //
    // Initialize the send sequence number and 
    // the 'receive sequence number'
    //
    SmartcardExtension->T1.SSN = 0;
    SmartcardExtension->T1.RSN = 0;

    SmartcardExtension->T1.IFSC = 0;

    ASSERT(SmartcardExtension->ReaderCapabilities.MaxIFSD != 0);

    // Initialize the interface information field size
    if (SmartcardExtension->ReaderCapabilities.MaxIFSD != 0 &&
        SmartcardExtension->ReaderCapabilities.MaxIFSD <= T1_IFSD) {
        SmartcardExtension->T1.IFSD = 
            (UCHAR) SmartcardExtension->ReaderCapabilities.MaxIFSD;

    } else {
        
        SmartcardExtension->T1.IFSD = T1_IFSD_DEFAULT;
    }
}   

VOID
SmartcardInvertData(
    PUCHAR Buffer,
    ULONG Length
    )
/*++

Routine Description:

    This routine converts the passed buffer from inverse to direct or the other way

Arguments:


Return Value:

    None

--*/

{
    ULONG i;

    for (i = 0; i < Length; i++) {

        UCHAR j, inv = 0;

        for (j = 0; j < 8; j++) {

            if (Buffer[i] & (1 << j)) {

                inv |= 1 << (7 - j);
            }
        }
        Buffer[i] = (inv ^ 0xFF);
    }
}

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardUpdateCardCapabilities(
#else
SmartcardUpdateCardCapabilities(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine updates the CardCapabilities structure, which holds information about
    the smartcard that has just been reset and is currently in use. It reads the 
    ATR string and retrieves all the relevent information.

    Please refer to ISO 7816-3 ,section 6.1.4 for the format of the ATR string
    
Arguments:

    SmartcardExtension 

Return Value:

    NTSTATUS

--*/
{
    PSCARD_CARD_CAPABILITIES cardCapabilities = &SmartcardExtension->CardCapabilities;
    PSCARD_READER_CAPABILITIES readerCapabilities = &SmartcardExtension->ReaderCapabilities;
    PUCHAR atrString = cardCapabilities->ATR.Buffer;
    ULONG atrLength = (ULONG) cardCapabilities->ATR.Length;
    UCHAR Y, Tck, TA[MAXIMUM_ATR_CODES], TB[MAXIMUM_ATR_CODES];
    UCHAR TC[MAXIMUM_ATR_CODES], TD[MAXIMUM_ATR_CODES];
    ULONG i, fs, numProtocols = 0, protocolTypes = 0;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN TA2Present = FALSE;
#if DEBUG
    TCHAR *ptsType[] = {TEXT("PTS_TYPE_DEFAULT"), TEXT("PTS_TYPE_OPTIMAL"), TEXT("PTS_TYPE_USER")};
#endif
#if defined (SMCLIB_NT) 
    KIRQL irql;
#endif

    SmartcardDebug(
        DEBUG_ATR,
        (TEXT("%s!SmartcardUpdateCardCapabilities:\n"),
        DRIVER_NAME)
        );

    if (atrLength < 2) {
        
        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   ATR is too short (Min. length is 2) \n"))
            );

        return STATUS_UNRECOGNIZED_MEDIA;
    }

#if DEBUG

    SmartcardDebug(
        DEBUG_ATR,
        (TEXT("   ATR: "))
        );

    DumpData(
        DEBUG_ATR,
        atrString,
        atrLength
        );
#endif

    if (atrString[0] != 0x3b && atrString[0] != 0x3f && atrString[0] != 0x03) {

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   Initial character %02xh of ATR is invalid\n"),
            atrString[0])
            );

        return STATUS_UNRECOGNIZED_MEDIA;
    }

    // Test for invers convention
    if (*atrString == 0x03) {

        cardCapabilities->InversConvention = TRUE;

        //
        // When the ATR starts with 0x03 then it 
        // has not been inverted already            
        //
        SmartcardInvertData(
            cardCapabilities->ATR.Buffer, 
            cardCapabilities->ATR.Length
            );              

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   Card uses Inverse Convention\n"))
            );
    } 

    __try {

        //
        // The caller might be calling this function repeatedly in order to 
        // test if the ATR is valid. If the ATR we currently have here is
        // not valid then we need to be able re-invert an inverted ATR.
        //

        atrString += 1;
        atrLength -= 1;

        //
        // Calculate check char, but do not test now since if only T=0 
        // is present the ATR doesn't contain a check char
        //
        for (i = 0, Tck = 0; i < atrLength; i++) {

            Tck ^= atrString[i];
        }

        // Initialize various data
        cardCapabilities->Protocol.Supported = 0;

        RtlZeroMemory(TA, sizeof(TA));
        RtlZeroMemory(TB, sizeof(TB));
        RtlZeroMemory(TC, sizeof(TC));
        RtlZeroMemory(TD, sizeof(TD));

        //
        // Set default values as described in ISO 7816-3
        //
    
        // TA1 codes Fl in high-byte and Dl in low-byte;
        TA[0] = 0x11;
        // TB1 codes II in bits b7/b6 and Pl1 in b5-b1. b8 has to be 0
        TB[0] = 0x25;
        // TC2 codes T=0 WI
        TC[1] = 10;

        // Translate ATR string to TA to TD values (See ISO)
        cardCapabilities->HistoricalChars.Length = *atrString & 0x0f;

        Y = *atrString++ & 0xf0;
        atrLength -= 1;

        for (i = 0; i < MAXIMUM_ATR_CODES; i++) {

            if (Y & 0x10) {

                if (i == 1) {

                    TA2Present = TRUE;                  
                }

                TA[i] = *atrString++;
                atrLength -= 1;
            }

            if (Y & 0x20) {

                TB[i] = *atrString++;
                atrLength -= 1;
            }

            if (Y & 0x40) {

                TC[i] = *atrString++;
                atrLength -= 1;
            }

            if (Y & 0x80) {

                Y = *atrString & 0xf0;
                TD[i] = *atrString++ & 0x0f;
                atrLength -= 1;

                // Check if the next parameters are for a new protocol.
                if (((1 << TD[i]) & protocolTypes) == 0) {

                    // Count the number of protocols that the card supports
                    numProtocols++;
                }
                protocolTypes |= 1 << TD[i];

            } else {
                
                break;
            }
        } 

        // Check if the card supports a protocol other than T=0
        if (protocolTypes & ~1) {

            //
            // The atr contains a checksum byte.
            // Exclude that from the historical byte length check
            //
            atrLength -=1;      

            //
            // This card supports more than one protocol or a protocol 
            // other than T=0, so test if the checksum is correct
            //
            if (Tck != 0) {

                SmartcardDebug(
                    DEBUG_ATR,
                    (TEXT("   ATR Checksum is invalid\n"))
                    );

                status = STATUS_UNRECOGNIZED_MEDIA;
                __leave;
            }
        }

        if (/* atrLength < 0 || */
            atrLength != cardCapabilities->HistoricalChars.Length) {
            
            SmartcardDebug(
                DEBUG_ATR,
                (TEXT("   ATR length is inconsistent\n"))
                );

            status = STATUS_UNRECOGNIZED_MEDIA;
            __leave;
        }
    }
    __finally {

        if (status != STATUS_SUCCESS) {

            if (cardCapabilities->InversConvention == TRUE) {

                SmartcardInvertData(
                    cardCapabilities->ATR.Buffer, 
                    cardCapabilities->ATR.Length
                    );              

                cardCapabilities->InversConvention = FALSE;
            }

        }
    }

    if (status != STATUS_SUCCESS)
        return status;
        
    // store historical characters
    RtlCopyMemory(
        cardCapabilities->HistoricalChars.Buffer,
        atrString,
        cardCapabilities->HistoricalChars.Length
        );

    //
    // Now convert TA - TD values to global interface bytes
    //

    // Clock rate conversion
    cardCapabilities->Fl = (TA[0] & 0xf0) >> 4;

    // bit rate adjustment
    cardCapabilities->Dl = (TA[0] & 0x0f);

    // Maximum programming current factor
    cardCapabilities->II = (TB[0] & 0xc0) >> 6;

    // Programming voltage in 0.1 Volts
    cardCapabilities->P = (TB[1] ? TB[1] : (TB[0] & 0x1f) * 10);

    // Extra guard time
    cardCapabilities->N = TC[0];

    //
    // Check if the Dl and Fl values are valid
    // 
    if (BitRateAdjustment[cardCapabilities->Dl].DNumerator == 0 ||
        ClockRateConversion[cardCapabilities->Fl].F == 0) {

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   Dl = %02x or Fl = %02x invalid\n"),
            cardCapabilities->Dl,
            cardCapabilities->Fl)
            );

        return STATUS_UNRECOGNIZED_MEDIA;
    }

    ASSERT(readerCapabilities->CLKFrequency.Max != 0);
    ASSERT(readerCapabilities->CLKFrequency.Default != 0);

    SmartcardDebug(
        DEBUG_ATR,
        (TEXT("   Card parameters from ATR:\n      Fl = %02x (%ld KHz), Dl = %02x, I = %02x, P = %02x, N = %02x\n"),
        cardCapabilities->Fl,
        ClockRateConversion[cardCapabilities->Fl].fs / 1000,
        cardCapabilities->Dl,
        cardCapabilities->II,
        cardCapabilities->P,
        cardCapabilities->N)
        );

    //
    // assume default clock frequency
    //
    fs = readerCapabilities->CLKFrequency.Default * 1000l;
    if (fs == 0) {

        fs = 372 * 9600l;
    }

    if (cardCapabilities->PtsData.Type == PTS_TYPE_DEFAULT) {

        //
        // Assume default parameters
        //
        cardCapabilities->PtsData.Fl = 1;
        cardCapabilities->PtsData.Dl = 1;

        cardCapabilities->PtsData.DataRate = 
            readerCapabilities->DataRate.Default;

        cardCapabilities->PtsData.CLKFrequency = 
            readerCapabilities->CLKFrequency.Default;
    }

    if (cardCapabilities->PtsData.Type != PTS_TYPE_DEFAULT) {

        //
        // Try to find optimal parameters:
        // Highest possible clock frequency of the card 
        // combined with fastes data rate
        //

        //
        // We now try to find a working Fl and Dl combination
        //

        if (cardCapabilities->PtsData.Type == PTS_TYPE_OPTIMAL) {
            
            cardCapabilities->PtsData.Fl = cardCapabilities->Fl;
        }

        ASSERT(cardCapabilities->PtsData.Fl < 16);
        ASSERT(ClockRateConversion[cardCapabilities->PtsData.Fl].F);

        if (cardCapabilities->PtsData.Fl > 15 ||
            ClockRateConversion[cardCapabilities->PtsData.Fl].F == 0) {

            return STATUS_INVALID_PARAMETER;
        }

        do {
            
            ULONG cardFreq, maxFreq;

            if (readerCapabilities->CLKFrequenciesSupported.Entries == 0 ||
                readerCapabilities->CLKFrequenciesSupported.List == NULL) {

                //
                // The clock freq. list supplied by the reader is empty
                // We take the standard values supplied by the reader
                //
                readerCapabilities->CLKFrequenciesSupported.List =
                    &readerCapabilities->CLKFrequency.Default;

                readerCapabilities->CLKFrequenciesSupported.Entries = 2;
            }

            //
            // Find the highest possible clock freq. supported 
            // by the card and the reader
            //
            cardFreq = 
                ClockRateConversion[cardCapabilities->PtsData.Fl].fs / 
                1000;

            cardCapabilities->PtsData.CLKFrequency = 0;

            for (i = 0; i < readerCapabilities->CLKFrequenciesSupported.Entries; i++) {

                // look for highest possible reader frequency
                if (readerCapabilities->CLKFrequenciesSupported.List[i] > 
                    cardCapabilities->PtsData.CLKFrequency &&
                    readerCapabilities->CLKFrequenciesSupported.List[i] <= 
                    cardFreq) {

                    cardCapabilities->PtsData.CLKFrequency =
                        readerCapabilities->CLKFrequenciesSupported.List[i];
                }
            }

            fs = cardCapabilities->PtsData.CLKFrequency * 1000;
            cardCapabilities->PtsData.DataRate = 0;

            ASSERT(fs != 0);
            if (fs == 0) {

                return STATUS_INVALID_PARAMETER;                
            }

            if (cardCapabilities->PtsData.Type == PTS_TYPE_OPTIMAL) {
                
                cardCapabilities->PtsData.Dl = cardCapabilities->Dl;
            }

            ASSERT(cardCapabilities->PtsData.Dl < 16);
            ASSERT(BitRateAdjustment[cardCapabilities->PtsData.Dl].DNumerator);

            if (cardCapabilities->PtsData.Dl > 15 ||
                BitRateAdjustment[cardCapabilities->PtsData.Dl].DNumerator == 0) {

                return STATUS_INVALID_PARAMETER;
            }

            if (readerCapabilities->DataRatesSupported.Entries == 0 ||
                readerCapabilities->DataRatesSupported.List == NULL) {

                //
                // The data rate list supplied by the reader is empty.
                // We take the standard min/max values of the reader
                //
                readerCapabilities->DataRatesSupported.List =
                    &readerCapabilities->DataRate.Default;

                readerCapabilities->DataRatesSupported.Entries = 2;
            }

            //
            // Now try to find the highest possible matching data rate
            // (A matching data rate is one that VERY close 
            // to one supplied by the reader)
            //
            while(cardCapabilities->PtsData.Dl > 1) {

                ULONG dataRate;

                //
                // Calculate the data rate using the current values
                //
                dataRate = 
                    (BitRateAdjustment[cardCapabilities->PtsData.Dl].DNumerator * 
                    fs) / 
                    (BitRateAdjustment[cardCapabilities->PtsData.Dl].DDivisor * 
                    ClockRateConversion[cardCapabilities->PtsData.Fl].F);

                //
                // Try to find a matching data rate
                //
                for (i = 0; i < readerCapabilities->DataRatesSupported.Entries; i++) {

                    if (readerCapabilities->DataRatesSupported.List[i] * 101 > dataRate * 100 &&
                        readerCapabilities->DataRatesSupported.List[i] * 99 < dataRate * 100) {

                        cardCapabilities->PtsData.DataRate = 
                            readerCapabilities->DataRatesSupported.List[i];

                        break;                          
                    }
                }

                if (cardCapabilities->PtsData.DataRate) {

                    break;                  
                }

                //
                // Select the next valid lower D value
                //
                while (BitRateAdjustment[--cardCapabilities->PtsData.Dl].DNumerator == 0)
                    ;
            }
                 
            if (cardCapabilities->PtsData.Fl == 1 && 
                cardCapabilities->PtsData.Dl == 1) {

                cardCapabilities->PtsData.DataRate =
                    readerCapabilities->DataRate.Default;                    

                cardCapabilities->PtsData.CLKFrequency = 
                    readerCapabilities->CLKFrequency.Default;

                break;
            }

            if (cardCapabilities->PtsData.DataRate) {

                break;                  
            }
            //
            // Select the next valid lower F value
            //
            maxFreq = ClockRateConversion[cardCapabilities->Fl].fs;

            do {

                cardCapabilities->PtsData.Fl -= 1;

            } while (ClockRateConversion[cardCapabilities->PtsData.Fl].F == 0 ||
                     ClockRateConversion[cardCapabilities->PtsData.Fl].fs > 
                     maxFreq);

        } while(cardCapabilities->PtsData.DataRate == 0);
    }

    ASSERT(fs != 0);
    ASSERT(cardCapabilities->PtsData.Dl < 16);
    ASSERT(BitRateAdjustment[cardCapabilities->PtsData.Dl].DNumerator != 0);

    //
    // We calculate the ETU on basis of the timing supplied by the 
    // clk-frequency of the reader
    //
    //
    // Work etu in units of time resolution(TR) (NOT in seconds)
    //
    cardCapabilities->etu = 
        1 +     // required to round up
        (TR * 
        BitRateAdjustment[cardCapabilities->PtsData.Dl].DDivisor *
        ClockRateConversion[cardCapabilities->PtsData.Fl].F) /
        (BitRateAdjustment[cardCapabilities->PtsData.Dl].DNumerator * 
        fs);

    //
    // guard time in micro seconds
    // the guard time is the gap between the end of the
    // current character and the beginning of the next character
    //
    cardCapabilities->GT = 0;
    cardCapabilities->PtsData.StopBits = 2;

    if (cardCapabilities->N == 255) {

        cardCapabilities->PtsData.StopBits = 1;     

    } else if (cardCapabilities->N > 0) {
        
        cardCapabilities->GT = cardCapabilities->N * cardCapabilities->etu;
    }

    SmartcardDebug(
        DEBUG_ATR,
        (TEXT("   PTS parameters (%s):\n      Fl = %02x (%ld KHz), Dl = %02x (%ld Bps, %d Stop Bits)\n"),
        ptsType[cardCapabilities->PtsData.Type],
        cardCapabilities->PtsData.Fl,
        cardCapabilities->PtsData.CLKFrequency,
        cardCapabilities->PtsData.Dl,
        cardCapabilities->PtsData.DataRate,
        cardCapabilities->PtsData.StopBits)
        );

    SmartcardDebug(
        DEBUG_ATR,
        (TEXT("   Calculated timing values:\n      Work etu = %ld micro sec, Guard time = %ld micro sec\n"),
        cardCapabilities->etu,
        cardCapabilities->GT)
        );

#if defined (SMCLIB_NT) && !defined(SMCLIB_TEST)
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock, &irql);
#endif
    if(SmartcardExtension->ReaderCapabilities.CurrentState >= SCARD_PRESENT) {

        if (TA2Present || numProtocols <= 1 && 
            cardCapabilities->Fl == 1 && 
            cardCapabilities->Dl == 1) {

            //
            // If the card supports only one protocol (or T=0 as default)
            // and only standard paramters then PTS selection is not available
            //
            SmartcardExtension->ReaderCapabilities.CurrentState = 
                SCARD_SPECIFIC;

        } else {
            
            SmartcardExtension->ReaderCapabilities.CurrentState = 
                SCARD_NEGOTIABLE;
        }
    }
#if defined (SMCLIB_NT) && !defined(SMCLIB_TEST)
    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock, irql);
#endif


    //
    // Now find protocol specific data
    //

    if (TD[0] == 0) {
        
        cardCapabilities->Protocol.Supported |=
            SCARD_PROTOCOL_T0;

        cardCapabilities->T0.WI = TC[1];

        if (cardCapabilities->PtsData.Dl > 0 && 
            cardCapabilities->PtsData.Dl < 6) {

            cardCapabilities->T0.WT = 1 +
                cardCapabilities->T0.WI *
                960 * cardCapabilities->etu * 
                Pow2((UCHAR) (cardCapabilities->PtsData.Dl - 1));

        } else { 

            cardCapabilities->T0.WT = 1+
                cardCapabilities->T0.WI *
                960 * cardCapabilities->etu /
                Pow2((UCHAR) (cardCapabilities->PtsData.Dl - 1));                   
        } 

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   T=0 Values from ATR:\n      WI = %ld\n"),
            cardCapabilities->T0.WI)
            );
        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   T=0 Timing from ATR:\n      WT = %ld ms\n"),
            cardCapabilities->T0.WT / 1000)
            );
    }

    if (protocolTypes & SCARD_PROTOCOL_T1) {

        for (i = 0; TD[i] != 1 && i < MAXIMUM_ATR_CODES; i++)
            ;
    
        for (; TD[i] == 1 && i < MAXIMUM_ATR_CODES; i++) 
            ;

        if (i == MAXIMUM_ATR_CODES) {

            return STATUS_UNRECOGNIZED_MEDIA;           
        }

        cardCapabilities->Protocol.Supported |= 
            SCARD_PROTOCOL_T1;

        cardCapabilities->T1.IFSC = 
            (TA[i] ? TA[i] : 32);

        cardCapabilities->T1.CWI = 
            ((TB[i] & 0x0f) ? (TB[i] & 0x0f) : T1_CWI_DEFAULT);

        cardCapabilities->T1.BWI = 
            ((TB[i] & 0xf0) >> 4 ? (TB[i] & 0xf0) >> 4 : T1_BWI_DEFAULT);

        cardCapabilities->T1.EDC = 
            (TC[i] & 0x01);

        cardCapabilities->T1.CWT = 1 +
            (Pow2(cardCapabilities->T1.CWI) + 11) * cardCapabilities->etu;

        cardCapabilities->T1.BWT = 1 +
            (((Pow2(cardCapabilities->T1.BWI) * 960l * 372l) / 
                cardCapabilities->PtsData.CLKFrequency) + 
            (11 * cardCapabilities->etu)) * 1000;

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   T=1 Values from ATR:\n      IFSC = %ld, CWI = %ld, BWI = %ld, EDC = %02x\n"),
            cardCapabilities->T1.IFSC,
            cardCapabilities->T1.CWI,
            cardCapabilities->T1.BWI,
            cardCapabilities->T1.EDC)
            );
        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   T=1 Timing from ATR:\n      CWT = %ld ms, BWT = %ld ms\n"),
            cardCapabilities->T1.CWT / 1000,
            cardCapabilities->T1.BWT / 1000)
            );
    }

    if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC) {
        
        if (TA2Present) {

            //
            // TA2 is present in the ATR, so use 
            // the protocol indicated in the ATR
            //
            cardCapabilities->Protocol.Selected = 1 << (TA[1] & 0xf);
            
        } else {
            
            //
            // The card only supports one protocol
            // So make that one protocol the current one to use
            //
            cardCapabilities->Protocol.Selected = 
                cardCapabilities->Protocol.Supported;
        }

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   Mode: Specific %s\n\n"),          
            TA2Present ? TEXT("set by TA(2)") : TEXT(""))
            );

    } else {

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   Mode: Negotiable\n\n"))
            );
    }

    //
    // Every card has to support the 'raw' protocol
    // It enables the usage of cards that have their own protocol defined
    //
    SmartcardExtension->CardCapabilities.Protocol.Supported |= 
        SCARD_PROTOCOL_RAW;

    return STATUS_SUCCESS;
}

#ifdef SMCLIB_TEST

__cdecl
main()
{
    SMARTCARD_EXTENSION SmartcardExtension;
    static ULONG dataRatesSupported[] = { 9909 };

    memset(&SmartcardExtension, 0, sizeof(SmartcardExtension));

    // Gemplus T=0 card
    // memcpy(SmartcardExtension.CardCapabilities.ATR.Buffer, "\x3b\x2a\x00\x80\x65\xa2\x01\x02\x01\x31\x72\xd6\x43", 13);
    // SmartcardExtension.CardCapabilities.ATR.Length = 13;

    // MS card with TA2 set - card won't work due to incorrect parameters
    memcpy(SmartcardExtension.CardCapabilities.ATR.Buffer, "\x3b\x98\x13\x91\x81\x31\x20\x55\x00\x57\x69\x6e\x43\x61\x72\x64\xbb", 17);
    SmartcardExtension.CardCapabilities.ATR.Length = 17;

    SmartcardExtension.ReaderCapabilities.CLKFrequency.Default = 3686;
    SmartcardExtension.ReaderCapabilities.CLKFrequency.Max = 3686;

    SmartcardExtension.ReaderCapabilities.DataRate.Default =
    SmartcardExtension.ReaderCapabilities.DataRate.Max = 9909;

    SmartcardExtension.ReaderCapabilities.DataRatesSupported.List =
       dataRatesSupported;
    SmartcardExtension.ReaderCapabilities.DataRatesSupported.Entries =
       sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);

    SmartcardExtension.ReaderCapabilities.CurrentState = SCARD_PRESENT;

    SmartcardSetDebugLevel(DEBUG_ALL);
    SmartcardUpdateCardCapabilities(&SmartcardExtension);
}

#define DbgPrint printf

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\smclib\vxd\smcvxd.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    smcvxd.h

Abstract:

    Operation system data definitions for the smart card library

Environment:

    Windows9x VxD

Notes:

Revision History:

    - Created June 1997 by Klaus Schutz 

--*/                                         

#ifdef SMCLIB_HEADER

#define WANTVXDWRAPS

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <basedef.h>
#include <vmm.h>
#include <debug.h>
#include <vwin32.h>
#include <winerror.h>
#include <vxdwraps.h>

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

#endif

typedef struct _SMARTCARD_EXTENSION *PSMARTCARD_EXTENSION;

typedef struct _OS_DEP_DATA {

	//
	// Pointer to the smartcard extension
	//
	PSMARTCARD_EXTENSION SmartcardExtension;

	//
	// Current DiocParams to be processed
	//
	PDIOCPARAMETERS CurrentDiocParams;

    //
    // These overlapped data are used for all pending operations
    //
    OVERLAPPED *CurrentOverlappedData;

    //
    // These overlapped data are used for card tracking completion
    //
    OVERLAPPED *NotificationOverlappedData;

    //
    // This is used to synchronize access to the driver
    //
    PVMMMUTEX Mutex;

} OS_DEP_DATA, *POS_DEP_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\smclib\vxd\errmap.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    errmap.h

Abstract:

    defines an array for mapping nt-status codes to win32 error codes

Environment:

    Windows95 / Memphis static VxD

Notes:

    This files stems originally from \nt\private\ntos\rtl\error.h

Revision History:

    - Copied June 1997 by Klaus Schutz 

--*/

LONG CodePairs[] = {

    //
    // These are also defined in WINNT.H, but we are stuck with these
    // mappings.
    //

    STATUS_DATATYPE_MISALIGNMENT, ERROR_NOACCESS,
    STATUS_ACCESS_VIOLATION, ERROR_NOACCESS,

    STATUS_CTL_FILE_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    STATUS_PORT_ALREADY_SET, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_NOT_IMAGE, ERROR_INVALID_PARAMETER,
    STATUS_BAD_WORKING_SET_LIMIT, ERROR_INVALID_PARAMETER,
    STATUS_WORKING_SET_LIMIT_RANGE, ERROR_INVALID_PARAMETER,
    STATUS_INCOMPATIBLE_FILE_MAP, ERROR_INVALID_PARAMETER,
    STATUS_PORT_DISCONNECTED, ERROR_INVALID_HANDLE,
    STATUS_NOT_LOCKED, ERROR_NOT_LOCKED,
    STATUS_NOT_MAPPED_VIEW, ERROR_INVALID_ADDRESS,
    STATUS_UNABLE_TO_FREE_VM, ERROR_INVALID_PARAMETER,
    STATUS_UNABLE_TO_DELETE_SECTION, ERROR_INVALID_PARAMETER,
    STATUS_MORE_PROCESSING_REQUIRED, ERROR_MORE_DATA,
    STATUS_INVALID_CID, ERROR_INVALID_PARAMETER,
    STATUS_STACK_OVERFLOW, ERROR_STACK_OVERFLOW,
    STATUS_BAD_INITIAL_STACK, ERROR_STACK_OVERFLOW,
    STATUS_INVALID_VOLUME_LABEL, ERROR_LABEL_TOO_LONG,
    STATUS_SECTION_NOT_EXTENDED, ERROR_OUTOFMEMORY,
    STATUS_NOT_MAPPED_DATA, ERROR_INVALID_ADDRESS,

    STATUS_INFO_LENGTH_MISMATCH, ERROR_BAD_LENGTH,
    STATUS_INVALID_INFO_CLASS, ERROR_INVALID_PARAMETER,

    STATUS_SUSPEND_COUNT_EXCEEDED, ERROR_SIGNAL_REFUSED,

    STATUS_NOTIFY_ENUM_DIR, ERROR_NOTIFY_ENUM_DIR,

    STATUS_REGISTRY_RECOVERED, ERROR_REGISTRY_RECOVERED,

    STATUS_REGISTRY_IO_FAILED, ERROR_REGISTRY_IO_FAILED,

    STATUS_NOT_REGISTRY_FILE, ERROR_NOT_REGISTRY_FILE,

    STATUS_KEY_DELETED, ERROR_KEY_DELETED,

    STATUS_NO_LOG_SPACE, ERROR_NO_LOG_SPACE,

    STATUS_KEY_HAS_CHILDREN, ERROR_KEY_HAS_CHILDREN,

    STATUS_CHILD_MUST_BE_VOLATILE, ERROR_CHILD_MUST_BE_VOLATILE,

    STATUS_REGISTRY_CORRUPT, ERROR_BADDB,

    STATUS_DLL_NOT_FOUND, ERROR_MOD_NOT_FOUND,

    STATUS_DLL_INIT_FAILED, ERROR_DLL_INIT_FAILED,

    STATUS_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_UNABLE_TO_LOAD, ERROR_BAD_DRIVER,

    STATUS_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,
    STATUS_DRIVER_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_PENDING, ERROR_IO_PENDING,

    STATUS_MORE_ENTRIES, ERROR_MORE_DATA,

    STATUS_INTEGER_OVERFLOW, ERROR_ARITHMETIC_OVERFLOW,

    STATUS_BUFFER_OVERFLOW, ERROR_MORE_DATA,

    STATUS_NO_MORE_FILES, ERROR_NO_MORE_FILES,

    STATUS_NO_INHERITANCE, ERROR_NO_INHERITANCE,

    STATUS_NO_MORE_EAS, ERROR_NO_MORE_ITEMS,
    STATUS_NO_MORE_ENTRIES, ERROR_NO_MORE_ITEMS,
    STATUS_GUIDS_EXHAUSTED, ERROR_NO_MORE_ITEMS,
    STATUS_AGENTS_EXHAUSTED, ERROR_NO_MORE_ITEMS,

    STATUS_UNSUCCESSFUL, ERROR_GEN_FAILURE,

    STATUS_TOO_MANY_LINKS, ERROR_TOO_MANY_LINKS,

    STATUS_NOT_IMPLEMENTED, ERROR_INVALID_FUNCTION,
    STATUS_ILLEGAL_FUNCTION, ERROR_INVALID_FUNCTION,

    STATUS_IN_PAGE_ERROR, ERROR_SWAPERROR,

    STATUS_PAGEFILE_QUOTA, ERROR_PAGEFILE_QUOTA,
    STATUS_COMMITMENT_LIMIT, ERROR_COMMITMENT_LIMIT,
    STATUS_SECTION_TOO_BIG, ERROR_NOT_ENOUGH_MEMORY,

    STATUS_INVALID_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_OBJECT_TYPE_MISMATCH, ERROR_INVALID_HANDLE,
    STATUS_FILE_CLOSED, ERROR_INVALID_HANDLE,
    STATUS_INVALID_PORT_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_HANDLE_NOT_CLOSABLE, ERROR_INVALID_HANDLE,

    STATUS_NOT_COMMITTED, ERROR_INVALID_ADDRESS,
    STATUS_PARTIAL_COPY, ERROR_PARTIAL_COPY,

    STATUS_LPC_REPLY_LOST, ERROR_INTERNAL_ERROR,
    STATUS_INVALID_PARAMETER, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_1, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_2, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_3, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_4, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_5, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_6, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_7, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_8, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_9, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_10, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_11, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_12, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_MIX, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PAGE_PROTECTION, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_PROTECTION, ERROR_INVALID_PARAMETER,

    STATUS_RESOURCE_DATA_NOT_FOUND, ERROR_RESOURCE_DATA_NOT_FOUND,
    STATUS_RESOURCE_TYPE_NOT_FOUND, ERROR_RESOURCE_TYPE_NOT_FOUND,
    STATUS_RESOURCE_NAME_NOT_FOUND, ERROR_RESOURCE_NAME_NOT_FOUND,
    STATUS_RESOURCE_LANG_NOT_FOUND, ERROR_RESOURCE_LANG_NOT_FOUND,

    STATUS_NO_SUCH_DEVICE, ERROR_FILE_NOT_FOUND,
    STATUS_NO_SUCH_FILE, ERROR_FILE_NOT_FOUND,

    STATUS_INVALID_DEVICE_REQUEST, ERROR_INVALID_FUNCTION,

    STATUS_END_OF_FILE, ERROR_HANDLE_EOF,
    STATUS_FILE_FORCED_CLOSED, ERROR_HANDLE_EOF,

    STATUS_WRONG_VOLUME, ERROR_WRONG_DISK,

    STATUS_NO_MEDIA, ERROR_NO_MEDIA_IN_DRIVE,

    STATUS_NO_MEDIA_IN_DEVICE, ERROR_NOT_READY,

    STATUS_VOLUME_DISMOUNTED, ERROR_NOT_READY,

    STATUS_NONEXISTENT_SECTOR, ERROR_SECTOR_NOT_FOUND,

    STATUS_WORKING_SET_QUOTA, ERROR_WORKING_SET_QUOTA,
    STATUS_NO_MEMORY, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_CONFLICTING_ADDRESSES, ERROR_INVALID_ADDRESS,

    STATUS_INVALID_SYSTEM_SERVICE, ERROR_INVALID_FUNCTION,

    STATUS_THREAD_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_PROCESS_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_INVALID_LOCK_SEQUENCE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_VIEW_SIZE, ERROR_ACCESS_DENIED,
    STATUS_ALREADY_COMMITTED, ERROR_ACCESS_DENIED,
    STATUS_ACCESS_DENIED, ERROR_ACCESS_DENIED,
    STATUS_FILE_IS_A_DIRECTORY, ERROR_ACCESS_DENIED,
    STATUS_CANNOT_DELETE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_COMPUTER_NAME, ERROR_INVALID_COMPUTERNAME,
    STATUS_FILE_DELETED, ERROR_ACCESS_DENIED,
    STATUS_DELETE_PENDING, ERROR_ACCESS_DENIED,
    STATUS_PORT_CONNECTION_REFUSED, ERROR_ACCESS_DENIED,

    STATUS_NO_SUCH_PRIVILEGE, ERROR_NO_SUCH_PRIVILEGE,

    STATUS_PRIVILEGE_NOT_HELD, ERROR_PRIVILEGE_NOT_HELD,

    STATUS_CANNOT_IMPERSONATE, ERROR_CANNOT_IMPERSONATE,

    STATUS_LOGON_FAILURE, ERROR_LOGON_FAILURE,

    STATUS_ACCOUNT_RESTRICTION, ERROR_ACCOUNT_RESTRICTION,

    STATUS_INVALID_LOGON_HOURS, ERROR_INVALID_LOGON_HOURS,

    STATUS_INVALID_WORKSTATION, ERROR_INVALID_WORKSTATION,

    STATUS_BUFFER_TOO_SMALL, ERROR_INSUFFICIENT_BUFFER,

    STATUS_UNABLE_TO_DECOMMIT_VM, ERROR_INVALID_ADDRESS,

    STATUS_DISK_CORRUPT_ERROR, ERROR_DISK_CORRUPT,
    STATUS_FT_MISSING_MEMBER, ERROR_IO_DEVICE,
    STATUS_FT_ORPHANING, ERROR_IO_DEVICE,

    STATUS_VARIABLE_NOT_FOUND, ERROR_ENVVAR_NOT_FOUND,

    STATUS_OBJECT_NAME_INVALID, ERROR_INVALID_NAME,

    STATUS_OBJECT_NAME_NOT_FOUND, ERROR_FILE_NOT_FOUND,

    STATUS_OBJECT_NAME_COLLISION, ERROR_ALREADY_EXISTS,

    STATUS_OBJECT_PATH_INVALID, ERROR_BAD_PATHNAME,

    STATUS_OBJECT_PATH_NOT_FOUND, ERROR_PATH_NOT_FOUND,
    STATUS_DFS_EXIT_PATH_FOUND, ERROR_PATH_NOT_FOUND,

    STATUS_OBJECT_PATH_SYNTAX_BAD, ERROR_BAD_PATHNAME,

    STATUS_NAME_TOO_LONG, ERROR_FILENAME_EXCED_RANGE,

    STATUS_DATA_OVERRUN, ERROR_IO_DEVICE,
    STATUS_DATA_LATE_ERROR, ERROR_IO_DEVICE,
    STATUS_DATA_ERROR, ERROR_CRC,

    STATUS_CRC_ERROR, ERROR_CRC,

    STATUS_SHARING_VIOLATION, ERROR_SHARING_VIOLATION,

    STATUS_QUOTA_EXCEEDED, ERROR_NOT_ENOUGH_QUOTA,

    STATUS_MUTANT_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_SEMAPHORE_LIMIT_EXCEEDED, ERROR_TOO_MANY_POSTS,

    STATUS_DISK_FULL, ERROR_DISK_FULL,

    STATUS_LOCK_NOT_GRANTED, ERROR_LOCK_VIOLATION,

    STATUS_FILE_LOCK_CONFLICT, ERROR_LOCK_VIOLATION,  // FIX, FIX - is this right?

    STATUS_NOT_A_DIRECTORY, ERROR_DIRECTORY,          // FIX, FIX - is this right?

    STATUS_UNKNOWN_REVISION, ERROR_UNKNOWN_REVISION,

    STATUS_REVISION_MISMATCH, ERROR_REVISION_MISMATCH,

    STATUS_INVALID_OWNER, ERROR_INVALID_OWNER,

    STATUS_INVALID_PRIMARY_GROUP, ERROR_INVALID_PRIMARY_GROUP,

    STATUS_NO_IMPERSONATION_TOKEN, ERROR_NO_IMPERSONATION_TOKEN,

    STATUS_CANT_DISABLE_MANDATORY, ERROR_CANT_DISABLE_MANDATORY,

    STATUS_NO_LOGON_SERVERS, ERROR_NO_LOGON_SERVERS,
    STATUS_DOMAIN_CONTROLLER_NOT_FOUND, ERROR_DOMAIN_CONTROLLER_NOT_FOUND,

    STATUS_NO_SUCH_LOGON_SESSION, ERROR_NO_SUCH_LOGON_SESSION,

    STATUS_INVALID_ACCOUNT_NAME, ERROR_INVALID_ACCOUNT_NAME,

    STATUS_USER_EXISTS, ERROR_USER_EXISTS,

    STATUS_NO_SUCH_USER, ERROR_NO_SUCH_USER,

    STATUS_GROUP_EXISTS, ERROR_GROUP_EXISTS,

    STATUS_NO_SUCH_GROUP, ERROR_NO_SUCH_GROUP,

    STATUS_SPECIAL_GROUP, ERROR_SPECIAL_GROUP,

    STATUS_MEMBER_IN_GROUP, ERROR_MEMBER_IN_GROUP,

    STATUS_MEMBER_NOT_IN_GROUP, ERROR_MEMBER_NOT_IN_GROUP,

    STATUS_LAST_ADMIN, ERROR_LAST_ADMIN,

    STATUS_WRONG_PASSWORD, ERROR_INVALID_PASSWORD,
    STATUS_WRONG_PASSWORD_CORE, ERROR_INVALID_PASSWORD,

    STATUS_ILL_FORMED_PASSWORD, ERROR_ILL_FORMED_PASSWORD,

    STATUS_PASSWORD_RESTRICTION, ERROR_PASSWORD_RESTRICTION,

    STATUS_PASSWORD_EXPIRED, ERROR_PASSWORD_EXPIRED,
    STATUS_PASSWORD_MUST_CHANGE, ERROR_PASSWORD_MUST_CHANGE,

    STATUS_ACCOUNT_DISABLED, ERROR_ACCOUNT_DISABLED,
    STATUS_ACCOUNT_LOCKED_OUT, ERROR_ACCOUNT_LOCKED_OUT,

    STATUS_NONE_MAPPED, ERROR_NONE_MAPPED,

    STATUS_TOO_MANY_LUIDS_REQUESTED, ERROR_TOO_MANY_LUIDS_REQUESTED,

    STATUS_LUIDS_EXHAUSTED, ERROR_LUIDS_EXHAUSTED,

    STATUS_INVALID_SUB_AUTHORITY, ERROR_INVALID_SUB_AUTHORITY,

    STATUS_INVALID_ACL, ERROR_INVALID_ACL,

    STATUS_INVALID_SID, ERROR_INVALID_SID,

    STATUS_INVALID_SECURITY_DESCR, ERROR_INVALID_SECURITY_DESCR,

    STATUS_PROCEDURE_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_BAD_INITIAL_PC, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_FILE_FOR_SECTION, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_MP_UP_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_NOT_MZ, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_CHECKSUM_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_PROTECT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_LE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_NE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_WIN_16, ERROR_BAD_EXE_FORMAT,

    STATUS_NO_TOKEN, ERROR_NO_TOKEN,

    STATUS_RANGE_NOT_LOCKED, ERROR_NOT_LOCKED,

    STATUS_SERVER_DISABLED, ERROR_SERVER_DISABLED,

    STATUS_SERVER_NOT_DISABLED, ERROR_SERVER_NOT_DISABLED,

    STATUS_INVALID_ID_AUTHORITY, ERROR_INVALID_ID_AUTHORITY,

    STATUS_ALLOTTED_SPACE_EXCEEDED, ERROR_ALLOTTED_SPACE_EXCEEDED,

    STATUS_TOO_MANY_PAGING_FILES, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_INSUFFICIENT_RESOURCES, ERROR_NO_SYSTEM_RESOURCES,

    STATUS_INSUFF_SERVER_RESOURCES, ERROR_NOT_ENOUGH_SERVER_MEMORY,

    STATUS_FILE_INVALID, ERROR_FILE_INVALID,
    STATUS_MAPPED_FILE_SIZE_ZERO, ERROR_FILE_INVALID,

    STATUS_DEVICE_PAPER_EMPTY, ERROR_OUT_OF_PAPER,

    STATUS_DEVICE_POWERED_OFF, ERROR_NOT_READY,
    STATUS_DEVICE_OFF_LINE, ERROR_NOT_READY,

    STATUS_DEVICE_DATA_ERROR, ERROR_CRC,

    STATUS_DEVICE_NOT_READY, ERROR_NOT_READY,
    STATUS_DEVICE_POWER_FAILURE, ERROR_NOT_READY,

    STATUS_DEVICE_BUSY, ERROR_BUSY,                   // FIX, FIX - is there a better choice?

    STATUS_FREE_VM_NOT_AT_BASE, ERROR_INVALID_ADDRESS,
    STATUS_MEMORY_NOT_ALLOCATED, ERROR_INVALID_ADDRESS,

    STATUS_NOT_SAME_DEVICE, ERROR_NOT_SAME_DEVICE,

    STATUS_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,

    STATUS_REMOTE_NOT_LISTENING, ERROR_REM_NOT_LIST,

    STATUS_DUPLICATE_NAME, ERROR_DUP_NAME,

    STATUS_BAD_NETWORK_PATH, ERROR_BAD_NETPATH,

    STATUS_NETWORK_BUSY, ERROR_NETWORK_BUSY,

    STATUS_DEVICE_DOES_NOT_EXIST, ERROR_DEV_NOT_EXIST,

    STATUS_TOO_MANY_COMMANDS, ERROR_TOO_MANY_CMDS,

    STATUS_ADAPTER_HARDWARE_ERROR, ERROR_ADAP_HDW_ERR,

    STATUS_REDIRECTOR_NOT_STARTED, ERROR_PATH_NOT_FOUND,

    STATUS_INVALID_EA_NAME, ERROR_INVALID_EA_NAME,

    STATUS_EA_LIST_INCONSISTENT, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EA_TOO_LARGE, ERROR_EA_LIST_INCONSISTENT,
    STATUS_INVALID_EA_FLAG, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EAS_NOT_SUPPORTED, ERROR_EAS_NOT_SUPPORTED,

    STATUS_FILE_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_EA_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_NONEXISTENT_EA_ENTRY, ERROR_FILE_CORRUPT,
    STATUS_NO_EAS_ON_FILE, ERROR_FILE_CORRUPT,

    STATUS_INVALID_NETWORK_RESPONSE, ERROR_BAD_NET_RESP,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,
    STATUS_UNEXPECTED_NETWORK_ERROR, ERROR_UNEXP_NET_ERR,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,

    STATUS_BAD_REMOTE_ADAPTER, ERROR_BAD_REM_ADAP,

    STATUS_PRINT_QUEUE_FULL, ERROR_PRINTQ_FULL,

    STATUS_NO_SPOOL_SPACE, ERROR_NO_SPOOL_SPACE,

    STATUS_PRINT_CANCELLED, ERROR_PRINT_CANCELLED,

    STATUS_NETWORK_NAME_DELETED, ERROR_NETNAME_DELETED,

    STATUS_NETWORK_ACCESS_DENIED, ERROR_NETWORK_ACCESS_DENIED,

    STATUS_BAD_DEVICE_TYPE, ERROR_BAD_DEV_TYPE,

    STATUS_BAD_NETWORK_NAME, ERROR_BAD_NET_NAME,

    STATUS_TOO_MANY_NAMES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_GUIDS_REQUESTED, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_ADDRESSES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_NODES, ERROR_TOO_MANY_NAMES,

    STATUS_TOO_MANY_SESSIONS, ERROR_TOO_MANY_SESS,

    STATUS_SHARING_PAUSED, ERROR_SHARING_PAUSED,

    STATUS_REQUEST_NOT_ACCEPTED, ERROR_REQ_NOT_ACCEP,

    STATUS_REDIRECTOR_PAUSED, ERROR_REDIR_PAUSED,

    STATUS_NET_WRITE_FAULT, ERROR_NET_WRITE_FAULT,

    STATUS_VIRTUAL_CIRCUIT_CLOSED, ERROR_VC_DISCONNECTED,

    STATUS_INVALID_PIPE_STATE, ERROR_BAD_PIPE,
    STATUS_INVALID_READ_MODE, ERROR_BAD_PIPE,

    STATUS_PIPE_CLOSING, ERROR_NO_DATA,
    STATUS_PIPE_EMPTY, ERROR_NO_DATA,

    STATUS_PIPE_CONNECTED, ERROR_PIPE_CONNECTED,

    STATUS_PIPE_DISCONNECTED, ERROR_PIPE_NOT_CONNECTED,

    STATUS_PIPE_LISTENING, ERROR_PIPE_LISTENING,

    STATUS_PIPE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_INSTANCE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_PIPE_BUSY, ERROR_PIPE_BUSY,

    STATUS_PIPE_BROKEN, ERROR_BROKEN_PIPE,

    STATUS_DIRECTORY_NOT_EMPTY, ERROR_DIR_NOT_EMPTY,

    STATUS_TOO_MANY_OPENED_FILES, ERROR_TOO_MANY_OPEN_FILES,

    STATUS_IO_TIMEOUT, ERROR_SEM_TIMEOUT,

    STATUS_CANCELLED, ERROR_OPERATION_ABORTED,

    STATUS_UNRECOGNIZED_MEDIA, ERROR_UNRECOGNIZED_MEDIA,

    STATUS_INVALID_LEVEL, ERROR_INVALID_LEVEL,

    STATUS_UNRECOGNIZED_VOLUME, ERROR_UNRECOGNIZED_VOLUME,

    STATUS_MEDIA_WRITE_PROTECTED, ERROR_WRITE_PROTECT,
    STATUS_TOO_LATE, ERROR_WRITE_PROTECT,

    STATUS_SUCCESS, NO_ERROR,

    STATUS_FULLSCREEN_MODE, ERROR_FULLSCREEN_MODE,

    STATUS_END_OF_MEDIA, ERROR_END_OF_MEDIA,

    STATUS_EOM_OVERFLOW, ERROR_EOM_OVERFLOW,

    STATUS_BEGINNING_OF_MEDIA, ERROR_BEGINNING_OF_MEDIA,

    STATUS_MEDIA_CHANGED, ERROR_MEDIA_CHANGED,

    STATUS_BUS_RESET, ERROR_BUS_RESET,

    STATUS_FILEMARK_DETECTED, ERROR_FILEMARK_DETECTED,

    STATUS_SETMARK_DETECTED, ERROR_SETMARK_DETECTED,

    STATUS_NO_DATA_DETECTED, ERROR_NO_DATA_DETECTED,

    STATUS_PARTITION_FAILURE, ERROR_PARTITION_FAILURE,

    STATUS_INVALID_BLOCK_LENGTH, ERROR_INVALID_BLOCK_LENGTH,

    STATUS_DEVICE_NOT_PARTITIONED, ERROR_DEVICE_NOT_PARTITIONED,

    STATUS_UNABLE_TO_LOCK_MEDIA, ERROR_UNABLE_TO_LOCK_MEDIA,

    STATUS_UNABLE_TO_UNLOAD_MEDIA, ERROR_UNABLE_TO_UNLOAD_MEDIA,

    STATUS_UNMAPPABLE_CHARACTER, ERROR_NO_UNICODE_TRANSLATION,

    STATUS_NOT_ALL_ASSIGNED, ERROR_NOT_ALL_ASSIGNED,

    STATUS_SOME_NOT_MAPPED, ERROR_SOME_NOT_MAPPED,

    STATUS_NO_QUOTAS_FOR_ACCOUNT, ERROR_NO_QUOTAS_FOR_ACCOUNT,

    STATUS_LOCAL_USER_SESSION_KEY, ERROR_LOCAL_USER_SESSION_KEY,

    STATUS_NULL_LM_PASSWORD, ERROR_NULL_LM_PASSWORD,

    STATUS_BAD_INHERITANCE_ACL, ERROR_BAD_INHERITANCE_ACL,

    STATUS_INVALID_GROUP_ATTRIBUTES, ERROR_INVALID_GROUP_ATTRIBUTES,

    STATUS_BAD_IMPERSONATION_LEVEL, ERROR_BAD_IMPERSONATION_LEVEL,

    STATUS_CANT_OPEN_ANONYMOUS, ERROR_CANT_OPEN_ANONYMOUS,

    STATUS_BAD_VALIDATION_CLASS, ERROR_BAD_VALIDATION_CLASS,

    STATUS_BAD_TOKEN_TYPE, ERROR_BAD_TOKEN_TYPE,

    STATUS_NO_SECURITY_ON_OBJECT, ERROR_NO_SECURITY_ON_OBJECT,

    STATUS_CANT_ACCESS_DOMAIN_INFO, ERROR_CANT_ACCESS_DOMAIN_INFO,

    STATUS_INVALID_SERVER_STATE, ERROR_INVALID_SERVER_STATE,

    STATUS_INVALID_DOMAIN_STATE, ERROR_INVALID_DOMAIN_STATE,

    STATUS_INVALID_DOMAIN_ROLE, ERROR_INVALID_DOMAIN_ROLE,

    STATUS_NO_SUCH_DOMAIN, ERROR_NO_SUCH_DOMAIN,

    STATUS_DOMAIN_EXISTS, ERROR_DOMAIN_EXISTS,

    STATUS_DOMAIN_LIMIT_EXCEEDED, ERROR_DOMAIN_LIMIT_EXCEEDED,

    STATUS_INTERNAL_DB_CORRUPTION, ERROR_INTERNAL_DB_CORRUPTION,

    STATUS_INTERNAL_ERROR, ERROR_INTERNAL_ERROR,

    STATUS_GENERIC_NOT_MAPPED, ERROR_GENERIC_NOT_MAPPED,

    STATUS_BAD_DESCRIPTOR_FORMAT, ERROR_BAD_DESCRIPTOR_FORMAT,

    STATUS_NOT_LOGON_PROCESS, ERROR_NOT_LOGON_PROCESS,

    STATUS_LOGON_SESSION_EXISTS, ERROR_LOGON_SESSION_EXISTS,

    STATUS_NO_SUCH_PACKAGE, ERROR_NO_SUCH_PACKAGE,

    STATUS_BAD_LOGON_SESSION_STATE, ERROR_BAD_LOGON_SESSION_STATE,

    STATUS_LOGON_SESSION_COLLISION, ERROR_LOGON_SESSION_COLLISION,

    STATUS_INVALID_LOGON_TYPE, ERROR_INVALID_LOGON_TYPE,

    STATUS_RXACT_INVALID_STATE, ERROR_RXACT_INVALID_STATE,

    STATUS_RXACT_COMMIT_FAILURE, ERROR_RXACT_COMMIT_FAILURE,

    STATUS_SPECIAL_ACCOUNT, ERROR_SPECIAL_ACCOUNT,

    STATUS_SPECIAL_USER, ERROR_SPECIAL_USER,

    STATUS_MEMBERS_PRIMARY_GROUP, ERROR_MEMBERS_PRIMARY_GROUP,

    STATUS_TOKEN_ALREADY_IN_USE, ERROR_TOKEN_ALREADY_IN_USE,

    STATUS_NO_SUCH_ALIAS, ERROR_NO_SUCH_ALIAS,

    STATUS_MEMBER_NOT_IN_ALIAS, ERROR_MEMBER_NOT_IN_ALIAS,

    STATUS_MEMBER_IN_ALIAS, ERROR_MEMBER_IN_ALIAS,

    STATUS_ALIAS_EXISTS, ERROR_ALIAS_EXISTS,

    STATUS_LOGON_NOT_GRANTED, ERROR_LOGON_NOT_GRANTED,

    STATUS_TOO_MANY_SECRETS, ERROR_TOO_MANY_SECRETS,

    STATUS_SECRET_TOO_LONG, ERROR_SECRET_TOO_LONG,

    STATUS_INTERNAL_DB_ERROR, ERROR_INTERNAL_DB_ERROR,

    STATUS_TOO_MANY_CONTEXT_IDS, ERROR_TOO_MANY_CONTEXT_IDS,

    STATUS_LOGON_TYPE_NOT_GRANTED, ERROR_LOGON_TYPE_NOT_GRANTED,

    STATUS_NT_CROSS_ENCRYPTION_REQUIRED, ERROR_NT_CROSS_ENCRYPTION_REQUIRED,

    STATUS_NO_SUCH_MEMBER, ERROR_NO_SUCH_MEMBER,

    STATUS_INVALID_MEMBER, ERROR_INVALID_MEMBER,

    STATUS_TOO_MANY_SIDS, ERROR_TOO_MANY_SIDS,

    STATUS_LM_CROSS_ENCRYPTION_REQUIRED, ERROR_LM_CROSS_ENCRYPTION_REQUIRED,

    STATUS_MESSAGE_NOT_FOUND, ERROR_MR_MID_NOT_FOUND,

    STATUS_LOCAL_DISCONNECT, ERROR_NETNAME_DELETED,
    STATUS_REMOTE_DISCONNECT, ERROR_NETNAME_DELETED,

    STATUS_REMOTE_RESOURCES, ERROR_REM_NOT_LIST,

    STATUS_LINK_FAILED, ERROR_UNEXP_NET_ERR,
    STATUS_LINK_TIMEOUT, ERROR_UNEXP_NET_ERR,

    STATUS_INVALID_CONNECTION, ERROR_UNEXP_NET_ERR,
    STATUS_INVALID_ADDRESS, ERROR_UNEXP_NET_ERR,

    STATUS_IO_DEVICE_ERROR, ERROR_IO_DEVICE,
    STATUS_DEVICE_PROTOCOL_ERROR, ERROR_IO_DEVICE,
    STATUS_DRIVER_INTERNAL_ERROR, ERROR_IO_DEVICE,

    STATUS_INVALID_DEVICE_STATE, ERROR_BAD_COMMAND,

    STATUS_DEVICE_CONFIGURATION_ERROR, ERROR_INVALID_PARAMETER,

    STATUS_INVALID_USER_BUFFER, ERROR_INVALID_USER_BUFFER,

    STATUS_SERIAL_NO_DEVICE_INITED, ERROR_SERIAL_NO_DEVICE,

    STATUS_SHARED_IRQ_BUSY, ERROR_IRQ_BUSY,

    STATUS_SERIAL_MORE_WRITES, ERROR_MORE_WRITES,

    STATUS_SERIAL_COUNTER_TIMEOUT, ERROR_COUNTER_TIMEOUT,

    STATUS_FLOPPY_ID_MARK_NOT_FOUND, ERROR_FLOPPY_ID_MARK_NOT_FOUND,

    STATUS_FLOPPY_WRONG_CYLINDER, ERROR_FLOPPY_WRONG_CYLINDER,

    STATUS_FLOPPY_UNKNOWN_ERROR, ERROR_FLOPPY_UNKNOWN_ERROR,

    STATUS_FLOPPY_BAD_REGISTERS, ERROR_FLOPPY_BAD_REGISTERS,

    STATUS_DISK_RECALIBRATE_FAILED, ERROR_DISK_RECALIBRATE_FAILED,

    STATUS_DISK_OPERATION_FAILED, ERROR_DISK_OPERATION_FAILED,

    STATUS_DISK_RESET_FAILED, ERROR_DISK_RESET_FAILED,

    STATUS_EVENTLOG_FILE_CORRUPT, ERROR_EVENTLOG_FILE_CORRUPT,

    STATUS_EVENTLOG_CANT_START, ERROR_EVENTLOG_CANT_START,

    STATUS_NETLOGON_NOT_STARTED, ERROR_NETLOGON_NOT_STARTED,

    STATUS_ACCOUNT_EXPIRED, ERROR_ACCOUNT_EXPIRED,

    STATUS_NETWORK_CREDENTIAL_CONFLICT, ERROR_SESSION_CREDENTIAL_CONFLICT,

    STATUS_REMOTE_SESSION_LIMIT, ERROR_REMOTE_SESSION_LIMIT_EXCEEDED,

    STATUS_INVALID_BUFFER_SIZE, ERROR_INVALID_USER_BUFFER,

    STATUS_INVALID_ADDRESS_COMPONENT, ERROR_INVALID_NETNAME,
    STATUS_INVALID_ADDRESS_WILDCARD, ERROR_INVALID_NETNAME,

    STATUS_ADDRESS_ALREADY_EXISTS, ERROR_DUP_NAME,

    STATUS_ADDRESS_CLOSED, ERROR_NETNAME_DELETED,
    STATUS_CONNECTION_DISCONNECTED, ERROR_NETNAME_DELETED,

    STATUS_CONNECTION_RESET, ERROR_NETNAME_DELETED,

    STATUS_TRANSACTION_ABORTED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_TIMED_OUT, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_RELEASE, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_MATCH, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_RESPONDED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_ID, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_TYPE, ERROR_UNEXP_NET_ERR,

    STATUS_NOT_SERVER_SESSION, ERROR_NOT_SUPPORTED,
    STATUS_NOT_CLIENT_SESSION, ERROR_NOT_SUPPORTED,

    STATUS_USER_MAPPED_FILE, ERROR_USER_MAPPED_FILE,

    STATUS_PLUGPLAY_NO_DEVICE, ERROR_SERVICE_DISABLED,

    STATUS_NO_TRUST_LSA_SECRET, ERROR_NO_TRUST_LSA_SECRET,

    STATUS_NO_TRUST_SAM_ACCOUNT, ERROR_NO_TRUST_SAM_ACCOUNT,

    STATUS_TRUSTED_DOMAIN_FAILURE, ERROR_TRUSTED_DOMAIN_FAILURE,

    STATUS_TRUSTED_RELATIONSHIP_FAILURE, ERROR_TRUSTED_RELATIONSHIP_FAILURE,

    STATUS_TRUST_FAILURE, ERROR_TRUST_FAILURE,

    STATUS_LOG_FILE_FULL, ERROR_LOG_FILE_FULL,

    STATUS_EVENTLOG_FILE_CHANGED, ERROR_EVENTLOG_FILE_CHANGED,

    STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT, ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT,

    STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT, ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT,

    STATUS_NOLOGON_SERVER_TRUST_ACCOUNT, ERROR_NOLOGON_SERVER_TRUST_ACCOUNT,

    STATUS_DOMAIN_TRUST_INCONSISTENT, ERROR_DOMAIN_TRUST_INCONSISTENT,

    STATUS_NO_USER_SESSION_KEY, ERROR_NO_USER_SESSION_KEY,

    STATUS_POSSIBLE_DEADLOCK, ERROR_POSSIBLE_DEADLOCK,

    STATUS_IMAGE_ALREADY_LOADED, ERROR_SERVICE_ALREADY_RUNNING,

    STATUS_NO_BROWSER_SERVERS_FOUND, ERROR_NO_BROWSER_SERVERS_FOUND,

    STATUS_MAPPED_ALIGNMENT, ERROR_MAPPED_ALIGNMENT,

    STATUS_CONNECTION_IN_USE, ERROR_DEVICE_IN_USE,

    STATUS_VERIFY_REQUIRED, ERROR_MEDIA_CHANGED,

    STATUS_ALREADY_DISCONNECTED, ERROR_ACTIVE_CONNECTIONS,

    STATUS_CONNECTION_REFUSED, ERROR_CONNECTION_REFUSED,

    STATUS_GRACEFUL_DISCONNECT, ERROR_GRACEFUL_DISCONNECT,

    STATUS_ADDRESS_ALREADY_ASSOCIATED, ERROR_ADDRESS_ALREADY_ASSOCIATED,

    STATUS_ADDRESS_NOT_ASSOCIATED, ERROR_ADDRESS_NOT_ASSOCIATED,

    STATUS_CONNECTION_INVALID, ERROR_CONNECTION_INVALID,

    STATUS_CONNECTION_ACTIVE, ERROR_CONNECTION_ACTIVE,

    STATUS_NETWORK_UNREACHABLE, ERROR_NETWORK_UNREACHABLE,

    STATUS_HOST_UNREACHABLE, ERROR_HOST_UNREACHABLE,

    STATUS_PROTOCOL_UNREACHABLE, ERROR_PROTOCOL_UNREACHABLE,

    STATUS_PORT_UNREACHABLE, ERROR_PORT_UNREACHABLE,

    STATUS_REQUEST_ABORTED, ERROR_REQUEST_ABORTED,

    STATUS_CONNECTION_ABORTED, ERROR_CONNECTION_ABORTED,

    STATUS_CONNECTION_COUNT_LIMIT, ERROR_CONNECTION_COUNT_LIMIT,

    STATUS_PATH_NOT_COVERED, ERROR_HOST_UNREACHABLE,

    STATUS_LOGIN_TIME_RESTRICTION, ERROR_LOGIN_TIME_RESTRICTION,
    STATUS_LOGIN_WKSTA_RESTRICTION, ERROR_LOGIN_WKSTA_RESTRICTION,
    STATUS_LICENSE_QUOTA_EXCEEDED, ERROR_LICENSE_QUOTA_EXCEEDED,

    STATUS_RESOURCE_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_DUPLICATE_OBJECTID, STATUS_DUPLICATE_OBJECTID,
    STATUS_OBJECTID_EXISTS, STATUS_OBJECTID_EXISTS,
    0xffffffff, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\stcusb\makefile.inc ===
stcusblg.h stcusblg.rc msg00001.bin: stcusblg.mc
    mc stcusblg.mc

stcusblg.rc: msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\smclib\vxd\smcvxd.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    smcvxd.c

Abstract:

    This is the Windows 9x specific driver file for the smart card library.
    The smart card library is actually more a library as a driver.
    It contains support functions for smart card driver/reader systems.
    This driver should be loaded through an entry in the registry.

Environment:

    Windows 9x Static VxD

Notes:

Revision History:

    - Created June 1997 by Klaus Schutz

--*/

#define _ISO_TABLES_
#define WIN40SERVICES
#include "..\..\inc\smclib.h"

#define REGISTRY_PATH_LEN 128
static PUCHAR DevicePath = "System\\CurrentControlSet\\Services\\VxD\\Smclib\\Devices";
static BOOLEAN DriverInitialized;

#include "errmap.h"

DWORD
_stdcall
SMCLIB_Init(void)
/*++

Routine Description:

    This function will be called by the Windows Kernel upon init of this driver

Arguments:

    -

Return Value:

    VXD_SUCCESS - This driver loaded successfully
    VXD_FAILURE - Load was not successful

--*/
{
    if (DriverInitialized == FALSE) {

        HANDLE hKey;
        ULONG i;

        DriverInitialized = TRUE;

        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s(SMCLIB_Init): Enter. %s %s\n",
            DRIVER_NAME,
            __DATE__,
            __TIME__)
            );

        //
        // Delete old device names
        //
        if(_RegOpenKey(
            HKEY_LOCAL_MACHINE,
            DevicePath,
            &hKey
            ) != ERROR_SUCCESS) {

            SmartcardDebug(
                DEBUG_ERROR,
                ("%s(SMCLIB_Init): Unable to open registry key\n",
                DRIVER_NAME)
                );

        } else {

            _RegDeleteKey(
                hKey,
                ""
                );

            _RegCloseKey(hKey);
        }

        //
        // Create new device sub-key
        //
        _RegCreateKey(
            HKEY_LOCAL_MACHINE,
            DevicePath,
            &hKey
            );

        _RegCloseKey(hKey);
    }

    return(VXD_SUCCESS);
}

ULONG
SMCLIB_MapNtStatusToWinError(
    NTSTATUS status
    )
/*++

Routine Description:

  Maps a NT status code to a Win32 error value

Arguments:

  status - nt status code to map to a Win32 error value

Return Value:

  Win32 error value

--*/
{
    ULONG i;

    for (i = 0;i < sizeof(CodePairs) / sizeof(CodePairs[0]); i += 2) {

        if (CodePairs[i] == status) {

            return CodePairs[i + 1];

        }
    }

    SmartcardDebug(
        DEBUG_ERROR,
        ("%s(MapNtStatusToWinError): NTSTATUS %lx unknown\n",
        DRIVER_NAME,
        status)
        );

    //
    // We were unable to map the error code
    //
    return ERROR_GEN_FAILURE;
}

void
SMCLIB_Assert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    )
/*++

Routine Description:

    This is a simple assert function that gets called using the ASSERT
    macro. Windows 9x does not offer this functionality

Arguments:

    FailedAssertion - The assertion we tested
    FileName - Yes, this is the name of the source file
    LineNumber - What might this be ?
    Message - An additional message supplied using ASSERTMSG

Return Value:

    -

--*/
{
#ifdef DEBUG

    Debug_Printf(
        "Assertion Failed: %s in %s(%ld)",
        FailedAssertion,
        FileName,
        LineNumber
        );

    if (Message)
        Debug_Printf(" %s",Message);

    Debug_Printf("\n");

#endif
}

//#ifdef _vmm_add_ddb_to_do
BOOL
VXDINLINE
_VMM_Add_DDB(
   struct VxD_Desc_Block *pDeviceDDB
   )
/*++

Routine Description:

    This routine is used to create a new device instance for a driver
    that supports multiple instances - like a serial based driver that
    supports more than one device -

Arguments:

    pDeviceDDB - The DDB struct that is to be added to the system

Return Value:

    TRUE - Yope, it worked
    FALSE - Out of business (May be the device name already exists)

--*/
{
    _asm mov edi, pDeviceDDB
    VxDCall(VMM_Add_DDB)
    _asm {

        mov     eax, 1
        jnc     exit
        mov     eax, 0
exit:
    }
}

BOOL
VXDINLINE
_VMM_Remove_DDB(
   struct VxD_Desc_Block *pDeviceDDB
    )
/*++

Routine Description:

    Removes a DDB (device) that was created using VMM_Add_DDB

Arguments:

    The address of the DDB to remove

Return Value:

    TRUE - OK, DDB removed otherwise FALSE

--*/
{
    _asm mov edi, pDeviceDDB
    VxDCall(VMM_Remove_DDB)
    _asm {

        mov     eax, 1
        jnc     exit
        mov     eax, 0
exit:
    }
}
//#endif

PVMMDDB
SMCLIB_VxD_CreateDevice(
    char *Device,
    void (*ControlProc)(void)
    )
/*++

Routine Description:

    Creates a new device. This routine allows a driver to create additional devices.

Arguments:

    Device - Name of the device to be created. At most 8 characters
    ControlProc - Address of the VxD control procedure. (NOT the DeviceIoControl function!)

Return Value:

    The newly created DDB if successful or NULL otherwise

--*/
{
    PVMMDDB pDDB;
    UCHAR DeviceName[9];

    ASSERT(Device != NULL);
    ASSERT(strlen(Device) <= 8);
    ASSERT(ControlProc != NULL);

    if (strlen(Device) > 8) {

        return NULL;
    }

    _Sprintf(DeviceName, "%-8s", Device);

    //
    // Allocate space for the VxD description block
    //
    pDDB = (PVMMDDB) _HeapAllocate(
        sizeof(struct VxD_Desc_Block),
        HEAPZEROINIT
        );

    if (pDDB)
    {
        pDDB->DDB_SDK_Version         = DDK_VERSION;
        pDDB->DDB_Req_Device_Number   = UNDEFINED_DEVICE_ID;
        pDDB->DDB_Dev_Major_Version   = 1;
        pDDB->DDB_Dev_Minor_Version   = 0;
        memcpy(pDDB->DDB_Name, DeviceName, 8);
        pDDB->DDB_Init_Order          = UNDEFINED_INIT_ORDER;
        pDDB->DDB_Control_Proc        = (ULONG) ControlProc;
        pDDB->DDB_Reference_Data      = 0;
        pDDB->DDB_Prev                = 'Prev';
        pDDB->DDB_Size                = sizeof(struct VxD_Desc_Block);
        pDDB->DDB_Reserved1           = 'Rsv1';
        pDDB->DDB_Reserved2           = 'Rsv2';
        pDDB->DDB_Reserved3           = 'Rsv3';

        //
        // Now create the DDB
        //
        if (!_VMM_Add_DDB(pDDB)) {

            _HeapFree(pDDB, 0);
            return NULL;
        }
    }

    return pDDB;
}

BOOL
SMCLIB_VxD_DeleteDevice(
    PVMMDDB pDDB
    )
/*++

Routine Description:

    Deleted a device. This function can be used to delete
    a device that was created using VxD_CreateDevice

Arguments:

    pDDB - The DDB to be deleted

Return Value:

    TRUE - device successfully deleted
    FALSE - device not deleted

--*/
{
    ASSERT(pDDB != NULL);

    if(pDDB == NULL || !_VMM_Remove_DDB(pDDB)) {

        return FALSE;
    }

    _HeapFree(pDDB, 0);

    return TRUE;
}

DWORD
_stdcall
VxD_PageLock(
   DWORD lpMem,
   DWORD cbSize
   )
/*++

Routine Description:

  This function lock the page

Arguments:

  lpMem  - pointer to the datablock which has to be locked
  cbSize - length of the datablock

Return Value:

  - pointer to the locked datablock

--*/
{
    DWORD LinPageNum;
   DWORD LinOffset;
   DWORD nPages;
   DWORD dwRet;

    LinOffset = lpMem & 0xfff; // page offset of memory to map
    LinPageNum = lpMem >> 12;  // generate page number

    // Calculate # of pages to map globally
    nPages = ((lpMem + cbSize) >> 12) - LinPageNum + 1;

    //
    // Return global mapping of passed in pointer, as this new pointer
    // is how the memory must be accessed out of context.
    //
   dwRet = _LinPageLock(LinPageNum, nPages, PAGEMAPGLOBAL | PAGEMARKDIRTY);

   ASSERT(dwRet != 0);

    SmartcardDebug(
        DEBUG_ERROR,
        ("%s!VxD_PageLock: LinPageNum = %lx, nPages = %lx, dwRet = %lx\n",
        DRIVER_NAME,
        LinPageNum,
        nPages,
        dwRet)
        );

    return (dwRet + LinOffset);
}

void
_stdcall
VxD_PageUnlock(
   DWORD lpMem,
   DWORD cbSize
   )
/*++

Routine Description:

    This function unlocks a datablock

Arguments:

    lpMem - pointer to the datablock which has to be unlocked
    cbSize - length of the datablock

Return Value:

    -

--*/
{
    DWORD LinPageNum;
   DWORD nPages;
   DWORD dwRet;

    LinPageNum = lpMem >> 12;
    nPages = ((lpMem + cbSize) >> 12) - LinPageNum + 1;

    SmartcardDebug(
        DEBUG_ERROR,
        ("%s!VxD_PageUnlock: LinPageNum = %lx, nPages = %lx\n",
        DRIVER_NAME,
        LinPageNum,
        nPages)
        );

    // Free globally mapped memory
    dwRet = _LinPageUnlock(LinPageNum, nPages, PAGEMAPGLOBAL);

   ASSERT(dwRet != 0);
}

void
SMCLIB_SmartcardCompleteCardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine calls i/o completion for the pending
    card tracking operation. It also unlocks the previously
    locked memory that was used for the overlapped strucutre

Arguments:

    SmartcardExtension

Return Value:

    -

--*/
{
    if (SmartcardExtension->OsData->NotificationOverlappedData) {

        DWORD O_Internal = SmartcardExtension->OsData->NotificationOverlappedData->O_Internal;

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardCompleteCardTracking): Completing %lx\n",
            DRIVER_NAME,
         SmartcardExtension->OsData->NotificationOverlappedData)
            );

       //
       // set number of bytes returned to 0
       //
       SmartcardExtension->OsData->NotificationOverlappedData->O_InternalHigh = 0;

        _asm mov ebx, O_Internal

        VxDCall(VWIN32_DIOCCompletionRoutine)

       _HeapFree(
          SmartcardExtension->OsData->NotificationOverlappedData,
          0
          );

        SmartcardExtension->OsData->NotificationOverlappedData = NULL;
    }
}

void
SMCLIB_SmartcardCompleteRequest(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine calls i/o completion for a pending
    io operation. It also unlocks the previously
    locked memory that was used for the overlapped structure

Arguments:

    SmartcardExtension

Return Value:

    -

--*/
{
    DWORD O_Internal = SmartcardExtension->OsData->CurrentOverlappedData->O_Internal;

    _asm mov ebx, O_Internal

    VxDCall(VWIN32_DIOCCompletionRoutine)

   VxD_PageUnlock(
      (DWORD) SmartcardExtension->OsData->CurrentOverlappedData,
      sizeof(OVERLAPPED)
      );

   VxD_PageUnlock(
      (DWORD) SmartcardExtension->IoRequest.RequestBuffer,
        SmartcardExtension->IoRequest.RequestBufferLength
      );

   VxD_PageUnlock(
      (DWORD) SmartcardExtension->IoRequest.ReplyBuffer,
        SmartcardExtension->IoRequest.ReplyBufferLength
      );

    SmartcardExtension->OsData->CurrentDiocParams = NULL;
}

NTSTATUS
SMCLIB_SmartcardCreateLink(
   PUCHAR LinkName,
   PUCHAR DeviceName
   )
/*++

Routine Description:

    This routine creates a symbolic link name for the given device name.
    It means it creates a 'STRING-value' in the registry ..VxD\smclib\devices
    like SCReader[0-9] = DeviceName.
    The smart card resource manager uses these entries in order to figure out
    what smart card devices are currently running.
    We do this because we don't have the ability to create a dynamic device
    name like we can do in Windows NT.

Arguments:

   LinkName - receives the created link name
   DeviceName  - the device name for which the link should be created

Return Value:

    NTSTATUS

--*/
{
    PUCHAR Value;
    ULONG i;
    HANDLE hKey;

    if (DriverInitialized == FALSE) {

        SMCLIB_Init();
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardCreateLink): Enter\n",
        DRIVER_NAME)
        );

    ASSERT(LinkName != NULL);
    ASSERT(DeviceName != NULL);
    ASSERT(strlen(DeviceName) <= 12);

    if (LinkName == NULL) {

        return STATUS_INVALID_PARAMETER_1;
    }

    if (DeviceName == NULL) {

        return STATUS_INVALID_PARAMETER_2;
    }

    //
    // Open the key where the device names are stored
    //
    if(_RegOpenKey(
        HKEY_LOCAL_MACHINE,
        DevicePath,
        &hKey
        ) != ERROR_SUCCESS) {

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Allocate a buffer for enumeration of the registry
    //
    Value = (PUCHAR) _HeapAllocate(REGISTRY_PATH_LEN, 0);

    if (Value == NULL) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardCreateLink): Allocation failed\n",
            DRIVER_NAME)
            );

      return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now find a free device name
    //
    for (i = 0; i < MAXIMUM_SMARTCARD_READERS ; i++) {

        _Sprintf(
            Value,
            "SCReader%d",
            i
            );

        //
        // Check for existence of the key
        //

        if(_RegQueryValueEx(
            hKey,
            Value,
            NULL,
            NULL,
            NULL,
            NULL
            ) != ERROR_SUCCESS) {

            break;
        }
    }

    //
    // Free the buffer since we don't need it anymore
    //
    _HeapFree(Value, 0);

    if (i >= MAXIMUM_SMARTCARD_READERS) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardCreateLink): Can't create link: Too many readers\n",
            DRIVER_NAME)
            );

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Create the link name...
    //
    _Sprintf(
        LinkName,
        "SCReader%d",
        i
        );

    //
    // ...and store it in the registry
    //
    _RegSetValueEx(
        hKey,
        LinkName,
        NULL,
        REG_SZ,
        DeviceName,
        strlen(DeviceName)
        );

    _RegCloseKey(hKey);

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s(SmartcardCreateLink): Link %s created for Driver %s\n",
        DRIVER_NAME,
        LinkName,
        DeviceName)
        );

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardCreateLink): Exit\n",
        DRIVER_NAME)
        );

    return STATUS_SUCCESS;
}

NTSTATUS
SMCLIB_SmartcardDeleteLink(
   PUCHAR LinkName
   )
/*++

Routine Description:

   Deletes the link previously created with SmartcardCreateLink()
    This routine deletes the symbolic link name that is stored in the
    registry. A driver ususally calls this function upon unload.

Arguments:

    LinkName - The link that is to be deleted

Return Value:

    NTSTATUS

--*/
{
    HANDLE hKey;
    NTSTATUS status;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardDeleteLink): Enter\n",
        DRIVER_NAME)
        );

    ASSERT(LinkName);
    ASSERT(strlen(LinkName) <= 10);

    //
    // Open the key where the device names are stored
    //
    if(_RegOpenKey(
        HKEY_LOCAL_MACHINE,
        DevicePath,
        &hKey
        ) != ERROR_SUCCESS) {

        return STATUS_UNSUCCESSFUL;
    }

    if(_RegDeleteValue(
        hKey,
        LinkName
        ) == ERROR_SUCCESS) {

        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s(SmartcardDeleteLink): Link %s deleted\n",
            DRIVER_NAME,
            LinkName)
            );

        status = STATUS_SUCCESS;

    } else {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardDeleteLink): Can't delete link %s\n",
            DRIVER_NAME,
            LinkName)
            );

        status = STATUS_UNSUCCESSFUL;
    }

    _RegCloseKey(hKey);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardDeleteLink): Exit",
        DRIVER_NAME)
        );

    return status;
}

NTSTATUS
SMCLIB_SmartcardInitialize(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

   This function allocated the send and receive buffers for smart card
   data. It also sets the pointer to 2 ISO tables to make them accessible
   to the driver

Arguments:

    SmartcardExtension

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardInitialize): Enter - Version %lx, %s %s\n",
        DRIVER_NAME,
        SMCLIB_VERSION,
        __DATE__,
        __TIME__)
        );

    ASSERT(SmartcardExtension != NULL);
    ASSERT(SmartcardExtension->OsData == NULL);

    if (SmartcardExtension == NULL) {

        return STATUS_INVALID_PARAMETER;
    }

    if (SmartcardExtension->Version < SMCLIB_VERSION_REQUIRED) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardInitialize): Invalid Version in SMARTCARD_EXTENSION. Must be %lx\n",
            DRIVER_NAME,
            SMCLIB_VERSION)
            );

        return STATUS_UNSUCCESSFUL;
    }

   if (SmartcardExtension->SmartcardRequest.BufferSize < MIN_BUFFER_SIZE) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardInitialize): WARNING: SmartcardRequest.BufferSize (%ld) < MIN_BUFFER_SIZE (%ld)\n",
            DRIVER_NAME,
            SmartcardExtension->SmartcardRequest.BufferSize,
            MIN_BUFFER_SIZE)
            );

      SmartcardExtension->SmartcardRequest.BufferSize = MIN_BUFFER_SIZE;
      }

   if (SmartcardExtension->SmartcardReply.BufferSize < MIN_BUFFER_SIZE) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardInitialize): WARNING: SmartcardReply.BufferSize (%ld) < MIN_BUFFER_SIZE (%ld)\n",
            DRIVER_NAME,
            SmartcardExtension->SmartcardReply.BufferSize,
            MIN_BUFFER_SIZE)
            );

      SmartcardExtension->SmartcardReply.BufferSize = MIN_BUFFER_SIZE;
      }

   SmartcardExtension->SmartcardRequest.Buffer = _HeapAllocate(
      SmartcardExtension->SmartcardRequest.BufferSize,
        0
      );

   SmartcardExtension->SmartcardReply.Buffer = _HeapAllocate(
      SmartcardExtension->SmartcardReply.BufferSize,
        0
      );

   SmartcardExtension->OsData = _HeapAllocate(
      sizeof(OS_DEP_DATA),
        0
      );

    //
    // Check if one of the above allocations failed
    //
    if (SmartcardExtension->SmartcardRequest.Buffer == NULL ||
        SmartcardExtension->SmartcardReply.Buffer == NULL ||
        SmartcardExtension->OsData == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;

        if (SmartcardExtension->SmartcardRequest.Buffer) {

            _HeapFree(SmartcardExtension->SmartcardRequest.Buffer, 0);
        }

        if (SmartcardExtension->SmartcardReply.Buffer) {

            _HeapFree(SmartcardExtension->SmartcardReply.Buffer, 0);
        }

        if (SmartcardExtension->OsData == NULL) {

            _HeapFree(SmartcardExtension->OsData, 0);
        }
    }

    if (status != STATUS_SUCCESS) {

        return status;
    }

    memset(SmartcardExtension->OsData, 0, sizeof(OS_DEP_DATA));

    //
    // Create mutex that is used to synch access to the driver
    //
    SmartcardExtension->OsData->Mutex = _CreateMutex(0, 0);

   //
   // Make the 2 ISO tables accessible to the driver
   //
   SmartcardExtension->CardCapabilities.ClockRateConversion =
      &ClockRateConversion[0];

   SmartcardExtension->CardCapabilities.BitRateAdjustment =
      &BitRateAdjustment[0];

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardInitialize): Exit\n",
        DRIVER_NAME)
        );

   return status;
}

VOID
SMCLIB_SmartcardExit(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

    This routine frees the send and receive buffer.
   It is usually called when the driver unloads.

Arguments:

    SmartcardExtension

Return Value:

    NTSTATUS

--*/
{
    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardExit): Enter\n",
        DRIVER_NAME)
        );

   if (SmartcardExtension->SmartcardRequest.Buffer) {

      _HeapFree(SmartcardExtension->SmartcardRequest.Buffer, 0);
   }

   if (SmartcardExtension->SmartcardReply.Buffer) {

      _HeapFree(SmartcardExtension->SmartcardReply.Buffer, 0);
   }

   if (SmartcardExtension->OsData) {

      _HeapFree(SmartcardExtension->OsData, 0);
   }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardExit): Exit\n",
        DRIVER_NAME)
        );
}

VOID
SMCLIB_SmartcardLogError(
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:
Return Value:

--*/

{
    SmartcardDebug(
        DEBUG_ERROR,
        ("%s(SmartcardLogError): Not yet implemented\n",
        DRIVER_NAME)
        );
}


NTSTATUS
SMCLIB_SmartcardDeviceControl(
    PSMARTCARD_EXTENSION SmartcardExtension,
    DIOCPARAMETERS *lpDiocParams
    )
/*++

Routine Description:

    The routine is the general device control dispatch function for VxD drivers.

Arguments:

    SmartcardExtension  - The pointer to the smart card datae
    lpDiocParams - struct containing the caller parameter

Return Value:

   NTSTATUS

--*/

{
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT(SmartcardExtension != NULL);

    if (SmartcardExtension == NULL) {

        return STATUS_INVALID_PARAMETER_1;
    }

    ASSERT(lpDiocParams != NULL);

    if (lpDiocParams == NULL) {

        return STATUS_INVALID_PARAMETER_2;
    }

    ASSERT(lpDiocParams->lpoOverlapped != 0);

    if (lpDiocParams->lpoOverlapped == 0) {

        return STATUS_INVALID_PARAMETER;
    }

    // Check the version that the driver requires
    ASSERT(SmartcardExtension->Version >= SMCLIB_VERSION_REQUIRED);

    if (SmartcardExtension->Version < SMCLIB_VERSION_REQUIRED) {

        return STATUS_INVALID_PARAMETER;
    }

    // Synchronize access to the driver
    _EnterMutex(
        SmartcardExtension->OsData->Mutex,
        BLOCK_SVC_INTS | BLOCK_THREAD_IDLE
        );

    if (status == STATUS_SUCCESS) {

        SmartcardDebug(
            DEBUG_IOCTL,
            ("SMCLIB(SmartcardDeviceControl): Ioctl = %s, DIOCP = %lx\n",
            MapIoControlCodeToString(lpDiocParams->dwIoControlCode),
            lpDiocParams)
            );

        // Return if device is busy
        if (SmartcardExtension->OsData->CurrentDiocParams != NULL) {

           SmartcardDebug(
               DEBUG_IOCTL,
               ("%s(SmartcardDeviceControl): Device is busy\n",
                DRIVER_NAME)
               );

            status = STATUS_DEVICE_BUSY;
        }
    }

    if (status == STATUS_SUCCESS) {

        if (lpDiocParams->lpcbBytesReturned) {

            // Default number of bytes returned
            *(PULONG) lpDiocParams->lpcbBytesReturned = 0;
        }

        switch (lpDiocParams->dwIoControlCode) {

            //
            // We have to check for _IS_ABSENT and _IS_PRESENT first,
            // since these are (the only allowed) asynchronous requests
            //
            case IOCTL_SMARTCARD_IS_ABSENT:
            case IOCTL_SMARTCARD_IS_PRESENT:

             if (SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] == NULL) {

                status = STATUS_NOT_SUPPORTED;
                break;
             }

                // Now check if the driver is already processing notification
                if (SmartcardExtension->OsData->NotificationOverlappedData != NULL) {

                    status = STATUS_DEVICE_BUSY;
                    break;
                }

                //
                // Lock the overlapped structure that has to be notified
                // about the completion into memory
                //
                  SmartcardExtension->OsData->NotificationOverlappedData =
               _HeapAllocate( sizeof(OVERLAPPED), HEAPZEROINIT );

            if (SmartcardExtension->OsData->NotificationOverlappedData == NULL) {

               return STATUS_INSUFFICIENT_RESOURCES;
            }

            memcpy(
               SmartcardExtension->OsData->NotificationOverlappedData,
               (PVOID) lpDiocParams->lpoOverlapped,
               sizeof(OVERLAPPED)
               );

                if (lpDiocParams->dwIoControlCode == IOCTL_SMARTCARD_IS_ABSENT) {

                 //
                 // If the card is already (or still) absent, we can return immediatly.
                 // Otherwise we must statrt event tracking.
                 //
                 if (SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT) {

                    status = SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING](
                       SmartcardExtension
                       );
                 }

                } else {

                 //
                 // If the card is already (or still) present, we can return immediatly.
                 // Otherwise we must statrt event tracking.
                 //
                 if (SmartcardExtension->ReaderCapabilities.CurrentState <= SCARD_ABSENT) {

                    status = SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING](
                       SmartcardExtension
                       );
                 }
                }

                if (status != STATUS_PENDING) {

                    //
                    // Unlock the overlapped structure again since the driver
                    // doesn't need it anymore
                    //
                    _HeapFree(
                      SmartcardExtension->OsData->NotificationOverlappedData,
                      0
                      );

                    SmartcardExtension->OsData->NotificationOverlappedData = NULL;
                }
             break;

            default:
               // Check if buffers are properly allocated
               ASSERT(SmartcardExtension->SmartcardRequest.Buffer);
               ASSERT(SmartcardExtension->SmartcardReply.Buffer);

               SmartcardExtension->OsData->CurrentDiocParams = lpDiocParams;

               // Get major io control code
               SmartcardExtension->MajorIoControlCode =
                    lpDiocParams->dwIoControlCode;

               if (lpDiocParams->lpvInBuffer) {

                  //
                  // Transfer minor io control code, even if it doesn't make sense for
                  // this particular major code
                  //
                  SmartcardExtension->MinorIoControlCode =
                     *(PULONG) (lpDiocParams->lpvInBuffer);

                   // Lock memory and save pointer to and length of request buffer
                   SmartcardExtension->IoRequest.RequestBuffer = (PUCHAR) VxD_PageLock(
                      lpDiocParams->lpvInBuffer,
                        lpDiocParams->cbInBuffer
                        );

                   SmartcardExtension->IoRequest.RequestBufferLength =
                        lpDiocParams->cbInBuffer;

               } else {

                    SmartcardExtension->IoRequest.RequestBuffer = NULL;
                   SmartcardExtension->IoRequest.RequestBufferLength = 0;
                }

                if (lpDiocParams->lpvOutBuffer) {

                   // Lock memory an save pointer to and length of reply buffer
                   SmartcardExtension->IoRequest.ReplyBuffer = (PUCHAR) VxD_PageLock(
                      lpDiocParams->lpvOutBuffer,
                        lpDiocParams->cbOutBuffer
                        );

                   SmartcardExtension->IoRequest.ReplyBufferLength =
                        lpDiocParams->cbOutBuffer;

                } else {

                    SmartcardExtension->IoRequest.ReplyBuffer = NULL;
                   SmartcardExtension->IoRequest.ReplyBufferLength = 0;
                }

                // Lock overlapped struct into memory
                SmartcardExtension->OsData->CurrentOverlappedData =
                    (OVERLAPPED *) VxD_PageLock(
                  lpDiocParams->lpoOverlapped,
                  sizeof(OVERLAPPED)
                  );

                if (SmartcardExtension->OsData->CurrentOverlappedData) {

                   //
                   // Pointer to variable that receives the actual number
                   // of bytes returned. Since we don't know yet if the
                    // driver will return STATUS_PENDING, we use the
                    // overlapped data to store the number of bytes returned
                   //
                   SmartcardExtension->IoRequest.Information =
                        &SmartcardExtension->OsData->CurrentOverlappedData->O_InternalHigh;

                    // Set the default number of bytes returned to 0
                    *SmartcardExtension->IoRequest.Information = 0;

                    // Process the ioctl-request
                    status = SmartcardDeviceIoControl(SmartcardExtension);

                    if (status != STATUS_PENDING) {

                        if(lpDiocParams->lpcbBytesReturned) {

                           *(PULONG) (lpDiocParams->lpcbBytesReturned) =
                                *(SmartcardExtension->IoRequest.Information);
                        }

                        //
                        // The driver satisfied the call immediatly. So we don't use the overlapped
                        // data to return information to the caller. We can transfer the 'number
                        // of bytes returned' directly
                        //
                        if (SmartcardExtension->OsData->CurrentOverlappedData) {

                            // Unlock all memory
                           VxD_PageUnlock(
                              (DWORD) SmartcardExtension->OsData->CurrentOverlappedData,
                              sizeof(OVERLAPPED)
                              );
                        }

                        if (SmartcardExtension->IoRequest.RequestBuffer) {

                           VxD_PageUnlock(
                              (DWORD) SmartcardExtension->IoRequest.RequestBuffer,
                                SmartcardExtension->IoRequest.RequestBufferLength
                              );
                        }

                        if (SmartcardExtension->IoRequest.ReplyBuffer) {

                           VxD_PageUnlock(
                              (DWORD) SmartcardExtension->IoRequest.ReplyBuffer,
                                SmartcardExtension->IoRequest.ReplyBufferLength
                              );
                        }

                        //
                        // If the devcie is not busy, we can set the
                        // current parameters back to NULL
                        //
                        SmartcardExtension->OsData->CurrentDiocParams = NULL;
                    }

                } else {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
             break;
        }
    }

    SmartcardDebug(
        DEBUG_IOCTL,
        ("SMCLIB(SmartcardDeviceControl): Exit\n")
        );

    _LeaveMutex(SmartcardExtension->OsData->Mutex);

    return status;
}



DWORD
_stdcall
SMCLIB_DeviceIoControl(
    DWORD  dwService,
    DWORD  dwDDB,
    DWORD  hDevice,
    DIOCPARAMETERS *lpDIOCParms
    )
{
    return 0;
}

SMCLIB_Get_Version()
{
    return SMCLIB_VERSION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\stcusb\common.h ===
/*++

Copyright (c) 1999 SCM Microsystems, Inc.

Module Name:

    common.h

Abstract:

   Constants, structures, macro etc.. for STC USB WDM


Revision History:

   PP       01/20/1999  Initial Version

--*/


#if !defined( __COMMON_H__ )
#define __COMMON_H__

#include <ntstatus.h>
#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <usb100.h>
#include <DEVIOCTL.H>

#define DRIVER_NAME "STCUSB"

#include "SMCLIB.h"
#include "WINSMCRD.h"

//
// Constants -----------------------------------------------------------------
//

#define SMARTCARD_POOL_TAG '4SCS'

#define STCUSB_VENDOR_NAME             "SCM Microsystems"
#define STCUSB_PRODUCT_NAME               "STCUSB"
#define MAX_READ_REGISTER_BUFFER_SIZE     18

#define STCUSB_MAX_DEVICE              16
#define USB_WRITE_RETRIES              2

#define IOCTL_WRITE_STC_REGISTER       SCARD_CTL_CODE(0x800)
#define IOCTL_READ_STC_REGISTER           SCARD_CTL_CODE(0x801)
#define IOCTL_WRITE_STC_DATA           SCARD_CTL_CODE(0x802)
#define IOCTL_READ_STC_DATA               SCARD_CTL_CODE(0x803)

#define POLLING_PERIOD                 500

#define CLA_IDX                        0
#define INS_IDX                        1
#define P1_IDX                      2
#define P2_IDX                      3
#define P3_IDX                      4

#define ISO_OUT                        TRUE
#define ISO_IN                      !ISO_OUT


#define  NAD_IDX                       0x00
#define PCB_IDX                        0x01
#define LEN_IDX                        0x02
#define DATA_IDX                    0x03
#define PROLOGUE_LEN                0x03
#define EPILOGUE_LEN                0x01

#define OSC                         16000
#define FREQ                        3580
#define CYC_TO_MS( cyc )               ((ULONG)( cyc / FREQ ))

// register addresses
#define ADR_ETULENGTH15                0x00
#define ADR_ETULENGTH7                 0x01
#define ADR_CGT8                    0x02
#define ADR_CGT7                    0x03
#define ADR_CWT31                   0x04
#define ADR_CWT23                   0x05
#define ADR_CWT15                   0x06
#define ADR_CWT7                    0x07
#define  ADR_BGT8                   0x08
#define ADR_BGT7                    0x09
#define ADR_BWT31                   0x0A
#define ADR_BWT23                   0x0B
#define ADR_BWT15                   0x0C
#define ADR_BWT7                    0x0D
#define ADR_TCON                    0x0E
#define ADR_UART_CONTROL               0x0F
#define ADR_FIFO_CONFIG                0x10
#define ADR_INT_CONTROL                0x11
#define ADR_INT_STATUS                 0x12
#define ADR_DATA                    0x13
#define ADR_IO_CONFIG                  0x14
#define ADR_SC_CONTROL                 0x15
#define ADR_CLOCK_CONTROL              0x16


// clock control register
#define M_CKE                       0x01
#define M_OEN                       0x02

// ETU length register
#define M_ETU_RST                   0x80
#define M_DIV                       0x30
#define M_DIV1                      0x20
#define M_DIV0                      0x10
#define M_ETUH                      0x0F

#define M_ETUL                      0xFF

// CGT length register
#define M_CGTH                      0x01
#define M_CGTL                      0XFF

// BGT length register
#define M_BGTH                      0x01
#define M_BGTL                      0xFF

// CWT register
#define M_CWT4                      0xFF
#define M_CWT3                      0xFF
#define M_CWT2                      0xFF
#define M_CWT1                      0xFF

// TCON register
#define M_MGT                       0x80
#define M_MWT                       0x40
#define M_WTR                       0x04
#define M_GT                        0x02
#define M_WT                        0x01

// UART control register
#define M_UEN                       0x40
#define M_UART_RST                     0x20
#define M_CONV                      0x10
#define  M_TS                       0x08
#define  M_PE                       0x04
#define  M_R                           0x03

// FIFO config register
#define M_RFP                       0x80
#define M_LD                        0x0F

// INT control register
#define  M_SSL                      0x20
#define M_DRM                       0x10
#define M_DSM                       0x08
#define M_WTE                       0x04
#define M_SIM                       0x02
#define M_MEM                       0x01
#define M_DRM_MEM                   0x11

// INT status register
#define M_FNE                       0x80
#define M_FE                        0x40
#define M_OE                        0x20
#define M_DR                        0x10
#define M_TRE                       0x08
#define M_WTOVF                        0x04
#define M_SENSE                        0x02
#define M_MOV                       0x01

// SMART card interface
#define M_ALT1                      0x20
#define M_ALT2                      0x10
#define M_ALT0                      0x08
#define M_SDE                       0x04
#define M_SL                        0x02
#define M_SD                        0x01

// SMART card control register
#define M_IO                        0x80
#define M_VCE                       0x40
#define M_SC_RST                    0x20
#define M_SCE                       0x10
#define M_SCK                       0x08
#define M_C8                        0x04
#define M_C4                        0x02
#define M_VPE                       0x01


// Nad
#define HOST_TO_STC1                0x12
#define HOST_TO_STC2                0x52
#define HOST_TO_ICC1                0x02
#define HOST_TO_ICC2                0x42
#define STC1_TO_HOST                0x21
#define STC2_TO_HOST                0x25
#define ICC1_TO_HOST                0x20
#define ICC2_TO_HOST                0x24

// PCB
#define PCB                         0x00


#define CLA_READ_REGISTER              0x00
#define INS_READ_REGISTER              0xB0

#define CLA_WRITE_REGISTER             0x00
#define INS_WRITE_REGISTER             0xD0

#define CLA_READ_FIRMWARE_REVISION        0x00
#define INS_READ_FIRMWARE_REVISION        0xB1

#define PCB_DEFAULT                    0x00
#define TLV_BUFFER_SIZE                0x20
#define ATR_SIZE                    0x40  // TS + 32 + SW + PROLOGUE + EPILOGUE...

#define MAX_T1_BLOCK_SIZE              270

// ATR interface byte coding in TS
#define TAx                         0x01
#define TBx                         0x02
#define TCx                         0x04
#define TDx                         0x08


#define FREQ_DIV     1  // 3,58 MHz XTAL -> SC Clock = 3.58MHz
//#define FREQ_DIV   0x08  /* 30MHz XTAL -> SC Clock = 3.75MHz */

#define PROTOCOL_TO                    0
#define PROTOCOL_T1                    1
#define PROTOCOL_T14                14
#define PROTOCOL_T15                15

#define STC_READ_TIMEOUT               1000

//  max. of communication errors while polling the device
#define ERROR_COUNTER_TRESHOLD     5

//
// Define the facility codes
//
#define FACILITY_SCARD                   0x10
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: STCUSB_NO_DEVICE_FOUND
//
// MessageText:
//
//  No USB smart card reader found in the system. 
//
#define STCUSB_NO_DEVICE_FOUND           ((NTSTATUS)0xC0100001L)

//
// MessageId: STCUSB_CANT_INITIALIZE_READER
//
// MessageText:
//
//  The attached reader is not working properly.
//
#define STCUSB_CANT_INITIALIZE_READER    ((NTSTATUS)0xC0100002L)

//
// MessageId: STCUSB_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Insufficient system resources to start device.
//
#define STCUSB_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC0100003L)

//
// MessageId: STCUSB_ERROR_CLAIM_RESOURCES
//
// MessageText:
//
//  Resources can not be claimed or an resource conflict exists.
//
#define STCUSB_ERROR_CLAIM_RESOURCES     ((NTSTATUS)0xC0100006L)

//
// MessageId: STCUSB_NO_MEMORY
//
// MessageText:
//
//  The system does not have enough memory.
//
#define STCUSB_NO_MEMORY                 ((NTSTATUS)0xC0040007L)

//
// MessageId: STCUSB_TOO_MANY_ERRORS
//
// MessageText:
//
//  The error treshold while detecting a smart card was reached.
//
#define STCUSB_TOO_MANY_ERRORS           ((NTSTATUS)0xC0040008L)

//
// MessageId: STCUSB_USB_MSG
//
// MessageText:
//
//  SmartCard USB Driver : %2.
//
#define STCUSB_USB_MSG                   ((NTSTATUS)0x40100010L)

//
// MessageId: STCUSB_USB_ERROR
//
// MessageText:
//
//  SmartCard USB Driver : %2.
//
#define STCUSB_USB_ERROR                 ((NTSTATUS)0xC0100011L)

//
// MessageId: STCUSB_TIMEOUT
//
// MessageText:
//
//  SmartCard Reader TIMEOUT : %2.
//
#define STCUSB_TIMEOUT                   ((NTSTATUS)0xC00000B5L)

//
// Macros --------------------------------------------------------------------
//
#define SysCompareMemory( p1, p2, Len )         ( RtlCompareMemory( p1,p2, Len ) != Len )
#define SysCopyMemory( pDest, pSrc, Len )    RtlCopyMemory( pDest, pSrc, Len )
#define SysFillMemory( pDest, Value, Len )      RtlFillMemory( pDest, Len, Value )


//
// Structures ----------------------------------------------------------------
//
typedef struct _DEVICE_EXTENSION
{
   // The PDO that we are attached to
    PDEVICE_OBJECT AttachedPDO;

    // Our PnP device name
   UNICODE_STRING DeviceName;

    // Current number of io-requests
    LONG IoCount;

    // Used to access IoCount;
    KSPIN_LOCK SpinLock;

     // Used to signal that the device has been removed
    //KEVENT ReaderRemoved;

    // Used to signal that the reader is able to process reqeusts
    KEVENT ReaderStarted;

    // Used to signal the the reader has been closed
    LONG ReaderOpen;

    // Used to synchonize the polling thread
    KMUTEX   hMutex;

    // Used to keep track of the current power state the reader is in
    LONG PowerState;

   // configuration handle for the configuration the device is currently in use
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;

    // ptr to the USB device descriptor for this device
   PUSB_DEVICE_DESCRIPTOR DeviceDescriptor;

    // we support up to one interface
   PUSBD_INTERFACE_INFORMATION Interface;

   // poll thread relevant data
   KEVENT       FinishPollThread;
   KEVENT       PollThreadStopped;
   PIO_WORKITEM PollWorkItem;

   SMARTCARD_EXTENSION  SmartcardExtension;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef enum _READER_POWER_STATE {
    PowerReaderUnspecified = 0,
    PowerReaderWorking,
    PowerReaderOff
} READER_POWER_STATE, *PREADER_POWER_STATE;

typedef struct _READER_EXTENSION {

   UCHAR Device;

   // Software revision ID of the firmware.
   UCHAR FirmwareMajor, FirmwareMinor;

    BOOLEAN CardPresent;

    // Current reader power state.
    READER_POWER_STATE ReaderPowerState;

   // read timeout in ms
   ULONG       ReadTimeout;

   PDEVICE_OBJECT DeviceObject;

   UCHAR ucReadBuffer[MIN_BUFFER_SIZE];

   ULONG ulReadBufferLen;

   // counter for communication errors while polling the reader
   ULONG ErrorCounter;

      // pre-allocated buffer to perform read/write in extension 
   PUCHAR pExtBuffer;		//	added CB_09/02/01

   // pre-allocated URB in extension to be used in UsbRead and UsbWrite CB_09/02/01
   PURB   pUrb;				//	added CB_09/02/01

	// Priority of the KeThread.... to support low PC ressources
   LONG		Chosen_Priority;


} READER_EXTENSION, *PREADER_EXTENSION;

#define SIZEOF_READER_EXTENSION     ( sizeof( READER_EXTENSION ))

typedef struct _STC_REGISTER
{
   UCHAR Register;
   UCHAR Size;
   ULONG Value;

} STC_REGISTER, *PSTC_REGISTER;

//
// wrapper ------------------------------------------------------------------
//


#define IFReadSTCRegister  UsbReadSTCRegister
#define IFReadSTCData      UsbReadSTCData
#define IFWriteSTCRegister UsbWriteSTCRegister
#define IFWriteSTCData     UsbWriteSTCData

#endif   // __COMMON_H__

// ------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\stcusb\stccb.h ===
/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

    stccb.h

Abstract:

	Constants & access function prototypes for callback functions


Revision History:

	PP			12/18/1998	Initial Version

--*/
#if !defined( __STC_CB_H__ )
#define __STC_CB_H__

//
//	Prototypes ----------------------------------------------------------------
//


NTSTATUS
CBCardPower(
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBSetProtocol(		
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBTransmit(
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBCardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBUpdateCardState(
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBGenericIOCTL(
	PSMARTCARD_EXTENSION SmartcardExtension);

//
//	LOCAL PROTOTYPES (not part of the callback handler interface )
//
NTSTATUS
CBT0Transmit(		
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBT1Transmit(
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBRawTransmit(		
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBSynchronizeSTC(
	PSMARTCARD_EXTENSION SmartcardExtension );


#endif // __STC_CB_H__

//	------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\stcusb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by stcusb.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\stcusb\stccb.c ===
/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

   StcCb.c

Abstract:

   Declaration of callback functions - WDM Version


Revision History:


   PP 1.01     01/19/1998
   PP 1.00     12/18/1998     Initial Version

--*/


// Include

#include "common.h"
#include "stccmd.h"
#include "stccb.h"
#include "stcusbnt.h"
#include "usbcom.h"

NTSTATUS
CBCardPower(
   PSMARTCARD_EXTENSION SmartcardExtension)
/*++

CBCardPower:
   callback handler for SMCLIB RDF_CARD_POWER

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_BUFFER_TOO_SMALL

--*/
{
   NTSTATUS       NTStatus = STATUS_SUCCESS;
   UCHAR          ATRBuffer[ ATR_SIZE ];
   ULONG          Command,
                  ATRLength;
   PREADER_EXTENSION ReaderExtension;
   KIRQL          irql;

   SmartcardDebug( DEBUG_TRACE, ("%s!CBCardPower Enter\n",DRIVER_NAME ));

   ReaderExtension = SmartcardExtension->ReaderExtension;


   // discard old ATR
   SysFillMemory( SmartcardExtension->CardCapabilities.ATR.Buffer, 0x00, 0x40 );

   SmartcardExtension->CardCapabilities.ATR.Length = 0;
   SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

   Command = SmartcardExtension->MinorIoControlCode;

   switch ( Command )
   {
      case SCARD_WARM_RESET:

         // if the card was not powerd, fall through to cold reset
         KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                           &irql);

         if( SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_SWALLOWED )
         {

            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

            // reset the card
            ATRLength = ATR_SIZE;
            NTStatus = STCReset(
               ReaderExtension,
               0,             // not used: ReaderExtension->Device,
               TRUE,          // warm reset
               ATRBuffer,
               &ATRLength);

            break;
         } else {
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);
         }
         // warm reset not possible because card was not powerd

      case SCARD_COLD_RESET:
         // reset the card
         ATRLength = ATR_SIZE;
         NTStatus = STCReset(
            ReaderExtension,
            0,                // not used: ReaderExtension->Device,
            FALSE,               // cold reset
            ATRBuffer,
            &ATRLength);
         break;

      case SCARD_POWER_DOWN:

         // discard old card status
         ATRLength = 0;
         NTStatus = STCPowerOff( ReaderExtension );

         if(NTStatus == STATUS_SUCCESS)
         {
            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);
            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_PRESENT;

            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);
         }
         break;
   }

   // finish the request
   if( NTStatus == STATUS_SUCCESS )
   {

      // update all neccessary data if an ATR was received
      if( ATRLength >= 2 )
      {
         // copy ATR to user buffer
         if( ATRLength <= SmartcardExtension->IoRequest.ReplyBufferLength )
         {
            SysCopyMemory(
               SmartcardExtension->IoRequest.ReplyBuffer,
               ATRBuffer,
               ATRLength);
            *SmartcardExtension->IoRequest.Information = ATRLength;
         }
         else
         {
            NTStatus = STATUS_BUFFER_TOO_SMALL;
         }

         // copy ATR to card capability buffer
         if( ATRLength <= MAXIMUM_ATR_LENGTH )
         {
            SysCopyMemory(
               SmartcardExtension->CardCapabilities.ATR.Buffer,
               ATRBuffer,
               ATRLength);

            SmartcardExtension->CardCapabilities.ATR.Length = ( UCHAR )ATRLength;

            // let the lib update the card capabilities
            NTStatus = SmartcardUpdateCardCapabilities( SmartcardExtension );

         }
         else
         {
            NTStatus = STATUS_BUFFER_TOO_SMALL;
         }
         if( NTStatus == STATUS_SUCCESS )
         {
            // set the stc registers
            CBSynchronizeSTC( SmartcardExtension );

            // set read timeout
            if( SmartcardExtension->CardCapabilities.Protocol.Selected == SCARD_PROTOCOL_T1 )
            {
               ReaderExtension->ReadTimeout =
                  (ULONG) (SmartcardExtension->CardCapabilities.T1.BWT  / 1000);

            }
            else
            {
               ReaderExtension->ReadTimeout =
                  (ULONG) (SmartcardExtension->CardCapabilities.T0.WT / 1000);
               if(ReaderExtension->ReadTimeout < 50)
               {
                  ReaderExtension->ReadTimeout = 50; //  50 ms minimum timeout
               }
            }
         }
      }
   }


   SmartcardDebug( DEBUG_TRACE,( "%s!CBCardPower Exit: %X\n", DRIVER_NAME,NTStatus ));
   return( NTStatus );
}

NTSTATUS
CBSetProtocol(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

CBSetProtocol:
   callback handler for SMCLIB RDF_SET_PROTOCOL

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_BUFFER_TOO_SMALL
   STATUS_INVALID_DEVICE_STATE
   STATUS_INVALID_DEVICE_REQUEST

--*/
{
   NTSTATUS       NTStatus = STATUS_PENDING;
   UCHAR          PTSRequest[5],
                  PTSReply[5];
   ULONG          NewProtocol;
   PREADER_EXTENSION ReaderExtension;
   KIRQL          irql;

   SmartcardDebug( DEBUG_TRACE, ("%s!CBSetProtocol Enter\n",DRIVER_NAME ));

   ReaderExtension = SmartcardExtension->ReaderExtension;
   NewProtocol    = SmartcardExtension->MinorIoControlCode;

   // check if the card is already in specific state

   KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                     &irql);
   if( ( SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC )  &&
      ( SmartcardExtension->CardCapabilities.Protocol.Selected & NewProtocol ))
   {
      NTStatus = STATUS_SUCCESS;
   }

   KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                     irql);

   // protocol supported?
   if( !( SmartcardExtension->CardCapabilities.Protocol.Supported & NewProtocol ) ||
      !( SmartcardExtension->ReaderCapabilities.SupportedProtocols & NewProtocol ))
   {
      NTStatus = STATUS_INVALID_DEVICE_REQUEST;
   }

   // send PTS
   while( NTStatus == STATUS_PENDING )
   {
      // set initial character of PTS
      PTSRequest[0] = 0xFF;

      // set the format character
      if(( NewProtocol & SCARD_PROTOCOL_T1 )&&
         (SmartcardExtension->CardCapabilities.Protocol.Supported & SCARD_PROTOCOL_T1 ))
      {
         PTSRequest[1] = 0x11;
         SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T1;
      }
      else
      {
         PTSRequest[1] = 0x10;
         SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;
      }

      // PTS1 codes Fl and Dl
      PTSRequest[2] =
         SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
         SmartcardExtension->CardCapabilities.PtsData.Dl;

      // check character
      PTSRequest[3] = PTSRequest[0] ^ PTSRequest[1] ^ PTSRequest[2];

      // write PTSRequest
      NTStatus = IFWriteSTCData( ReaderExtension, PTSRequest, 4 );

      // get response
      if( NTStatus == STATUS_SUCCESS )
      {
         NTStatus = IFReadSTCData( ReaderExtension, PTSReply, 4 );

         if(( NTStatus == STATUS_SUCCESS ) && !SysCompareMemory( PTSRequest, PTSReply, 4))
         {
            // set the stc registers
            SmartcardExtension->CardCapabilities.Dl =
               SmartcardExtension->CardCapabilities.PtsData.Dl;
            SmartcardExtension->CardCapabilities.Fl =
               SmartcardExtension->CardCapabilities.PtsData.Fl;

            CBSynchronizeSTC( SmartcardExtension );

            // the card replied correctly to the PTS-request
            break;
         }
      }

      //
      // The card did either NOT reply or it replied incorrectly
      // so try default values
      //
      if( SmartcardExtension->CardCapabilities.PtsData.Type != PTS_TYPE_DEFAULT )
      {
         SmartcardExtension->CardCapabilities.PtsData.Type  = PTS_TYPE_DEFAULT;
         SmartcardExtension->MinorIoControlCode          = SCARD_COLD_RESET;
         NTStatus = CBCardPower( SmartcardExtension );

         if( NTStatus == STATUS_SUCCESS )
         {
            NTStatus = STATUS_PENDING;
         }
         else
         {
            NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
         }
      }
   }

   if( NTStatus == STATUS_TIMEOUT )
   {
      NTStatus = STATUS_IO_TIMEOUT;
   }

   if( NTStatus == STATUS_SUCCESS )
   {
      // card replied correctly to the PTS request
      if( SmartcardExtension->CardCapabilities.Protocol.Selected & SCARD_PROTOCOL_T1 )
      {
         ReaderExtension->ReadTimeout = SmartcardExtension->CardCapabilities.T1.BWT / 1000;
      }
      else
      {
         ULONG ClockRateFactor =
            SmartcardExtension->CardCapabilities.ClockRateConversion[SmartcardExtension->CardCapabilities.PtsData.Fl].F;

         // check for RFU value, and replace by default value
         if( !ClockRateFactor )
            ClockRateFactor = 372;

         ReaderExtension->ReadTimeout = 960 
            * SmartcardExtension->CardCapabilities.T0.WI 
            * ClockRateFactor
            / SmartcardExtension->CardCapabilities.PtsData.CLKFrequency;

         // We need to have a minimum timeout anyway
         if(ReaderExtension->ReadTimeout <50)
         {
            ReaderExtension->ReadTimeout =50; // 50 ms minimum timeout
         }
      }

      // indicate that the card is in specific mode
      KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                        &irql);
      SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
      KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                        irql);

      // return the selected protocol to the caller
      *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = SmartcardExtension->CardCapabilities.Protocol.Selected;
      *SmartcardExtension->IoRequest.Information = sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);
   }
   else
   {
      SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
      *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = 0;
      *SmartcardExtension->IoRequest.Information = 0;
   }

   SmartcardDebug( DEBUG_TRACE, ("%d!CBSetProtocol: Exit %X\n",DRIVER_NAME, NTStatus ));

   return( NTStatus );
}
NTSTATUS
CBGenericIOCTL(
   PSMARTCARD_EXTENSION SmartcardExtension)
/*++

Description:
   Performs generic callbacks to the reader

Arguments:
   SmartcardExtension   context of the call

Return Value:
   STATUS_SUCCESS

--*/
{
   NTSTATUS          NTStatus;
   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!CBGenericIOCTL: Enter\n",
      DRIVER_NAME));

   //
   // get pointer to current IRP stack location
   //
   //
   // assume error
   //
   NTStatus = STATUS_INVALID_DEVICE_REQUEST;


   //
   // dispatch IOCTL
   //
   switch( SmartcardExtension->MajorIoControlCode )
   {



      case IOCTL_WRITE_STC_REGISTER:


         NTStatus = IFWriteSTCRegister(
            SmartcardExtension->ReaderExtension,
            *(SmartcardExtension->IoRequest.RequestBuffer),             // Address
            (ULONG)(*(SmartcardExtension->IoRequest.RequestBuffer + 1)),   // Size
            SmartcardExtension->IoRequest.RequestBuffer + 2);           // Data

         *SmartcardExtension->IoRequest.Information = 1;
         if(NTStatus == STATUS_SUCCESS)
         {
            *(SmartcardExtension->IoRequest.ReplyBuffer) = 0;
         }
         else
         {
            *(SmartcardExtension->IoRequest.ReplyBuffer) = 1;
         }

         break;

      case IOCTL_READ_STC_REGISTER:

         NTStatus = IFReadSTCRegister(
            SmartcardExtension->ReaderExtension,
            *(SmartcardExtension->IoRequest.RequestBuffer),             // Address
            (ULONG)(*(SmartcardExtension->IoRequest.RequestBuffer + 1)),   // Size
            SmartcardExtension->IoRequest.ReplyBuffer);                 // Data

         if(NTStatus ==STATUS_SUCCESS)
         {
            *SmartcardExtension->IoRequest.Information =
               (ULONG)(*(SmartcardExtension->IoRequest.RequestBuffer + 1));
         }
         else
         {
            SmartcardExtension->IoRequest.Information = 0;
         }

         break;



      case IOCTL_WRITE_STC_DATA:


         NTStatus = IFWriteSTCData(
            SmartcardExtension->ReaderExtension,
            SmartcardExtension->IoRequest.RequestBuffer + 1,            // Data
            (ULONG)(*(SmartcardExtension->IoRequest.RequestBuffer)));      // Size

         *SmartcardExtension->IoRequest.Information = 1;
         if(NTStatus == STATUS_SUCCESS)
         {
            *(SmartcardExtension->IoRequest.ReplyBuffer) = 0;
         }
         else
         {
            *(SmartcardExtension->IoRequest.ReplyBuffer) = 1;
         }

         break;

      case IOCTL_READ_STC_DATA:

         NTStatus = IFReadSTCData(
            SmartcardExtension->ReaderExtension,
            SmartcardExtension->IoRequest.ReplyBuffer,                  // Data
            (ULONG)(*(SmartcardExtension->IoRequest.RequestBuffer)));      // Size

         if(NTStatus ==STATUS_SUCCESS)
         {
            *SmartcardExtension->IoRequest.Information =
               (ULONG)(*(SmartcardExtension->IoRequest.RequestBuffer));
         }
         else
         {
            SmartcardExtension->IoRequest.Information = 0;
         }

         break;

      default:
         break;
   }


   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!CBGenericIOCTL: Exit\n",
      DRIVER_NAME));

   return( NTStatus );
}



NTSTATUS
CBTransmit(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

CBTransmit:
   callback handler for SMCLIB RDF_TRANSMIT

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_INVALID_DEVICE_REQUEST

--*/
{
   NTSTATUS  NTStatus = STATUS_SUCCESS;

   SmartcardDebug( DEBUG_TRACE, ("%s!CBTransmit Enter\n",DRIVER_NAME ));

   // dispatch on the selected protocol
   switch( SmartcardExtension->CardCapabilities.Protocol.Selected )
   {
      case SCARD_PROTOCOL_T0:
         NTStatus = CBT0Transmit( SmartcardExtension );
         break;

      case SCARD_PROTOCOL_T1:
         NTStatus = CBT1Transmit( SmartcardExtension );
         break;

      case SCARD_PROTOCOL_RAW:
         NTStatus = CBRawTransmit( SmartcardExtension );
         break;

      default:
         NTStatus = STATUS_INVALID_DEVICE_REQUEST;
         break;
   }

   SmartcardDebug( DEBUG_TRACE, ("%s!CBTransmit Exit: %X\n",DRIVER_NAME, NTStatus ));

   return( NTStatus );
}



NTSTATUS
T0_ExchangeData(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pRequest,
   ULONG          RequestLen,
   PUCHAR            pReply,
   PULONG            pReplyLen)
/*++

Routine Description:
   T=0 management

Arguments:
   ReaderExtension   Context of the call
   pRequest    Request buffer
   RequestLen     Request buffer length
   pReply         Reply buffer
   pReplyLen      Reply buffer length


Return Value:
   STATUS_SUCCESS
   Status returned by IFReadSTCData or IFWriteSTCData

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   BOOLEAN     Direction;
   UCHAR    Ins,
            Pcb = 0;
   ULONG    Len,
            DataIdx;
   KPRIORITY    PreviousPriority;
   BOOLEAN     PriorityBoost = FALSE;


   if (ReaderExtension->Chosen_Priority > KeQueryPriorityThread(KeGetCurrentThread())) {

       SmartcardDebug(
          DEBUG_TRACE,
          ( "%s!T0_ExchangeData: Setting priority: 0x%x\n",
          DRIVER_NAME,
          ReaderExtension->Chosen_Priority));

       PriorityBoost = TRUE;

       PreviousPriority = KeSetPriorityThread(KeGetCurrentThread(),
                                              ReaderExtension->Chosen_Priority);

   }

   // get direction
   Ins = pRequest[ INS_IDX ] & 0xFE;
   Len   = pRequest[ P3_IDX ];

   if( RequestLen == 5 )
   {
      Direction   = ISO_OUT;
      DataIdx     = 0;
      // For an ISO OUT command Len=0 means that the host expect an
      // 256 byte answer
      if( !Len )
      {
         Len = 0x100;
      }
      // Add 2 for SW1 SW2
      Len+=2;
   }
   else
   {
      Direction   = ISO_IN;
      DataIdx     = 5;
   }

   // send header CLASS,INS,P1,P2,P3
   NTStatus = IFWriteSTCData( ReaderExtension, pRequest, 5 );

   if( NTStatus == STATUS_SUCCESS )
   {
      NTStatus = STATUS_MORE_PROCESSING_REQUIRED;
   }

   while( NTStatus == STATUS_MORE_PROCESSING_REQUIRED )
   {
      // PCB reading
      NTStatus = IFReadSTCData( ReaderExtension, &Pcb, 1 );

      if( NTStatus == STATUS_SUCCESS )
      {
         if( Pcb == 0x60 )
         {
            // null byte?
            NTStatus = STATUS_MORE_PROCESSING_REQUIRED;
            continue;
         }
         else if( ( Pcb & 0xFE ) == Ins )
         {
            // transfer all
            if( Direction == ISO_IN )
            {
               // write remaining data
               NTStatus = IFWriteSTCData( ReaderExtension, pRequest + DataIdx, Len );
               if( NTStatus == STATUS_SUCCESS )
               {
                  // if all data successful written the status word is expected
                  NTStatus = STATUS_MORE_PROCESSING_REQUIRED;
                  Direction   = ISO_OUT;
                  DataIdx     = 0;
                  Len         = 2;
               }
            }
            else
            {
               // read remaining data
               NTStatus = IFReadSTCData( ReaderExtension, pReply + DataIdx, Len );

               DataIdx += Len;
            }
         }
         else if( (( Pcb & 0xFE ) ^ Ins ) == 0xFE )
         {
            // transfer next
            if( Direction == ISO_IN )
            {
               // write next

               NTStatus = IFWriteSTCData( ReaderExtension, pRequest + DataIdx, 1 );

               if( NTStatus == STATUS_SUCCESS )
               {
                  DataIdx++;

                  // if all data successful written the status word is expected
                  if( --Len == 0 )
                  {
                     Direction   = ISO_OUT;
                     DataIdx     = 0;
                     Len         = 2;
                  }
                  NTStatus = STATUS_MORE_PROCESSING_REQUIRED;
               }
            }
            else
            {
               // read next
               NTStatus = IFReadSTCData( ReaderExtension, pReply + DataIdx, 1 );


               if( NTStatus == STATUS_SUCCESS )
               {
                  NTStatus = STATUS_MORE_PROCESSING_REQUIRED;
                  if (Len == 0) {
                      // we should have be done reading by now.
                      NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
                      break;

                  }

                  Len--;
                  DataIdx++;
               }
            }
         }
         else if( (( Pcb & 0x60 ) == 0x60 ) || (( Pcb & 0x90 ) == 0x90 ) )
         {
            if( Direction == ISO_IN )
            {
               Direction   = ISO_OUT;
               DataIdx     = 0;
            }

            // SW1
            *pReply  = Pcb;

            // read SW2 and leave

            NTStatus = IFReadSTCData( ReaderExtension, &Pcb, 1 );

            *(pReply + 1)  = Pcb;
            DataIdx        += 2;
         }
         else
         {
            NTStatus = STATUS_UNSUCCESSFUL;
         }
      }
   }

   if(( NTStatus == STATUS_SUCCESS ) && ( pReplyLen != NULL ))
   {
      *pReplyLen = DataIdx;
   }

   if (PriorityBoost) {

       
       SmartcardDebug(
          DEBUG_TRACE,
          ( "%s!T0_ExchangeData: Setting priority: 0x%x\n",
          DRIVER_NAME,
          PreviousPriority));

       PreviousPriority = KeSetPriorityThread(KeGetCurrentThread(),
                                              PreviousPriority);

   }

   return( NTStatus );
}


NTSTATUS
CBT0Transmit(
   PSMARTCARD_EXTENSION SmartcardExtension)
/*++

CBT0Transmit:
   finishes the callback RDF_TRANSMIT for the T0 protocol

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS            NTStatus = STATUS_SUCCESS;

   SmartcardDebug( DEBUG_TRACE, ("%s!CBT0Transmit Enter\n",DRIVER_NAME ));

   SmartcardExtension->SmartcardRequest.BufferLength = 0;

   // let the lib setup the T=1 APDU & check for errors
   NTStatus = SmartcardT0Request( SmartcardExtension );

   if( NTStatus == STATUS_SUCCESS )
   {
      NTStatus = T0_ExchangeData(
         SmartcardExtension->ReaderExtension,
         SmartcardExtension->SmartcardRequest.Buffer,
         SmartcardExtension->SmartcardRequest.BufferLength,
         SmartcardExtension->SmartcardReply.Buffer,
         &SmartcardExtension->SmartcardReply.BufferLength);

      if( NTStatus == STATUS_SUCCESS )
      {
         // let the lib evaluate the result & tansfer the data
         NTStatus = SmartcardT0Reply( SmartcardExtension );
      }
   }

   SmartcardDebug( DEBUG_TRACE,("%s!CBT0Transmit Exit: %X\n",DRIVER_NAME, NTStatus ));

    return( NTStatus );
}





NTSTATUS
CBT1Transmit(
   PSMARTCARD_EXTENSION SmartcardExtension)
/*++

CBT1Transmit:
   finishes the callback RDF_TRANSMIT for the T1 protocol

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS   NTStatus = STATUS_SUCCESS;
    KPRIORITY   PreviousPriority;
    BOOLEAN     PriorityBoost = FALSE;
   SmartcardDebug( DEBUG_TRACE, ("%s!CBT1Transmit Enter\n",DRIVER_NAME ));

   // smclib workaround
   *(PULONG)&SmartcardExtension->IoRequest.ReplyBuffer[0] = 0x02;
   *(PULONG)&SmartcardExtension->IoRequest.ReplyBuffer[4] = sizeof( SCARD_IO_REQUEST );

   // use the lib support to construct the T=1 packets
   do {
      // no header for the T=1 protocol
      SmartcardExtension->SmartcardRequest.BufferLength = 0;

      SmartcardExtension->T1.NAD = 0;

      // let the lib setup the T=1 APDU & check for errors
      NTStatus = SmartcardT1Request( SmartcardExtension );
      if( NTStatus == STATUS_SUCCESS )
      {
         if (SmartcardExtension->ReaderExtension->Chosen_Priority > KeQueryPriorityThread(KeGetCurrentThread())) {

             SmartcardDebug(
                DEBUG_TRACE,
                ( "%s!CBT1Transmit: Setting priority: 0x%x\n",
                DRIVER_NAME,
                SmartcardExtension->ReaderExtension->Chosen_Priority));

             PriorityBoost = TRUE;
             PreviousPriority = KeSetPriorityThread(KeGetCurrentThread(),
                                                    SmartcardExtension->ReaderExtension->Chosen_Priority);

         }
         // send command (don't calculate LRC because CRC may be used!)
         NTStatus = IFWriteSTCData(
            SmartcardExtension->ReaderExtension,
            SmartcardExtension->SmartcardRequest.Buffer,
            SmartcardExtension->SmartcardRequest.BufferLength);

         if (PriorityBoost) {

             SmartcardDebug(
                DEBUG_TRACE,
                ( "%s!CBT1Transmit: Setting priority: 0x%x\n",
                DRIVER_NAME,
                PreviousPriority));
             PriorityBoost = FALSE;

             PreviousPriority = KeSetPriorityThread(KeGetCurrentThread(),
                                                    PreviousPriority);

         }


         // extend read timeout if the card issued a WTX request
         if (SmartcardExtension->T1.Wtx)
         {
            SmartcardExtension->ReaderExtension->ReadTimeout = 
               ( SmartcardExtension->T1.Wtx * 
               SmartcardExtension->CardCapabilities.T1.BWT + 999L )/
               1000L;
         }
         else
         {
            // restore timeout
            SmartcardExtension->ReaderExtension->ReadTimeout = 
               (ULONG) (SmartcardExtension->CardCapabilities.T1.BWT  / 1000);
         }

         // get response
         SmartcardExtension->SmartcardReply.BufferLength = 0;

         if( NTStatus == STATUS_SUCCESS )
         {

            if (SmartcardExtension->ReaderExtension->Chosen_Priority > KeQueryPriorityThread(KeGetCurrentThread())) {

                SmartcardDebug(
                   DEBUG_TRACE,
                   ( "%s!CBT1Transmit: Setting priority: 0x%x\n",
                   DRIVER_NAME,
                   SmartcardExtension->ReaderExtension->Chosen_Priority));
                PriorityBoost = TRUE;

               PreviousPriority = KeSetPriorityThread(KeGetCurrentThread(),
                                                      SmartcardExtension->ReaderExtension->Chosen_Priority);

            }

            NTStatus = IFReadSTCData(
               SmartcardExtension->ReaderExtension,
               SmartcardExtension->SmartcardReply.Buffer,
               3);

            if( NTStatus == STATUS_SUCCESS )
            {
               ULONG Length;

               Length = (ULONG)SmartcardExtension->SmartcardReply.Buffer[ LEN_IDX ] + 1;

               if( Length + 3 < MIN_BUFFER_SIZE )
               {
                  NTStatus = IFReadSTCData(
                     SmartcardExtension->ReaderExtension,
                     &SmartcardExtension->SmartcardReply.Buffer[ DATA_IDX ],
                     Length);

                  SmartcardExtension->SmartcardReply.BufferLength = Length + 3;
               }
               else
               {
                  NTStatus = STATUS_BUFFER_TOO_SMALL;
               }
            }

            if (PriorityBoost) {

                SmartcardDebug(
                   DEBUG_TRACE,
                   ( "%s!CBT1Transmit: Setting priority: 0x%x\n",
                   DRIVER_NAME,
                   PreviousPriority));

                PriorityBoost = FALSE;

                PreviousPriority = KeSetPriorityThread(KeGetCurrentThread(),
                                                       PreviousPriority);

            }

            //
            // if STCRead detects an LRC error, ignore it (maybe CRC used). Timeouts will
            // be detected by the lib if len=0
            //
            if(( NTStatus == STATUS_CRC_ERROR ) || ( NTStatus == STATUS_IO_TIMEOUT ))
            {
               NTStatus = STATUS_SUCCESS;
            }

            if( NTStatus == STATUS_SUCCESS )
            {
               // let the lib evaluate the result & setup the next APDU
               NTStatus = SmartcardT1Reply( SmartcardExtension );
            }
         }
      }

   // continue if the lib wants to send the next packet
   } while( NTStatus == STATUS_MORE_PROCESSING_REQUIRED );

   if( NTStatus == STATUS_IO_TIMEOUT )
   {
      NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
   }

   SmartcardDebug( DEBUG_TRACE,( "%s!CBT1Transmit Exit: %X\n",DRIVER_NAME, NTStatus ));

   return ( NTStatus );
}

NTSTATUS
CBRawTransmit(
   PSMARTCARD_EXTENSION SmartcardExtension)
/*++

CBRawTransmit:
   finishes the callback RDF_TRANSMIT for the RAW protocol

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_UNSUCCESSFUL

--*/
{
    NTSTATUS         NTStatus = STATUS_UNSUCCESSFUL;

   SmartcardDebug( DEBUG_TRACE, ("%s!CBRawTransmit Exit: %X\n",DRIVER_NAME, NTStatus ));
   return ( NTStatus );
}


NTSTATUS
CBCardTracking(
   PSMARTCARD_EXTENSION SmartcardExtension)
/*++

CBCardTracking:
   callback handler for SMCLIB RDF_CARD_TRACKING. the requested event was
   validated by the smclib (i.e. a card removal request will only be passed
   if a card is present).
   for a win95 build STATUS_PENDING will be returned without any other action.
   for NT the cancel routine for the irp will be set to the drivers cancel
   routine.

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_PENDING

--*/
{
   KIRQL CurrentIrql;

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!CBCardTracking Enter\n",
      DRIVER_NAME));

   // set cancel routine
   IoAcquireCancelSpinLock( &CurrentIrql );

   IoSetCancelRoutine(
      SmartcardExtension->OsData->NotificationIrp,
      StcUsbCancel);

   IoReleaseCancelSpinLock( CurrentIrql );

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!CBCardTracking Exit\n",
      DRIVER_NAME));

   return( STATUS_PENDING );

}


NTSTATUS
CBUpdateCardState(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

CBUpdateCardState:
   updates the variable CurrentState in SmartcardExtension

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   UCHAR    cardStatus = 0;
   KIRQL    irql;
   BOOLEAN     stateChanged = FALSE;
   ULONG    oldState;

   // read card state
   status = IFReadSTCRegister(
      SmartcardExtension->ReaderExtension,
      ADR_IO_CONFIG,
      1,
      &cardStatus
      );

   KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                     &irql);
   oldState = SmartcardExtension->ReaderCapabilities.CurrentState;

   switch(status)
   {
      case STATUS_NO_MEDIA:
         SmartcardExtension->ReaderExtension->ErrorCounter = 0;
         SmartcardExtension->ReaderCapabilities.CurrentState =
            SCARD_ABSENT;
         break;

      case STATUS_MEDIA_CHANGED:
         SmartcardExtension->ReaderExtension->ErrorCounter = 0;
         SmartcardExtension->ReaderCapabilities.CurrentState =
            SCARD_PRESENT;
         break;

      case STATUS_SUCCESS:
         SmartcardExtension->ReaderExtension->ErrorCounter = 0;
         cardStatus &= M_SD;
         if( cardStatus == 0 )
         {
            SmartcardExtension->ReaderCapabilities.CurrentState =
               SCARD_ABSENT;
         }
         else if( SmartcardExtension->ReaderCapabilities.CurrentState <=
            SCARD_ABSENT )
         {
            SmartcardExtension->ReaderCapabilities.CurrentState =
               SCARD_PRESENT;
         }
         break;

      default:
         if( ++SmartcardExtension->ReaderExtension->ErrorCounter < ERROR_COUNTER_TRESHOLD )
         {
             // a unknown status was reported from the reader, so use the previous state
             SmartcardExtension->ReaderCapabilities.CurrentState = oldState;
         }
         else
         {
              SmartcardLogError(
                 SmartcardExtension->OsData->DeviceObject,
                 STCUSB_TOO_MANY_ERRORS,
                 NULL,
                 0);

             // a report of SCARD_UNKNOWN will force the resource manager to 
             // disconnect the reader
             SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_UNKNOWN;
         }
         break;
   }
   //
   // we need to update the card state if there was a card before hibernate
   // stand / by or when the current state has changed.
   //
   if (SmartcardExtension->ReaderExtension->CardPresent ||
      oldState <= SCARD_ABSENT &&
      SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT ||
      oldState > SCARD_ABSENT &&
      SmartcardExtension->ReaderCapabilities.CurrentState <= SCARD_ABSENT) {

        stateChanged = TRUE;
      SmartcardExtension->ReaderExtension->CardPresent = FALSE;
    }

   if (stateChanged && SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT) {
       
       PoSetSystemState (ES_USER_PRESENT);

   }
   
   if(stateChanged && SmartcardExtension->OsData->NotificationIrp != NULL)
   {
      KIRQL CurrentIrql;
      PIRP pIrp;

      IoAcquireCancelSpinLock( &CurrentIrql );
      IoSetCancelRoutine( SmartcardExtension->OsData->NotificationIrp, NULL );
      IoReleaseCancelSpinLock( CurrentIrql );

      SmartcardExtension->OsData->NotificationIrp->IoStatus.Status =
            STATUS_SUCCESS;
      SmartcardExtension->OsData->NotificationIrp->IoStatus.Information = 0;

      SmartcardDebug(
         DEBUG_DRIVER,
         ("%s!CBUpdateCardState: Completing notification irp %lx\n",
         DRIVER_NAME,
         SmartcardExtension->OsData->NotificationIrp));

      pIrp = SmartcardExtension->OsData->NotificationIrp;
      SmartcardExtension->OsData->NotificationIrp = NULL;

     KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock, irql);

      IoCompleteRequest(pIrp, IO_NO_INCREMENT);

   } else {
     KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock, irql);
   }

   return status;
}

NTSTATUS
CBSynchronizeSTC(
   PSMARTCARD_EXTENSION SmartcardExtension )
/*++

CBSynchronizeSTC:
   updates the card dependend data of the stc (wait times, ETU...)

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS

--*/

{
   NTSTATUS          NTStatus = STATUS_SUCCESS;
   PREADER_EXTENSION    ReaderExtension;
   ULONG             CWT,
                     BWT,
                     CGT,
                     ETU;
   UCHAR             Dl,
                     Fl,
                     N;

   PCLOCK_RATE_CONVERSION  ClockRateConversion;
   PBIT_RATE_ADJUSTMENT BitRateAdjustment;

   ReaderExtension      = SmartcardExtension->ReaderExtension;
   ClockRateConversion  = SmartcardExtension->CardCapabilities.ClockRateConversion;
   BitRateAdjustment = SmartcardExtension->CardCapabilities.BitRateAdjustment;

   // cycle length
   Dl = SmartcardExtension->CardCapabilities.Dl;
   Fl = SmartcardExtension->CardCapabilities.Fl;

   ETU = ClockRateConversion[Fl & 0x0F].F;

   ETU /= BitRateAdjustment[ Dl & 0x0F ].DNumerator;
   ETU *= BitRateAdjustment[ Dl & 0x0F ].DDivisor;

   // ETU += (ETU % 2 == 0) ? 0 : 1;

   // a extra guard time of 0xFF means minimum delay in both directions
   N = SmartcardExtension->CardCapabilities.N;
   if( N == 0xFF )
   {
      N = 0;
   }

   // set character waiting & guard time
   switch ( SmartcardExtension->CardCapabilities.Protocol.Selected )
   {
      case SCARD_PROTOCOL_T0:
         CWT = 960 * SmartcardExtension->CardCapabilities.T0.WI;
         CGT = 14 + N;  // 13 + N;     cryptoflex error
         break;

      case SCARD_PROTOCOL_T1:
         CWT = 11 + ( 0x01 << SmartcardExtension->CardCapabilities.T1.CWI );
         BWT = 11 + ( 0x01 << SmartcardExtension->CardCapabilities.T1.BWI ) * 960;
         CGT = 15 + N ;//13 + N; // 12 + N;     sicrypt error

         NTStatus = STCSetBWT( ReaderExtension, BWT * ETU );

         break;

      default:
         // restore default CGT
         CGT=13;
         STCSetCGT( ReaderExtension, CGT);
         NTStatus = STATUS_UNSUCCESSFUL;
         break;
   }

   if(( NTStatus == STATUS_SUCCESS ) && ETU )
   {
      NTStatus = STCSetETU( ReaderExtension, ETU );

      if( NTStatus == STATUS_SUCCESS )
      {
         NTStatus = STCSetCGT( ReaderExtension, CGT );

         if( NTStatus == STATUS_SUCCESS )
         {
            NTStatus = STCSetCWT( ReaderExtension, CWT * ETU );
         }
      }
   }
   return( NTStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\stcusb\stccmd.h ===
/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

    stccmd.h

Abstract:

	function prototypes for stc commands


Revision History:

	PP			12/18/1998	Initial Version

--*/

#if !defined( __STC_CMD_H__ )
#define __STC_CMD_H__
//
//
//	Prototypes ----------------------------------------------------------------
//

NTSTATUS 
STCResetInterface(
	PREADER_EXTENSION	ReaderExtension);

NTSTATUS
STCReset( 
	PREADER_EXTENSION	ReaderExtension,
	UCHAR				Device,
	BOOLEAN				WarmReset,
	PUCHAR				pATR,
	PULONG				pATRLength);

NTSTATUS 
STCReadATR(
	PREADER_EXTENSION	ReaderExtension, 
	PUCHAR				pATR, 
	PULONG				pATRLength);

NTSTATUS
STCPowerOff(
	PREADER_EXTENSION	ReaderExtension);

NTSTATUS
STCPowerOn(
	PREADER_EXTENSION	ReaderExtension);

NTSTATUS
STCSetRST(
	PREADER_EXTENSION	ReaderExtension,
	BOOLEAN				On);
NTSTATUS
STCConfigureSTC( 	
	PREADER_EXTENSION	ReaderExtension,
	PSTC_REGISTER		pConfiguration
	);

NTSTATUS
STCSetETU(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				NewETU);

NTSTATUS
STCSetCGT(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				NewCGT);

NTSTATUS
STCSetCWT(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				NewCWT);

NTSTATUS
STCSetBWT(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				NewBWT);

NTSTATUS 
STCShortCircuitTest(
	PREADER_EXTENSION	ReaderExtension,
	BOOLEAN				*Detected);

NTSTATUS
STCSetFDIV(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				Factor);

NTSTATUS 
STCInitUART(
	PREADER_EXTENSION	ReaderExtension,
	BOOLEAN				AutoLearn);



#endif	//	!__STC_CMD_H__


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\stcusb\stcusbnt.h ===
/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

    stcusbNT.h

Abstract:

    Driver header - WDM Version

Author:


Revision History:

    PP  1.00        12/18/1998      Initial Version

--*/

#if !defined ( __STCUSB_WDM_H__ )
#define __STCUSB_WDM_H__

//
//  Prototypes ----------------------------------------------------------------
//

        
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath);

NTSTATUS
StcUsbPnP(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp);

NTSTATUS
StcUsbPower(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp);


NTSTATUS
StcUsbCreateDevice(
    IN  PDRIVER_OBJECT DriverObject,
    OUT PDEVICE_OBJECT *DeviceObject);

NTSTATUS 
StcUsbStartDevice(
    PDEVICE_OBJECT DeviceObject);

VOID
StcUsbStopDevice( 
    PDEVICE_OBJECT DeviceObject);

NTSTATUS
StcUsbAddDevice(
    IN PDRIVER_OBJECT DriverObject, 
    IN PDEVICE_OBJECT PhysicalDeviceObject);

VOID
StcUsbUnloadDevice( 
    PDEVICE_OBJECT DeviceObject);

VOID
StcUsbUnloadDriver( 
    PDRIVER_OBJECT DriverObject);

NTSTATUS
StcUsbCleanup(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp);

NTSTATUS
StcUsbSystemControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP Irp);

NTSTATUS
StcUsbDeviceIoControl(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp);

NTSTATUS 
StcUsbCreateClose(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp);

NTSTATUS
StcUsbCancel(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp);

NTSTATUS
StcUsbGenericIOCTL(
    PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
StcUsbStartPollThread( PDEVICE_EXTENSION DeviceExtension );

VOID
StcUsbStopPollThread( PDEVICE_EXTENSION DeviceExtension );

void SysDelay( ULONG Timeout );



#endif  // __STCUSB_WDM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\stcusb\usbcom.c ===
/*++

Copyright (c) 1997 SCM Microsystems, Inc.

Module Name:

    usbcom.c

Abstract:

   Hardware access functions for USB smartcard reader


Environment:

      WDM

Revision History:

   PP       01/19/1999  1.01
   PP       12/18/1998  1.00  Initial Version


--*/


#include "common.h"
#include "stcCmd.h"
#include "usbcom.h"
#include "stcusbnt.h"

#pragma optimize( "", off )



NTSTATUS STCtoNT(
   UCHAR ucData[])
/*++

Routine Description:
   Error code translation routine

Arguments:
   ucData   Error code returned by the STC

Return Value:
   Corresponding NT error code

--*/
{
   USHORT usCode = ucData[0]*0x100 +ucData[1];
   NTSTATUS NtStatus;


   switch (usCode)
   {
      case 0x9000:
         NtStatus = STATUS_SUCCESS;
         break;
      case 0x5800:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x2000:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x4000:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x64A1:
         NtStatus = STATUS_NO_MEDIA;
         break;
      case 0x64A0:
         NtStatus = STATUS_MEDIA_CHANGED;
         break;
      case 0x6203:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x6300:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x6500:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x6A00:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x6A80:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      default:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
   }
   return(NtStatus);
}


//******************************************************************************
//
// UsbSyncCompletionRoutine()
//
// Completion routine used by UsbCallUSBD.
//
// Signals an Irp completion event and then returns MORE_PROCESSING_REQUIRED
// to stop further completion of the Irp.
//
// If the Irp is one we allocated ourself, DeviceObject is NULL.
//
//******************************************************************************

NTSTATUS
UsbSyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT kevent;

    kevent = (PKEVENT)Context;

    KeSetEvent(kevent,
               IO_NO_INCREMENT,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

//******************************************************************************
//
// UsbCallUSBD()
//
// Synchronously sends a URB down the device stack.  Blocks until the request
// completes normally or until the request is timed out and cancelled.
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
UsbCallUSBD (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    KEVENT              localevent;
    PIRP                irp;
    PIO_STACK_LOCATION  nextStack;
    NTSTATUS            ntStatus;

    deviceExtension = DeviceObject->DeviceExtension;

    // Initialize the event we'll wait on
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Allocate the Irp
    //
    irp = IoAllocateIrp(deviceExtension->AttachedPDO->StackSize,
                        FALSE);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = Urb;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutine(irp,
                           UsbSyncCompletionRoutine,
                           &localevent,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel

    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(deviceExtension->AttachedPDO,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        LARGE_INTEGER timeout;

        // We used to wait for 1 second, but that made this timeout longer
        // than the polling period of 500ms.  So, if this read failed (e.g.,
        // because of device or USB failure) and timeout, two more worker items
        // would get queued and eventually hundreds of working items would be
        // backed up.  By reducing this timeout we have a good chance that this
        // will finish before the next item is queued.  450ms seems a good value.
        //
        timeout.QuadPart = -4500000; // 450ms

        ntStatus = KeWaitForSingleObject(&localevent,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         &timeout);

        if (ntStatus == STATUS_TIMEOUT)
        {
            ntStatus = STATUS_IO_TIMEOUT;

            // Cancel the Irp we just sent.
            //
            IoCancelIrp(irp);

            // And wait until the cancel completes
            //
            KeWaitForSingleObject(&localevent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        else
        {
            ntStatus = irp->IoStatus.Status;
        }
    }

    // Done with the Irp, now free it.
    //
    IoFreeIrp(irp);

    return ntStatus;
}

NTSTATUS
UsbSelectInterfaces(
   IN PDEVICE_OBJECT DeviceObject,
   IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor)
/*++

Routine Description:
    Initializes an USB reader with (possibly) multiple interfaces;
   This driver only supports one interface (with multiple endpoints).


Arguments:
    DeviceObject - pointer to the device object for this instance of the device.

    ConfigurationDescriptor - pointer to the USB configuration
                    descriptor containing the interface and endpoint
                    descriptors.


Return Value:

    NT status code

--*/
{
   PDEVICE_EXTENSION DeviceExtension= DeviceObject->DeviceExtension;
   NTSTATUS NtStatus;
   PURB pUrb = NULL;
   USHORT usSize;
   ULONG  ulNumberOfInterfaces, i;
   UCHAR ucNumberOfPipes, ucAlternateSetting, ucMyInterfaceNumber;
   PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor;
   PUSBD_INTERFACE_INFORMATION InterfaceObject;

    // This driver only supports one interface, we must parse
    // the configuration descriptor for the interface
    // and remember the pipes.
    //

    pUrb = USBD_CreateConfigurationRequest(ConfigurationDescriptor, &usSize);

   if (pUrb)
   {
      //
      // USBD_ParseConfigurationDescriptorEx searches a given configuration
      // descriptor and returns a pointer to an interface that matches the
      //  given search criteria. We only support one interface on this device
      //
        InterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
         ConfigurationDescriptor,
         ConfigurationDescriptor, //search from start of config  descriptro
         -1,   // interface number not a criteria; we only support one interface
         -1,   // not interested in alternate setting here either
         -1,   // interface class not a criteria
         -1,   // interface subclass not a criteria
         -1);  // interface protocol not a criteria

      ASSERT( InterfaceDescriptor != NULL );

      InterfaceObject = &pUrb->UrbSelectConfiguration.Interface;

      for (i = 0; i < InterfaceObject->NumberOfPipes; i++)
      {
         InterfaceObject->Pipes[i].PipeFlags = 0;
        }

        UsbBuildSelectConfigurationRequest(
         pUrb,
         usSize,
         ConfigurationDescriptor);

      NtStatus = UsbCallUSBD(DeviceObject, pUrb);
    }
   else
   {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(NtStatus == STATUS_SUCCESS)
   {

      // Save the configuration handle for this device
        DeviceExtension->ConfigurationHandle =
            pUrb->UrbSelectConfiguration.ConfigurationHandle;

      ASSERT(DeviceExtension->Interface == NULL);

        DeviceExtension->Interface = ExAllocatePool(
         NonPagedPool,
            InterfaceObject->Length
         );

        if (DeviceExtension->Interface)
      {
            // save a copy of the interface information returned
            RtlCopyMemory(
            DeviceExtension->Interface,
            InterfaceObject,
            InterfaceObject->Length);
      }
      else
      {
         NtStatus = STATUS_NO_MEMORY;
      }
    }

    if (pUrb)
   {
        ExFreePool(pUrb);
    }

    return NtStatus;
}

NTSTATUS
UsbConfigureDevice(
   IN PDEVICE_OBJECT DeviceObject)
/*++

Routine Description:
    Initializes a given instance of the device on the USB and
   selects and saves the configuration.

Arguments:

   DeviceObject - pointer to the physical device object for this instance of the device.


Return Value:

    NT status code


--*/
{
   PDEVICE_EXTENSION DeviceExtension= DeviceObject->DeviceExtension;
   NTSTATUS NtStatus;
   PURB pUrb = NULL;
   ULONG ulSize;
   PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor = NULL;

   __try {

      pUrb = ExAllocatePool(
         NonPagedPool,
         sizeof( struct _URB_CONTROL_DESCRIPTOR_REQUEST )
         );

      if( pUrb == NULL)
      {
         NtStatus = STATUS_NO_MEMORY;
         __leave;
      }

      // When USB_CONFIGURATION_DESCRIPTOR_TYPE is specified for DescriptorType
      // in a call to UsbBuildGetDescriptorRequest(),
      // all interface, endpoint, class-specific, and vendor-specific descriptors
      // for the configuration also are retrieved.
      // The caller must allocate a buffer large enough to hold all of this
      // information or the data is truncated without error.
      // Therefore the 'siz' set below is just a 'good guess', and we may have to retry
        ulSize = sizeof( USB_CONFIGURATION_DESCRIPTOR ) + 16;

       // We will break out of this 'retry loop' when UsbBuildGetDescriptorRequest()
      // has a big enough deviceExtension->UsbConfigurationDescriptor buffer not to truncate
      while( 1 )
      {
         ConfigurationDescriptor = ExAllocatePool( NonPagedPool, ulSize );

         if(ConfigurationDescriptor == NULL)
         {
            NtStatus = STATUS_NO_MEMORY;
            __leave;
         }

         UsbBuildGetDescriptorRequest(
            pUrb,
            sizeof( struct _URB_CONTROL_DESCRIPTOR_REQUEST ),
            USB_CONFIGURATION_DESCRIPTOR_TYPE,
            0,
            0,
            ConfigurationDescriptor,
            NULL,
            ulSize,
            NULL );

         NtStatus = UsbCallUSBD( DeviceObject, pUrb );

         // if we got some data see if it was enough.
         // NOTE: we may get an error in URB because of buffer overrun
         if (pUrb->UrbControlDescriptorRequest.TransferBufferLength == 0 ||
            ConfigurationDescriptor->wTotalLength <= ulSize)
         {
            break;
         }

         ulSize = ConfigurationDescriptor->wTotalLength;
         ExFreePool(ConfigurationDescriptor);
         ConfigurationDescriptor = NULL;
      }

      //
      // We have the configuration descriptor for the configuration we want.
      // Now we issue the select configuration command to get
      // the  pipes associated with this configuration.
      //
      if(NT_SUCCESS(NtStatus))
      {
          NtStatus = UsbSelectInterfaces(
             DeviceObject,
             ConfigurationDescriptor);
      }
   }
   __finally {

      if( pUrb )
      {
         ExFreePool( pUrb );
      }
      if( ConfigurationDescriptor )
      {
         ExFreePool( ConfigurationDescriptor );
      }
   }

   return NtStatus;
}

NTSTATUS
UsbWriteSTCData(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pucData,
   ULONG          ulSize)

/*++

Routine Description:
   Write data in the STC

Arguments:
   ReaderExtension   Context of the call
   APDU        Buffer to write
   ulAPDULen      Length of the buffer to write
Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PUCHAR pucCmd;
   UCHAR ucResponse[3];
   BOOLEAN resend = TRUE;
   LONG Len;
   ULONG Index;
   LONG refLen = (LONG) ulSize;
   ULONG Retries;

   pucCmd = ReaderExtension->pExtBuffer;

   ReaderExtension->ulReadBufferLen = 0;

   // Build the write data command
   Len = refLen;
   Index = 0;

   while (resend == TRUE)
   {
      if(Len > 62)
      {
         Len = 62;
         resend = TRUE;
      }
      else
      {
         resend = FALSE;
      }

      *pucCmd = 0xA0;
      *(pucCmd+1) = (UCHAR) Len;
      memcpy( pucCmd + 2, pucData+Index, Len );

          Retries = USB_WRITE_RETRIES;
          do
          {
         // Send the Write data command
         NTStatus = UsbWrite( ReaderExtension, pucCmd, 2 + Len);
         if (NTStatus != STATUS_SUCCESS)
                 {
            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!UsbWriteSTCData: write error %X \n",
               DRIVER_NAME,
               NTStatus)
               );
            break;
                 }
         // Read the response
         NTStatus = UsbRead( ReaderExtension, ucResponse, 3);
         if (NTStatus != STATUS_SUCCESS)
                 {
            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!UsbWriteSTCData: read error %X \n",
               DRIVER_NAME,
               NTStatus)
               );
            break;
                 }
         else
                 {
             // Test if what we read is really a response to a write
            if(ucResponse[0] != 0xA0)
                        {
               NTStatus = STCtoNT(ucResponse);
                        }
                 }
          } while(( NTStatus != STATUS_SUCCESS ) && --Retries );

          if( NTStatus != STATUS_SUCCESS )
                  break;

      Index += 62;
      Len = refLen - 62;
      refLen = refLen - 62;
   }

   return STATUS_SUCCESS;
}

NTSTATUS
UsbReadSTCData(
   PREADER_EXTENSION    ReaderExtension,
   PUCHAR               pucData,
   ULONG             ulDataLen)

/*++

Routine Description:
   Read data from the STC

Arguments:
   ReaderExtension   Context of the call
   ulAPDULen      Length of the buffer to write
   pucData        Output Buffer


Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR       ucCmd[1];
   PUCHAR      pucResponse;
   int i;
   ULONG ulLenExpected = ulDataLen;
   ULONG Index=0;
   BOOLEAN  SendReadCommand = TRUE;
   LARGE_INTEGER  Begin;
   LARGE_INTEGER  End;

   pucResponse  = ReaderExtension->pExtBuffer;

   KeQuerySystemTime( &Begin );
   End = Begin;
   End.QuadPart = End.QuadPart + (LONGLONG)10 * 1000 * ReaderExtension->ReadTimeout;

   // First let see if we have not already read the data that
   // we need
   if(ReaderExtension->ulReadBufferLen != 0)
   {
      if(ReaderExtension->ulReadBufferLen >= ulLenExpected)
      {
         // all the data that we need are available
         memcpy(pucData,ReaderExtension->ucReadBuffer,ulLenExpected);
         ReaderExtension->ulReadBufferLen = ReaderExtension->ulReadBufferLen - ulLenExpected;
         if(ReaderExtension->ulReadBufferLen != 0)
         {
            memcpy(
               ReaderExtension->ucReadBuffer,
               ReaderExtension->ucReadBuffer+ulLenExpected,
               ReaderExtension->ulReadBufferLen);
         }
         SendReadCommand = FALSE;
      }
      else
      {
         // all the data that we need are not available
         memcpy(pucData,ReaderExtension->ucReadBuffer,ReaderExtension->ulReadBufferLen);
         ulLenExpected = ulLenExpected - ReaderExtension->ulReadBufferLen;
         Index = ReaderExtension->ulReadBufferLen;
         ReaderExtension->ulReadBufferLen = 0;
         SendReadCommand = TRUE;
      }
   }
   while( SendReadCommand == TRUE)
   {
      // Build the Read Register command
      ucCmd[0] = 0xE0;

      NTStatus = UsbWrite( ReaderExtension, ucCmd, 1);
      if (NTStatus != STATUS_SUCCESS)
      {
         SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!UsbReadSTCData: write error %X \n",
            DRIVER_NAME,
            NTStatus)
            );
         break;
      }

      NTStatus = UsbRead( ReaderExtension, pucResponse, 64);
      if (NTStatus != STATUS_SUCCESS)
      {
         SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!UsbReadSTCData: read error %X \n",
            DRIVER_NAME,
            NTStatus)
            );
         break;
      }
      // Test if what we read is really a READ DATA frame
      if(*pucResponse != 0xE0)
      {
         if(*pucResponse == 0x64 && *(pucResponse + 1) == 0xA0)
         {
            NTStatus = STATUS_NO_MEDIA;
         }
         else
         {
            NTStatus = STCtoNT(pucResponse);
         }
         break;
      }
      // If there is no data available
      if (*(pucResponse + 1) == 0)
      {
         KeQuerySystemTime( &Begin );
         if(RtlLargeIntegerGreaterThan(End, Begin))
         {
            SendReadCommand = TRUE;
         }
         else
         {
            ReaderExtension->ulReadBufferLen = 0;
            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!UsbReadSTCData: Timeout %X \n",
               DRIVER_NAME,
               STATUS_IO_TIMEOUT));
            NTStatus =STATUS_IO_TIMEOUT;
            break;
         }
      }
      if ((ULONG) *(pucResponse+1) < ulLenExpected)
      {
         memcpy(pucData+Index,pucResponse+2,(ULONG) *(pucResponse+1));
         Index = Index + (ULONG) *(pucResponse+1);
         ulLenExpected = ulLenExpected - (ULONG) *(pucResponse+1);
         SendReadCommand = TRUE;
      }
      else
      {
         SendReadCommand = FALSE;
         memcpy(pucData+Index,pucResponse+2,ulLenExpected);

         if((ULONG) *(pucResponse+1) > ulLenExpected)
         {
            memcpy(
               ReaderExtension->ucReadBuffer,
               pucResponse+ulLenExpected+2,
               (ULONG) *(pucResponse+1) - ulLenExpected);

            ReaderExtension->ulReadBufferLen =
               (ULONG) *(pucResponse+1) - ulLenExpected;
         }
         else
         {
            ReaderExtension->ulReadBufferLen = 0;
         }
      }
   }

   return NTStatus;
}

NTSTATUS
UsbWriteSTCRegister(
   PREADER_EXTENSION ReaderExtension,
   UCHAR          ucAddress,
   ULONG          ulSize,
   PUCHAR            pucValue)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PUCHAR pucCmd;
   UCHAR ucResponse[2];

   if(ulSize > 16)
   {
      return STATUS_UNSUCCESSFUL;
   }

   pucCmd = ReaderExtension->pExtBuffer;

   ReaderExtension->ulReadBufferLen = 0;

   // Build the write register command
   *pucCmd = 0x80 | ucAddress;
   *(pucCmd+1) = (UCHAR) ulSize;
   memcpy( pucCmd + 2, pucValue, ulSize );

   // Send the Write Register command
   NTStatus = UsbWrite( ReaderExtension, pucCmd, 2 + ulSize);
   if (NTStatus == STATUS_SUCCESS)
   {
      // Read the acknowledge
      NTStatus = UsbRead( ReaderExtension, ucResponse, 2);
      if (NTStatus == STATUS_SUCCESS)
      {
         NTStatus = STCtoNT(ucResponse);
      }
   }

   return NTStatus;
}

NTSTATUS
UsbReadSTCRegister(
   PREADER_EXTENSION ReaderExtension,
   UCHAR          ucAddress,
   ULONG          ulSize,
   PUCHAR            pucValue)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR       ucCmd[2];
   PUCHAR      pucResponse;

   if(ulSize > 16)
   {
      return STATUS_UNSUCCESSFUL;
   }

   pucResponse = ReaderExtension->pExtBuffer;

   // Build the Read Register command
   ucCmd[0] = 0xC0 | ucAddress;
   ucCmd[1] = (UCHAR) ulSize;

   // Send the Read Register command
   NTStatus = UsbWrite( ReaderExtension, ucCmd, 2);
   if (NTStatus == STATUS_SUCCESS)
   {
      // Read the response from the reader
      NTStatus = UsbRead(
         ReaderExtension,
         pucResponse,
         6
         );

      if (NTStatus == STATUS_SUCCESS)
      {
         // Test if what we read is really a READ frame
         if(*pucResponse == 0x21)
         {
            if(*(pucResponse + 1) > 4)
            {
               NTStatus = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
               memcpy(
                  pucValue,
                  pucResponse + 2,
                  (ULONG) *(pucResponse + 1)
                  );
            }
         }
         else
         {
            NTStatus = STCtoNT(pucResponse);
         }
      }
   }

   return NTStatus;
}

NTSTATUS
UsbGetFirmwareRevision(
   PREADER_EXTENSION ReaderExtension)
/*++
Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR       ucCmd[1];
   UCHAR    ucResponse[4];

   ucCmd[0] = 0xE1;
   NTStatus = UsbWrite( ReaderExtension, ucCmd, 2 );

   if( NTStatus == STATUS_SUCCESS )
   {
      ReaderExtension->ReadTimeout = 1000;
      NTStatus = UsbRead( ReaderExtension, ucResponse, 4 );

      if( NTStatus == STATUS_SUCCESS )
      {
         ReaderExtension->FirmwareMajor = ucResponse[ 2 ];
         ReaderExtension->FirmwareMinor = ucResponse[ 3 ];
      }
   }
   return NTStatus ;
}


NTSTATUS
UsbRead(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pData,
   ULONG          DataLen  )
/*++
Description:
   Read data on the USB bus

Arguments:
   ReaderExtension   context of call
   pData       ptr to data buffer
   DataLen        length of data buffer
   pNBytes        number of bytes returned

Return Value:
   STATUS_SUCCESS
   STATUS_BUFFER_TOO_SMALL
   STATUS_UNSUCCESSFUL

--*/
{
   NTSTATUS NtStatus = STATUS_SUCCESS;
   PURB pUrb;
   USBD_INTERFACE_INFORMATION* pInterfaceInfo;
   USBD_PIPE_INFORMATION* pPipeInfo;
   PDEVICE_OBJECT DeviceObject = ReaderExtension->DeviceObject;
   PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
   ULONG ulSize;

   pInterfaceInfo = DeviceExtension->Interface;

   ASSERT(pInterfaceInfo != NULL);

   if (pInterfaceInfo == NULL) {

      // The device has likely been disconnected during hibernate / stand by
      return STATUS_DEVICE_NOT_CONNECTED;
   }

   // Read pipe number is 0 on this device
   pPipeInfo = &( pInterfaceInfo->Pipes[ 0 ] );

   ulSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
   pUrb = ReaderExtension->pUrb;


   UsbBuildInterruptOrBulkTransferRequest(
      pUrb,
      (USHORT)ulSize,
      pPipeInfo->PipeHandle,
      pData,
      NULL,
      DataLen,
      USBD_SHORT_TRANSFER_OK,
      NULL);

      NtStatus = UsbCallUSBD( DeviceObject, pUrb );

   return NtStatus;
}

NTSTATUS
UsbWrite(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pData,
   ULONG          DataLen)
/*++
Description:
   Write data on the usb port

Arguments:
   ReaderExtension   context of call
   pData          ptr to data buffer
   DataLen           length of data buffer (exclusive LRC!)

Return Value:
   return value of

--*/
{
   NTSTATUS NtStatus = STATUS_SUCCESS;
   PURB pUrb;
   USBD_INTERFACE_INFORMATION* pInterfaceInfo;
   USBD_PIPE_INFORMATION* pPipeInfo;
   PDEVICE_OBJECT DeviceObject = ReaderExtension->DeviceObject;
   PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
   ULONG ulSize;

   pInterfaceInfo = DeviceExtension->Interface;

   ASSERT(pInterfaceInfo != NULL);

   if (pInterfaceInfo == NULL) {

      // The device has likely been disconnected during hibernate / stand by
      return STATUS_DEVICE_NOT_CONNECTED;
   }

   // Write pipe number is 1 on this device
   pPipeInfo = &( pInterfaceInfo->Pipes[ 1 ] );

   ulSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
   pUrb = ReaderExtension->pUrb;

   UsbBuildInterruptOrBulkTransferRequest(
      pUrb,
      (USHORT)ulSize,
      pPipeInfo->PipeHandle,
      pData,
      NULL,
      DataLen,
      USBD_SHORT_TRANSFER_OK,
      NULL );

   NtStatus = UsbCallUSBD( DeviceObject, pUrb );
   
   return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\stcusb\usbcom.h ===
/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

    UsbCom.h

Abstract:

	Constants & access function prototypes for USB  smartcard reader


Revision History:

	PP			12/18/1998	Initial Version

--*/

#if !defined( __USB_COM_H__ )
#define __USB_COM_H__

//
//	Prototypes for access functions -------------------------------------------
//
NTSTATUS
UsbResetDevice(
    IN PDEVICE_OBJECT DeviceObject
    );
NTSTATUS 
UsbCallUSBD( 
	IN PDEVICE_OBJECT DeviceObject, 
	IN PURB pUrb);

NTSTATUS 
UsbConfigureDevice( 
	IN PDEVICE_OBJECT DeviceObject);


NTSTATUS
UsbWriteSTCData(
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pucData,
	ULONG				ulSize);

NTSTATUS
UsbReadSTCData(
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pucData,
	ULONG				ulDataLen);

NTSTATUS
UsbWriteSTCRegister(
	PREADER_EXTENSION	ReaderExtension,
	UCHAR				ucAddress,
	ULONG				ulSize,
	PUCHAR				pucValue);

NTSTATUS
UsbReadSTCRegister(
	PREADER_EXTENSION	ReaderExtension,
	UCHAR				ucAddress,
	ULONG				ulSize,
	PUCHAR				pucValue);

NTSTATUS
UsbGetFirmwareRevision(
	PREADER_EXTENSION	ReaderExtension);

NTSTATUS
UsbRead( 
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pData,
	ULONG				DataLen);

NTSTATUS
UsbWrite( 
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pData,
	ULONG				DataLen);

NTSTATUS
UsbSend( 
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pDataIn,
	ULONG				DataLenIn,
	PUCHAR				pDataOut,
	ULONG				DataLenOut);


#endif	//	__USB_COM_H__

//	------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\stcusb\stccmd.c ===
/*++

Copyright (c) 1997 SCM Microsystems, Inc.

Module Name:

    StcCmd.c

Abstract:

   Basic command functions for STC smartcard reader


Environment:



Revision History:

   PP       01.19.1999  1.01  Modification for PC/SC
   YL                1.00  Initial Version

--*/

#include "common.h"
#include "StcCmd.h"
#include "usbcom.h"
#include "stcusbnt.h"


const STC_REGISTER STCInitialize[] =
{
   { ADR_SC_CONTROL,    0x01, 0x00     },    // reset
   { ADR_CLOCK_CONTROL, 0x01, 0x01     },
   { ADR_CLOCK_CONTROL, 0x01, 0x03     },
   { ADR_UART_CONTROL,     0x01, 0x27     },
   { ADR_UART_CONTROL,     0x01, 0x4F     },
   { ADR_IO_CONFIG,     0x01, 0x02     },    // 0x10 eva board
   { ADR_FIFO_CONFIG,      0x01, 0x81     },
   { ADR_INT_CONTROL,      0x01, 0x11     },
   { 0x0E,              0x01, 0xC0     },
   { 0x00,              0x00, 0x00     },
};

const STC_REGISTER STCClose[] =
{
   { ADR_INT_CONTROL,      0x01, 0x00     },
   { ADR_SC_CONTROL,    0x01, 0x00     },    // reset
   { ADR_UART_CONTROL,     0x01, 0x40     },
   { ADR_CLOCK_CONTROL, 0x01, 0x01     },
   { ADR_CLOCK_CONTROL, 0x01, 0x00     },
   { 0x00,              0x00, 0x00     },
};





NTSTATUS
STCResetInterface(
   PREADER_EXTENSION ReaderExtension)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:

--*/
{
   NTSTATUS NtStatus = STATUS_SUCCESS;
   DWORD dwETU;

   dwETU = 0x7401 | 0x0080;
   NtStatus=IFWriteSTCRegister(
      ReaderExtension,
      ADR_ETULENGTH15,
      2,
      (UCHAR *)&dwETU);

   return(NtStatus);
}

NTSTATUS
STCReset(
   PREADER_EXTENSION ReaderExtension,
   UCHAR          Device,
   BOOLEAN           WarmReset,
   PUCHAR            pATR,
   PULONG            pATRLength)
/*++
Description:
   performs a reset of ICC

Arguments:
   ReaderExtension      context of call
   Device            device requested
   WarmReset         kind of ICC reset
   pATR           ptr to ATR buffer, NULL if no ATR required
   pATRLength        size of ATR buffer / length of ATR

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_UNRECOGNIZED_MEDIA
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;

   // set UART to autolearn mode
   NTStatus = STCInitUART( ReaderExtension, TRUE );


   if( NTStatus == STATUS_SUCCESS)
   {
      //
      // set default frequency for ATR
      //
      NTStatus = STCSetFDIV( ReaderExtension, FREQ_DIV );

      if( NTStatus == STATUS_SUCCESS && ( !WarmReset ))
      {
         //
         // deactivate contacts
         //
         NTStatus = STCPowerOff( ReaderExtension );
      }

      //
      // set power to card
      //
      if( NTStatus == STATUS_SUCCESS)
      {
         NTStatus = STCPowerOn( ReaderExtension );

         if( NTStatus == STATUS_SUCCESS)
         {
            NTStatus = STCReadATR( ReaderExtension, pATR, pATRLength );
         }
      }
   }

   if( NTStatus != STATUS_SUCCESS )
   {
      STCPowerOff( ReaderExtension );
   }
   return( NTStatus );
}

NTSTATUS
STCReadATR(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pATR,
   PULONG            pATRLen)
/*++
Description:
   Read and analize the ATR

Arguments:
   ReaderExtension      context of call
   pATR           ptr to ATR buffer,
   pATRLen           size of ATR buffer / length of ATR

Return Value:

--*/

{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    T0_Yx,
            T0_K,          // number of historical bytes
            Protocol;
   ULONG    ATRLen;
   //
   // set read timeout for ATR
   //
   ReaderExtension->ReadTimeout = 250; // only 250ms for this firs ATR
   //
   // read TS if active low reset
   //
   NTStatus = IFReadSTCData( ReaderExtension, pATR, 1 );

   if( NTStatus == STATUS_IO_TIMEOUT )
   {
      ReaderExtension->ReadTimeout = 2500;
      NTStatus = STCSetRST( ReaderExtension, TRUE );

      if( NTStatus == STATUS_SUCCESS )
      {
         NTStatus = IFReadSTCData( ReaderExtension, pATR, 1 );
      }
   }


   Protocol = PROTOCOL_TO;
   ATRLen      = 1;

   if( NTStatus == STATUS_SUCCESS )
   {
      // T0
      NTStatus = IFReadSTCData( ReaderExtension, pATR + ATRLen, 1 );
      ATRLen++;

      /* Convention management */
      if ( pATR[0] == 0x03 )     /* Direct convention */
      {
         pATR[0] = 0x3F;
      }

      if ( ( pATR[0] != 0x3F ) && ( pATR[0] != 0x3B ) )
      {
         NTStatus = STATUS_DATA_ERROR;
      }

      if( NTStatus == STATUS_SUCCESS )
      {
         ULONG Request;

         // number of historical bytes
         T0_K = (UCHAR) ( pATR[ATRLen-1] & 0x0F );

         // coding of TA, TB, TC, TD
         T0_Yx = (UCHAR) ( pATR[ATRLen-1] & 0xF0 ) >> 4;

         while(( NTStatus == STATUS_SUCCESS ) && T0_Yx )
         {
            UCHAR Mask;

            // evaluate presence of TA, TB, TC, TD
            Mask  = T0_Yx;
            Request  = 0;
            while( Mask )
            {
               if( Mask & 1 )
               {
                  Request++;
               }
               Mask >>= 1;
            }
            NTStatus = IFReadSTCData( ReaderExtension, pATR + ATRLen, Request );
            ATRLen += Request;
            if (ATRLen >= ATR_SIZE) {
                NTStatus = STATUS_UNRECOGNIZED_MEDIA;
                break;
            }

            if( T0_Yx & TDx )
            {
               // high nibble of TD codes the next set of TA, TB, TC, TD
               T0_Yx = ( pATR[ATRLen-1] & 0xF0 ) >> 4;
               // low nibble of TD codes the protocol
               Protocol = pATR[ATRLen-1] & 0x0F;
            }
            else
            {
               break;
            }
         }

         if( NTStatus == STATUS_SUCCESS )
         {
            // historical bytes
            NTStatus = IFReadSTCData( ReaderExtension, pATR + ATRLen, T0_K );

            // check sum
            if( NTStatus == STATUS_SUCCESS )
            {
               ATRLen += T0_K;


               if( (ATRLen < ATR_SIZE) && (Protocol >= PROTOCOL_T1) )
               {
                  NTStatus = IFReadSTCData( ReaderExtension, pATR + ATRLen, 1 );
                  if( NTStatus == STATUS_SUCCESS )
                  {
                     ATRLen++;
                  }
                  else if( NTStatus == STATUS_IO_TIMEOUT )
                  {
                     // some cards don't support the TCK
                     NTStatus = STATUS_SUCCESS;
                  }
               } else {
                   if (ATRLen >= ATR_SIZE) {
                       NTStatus = STATUS_UNRECOGNIZED_MEDIA;
                   }
               }
            }
         }
      }
   }

   if( NTStatus == STATUS_IO_TIMEOUT )
   {
      NTStatus = STATUS_UNRECOGNIZED_MEDIA;
   }

   if(( NTStatus == STATUS_SUCCESS ) && ( pATRLen != NULL ))
   {
      *pATRLen = ATRLen;
   }
   return( NTStatus );
}


NTSTATUS
STCPowerOff(
   PREADER_EXTENSION ReaderExtension )
/*++
Description:
   Deactivates the requested device

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    SCCtrl;

   // clear SIM
   SCCtrl=0x11;
   NTStatus=IFWriteSTCRegister(
      ReaderExtension,
      ADR_INT_CONTROL,
      1,
      &SCCtrl);

   SCCtrl = 0x00;
   NTStatus = IFWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1, &SCCtrl );

   return( NTStatus );
}

NTSTATUS
STCPowerOn(
   PREADER_EXTENSION ReaderExtension )
/*++
Description:
   Deactivates the requested device

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    SCCtrl,Byte;

   Byte = 0x02;
   NTStatus = IFWriteSTCRegister(
      ReaderExtension,
      ADR_IO_CONFIG,
      1,
      &Byte
      );

   SCCtrl = 0x40;       // vcc
   NTStatus = IFWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1, &SCCtrl );

   if( NTStatus == STATUS_SUCCESS )
   {
      SCCtrl = 0x41;    // vpp
      NTStatus = IFWriteSTCRegister(
         ReaderExtension,
         ADR_SC_CONTROL,
         1,
         &SCCtrl
         );


      // set SIM
      SCCtrl = 0x13;
      NTStatus=IFWriteSTCRegister(
         ReaderExtension,
         ADR_INT_CONTROL,
         1,
         &SCCtrl);

      if( NTStatus == STATUS_SUCCESS )
      {
         SCCtrl = 0xD1; //  vcc, clk, io
         NTStatus = IFWriteSTCRegister(
            ReaderExtension,
            ADR_SC_CONTROL,
            1,
            &SCCtrl
            );
      }
   }
   return( NTStatus );
}


NTSTATUS
STCSetRST(
   PREADER_EXTENSION ReaderExtension,
   BOOLEAN           On)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    SCCtrl = 0;

   NTStatus = IFReadSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1,&SCCtrl );
   if( NTStatus == STATUS_SUCCESS )
   {
      if( On )
      {
         SCCtrl |= 0x20;
      }
      else
      {
         SCCtrl &= ~0x20;
      }

      NTStatus = IFWriteSTCRegister(
         ReaderExtension,
         ADR_SC_CONTROL,
         1,
         &SCCtrl
         );
   }
   return(NTStatus);
}


NTSTATUS
STCConfigureSTC(
   PREADER_EXTENSION ReaderExtension,
   PSTC_REGISTER     pConfiguration
   )
{
   NTSTATUS       NTStatus = STATUS_SUCCESS;
   UCHAR          Value;

   do
   {
      if( pConfiguration->Register == ADR_INT_CONTROL )
      {
         // Read interrupt status register to acknoledge wrong states
         NTStatus = IFReadSTCRegister(
            ReaderExtension,
            ADR_INT_STATUS,
            1,
            &Value
            );
      }

      Value = (UCHAR) pConfiguration->Value;
      NTStatus = IFWriteSTCRegister(
         ReaderExtension,
         pConfiguration->Register,
         pConfiguration->Size,
         (PUCHAR)&pConfiguration->Value
         );

      if (NTStatus == STATUS_NO_MEDIA)
      {
         // ignore that no card is in the reader
         NTStatus = STATUS_SUCCESS;
      }

      // delay to stabilize the oscilator clock:
      if( pConfiguration->Register == ADR_CLOCK_CONTROL )
      {
         SysDelay( 100 );
      }
      pConfiguration++;

   } while(NTStatus == STATUS_SUCCESS && pConfiguration->Size);

   return NTStatus;
}


NTSTATUS
STCSetETU(
   PREADER_EXTENSION ReaderExtension,
   ULONG          NewETU)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_DATA_ERROR;
   UCHAR    ETU[2];

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!STCSetETU   %d\n",
      DRIVER_NAME,
      NewETU));

   if( NewETU < 0x0FFF )
   {
      NTStatus = IFReadSTCRegister(
         ReaderExtension,
         ADR_ETULENGTH15,
         2,
         ETU);

      if( NTStatus == STATUS_SUCCESS )
      {
         //
         // save all RFU bits
         //
         ETU[1]   = (UCHAR) NewETU;
         ETU[0]   = (UCHAR)(( ETU[0] & 0xF0 ) | ( NewETU >> 8 ));

         NTStatus = IFWriteSTCRegister(
            ReaderExtension,
            ADR_ETULENGTH15,
            2,
            ETU);
      }
   }
   return(NTStatus);
}

NTSTATUS
STCSetCGT(
   PREADER_EXTENSION ReaderExtension,
   ULONG          NewCGT)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/

{
   NTSTATUS NTStatus = STATUS_DATA_ERROR;
   UCHAR    CGT[2];

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!STCSetCGT   %d\n",
      DRIVER_NAME,
      NewCGT));

   if( NewCGT < 0x01FF )
   {
      NTStatus = IFReadSTCRegister(
         ReaderExtension,
         ADR_CGT8,
         2,
         CGT);

      if( NTStatus == STATUS_SUCCESS )
      {
         //
         // save all RFU bits
         //
         CGT[1] = ( UCHAR )NewCGT;
         CGT[0] = (UCHAR)(( CGT[0] & 0xFE ) | ( NewCGT >> 8 ));

         NTStatus = IFWriteSTCRegister(
            ReaderExtension,
            ADR_CGT8,
            2,
            CGT);
      }
   }
   return(NTStatus);
}

NTSTATUS
STCSetCWT(
   PREADER_EXTENSION ReaderExtension,
   ULONG          NewCWT)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    CWT[4];


   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!STCSetCWT   %d\n",
      DRIVER_NAME,
      NewCWT));
   // little indians...
   CWT[0] = (( PUCHAR )&NewCWT )[3];
   CWT[1] = (( PUCHAR )&NewCWT )[2];
   CWT[2] = (( PUCHAR )&NewCWT )[1];
   CWT[3] = (( PUCHAR )&NewCWT )[0];

   NTStatus = IFWriteSTCRegister(
      ReaderExtension,
      ADR_CWT31,
      4,
      CWT );
   return(NTStatus);
}

NTSTATUS
STCSetBWT(
   PREADER_EXTENSION ReaderExtension,
   ULONG          NewBWT)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS    NTStatus = STATUS_SUCCESS;
   UCHAR    BWT[4];

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!STCSetBWT   %d\n",
      DRIVER_NAME,
      NewBWT));

   // little indians...
   BWT[0] = (( PUCHAR )&NewBWT )[3];
   BWT[1] = (( PUCHAR )&NewBWT )[2];
   BWT[2] = (( PUCHAR )&NewBWT )[1];
   BWT[3] = (( PUCHAR )&NewBWT )[0];

   NTStatus = IFWriteSTCRegister(
      ReaderExtension,
      ADR_BWT31,
      4,
      BWT );

   return(NTStatus);
}


NTSTATUS
STCSetFDIV(
   PREADER_EXTENSION ReaderExtension,
   ULONG          Factor)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    DIV = 0;

   NTStatus = IFReadSTCRegister(
      ReaderExtension,
      ADR_ETULENGTH15,
      1,
      &DIV );

   if( NTStatus == STATUS_SUCCESS )
   {
      switch( Factor )
      {
         case 1:
            DIV &= ~M_DIV0;
            DIV &= ~M_DIV1;
            break;

         case 2:
            DIV |= M_DIV0;
            DIV &= ~M_DIV1;
            break;

         case 4   :
            DIV &= ~M_DIV0;
            DIV |= M_DIV1;
            break;

         case 8   :
            DIV |= M_DIV0;
            DIV |= M_DIV1;
            break;

         default :
            NTStatus = STATUS_DATA_ERROR;
      }
      if( NTStatus == STATUS_SUCCESS )
      {
         NTStatus = IFWriteSTCRegister(
            ReaderExtension,
            ADR_ETULENGTH15,
            1,
            &DIV );
      }
   }
   return(NTStatus);
}

NTSTATUS
STCInitUART(
   PREADER_EXTENSION ReaderExtension,
   BOOLEAN           AutoLearn)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    Value;

   Value = AutoLearn ? 0x6F : 0x66;

   NTStatus = IFWriteSTCRegister(
      ReaderExtension,
      ADR_UART_CONTROL,
      1,
      &Value );

   return( NTStatus );
}

//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbccid\usbcom.c ===
#include "usbcom.h"
#include "usbsc.h"
#include <usbutil.h>
#include <usb.h>
#include <usbdlib.h>


NTSTATUS
UsbWrite(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pData,
   ULONG             DataLen,
   LONG              Timeout)
/*++
Description:
   Write data to the usb port

Arguments:
   ReaderExtension   context of call
   pData             ptr to data buffer
   DataLen           length of data buffer

Return Value:
   NTSTATUS

--*/
{
   NTSTATUS             status = STATUS_SUCCESS;
   PURB                 pUrb = NULL;
   PDEVICE_OBJECT       DeviceObject;
   PDEVICE_EXTENSION    DeviceExtension;
   ULONG                ulSize;

   __try 
   {
       
       SmartcardDebug( DEBUG_TRACE, ("%s!UsbWrite Enter\n",DRIVER_NAME ));

       DeviceObject = ReaderExtension->DeviceObject;
       DeviceExtension = DeviceObject->DeviceExtension;


       ulSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
       pUrb = ExAllocatePool( NonPagedPool, 
                              ulSize );

       if(pUrb == NULL) {

          status = STATUS_INSUFFICIENT_RESOURCES;

       } else {

          UsbBuildInterruptOrBulkTransferRequest(pUrb,
                                                 (USHORT)ulSize,
                                                 ReaderExtension->BulkOutHandle,
                                                 pData,
                                                 NULL,
                                                 DataLen,
                                                 USBD_SHORT_TRANSFER_OK,
                                                 NULL);

          status = USBCallSync(DeviceExtension->LowerDeviceObject, 
                               pUrb,
                               Timeout,
                               &DeviceExtension->RemoveLock);
          ExFreePool( pUrb );
          pUrb = NULL;

       }
          
   }

   __finally 
   {
       if (pUrb) {
           ExFreePool(pUrb);
           pUrb = NULL;
       }

       SmartcardDebug( DEBUG_TRACE, ("%s!UsbWrite Exit : 0x%x\n",DRIVER_NAME, status ));

   }

   return status;
   
}

NTSTATUS
UsbRead(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pData,
   ULONG             DataLen,
   LONG              Timeout)
/*++
Description:
   Read data from the USB bus

Arguments:
   ReaderExtension   context of call
   pData             ptr to data buffer
   DataLen           length of data buffer
   pNBytes           number of bytes returned

Return Value:
   STATUS_SUCCESS
   STATUS_BUFFER_TOO_SMALL
   STATUS_UNSUCCESSFUL

--*/
{
   NTSTATUS             status = STATUS_SUCCESS;
   PURB                 pUrb = NULL;
   PDEVICE_OBJECT       DeviceObject;
   PDEVICE_EXTENSION    DeviceExtension;
   ULONG                ulSize;

   __try 
   {
       
       SmartcardDebug( DEBUG_TRACE, ("%s!UsbRead Enter\n",DRIVER_NAME ));
       
       DeviceObject = ReaderExtension->DeviceObject;
       DeviceExtension = DeviceObject->DeviceExtension;

       ulSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
       pUrb = ExAllocatePool( NonPagedPool, 
                              ulSize );

       if(pUrb == NULL) {

          status = STATUS_INSUFFICIENT_RESOURCES;
          __leave;

       } else {

          UsbBuildInterruptOrBulkTransferRequest(pUrb,
                                                 (USHORT)ulSize,
                                                 ReaderExtension->BulkInHandle,
                                                 pData,
                                                 NULL,
                                                 DataLen,
                                                 USBD_SHORT_TRANSFER_OK,
                                                 NULL);

          status = USBCallSync(DeviceExtension->LowerDeviceObject, 
                               pUrb,
                               Timeout,
                               &DeviceExtension->RemoveLock);

       }

   }

   __finally 
   {

       if (pUrb) {
           ExFreePool(pUrb);
           pUrb = NULL;
       }
       SmartcardDebug( DEBUG_TRACE, ("%s!UsbRead Exit : 0x%x\n",DRIVER_NAME, status ));

   }

   return status;

}


NTSTATUS
UsbConfigureDevice(
   IN PDEVICE_OBJECT DeviceObject
   )
/*++

Routine Description:
    Initializes a given instance of the device on the USB and
   selects and saves the configuration.
   Also saves the Class Descriptor and the pipe handles.

Arguments:

   DeviceObject - pointer to the physical device object for this instance of the device.


Return Value:

    NT status code


--*/
{
   PDEVICE_EXTENSION    pDevExt; 
   PSMARTCARD_EXTENSION smartcardExt;
   PREADER_EXTENSION    readerExt;
   NTSTATUS             status = STATUS_SUCCESS;
   PURB                 pUrb = NULL;
   ULONG                ulSize;
   PUSB_CONFIGURATION_DESCRIPTOR 
                        ConfigurationDescriptor = NULL;
   PUSB_COMMON_DESCRIPTOR   
                        comDesc;
   UINT                 i;

    __try 
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbConfigureDevice Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;
        smartcardExt = &pDevExt->SmartcardExtension;
        readerExt = smartcardExt->ReaderExtension;
       
        pUrb = ExAllocatePool(NonPagedPool,
                              sizeof( struct _URB_CONTROL_DESCRIPTOR_REQUEST ));

        if( pUrb == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }

        //
        // Get the device descriptor
        //
        pDevExt->DeviceDescriptor = ExAllocatePool(NonPagedPool,
                                                   sizeof(USB_DEVICE_DESCRIPTOR));

        if(pDevExt->DeviceDescriptor == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
           __leave;

        }

        UsbBuildGetDescriptorRequest(pUrb,
                                     sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_DEVICE_DESCRIPTOR_TYPE,
                                     0,
                                     0,
                                     pDevExt->DeviceDescriptor,
                                     NULL,
                                     sizeof(USB_DEVICE_DESCRIPTOR),
                                     NULL);

        // Send the urb to the USB driver
        status = USBCallSync(pDevExt->LowerDeviceObject,
                             pUrb,
                             0,
                             &pDevExt->RemoveLock);

        if(!NT_SUCCESS(status)) {

           __leave;

        }


        // When USB_CONFIGURATION_DESCRIPTOR_TYPE is specified for DescriptorType
        // in a call to UsbBuildGetDescriptorRequest(),
        // all interface, endpoint, class-specific, and vendor-specific descriptors
        // for the configuration also are retrieved.
        // The caller must allocate a buffer large enough to hold all of this
        // information or the data is truncated without error.
        // Therefore the 'siz' set below is just a guess, and we may have to retry
        ulSize = sizeof( USB_CONFIGURATION_DESCRIPTOR );

        // We will break out of this 'retry loop' when UsbBuildGetDescriptorRequest()
        // has a big enough deviceExtension->UsbConfigurationDescriptor buffer not to truncate
        while( 1 ) {

            ConfigurationDescriptor = ExAllocatePool( NonPagedPool, ulSize );

            if(ConfigurationDescriptor == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            UsbBuildGetDescriptorRequest(pUrb,
                                         sizeof( struct _URB_CONTROL_DESCRIPTOR_REQUEST ),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         ConfigurationDescriptor,
                                         NULL,
                                         ulSize,
                                         NULL );

            status = USBCallSync(pDevExt->LowerDeviceObject,
                                 pUrb,
                                 0,
                                 &pDevExt->RemoveLock);
                                  
            // if we got some data see if it was enough.
            // NOTE: we may get an error in URB because of buffer overrun
            if (pUrb->UrbControlDescriptorRequest.TransferBufferLength == 0 ||
                ConfigurationDescriptor->wTotalLength <= ulSize) {

                break;

            }

            ulSize = ConfigurationDescriptor->wTotalLength;
            ExFreePool(ConfigurationDescriptor);
            ConfigurationDescriptor = NULL;

        }

        //
        // We have the configuration descriptor for the configuration we want.
        // Now we issue the select configuration command to get
        // the  pipes associated with this configuration.
        //
        if(!NT_SUCCESS(status)) {

            __leave;

        }

        status = UsbSelectInterfaces(DeviceObject,
                                     ConfigurationDescriptor);
        
        if (!NT_SUCCESS(status)) {

            __leave;

        }

        //
        // Get the pipe handles from the interface
        //
        for (i = 0; i < pDevExt->Interface->NumberOfPipes; i++) {

            if (pDevExt->Interface->Pipes[i].PipeType == USB_ENDPOINT_TYPE_INTERRUPT) {

                readerExt->InterruptHandle = pDevExt->Interface->Pipes[i].PipeHandle;
                readerExt->InterruptIndex = i;

            } else if (pDevExt->Interface->Pipes[i].PipeType == USB_ENDPOINT_TYPE_BULK) {

                if (pDevExt->Interface->Pipes[i].EndpointAddress & 0x80) {  // Bulk-in pipe

                    readerExt->BulkInHandle = pDevExt->Interface->Pipes[i].PipeHandle;
                    readerExt->BulkInIndex = i;

                } else {    // Bulk-out pipe
                    
                    readerExt->BulkOutHandle = pDevExt->Interface->Pipes[i].PipeHandle;
                    readerExt->BulkOutIndex = i;

                }
            }
        }

        // 
        // Get CCID Class Descriptor
        //

        comDesc = USBD_ParseDescriptors(ConfigurationDescriptor,
                                        ConfigurationDescriptor->wTotalLength,
                                        ConfigurationDescriptor,
                                        CCID_CLASS_DESCRIPTOR_TYPE);

        ASSERT(comDesc);

     

        readerExt->ClassDescriptor = *((CCID_CLASS_DESCRIPTOR *) comDesc);
        readerExt->ExchangeLevel = (WORD) (readerExt->ClassDescriptor.dwFeatures >> 16);
        


    }

    __finally 
    {

        if( pUrb ) {

            ExFreePool( pUrb );
            pUrb = NULL;

        }

        if( ConfigurationDescriptor ) {

            ExFreePool( ConfigurationDescriptor );
            ConfigurationDescriptor = NULL;

        }

        if (!NT_SUCCESS(status) && pDevExt->DeviceDescriptor) {

            ExFreePool(pDevExt->DeviceDescriptor);
            pDevExt->DeviceDescriptor = NULL;

        }

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbConfigureDevice Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}

NTSTATUS
UsbSelectInterfaces(
   IN PDEVICE_OBJECT DeviceObject,
   IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
   )
/*++

Routine Description:
    Initializes a USB reader with (possibly) multiple interfaces;


Arguments:
    DeviceObject - pointer to the device object for this instance of the device.

    ConfigurationDescriptor - pointer to the USB configuration
                    descriptor containing the interface and endpoint
                    descriptors.


Return Value:

    NT status code

--*/
{

    PDEVICE_EXTENSION           pDevExt;
    NTSTATUS                    status;
    PURB                        pUrb = NULL;
    USHORT                      usSize;
    ULONG                       ulNumberOfInterfaces, i;
    UCHAR                       ucNumberOfPipes, 
                                ucAlternateSetting, 
                                ucMyInterfaceNumber;
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION InterfaceObject;
    USBD_INTERFACE_LIST_ENTRY   interfaces[2];


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbSelectInterfaces Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;

        ASSERT(pDevExt->Interface == NULL);

        //
        // USBD_ParseConfigurationDescriptorEx searches a given configuration
        // descriptor and returns a pointer to an interface that matches the
        //  given search criteria.
        //
        InterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(ConfigurationDescriptor,
                                                                  ConfigurationDescriptor, //search from start of config  descriptro
                                                                  -1,   // interface number not a criteria; 
                                                                  -1,   // not interested in alternate setting here either
                                                                  0x0b,   // CCID Device Class
                                                                  -1,   // interface subclass not a criteria
                                                                  -1);  // interface protocol not a criteria

        ASSERT( InterfaceDescriptor != NULL );

        if (InterfaceDescriptor == NULL) {

            status = STATUS_UNSUCCESSFUL;   
            __leave;

        }

        interfaces[0].InterfaceDescriptor = InterfaceDescriptor;
        interfaces[1].InterfaceDescriptor = NULL;
        
        pUrb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, 
                                                 interfaces);    

        if (pUrb == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }
        ASSERT(pDevExt->LowerDeviceObject);

        status = USBCallSync(pDevExt->LowerDeviceObject,
                             pUrb,
                             0,
                             &pDevExt->RemoveLock);


        if(!NT_SUCCESS(status)) {
            
            __leave;

        }
                                
        // save a copy of the interface information returned
        InterfaceObject = interfaces[0].Interface;

        ASSERT(pDevExt->Interface == NULL);
        pDevExt->Interface = ExAllocatePool(NonPagedPool,
                                            InterfaceObject->Length);

        if (pDevExt->Interface == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }


        RtlCopyMemory(pDevExt->Interface,
                      InterfaceObject,
                      InterfaceObject->Length);

        
    }

    __finally
    {

        if (pUrb) {

            ExFreePool(pUrb);
            pUrb = NULL;

        }
        
        if (!NT_SUCCESS(status)) {

            if (pDevExt->Interface) {

                ExFreePool(pDevExt->Interface);
                pDevExt->Interface = NULL;

            }

        }

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbSelectInterfaces Exit : 0x%x\n",DRIVER_NAME, status ));


    }
    
    return status;

}

NTSTATUS
GetStringDescriptor(
    PDEVICE_OBJECT DeviceObject,
    UCHAR          StringIndex,
    PUCHAR         StringBuffer,
    PUSHORT        StringLength
    )
/*++

Routine Description:
    Retrieves an ASCII string descriptor from the USB Reader

Arguments:
    DeviceObject    - The device object
    StringIndex     - The index of the string to be retrieved
    StringBuffer    - Caller allocated buffer to hold the string
    StringLength    - Length of the string

Return Value:
    NT status value

--*/
{

    NTSTATUS            status = STATUS_SUCCESS;
    USB_STRING_DESCRIPTOR 
                        USD, 
                        *pFullUSD = NULL;
    PURB                pUrb;
    USHORT              langID = 0x0409;  // US English
    PDEVICE_EXTENSION   pDevExt;
    UNICODE_STRING      uString;
    ANSI_STRING         aString;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!GetStringDescriptor Enter\n",DRIVER_NAME ));
        
        pDevExt = DeviceObject->DeviceExtension;
        
        pUrb = ExAllocatePool(NonPagedPool,
                              sizeof( struct _URB_CONTROL_DESCRIPTOR_REQUEST ));

        if( pUrb == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }

        UsbBuildGetDescriptorRequest(pUrb, // points to the URB to be filled in
                                     sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     StringIndex, // index of string descriptor
                                     langID, // language ID of string.
                                     &USD, // points to a USB_STRING_DESCRIPTOR.
                                     NULL,
                                     sizeof(USB_STRING_DESCRIPTOR),
                                     NULL);

        status = USBCallSync(pDevExt->LowerDeviceObject,
                             pUrb,
                             0,
                             &pDevExt->RemoveLock);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

        pFullUSD = ExAllocatePool(NonPagedPool, USD.bLength);

        UsbBuildGetDescriptorRequest(pUrb, // points to the URB to be filled in
                                     sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     StringIndex, // index of string descriptor
                                     langID, // language ID of string
                                     pFullUSD,
                                     NULL,
                                     USD.bLength,
                                     NULL);

        status = USBCallSync(pDevExt->LowerDeviceObject,
                             pUrb,
                             0,
                             &pDevExt->RemoveLock);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

        uString.MaximumLength = uString.Length = pFullUSD->bLength-2;
        uString.Buffer = pFullUSD->bString;
        
        status = RtlUnicodeStringToAnsiString(&aString,
                                              &uString,
                                              TRUE);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

        if (aString.Length > MAXIMUM_ATTR_STRING_LENGTH) {
            aString.Length = MAXIMUM_ATTR_STRING_LENGTH;
            aString.Buffer[aString.Length - 1] = 0;
        }

        RtlCopyMemory(StringBuffer, aString.Buffer, aString.Length);

        *StringLength = aString.Length;

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!GetStringDescriptor Exit : 0x%x\n",DRIVER_NAME, status ));

        if (aString.Buffer) {
            
            RtlFreeAnsiString(&aString);

        }

        if (pUrb) {

            ExFreePool(pUrb);
            pUrb = NULL;

        }

        if (pFullUSD) {

            ExFreePool(pFullUSD);
            pFullUSD = NULL;

        }

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbccid\usbcom.h ===
#include "usbsc.h"

NTSTATUS
UsbWrite(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pData,
   ULONG             DataLen,
   LONG              Timeout
   );

NTSTATUS
UsbRead(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pData,
   ULONG             DataLen,
   LONG              Timeout
   );

NTSTATUS
UsbSelectInterfaces(
   IN PDEVICE_OBJECT DeviceObject,
   IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
   );

NTSTATUS
UsbConfigureDevice(
   IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS
GetStringDescriptor(
    PDEVICE_OBJECT DeviceObject,
    UCHAR          StringIndex,
    PUCHAR         StringBuffer,
    PUSHORT         StringLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\stcusb\stcusbnt.c ===
/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

   StcUsbNT.c

Abstract:

   Main Driver Module - WDM Version


Revision History:


   PP 1.01     01/19/1998     Initial Version
   PP 1.00     12/18/1998     Initial Version

--*/

#include <ntstatus.h>
#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <usb100.h>

#include <common.h>
#include <stcCmd.h>
#include <stcCB.h>
#include <stcusblg.h>
#include <usbcom.h>
#include <stcusbnt.h>


#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGEABLE, StcUsbAddDevice)
#pragma alloc_text(PAGEABLE, StcUsbCreateDevice)
#pragma alloc_text(PAGEABLE, StcUsbStartDevice)
#pragma alloc_text(PAGEABLE, StcUsbUnloadDriver)
#pragma alloc_text(PAGEABLE, StcUsbCreateClose)

extern const STC_REGISTER STCInitialize[];
extern const STC_REGISTER STCClose[];

NTSTATUS
DriverEntry(
   PDRIVER_OBJECT DriverObject,
   PUNICODE_STRING   RegistryPath )
/*++

DriverEntry:
   entry function of the driver. setup the callbacks for the OS and try to
   initialize a device object for every device in the system

Arguments:
   DriverObject   context of the driver
   RegistryPath   path to the registry entry for the driver

Return Value:
   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL

--*/
{
//  SmartcardSetDebugLevel( DEBUG_DRIVER | DEBUG_TRACE );
   SmartcardDebug(
        DEBUG_DRIVER,
       ("------------------------------------------------------------------\n" )
       );

   SmartcardDebug(
        DEBUG_DRIVER,
       ("%s!DriverEntry: Enter - %s %s\n",
        DRIVER_NAME,
        __DATE__,
        __TIME__));

   SmartcardDebug(
        DEBUG_DRIVER,
       ("------------------------------------------------------------------\n" )
       );

   // tell the system our entry points
   DriverObject->MajorFunction[IRP_MJ_CREATE] =       StcUsbCreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLOSE] =           StcUsbCreateClose;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =  StcUsbDeviceIoControl;
   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] =  StcUsbSystemControl;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP]  =        StcUsbCleanup;
   DriverObject->MajorFunction[IRP_MJ_PNP]   =           StcUsbPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER] =          StcUsbPower;

   DriverObject->DriverExtension->AddDevice =            StcUsbAddDevice;
   DriverObject->DriverUnload =                    StcUsbUnloadDriver;

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!DriverEntry: Exit\n",
      DRIVER_NAME));

   return STATUS_SUCCESS;;
}

NTSTATUS
StcUsbAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject)
/*++

Routine Description:
   creates a new device object for the driver, allocates & initializes all
   neccessary structures (i.e. SmartcardExtension & ReaderExtension).

Arguments:
   DriverObject   context of call
   DeviceObject   ptr to the created device object

Return Value:
   STATUS_SUCCESS
   STATUS_INSUFFICIENT_RESOURCES
   status returned by smclib.sys

--*/
{
   NTSTATUS status;
   UNICODE_STRING DriverID;
   PDEVICE_OBJECT DeviceObject = NULL;
   PDEVICE_EXTENSION DeviceExtension = NULL;
   PREADER_EXTENSION ReaderExtension = NULL;
    PSMARTCARD_EXTENSION SmartcardExtension = NULL;
   UNICODE_STRING vendorNameU, ifdTypeU;
   ANSI_STRING vendorNameA, ifdTypeA;
   HANDLE regKey = NULL;
   DWORD    ReadPriority = -1;

   // this is a list of our supported data rates

    static ULONG dataRatesSupported[] = { 9600, 19200, 38400, 55800, 76800, 115200, 153600 };

   PAGED_CODE();

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbAddDevice: Enter\n",
      DRIVER_NAME));
    try
   {
       ULONG deviceInstance;
      RTL_QUERY_REGISTRY_TABLE parameters[4];
      RtlZeroMemory(parameters, sizeof(parameters));
      RtlZeroMemory(&vendorNameU, sizeof(vendorNameU));
      RtlZeroMemory(&ifdTypeU, sizeof(ifdTypeU));
      RtlZeroMemory(&vendorNameA, sizeof(vendorNameA));
      RtlZeroMemory(&ifdTypeA, sizeof(ifdTypeA));

       // Create the device object
       status = IoCreateDevice(
          DriverObject,
          sizeof(DEVICE_EXTENSION),
            NULL,
          FILE_DEVICE_SMARTCARD,
          0,
          TRUE,
          &DeviceObject);

        if (status != STATUS_SUCCESS)
      {
         SmartcardLogError(
            DriverObject,
            STCUSB_INSUFFICIENT_RESOURCES,
            NULL,
            0);

            __leave;
        }

       //   set up the device extension.
       DeviceExtension = DeviceObject->DeviceExtension;
        SmartcardExtension = &DeviceExtension->SmartcardExtension;
      SmartcardExtension->VendorAttr.UnitNo = MAXULONG;

      for (deviceInstance = 0; deviceInstance < MAXULONG; deviceInstance++) {

         PDEVICE_OBJECT devObj;

         for (devObj = DeviceObject;
             devObj != NULL;
             devObj = devObj->NextDevice) {

             PDEVICE_EXTENSION devExt = devObj->DeviceExtension;
             PSMARTCARD_EXTENSION smcExt = &devExt->SmartcardExtension;

             if (deviceInstance == smcExt->VendorAttr.UnitNo) {

                break;
             }
         }
         if (devObj == NULL) {

            SmartcardExtension->VendorAttr.UnitNo = deviceInstance;
             SmartcardExtension->ReaderCapabilities.Channel = deviceInstance;
            break;
         }
      }

      // Used to synchonize the smartcard detection polling
      // with the the IO Control routine
      KeInitializeMutex(
         &DeviceExtension->hMutex,
         1);

      // Used for stop / start notification
      KeInitializeEvent(
         &DeviceExtension->ReaderStarted,
         NotificationEvent,
         FALSE);

      // Used to control the poll thread
      KeInitializeEvent(
          &DeviceExtension->FinishPollThread,
          NotificationEvent,
          FALSE
          );

      KeInitializeEvent(
          &DeviceExtension->PollThreadStopped,
          NotificationEvent,
          TRUE);

      DeviceExtension->PollWorkItem = IoAllocateWorkItem( DeviceObject );
      if( DeviceExtension->PollWorkItem == NULL )
      {
         status = STATUS_INSUFFICIENT_RESOURCES;
         __leave;
      }

      //   allocate the reader extension
      ReaderExtension = ExAllocatePool(NonPagedPool,
                                       sizeof( READER_EXTENSION ));

      if( ReaderExtension == NULL )
      {
         SmartcardLogError(
            DriverObject,
            STCUSB_INSUFFICIENT_RESOURCES,
            NULL,
            0);

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
      }

      RtlZeroMemory( ReaderExtension, sizeof( READER_EXTENSION ));

      SmartcardExtension->ReaderExtension = ReaderExtension;
      SmartcardExtension->ReaderExtension->DeviceObject = DeviceObject;

          // allocate the extension buffer      CB_09/02/01
          SmartcardExtension->ReaderExtension->pExtBuffer = ExAllocatePool(NonPagedPool,
                                                                       MIN_BUFFER_SIZE);
          
          if (NULL == SmartcardExtension->ReaderExtension->pExtBuffer)
          {
                  SmartcardLogError(
                                DriverObject,
                                STCUSB_INSUFFICIENT_RESOURCES,
                                NULL,
                                0);
                  status = STATUS_INSUFFICIENT_RESOURCES;
                  __leave;
          }

          // allocate the URB CB_09/02/01
          SmartcardExtension->ReaderExtension->pUrb = ExAllocatePool(NonPagedPool,
                                                                 sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER ));
          if (NULL == SmartcardExtension->ReaderExtension->pUrb)
          {
                  SmartcardLogError(
                                DriverObject,
                                STCUSB_INSUFFICIENT_RESOURCES,
                                NULL,
                                0);
                  status = STATUS_INSUFFICIENT_RESOURCES;
                  __leave;
          }


       //   setup smartcard extension - callback's
       SmartcardExtension->ReaderFunction[RDF_CARD_POWER] = CBCardPower;
       SmartcardExtension->ReaderFunction[RDF_TRANSMIT] =      CBTransmit;
       SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] = CBCardTracking;
       SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] =  CBSetProtocol;

       //   setup smartcard extension - vendor attribute
       RtlCopyMemory(
          SmartcardExtension->VendorAttr.VendorName.Buffer,
          STCUSB_VENDOR_NAME,
          sizeof( STCUSB_VENDOR_NAME ));

       SmartcardExtension->VendorAttr.VendorName.Length =
            sizeof( STCUSB_VENDOR_NAME );

       RtlCopyMemory(
          SmartcardExtension->VendorAttr.IfdType.Buffer,
          STCUSB_PRODUCT_NAME,
          sizeof( STCUSB_PRODUCT_NAME ));
       SmartcardExtension->VendorAttr.IfdType.Length =
          sizeof( STCUSB_PRODUCT_NAME );

       SmartcardExtension->VendorAttr.IfdVersion.BuildNumber = 0;

       //   store firmware revision in ifd version
       SmartcardExtension->VendorAttr.IfdVersion.VersionMajor =
          ReaderExtension->FirmwareMajor;
       SmartcardExtension->VendorAttr.IfdVersion.VersionMinor =
          ReaderExtension->FirmwareMinor;
       SmartcardExtension->VendorAttr.IfdSerialNo.Length = 0;

       //   setup smartcard extension - reader capabilities
       SmartcardExtension->ReaderCapabilities.SupportedProtocols =
          SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
       SmartcardExtension->ReaderCapabilities.ReaderType =
          SCARD_READER_TYPE_USB;
       SmartcardExtension->ReaderCapabilities.MechProperties = 0;

      // Clk frequency in KHz encoded as little endian integer
      SmartcardExtension->ReaderCapabilities.CLKFrequency.Default = 3571;
      SmartcardExtension->ReaderCapabilities.CLKFrequency.Max = 3571;

      // reader could support higher data rates
      SmartcardExtension->ReaderCapabilities.DataRatesSupported.List =
         dataRatesSupported;
      SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
         sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);

          SmartcardExtension->ReaderCapabilities.DataRate.Default =dataRatesSupported[0];
          SmartcardExtension->ReaderCapabilities.DataRate.Max = 
                        dataRatesSupported[SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries -1];


       //   enter correct version of the lib
       SmartcardExtension->Version = SMCLIB_VERSION;
       SmartcardExtension->SmartcardRequest.BufferSize   = MIN_BUFFER_SIZE;
       SmartcardExtension->SmartcardReply.BufferSize  = MIN_BUFFER_SIZE;

       SmartcardExtension->ReaderCapabilities.MaxIFSD    = 252; 

        SmartcardExtension->ReaderExtension->ReaderPowerState =
            PowerReaderWorking;

       status = SmartcardInitialize(SmartcardExtension);

        if (status != STATUS_SUCCESS)
      {
         SmartcardLogError(
            DriverObject,
            STCUSB_INSUFFICIENT_RESOURCES,
            NULL,
            0);

            __leave;
        }

      // tell the lib our device object
      SmartcardExtension->OsData->DeviceObject = DeviceObject;

      DeviceExtension->AttachedPDO = IoAttachDeviceToDeviceStack(
            DeviceObject,
            PhysicalDeviceObject);

        ASSERT(DeviceExtension->AttachedPDO != NULL);

        if (DeviceExtension->AttachedPDO == NULL)
      {
            status = STATUS_UNSUCCESSFUL;
            __leave;
        }

      // register our new device
      status = IoRegisterDeviceInterface(
         PhysicalDeviceObject,
         &SmartCardReaderGuid,
         NULL,
         &DeviceExtension->DeviceName);

      ASSERT(status == STATUS_SUCCESS);

      DeviceObject->Flags |= DO_BUFFERED_IO;
      DeviceObject->Flags |= DO_POWER_PAGABLE;
      DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
      //
      // try to read the reader name from the registry
      // if that does not work, we will use the default
      // (hardcoded) name
      //
      if (IoOpenDeviceRegistryKey(
         PhysicalDeviceObject,
         PLUGPLAY_REGKEY_DEVICE,
         KEY_READ,
         &regKey
         ) != STATUS_SUCCESS) {

         __leave;
      }

      parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[0].Name = L"VendorName";
      parameters[0].EntryContext = &vendorNameU;
      parameters[0].DefaultType = REG_SZ;
      parameters[0].DefaultData = &vendorNameU;
      parameters[0].DefaultLength = 0;

      parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[1].Name = L"IfdType";
      parameters[1].EntryContext = &ifdTypeU;
      parameters[1].DefaultType = REG_SZ;
      parameters[1].DefaultData = &ifdTypeU;
      parameters[1].DefaultLength = 0;

      parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[2].Name = L"ReadPriorityBoost";
      parameters[2].EntryContext = &ReadPriority;
      parameters[2].DefaultType = REG_DWORD;
      parameters[2].DefaultData = 0;
      parameters[2].DefaultLength = 0;


      if (RtlQueryRegistryValues(
          RTL_REGISTRY_HANDLE,
          (PWSTR) regKey,
          parameters,
          NULL,
          NULL
          ) != STATUS_SUCCESS) {

         __leave;
      }

      if (ReadPriority > 0) {

          SmartcardDebug(
             DEBUG_TRACE,
             ( "%s!StcUsbAddDevice: Setting priority: 0x%x\n",
             DRIVER_NAME,
             ReadPriority));

          SmartcardExtension->ReaderExtension->Chosen_Priority = (LONG) ReadPriority;

      } else {

          SmartcardExtension->ReaderExtension->Chosen_Priority = -1;
          SmartcardDebug(
             DEBUG_TRACE,
             ( "%s!StcUsbAddDevice: Leaving priority: 0x%x\n",
             DRIVER_NAME,
             ReadPriority));


      }

      if (RtlUnicodeStringToAnsiString(
         &vendorNameA,
         &vendorNameU,
         TRUE
         ) != STATUS_SUCCESS) {

         __leave;
      }

      if (RtlUnicodeStringToAnsiString(
         &ifdTypeA,
         &ifdTypeU,
         TRUE
         ) != STATUS_SUCCESS) {

         __leave;
      }

      if (vendorNameA.Length == 0 ||
         vendorNameA.Length > MAXIMUM_ATTR_STRING_LENGTH ||
         ifdTypeA.Length == 0 ||
         ifdTypeA.Length > MAXIMUM_ATTR_STRING_LENGTH) {

         __leave;
      }

      RtlCopyMemory(
         SmartcardExtension->VendorAttr.VendorName.Buffer,
         vendorNameA.Buffer,
         vendorNameA.Length
         );
      SmartcardExtension->VendorAttr.VendorName.Length =
         vendorNameA.Length;
      RtlCopyMemory(
         SmartcardExtension->VendorAttr.IfdType.Buffer,
         ifdTypeA.Buffer,
         ifdTypeA.Length
         );
      SmartcardExtension->VendorAttr.IfdType.Length =
         ifdTypeA.Length;
    }
    __finally
   {
      if (vendorNameU.Buffer) {

         RtlFreeUnicodeString(&vendorNameU);
      }

      if (ifdTypeU.Buffer) {

         RtlFreeUnicodeString(&ifdTypeU);
      }

      if (vendorNameA.Buffer) {

         RtlFreeAnsiString(&vendorNameA);
      }

      if (ifdTypeA.Buffer) {

         RtlFreeAnsiString(&ifdTypeA);
      }

      if (regKey != NULL) {

         ZwClose(regKey);
      }

        if (status != STATUS_SUCCESS)
      {
            StcUsbUnloadDevice(DeviceObject);
        }

       SmartcardDebug(
          DEBUG_TRACE,
          ( "%s!StcUsbAddDevice: Exit %x\n",
         DRIVER_NAME,
          status ));
    }
    return status;
}


NTSTATUS
StcUsbStartDevice(
   PDEVICE_OBJECT DeviceObject
   )
/*++

Routine Description:
   get the actual configuration from the USB communication layer
   and initializes the reader hardware

Arguments:
   DeviceObject         context of call

Return Value:
   STATUS_SUCCESS
   status returned by LowLevel routines

--*/
{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &DeviceExtension->SmartcardExtension;
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS NtStatus = STATUS_NO_MEMORY;

    PURB pUrb = NULL;

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!StcUsbStartDevice: Enter\n",
      DRIVER_NAME));

   __try {

      // Initialize the USB interface
      pUrb = ExAllocatePool(
         NonPagedPool,
         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)
         );

      if(pUrb == NULL)
      {
         __leave;

      }

      DeviceExtension->DeviceDescriptor = ExAllocatePool(
         NonPagedPool,
         sizeof(USB_DEVICE_DESCRIPTOR)
         );

      if(DeviceExtension->DeviceDescriptor == NULL)
      {
         __leave;
      }

      UsbBuildGetDescriptorRequest(
         pUrb,
         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
         USB_DEVICE_DESCRIPTOR_TYPE,
         0,
         0,
         DeviceExtension->DeviceDescriptor,
         NULL,
         sizeof(USB_DEVICE_DESCRIPTOR),
         NULL
         );

      // Send the urb to the USB driver
      NtStatus = UsbCallUSBD(DeviceObject, pUrb);

      if(NtStatus != STATUS_SUCCESS)
      {
         __leave;
      }

      NtStatus = UsbConfigureDevice(DeviceObject);

      if (!NT_SUCCESS(NtStatus)) {

          __leave;

      }

      ReaderExtension->ulReadBufferLen = 0;

      // setup the STC registers
      NtStatus = STCConfigureSTC(
            SmartcardExtension->ReaderExtension,
            ( PSTC_REGISTER ) STCInitialize
            );

        if (NtStatus != STATUS_SUCCESS)
      {
          SmartcardLogError(
             DeviceObject,
             STCUSB_CANT_INITIALIZE_READER,
             NULL,
             0);

            __leave;
        }

      UsbGetFirmwareRevision(SmartcardExtension->ReaderExtension);
       //   store firmware revision in ifd version
       SmartcardExtension->VendorAttr.IfdVersion.VersionMajor =
          ReaderExtension->FirmwareMajor;
       SmartcardExtension->VendorAttr.IfdVersion.VersionMinor =
          ReaderExtension->FirmwareMinor;

      // CBUpdateCardState(SmartcardExtension );


        NtStatus = IoSetDeviceInterfaceState(
         &DeviceExtension->DeviceName,
         TRUE
         );

      if (NtStatus == STATUS_OBJECT_NAME_EXISTS)
      {
         // We tried to re-enable the device which is ok
         // This can happen after a stop - start sequence
         NtStatus = STATUS_SUCCESS;
      }

        // signal that the reader has been started
        KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);

        // start polling the device for card movement detection
        StcUsbStartPollThread( DeviceExtension );


      ASSERT(NtStatus == STATUS_SUCCESS);
    }
    finally
   {
      if (pUrb != NULL)
      {
         ExFreePool(pUrb);
      }

        if (NtStatus != STATUS_SUCCESS)
        {
            StcUsbStopDevice(DeviceObject);
        }

        SmartcardDebug(
           DEBUG_TRACE,
           ( "%s!StcUsbStartDevice: Exit %x\n",
         DRIVER_NAME,
           NtStatus ));
    }
    return NtStatus;
}



VOID
StcUsbStopDevice(
   PDEVICE_OBJECT DeviceObject)
/*++

Routine Description:
    Finishes card tracking requests and closes the connection to the
    Usb port.

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS status;
   LARGE_INTEGER delayPeriod;

    if (DeviceObject == NULL)
   {
        return;
    }

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbStopDevice: Enter\n",
      DRIVER_NAME));

    DeviceExtension = DeviceObject->DeviceExtension;

    KeClearEvent(&DeviceExtension->ReaderStarted);

   // stop polling the reader
   StcUsbStopPollThread( DeviceExtension );

   if (DeviceExtension->DeviceDescriptor)
   {
      ExFreePool(DeviceExtension->DeviceDescriptor);
      DeviceExtension->DeviceDescriptor = NULL;
   }

   if (DeviceExtension->Interface)
   {
      ExFreePool(DeviceExtension->Interface);
      DeviceExtension->Interface = NULL;
   }

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbStopDevice: Exit\n",
      DRIVER_NAME));
}

NTSTATUS
StcUsbSystemControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   )
{
   PDEVICE_EXTENSION DeviceExtension; 
   NTSTATUS status = STATUS_SUCCESS;

   DeviceExtension      = DeviceObject->DeviceExtension;

   IoSkipCurrentIrpStackLocation(Irp);
   status = IoCallDriver(DeviceExtension->AttachedPDO, Irp);
      
   return status;

}

NTSTATUS
StcUsbDeviceIoControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp)
/*++

StcUsbDeviceIoControl:
   all IRP's requiring IO are queued to the StartIo routine, other requests
   are served immediately

--*/
{
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    KIRQL irql;
    LARGE_INTEGER timeout;
    PSMARTCARD_EXTENSION SmartcardExtension = &deviceExtension->SmartcardExtension;
   PREADER_EXTENSION ReaderExtension= SmartcardExtension->ReaderExtension;


    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    if (deviceExtension->IoCount < 0)
   {
        KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
        status = KeWaitForSingleObject(
            &deviceExtension->ReaderStarted,
            Executive,
            KernelMode,
            FALSE,
            NULL);

        KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    }
    ASSERT(deviceExtension->IoCount >= 0);
    deviceExtension->IoCount++;
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    status = SmartcardAcquireRemoveLock(&deviceExtension->SmartcardExtension);

    if (status != STATUS_SUCCESS)
   {

        // the device has been removed. Fail the call
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }

    KeWaitForMutexObject(
        &deviceExtension->hMutex,
        Executive,
        KernelMode,
        FALSE,
      NULL);

   status = SmartcardDeviceControl(
      &(deviceExtension->SmartcardExtension),
      Irp);

    KeReleaseMutex(
      &deviceExtension->hMutex,
      FALSE);

    SmartcardReleaseRemoveLock(&deviceExtension->SmartcardExtension);

    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    deviceExtension->IoCount--;
    ASSERT(deviceExtension->IoCount >= 0);
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    return status;
}
NTSTATUS
StcUsbCallComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event)
/*++

Routine Description:
   Completion routine for an Irp sent to the Usb driver. The event will
   be set to notify that the Usb driver is done. The routine will not
   'complete' the Irp, so the caller of CallUsbDriver can continue.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    if (Irp->Cancel)
   {
        Irp->IoStatus.Status = STATUS_CANCELLED;
    }

    KeSetEvent (Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
StcUsbCallUsbDriver(
    IN PDEVICE_OBJECT AttachedPDO,
    IN PIRP Irp)

/*++

Routine Description:
   Send an Irp to the Usb driver.

--*/
{
   NTSTATUS NtStatus = STATUS_SUCCESS;
    KEVENT Event;

    // Copy our stack location to the next.
    IoCopyCurrentIrpStackLocationToNext(Irp);

   //
   // initialize an event for process synchronization. the event is passed
   // to our completion routine and will be set if the pcmcia driver is done
   //
    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE);

    // Our IoCompletionRoutine sets only our event
    IoSetCompletionRoutine (
        Irp,
        StcUsbCallComplete,
        &Event,
        TRUE,
        TRUE,
        TRUE);

    if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER)
   {
      NtStatus = PoCallDriver(AttachedPDO, Irp);
    }
   else
   {
      NtStatus = IoCallDriver(AttachedPDO, Irp);
    }

   // Wait until the usb driver has processed the Irp
    if (NtStatus == STATUS_PENDING)
   {
        NtStatus = KeWaitForSingleObject(
            &Event,
            Executive,
            KernelMode,
            FALSE,
            NULL);

      if (NtStatus == STATUS_SUCCESS)
      {
         NtStatus = Irp->IoStatus.Status;
      }
   }

   return(NtStatus);
}




NTSTATUS
StcUsbPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
/*++

Routine Description:
   driver callback for pnp manager
   All other requests will be passed to the usb driver to ensure correct processing.

--*/
{

   NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension = &DeviceExtension->SmartcardExtension;
   PIO_STACK_LOCATION IrpStack;
    PDEVICE_OBJECT AttachedPDO;
    BOOLEAN deviceRemoved = FALSE;
    KIRQL irql;

    PAGED_CODE();

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbPnP: Enter\n",
      DRIVER_NAME));

    status = SmartcardAcquireRemoveLock(SmartcardExtension);

    if (status != STATUS_SUCCESS)
   {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    AttachedPDO = DeviceExtension->AttachedPDO;

//   Irp->IoStatus.Information = 0;
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

    // Now look what the PnP manager wants...
   switch(IrpStack->MinorFunction)
   {
      case IRP_MN_START_DEVICE:

            // Now we should connect to our resources (Irql, Io etc.)
         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_START_DEVICE\n",
            DRIVER_NAME));

            // We have to call the underlying driver first
            status = StcUsbCallUsbDriver(AttachedPDO, Irp);
            
            if (NT_SUCCESS(status))
         {
                status = StcUsbStartDevice(DeviceObject);

         }
         break;

        case IRP_MN_QUERY_STOP_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_QUERY_STOP_DEVICE\n",
            DRIVER_NAME));
            KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);
            if (DeviceExtension->IoCount > 0)
         {
                // we refuse to stop if we have pending io
                KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
                status = STATUS_DEVICE_BUSY;

            }
         else
         {
             // stop processing requests
                DeviceExtension->IoCount = -1;
                KeClearEvent(&DeviceExtension->ReaderStarted);
                KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
                status = StcUsbCallUsbDriver(AttachedPDO, Irp);
            }
         break;

        case IRP_MN_CANCEL_STOP_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_CANCEL_STOP_DEVICE\n",
            DRIVER_NAME));

            status = StcUsbCallUsbDriver(AttachedPDO, Irp);

            // we can continue to process requests
            DeviceExtension->IoCount = 0;
            KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);
         break;

      case IRP_MN_STOP_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_STOP_DEVICE\n",
            DRIVER_NAME));

            StcUsbStopDevice(DeviceObject);
            status = StcUsbCallUsbDriver(AttachedPDO, Irp);
         break;

      case IRP_MN_QUERY_REMOVE_DEVICE:

            // Remove our device
         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_QUERY_REMOVE_DEVICE\n",
            DRIVER_NAME));

         // disable the reader
         status = IoSetDeviceInterfaceState(
            &DeviceExtension->DeviceName,
            FALSE);
         ASSERT(status == STATUS_SUCCESS);

         if (status != STATUS_SUCCESS)
         {
            break;
         }

         // check if the reader has been opened
            if (DeviceExtension->ReaderOpen)
         {
            // someone is connected, enable the reader and fail the call
            IoSetDeviceInterfaceState(
               &DeviceExtension->DeviceName,
               TRUE);
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            // pass the call to the next driver in the stack
            status = StcUsbCallUsbDriver(AttachedPDO, Irp);
         break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            // Removal of device has been cancelled
         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_CANCEL_REMOVE_DEVICE\n",
            DRIVER_NAME));

            // pass the call to the next driver in the stack
            status = StcUsbCallUsbDriver(AttachedPDO, Irp);

            if (status == STATUS_SUCCESS)
         {
            status = IoSetDeviceInterfaceState(
               &DeviceExtension->DeviceName,
               TRUE);
            }
         break;

      case IRP_MN_REMOVE_DEVICE:

            // Remove our device
         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_REMOVE_DEVICE\n",
            DRIVER_NAME));

            StcUsbStopDevice(DeviceObject);
            StcUsbUnloadDevice(DeviceObject);

            status = StcUsbCallUsbDriver(AttachedPDO, Irp);
            deviceRemoved = TRUE;
         break;

      default:
         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_...%lx\n",
                DRIVER_NAME,
                IrpStack->MinorFunction));
            // This is an Irp that is only useful for underlying drivers
            status = StcUsbCallUsbDriver(AttachedPDO, Irp);
         break;
   }

   Irp->IoStatus.Status = status;

    IoCompleteRequest(
        Irp,
        IO_NO_INCREMENT);

    if (deviceRemoved == FALSE)
   {
        SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);
    }

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbPnP: Exit %x\n",
      DRIVER_NAME,
        status));

    return status;
}

VOID
StcUsbSystemPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    This function is called when the underlying stacks
    completed the power transition.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (PowerState);
    UNREFERENCED_PARAMETER (IoStatus);

    KeSetEvent(Event, 0, FALSE);
}

NTSTATUS
StcUsbDevicePowerCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension)
/*++

Routine Description:
    This routine is called after the underlying stack powered
    UP the Usb port, so it can be used again.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS status;
    UCHAR state;
    BOOLEAN CardPresent;

   //
   // setup the STC registers
   //
   status = STCConfigureSTC(
        SmartcardExtension->ReaderExtension,
        ( PSTC_REGISTER ) STCInitialize
        );

    // get the current state of the card
    CBUpdateCardState(SmartcardExtension);

    // save the current power state of the reader
    SmartcardExtension->ReaderExtension->ReaderPowerState =
        PowerReaderWorking;

    SmartcardReleaseRemoveLock(SmartcardExtension);

    // inform the power manager of our state.
    PoSetPowerState (
        DeviceObject,
        DevicePowerState,
        irpStack->Parameters.Power.State);

    PoStartNextPowerIrp(Irp);

    KeSetEvent(&deviceExtension->ReaderStarted,
               0,
               FALSE);

    // restart the polling thread
    StcUsbStartPollThread( deviceExtension );

    return STATUS_SUCCESS;
}

typedef enum _ACTION {

    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending

} ACTION;

NTSTATUS
StcUsbPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
/*++

Routine Description:
    The power dispatch routine.
    This driver is the power policy owner of the device stack,
    because this driver knows about the connected reader.
    Therefor this driver will translate system power states
    to device power states.

Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT status code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    ACTION action;
    POWER_STATE powerState;
   KEVENT event;
   KIRQL    irql;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!StcUsbPower: Enter\n",
      DRIVER_NAME));

    status = SmartcardAcquireRemoveLock(smartcardExtension);


    if (!NT_SUCCESS(status))
   {
        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

   switch (irpStack->Parameters.Power.Type) {
   case DevicePowerState:
      if (irpStack->MinorFunction == IRP_MN_SET_POWER) {

         switch (irpStack->Parameters.Power.State.DeviceState) {

         case PowerDeviceD0:
            // Turn on the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!StcUsbPower: PowerDevice D0\n",
                           DRIVER_NAME));

            //
            // First, we send down the request to the bus, in order
            // to power on the port. When the request completes,
            // we turn on the reader
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine (
                                   Irp,
                                   StcUsbDevicePowerCompletion,
                                   smartcardExtension,
                                   TRUE,
                                   TRUE,
                                   TRUE);
            action = WaitForCompletion;
            break;

         case PowerDeviceD3:
            // Turn off the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!StcUsbPower: PowerDevice D3\n",
                           DRIVER_NAME));

            KeClearEvent(&deviceExtension->ReaderStarted);

            StcUsbStopPollThread( deviceExtension );

            PoSetPowerState (
                            DeviceObject,
                            DevicePowerState,
                            irpStack->Parameters.Power.State);

            // save the current card state
            KeAcquireSpinLock(&smartcardExtension->OsData->SpinLock,
                              &irql);
            smartcardExtension->ReaderExtension->CardPresent =
            smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;

            // power down the card
            if (smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT ) {
               KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                 irql);
               smartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
               status = CBCardPower(smartcardExtension);
               //
               // This will trigger the card monitor, since we do not really
               // know if the user will remove / re-insert a card while the
               // system is asleep
               //
            } else {
               KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                 irql);
            }
            status = STCConfigureSTC(
                                    smartcardExtension->ReaderExtension,
                                    ( PSTC_REGISTER ) STCClose
                                    );

            // save the current power state of the reader
            smartcardExtension->ReaderExtension->ReaderPowerState =
            PowerReaderOff;

            action = SkipRequest;
            break;

         default:
            action = SkipRequest;
            break;
         }
      } else {

         action = SkipRequest;
      }
      break;

   case SystemPowerState: {
         //
         // The system wants to change the power state.
         // We need to translate the system power state to
         // a corresponding device power state.
         //

         POWER_STATE_TYPE powerType = DevicePowerState;
         
         ASSERT(smartcardExtension->ReaderExtension->ReaderPowerState !=
                PowerReaderUnspecified);

         switch (irpStack->MinorFunction) {

         case IRP_MN_QUERY_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!StcUsbPower: Query Power\n",
                           DRIVER_NAME));

            //
            // By default we succeed and pass down
            //

            action = SkipRequest;
            Irp->IoStatus.Status = STATUS_SUCCESS;

            switch (irpStack->Parameters.Power.State.SystemState) {

            case PowerSystemMaximum:
            case PowerSystemWorking:
               break;
            
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:
               KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
               if (deviceExtension->IoCount == 0) {

                  // Block any further ioctls
//                  KeClearEvent(&deviceExtension->ReaderStarted);

               } else {

                  // can't go to sleep mode since the reader is busy.
                  status = STATUS_DEVICE_BUSY;
                  action = CompleteRequest;
               }
               KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
               break;
            }
            break;

         case IRP_MN_SET_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!StcUsbPower: PowerSystem S%d\n",
                           DRIVER_NAME,
                           irpStack->Parameters.Power.State.SystemState - 1));

            switch (irpStack->Parameters.Power.State.SystemState) {

            case PowerSystemMaximum:
            case PowerSystemWorking:

               if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                   PowerReaderWorking) {

                  // We're already in the right state
                  KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
                  action = SkipRequest;
                  break;
               }

               powerState.DeviceState = PowerDeviceD0;
               action = MarkPending;
               break;

            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:

               if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                   PowerReaderOff) {
                  // We're already in the right state
                  action = SkipRequest;
                  break;
               }

               powerState.DeviceState = PowerDeviceD3;

               // first, inform the power manager of our new state.
               PoSetPowerState (
                               DeviceObject,
                               SystemPowerState,
                               powerState);

               action = MarkPending;
               break;

            default:
               action = SkipRequest;
               break;
            }
            break;
         default:
            action = SkipRequest;
            break;
         }
      }
      break;

   default:
      action = SkipRequest;
      break;
   }

    switch (action)
   {
        case CompleteRequest:
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;

            SmartcardReleaseRemoveLock(smartcardExtension);
            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
         break;

        case MarkPending:
         // initialize the event we need in the completion function
         KeInitializeEvent(
            &event,
            NotificationEvent,
            FALSE
            );
         // request the device power irp
         status = PoRequestPowerIrp (
            DeviceObject,
            IRP_MN_SET_POWER,
            powerState,
            StcUsbSystemPowerCompletion,
            &event,
            NULL
            );


         if (status == STATUS_PENDING) {

            // wait until the device power irp completed
            status = KeWaitForSingleObject(
               &event,
               Executive,
               KernelMode,
               FALSE,
               NULL
               );

            SmartcardReleaseRemoveLock(smartcardExtension);

            if (powerState.SystemState == PowerSystemWorking) {

               PoSetPowerState (
                  DeviceObject,
                  SystemPowerState,
                  powerState
                  );
            }

            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->AttachedPDO, Irp);

         } else {

            SmartcardReleaseRemoveLock(smartcardExtension);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
         }
         break;

        case SkipRequest:
            SmartcardReleaseRemoveLock(smartcardExtension);
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->AttachedPDO, Irp);
         break;

        case WaitForCompletion:
            status = PoCallDriver(deviceExtension->AttachedPDO, Irp);
         break;

        default:
            break;
    }
    return status;
}

NTSTATUS
StcUsbCreateClose(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   )
/*++

Routine Description:

    This routine is called by the I/O system when the device is opened or closed.

Arguments:
   DeviceObject   context of device
   Irp            context of call

Return Value:
   STATUS_SUCCESS
   STATUS_DEVICE_BUSY

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!StcCreateClose: Enter\n",
      DRIVER_NAME));

   __try {

      if (irpStack->MajorFunction == IRP_MJ_CREATE) {

         status = SmartcardAcquireRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );

         if (status != STATUS_SUCCESS) {

            status = STATUS_DEVICE_REMOVED;
            __leave;
         }

         // test if the device has been opened already
         if (InterlockedCompareExchange(
            &deviceExtension->ReaderOpen,
            TRUE,
            FALSE) == FALSE) {

            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!StcCreateClose: Open\n",
               DRIVER_NAME)
               );

         } else {

            // the device is already in use
            status = STATUS_UNSUCCESSFUL;

            // release the lock
            SmartcardReleaseRemoveLockWithTag(
               &deviceExtension->SmartcardExtension,
               'lCrC'
               );
         }

      } else {

         SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!StcCreateClose: Close\n",
            DRIVER_NAME)
            );

         SmartcardReleaseRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );

         deviceExtension->ReaderOpen = FALSE;
      }
   }
   __finally {

      Irp->IoStatus.Status = status;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
   }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!StcCreateClose: Exit (%lx)\n",
      DRIVER_NAME,
      status));

   return status;
}


NTSTATUS
StcUsbCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!StcUsbCancel: Enter\n",
        DRIVER_NAME));

    ASSERT(Irp == smartcardExtension->OsData->NotificationIrp);

   Irp->IoStatus.Information  = 0;
   Irp->IoStatus.Status    = STATUS_CANCELLED;

   smartcardExtension->OsData->NotificationIrp = NULL;

    IoReleaseCancelSpinLock(
        Irp->CancelIrql);

   IoCompleteRequest(
      Irp,
      IO_NO_INCREMENT);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!StcUsbCancel: Exit\n",
        DRIVER_NAME));

    return STATUS_CANCELLED;
}

NTSTATUS
StcUsbCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when the calling thread terminates

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
   NTSTATUS status = STATUS_SUCCESS;
    KIRQL CancelIrql;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!StcUsbCleanup: Enter\n",
        DRIVER_NAME));

   IoAcquireCancelSpinLock(&CancelIrql);

   // cancel pending notification irps
   if( smartcardExtension->OsData->NotificationIrp )
   {
        // reset the cancel function so that it won't be called anymore
        IoSetCancelRoutine(
            smartcardExtension->OsData->NotificationIrp,
            NULL
            );

        smartcardExtension->OsData->NotificationIrp->CancelIrql =
            CancelIrql;

        StcUsbCancel(
            DeviceObject,
            smartcardExtension->OsData->NotificationIrp);

   } else {

        IoReleaseCancelSpinLock(CancelIrql);
    }

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!StcUsbCleanup: Completing IRP %lx\n",
        DRIVER_NAME,
        Irp));

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

   IoCompleteRequest(
      Irp,
      IO_NO_INCREMENT);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!StcUsbCleanup: Exit\n",
        DRIVER_NAME));

    return STATUS_SUCCESS;
}


VOID
StcUsbUnloadDevice(
   PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:
   close connections to smclib.sys and the usb driver, delete symbolic
   link and mark the slot as unused.


Arguments:
   DeviceObject   device to unload

Return Value:
   void

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
    NTSTATUS status;

    if (DeviceObject == NULL)
   {
        return;
    }

   DeviceExtension= DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbUnloadDevice: Enter\n",
      DRIVER_NAME));

    KeWaitForMutexObject(
        &DeviceExtension->hMutex,
        Executive,
        KernelMode,
        FALSE,
      NULL);

   KeReleaseMutex(
      &DeviceExtension->hMutex,
      FALSE);

   // free polling resources
   if( DeviceExtension->PollWorkItem != NULL )
   {
      IoFreeWorkItem( DeviceExtension->PollWorkItem );
      DeviceExtension->PollWorkItem = NULL;

   }


   // disable our device so no one can open it
   IoSetDeviceInterfaceState(
      &DeviceExtension->DeviceName,
      FALSE);

   // report to the lib that the device will be unloaded
   if(SmartcardExtension->OsData != NULL)
   {
      ASSERT(SmartcardExtension->OsData->NotificationIrp == NULL);
      SmartcardReleaseRemoveLockAndWait(SmartcardExtension);
   }

   // delete the symbolic link
   if( DeviceExtension->DeviceName.Buffer != NULL )
   {
      RtlFreeUnicodeString(&DeviceExtension->DeviceName);
      DeviceExtension->DeviceName.Buffer = NULL;
   }

   if( SmartcardExtension->OsData != NULL )
   {
      SmartcardExit( SmartcardExtension );
   }

        // free extension buffer CB_09/02/01
        if (NULL != SmartcardExtension->ReaderExtension->pExtBuffer)
        {
                ExFreePool(SmartcardExtension->ReaderExtension->pExtBuffer);
                SmartcardExtension->ReaderExtension->pExtBuffer = NULL;
        }

        if (NULL != SmartcardExtension->ReaderExtension->pUrb)
        {
                ExFreePool(SmartcardExtension->ReaderExtension->pUrb);
                SmartcardExtension->ReaderExtension->pUrb = NULL;
        }


    if (DeviceExtension->SmartcardExtension.ReaderExtension != NULL)
   {
        ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension);
        DeviceExtension->SmartcardExtension.ReaderExtension = NULL;
    }

    // Detach from the usb driver
    if (DeviceExtension->AttachedPDO)
   {
      IoDetachDevice(DeviceExtension->AttachedPDO);
        DeviceExtension->AttachedPDO = NULL;
    }

   // delete the device object
   IoDeleteDevice(DeviceObject);

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbUnloadDevice: Exit\n",
      DRIVER_NAME));
}

VOID
StcUsbUnloadDriver(
   PDRIVER_OBJECT DriverObject)
/*++

Description:
   unloads all devices for a given driver object

Arguments:
   DriverObject   context of driver

--*/
{
   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbUnloadDriver\n",
      DRIVER_NAME));
}

void
SysDelay(
   ULONG Timeout
   )
/*++

SysDelay:
   performs a required delay.

Arguments:
   Timeout     delay in milli seconds

Return Value:
   void

--*/
{
   LARGE_INTEGER  SysTimeout;

   SysTimeout.QuadPart = (LONGLONG)-10 * 1000 * Timeout;

   // KeDelayExecutionThread: counted in 100 ns
   KeDelayExecutionThread( KernelMode, FALSE, &SysTimeout );
}


VOID 
StcUsbCardDetectionThread(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_EXTENSION DeviceExtension)
/*++

StcUsbCardDetectionThread:
    create the card detection thread
Arguments:
    SmartcardExtension  context of call

Return Value:
    -

--*/
{
   NTSTATUS                NTStatus = STATUS_SUCCESS;
   PSMARTCARD_EXTENSION    SmartcardExtension  = &DeviceExtension->SmartcardExtension;
   LARGE_INTEGER           Timeout;

   SmartcardDebug( 
      DEBUG_TRACE, 
      ("%s!StcUsbCardDetectionThread\n",
      DRIVER_NAME));

   __try
   {

      if (!KeReadStateEvent(&DeviceExtension->ReaderStarted)) {

          __leave;

      }
      NTStatus = SmartcardAcquireRemoveLock(SmartcardExtension);

      if( NTStatus == STATUS_DELETE_PENDING )
         __leave;

      // wait for the mutex shared with the deviceiocontrol routine
      NTStatus = KeWaitForMutexObject(
         &DeviceExtension->hMutex,
         Executive,
         KernelMode,
         FALSE,
         NULL);
        
      if( NTStatus != STATUS_SUCCESS )
         __leave;

      CBUpdateCardState(SmartcardExtension);

      KeReleaseMutex( &DeviceExtension->hMutex, FALSE );

      SmartcardReleaseRemoveLock(SmartcardExtension);

      Timeout.QuadPart = -10000 * POLLING_PERIOD; 

      NTStatus = KeWaitForSingleObject(         
         &DeviceExtension->FinishPollThread,
         Executive,
         KernelMode,
         FALSE,
         &Timeout
         );

      // thread stopped?
      if( NTStatus == STATUS_SUCCESS )
         __leave;

      // queue the work item again
      IoQueueWorkItem(
         DeviceExtension->PollWorkItem,
         StcUsbCardDetectionThread,
         DelayedWorkQueue,
         DeviceExtension
         );
    }
    __finally
    {
        if( NTStatus != STATUS_TIMEOUT )
        {
            SmartcardDebug( 
                DEBUG_TRACE, 
                ("%s!StcUsbCardDetectionThread Terminate polling thread\n",
                DRIVER_NAME));

            KeSetEvent( &DeviceExtension->PollThreadStopped, 0, FALSE);
        }
    }
    return;
}



NTSTATUS
StcUsbStartPollThread( PDEVICE_EXTENSION DeviceExtension )
{
   NTSTATUS    NTStatus = STATUS_SUCCESS;

   KeClearEvent( &DeviceExtension->FinishPollThread );
   KeClearEvent( &DeviceExtension->PollThreadStopped );

   // queue the work item again
   IoQueueWorkItem(
      DeviceExtension->PollWorkItem,
      StcUsbCardDetectionThread,
      DelayedWorkQueue,
      DeviceExtension
      );

   return( NTStatus );
}


VOID
StcUsbStopPollThread( PDEVICE_EXTENSION DeviceExtension )
{
   NTSTATUS    NTStatus = STATUS_SUCCESS;

   if( DeviceExtension->PollWorkItem )
   {
      //  notify the card detection thread to finish. This will kick the thread out of the wait
      KeSetEvent( &DeviceExtension->FinishPollThread, 0, FALSE );
      KeWaitForSingleObject(
          &DeviceExtension->PollThreadStopped,
          Executive,
          KernelMode,
          FALSE,
          0
          );
   }
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbccid\usbsccb.c ===
#include "usbsc.h"
#include "usbsccb.h"
#include "usbcom.h"
#include "usbutil.h"
#include "usbscnt.h"

#pragma warning( disable : 4242 4244)

CHAR* InMessages[] = {
    "RDR_to_PC_DataBlock",
    "RDR_to_PC_SlotStatus",
    "RDR_to_PC_Parameters",
    "RDR_to_PC_Escape",
    "RDR_to_PC_DataRateAndClockFrequency",
    "INVALID MESSAGE"
};

CHAR* OutMessages[] = {
    "INVALID MESSAGE",              // 0x60
    "PC_to_RDR_SetParameters",      // 0x61
    "PC_to_RDR_IccPowerOn",         // 0x62
    "PC_to_RDR_IccPowerOff",        // 0x63
    "INVALID MESSAGE",              // 0x64
    "PC_to_RDR_GetSlotStatus",      // 0x65
    "INVALID MESSAGE",              // 0x66
    "INVALID MESSAGE",              // 0x67
    "INVALID MESSAGE",              // 0x68
    "INVALID MESSAGE",              // 0x69
    "PC_to_RDR_Secure",             // 0x6a
    "PC_to_RDR_Escape",             // 0x6b
    "PC_to_RDR_GetParameters",      // 0x6c
    "PC_to_RDR_ResetParameters",    // 0x6d
    "PC_to_RDR_IccClock",           // 0x6e
    "PC_to_RDR_XfrBlock",           // 0x6f
    "INVALID MESSAGE",              // 0x70
    "PC_to_RDR_Mechanical",         // 0x71
    "PC_to_RDR_Abort",              // 0x72
    "PC_to_RDR_SetDataRateAndClockFrequency" // 0x73
};

UINT VoltMask[] = {
    0,                              // Auto
    1,                              // 5.0V
    2,                              // 3.0V
    4                               // 1.8V
};



CHAR* 
GetMessageName(
    BYTE MessageType
    )       
{
    CHAR* name;
    if (MessageType & 0x80) {
        // IN message
        MessageType -= 0x80;
        if (MessageType > 5) {
            MessageType = 5;
        }
        name = InMessages[MessageType];

    } else {
        MessageType -= 0x60;
        if (MessageType >= 20) {
            MessageType = 0;
        }
        name = OutMessages[MessageType];
    }

    return name;

}
NTSTATUS 
UsbScTransmit(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    RDF_TRANSMIT Callback function
    Called from smclib

Arguments:
    SmartcardExtension

Return Value:
    NT Status value

--*/
{

    NTSTATUS status = STATUS_SUCCESS;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScTransmit Enter\n",DRIVER_NAME ));
        
        switch( SmartcardExtension->CardCapabilities.Protocol.Selected )  {
        
        case SCARD_PROTOCOL_T0:
            status = UsbScT0Transmit( SmartcardExtension );
            break;

        case SCARD_PROTOCOL_T1:
            status = UsbScT1Transmit( SmartcardExtension );
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        }
        
    }

    __finally
    {
        
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScTransmit Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}


NTSTATUS 
UsbScSetProtocol(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    RDF_SET_PROTOCOL callback
    called from smclib

Arguments:

Return Value:

--*/
{

    NTSTATUS                    status = STATUS_UNSUCCESSFUL;
    UINT                        protocolMask;
    UINT                        protocol;
    PUSBSC_OUT_MESSAGE_HEADER   message = NULL;
    PROTOCOL_DATA_T0            *dataT0;
    PROTOCOL_DATA_T1            *dataT1;
    PSCARD_CARD_CAPABILITIES    cardCaps = NULL;
    PCLOCK_AND_DATA_RATE        cadData = NULL;
    PUCHAR                      response = NULL;
    PPPS_REQUEST                pPPS = NULL;
    PPS_REQUEST                 pps;
    UINT                        bytesToRead;
    KIRQL                       irql;
    

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSetProtocol Enter\n",DRIVER_NAME ));
        
        protocolMask    = SmartcardExtension->MinorIoControlCode;
        cardCaps        = &SmartcardExtension->CardCapabilities;

        SmartcardDebug( DEBUG_PROTOCOL, ("%s : Setting Protocol\n",DRIVER_NAME ));

        // Modify protocolMask to those protocols that the reader and the card
        // support.

        protocolMask = protocolMask & 
            SmartcardExtension->CardCapabilities.Protocol.Supported & 
            SmartcardExtension->ReaderExtension->ClassDescriptor.dwProtocols;

        //
        // If the reader supports automatic parameter configuration, then just 
        // check for the selected protocol
        //
        if (SmartcardExtension->ReaderExtension->ClassDescriptor.dwFeatures & AUTO_PARAMETER_NEGOTIATION) {
            
            message = ExAllocatePool(NonPagedPool,
                                     sizeof(USBSC_OUT_MESSAGE_HEADER));

            if (!message) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            RtlZeroMemory(message,
                          sizeof( USBSC_OUT_MESSAGE_HEADER )); 
                          

            
            response = ExAllocatePool(NonPagedPool,
                                      sizeof(USBSC_IN_MESSAGE_HEADER)
                                      + sizeof(PROTOCOL_DATA_T1));

            if (!response) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            message->bMessageType = PC_to_RDR_GetParameters;
            message->dwLength = 0;
            message->bSlot = 0;

            
            SmartcardDebug( DEBUG_PROTOCOL, ("%s : Reader supports auto parameter negotiation\n",DRIVER_NAME ));
            
            status = UsbScReadWrite(SmartcardExtension,
                                    message,
                                    response,
                                    sizeof(PROTOCOL_DATA_T1),
                                    NULL,
                                    FALSE);

            if (!NT_SUCCESS(status)) {

                __leave;

            }

            if ((((PUSBSC_IN_MESSAGE_HEADER) response)->bProtocolNum+1) & protocolMask) {
            
                *SmartcardExtension->IoRequest.ReplyBuffer = ((PUSBSC_IN_MESSAGE_HEADER) response)->bProtocolNum + 1;
                *SmartcardExtension->IoRequest.Information = sizeof(ULONG);

                KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                                  &irql);
                SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
                SmartcardExtension->CardCapabilities.Protocol.Selected = *SmartcardExtension->IoRequest.ReplyBuffer;
                KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                  irql);

            } else {
                SmartcardDebug( DEBUG_PROTOCOL, ("%s : Reader has not selected desired protocol\n",DRIVER_NAME ));

                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            
            __leave;

        }

        // 
        // Check if the card has already selected the right protocol
        //
        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);
        if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC &&
            (SmartcardExtension->CardCapabilities.Protocol.Selected & 
             SmartcardExtension->MinorIoControlCode)) {

            protocolMask = SmartcardExtension->CardCapabilities.Protocol.Selected;

            status = STATUS_SUCCESS;    

        }
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);

        //
        // Check if PPS request needs to be sent
        //
        if (!(NT_SUCCESS(status)) && !(SmartcardExtension->ReaderExtension->ClassDescriptor.dwFeatures & (AUTO_PARAMETER_NEGOTIATION | AUTO_PPS))) {
            PUCHAR replyPos;

            //
            // Must send PPS request
            //


            message = ExAllocatePool(NonPagedPool,
                                     sizeof(USBSC_OUT_MESSAGE_HEADER)
                                     + sizeof(PPS_REQUEST));

            if (!message) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            RtlZeroMemory(message,
                          sizeof( USBSC_OUT_MESSAGE_HEADER ) 
                          + sizeof(PPS_REQUEST));

            
            response = ExAllocatePool(NonPagedPool,
                                      sizeof(USBSC_IN_MESSAGE_HEADER)
                                      + sizeof(PPS_REQUEST));

            if (!response) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            while (TRUE) {
            
                pPPS = (PPPS_REQUEST) ((PUCHAR) message + sizeof(USBSC_OUT_MESSAGE_HEADER));

                pPPS->bPPSS = 0xff;
            
                if (protocolMask & SCARD_PROTOCOL_T1) {
                                        
                    pPPS->bPPS0 = 0x11;
                    
                    
                } else if (protocolMask & SCARD_PROTOCOL_T0) {

                    pPPS->bPPS0 = 0x10;

                    
                } else {
                    
                    SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSetProtocol Invalid protocol\n",DRIVER_NAME ));
                    
                    status = STATUS_INVALID_DEVICE_REQUEST;
                    __leave;
                   
                }

                pPPS->bPPS1 = (cardCaps->PtsData.Fl << 4) 
                               | cardCaps->PtsData.Dl;

                pPPS->bPCK = (pPPS->bPPSS ^ pPPS->bPPS0 ^ pPPS->bPPS1);
            
                SmartcardDebug( DEBUG_PROTOCOL, 
                                ("%s : Sending PPS request (0x%x 0x%x 0x%x 0x%x)\n",
                                 DRIVER_NAME,
                                 pPPS->bPPSS,
                                 pPPS->bPPS0,
                                 pPPS->bPPS1,
                                 pPPS->bPCK ));
                
                message->bMessageType = PC_to_RDR_XfrBlock;
                message->bSlot = 0;
                message->dwLength = sizeof(PPS_REQUEST);


                switch (SmartcardExtension->ReaderExtension->ExchangeLevel) {
                case TPDU_LEVEL:

                    message->wLevelParameter = 0;
                    bytesToRead = sizeof(PPS_REQUEST);
            
                    status = UsbScReadWrite(SmartcardExtension,
                                            message,
                                            response,
                                            bytesToRead,
                                            &pps,
                                            FALSE);
                                        
                    break;

                case CHARACTER_LEVEL:

                 
                    replyPos = (PUCHAR) &pps; 

                
                    bytesToRead = 4;
                    message->wLevelParameter = 2;
                    
                    while (bytesToRead) {

                        status = UsbScReadWrite(SmartcardExtension,
                                                message,
                                                response,
                                                message->wLevelParameter,
                                                replyPos,
                                                FALSE);
                     
                        bytesToRead -= 2;
                        replyPos += 2;
                        message->dwLength = 0;
                        if (!NT_SUCCESS(status)) {
                            break;
                        }
                        
                    }


                    break;

                }

                if (!NT_SUCCESS(status) || (memcmp(&pps, pPPS, sizeof(PPS_REQUEST)) != 0)) {

                    // The card failed with the current settings
                    // If PtsData.Type is not PTS_TYPE_DEFAULT, then try that.

                    

                    if (cardCaps->PtsData.Type == PTS_TYPE_DEFAULT) {

                        SmartcardDebug( DEBUG_PROTOCOL, ("%s : The card failed PPS request\n",DRIVER_NAME ));

                        ASSERT(FALSE);
                        status = STATUS_DEVICE_PROTOCOL_ERROR;
                        __leave;
                
                    }

                    SmartcardDebug( DEBUG_PROTOCOL, ("%s : The card failed PPS request, trying default PPS\n",DRIVER_NAME ));
                    cardCaps->PtsData.Type = PTS_TYPE_DEFAULT;
                    SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;

                    status = UsbScCardPower(SmartcardExtension);

                } else {


                    break;

                }


            }
                

            if (message != NULL) {

                ExFreePool(message);
                message = NULL;

            }

            if (response != NULL) {

                ExFreePool(response);
                response = NULL;
            }

        }

        //
        // Send set protocol request to the reader
        //
        if (protocolMask & SCARD_PROTOCOL_T1) {  // T=1

            SmartcardDebug( DEBUG_PROTOCOL, ("%s : Setting protocol T=1\n",DRIVER_NAME ));


            protocol = 1;

            message = ExAllocatePool(NonPagedPool,
                                     sizeof( USBSC_OUT_MESSAGE_HEADER ) 
                                     + sizeof(PROTOCOL_DATA_T1));

            if (!message) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            RtlZeroMemory(message,
                          sizeof( USBSC_OUT_MESSAGE_HEADER ) 
                          + sizeof(PROTOCOL_DATA_T1));


            dataT1 = (PPROTOCOL_DATA_T1) ((PUCHAR) message + sizeof(USBSC_OUT_MESSAGE_HEADER));


            // 
            //  7            4 3            0
            //  ----------------------------
            // |     FI      |   DI        |
            // ----------------------------
            //
            dataT1->bmFindexDindex = (cardCaps->PtsData.Fl << 4) 
                                     | cardCaps->PtsData.Dl;


            //
            // B7-2 = 000100b
            // B0 = Checksum type (0=LRC, 1=CRC)
            // B1 = Convention used (0=direct, 1=inverse)
            // 
            dataT1->bmTCCKST1 = 0x10 | (cardCaps->T1.EDC & 0x01);

            if (cardCaps->InversConvention) {

                dataT1->bmTCCKST1 |= 2;

            }

            dataT1->bGuardTimeT1 = cardCaps->N;

            // 
            //  7            4 3            0
            //  ----------------------------
            // |     BWI     |   CWI       |
            // ----------------------------
            //            
            dataT1->bmWaitingIntegersT1 = (cardCaps->T1.BWI << 4) 
                                            | (cardCaps->T1.CWI & 0xf);

            dataT1->bClockStop = 0;
            dataT1->bIFSC = cardCaps->T1.IFSC;
            dataT1->bNadValue = 0;
            message->dwLength = sizeof(PROTOCOL_DATA_T1);

        } else if (protocolMask & SCARD_PROTOCOL_T0) {

            SmartcardDebug( DEBUG_PROTOCOL, ("%s :  Setting protocol T=0\n",DRIVER_NAME ));


            protocol = 0;
            message = ExAllocatePool(NonPagedPool,
                                     sizeof( USBSC_OUT_MESSAGE_HEADER ) 
                                     + sizeof(PROTOCOL_DATA_T0));

            if (!message) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }
            RtlZeroMemory(message,
                          sizeof( USBSC_OUT_MESSAGE_HEADER ) 
                          + sizeof(PROTOCOL_DATA_T0));
            
            dataT0 = (PROTOCOL_DATA_T0 *) (((UCHAR *) message) + sizeof(USBSC_OUT_MESSAGE_HEADER));

            // 
            //  7            4 3            0
            //  ----------------------------
            // |     FI      |   DI        |
            // ----------------------------
            //
            dataT0->bmFindexDindex = (cardCaps->PtsData.Fl << 4)
                                    | cardCaps->PtsData.Dl;

            //
            // B7-2 = 000000b
            // B0 = 0
            // B1 = Convention used (0=direct, 1=inverse)
            // 
            dataT0->bmTCCKST0 = 0;
            if (cardCaps->InversConvention) {

                dataT0->bmTCCKST0 |= 2;

            }

            dataT0->bGuardTimeT0 = cardCaps->N;
            dataT0->bWaitingIntegerT0 = cardCaps->T0.WI;
            dataT0->bClockStop = 0;
            message->dwLength = sizeof(PROTOCOL_DATA_T0);

        } else {

            SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSetProtocol Invalid protocol\n",DRIVER_NAME ));

            status = STATUS_INVALID_DEVICE_REQUEST;
            __leave;

        }

        message->bMessageType = PC_to_RDR_SetParameters;
        message->bSlot = 0;
        message->bProtocolNum = protocol;

        status = UsbScReadWrite(SmartcardExtension,
                                message,
                                (PVOID) message,
                                message->dwLength,
                                NULL,
                                FALSE);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

        //
        // See if reader supports auto clock/baud rate configuration
        //
        if ((SmartcardExtension->ReaderExtension->ClassDescriptor.dwFeatures & (AUTO_BAUD_RATE | AUTO_CLOCK_FREQ)) != (AUTO_BAUD_RATE | AUTO_CLOCK_FREQ)) {
        
            // Set ClockFrequency and DataRate

            RtlZeroMemory(message,
                          sizeof(USBSC_OUT_MESSAGE_HEADER)
                          + sizeof(CLOCK_AND_DATA_RATE));
            message->bMessageType = PC_to_RDR_SetDataRateAndClockFrequency;
            message->dwLength = 8;
            message->bSlot = 0;

            cadData = (PCLOCK_AND_DATA_RATE) ((PUCHAR)message+sizeof(USBSC_OUT_MESSAGE_HEADER));
            cadData->dwClockFrequency = SmartcardExtension->CardCapabilities.PtsData.CLKFrequency;
            cadData->dwDataRate = SmartcardExtension->CardCapabilities.PtsData.DataRate;

            status = UsbScReadWrite(SmartcardExtension,
                                    message,
                                    (PVOID) message,
                                    sizeof(CLOCK_AND_DATA_RATE),
                                    NULL,
                                    FALSE);

            if (!NT_SUCCESS(status)) {

                __leave;

            }

        }


        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);

        if (SmartcardExtension->ReaderCapabilities.CurrentState != SCARD_SPECIFIC) {

            // This was a call from UsbScCardPower, so don't fill in the buffer.
            *SmartcardExtension->IoRequest.ReplyBuffer = protocol + 1;
            *SmartcardExtension->IoRequest.Information = sizeof(ULONG);
            
        }
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
        SmartcardExtension->CardCapabilities.Protocol.Selected = protocol + 1;
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
         
    }

    __finally
    {

        if (message != NULL) {

            ExFreePool(message);
            message = NULL;

        }

        if (response != NULL) {

            ExFreePool(response);
            response = NULL;
        }

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSetProtocol Exit : 0x%x\n",DRIVER_NAME, status ));

    
    }

    return status;

}


NTSTATUS 
UsbScCardPower(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    RDF_CARD_POWER callback
    called from smclib


Arguments:

Return Value:

--*/
{

    NTSTATUS            status = STATUS_SUCCESS;
    PREADER_EXTENSION   readerExtension;
    UCHAR               atr[sizeof(USBSC_IN_MESSAGE_HEADER) + ATR_SIZE];
    USBSC_OUT_MESSAGE_HEADER    powerMessage;
    PUSBSC_IN_MESSAGE_HEADER    replyHeader;
    BYTE                voltage;
    LARGE_INTEGER       waitTime;
    KIRQL               irql;
    BOOLEAN             callSetProtocol = FALSE;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardPower Enter\n",DRIVER_NAME ));

        replyHeader     = (PUSBSC_IN_MESSAGE_HEADER) atr;
        readerExtension = SmartcardExtension->ReaderExtension;
        *SmartcardExtension->IoRequest.Information = 0;

        switch (SmartcardExtension->MinorIoControlCode) {
        case SCARD_WARM_RESET:

            RtlZeroMemory(&powerMessage, sizeof(USBSC_OUT_MESSAGE_HEADER));

            powerMessage.bMessageType   = PC_to_RDR_IccPowerOn;
            powerMessage.bPowerSelect   = readerExtension->CurrentVoltage;
            powerMessage.dwLength       = 0;
            powerMessage.bSlot          = 0;

            SmartcardDebug( DEBUG_PROTOCOL, ("%s : SCARD_WARM_RESET (bPowerSelect = 0x%x)\n",DRIVER_NAME, readerExtension->CurrentVoltage ));

            status = UsbScReadWrite(SmartcardExtension,
                                    &powerMessage,
                                    atr,
                                    ATR_SIZE,
                                    SmartcardExtension->IoRequest.ReplyBuffer,
                                    FALSE);

            if (!NT_SUCCESS(status)) {

                SmartcardDebug( DEBUG_ERROR, ("%s : PC_to_RDR_IccPowerOn failed with status = 0x%x\n",DRIVER_NAME, status ));
                __leave;

            }

            if (replyHeader->dwLength > ATR_SIZE) {
                SmartcardDebug( DEBUG_ERROR, ("%s :Invalid ATR size returned\n",DRIVER_NAME, status ));
                status = STATUS_DEVICE_PROTOCOL_ERROR;
                __leave;

            }
            *SmartcardExtension->IoRequest.Information = replyHeader->dwLength;

            RtlCopyMemory(SmartcardExtension->CardCapabilities.ATR.Buffer, 
                          SmartcardExtension->IoRequest.ReplyBuffer,
                          *SmartcardExtension->IoRequest.Information);

            SmartcardExtension->CardCapabilities.ATR.Length = *SmartcardExtension->IoRequest.Information;
            status = SmartcardUpdateCardCapabilities(SmartcardExtension);

            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);

            if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC) {

                callSetProtocol = TRUE;

            }
                   
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);


            break;
                
        case SCARD_COLD_RESET:

            SmartcardDebug( DEBUG_PROTOCOL, ("%s : SCARD_COLD_RESET\n",DRIVER_NAME ));

            RtlZeroMemory(&powerMessage, sizeof(USBSC_OUT_MESSAGE_HEADER));
            powerMessage.dwLength       = 0;
            powerMessage.bSlot          = 0;



            // Need to first power off card before selecting another 
            // voltage.
            powerMessage.bMessageType =  PC_to_RDR_IccPowerOff;

            status = UsbScReadWrite(SmartcardExtension,
                                    &powerMessage,
                                    atr,
                                    0,
                                    NULL,
                                    FALSE);

            if (!NT_SUCCESS(status)) {

                SmartcardDebug( DEBUG_ERROR, ("%s : PC_to_RDR_IccPowerOff failed with status = 0x%x\n",DRIVER_NAME, status ));


                __leave;

            }

            // We need to iterate through the possible voltages, moving from low voltage to high
            // until we find one that works
            for (voltage = 3; voltage > 0 && voltage <= 3; voltage--) {

                if (readerExtension->ClassDescriptor.dwFeatures & AUTO_VOLTAGE_SELECTION) {

                    // reader supports auto voltage selection
                    voltage = 0;

                } else if (!(readerExtension->ClassDescriptor.bVoltageSupport & VoltMask[voltage])) {

                    // Reader doesn't support this voltage.
                    continue;
                }
                
  
                // Wait 10ms per spec
                waitTime.HighPart = -1;
                waitTime.LowPart = -100;    // 10ms

                KeDelayExecutionThread(KernelMode,
                                       FALSE,
                                       &waitTime);

                // Now we can power back on
                RtlZeroMemory(&powerMessage, sizeof(USBSC_OUT_MESSAGE_HEADER));

                powerMessage.bMessageType = PC_to_RDR_IccPowerOn;
                powerMessage.bPowerSelect = voltage;
                powerMessage.dwLength = 0;

                SmartcardDebug( DEBUG_PROTOCOL, ("%s : Selecting voltage = 0x%x\n",DRIVER_NAME, voltage ));


                status = UsbScReadWrite(SmartcardExtension,
                                        &powerMessage,
                                        atr,
                                        ATR_SIZE,
                                        SmartcardExtension->IoRequest.ReplyBuffer,
                                        FALSE);

                if (NT_SUCCESS(status)) {

                    // everything worked. We found the correct voltage
                    SmartcardDebug( DEBUG_PROTOCOL, ("%s : Voltage set to 0x%x\n",DRIVER_NAME, voltage ));
                    *SmartcardExtension->IoRequest.Information = replyHeader->dwLength;
                    readerExtension->CurrentVoltage = voltage;
                    break;

                }
              
                //
                // If card or reader doesn't support selected voltage, it will
                // either timeout, return ICC_CLASS_NOT_SUPPORTED or
                // report that parameter 7 (bPowerselect) is not supported
                //
                if (((replyHeader->bStatus == 0x41) && (replyHeader->bError == ICC_MUTE))
                    || (replyHeader->bError == ICC_CLASS_NOT_SUPPORTED)
                    || (replyHeader->bError == 7)) {

                    SmartcardDebug( DEBUG_PROTOCOL, ("%s : Reader did not support voltage = 0x%x\n",DRIVER_NAME, voltage ));



                    // We are going to try another voltage
                        
                } else {
                    //
                    // We have a bigger problem that we can't handle
                    // Let's just ignore it for now and see if it is 
                    // due to insufficient voltage
                    //

                    SmartcardDebug( DEBUG_ERROR, ("%s!UsbScCardPower Unhandled error (probably due to insufficient voltage)\n",DRIVER_NAME ));
 
                }

            }

            // Save the ATR so smclib can parse it
            if (*SmartcardExtension->IoRequest.Information > ATR_SIZE) {
                SmartcardDebug( DEBUG_ERROR, ("%s : Invalid ATR size returned\n",DRIVER_NAME ));

                status = STATUS_DEVICE_PROTOCOL_ERROR;
                __leave;
            }
            RtlCopyMemory(SmartcardExtension->CardCapabilities.ATR.Buffer, 
                          SmartcardExtension->IoRequest.ReplyBuffer,
                          *SmartcardExtension->IoRequest.Information);

            SmartcardExtension->CardCapabilities.ATR.Length = *SmartcardExtension->IoRequest.Information;
            status = SmartcardUpdateCardCapabilities(SmartcardExtension);

            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);

            if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC) {

                callSetProtocol = TRUE;

            }
                   
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

            break;

        case SCARD_POWER_DOWN:

            SmartcardDebug( DEBUG_PROTOCOL, ("%s : SCARD_POWER_DOWN\n",DRIVER_NAME ));
            RtlZeroMemory(&powerMessage, sizeof(USBSC_OUT_MESSAGE_HEADER));

            powerMessage.bSlot = 0;
            powerMessage.bMessageType = PC_to_RDR_IccPowerOff;
            powerMessage.dwLength = 0;
            
            status = UsbScReadWrite(SmartcardExtension,
                                    &powerMessage,
                                    atr,
                                    0,
                                    NULL,
                                    FALSE);

            if (!NT_SUCCESS(status)) {
                SmartcardDebug( DEBUG_ERROR, ("%s : PC_to_RDR_IccPowerOff failed with status = 0x%x\n",DRIVER_NAME, status ));
                __leave;
            }

            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);
            if (SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_PRESENT) {

                SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_PRESENT;

            }

            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

            SmartcardExtension->CardCapabilities.ATR.Length = 0;
            
            break;
        }
    
    }

    __finally
    {

        if (callSetProtocol) {

            ULONG minorIoctl;
            // SetProtocol will not be called in this case, so call it now.

            // Select best possible PTS data
            SmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_OPTIMAL;
            status = SmartcardUpdateCardCapabilities(SmartcardExtension);

            minorIoctl = SmartcardExtension->MinorIoControlCode;
            SmartcardExtension->MinorIoControlCode = SmartcardExtension->CardCapabilities.Protocol.Selected;


            UsbScSetProtocol(SmartcardExtension);
            SmartcardExtension->MinorIoControlCode = minorIoctl;

        }

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardPower Exit : 0x%x\n",DRIVER_NAME, status ));
    
    }

    return status;

}


NTSTATUS 
UsbScCardTracking(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    RDF_CARD_TRACKING callback
    called from smclib


Arguments:

Return Value:

--*/
{       
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL ioIrql, keIrql;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardTracking Enter\n",DRIVER_NAME ));

   
        // set cancel routine
        IoAcquireCancelSpinLock( &ioIrql );

        IoSetCancelRoutine(
           SmartcardExtension->OsData->NotificationIrp,
           ScUtil_Cancel);

        IoReleaseCancelSpinLock( ioIrql );

        status = STATUS_PENDING;
    
    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardTracking Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}


NTSTATUS 
UsbScCardSwallow(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    RDF_READER_SWALLOW callback
    called from smclib


Arguments:

Return Value:

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    __try
    {

        USBSC_OUT_MESSAGE_HEADER header;
        USBSC_IN_MESSAGE_HEADER reply;

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardSwallow Enter\n",DRIVER_NAME ));

        header.bMessageType = PC_to_RDR_Mechanical;
        header.dwLength = 0;
        header.bSlot = 0;
        header.bFunction = 4; // lock

        status = UsbScReadWrite(SmartcardExtension,
                                &header,
                                (PUCHAR) &reply,
                                0,
                                NULL,
                                FALSE);

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardSwallow Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}


NTSTATUS 
UsbScCardEject(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    RDF_CARD_EJECT callback
    called from smclib

Arguments:

Return Value:

--*/
{
    
    NTSTATUS status = STATUS_SUCCESS;

    __try
    {

        USBSC_OUT_MESSAGE_HEADER header;
        USBSC_IN_MESSAGE_HEADER reply;
        
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardEject Enter\n",DRIVER_NAME ));

        header.bMessageType = PC_to_RDR_Mechanical;
        header.dwLength = 0;
        header.bSlot = 0;
        header.bFunction = 5; // unlock

        status = UsbScReadWrite(SmartcardExtension,
                                &header,
                                (PUCHAR) &reply,
                                0,
                                NULL,
                                FALSE);

    
    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardEject Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}


NTSTATUS 
UsbScT0Transmit(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    Handles transmitting data to/from reader using the T=0 protocol

Arguments:
    SmartcardExtension

Return Value:
    NT status value

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PREADER_EXTENSION   ReaderExtension = SmartcardExtension->ReaderExtension;
    ULONG               bytesToSend;
    ULONG               requestLength;
    ULONG               bytesToRead;
    PUCHAR              currentHeaderPos;
    PUCHAR              currentData;
    ULONG               maxDataLen = 0;
    USBSC_OUT_MESSAGE_HEADER header;
    PUSBSC_IN_MESSAGE_HEADER replyHeader;
    PUCHAR              responseBuffer = NULL;
    PUCHAR              replyPos;
    LONG                timeout = 0;
    UCHAR               ins;
    ULONG               initialRequestLength = 0;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit Enter\n",DRIVER_NAME ));


        // Tell the lib to allocate space for the header
        SmartcardExtension->SmartcardRequest.BufferLength = sizeof(USBSC_OUT_MESSAGE_HEADER);
        SmartcardExtension->SmartcardReply.BufferLength = 0;

        initialRequestLength = SmartcardExtension->IoRequest.RequestBufferLength - 
            sizeof(SCARD_IO_REQUEST);
        
        status = SmartcardT0Request(SmartcardExtension);

        if (!NT_SUCCESS(status)) {
            
            __leave;

        }

        

        bytesToSend = SmartcardExtension->SmartcardRequest.BufferLength - sizeof(USBSC_OUT_MESSAGE_HEADER);
        bytesToRead = SmartcardExtension->T0.Le + 2;            // Le + SW2 and SW2
        replyPos    = SmartcardExtension->SmartcardReply.Buffer;
                       
        if ((SmartcardExtension->T0.Le == 0)
            && (SmartcardExtension->T0.Lc == 0)
            && (initialRequestLength == 4)
            && ReaderExtension->ExchangeLevel != CHARACTER_LEVEL) {
            // Case 1 APDU.  Only want to send 4 byte APDU in this case but smclib
            // expanded it to 5 bytes by setting P3 to 0.  For CCID, strip off P3.
            bytesToSend--;
        }

        // allocate buffer to hold message header and data.
        responseBuffer = ExAllocatePool(NonPagedPool,
                                        sizeof( USBSC_OUT_MESSAGE_HEADER ) + bytesToRead);

        if (!responseBuffer) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }

        replyHeader = (PUSBSC_IN_MESSAGE_HEADER) responseBuffer;
        currentHeaderPos = SmartcardExtension->SmartcardRequest.Buffer;

        // Set parameters that are common to all ExchangeLevels.
        header.bMessageType = PC_to_RDR_XfrBlock;
        header.bSlot = 0;
        header.bBWI = 0;

        switch (ReaderExtension->ExchangeLevel) {
       
        case SHORT_APDU_LEVEL: 
            SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit SHORT_APDU_LEVEL\n",DRIVER_NAME ));

            // Fall through since short APDU is an extended APDU with bytesToSend <= MaxMessageLength-10
        case EXTENDED_APDU_LEVEL:

            if (ReaderExtension->ExchangeLevel == EXTENDED_APDU_LEVEL) {
                
                SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit EXTENDED_APDU_LEVEL\n",DRIVER_NAME ));

            }


            if (bytesToSend <= (ReaderExtension->MaxMessageLength - sizeof(USBSC_OUT_MESSAGE_HEADER))) {
                // this is basically just like a short APDU
                header.wLevelParameter = 0;
                requestLength = bytesToSend;

            } else {

                SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit multi-packet message\n",DRIVER_NAME ));


                requestLength = ReaderExtension->MaxMessageLength - sizeof(USBSC_OUT_MESSAGE_HEADER);
                header.wLevelParameter = 1;

            }

            while (bytesToSend || ((replyHeader->bChainParameter & 0x01) == 0x01)) {

                header.dwLength = requestLength;
                *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        bytesToRead,
                                        replyPos,
                                        FALSE);
                if (!NT_SUCCESS(status)) {

                    __leave;

                }

                SmartcardDebug( DEBUG_PROTOCOL, ("%s!UsbScT0Transmit SW1=0x%x, SW2=0x%x\n",DRIVER_NAME, replyPos[replyHeader->dwLength-2], replyPos[replyHeader->dwLength-1] ));

                if (bytesToSend < requestLength) {
                    // this should NEVER happen
                    status = STATUS_DEVICE_PROTOCOL_ERROR;
                    __leave;
                }
                bytesToSend -= requestLength;
                currentHeaderPos += requestLength;

                if ((bytesToSend <= (ReaderExtension->MaxMessageLength - sizeof(USBSC_OUT_MESSAGE_HEADER))) && (bytesToSend > 0)) {
                    // Last part of APDU
                    
                    requestLength = bytesToSend;
                    header.wLevelParameter = 2;
                    
                } else if (bytesToSend > 0) {
                    // Still more APDU to come

                    header.wLevelParameter = 3;
                 
                } else {
                    // Expect more data

                    header.wLevelParameter = 0x10;
                }

                if (bytesToRead < replyHeader->dwLength) {
                    status = STATUS_DEVICE_PROTOCOL_ERROR;
                    __leave;
                }
                bytesToRead -= replyHeader->dwLength;
                replyPos += replyHeader->dwLength;     
                SmartcardExtension->SmartcardReply.BufferLength += replyHeader->dwLength;            

            }

            break;

        case TPDU_LEVEL:

            SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit TPDU_LEVEL\n",DRIVER_NAME ));

            header.wLevelParameter = 0;
            header.dwLength = bytesToSend;
            *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;
            

            status = UsbScReadWrite(SmartcardExtension,
                                    currentHeaderPos,
                                    responseBuffer,
                                    bytesToRead,
                                    replyPos,
                                    FALSE);


            if (!NT_SUCCESS(status)) {
                __leave;
            }


            bytesToSend = 0;
            bytesToRead -= replyHeader->dwLength;
            
            replyPos += replyHeader->dwLength;    
            SmartcardExtension->SmartcardReply.BufferLength += replyHeader->dwLength;

            break;

        case CHARACTER_LEVEL:

            SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit CHARACTER_LEVEL\n",DRIVER_NAME ));

            //
            // Send T0 command header
            //
            requestLength = 5;
            currentHeaderPos = SmartcardExtension->SmartcardRequest.Buffer;
            ins = currentHeaderPos[sizeof(USBSC_OUT_MESSAGE_HEADER)+1];
            header.dwLength = requestLength;


            while (bytesToSend || bytesToRead) {

                BOOL restartWorkingTime = TRUE;

                header.wLevelParameter = 1;
                *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        header.wLevelParameter,
                                        replyPos,
                                        FALSE);
                if (!NT_SUCCESS(status)) {

                    __leave;

                }


                bytesToSend -= header.dwLength;
                currentHeaderPos += header.dwLength;

                currentData = responseBuffer + sizeof( USBSC_IN_MESSAGE_HEADER );
                if ((*currentData) == 0x60) {

                    // this is a NULL byte.
                    header.wLevelParameter = 1;
                    header.dwLength = 0;
                    continue;
                    

                } else if (((*currentData & 0xF0) == 0x60) || ((*currentData & 0xF0) == 0x90)) {
                    // Got SW1

                    //
                    // data has already been coppied to request buffer
                    // just increment replyPos to prevent overwriting
                    //
                    replyPos++;
                    SmartcardExtension->SmartcardReply.BufferLength++;


                    //Get SW2
                    header.dwLength = 0;
                    header.wLevelParameter = 1;
                    *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;


                    UsbScReadWrite(SmartcardExtension,
                                   currentHeaderPos,
                                   responseBuffer,
                                   header.wLevelParameter,
                                   replyPos,
                                   FALSE);
                    if (!NT_SUCCESS(status)) {

                        __leave;

                    }

                    
                    bytesToRead = 0;
                    bytesToSend = 0;
                    replyPos++;
                    SmartcardExtension->SmartcardReply.BufferLength++;

                    continue;

                }

                if ((*currentData & 0xFE) == (ins & 0xFE)) {

                    //
                    //Transfer all bytes
                    //
                    header.dwLength = bytesToSend;
                    header.wLevelParameter = bytesToRead;
                    if (bytesToSend) {
                        continue;
                    }

                } else if ((*currentData & 0xFE) == ((~ins) & 0xFE)) {

                    //
                    // Transfer next byte
                    //
                    header.dwLength = bytesToSend ? 1 : 0;
                    header.wLevelParameter = bytesToRead ? 1 : 0;

                    if (bytesToSend) {
                        continue;
                    }

                } else {

                    status = STATUS_UNSUCCESSFUL;
                    __leave;

                }
                    
                *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        header.wLevelParameter,
                                        replyPos,
                                        FALSE);    
                if (!NT_SUCCESS(status)) {

                    __leave;
                    
                }

                if (bytesToRead < replyHeader->dwLength) {
                    status = STATUS_DEVICE_PROTOCOL_ERROR;
                    __leave;
                }

                bytesToSend -= header.dwLength;
                currentHeaderPos += header.dwLength;
                bytesToRead -= replyHeader->dwLength;
                replyPos += replyHeader->dwLength;      
                SmartcardExtension->SmartcardReply.BufferLength += replyHeader->dwLength;

                 
            }


            break;
        }

        status = SmartcardT0Reply(SmartcardExtension);
        
    

    }

    __finally
    {

        if (responseBuffer) {

            ExFreePool(responseBuffer);
            responseBuffer = NULL;

        }

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit Exit : 0x%x\n",DRIVER_NAME, status ));
    
    }

    return status;

}


NTSTATUS 
UsbScT1Transmit(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    Handles transmitting data to/from reader using the T=1 protocol

Arguments:
    SmartcardExtension

Return Value:
    NT status value

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PREADER_EXTENSION   ReaderExtension = SmartcardExtension->ReaderExtension;
    USBSC_OUT_MESSAGE_HEADER header;
    PUSBSC_IN_MESSAGE_HEADER replyHeader;
    PUCHAR              currentHeaderPos;
    PUCHAR              responseBuffer = NULL;
    PUCHAR              requestBuffer = NULL;
    PUCHAR              replyPos;
    ULONG               bytesToSend;
    ULONG               requestLength;
    ULONG               bytesToRead;
    LONG                timeout = 0;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT1Transmit Enter\n",DRIVER_NAME ));

        // allocate buffer to hold message header and data.
        responseBuffer = ExAllocatePool(NonPagedPool,
                                        SmartcardExtension->IoRequest.ReplyBufferLength + sizeof(USBSC_OUT_MESSAGE_HEADER));

        if (!responseBuffer) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }
        
        replyPos = SmartcardExtension->SmartcardReply.Buffer;
                       
        replyHeader      = (PUSBSC_IN_MESSAGE_HEADER) responseBuffer;
        currentHeaderPos = SmartcardExtension->SmartcardRequest.Buffer;
        SmartcardExtension->SmartcardReply.BufferLength = 0;
        bytesToRead = SmartcardExtension->ReaderCapabilities.MaxIFSD + 5;    // Set to MAX possible so we allocate enough


        // With the APDU exchange levels, we don't use smclib to manage the 
        // protocol.  We just shovel the data and the reader handles the details
        if ((ReaderExtension->ExchangeLevel == SHORT_APDU_LEVEL)
            || (ReaderExtension->ExchangeLevel == EXTENDED_APDU_LEVEL)) {
                    
            PIO_HEADER IoHeader = (PIO_HEADER) SmartcardExtension->IoRequest.RequestBuffer;

            SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT1Transmit APDU_LEVEL\n",DRIVER_NAME ));


            if (SmartcardExtension->IoRequest.ReplyBufferLength <
                IoHeader->ScardIoRequest.cbPciLength + 2) {

                //
                // We should at least be able to store 
                // the io-header plus SW1 and SW2
                //
                status = STATUS_BUFFER_TOO_SMALL;               
                __leave;

            }

            bytesToSend = SmartcardExtension->IoRequest.RequestBufferLength - 
                                IoHeader->ScardIoRequest.cbPciLength;

            // Need to allocate buffer for write data
            requestBuffer = ExAllocatePool(NonPagedPool,
                                           bytesToSend + sizeof(USBSC_OUT_MESSAGE_HEADER));

            if (requestBuffer == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            replyPos = SmartcardExtension->IoRequest.ReplyBuffer;
            currentHeaderPos = requestBuffer;
            *SmartcardExtension->IoRequest.Information = 0;

            // Copy over the data to write to the reader so we have room for the message header
            RtlCopyMemory(&requestBuffer[sizeof(USBSC_OUT_MESSAGE_HEADER)],
                          &SmartcardExtension->IoRequest.RequestBuffer[sizeof(SCARD_IO_REQUEST)],
                          SmartcardExtension->IoRequest.RequestBufferLength - sizeof(SCARD_IO_REQUEST));

            // Copy over the SCARD_IO)REQUEST structure from the request buffer to the 
            // reply buffer
            RtlCopyMemory(replyPos,
                          IoHeader,
                          sizeof(SCARD_IO_REQUEST ));

            replyPos += sizeof(SCARD_IO_REQUEST);

            header.bMessageType = PC_to_RDR_XfrBlock;
            header.bSlot = 0;
            header.bBWI = 0;

            if (bytesToSend <= (ReaderExtension->MaxMessageLength - sizeof(USBSC_OUT_MESSAGE_HEADER))) {

                // this is basically just like a short APDU
                header.wLevelParameter = 0;
                requestLength = bytesToSend;

            } else {

                requestLength = ReaderExtension->MaxMessageLength - sizeof(USBSC_OUT_MESSAGE_HEADER);
                header.wLevelParameter = 1;

            }

            while (bytesToSend || ((replyHeader->bChainParameter & 0x01) == 0x01)) {

                header.dwLength = requestLength;
                *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        bytesToRead,
                                        replyPos,
                                        FALSE);

                if (!NT_SUCCESS(status)) {

                    __leave;

                }

                bytesToSend -= requestLength;
                currentHeaderPos += requestLength;

                if ((bytesToSend <= (ReaderExtension->MaxMessageLength - sizeof(USBSC_OUT_MESSAGE_HEADER))) && (bytesToSend > 0)) {
                    // Last part of APDU

                    requestLength = bytesToSend;
                    header.wLevelParameter = 2;

                } else if (bytesToSend > 0) {
                    // Still more APDU to come

                    header.wLevelParameter = 3;

                } else {
                    // Expect more data

                    header.wLevelParameter = 0x10;
                }

                replyPos += replyHeader->dwLength;         
                *SmartcardExtension->IoRequest.Information += replyHeader->dwLength;
                
            }

            *SmartcardExtension->IoRequest.Information += IoHeader->ScardIoRequest.cbPciLength;

            __leave;  // Finished transmitting data


        }

        // TPDU and Character levels
        // Run this loop as long as he protocol requires to send data
        do {

            // Tell the lib to allocate space for the header
            SmartcardExtension->SmartcardRequest.BufferLength = sizeof(USBSC_OUT_MESSAGE_HEADER);
            SmartcardExtension->SmartcardReply.BufferLength = 0;

            status = SmartcardT1Request(SmartcardExtension);
    
            if (!NT_SUCCESS(status)) {

                __leave;

            }

            replyPos = SmartcardExtension->SmartcardReply.Buffer;

            bytesToSend = SmartcardExtension->SmartcardRequest.BufferLength - sizeof(USBSC_OUT_MESSAGE_HEADER);

            // Set parameters that are common to all ExchangeLevels.
            header.bMessageType = PC_to_RDR_XfrBlock;
            header.bSlot = 0;
            
            switch (ReaderExtension->ExchangeLevel) {
 
            case TPDU_LEVEL:

                SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT1Transmit TPDU_LEVEL\n",DRIVER_NAME ));


                header.wLevelParameter = 0;
                header.dwLength = bytesToSend;
                header.bBWI = SmartcardExtension->T1.Wtx;

                *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        bytesToRead,
                                        replyPos,
                                        FALSE);

                // 
                // smclib will detect timeout errors, so we set status
                // to success
                //
                if (status == STATUS_IO_TIMEOUT) {

                    status = STATUS_SUCCESS;

                }

                if (!NT_SUCCESS(status)) {

                    __leave;

                }

                bytesToSend = 0;
                SmartcardExtension->SmartcardReply.BufferLength = replyHeader->dwLength;

                break;

            case CHARACTER_LEVEL:
            
                SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT1Transmit CHARACTER_LEVEL\n",DRIVER_NAME ));

                currentHeaderPos = SmartcardExtension->SmartcardRequest.Buffer;
            
            
                header.dwLength = bytesToSend;
            
                header.wLevelParameter = 3; // response is just the prologue field

                header.bBWI = SmartcardExtension->T1.Wtx;

            
                *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

            
                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        header.wLevelParameter,
                                        replyPos,
                                        FALSE);

                //
                // smclib will detect timeout errors, so we set status to 
                // success
                //
                if (status == STATUS_IO_TIMEOUT) {

                    status = STATUS_SUCCESS;
                    SmartcardExtension->SmartcardReply.BufferLength += replyHeader->dwLength;
                    break;


                }


                if (!NT_SUCCESS(status)) {
                    ASSERT(FALSE);

                    __leave;

                }


                SmartcardExtension->SmartcardReply.BufferLength += replyHeader->dwLength;


                bytesToSend = 0;
                bytesToRead = replyPos[2] + 
                    (SmartcardExtension->CardCapabilities.T1.EDC & 0x01 ? 2 : 1);

                header.dwLength = 0;
                header.wLevelParameter = bytesToRead;
                    *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

                replyPos += replyHeader->dwLength;


                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        header.wLevelParameter,
                                        replyPos,
                                        FALSE);

                //
                // smclib will detect timeout errors, so we set status to 
                // success
                //
                if (status == STATUS_IO_TIMEOUT) {

                    status = STATUS_SUCCESS;

                }


                if (!NT_SUCCESS(status)) {

                    __leave;

                }

                SmartcardExtension->SmartcardReply.BufferLength += replyHeader->dwLength;

                break;

            }

            status = SmartcardT1Reply(SmartcardExtension);

        } while (status == STATUS_MORE_PROCESSING_REQUIRED);


    }

    __finally
    {

        if (requestBuffer) {

            ExFreePool(requestBuffer);
            requestBuffer = NULL;

        }

        if (responseBuffer) {

            ExFreePool(responseBuffer);
            responseBuffer = NULL;

        }

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT1Transmit Exit : 0x%x\n",DRIVER_NAME, status ));
    
    }

    return status;

}


NTSTATUS
UsbScReadWrite(
    PSMARTCARD_EXTENSION SmartcardExtension,
    PVOID WriteBuffer,
    PUCHAR ReadBuffer,
    WORD ReadLength,
    PVOID ResponseBuffer,
    BOOL NullByte)
/*++

Routine Description:
    Writes data to the reader, and then reads response from reader.
    Handles the bSeq value, checking the slot number, any time extension requests
    Also converts errors into NTSTATUS codes

Arguments:
    SmartcardExtension  - 
    WriteBuffer         - Data to be written to the reader
    ReaderBuffer        - Caller allocated buffer to hold the response 
    ReadLength          - Number of bytes expected (excluding header)
    ResponseBuffer      - optional buffer to copy response data only (no header)
    NullByte            - Look for NULL byte (used in T=0 protocol)

Return Value:
    NTSTATUS value

--*/
{
    
    NTSTATUS            status = STATUS_SUCCESS;
    PUSBSC_OUT_MESSAGE_HEADER header; 
    PUSBSC_IN_MESSAGE_HEADER replyHeader; 
    WORD                writeLength; 
    ULONG               timeout = 0;


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScReadWrite Enter\n",DRIVER_NAME ));

        header = (PUSBSC_OUT_MESSAGE_HEADER) WriteBuffer;
        replyHeader = (PUSBSC_IN_MESSAGE_HEADER) ReadBuffer;
        writeLength = header->dwLength + sizeof( USBSC_OUT_MESSAGE_HEADER);
        ReadLength += sizeof( USBSC_IN_MESSAGE_HEADER );


        header->bSeq = InterlockedIncrement(&SmartcardExtension->ReaderExtension->SequenceNumber);        

        //
        //  Send the data to the device
        //
        status = UsbWrite(SmartcardExtension->ReaderExtension,
                          WriteBuffer,
                          writeLength,
                          timeout);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

        SmartcardDebug( DEBUG_PROTOCOL, 
                        ("%s!UsbScReadWrite Wrote %s, 0x%x bytes (header + 0x%x)\n",
                         DRIVER_NAME, 
                         GetMessageName(header->bMessageType), 
                         writeLength, header->dwLength ));


        if (SmartcardExtension->CardCapabilities.Protocol.Selected == SCARD_PROTOCOL_T1) {

            if (SmartcardExtension->T1.Wtx) {

                SmartcardDebug( DEBUG_PROTOCOL, ("%s!UsbScReadWrite Wait time extension.  Wtx=0x%x, bBWI=0x%x\n",DRIVER_NAME, SmartcardExtension->T1.Wtx, header->bBWI));

            }

        }

        // We want to loop here if the reader requests a time extension
        while (1) {
            
            status = UsbRead(SmartcardExtension->ReaderExtension,
                             ReadBuffer,
                             ReadLength,
                             timeout);

            if (!NT_SUCCESS(status)) {

                __leave;

            }

            SmartcardDebug( DEBUG_PROTOCOL, 
                            ("%s!UsbScReadWrite Read %s, 0x%x bytes (header + 0x%x)\n",
                             DRIVER_NAME, 
                             GetMessageName(replyHeader->bMessageType),
                             ReadLength, replyHeader->dwLength ));
            


            if ((replyHeader->bSlot != header->bSlot) || (replyHeader->bSeq != header->bSeq)) {

                // This is not ours.  Who knows where this came from (probably a different slot that we don't support)
                SmartcardDebug( DEBUG_PROTOCOL, ("%s!UsbScReadWrite Someone else's message received\n\t\tSlot %x (%x), Seq %x (%x)\n",
                                              DRIVER_NAME,
                                              replyHeader->bSlot,
                                              header->bSlot,
                                              replyHeader->bSeq,
                                              header->bSeq ));
                


                continue;

            } else if (replyHeader->bStatus & COMMAND_STATUS_FAILED) {

                // Doh we have a problem
                SmartcardDebug( DEBUG_PROTOCOL, 
                                ("%s!UsbScReadWrite COMMAND_STATUS_FAILED\n\tbmICCStatus = 0x%x\n\tbmCommandStatus = 0x%x\n\tbError = 0x%x\n",
                                 DRIVER_NAME, 
                                 replyHeader->bStatus & ICC_STATUS_MASK,
                                 (replyHeader->bStatus & COMMAND_STATUS_MASK) >> 6,
                                 replyHeader->bError));

                status = UsbScErrorConvert(replyHeader);

            } else if (replyHeader->bStatus & COMMAND_STATUS_TIME_EXT) {

                // Time extension requested
                // We should sleep for a bit while the reader prepares the data

                UINT wi = replyHeader->bError;
                LARGE_INTEGER delayTime;

                SmartcardDebug( DEBUG_PROTOCOL, ("%s!UsbScReadWrite Time extension requested\n",DRIVER_NAME ));

                delayTime.HighPart = -1;
                if (SmartcardExtension->CardCapabilities.Protocol.Selected == SCARD_PROTOCOL_T1) {
                    
                    delayTime.LowPart = 
                        (-1) *
                        SmartcardExtension->CardCapabilities.T1.BWT *
                        wi *
                        10;

                } else {
                
                    delayTime.LowPart = 
                        (-1) *  // relative
                        SmartcardExtension->CardCapabilities.T0.WT *
                        wi * 
                        10;  // 100 nanosecond units
                                    
                }

//                KeDelayExecutionThread(KernelMode,
//                                       FALSE,
//                                       &delayTime);
                continue;

            } else if (NullByte && (ReadBuffer[sizeof(USBSC_IN_MESSAGE_HEADER)] == 0x60)) {

                // NULL byte, wait for another response
                SmartcardDebug( DEBUG_PROTOCOL, ("%s!UsbScReadWrite Received NULL byte, waiting for next response\n",DRIVER_NAME ));

                continue;

            } else {
                // SUCCESS!!
                SmartcardDebug( DEBUG_PROTOCOL, 
                                ("%s!UsbScReadWrite Read %s, 0x%x bytes (header + 0x%x)\n",
                                 DRIVER_NAME, 
                                 GetMessageName(replyHeader->bMessageType),
                                 ReadLength, replyHeader->dwLength ));


            }
            break;

        }

        

        //
        // copy data to request buffer
        //
        if (ResponseBuffer) {

            RtlCopyMemory(ResponseBuffer, 
                          ReadBuffer + sizeof(USBSC_IN_MESSAGE_HEADER),
                          replyHeader->dwLength);

        }
    
    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScReadWrite Exit : 0x%x\n",DRIVER_NAME, status ));
    
    }

    return status;


}


NTSTATUS
UsbScErrorConvert(
    PUSBSC_IN_MESSAGE_HEADER ReplyHeader
    )
/*++

Routine Description:
    Converts the errors returned by the reader into
    valid NTSTATUS codes

Arguments:
    ReplyHeader     - reply header recieved from reader

Return Value:
    NTSTATUS code corresponding to the reader error

--*/
{

    NTSTATUS status = STATUS_UNSUCCESSFUL;
    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScErrorConvert Enter\n",DRIVER_NAME ));

        SmartcardDebug( DEBUG_TRACE, ("bmICCStatus = 0x%x\n",ReplyHeader->bStatus & ICC_STATUS_MASK ));
        SmartcardDebug( DEBUG_TRACE, ("bmCommandStatus = 0x%x\n", (ReplyHeader->bStatus & COMMAND_STATUS_MASK) >> 6 ));
        SmartcardDebug( DEBUG_TRACE, ("bError = 0x%x\n",ReplyHeader->bError ));


        switch (ReplyHeader->bError) {
        case CMD_ABORTED:
            status = STATUS_CANCELLED;
            break;
        
        case ICC_MUTE:
            if ((ReplyHeader->bStatus & ICC_STATUS_MASK) == 2) {

                status = STATUS_NO_MEDIA;

            } else {

                status = STATUS_IO_TIMEOUT;

            }
            break;

        case XFR_PARITY_ERROR:
            status = STATUS_PARITY_ERROR;
            break;
        
        case XFR_OVERRUN:
            status = STATUS_DATA_OVERRUN;
            break;
        
        case HW_ERROR:
            status = STATUS_IO_DEVICE_ERROR;
            break;
        
        
        case BAD_ATR_TS:
            status = STATUS_DEVICE_PROTOCOL_ERROR;
            break;

        case BAD_ATR_TCK:
            status = STATUS_DEVICE_PROTOCOL_ERROR;
            break;

        case ICC_PROTOCOL_NOT_SUPPORTED:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case ICC_CLASS_NOT_SUPPORTED:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case PROCEDURE_BYTE_CONFLICT:
            status = STATUS_DEVICE_PROTOCOL_ERROR;
            break;

        case DEACTIVATED_PROTOCOL:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case BUSY_WITH_AUTO_SEQUENCE:
            status = STATUS_DEVICE_BUSY;
            break;

        case PIN_TIMEOUT:
            break;

        case PIN_CANCELLED:
            break;

        case CMD_SLOT_BUSY:
            status = STATUS_DEVICE_BUSY;
            break;
        

        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;                
        
        }

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScErrorConvert Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;


}


NTSTATUS
UsbScTrackingISR(
    PVOID         Context, 
    PVOID         Buffer,
    ULONG         BufferLength,
    ULONG         NotificationType,
    PBOOLEAN      QueueData)
/*++

Routine Description:
    Callback function that is called when there is a slot change notification or
    a reader error.  This handles completing card tracking irps.

Arguments:
    

Return Value:

--*/
{

    NTSTATUS            status = STATUS_SUCCESS;
    PSMARTCARD_EXTENSION SmartcardExtension = (PSMARTCARD_EXTENSION) Context;
    PUSBSC_SLOT_CHANGE_HEADER header;
    PUSBSC_HWERROR_HEADER errorHeader;
    ULONG               oldState;
    UCHAR               slotState;
    KIRQL               irql;

    __try
    {
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScTrackingISR Enter\n",DRIVER_NAME ));

        // We don't need this data to be saved
        *QueueData = FALSE;

        // Make sure that we got enough data
        if (BufferLength < sizeof(USBSC_SLOT_CHANGE_HEADER)) {

            status = STATUS_INVALID_PARAMETER;
            __leave;

        }

        header = (PUSBSC_SLOT_CHANGE_HEADER) Buffer;

        switch (header->bMessageType) {
        case RDR_to_PC_NotifySlotChange:
            slotState = header->bmSlotICCState & SLOT0_MASK;
            
            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);           
                    
            oldState = SmartcardExtension->ReaderCapabilities.CurrentState;
            if (slotState & 0x2) {

                // State changed
                if (slotState & 0x1) {

                    SmartcardDebug( DEBUG_PROTOCOL, ("%s: RDR_to_PC_NotifySlotChange - Card Inserted (0x%x)\n",DRIVER_NAME, slotState));

                    // Card is inserted
                    SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
                    
                    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                      irql);
                    if (SmartcardExtension->OsData->NotificationIrp && (oldState <= SCARD_ABSENT)) {
                        
                        UsbScCompleteCardTracking(SmartcardExtension);

                    }

                } else {

                    SmartcardDebug( DEBUG_PROTOCOL, ("%s: RDR_to_PC_NotifySlotChange - Card Removed (0x%x)\n",DRIVER_NAME, slotState));
                    // Card is removed
                    SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
                    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                      irql);

                    if (SmartcardExtension->OsData->NotificationIrp && (oldState > SCARD_ABSENT)) {
                        
                        UsbScCompleteCardTracking(SmartcardExtension);

                    }

                }

            } else {
                SmartcardDebug( DEBUG_PROTOCOL, ("%s: RDR_to_PC_NotifySlotChange - No change (0x%x)\n",DRIVER_NAME, slotState));
                KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                  irql);

            }

            break;

        case RDR_to_PC_HardwareError:

            errorHeader = (PUSBSC_HWERROR_HEADER) Buffer;

            SmartcardDebug( DEBUG_PROTOCOL, ("%s: RDR_to_PC_HardwareError - 0x%x\n",DRIVER_NAME, errorHeader->bHardwareErrorCode));
            // Lets just ignore hardware errors for now and see what happens.
            break;

        default:
            ASSERT(FALSE);
            break;

        }

    }

    __finally
    {
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScTrackingISR Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;




}


VOID
UsbScCompleteCardTracking(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:
    Checks to see if there is a pending card tracking irp, and completes it if
    necessary.

Arguments:

Return Value:

--*/
{
    KIRQL   ioIrql, 
            keIrql;
    PIRP    notificationIrp;
    KIRQL cancelIrql;


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCompleteCardTracking Enter\n",DRIVER_NAME ));

        // Grab the NotificationIrp
        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &keIrql);

        notificationIrp = SmartcardExtension->OsData->NotificationIrp;
        SmartcardExtension->OsData->NotificationIrp = NULL;

        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          keIrql);


        if (notificationIrp) {

            // Complete the irp
            if (notificationIrp->Cancel) {

               SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCompleteCardTracking Irp CANCELLED\n",DRIVER_NAME ));

               notificationIrp->IoStatus.Status = STATUS_CANCELLED;

            } else {

               SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCompleteCardTracking Completing Irp\n",DRIVER_NAME ));


               notificationIrp->IoStatus.Status = STATUS_SUCCESS;
            }

            notificationIrp->IoStatus.Information = 0;

            IoAcquireCancelSpinLock(&cancelIrql);


            // reset the cancel function so that it won't be called anymore
            IoSetCancelRoutine(notificationIrp,
                               NULL);

            IoReleaseCancelSpinLock(cancelIrql);

            IoCompleteRequest(notificationIrp,
                              IO_NO_INCREMENT);

        }

    }
        
    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!TLP3CompleteCardTracking Exit\n",DRIVER_NAME ));

    }

}


NTSTATUS
UsbScVendorIoctl(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
{
/*++

Routine Description:
    Handles vendor specific ioctls, specifically the support for PC_to_RDR_Escape
    Which allows reader vendors to implement their own features and still 
    utilize this driver.  There is no parameter checking since this is a 
    generic pass through, so it is up to the vendor to have a rock-solid
    design.

Arguments:

Return Value:

--*/

    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PUSBSC_OUT_MESSAGE_HEADER header = NULL; 
    PUSBSC_IN_MESSAGE_HEADER replyHeader = NULL;
    ULONG replySize;
    ULONG requestSize;


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScVendorIoclt Enter\n", DRIVER_NAME ));

        switch (SmartcardExtension->MajorIoControlCode) {
        case IOCTL_CCID_ESCAPE:

            if (!SmartcardExtension->ReaderExtension->EscapeCommandEnabled) {

                SmartcardDebug( DEBUG_ERROR, ("%s!UsbScVendorIoclt Escape Command Not Enabled\n", DRIVER_NAME ));
                status = STATUS_INVALID_DEVICE_REQUEST;
                __leave;
            }

            if ((MAXULONG - sizeof(USBSC_OUT_MESSAGE_HEADER)) < SmartcardExtension->IoRequest.RequestBufferLength) {
                
                SmartcardDebug( DEBUG_ERROR, ("%s!UsbScVendorIoclt Request Buffer Length is too large\n", DRIVER_NAME ));
                status = STATUS_INVALID_DEVICE_REQUEST;
                __leave;

            }

            if ((MAXULONG - sizeof(USBSC_IN_MESSAGE_HEADER)) < SmartcardExtension->IoRequest.ReplyBufferLength) {
                SmartcardDebug( DEBUG_ERROR, ("%s!UsbScVendorIoclt Reply Buffer Length is too large\n", DRIVER_NAME ));

                status = STATUS_INVALID_DEVICE_REQUEST;
                __leave;

            }

            requestSize = SmartcardExtension->IoRequest.RequestBufferLength + sizeof(USBSC_OUT_MESSAGE_HEADER);
            replySize = SmartcardExtension->IoRequest.ReplyBufferLength + sizeof(USBSC_IN_MESSAGE_HEADER);


            header = ExAllocatePool(NonPagedPool,
                                    requestSize);

            if (!header) {
                
                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            RtlZeroMemory(header, 
                          sizeof(USBSC_OUT_MESSAGE_HEADER));

            replyHeader = ExAllocatePool(NonPagedPool,
                                         replySize);

            if (!replyHeader) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            header->bMessageType = PC_to_RDR_Escape;
            header->dwLength = SmartcardExtension->IoRequest.RequestBufferLength;
            header->bSlot = 0;

            RtlCopyMemory(&header[1], 
                          SmartcardExtension->IoRequest.RequestBuffer,
                          SmartcardExtension->IoRequest.RequestBufferLength);
            
           
            status = UsbScReadWrite(SmartcardExtension,
                                    header,
                                    (PUCHAR) replyHeader,
                                    replySize,
                                    SmartcardExtension->IoRequest.ReplyBuffer,
                                    FALSE);

            if (!NT_SUCCESS(status)) {

                __leave;

            }

            if (replyHeader->bMessageType != RDR_to_PC_Escape) {

                SmartcardDebug( DEBUG_ERROR, ("%s!UsbScVendorIoclt reader returned the wrong message type\n", DRIVER_NAME ));
                status = STATUS_DEVICE_PROTOCOL_ERROR;
                __leave;
            }

            *SmartcardExtension->IoRequest.Information = replyHeader->dwLength;


            break;


        default: 
            SmartcardDebug( DEBUG_ERROR, ("%s!UsbScVendorIoclt Unsupported Vendor IOCTL\n", DRIVER_NAME ));
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    }

    __finally
    {

        if (header) {
            
            ExFreePool(header);

        }

        if (replyHeader) {

            ExFreePool(replyHeader);

        }
        
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScVendorIoclt Exit (0x%x)\n", DRIVER_NAME, status ));
        
    }

    return status;
    
    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbccid\usbsc.h ===
#if !defined( __USBSC_H__ )
#define __USBSC_H__

#define DRIVER_NAME "USBSC"
#define _ISO_TABLES_

#include <NTDDK.H>
#include "smclib.h"
#include <windef.h>
#include <usb.h>
#include "usbutil.h"
#include "scutil.h"


#define ESCAPE_COMMAND_ENABLE L"EscapeCommandEnable"

#define SMARTCARD_POOL_TAG 'DICC'
#define CCID_CLASS_DESCRIPTOR_TYPE  0x21

#define PC_to_RDR_IccPowerOn        0x62
#define PC_to_RDR_IccPowerOff       0x63
#define PC_to_RDR_GetSlotStatus     0x65
#define PC_to_RDR_XfrBlock          0x6F
#define PC_to_RDR_GetParameters     0x6C
#define PC_to_RDR_ResetParameters   0x6D
#define PC_to_RDR_SetParameters     0x61
#define PC_to_RDR_Escape            0x6B
#define PC_to_RDR_IccClock          0x6E
#define PC_to_RDR_T0APDU            0x6A
#define PC_to_RDR_Secure            0x69
#define PC_to_RDR_Mechanical        0x71
#define PC_to_RDR_Abort             0x72
#define PC_to_RDR_SetDataRateAndClockFrequency 0x73

#define RDR_to_PC_DataBlock         0x80
#define RDR_to_PC_SlotStatus        0x81
#define RDR_to_PC_Parameters        0x82
#define RDR_to_PC_Escape            0x83
#define RDR_to_PC_DataRateAndClockFrequency 0x84
                                    
#define RDR_to_PC_NotifySlotChange  0x50
#define RDR_to_PC_HardwareError     0x51

#define ABORT                       0x01
#define GET_CLOCK_FREQUENCIES       0x02
#define GET_DATA_RATES              0x03

#define CMD_ABORTED                 0xFF
#define ICC_MUTE                    0xFE
#define XFR_PARITY_ERROR            0xFD
#define XFR_OVERRUN                 0xFC
#define HW_ERROR                    0xFB

#define BAD_ATR_TS                  0xF8
#define BAD_ATR_TCK                 0xF7
#define ICC_PROTOCOL_NOT_SUPPORTED  0xF6
#define ICC_CLASS_NOT_SUPPORTED     0xF5
#define PROCEDURE_BYTE_CONFLICT     0xF4
#define DEACTIVATED_PROTOCOL        0xF3
#define BUSY_WITH_AUTO_SEQUENCE     0xF2

#define PIN_TIMEOUT                 0xF0
#define PIN_CANCELLED               0xEF

#define CMD_SLOT_BUSY               0xE0

#define COMMAND_STATUS_MASK         0xC0
#define COMMAND_STATUS_FAILED       0x40
#define COMMAND_STATUS_TIME_EXT     0x80
#define COMMAND_STATUS_SUCCESS      0x00
#define ICC_STATUS_MASK             0x03

#define CHARACTER_LEVEL             0x00
#define TPDU_LEVEL                  0x01
#define SHORT_APDU_LEVEL            0x02
#define EXTENDED_APDU_LEVEL         0x04

#define ATR_SIZE                    64

#define AUTO_PARAMETER_CONFIG       0x02
#define AUTO_ICC_ACTIVATION         0x04
#define AUTO_VOLTAGE_SELECTION      0x08
#define AUTO_CLOCK_FREQ             0x10
#define AUTO_BAUD_RATE              0x20
#define AUTO_PARAMETER_NEGOTIATION  0x40
#define AUTO_PPS                    0x80
#define AUTO_CLOCK_STOP             0x100
#define NOZERO_NAD_ACCEPT           0x200
#define AUTO_IFSD_EXCHANGE          0x400
#define TPDU_EXCHANGE_LEVEL         0x10000
#define SHORT_APDU_EXCHANGE         0x20000
#define EXT_APDU_EXCHANGE           0x40000

#define SLOT0_MASK                  0x3
#define SLOT1_MASK                  0xc
#define SLOT2_MASK                  0x30
#define SLOT3_MASK                  0xc0

#define IOCTL_CCID_ESCAPE           SCARD_CTL_CODE(3500)


#include <pshpack1.h>
typedef struct _CCID_CLASS_DESCRIPTOR
{
    BYTE    bLength;
    BYTE    bDescriptorType;
    WORD    bcdCCID;
    BYTE    bMaxSlotIndex;
    BYTE    bVoltageSupport;
    DWORD   dwProtocols;
    DWORD   dwDefaultClock;
    DWORD   dwMaximumClock;
    BYTE    bNumClockSupported;
    DWORD   dwDataRate;
    DWORD   dwMaxDataRate;
    BYTE    bNumDataRatesSupported;
    DWORD   dwMaxIFSD;
    DWORD   dwSynchProtocols;
    DWORD   dwMechanical;
    DWORD   dwFeatures;
    DWORD   dwMaxCCIDMessageLength;
    BYTE    bClassGetResponse;
    BYTE    bClassEnvelope;
    WORD    wLcdLayout;
    BYTE    bPINSupport;
    BYTE    bMaxCCIDBusySlots;

} CCID_CLASS_DESCRIPTOR, *PCCID_CLASS_DESCRIPTOR;

#include <poppack.h>

typedef struct _DEVICE_EXTENSION
{
   SCUTIL_HANDLE           ScUtilHandle;           // Utility library handle
   USB_WRAPPER_HANDLE      WrapperHandle;          //  Points to the storage used by the Usb Wrapper
   SMARTCARD_EXTENSION     SmartcardExtension;
   PDEVICE_OBJECT          LowerDeviceObject;
   PDEVICE_OBJECT          PhysicalDeviceObject;
   IO_REMOVE_LOCK          RemoveLock;
   ULONG                   DeviceInstance;
   DEVICE_POWER_STATE      PowerState;             //  Used to keep track of the current power state the reader is in
   USBD_INTERFACE_INFORMATION* Interface;
   PUSB_DEVICE_DESCRIPTOR  DeviceDescriptor;
   DEVICE_CAPABILITIES     DeviceCapabilities;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _READER_EXTENSION {

    
    BOOLEAN             CardPresent;

    USBD_PIPE_HANDLE    BulkOutHandle;
    UINT                BulkOutIndex;

    USBD_PIPE_HANDLE    BulkInHandle;
    UINT                BulkInIndex;

    USBD_PIPE_HANDLE    InterruptHandle;
    UINT                InterruptIndex;

    // Current reader power state.
//    READER_POWER_STATE  ReaderPowerState;

   // read timeout in ms
    ULONG               ReadTimeout;

    PDEVICE_OBJECT      DeviceObject;
    DWORD               SequenceNumber;

    PDEVICE_EXTENSION   DeviceExtension;

    DWORD               MaxMessageLength;

    WORD                ExchangeLevel;

    CCID_CLASS_DESCRIPTOR
                        ClassDescriptor;

    BYTE                CurrentVoltage;

    BOOLEAN             EscapeCommandEnabled;

} READER_EXTENSION, *PREADER_EXTENSION;

#include <pshpack1.h>

        
typedef struct _USBSC_OUT_MESSAGE_HEADER
{

    BYTE    bMessageType;
    DWORD   dwLength;
    BYTE    bSlot;
    BYTE    bSeq;
    
    union {

        BYTE    bPowerSelect;

        struct {
            BYTE bBWI;
            WORD wLevelParameter;
        };

        BYTE bProtocolNum;

        BYTE bClockCommand;

        struct {
            BYTE bmChanges;
            BYTE bClassGetResponse;
            BYTE bClassEnvelope;
        };

        BYTE bFunction;

    };

} USBSC_OUT_MESSAGE_HEADER, *PUSBSC_OUT_MESSAGE_HEADER;

typedef struct _USBSC_IN_MESSAGE_HEADER
{

    BYTE    bMessageType;
    DWORD   dwLength;
    BYTE    bSlot;
    BYTE    bSeq;
    BYTE    bStatus;
    BYTE    bError;

    union {
        BYTE bChainParameter;
        BYTE bClockStatus;
        BYTE bProtocolNum;
    };
           
} USBSC_IN_MESSAGE_HEADER, *PUSBSC_IN_MESSAGE_HEADER;

typedef struct _USBSC_SLOT_CHANGE_HEADER
{

    BYTE    bMessageType;
    BYTE    bmSlotICCState;

} USBSC_SLOT_CHANGE_HEADER, *PUSBSC_SLOT_CHANGE_HEADER;

typedef struct _USBSC_HWERROR_HEADER
{

    BYTE    bMessageType;
    BYTE    bSlot;
    BYTE    bSeq;
    BYTE    bHardwareErrorCode;

} USBSC_HWERROR_HEADER, *PUSBSC_HWERROR_HEADER;


typedef struct _PROTOCOL_DATA_T0
{

    BYTE    bmFindexDindex;
    BYTE    bmTCCKST0;
    BYTE    bGuardTimeT0;
    BYTE    bWaitingIntegerT0;
    BYTE    bClockStop;

} PROTOCOL_DATA_T0, *PPROTOCOL_DATA_T0;

typedef struct _PROTOCOL_DATA_T1
{
    BYTE    bmFindexDindex;
    BYTE    bmTCCKST1;
    BYTE    bGuardTimeT1;
    BYTE    bmWaitingIntegersT1;
    BYTE    bClockStop;
    BYTE    bIFSC;
    BYTE    bNadValue;

} PROTOCOL_DATA_T1, *PPROTOCOL_DATA_T1;

typedef struct _CLOCK_AND_DATA_RATE
{
    DWORD   dwClockFrequency;
    DWORD   dwDataRate;

} CLOCK_AND_DATA_RATE, *PCLOCK_AND_DATA_RATE;

typedef struct _PIN_VERIFICATION_DATA
{
    BYTE    bTimeOut;
    BYTE    bmFormatString;
    BYTE    bmPINBlockString;
    BYTE    bmPINLengthFormat;
    WORD    wPINMaxExtraDigit;
    BYTE    bEntryValidationCondition;
    BYTE    bNumberMessage;
    WORD    wLangId;
    BYTE    bMsgIndex;
    BYTE    bTeoPrologue;
    WORD    wRFU;    
} PIN_VERIFICATION_DATA, *PPIN_VERIFICATION_DATA;

typedef struct _PIN_MODIFICATION_DATA
{
    BYTE    bTimeOut;
    BYTE    bmFormatString;
    BYTE    bmPINBlockString;
    BYTE    bmPinLengthFormat;
    BYTE    bInsertionOffsetOld;
    BYTE    bInsertionOffsetNew;
    WORD    wPINMaxExtraDigit;
    BYTE    bConfirmPIN;
    BYTE    bEntryValidationCondition;
    BYTE    bNumberMessage;
    WORD    wLangId;
    BYTE    bMsgIndex1;
    BYTE    bMsgIndex2;
    BYTE    bMsgIndex3;
    BYTE    bTeoPrologue;
    WORD    wRFU;
    
} PIN_MODIFICATION_DATA, *PPIN_MODIFICATION_DATA;

typedef struct _PPS_REQUEST
{   
    BYTE    bPPSS;
    BYTE    bPPS0;
    BYTE    bPPS1;
    BYTE    bPCK;
} PPS_REQUEST, *PPPS_REQUEST;
#include <poppack.h>



NTSTATUS
DriverEntry(
    PDRIVER_OBJECT  DriverObject,
    PUNICODE_STRING RegistryPath
    );

#endif  // !__USBSC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbccid\usbscnt.c ===
#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <ntddk.h>
#include <usbdrivr.h>
#include "usbutil.h"
#include "usbsc.h"
#include "smclib.h"
#include "usbscnt.h"
#include "usbsccb.h"
#include "usbscpnp.h"
#include "usbscpwr.h"

// declare pageable/initialization code
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGEABLE, UsbScAddDevice )
#pragma alloc_text( PAGEABLE, UsbScCreateClose )
#pragma alloc_text( PAGEABLE, UsbScUnloadDriver )


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:
    Drivers DriverEntry function

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
#ifdef BETA_SPEW
#if DEBUG
    SmartcardSetDebugLevel(DEBUG_PROTOCOL | DEBUG_ERROR);
#endif
#endif
    __try
    {
        SmartcardDebug( DEBUG_TRACE, ("%s!DriverEntry Enter\n",DRIVER_NAME ));

        // Initialize the Driver Object with driver's entry points
        DriverObject->DriverUnload                          = ScUtil_UnloadDriver;
        DriverObject->MajorFunction[IRP_MJ_CREATE]          = ScUtil_CreateClose;
        DriverObject->MajorFunction[IRP_MJ_CLOSE]           = ScUtil_CreateClose;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP]         = ScUtil_Cleanup;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = ScUtil_DeviceIOControl;
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = ScUtil_SystemControl;
        DriverObject->MajorFunction[IRP_MJ_PNP]             = ScUtil_PnP;
        DriverObject->MajorFunction[IRP_MJ_POWER]           = ScUtil_Power;
        DriverObject->DriverExtension->AddDevice            = UsbScAddDevice;


    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!DriverEntry Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}



NTSTATUS
UsbScAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:
    AddDevice routine.  Creates the FDO and does initialization work.

Arguments:

Return Value:

--*/
{

    NTSTATUS                status;
    PDEVICE_EXTENSION       pDevExt;
    PSMARTCARD_EXTENSION    pSmartcardExtension;
    PREADER_EXTENSION       pReaderExtension;
    RTL_QUERY_REGISTRY_TABLE parameters[3];
    PDEVICE_OBJECT          pDevObj = NULL;
    PURB                    urb;

    __try
    {
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScAddDevice Enter\n",DRIVER_NAME ));


        // create the device object
        status = IoCreateDevice(DriverObject,
                                sizeof( DEVICE_EXTENSION ),
                                NULL,
                                FILE_DEVICE_SMARTCARD,
                                0,
                                TRUE,
                                &pDevObj);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

        // initialize device extension
        pDevExt = pDevObj->DeviceExtension;

        pSmartcardExtension = &pDevExt->SmartcardExtension;

        pDevObj->Flags |= DO_POWER_PAGABLE;

        IoInitializeRemoveLock(&pDevExt->RemoveLock,
                               SMARTCARD_POOL_TAG,
                               0,
                               10);

        pDevExt->DeviceDescriptor = NULL;
        pDevExt->Interface = NULL;

        // allocate & initialize reader extension
        pSmartcardExtension->ReaderExtension = ExAllocatePool(NonPagedPool,
                                                              sizeof( READER_EXTENSION ));

        if ( pSmartcardExtension->ReaderExtension == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }

        pReaderExtension = pSmartcardExtension->ReaderExtension;

        ASSERT( pReaderExtension != NULL );

        RtlZeroMemory(pReaderExtension, sizeof( READER_EXTENSION ));
        pReaderExtension->DeviceObject = pDevObj;

        // initialize smartcard extension - version & callbacks

        // Write the version of the lib we use to the smartcard extension
        pSmartcardExtension->Version = SMCLIB_VERSION;
        pSmartcardExtension->SmartcardRequest.BufferSize =
            pSmartcardExtension->SmartcardReply.BufferSize = MIN_BUFFER_SIZE;

        //
        // Now let the lib allocate the buffer for data transmission
        // We can either tell the lib how big the buffer should be
        // by assigning a value to BufferSize or let the lib
        // allocate the default size
        //
        status = SmartcardInitialize(pSmartcardExtension);

        if (!NT_SUCCESS(status)) {

           __leave;

        }


        pSmartcardExtension->ReaderFunction[RDF_TRANSMIT]        = UsbScTransmit;
        pSmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL]    = UsbScSetProtocol;
        pSmartcardExtension->ReaderFunction[RDF_CARD_POWER]      = UsbScCardPower;
        pSmartcardExtension->ReaderFunction[RDF_CARD_TRACKING]   = UsbScCardTracking;
        pSmartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR]    = UsbScVendorIoctl;
        pSmartcardExtension->ReaderFunction[RDF_READER_SWALLOW]  = NULL; //UsbScCardSwallow;
        pSmartcardExtension->ReaderFunction[RDF_CARD_EJECT]      = NULL; //UsbScCardEject;


        // Save deviceObject
        pSmartcardExtension->OsData->DeviceObject = pDevObj;

        pDevExt = pDevObj->DeviceExtension;

        // attach the device object to the physical device object
        pDevExt->LowerDeviceObject = IoAttachDeviceToDeviceStack(pDevObj,
                                                                 Pdo);

        ASSERT( pDevExt->LowerDeviceObject != NULL );
        

        if ( pDevExt->LowerDeviceObject == NULL ) {

            status = STATUS_UNSUCCESSFUL;
            __leave;

        }

        pDevExt->PhysicalDeviceObject = Pdo;

        pDevObj->Flags |= DO_BUFFERED_IO;
        pDevObj->Flags |= DO_POWER_PAGABLE;
        pDevObj->Flags &= ~DO_DEVICE_INITIALIZING;

        ScUtil_Initialize(&pDevExt->ScUtilHandle,
                          Pdo,
                          pDevExt->LowerDeviceObject,
                          pSmartcardExtension,
                          &pDevExt->RemoveLock,
                          UsbScStartDevice,
                          UsbScStopDevice,
                          UsbScRemoveDevice,
                          NULL,
                          UsbScSetDevicePowerState);

        }

    __finally
    {
        SmartcardDebug(DEBUG_TRACE, ( "%s!DrvAddDevice: Exit (%lx)\n", DRIVER_NAME, status ));

    }
    return status;

}


NTSTATUS 
UsbScSetDevicePowerState(
    IN PDEVICE_OBJECT        DeviceObject, 
    IN DEVICE_POWER_STATE    DeviceState,
    OUT PBOOLEAN             PostWaitWake
    )
/*++

Routine Description:
    Handles whatever changes need to be made when the device is changing
    power states.

Arguments:
    DeviceObject
    DeviceState     - the device power state that the reader is entering
    PostWaitWakeIrp - used for future compatability with WDM Wrapper

Return Value:

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       pDevExt;
    PSMARTCARD_EXTENSION    smartcardExtension;
    KIRQL                   irql;
    PIO_STACK_LOCATION      irpStack;
    __try
    {
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSetDevicePowerState Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;
        smartcardExtension = &pDevExt->SmartcardExtension;

        if (DeviceState < pDevExt->PowerState) {
            // We are coming up!

            // 
            // According to the spec, we need to assume that all cards were removed.  
            // We will get insertion notification if a card is present.
            // So if there is a removal irp pending, we should complete that.
            // 
            KeAcquireSpinLock(&smartcardExtension->OsData->SpinLock,
                              &irql);

            if (smartcardExtension->OsData->NotificationIrp) {
                irpStack = IoGetCurrentIrpStackLocation(smartcardExtension->OsData->NotificationIrp);

                if (irpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SMARTCARD_IS_ABSENT) {
                    KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                      irql);
                    UsbScCompleteCardTracking(smartcardExtension);
                    
                } else {
                    
                    KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                      irql);


                }
            } else {

                KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                  irql);

            }

            //
            // Continue polling the interrupt pipe for insertion notifications
            //
            USBStartInterruptTransfers(pDevExt->WrapperHandle);

            pDevExt->PowerState = DeviceState;




        } else if (DeviceState > pDevExt->PowerState) {

            //
            // We are going down!
            //

                                     
            // Stop polling for insertion notifications
            USBStopInterruptTransfers(pDevExt->WrapperHandle);


            pDevExt->PowerState = DeviceState;

        }

        status = STATUS_SUCCESS;

    }

    __finally
    {
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSetDevicePowerState Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbccid\usbsccb.h ===
typedef struct _IO_HEADER {
    SCARD_IO_REQUEST ScardIoRequest;
    UCHAR Asn1Data[1];      
} IO_HEADER, *PIO_HEADER;



NTSTATUS 
UsbScTransmit(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScSetProtocol(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScCardPower(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScCardTracking(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScCardSwallow(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScCardEject(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScCardATRParse(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScT0Transmit(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScT1Transmit(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS
UsbScReadWrite(
    PSMARTCARD_EXTENSION SmartcardExtension,
    PVOID WriteBuffer,
    PUCHAR ReadBuffer,
    WORD ReadLength,
    PVOID ResponseBuffer,
    BOOL NullByte
    );

NTSTATUS
UsbScErrorConvert(
    PUSBSC_IN_MESSAGE_HEADER ReplyHeader
    );

NTSTATUS
UsbScTrackingISR(
    PVOID         Context, 
    PVOID         Buffer,
    ULONG         BufferLength,
    ULONG         NotificationType,
    PBOOLEAN      QueueData
    );

VOID
UsbScCompleteCardTracking(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
UsbScVendorIoctl(
    PSMARTCARD_EXTENSION SmartcardExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbccid\usbscpnp.c ===
#include "usbsc.h"
#include "usbscpnp.h"
#include "usbutil.h"
#include "usbcom.h"
#include "usbsccb.h"
#include "usbscnt.h"

          
#define NUM_DATA_RATES 10

#define NUM_CLOCK_FRQ 14

NTSTATUS
UsbScStartDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Handles the IRP_MN_START_DEVICE
    Gets the usb descriptors from the reader and configures it.
    Also starts "polling" the interrupt pipe

Arguments:

Return Value:

--*/
{

    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       pDevExt;
    PSMARTCARD_EXTENSION    smartcardExtension;
    PREADER_EXTENSION       readerExtension;
    ULONG                   deviceInstance;
    UCHAR                   string[MAXIMUM_ATTR_STRING_LENGTH];
    HANDLE                  regKey;
    PKEY_VALUE_PARTIAL_INFORMATION pInfo;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScStartDevice Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;
        smartcardExtension = &pDevExt->SmartcardExtension;
        readerExtension = smartcardExtension->ReaderExtension;



        status = UsbConfigureDevice(DeviceObject);

        if (!NT_SUCCESS(status)) {
            __leave;
        }


        //
        // Set the vendor information
        //


        status = GetStringDescriptor(DeviceObject,
                                     pDevExt->DeviceDescriptor->iManufacturer,
                                     smartcardExtension->VendorAttr.VendorName.Buffer,
                                     &smartcardExtension->VendorAttr.VendorName.Length);

        status = GetStringDescriptor(DeviceObject,
                                     pDevExt->DeviceDescriptor->iProduct,
                                     smartcardExtension->VendorAttr.IfdType.Buffer,
                                     &smartcardExtension->VendorAttr.IfdType.Length);

        status = GetStringDescriptor(DeviceObject,
                                     pDevExt->DeviceDescriptor->iSerialNumber,
                                     smartcardExtension->VendorAttr.IfdSerialNo.Buffer,
                                     &smartcardExtension->VendorAttr.IfdSerialNo.Length);

        
        smartcardExtension->VendorAttr.UnitNo = MAXULONG;

        for (deviceInstance = 0; deviceInstance < MAXULONG; deviceInstance++) {

           PDEVICE_OBJECT devObj;

           for (devObj = DeviceObject; devObj != NULL; devObj = devObj->NextDevice) {

               PDEVICE_EXTENSION devExt = devObj->DeviceExtension;
               PSMARTCARD_EXTENSION smcExt = &devExt->SmartcardExtension;

               if (deviceInstance == smcExt->VendorAttr.UnitNo) {

                  break;

               }

           }

           if (devObj == NULL) {

              smartcardExtension->VendorAttr.UnitNo = deviceInstance;
              break;

           }

        }


        //
        // Initialize Reader Capabilities
        //
        smartcardExtension->ReaderCapabilities.SupportedProtocols 
                                = readerExtension->ClassDescriptor.dwProtocols;

        smartcardExtension->ReaderCapabilities.ReaderType = SCARD_READER_TYPE_USB;

        smartcardExtension->ReaderCapabilities.MechProperties = 0;      // Not currently supporting any Mechanical properties

        smartcardExtension->ReaderCapabilities.Channel = smartcardExtension->VendorAttr.UnitNo;

        // Assume card is absent.
        smartcardExtension->ReaderCapabilities.CurrentState = (ULONG) SCARD_ABSENT;


        smartcardExtension->ReaderCapabilities.CLKFrequency.Default 
                                = readerExtension->ClassDescriptor.dwDefaultClock;

        smartcardExtension->ReaderCapabilities.CLKFrequency.Max 
                                = readerExtension->ClassDescriptor.dwMaximumClock;

        smartcardExtension->ReaderCapabilities.DataRate.Default 
                                = readerExtension->ClassDescriptor.dwDataRate;

        smartcardExtension->ReaderCapabilities.DataRate.Max 
                                = readerExtension->ClassDescriptor.dwMaxDataRate;

        smartcardExtension->ReaderCapabilities.MaxIFSD 
                                = readerExtension->ClassDescriptor.dwMaxIFSD;

        // See if the escape command should be allowed
        status = IoOpenDeviceRegistryKey(pDevExt->PhysicalDeviceObject,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         GENERIC_READ,
                                         &regKey);

        if (!NT_SUCCESS(status)) {

            readerExtension->EscapeCommandEnabled = FALSE;

        } else {

            UNICODE_STRING strEnable;
            ULONG tmp = 0;
            ULONG size;
            ULONG length;

            length = sizeof(KEY_VALUE_PARTIAL_INFORMATION)  + sizeof(ULONG);

            pInfo = ExAllocatePool(PagedPool, length);

            if (pInfo) {
                
                RtlInitUnicodeString (&strEnable, ESCAPE_COMMAND_ENABLE);
                status = ZwQueryValueKey(regKey,
                                         &strEnable,
                                         KeyValuePartialInformation,
                                         pInfo,
                                         length,
                                         &size);

                
            }

            ZwClose(regKey);

            if (!NT_SUCCESS(status)) {
                readerExtension->EscapeCommandEnabled = FALSE;
            } else {
                readerExtension->EscapeCommandEnabled = *((PULONG)pInfo->Data) ? TRUE : FALSE;
            }

            ExFreePool(pInfo);


        }


        if (readerExtension->EscapeCommandEnabled) {
            SmartcardDebug( DEBUG_PROTOCOL, ("%s : Escape Command Enabled\n",DRIVER_NAME ));
        } else {
            SmartcardDebug( DEBUG_PROTOCOL, ("%s : Escape Command Disabled\n",DRIVER_NAME ));
        }



        //
        // Get clock frequencies and data rates
        //

        if (readerExtension->ClassDescriptor.bNumClockSupported) { 
        
            // Doesn't support auto clock frequency selection
            ULONG   bufferLength;

            bufferLength = readerExtension->ClassDescriptor.bNumClockSupported * sizeof(DWORD);

            smartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.List 
                        = ExAllocatePool(NonPagedPool,
                                         bufferLength);

            if (!smartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.List) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            ASSERT(pDevExt->LowerDeviceObject);
            status = USBClassRequest(pDevExt->LowerDeviceObject,
                                     Interface,
                                     GET_CLOCK_FREQUENCIES,
                                     0,
                                     pDevExt->Interface->InterfaceNumber,
                                     smartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.List,
                                     &bufferLength,
                                     TRUE,
                                     0,
                                     &pDevExt->RemoveLock);

            if (!NT_SUCCESS(status)) {

                __leave;
                
            }

            smartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.Entries 
                = readerExtension->ClassDescriptor.bNumClockSupported;
          
        } 

        if (readerExtension->ClassDescriptor.bNumDataRatesSupported) {
            
            ULONG   bufferLength;

            bufferLength = readerExtension->ClassDescriptor.bNumDataRatesSupported * sizeof(DWORD);

            smartcardExtension->ReaderCapabilities.DataRatesSupported.List 
                = ExAllocatePool(NonPagedPool,
                                 bufferLength);

            if (!smartcardExtension->ReaderCapabilities.DataRatesSupported.List) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            ASSERT(pDevExt->LowerDeviceObject);
            status = USBClassRequest(pDevExt->LowerDeviceObject,
                                     Interface,
                                     GET_DATA_RATES,
                                     0,
                                     pDevExt->Interface->InterfaceNumber,
                                     smartcardExtension->ReaderCapabilities.DataRatesSupported.List,
                                     &bufferLength,
                                     TRUE,
                                     0,
                                     &pDevExt->RemoveLock);

            if (!NT_SUCCESS(status)) {
                
                __leave;

            }

            smartcardExtension->ReaderCapabilities.DataRatesSupported.Entries 
                    = readerExtension->ClassDescriptor.bNumDataRatesSupported;
            
        } else {
            // Can't get the list of supported data rates, so lets just guess

            ULONG   bufferLength = 0;
            UCHAR   numRates = 0;
            struct _DataRatesSupported *DataRates;
            USHORT i;
            USHORT j;
            DWORD  tempRates[NUM_CLOCK_FRQ*NUM_DATA_RATES*2];
            ULONG  fs;
            DWORD  dataRate;


            DataRates = &smartcardExtension->ReaderCapabilities.DataRatesSupported;

            // Calc the data rates:
            fs = readerExtension->ClassDescriptor.dwDefaultClock * 1000;

            while(fs) {
            
                for(i = 0; i < NUM_CLOCK_FRQ; i++) {
                    for(j=0; j < NUM_DATA_RATES; j++) {
                        if (BitRateAdjustment[j].DNumerator && ClockRateConversion[i].F) {
                            
                            dataRate = 
                                (BitRateAdjustment[j].DNumerator * 
                                 fs) / 
                                (BitRateAdjustment[j].DDivisor * 
                                 ClockRateConversion[i].F);

                            if ((dataRate >= readerExtension->ClassDescriptor.dwDataRate) &&
                                (dataRate <= readerExtension->ClassDescriptor.dwMaxDataRate)) {

                                tempRates[numRates++] = dataRate;
                                
                            }                                   
                            
                        }

                    }

                }

                if (readerExtension->ClassDescriptor.dwMaximumClock * 1000  
                    > fs) {
                    fs = readerExtension->ClassDescriptor.dwMaximumClock * 1000;
                } else {
                    fs = 0;
                }

            }


            
            bufferLength = numRates * sizeof(DWORD);

            DataRates->List 
                = ExAllocatePool(NonPagedPool,
                                 bufferLength);

            if (!DataRates->List) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            RtlCopyMemory(DataRates->List,
                          &tempRates[0],
                          bufferLength);
            
             
            DataRates->Entries = numRates;


        }

        ASSERT(pDevExt->LowerDeviceObject);
        pDevExt->WrapperHandle = USBInitializeInterruptTransfers(DeviceObject,
                                                                 pDevExt->LowerDeviceObject,
                                                                 sizeof(USBSC_HWERROR_HEADER),
                                                                 &pDevExt->Interface->Pipes[readerExtension->InterruptIndex],
                                                                 smartcardExtension,
                                                                 UsbScTrackingISR,
                                                                 USBWRAP_NOTIFICATION_READ_COMPLETE,
                                                                 &pDevExt->RemoveLock);

        status = USBStartInterruptTransfers(pDevExt->WrapperHandle);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScStartDevice Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}

NTSTATUS
UsbScStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Handles IRP_MN_STOP_DEVICE
    Stops "polling" the interrupt pipe and frees resources allocated in StartDevice

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;
    PSCARD_READER_CAPABILITIES readerCapabilities;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScStopDevice Enter\n",DRIVER_NAME ));

        if (!DeviceObject) {
            __leave;
        }

        pDevExt = DeviceObject->DeviceExtension;
        readerCapabilities = &pDevExt->SmartcardExtension.ReaderCapabilities;

        status = USBStopInterruptTransfers(pDevExt->WrapperHandle);
        status = USBReleaseInterruptTransfers(pDevExt->WrapperHandle);

        if (readerCapabilities->CLKFrequenciesSupported.List &&
            readerCapabilities->CLKFrequenciesSupported.List != &readerCapabilities->CLKFrequency.Default) {
            // We allocated the list.
            ExFreePool(readerCapabilities->CLKFrequenciesSupported.List);

        }

        if (readerCapabilities->DataRatesSupported.List && 
            readerCapabilities->DataRatesSupported.List != &readerCapabilities->DataRate.Default) {
            // We allocated the list.
            ExFreePool(readerCapabilities->DataRatesSupported.List);

        }

        if (pDevExt->DeviceDescriptor) {

           ExFreePool(pDevExt->DeviceDescriptor);
           pDevExt->DeviceDescriptor = NULL;

        }

        if (pDevExt->Interface) {

           ExFreePool(pDevExt->Interface);
           pDevExt->Interface = NULL;

        }
        
    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScStopDevice Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}


NTSTATUS
UsbScRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    handles IRP_MN_REMOVE_DEVICE
    stops and unloads the device.

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScRemoveDevice Enter\n",DRIVER_NAME ));

        UsbScStopDevice(DeviceObject,
                        Irp);

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScRemoveDevice Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbsc\usbcom.h ===
#include "usbsc.h"

NTSTATUS
UsbWrite(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pData,
   ULONG             DataLen,
   LONG              Timeout
   );

NTSTATUS
UsbRead(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pData,
   ULONG             DataLen,
   LONG              Timeout
   );

NTSTATUS
UsbSelectInterfaces(
   IN PDEVICE_OBJECT DeviceObject,
   IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
   );

NTSTATUS
UsbConfigureDevice(
   IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS
GetStringDescriptor(
    PDEVICE_OBJECT DeviceObject,
    UCHAR          StringIndex,
    PUCHAR         StringBuffer,
    PUSHORT         StringLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbsc\usbsccb.h ===
typedef struct _IO_HEADER {
    SCARD_IO_REQUEST ScardIoRequest;
    UCHAR Asn1Data[1];      
} IO_HEADER, *PIO_HEADER;



NTSTATUS 
UsbScTransmit(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScSetProtocol(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScCardPower(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScCardTracking(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScCardSwallow(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScCardEject(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScCardATRParse(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScT0Transmit(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS 
UsbScT1Transmit(
   PSMARTCARD_EXTENSION  SmartcardExtension
   );

NTSTATUS
UsbScReadWrite(
    PSMARTCARD_EXTENSION SmartcardExtension,
    PVOID WriteBuffer,
    PUCHAR ReadBuffer,
    WORD ReadLength,
    PVOID ResponseBuffer,
    BOOL NullByte
    );

NTSTATUS
UsbScErrorConvert(
    PUSBSC_IN_MESSAGE_HEADER ReplyHeader
    );

NTSTATUS
UsbScTrackingISR(
    PVOID         Context, 
    PVOID         Buffer,
    ULONG         BufferLength,
    ULONG         NotificationType,
    PBOOLEAN      QueueData
    );

VOID
UsbScCompleteCardTracking(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
UsbScVendorIoctl(
    PSMARTCARD_EXTENSION SmartcardExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbccid\usbscpnp.h ===
NTSTATUS
UsbScStartDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScSurpriseRemoval(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScQueryStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScCancelStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScQueryRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScCancelRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbccid\usbscnt.h ===
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
UsbScAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

VOID
UsbScUnloadDriver(
    PDRIVER_OBJECT    DriverObject
    );

NTSTATUS
UsbScCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
UsbScCreateClose(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );

NTSTATUS
UsbScDeviceIoControl(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );

NTSTATUS
UsbScPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UsbScPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UsbScCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS 
UsbScSetDevicePowerState(
    IN PDEVICE_OBJECT        DeviceObject, 
    IN DEVICE_POWER_STATE    DeviceState,
    OUT PBOOLEAN             PostWaitWakeIrp
    );

NTSTATUS
UsbScSystemControl(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    );

NTSTATUS
UsbScDefaultPnpHandler(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScForwardAndWait(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS 
OnRequestComplete(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PKEVENT         Event
    );

NTSTATUS 
IncIoCount(
    PDEVICE_EXTENSION DevExt
    );

NTSTATUS 
DecIoCount(
    PDEVICE_EXTENSION DevExt
    );

VOID
UsbScUnloadDevice(
    PDEVICE_OBJECT DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbsc\usbscnt.h ===
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
UsbScAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

VOID
UsbScUnloadDriver(
    PDRIVER_OBJECT    DriverObject
    );

NTSTATUS
UsbScCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
UsbScCreateClose(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );

NTSTATUS
UsbScDeviceIoControl(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );

NTSTATUS
UsbScPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UsbScPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UsbScCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS 
UsbScSetDevicePowerState(
    IN PDEVICE_OBJECT        DeviceObject, 
    IN DEVICE_POWER_STATE    DeviceState,
    OUT PBOOLEAN             PostWaitWakeIrp
    );

NTSTATUS
UsbScSystemControl(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    );

NTSTATUS
UsbScDefaultPnpHandler(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScForwardAndWait(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS 
OnRequestComplete(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PKEVENT         Event
    );

NTSTATUS 
IncIoCount(
    PDEVICE_EXTENSION DevExt
    );

NTSTATUS 
DecIoCount(
    PDEVICE_EXTENSION DevExt
    );

VOID
UsbScUnloadDevice(
    PDEVICE_OBJECT DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbccid\usbscpwr.h ===
NTSTATUS
UsbScDevicePower(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScSystemPower(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScSystemPowerCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    );

VOID
UsbScDeviceRequestCompletion(
    PDEVICE_OBJECT  DeviceObject,
    UCHAR           MinorFunction,
    POWER_STATE     PowerState,
    PVOID           Context,
    PIO_STATUS_BLOCK    IoStatus
    );

NTSTATUS
UsbScDevicePowerUpCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbccid\usbscpwr.c ===
#include "usbsc.h"

#include "usbscpwr.h"
#include "usbscnt.h"

NTSTATUS
UsbScDevicePower(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Handles Device Power Irps

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;
    PIO_STACK_LOCATION  stack;
    BOOLEAN             postWaitWake;
    POWER_STATE  state;



    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScDevicePower Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;
        stack = IoGetCurrentIrpStackLocation(Irp);
        state.DeviceState = stack->Parameters.Power.State.DeviceState;

        switch (stack->MinorFunction) {
        case IRP_MN_QUERY_POWER:

            // 
            // Since we can always wait for our irps to complete, so we just always succeed
            //

            IoReleaseRemoveLock(&pDevExt->RemoveLock,
                                Irp);
            PoStartNextPowerIrp(Irp);


            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(pDevExt->LowerDeviceObject,
                                  Irp);



            
            break;

        case IRP_MN_SET_POWER:

            if (state.DeviceState < pDevExt->PowerState) {

                //
                // We are coming up!!  We must let lower drivers power up before we do
                //
                IoMarkIrpPending(Irp);
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       UsbScDevicePowerUpCompletion,
                                       pDevExt,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                status = PoCallDriver(pDevExt->LowerDeviceObject,
                                      Irp);

                status = STATUS_PENDING;

            } else {

                //
                // We are moving to a lower power state, so we handle it before
                // passing it down
                //

                status = UsbScSetDevicePowerState(DeviceObject,
                                                  state.DeviceState,
                                                  &postWaitWake);
                

                PoSetPowerState(DeviceObject,
                                DevicePowerState,
                                state);


                IoReleaseRemoveLock(&pDevExt->RemoveLock,
                                    Irp);
                PoStartNextPowerIrp(Irp);
                IoSkipCurrentIrpStackLocation(Irp);

                status = PoCallDriver(pDevExt->LowerDeviceObject,
                                      Irp);

            }
            break;
        default:
            // We shouldn't be here
            ASSERT(FALSE);
            break;
        }

        

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScDevicePower Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;


}

NTSTATUS
UsbScSystemPower(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Handles system power irps

Arguments:

Return Value:

--*/
{

    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSystemPower Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;


        IoMarkIrpPending(Irp);
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               UsbScSystemPowerCompletion,
                               pDevExt,
                               TRUE,
                               TRUE,
                               TRUE);

        status = PoCallDriver(pDevExt->LowerDeviceObject,
                              Irp);

        status = STATUS_PENDING;



    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSystemPower Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;


}

NTSTATUS
UsbScSystemPowerCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    )
/*++

Routine Description:
    Completion routine called after system power irp has been passed down the stack.
    handles mapping system state to device state and requests the device power irp.

Arguments:

Return Value:

--*/
{

    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;
    PIO_STACK_LOCATION  irpStack;
    POWER_STATE         state;
    POWER_STATE         systemState;


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSystemPowerCompletion Enter\n",DRIVER_NAME ));
        pDevExt = (PDEVICE_EXTENSION) Context;

        if (!NT_SUCCESS(Irp->IoStatus.Status)) {
            SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSystemPowerCompletion SIRP failed by lower driver\n",DRIVER_NAME ));

            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp,
                              IO_NO_INCREMENT);
            status = Irp->IoStatus.Status;
            IoReleaseRemoveLock(&pDevExt->RemoveLock,
                                Irp);
            __leave;
        }

        irpStack = IoGetCurrentIrpStackLocation(Irp);

        systemState = irpStack->Parameters.Power.State;
        state.DeviceState = pDevExt->DeviceCapabilities.DeviceState[systemState.SystemState];

        status = PoRequestPowerIrp(DeviceObject,
                                   irpStack->MinorFunction,
                                   state,
                                   UsbScDeviceRequestCompletion,
                                   (PVOID) Irp,
                                   NULL);

        ASSERT(NT_SUCCESS(status));

        status = STATUS_MORE_PROCESSING_REQUIRED;


    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSystemPowerCompletion Exit : 0x%x\n",DRIVER_NAME, status ));


    }

    return status;

}



VOID
UsbScDeviceRequestCompletion(
    PDEVICE_OBJECT  DeviceObject,
    UCHAR           MinorFunction,
    POWER_STATE     PowerState,
    PVOID           Context,
    PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:
    Completion routine called after device power irp completes.
    Completes the system power irp.

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;
    PIRP                irp;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScDeviceRequestCompletion Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;
        irp = (PIRP) Context;

        PoStartNextPowerIrp(irp);
        irp->IoStatus.Status = IoStatus->Status;
        IoCompleteRequest(irp,
                          IO_NO_INCREMENT);

        IoReleaseRemoveLock(&pDevExt->RemoveLock,
                            irp);

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScDeviceRequestCompletion Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return;


}


NTSTATUS
UsbScDevicePowerUpCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    )
/*++

Routine Description:
    Completion routine called after device irp for higher power state has been
    passed down the stack.

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;
    PIO_STACK_LOCATION  irpStack;
    BOOLEAN             postWaitWake; // We don't really care about this



    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScDevicePowerUpCompletion Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;
        
        irpStack = IoGetCurrentIrpStackLocation(Irp);


        status = UsbScSetDevicePowerState(DeviceObject,
                                          irpStack->Parameters.Power.State.DeviceState,
                                          &postWaitWake);

        PoSetPowerState(DeviceObject,
                        DevicePowerState,
                        irpStack->Parameters.Power.State);

        PoStartNextPowerIrp(Irp);
 
    }

    __finally
    {

        IoReleaseRemoveLock(&pDevExt->RemoveLock,
                            Irp);

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScDevicePowerUpCompletion Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbsc\usbscpnp.h ===
NTSTATUS
UsbScStartDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScSurpriseRemoval(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScQueryStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScCancelStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScQueryRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScCancelRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbsc\usbscpwr.h ===
NTSTATUS
UsbScDevicePower(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScSystemPower(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
UsbScSystemPowerCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    );

VOID
UsbScDeviceRequestCompletion(
    PDEVICE_OBJECT  DeviceObject,
    UCHAR           MinorFunction,
    POWER_STATE     PowerState,
    PVOID           Context,
    PIO_STATUS_BLOCK    IoStatus
    );

NTSTATUS
UsbScDevicePowerUpCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbsc\usbcom.c ===
#include "usbcom.h"
#include "usbsc.h"
#include <usbutil.h>
#include <usb.h>
#include <usbdlib.h>


NTSTATUS
UsbWrite(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pData,
   ULONG             DataLen,
   LONG              Timeout)
/*++
Description:
   Write data to the usb port

Arguments:
   ReaderExtension   context of call
   pData             ptr to data buffer
   DataLen           length of data buffer

Return Value:
   NTSTATUS

--*/
{
   NTSTATUS             status = STATUS_SUCCESS;
   PURB                 pUrb = NULL;
   PDEVICE_OBJECT       DeviceObject;
   PDEVICE_EXTENSION    DeviceExtension;
   ULONG                ulSize;

   __try 
   {
       
       SmartcardDebug( DEBUG_TRACE, ("%s!UsbWrite Enter\n",DRIVER_NAME ));

       DeviceObject = ReaderExtension->DeviceObject;
       DeviceExtension = DeviceObject->DeviceExtension;


       ulSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
       pUrb = ExAllocatePool( NonPagedPool, 
                              ulSize );

       if(pUrb == NULL) {

          status = STATUS_INSUFFICIENT_RESOURCES;

       } else {

          UsbBuildInterruptOrBulkTransferRequest(pUrb,
                                                 (USHORT)ulSize,
                                                 ReaderExtension->BulkOutHandle,
                                                 pData,
                                                 NULL,
                                                 DataLen,
                                                 USBD_SHORT_TRANSFER_OK,
                                                 NULL);

          status = USBCallSync(DeviceExtension->LowerDeviceObject, 
                               pUrb,
                               Timeout,
                               &DeviceExtension->RemoveLock);
          ExFreePool( pUrb );
          pUrb = NULL;

       }
          
   }

   __finally 
   {
       if (pUrb) {
           ExFreePool(pUrb);
           pUrb = NULL;
       }

       SmartcardDebug( DEBUG_TRACE, ("%s!UsbWrite Exit : 0x%x\n",DRIVER_NAME, status ));

   }

   return status;
   
}

NTSTATUS
UsbRead(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pData,
   ULONG             DataLen,
   LONG              Timeout)
/*++
Description:
   Read data from the USB bus

Arguments:
   ReaderExtension   context of call
   pData             ptr to data buffer
   DataLen           length of data buffer
   pNBytes           number of bytes returned

Return Value:
   STATUS_SUCCESS
   STATUS_BUFFER_TOO_SMALL
   STATUS_UNSUCCESSFUL

--*/
{
   NTSTATUS             status = STATUS_SUCCESS;
   PURB                 pUrb = NULL;
   PDEVICE_OBJECT       DeviceObject;
   PDEVICE_EXTENSION    DeviceExtension;
   ULONG                ulSize;

   __try 
   {
       
       SmartcardDebug( DEBUG_TRACE, ("%s!UsbRead Enter\n",DRIVER_NAME ));
       
       DeviceObject = ReaderExtension->DeviceObject;
       DeviceExtension = DeviceObject->DeviceExtension;

       ulSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
       pUrb = ExAllocatePool( NonPagedPool, 
                              ulSize );

       if(pUrb == NULL) {

          status = STATUS_INSUFFICIENT_RESOURCES;
          __leave;

       } else {

          UsbBuildInterruptOrBulkTransferRequest(pUrb,
                                                 (USHORT)ulSize,
                                                 ReaderExtension->BulkInHandle,
                                                 pData,
                                                 NULL,
                                                 DataLen,
                                                 USBD_SHORT_TRANSFER_OK,
                                                 NULL);

          status = USBCallSync(DeviceExtension->LowerDeviceObject, 
                               pUrb,
                               Timeout,
                               &DeviceExtension->RemoveLock);

       }

   }

   __finally 
   {

       if (pUrb) {
           ExFreePool(pUrb);
           pUrb = NULL;
       }
       SmartcardDebug( DEBUG_TRACE, ("%s!UsbRead Exit : 0x%x\n",DRIVER_NAME, status ));

   }

   return status;

}


NTSTATUS
UsbConfigureDevice(
   IN PDEVICE_OBJECT DeviceObject
   )
/*++

Routine Description:
    Initializes a given instance of the device on the USB and
   selects and saves the configuration.
   Also saves the Class Descriptor and the pipe handles.

Arguments:

   DeviceObject - pointer to the physical device object for this instance of the device.


Return Value:

    NT status code


--*/
{
   PDEVICE_EXTENSION    pDevExt; 
   PSMARTCARD_EXTENSION smartcardExt;
   PREADER_EXTENSION    readerExt;
   NTSTATUS             status = STATUS_SUCCESS;
   PURB                 pUrb = NULL;
   ULONG                ulSize;
   PUSB_CONFIGURATION_DESCRIPTOR 
                        ConfigurationDescriptor = NULL;
   PUSB_COMMON_DESCRIPTOR   
                        comDesc;
   UINT                 i;

    __try 
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbConfigureDevice Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;
        smartcardExt = &pDevExt->SmartcardExtension;
        readerExt = smartcardExt->ReaderExtension;
       
        pUrb = ExAllocatePool(NonPagedPool,
                              sizeof( struct _URB_CONTROL_DESCRIPTOR_REQUEST ));

        if( pUrb == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }

        //
        // Get the device descriptor
        //
        pDevExt->DeviceDescriptor = ExAllocatePool(NonPagedPool,
                                                   sizeof(USB_DEVICE_DESCRIPTOR));

        if(pDevExt->DeviceDescriptor == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
           __leave;

        }

        UsbBuildGetDescriptorRequest(pUrb,
                                     sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_DEVICE_DESCRIPTOR_TYPE,
                                     0,
                                     0,
                                     pDevExt->DeviceDescriptor,
                                     NULL,
                                     sizeof(USB_DEVICE_DESCRIPTOR),
                                     NULL);

        // Send the urb to the USB driver
        status = USBCallSync(pDevExt->LowerDeviceObject,
                             pUrb,
                             0,
                             &pDevExt->RemoveLock);

        if(!NT_SUCCESS(status)) {

           __leave;

        }


        // When USB_CONFIGURATION_DESCRIPTOR_TYPE is specified for DescriptorType
        // in a call to UsbBuildGetDescriptorRequest(),
        // all interface, endpoint, class-specific, and vendor-specific descriptors
        // for the configuration also are retrieved.
        // The caller must allocate a buffer large enough to hold all of this
        // information or the data is truncated without error.
        // Therefore the 'siz' set below is just a guess, and we may have to retry
        ulSize = sizeof( USB_CONFIGURATION_DESCRIPTOR );

        // We will break out of this 'retry loop' when UsbBuildGetDescriptorRequest()
        // has a big enough deviceExtension->UsbConfigurationDescriptor buffer not to truncate
        while( 1 ) {

            ConfigurationDescriptor = ExAllocatePool( NonPagedPool, ulSize );

            if(ConfigurationDescriptor == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            UsbBuildGetDescriptorRequest(pUrb,
                                         sizeof( struct _URB_CONTROL_DESCRIPTOR_REQUEST ),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         ConfigurationDescriptor,
                                         NULL,
                                         ulSize,
                                         NULL );

            status = USBCallSync(pDevExt->LowerDeviceObject,
                                 pUrb,
                                 0,
                                 &pDevExt->RemoveLock);
                                  
            // if we got some data see if it was enough.
            // NOTE: we may get an error in URB because of buffer overrun
            if (pUrb->UrbControlDescriptorRequest.TransferBufferLength == 0 ||
                ConfigurationDescriptor->wTotalLength <= ulSize) {

                break;

            }

            ulSize = ConfigurationDescriptor->wTotalLength;
            ExFreePool(ConfigurationDescriptor);
            ConfigurationDescriptor = NULL;

        }

        //
        // We have the configuration descriptor for the configuration we want.
        // Now we issue the select configuration command to get
        // the  pipes associated with this configuration.
        //
        if(!NT_SUCCESS(status)) {

            __leave;

        }

        status = UsbSelectInterfaces(DeviceObject,
                                     ConfigurationDescriptor);
        
        if (!NT_SUCCESS(status)) {

            __leave;

        }

        //
        // Get the pipe handles from the interface
        //
        for (i = 0; i < pDevExt->Interface->NumberOfPipes; i++) {

            if (pDevExt->Interface->Pipes[i].PipeType == USB_ENDPOINT_TYPE_INTERRUPT) {

                readerExt->InterruptHandle = pDevExt->Interface->Pipes[i].PipeHandle;
                readerExt->InterruptIndex = i;

            } else if (pDevExt->Interface->Pipes[i].PipeType == USB_ENDPOINT_TYPE_BULK) {

                if (pDevExt->Interface->Pipes[i].EndpointAddress & 0x80) {  // Bulk-in pipe

                    readerExt->BulkInHandle = pDevExt->Interface->Pipes[i].PipeHandle;
                    readerExt->BulkInIndex = i;

                } else {    // Bulk-out pipe
                    
                    readerExt->BulkOutHandle = pDevExt->Interface->Pipes[i].PipeHandle;
                    readerExt->BulkOutIndex = i;

                }
            }
        }

        // 
        // Get CCID Class Descriptor
        //

        comDesc = USBD_ParseDescriptors(ConfigurationDescriptor,
                                        ConfigurationDescriptor->wTotalLength,
                                        ConfigurationDescriptor,
                                        CCID_CLASS_DESCRIPTOR_TYPE);

        ASSERT(comDesc);

     

        readerExt->ClassDescriptor = *((CCID_CLASS_DESCRIPTOR *) comDesc);
        readerExt->ExchangeLevel = (WORD) (readerExt->ClassDescriptor.dwFeatures >> 16);
        


    }

    __finally 
    {

        if( pUrb ) {

            ExFreePool( pUrb );
            pUrb = NULL;

        }

        if( ConfigurationDescriptor ) {

            ExFreePool( ConfigurationDescriptor );
            ConfigurationDescriptor = NULL;

        }

        if (!NT_SUCCESS(status) && pDevExt->DeviceDescriptor) {

            ExFreePool(pDevExt->DeviceDescriptor);
            pDevExt->DeviceDescriptor = NULL;

        }

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbConfigureDevice Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}

NTSTATUS
UsbSelectInterfaces(
   IN PDEVICE_OBJECT DeviceObject,
   IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
   )
/*++

Routine Description:
    Initializes a USB reader with (possibly) multiple interfaces;


Arguments:
    DeviceObject - pointer to the device object for this instance of the device.

    ConfigurationDescriptor - pointer to the USB configuration
                    descriptor containing the interface and endpoint
                    descriptors.


Return Value:

    NT status code

--*/
{

    PDEVICE_EXTENSION           pDevExt;
    NTSTATUS                    status;
    PURB                        pUrb = NULL;
    USHORT                      usSize;
    ULONG                       ulNumberOfInterfaces, i;
    UCHAR                       ucNumberOfPipes, 
                                ucAlternateSetting, 
                                ucMyInterfaceNumber;
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION InterfaceObject;
    USBD_INTERFACE_LIST_ENTRY   interfaces[2];


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbSelectInterfaces Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;

        ASSERT(pDevExt->Interface == NULL);

        //
        // USBD_ParseConfigurationDescriptorEx searches a given configuration
        // descriptor and returns a pointer to an interface that matches the
        //  given search criteria.
        //
        InterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(ConfigurationDescriptor,
                                                                  ConfigurationDescriptor, //search from start of config  descriptro
                                                                  -1,   // interface number not a criteria; 
                                                                  -1,   // not interested in alternate setting here either
                                                                  0x0b,   // CCID Device Class
                                                                  -1,   // interface subclass not a criteria
                                                                  -1);  // interface protocol not a criteria

        ASSERT( InterfaceDescriptor != NULL );

        if (InterfaceDescriptor == NULL) {

            status = STATUS_UNSUCCESSFUL;   
            __leave;

        }

        interfaces[0].InterfaceDescriptor = InterfaceDescriptor;
        interfaces[1].InterfaceDescriptor = NULL;
        
        pUrb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, 
                                                 interfaces);    

        if (pUrb == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }
        ASSERT(pDevExt->LowerDeviceObject);

        status = USBCallSync(pDevExt->LowerDeviceObject,
                             pUrb,
                             0,
                             &pDevExt->RemoveLock);


        if(!NT_SUCCESS(status)) {
            
            __leave;

        }
                                
        // save a copy of the interface information returned
        InterfaceObject = interfaces[0].Interface;

        ASSERT(pDevExt->Interface == NULL);
        pDevExt->Interface = ExAllocatePool(NonPagedPool,
                                            InterfaceObject->Length);

        if (pDevExt->Interface == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }


        RtlCopyMemory(pDevExt->Interface,
                      InterfaceObject,
                      InterfaceObject->Length);

        
    }

    __finally
    {

        if (pUrb) {

            ExFreePool(pUrb);
            pUrb = NULL;

        }
        
        if (!NT_SUCCESS(status)) {

            if (pDevExt->Interface) {

                ExFreePool(pDevExt->Interface);
                pDevExt->Interface = NULL;

            }

        }

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbSelectInterfaces Exit : 0x%x\n",DRIVER_NAME, status ));


    }
    
    return status;

}

NTSTATUS
GetStringDescriptor(
    PDEVICE_OBJECT DeviceObject,
    UCHAR          StringIndex,
    PUCHAR         StringBuffer,
    PUSHORT        StringLength
    )
/*++

Routine Description:
    Retrieves an ASCII string descriptor from the USB Reader

Arguments:
    DeviceObject    - The device object
    StringIndex     - The index of the string to be retrieved
    StringBuffer    - Caller allocated buffer to hold the string
    StringLength    - Length of the string

Return Value:
    NT status value

--*/
{

    NTSTATUS            status = STATUS_SUCCESS;
    USB_STRING_DESCRIPTOR 
                        USD, 
                        *pFullUSD = NULL;
    PURB                pUrb;
    USHORT              langID = 0x0409;  // US English
    PDEVICE_EXTENSION   pDevExt;
    UNICODE_STRING      uString;
    ANSI_STRING         aString;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!GetStringDescriptor Enter\n",DRIVER_NAME ));
        
        pDevExt = DeviceObject->DeviceExtension;
        
        pUrb = ExAllocatePool(NonPagedPool,
                              sizeof( struct _URB_CONTROL_DESCRIPTOR_REQUEST ));

        if( pUrb == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }

        UsbBuildGetDescriptorRequest(pUrb, // points to the URB to be filled in
                                     sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     StringIndex, // index of string descriptor
                                     langID, // language ID of string.
                                     &USD, // points to a USB_STRING_DESCRIPTOR.
                                     NULL,
                                     sizeof(USB_STRING_DESCRIPTOR),
                                     NULL);

        status = USBCallSync(pDevExt->LowerDeviceObject,
                             pUrb,
                             0,
                             &pDevExt->RemoveLock);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

        pFullUSD = ExAllocatePool(NonPagedPool, USD.bLength);

        UsbBuildGetDescriptorRequest(pUrb, // points to the URB to be filled in
                                     sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     StringIndex, // index of string descriptor
                                     langID, // language ID of string
                                     pFullUSD,
                                     NULL,
                                     USD.bLength,
                                     NULL);

        status = USBCallSync(pDevExt->LowerDeviceObject,
                             pUrb,
                             0,
                             &pDevExt->RemoveLock);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

        uString.MaximumLength = uString.Length = pFullUSD->bLength-2;
        uString.Buffer = pFullUSD->bString;
        
        status = RtlUnicodeStringToAnsiString(&aString,
                                              &uString,
                                              TRUE);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

        if (aString.Length > MAXIMUM_ATTR_STRING_LENGTH) {
            aString.Length = MAXIMUM_ATTR_STRING_LENGTH;
            aString.Buffer[aString.Length - 1] = 0;
        }

        RtlCopyMemory(StringBuffer, aString.Buffer, aString.Length);

        *StringLength = aString.Length;

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!GetStringDescriptor Exit : 0x%x\n",DRIVER_NAME, status ));

        if (aString.Buffer) {
            
            RtlFreeAnsiString(&aString);

        }

        if (pUrb) {

            ExFreePool(pUrb);
            pUrb = NULL;

        }

        if (pFullUSD) {

            ExFreePool(pFullUSD);
            pFullUSD = NULL;

        }

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbsc\usbsc.h ===
#if !defined( __USBSC_H__ )
#define __USBSC_H__

#define DRIVER_NAME "USBSC"

#include <NTDDK.H>
#include "smclib.h"
#include <windef.h>
#include <usb.h>
#include "usbutil.h"
#include "scutil.h"


#define ESCAPE_COMMAND_ENABLE L"EscapeCommandEnable"

#define SMARTCARD_POOL_TAG 'DICC'
#define CCID_CLASS_DESCRIPTOR_TYPE  0x21

#define PC_to_RDR_IccPowerOn        0x62
#define PC_to_RDR_IccPowerOff       0x63
#define PC_to_RDR_GetSlotStatus     0x65
#define PC_to_RDR_XfrBlock          0x6F
#define PC_to_RDR_GetParameters     0x6C
#define PC_to_RDR_ResetParameters   0x6D
#define PC_to_RDR_SetParameters     0x61
#define PC_to_RDR_Escape            0x6B
#define PC_to_RDR_IccClock          0x6E
#define PC_to_RDR_T0APDU            0x6A
#define PC_to_RDR_Secure            0x69
#define PC_to_RDR_Mechanical        0x71
#define PC_to_RDR_Abort             0x72
#define PC_to_RDR_SetDataRateAndClockFrequency 0x73

#define RDR_to_PC_DataBlock         0x80
#define RDR_to_PC_SlotStatus        0x81
#define RDR_to_PC_Parameters        0x82
#define RDR_to_PC_Escape            0x83
#define RDR_to_PC_DataRateAndClockFrequency 0x84
                                    
#define RDR_to_PC_NotifySlotChange  0x50
#define RDR_to_PC_HardwareError     0x51

#define ABORT                       0x01
#define GET_CLOCK_FREQUENCIES       0x02
#define GET_DATA_RATES              0x03

#define CMD_ABORTED                 0xFF
#define ICC_MUTE                    0xFE
#define XFR_PARITY_ERROR            0xFD
#define XFR_OVERRUN                 0xFC
#define HW_ERROR                    0xFB

#define BAD_ATR_TS                  0xF8
#define BAD_ATR_TCK                 0xF7
#define ICC_PROTOCOL_NOT_SUPPORTED  0xF6
#define ICC_CLASS_NOT_SUPPORTED     0xF5
#define PROCEDURE_BYTE_CONFLICT     0xF4
#define DEACTIVATED_PROTOCOL        0xF3
#define BUSY_WITH_AUTO_SEQUENCE     0xF2

#define PIN_TIMEOUT                 0xF0
#define PIN_CANCELLED               0xEF

#define CMD_SLOT_BUSY               0xE0

#define COMMAND_STATUS_MASK         0xC0
#define COMMAND_STATUS_FAILED       0x40
#define COMMAND_STATUS_TIME_EXT     0x80
#define COMMAND_STATUS_SUCCESS      0x00
#define ICC_STATUS_MASK             0x03

#define CHARACTER_LEVEL             0x00
#define TPDU_LEVEL                  0x01
#define SHORT_APDU_LEVEL            0x02
#define EXTENDED_APDU_LEVEL         0x04

#define ATR_SIZE                    64

#define AUTO_PARAMETER_CONFIG       0x02
#define AUTO_ICC_ACTIVATION         0x04
#define AUTO_VOLTAGE_SELECTION      0x08
#define AUTO_CLOCK_FREQ             0x10
#define AUTO_BAUD_RATE              0x20
#define AUTO_PARAMETER_NEGOTIATION  0x40
#define AUTO_PPS                    0x80
#define AUTO_CLOCK_STOP             0x100
#define NOZERO_NAD_ACCEPT           0x200
#define AUTO_IFSD_EXCHANGE          0x400
#define TPDU_EXCHANGE_LEVEL         0x10000
#define SHORT_APDU_EXCHANGE         0x20000
#define EXT_APDU_EXCHANGE           0x40000

#define SLOT0_MASK                  0x3
#define SLOT1_MASK                  0xc
#define SLOT2_MASK                  0x30
#define SLOT3_MASK                  0xc0

#define IOCTL_CCID_ESCAPE           SCARD_CTL_CODE(3500)


#include <pshpack1.h>
typedef struct _CCID_CLASS_DESCRIPTOR
{
    BYTE    bLength;
    BYTE    bDescriptorType;
    WORD    bcdCCID;
    BYTE    bMaxSlotIndex;
    BYTE    bVoltageSupport;
    DWORD   dwProtocols;
    DWORD   dwDefaultClock;
    DWORD   dwMaximumClock;
    BYTE    bNumClockSupported;
    DWORD   dwDataRate;
    DWORD   dwMaxDataRate;
    BYTE    bNumDataRatesSupported;
    DWORD   dwMaxIFSD;
    DWORD   dwSynchProtocols;
    DWORD   dwMechanical;
    DWORD   dwFeatures;
    DWORD   dwMaxCCIDMessageLength;
    BYTE    bClassGetResponse;
    BYTE    bClassEnvelope;
    WORD    wLcdLayout;
    BYTE    bPINSupport;
    BYTE    bMaxCCIDBusySlots;

} CCID_CLASS_DESCRIPTOR, *PCCID_CLASS_DESCRIPTOR;

#include <poppack.h>

typedef struct _DEVICE_EXTENSION
{
   SCUTIL_HANDLE           ScUtilHandle;           // Utility library handle
   USB_WRAPPER_HANDLE      WrapperHandle;          //  Points to the storage used by the Usb Wrapper
   SMARTCARD_EXTENSION     SmartcardExtension;
   PDEVICE_OBJECT          LowerDeviceObject;
   PDEVICE_OBJECT          PhysicalDeviceObject;
   IO_REMOVE_LOCK          RemoveLock;
   ULONG                   DeviceInstance;
   DEVICE_POWER_STATE      PowerState;             //  Used to keep track of the current power state the reader is in
   USBD_INTERFACE_INFORMATION* Interface;
   PUSB_DEVICE_DESCRIPTOR  DeviceDescriptor;
   DEVICE_CAPABILITIES     DeviceCapabilities;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _READER_EXTENSION {

    
    BOOLEAN             CardPresent;

    USBD_PIPE_HANDLE    BulkOutHandle;
    UINT                BulkOutIndex;

    USBD_PIPE_HANDLE    BulkInHandle;
    UINT                BulkInIndex;

    USBD_PIPE_HANDLE    InterruptHandle;
    UINT                InterruptIndex;

    // Current reader power state.
//    READER_POWER_STATE  ReaderPowerState;

   // read timeout in ms
    ULONG               ReadTimeout;

    PDEVICE_OBJECT      DeviceObject;
    DWORD               SequenceNumber;

    PDEVICE_EXTENSION   DeviceExtension;

    DWORD               MaxMessageLength;

    WORD                ExchangeLevel;

    CCID_CLASS_DESCRIPTOR
                        ClassDescriptor;

    BYTE                CurrentVoltage;

    BOOLEAN             EscapeCommandEnabled;

} READER_EXTENSION, *PREADER_EXTENSION;

#include <pshpack1.h>

        
typedef struct _USBSC_OUT_MESSAGE_HEADER
{

    BYTE    bMessageType;
    DWORD   dwLength;
    BYTE    bSlot;
    BYTE    bSeq;
    
    union {

        BYTE    bPowerSelect;

        struct {
            BYTE bBWI;
            WORD wLevelParameter;
        };

        BYTE bProtocolNum;

        BYTE bClockCommand;

        struct {
            BYTE bmChanges;
            BYTE bClassGetResponse;
            BYTE bClassEnvelope;
        };

        BYTE bFunction;

    };

} USBSC_OUT_MESSAGE_HEADER, *PUSBSC_OUT_MESSAGE_HEADER;

typedef struct _USBSC_IN_MESSAGE_HEADER
{

    BYTE    bMessageType;
    DWORD   dwLength;
    BYTE    bSlot;
    BYTE    bSeq;
    BYTE    bStatus;
    BYTE    bError;

    union {
        BYTE bChainParameter;
        BYTE bClockStatus;
        BYTE bProtocolNum;
    };
           
} USBSC_IN_MESSAGE_HEADER, *PUSBSC_IN_MESSAGE_HEADER;

typedef struct _USBSC_SLOT_CHANGE_HEADER
{

    BYTE    bMessageType;
    BYTE    bmSlotICCState;

} USBSC_SLOT_CHANGE_HEADER, *PUSBSC_SLOT_CHANGE_HEADER;

typedef struct _USBSC_HWERROR_HEADER
{

    BYTE    bMessageType;
    BYTE    bSlot;
    BYTE    bSeq;
    BYTE    bHardwareErrorCode;

} USBSC_HWERROR_HEADER, *PUSBSC_HWERROR_HEADER;


typedef struct _PROTOCOL_DATA_T0
{

    BYTE    bmFindexDindex;
    BYTE    bmTCCKST0;
    BYTE    bGuardTimeT0;
    BYTE    bWaitingIntegerT0;
    BYTE    bClockStop;

} PROTOCOL_DATA_T0, *PPROTOCOL_DATA_T0;

typedef struct _PROTOCOL_DATA_T1
{
    BYTE    bmFindexDindex;
    BYTE    bmTCCKST1;
    BYTE    bGuardTimeT1;
    BYTE    bmWaitingIntegersT1;
    BYTE    bClockStop;
    BYTE    bIFSC;
    BYTE    bNadValue;

} PROTOCOL_DATA_T1, *PPROTOCOL_DATA_T1;

typedef struct _CLOCK_AND_DATA_RATE
{
    DWORD   dwClockFrequency;
    DWORD   dwDataRate;

} CLOCK_AND_DATA_RATE, *PCLOCK_AND_DATA_RATE;

typedef struct _PIN_VERIFICATION_DATA
{
    BYTE    bTimeOut;
    BYTE    bmFormatString;
    BYTE    bmPINBlockString;
    BYTE    bmPINLengthFormat;
    WORD    wPINMaxExtraDigit;
    BYTE    bEntryValidationCondition;
    BYTE    bNumberMessage;
    WORD    wLangId;
    BYTE    bMsgIndex;
    BYTE    bTeoPrologue;
    WORD    wRFU;    
} PIN_VERIFICATION_DATA, *PPIN_VERIFICATION_DATA;

typedef struct _PIN_MODIFICATION_DATA
{
    BYTE    bTimeOut;
    BYTE    bmFormatString;
    BYTE    bmPINBlockString;
    BYTE    bmPinLengthFormat;
    BYTE    bInsertionOffsetOld;
    BYTE    bInsertionOffsetNew;
    WORD    wPINMaxExtraDigit;
    BYTE    bConfirmPIN;
    BYTE    bEntryValidationCondition;
    BYTE    bNumberMessage;
    WORD    wLangId;
    BYTE    bMsgIndex1;
    BYTE    bMsgIndex2;
    BYTE    bMsgIndex3;
    BYTE    bTeoPrologue;
    WORD    wRFU;
    
} PIN_MODIFICATION_DATA, *PPIN_MODIFICATION_DATA;

typedef struct _PPS_REQUEST
{   
    BYTE    bPPSS;
    BYTE    bPPS0;
    BYTE    bPPS1;
    BYTE    bPCK;
} PPS_REQUEST, *PPPS_REQUEST;
#include <poppack.h>



NTSTATUS
DriverEntry(
    PDRIVER_OBJECT  DriverObject,
    PUNICODE_STRING RegistryPath
    );

#endif  // !__USBSC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbsc\usbsccb.c ===
#include "usbsc.h"
#include "usbsccb.h"
#include "usbcom.h"
#include "usbutil.h"
#include "usbscnt.h"

#pragma warning( disable : 4242 4244)

CHAR* InMessages[] = {
    "RDR_to_PC_DataBlock",
    "RDR_to_PC_SlotStatus",
    "RDR_to_PC_Parameters",
    "RDR_to_PC_Escape",
    "RDR_to_PC_DataRateAndClockFrequency",
    "INVALID MESSAGE"
};

CHAR* OutMessages[] = {
    "INVALID MESSAGE",              // 0x60
    "PC_to_RDR_SetParameters",      // 0x61
    "PC_to_RDR_IccPowerOn",         // 0x62
    "PC_to_RDR_IccPowerOff",        // 0x63
    "INVALID MESSAGE",              // 0x64
    "PC_to_RDR_GetSlotStatus",      // 0x65
    "INVALID MESSAGE",              // 0x66
    "INVALID MESSAGE",              // 0x67
    "INVALID MESSAGE",              // 0x68
    "INVALID MESSAGE",              // 0x69
    "PC_to_RDR_Secure",             // 0x6a
    "PC_to_RDR_Escape",             // 0x6b
    "PC_to_RDR_GetParameters",      // 0x6c
    "PC_to_RDR_ResetParameters",    // 0x6d
    "PC_to_RDR_IccClock",           // 0x6e
    "PC_to_RDR_XfrBlock",           // 0x6f
    "INVALID MESSAGE",              // 0x70
    "PC_to_RDR_Mechanical",         // 0x71
    "PC_to_RDR_Abort",              // 0x72
    "PC_to_RDR_SetDataRateAndClockFrequency" // 0x73
};



CHAR* 
GetMessageName(
    BYTE MessageType
    )       
{
    CHAR* name;
    if (MessageType & 0x80) {
        // IN message
        MessageType -= 0x80;
        if (MessageType > 5) {
            MessageType = 5;
        }
        name = InMessages[MessageType];

    } else {
        MessageType -= 0x60;
        if (MessageType >= 20) {
            MessageType = 0;
        }
        name = OutMessages[MessageType];
    }

    return name;

}
NTSTATUS 
UsbScTransmit(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    RDF_TRANSMIT Callback function
    Called from smclib

Arguments:
    SmartcardExtension

Return Value:
    NT Status value

--*/
{

    NTSTATUS status = STATUS_SUCCESS;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScTransmit Enter\n",DRIVER_NAME ));
        
        switch( SmartcardExtension->CardCapabilities.Protocol.Selected )  {
        
        case SCARD_PROTOCOL_T0:
            status = UsbScT0Transmit( SmartcardExtension );
            break;

        case SCARD_PROTOCOL_T1:
            status = UsbScT1Transmit( SmartcardExtension );
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        }
        
    }

    __finally
    {
        
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScTransmit Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}


NTSTATUS 
UsbScSetProtocol(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    RDF_SET_PROTOCOL callback
    called from smclib

Arguments:

Return Value:

--*/
{

    NTSTATUS                    status = STATUS_UNSUCCESSFUL;
    UINT                        protocolMask;
    UINT                        protocol;
    PUSBSC_OUT_MESSAGE_HEADER   message = NULL;
    PROTOCOL_DATA_T0            *dataT0;
    PROTOCOL_DATA_T1            *dataT1;
    PSCARD_CARD_CAPABILITIES    cardCaps = NULL;
    PCLOCK_AND_DATA_RATE        cadData = NULL;
    PUCHAR                      response = NULL;
    PPPS_REQUEST                pPPS = NULL;
    PPS_REQUEST                 pps;
    UINT                        bytesToRead;
    KIRQL                       irql;



    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSetProtocol Enter\n",DRIVER_NAME ));
        
        protocolMask    = SmartcardExtension->MinorIoControlCode;
        cardCaps        = &SmartcardExtension->CardCapabilities;

        SmartcardDebug( DEBUG_PROTOCOL, ("%s : Setting Protocol\n",DRIVER_NAME ));

        //
        // If the reader supports automatic parameter configuration, then just 
        // check for the selected protocol
        //
        if (SmartcardExtension->ReaderExtension->ClassDescriptor.dwFeatures & AUTO_PARAMETER_NEGOTIATION) {
            
            message = ExAllocatePool(NonPagedPool,
                                     sizeof(USBSC_OUT_MESSAGE_HEADER));

            if (!message) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            RtlZeroMemory(message,
                          sizeof( USBSC_OUT_MESSAGE_HEADER )); 
                          

            
            response = ExAllocatePool(NonPagedPool,
                                      sizeof(USBSC_IN_MESSAGE_HEADER)
                                      + sizeof(PROTOCOL_DATA_T1));

            if (!response) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            message->bMessageType = PC_to_RDR_GetParameters;
            message->dwLength = 0;
            message->bSlot = 0;

            
            SmartcardDebug( DEBUG_PROTOCOL, ("%s : Reader supports auto parameter negotiation\n",DRIVER_NAME ));
            
            status = UsbScReadWrite(SmartcardExtension,
                                    message,
                                    response,
                                    sizeof(PROTOCOL_DATA_T1),
                                    NULL,
                                    FALSE);

            if (!NT_SUCCESS(status)) {

                __leave;

            }

            if ((((PUSBSC_IN_MESSAGE_HEADER) response)->bProtocolNum+1) & protocolMask) {
            
                *SmartcardExtension->IoRequest.ReplyBuffer = ((PUSBSC_IN_MESSAGE_HEADER) response)->bProtocolNum + 1;
                *SmartcardExtension->IoRequest.Information = sizeof(ULONG);

                KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                                  &irql);
                SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
                SmartcardExtension->CardCapabilities.Protocol.Selected = *SmartcardExtension->IoRequest.ReplyBuffer;
                KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                  irql);

            } else {
                SmartcardDebug( DEBUG_PROTOCOL, ("%s : Reader has not selected desired protocol\n",DRIVER_NAME ));

                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            
            __leave;

        }

        // 
        // Check if the card has already selected the right protocol
        //
        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);
        if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC &&
            (SmartcardExtension->CardCapabilities.Protocol.Selected & 
             SmartcardExtension->MinorIoControlCode)) {

            protocolMask = SmartcardExtension->CardCapabilities.Protocol.Selected;

            status = STATUS_SUCCESS;    

        }
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);

        //
        // Check if PPS request needs to be sent
        //
        if (!(NT_SUCCESS(status)) && !(SmartcardExtension->ReaderExtension->ClassDescriptor.dwFeatures & (AUTO_PARAMETER_NEGOTIATION | AUTO_PPS))) {
            PUCHAR replyPos;

            //
            // Must send PPS request
            //


            message = ExAllocatePool(NonPagedPool,
                                     sizeof(USBSC_OUT_MESSAGE_HEADER)
                                     + sizeof(PPS_REQUEST));

            if (!message) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            RtlZeroMemory(message,
                          sizeof( USBSC_OUT_MESSAGE_HEADER ) 
                          + sizeof(PPS_REQUEST));

            
            response = ExAllocatePool(NonPagedPool,
                                      sizeof(USBSC_IN_MESSAGE_HEADER)
                                      + sizeof(PPS_REQUEST));

            if (!response) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            while (TRUE) {
            
                pPPS = (PPPS_REQUEST) ((PUCHAR) message + sizeof(USBSC_OUT_MESSAGE_HEADER));

                pPPS->bPPSS = 0xff;
            
                if (protocolMask & SCARD_PROTOCOL_T1) {
                    
                    pPPS->bPPS0 = 0x11;
                    
                } else if (protocolMask & SCARD_PROTOCOL_T0) {

                    pPPS->bPPS0 = 0x10;

                    
                } else {
                    
                    SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSetProtocol Invalid protocol\n",DRIVER_NAME ));
                    
                    status = STATUS_INVALID_DEVICE_REQUEST;
                    __leave;
                   
                }

                pPPS->bPPS1 = (cardCaps->PtsData.Fl << 4) 
                               | cardCaps->PtsData.Dl;

                pPPS->bPCK = (pPPS->bPPSS ^ pPPS->bPPS0 ^ pPPS->bPPS1);
            
                SmartcardDebug( DEBUG_PROTOCOL, 
                                ("%s : Sending PPS request (0x%x 0x%x 0x%x 0x%x)\n",
                                 DRIVER_NAME,
                                 pPPS->bPPSS,
                                 pPPS->bPPS0,
                                 pPPS->bPPS1,
                                 pPPS->bPCK ));
                
                message->bMessageType = PC_to_RDR_XfrBlock;
                message->bSlot = 0;
                message->dwLength = sizeof(PPS_REQUEST);


                switch (SmartcardExtension->ReaderExtension->ExchangeLevel) {
                case TPDU_LEVEL:

                    message->wLevelParameter = 0;
                    bytesToRead = sizeof(PPS_REQUEST);
            
                    status = UsbScReadWrite(SmartcardExtension,
                                            message,
                                            response,
                                            bytesToRead,
                                            &pps,
                                            FALSE);
                                        
                    break;

                case CHARACTER_LEVEL:

                 
                    replyPos = (PUCHAR) &pps; 

                
                    bytesToRead = 4;
                    message->wLevelParameter = 2;
                    
                    while (bytesToRead) {

                        status = UsbScReadWrite(SmartcardExtension,
                                                message,
                                                response,
                                                message->wLevelParameter,
                                                replyPos,
                                                FALSE);
                     
                        bytesToRead -= 2;
                        replyPos += 2;
                        message->dwLength = 0;
                        
                    }


                    break;

                }

                if (!NT_SUCCESS(status) || (memcmp(&pps, pPPS, sizeof(PPS_REQUEST)) != 0)) {

                    // The card failed with the current settings
                    // If PtsData.Type is not PTS_TYPE_DEFAULT, then try that.

                    

                    if (cardCaps->PtsData.Type == PTS_TYPE_DEFAULT) {

                        SmartcardDebug( DEBUG_PROTOCOL, ("%s : The card failed PPS request\n",DRIVER_NAME ));

                        ASSERT(FALSE);
                        status = STATUS_DEVICE_PROTOCOL_ERROR;
                        __leave;
                
                    }

                    SmartcardDebug( DEBUG_PROTOCOL, ("%s : The card failed PPS request, trying default PPS\n",DRIVER_NAME ));
                    cardCaps->PtsData.Type = PTS_TYPE_DEFAULT;
                    SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;

                    status = UsbScCardPower(SmartcardExtension);

                } else {

                    break;

                }


            }
                

            if (message != NULL) {

                ExFreePool(message);
                message = NULL;

            }

            if (response != NULL) {

                ExFreePool(response);
                response = NULL;
            }

        }

        //
        // Send set protocol request to the reader
        //
        if (protocolMask & SCARD_PROTOCOL_T1) {  // T=1

            SmartcardDebug( DEBUG_PROTOCOL, ("%s : Setting protocol T=1\n",DRIVER_NAME ));


            protocol = 1;

            message = ExAllocatePool(NonPagedPool,
                                     sizeof( USBSC_OUT_MESSAGE_HEADER ) 
                                     + sizeof(PROTOCOL_DATA_T1));

            if (!message) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            RtlZeroMemory(message,
                          sizeof( USBSC_OUT_MESSAGE_HEADER ) 
                          + sizeof(PROTOCOL_DATA_T1));


            dataT1 = (PPROTOCOL_DATA_T1) ((PUCHAR) message + sizeof(USBSC_OUT_MESSAGE_HEADER));


            // 
            //  7            4 3            0
            //  ----------------------------
            // |     FI      |   DI        |
            // ----------------------------
            //
            dataT1->bmFindexDindex = (cardCaps->PtsData.Fl << 4) 
                                     | cardCaps->PtsData.Dl;


            //
            // B7-2 = 000100b
            // B0 = Checksum type (0=LRC, 1=CRC)
            // B1 = Convention used (0=direct, 1=inverse)
            // 
            dataT1->bmTCCKST1 = 0x10 | (cardCaps->T1.EDC & 0x01);

            if (cardCaps->InversConvention) {

                dataT1->bmTCCKST1 |= 2;

            }

            dataT1->bGuardTimeT1 = cardCaps->N;

            // 
            //  7            4 3            0
            //  ----------------------------
            // |     BWI     |   CWI       |
            // ----------------------------
            //            
            dataT1->bmWaitingIntegersT1 = (cardCaps->T1.BWI << 4) 
                                            | (cardCaps->T1.CWI & 0xf);

            dataT1->bClockStop = 0;
            dataT1->bIFSC = cardCaps->T1.IFSC;
            dataT1->bNadValue = 0;
            message->dwLength = sizeof(PROTOCOL_DATA_T1);

        } else if (protocolMask & SCARD_PROTOCOL_T0) {

            SmartcardDebug( DEBUG_PROTOCOL, ("%s :  Setting protocol T=0\n",DRIVER_NAME ));


            protocol = 0;
            message = ExAllocatePool(NonPagedPool,
                                     sizeof( USBSC_OUT_MESSAGE_HEADER ) 
                                     + sizeof(PROTOCOL_DATA_T0));

            if (!message) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }
            RtlZeroMemory(message,
                          sizeof( USBSC_OUT_MESSAGE_HEADER ) 
                          + sizeof(PROTOCOL_DATA_T0));
            
            dataT0 = (PROTOCOL_DATA_T0 *) (((UCHAR *) message) + sizeof(USBSC_OUT_MESSAGE_HEADER));

            // 
            //  7            4 3            0
            //  ----------------------------
            // |     FI      |   DI        |
            // ----------------------------
            //
            dataT0->bmFindexDindex = (cardCaps->PtsData.Fl << 4)
                                    | cardCaps->PtsData.Dl;

            //
            // B7-2 = 000000b
            // B0 = 0
            // B1 = Convention used (0=direct, 1=inverse)
            // 
            dataT0->bmTCCKST0 = 0;
            if (cardCaps->InversConvention) {

                dataT0->bmTCCKST0 |= 2;

            }

            dataT0->bGuardTimeT0 = cardCaps->N;
            dataT0->bWaitingIntegerT0 = cardCaps->T0.WI;
            dataT0->bClockStop = 0;
            message->dwLength = sizeof(PROTOCOL_DATA_T0);

        } else {

            SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSetProtocol Invalid protocol\n",DRIVER_NAME ));

            status = STATUS_INVALID_DEVICE_REQUEST;
            __leave;

        }

        message->bMessageType = PC_to_RDR_SetParameters;
        message->bSlot = 0;
        message->bProtocolNum = protocol;

        status = UsbScReadWrite(SmartcardExtension,
                                message,
                                (PVOID) message,
                                message->dwLength,
                                NULL,
                                FALSE);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

        //
        // See if reader supports auto clock/baud rate configuration
        //
        if ((SmartcardExtension->ReaderExtension->ClassDescriptor.dwFeatures & (AUTO_BAUD_RATE | AUTO_CLOCK_FREQ)) != (AUTO_BAUD_RATE | AUTO_CLOCK_FREQ)) {
        
            // Set ClockFrequency and DataRate

            RtlZeroMemory(message,
                          sizeof(USBSC_OUT_MESSAGE_HEADER)
                          + sizeof(CLOCK_AND_DATA_RATE));
            message->bMessageType = PC_to_RDR_SetDataRateAndClockFrequency;
            message->dwLength = 8;
            message->bSlot = 0;

            cadData = (PCLOCK_AND_DATA_RATE) ((PUCHAR)message+sizeof(USBSC_OUT_MESSAGE_HEADER));
            cadData->dwClockFrequency = SmartcardExtension->CardCapabilities.PtsData.CLKFrequency;
            cadData->dwDataRate = SmartcardExtension->CardCapabilities.PtsData.DataRate;

            status = UsbScReadWrite(SmartcardExtension,
                                    message,
                                    (PVOID) message,
                                    sizeof(CLOCK_AND_DATA_RATE),
                                    NULL,
                                    FALSE);

            if (!NT_SUCCESS(status)) {

                __leave;

            }

        }

        *SmartcardExtension->IoRequest.ReplyBuffer = protocol + 1;
        *SmartcardExtension->IoRequest.Information = sizeof(ULONG);

        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
        SmartcardExtension->CardCapabilities.Protocol.Selected = protocol + 1;
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
         
    }

    __finally
    {

        if (message != NULL) {

            ExFreePool(message);
            message = NULL;

        }

        if (response != NULL) {

            ExFreePool(response);
            response = NULL;
        }

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSetProtocol Exit : 0x%x\n",DRIVER_NAME, status ));

    
    }

    return status;

}


NTSTATUS 
UsbScCardPower(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    RDF_CARD_POWER callback
    called from smclib


Arguments:

Return Value:

--*/
{

    NTSTATUS            status = STATUS_SUCCESS;
    PREADER_EXTENSION   readerExtension;
    UCHAR               atr[sizeof(USBSC_IN_MESSAGE_HEADER) + ATR_SIZE];
    USBSC_OUT_MESSAGE_HEADER    powerMessage;
    PUSBSC_IN_MESSAGE_HEADER    replyHeader;
    BYTE                voltage;
    LARGE_INTEGER       waitTime;
    KIRQL               irql;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardPower Enter\n",DRIVER_NAME ));

        replyHeader     = (PUSBSC_IN_MESSAGE_HEADER) atr;
        readerExtension = SmartcardExtension->ReaderExtension;
        *SmartcardExtension->IoRequest.Information = 0;

        switch (SmartcardExtension->MinorIoControlCode) {
        case SCARD_WARM_RESET:

            RtlZeroMemory(&powerMessage, sizeof(USBSC_OUT_MESSAGE_HEADER));

            powerMessage.bMessageType   = PC_to_RDR_IccPowerOn;
            powerMessage.bPowerSelect   = readerExtension->CurrentVoltage;
            powerMessage.dwLength       = 0;
            powerMessage.bSlot          = 0;

            SmartcardDebug( DEBUG_PROTOCOL, ("%s : SCARD_WARM_RESET (bPowerSelect = 0x%x)\n",DRIVER_NAME, readerExtension->CurrentVoltage ));

            status = UsbScReadWrite(SmartcardExtension,
                                    &powerMessage,
                                    atr,
                                    ATR_SIZE,
                                    SmartcardExtension->IoRequest.ReplyBuffer,
                                    FALSE);

            if (!NT_SUCCESS(status)) {

                SmartcardDebug( DEBUG_ERROR, ("%s : PC_to_RDR_IccPowerOn failed with status = 0x%x\n",DRIVER_NAME, status ));
                __leave;

            }

            if (replyHeader->dwLength > ATR_SIZE) {
                SmartcardDebug( DEBUG_ERROR, ("%s :Invalid ATR size returned\n",DRIVER_NAME, status ));
                status = STATUS_DEVICE_PROTOCOL_ERROR;
                __leave;

            }
            *SmartcardExtension->IoRequest.Information = replyHeader->dwLength;

            RtlCopyMemory(SmartcardExtension->CardCapabilities.ATR.Buffer, 
                          SmartcardExtension->IoRequest.ReplyBuffer,
                          *SmartcardExtension->IoRequest.Information);

            SmartcardExtension->CardCapabilities.ATR.Length = *SmartcardExtension->IoRequest.Information;
            status = SmartcardUpdateCardCapabilities(SmartcardExtension);

            break;
                
        case SCARD_COLD_RESET:

            SmartcardDebug( DEBUG_PROTOCOL, ("%s : SCARD_COLD_RESET\n",DRIVER_NAME ));

            RtlZeroMemory(&powerMessage, sizeof(USBSC_OUT_MESSAGE_HEADER));
            powerMessage.dwLength       = 0;
            powerMessage.bSlot          = 0;



            // Need to first power off card before selecting another 
            // voltage.
            powerMessage.bMessageType =  PC_to_RDR_IccPowerOff;

            status = UsbScReadWrite(SmartcardExtension,
                                    &powerMessage,
                                    atr,
                                    0,
                                    NULL,
                                    FALSE);

            if (!NT_SUCCESS(status)) {

                SmartcardDebug( DEBUG_ERROR, ("%s : PC_to_RDR_IccPowerOff failed with status = 0x%x\n",DRIVER_NAME, status ));


                __leave;

            }

            // We need to iterate through the possible voltages, moving from low voltage to high
            // until we find one that works
            for (voltage = 3; voltage > 0 && voltage <= 3; voltage--) {

                if (readerExtension->ClassDescriptor.dwFeatures & AUTO_VOLTAGE_SELECTION) {

                    // reader supports auto voltage selection
                    voltage = 0;

                }
                
  
                // Wait 10ms per spec
                waitTime.HighPart = -1;
                waitTime.LowPart = -100;    // 10ms

                KeDelayExecutionThread(KernelMode,
                                       FALSE,
                                       &waitTime);

                // Now we can power back on
                RtlZeroMemory(&powerMessage, sizeof(USBSC_OUT_MESSAGE_HEADER));

                powerMessage.bMessageType = PC_to_RDR_IccPowerOn;
                powerMessage.bPowerSelect = voltage;
                powerMessage.dwLength = 0;

                SmartcardDebug( DEBUG_PROTOCOL, ("%s : Selecting voltage = 0x%x\n",DRIVER_NAME, voltage ));


                status = UsbScReadWrite(SmartcardExtension,
                                        &powerMessage,
                                        atr,
                                        ATR_SIZE,
                                        SmartcardExtension->IoRequest.ReplyBuffer,
                                        FALSE);

                if (NT_SUCCESS(status)) {

                    // everything worked. We found the correct voltage
                    SmartcardDebug( DEBUG_PROTOCOL, ("%s : Voltage set to 0x%x\n",DRIVER_NAME, voltage ));
                    *SmartcardExtension->IoRequest.Information = replyHeader->dwLength;
                    readerExtension->CurrentVoltage = voltage;
                    break;

                }
              
                //
                // If card or reader doesn't support selected voltage, it will
                // either timeout, return ICC_CLASS_NOT_SUPPORTED or
                // report that parameter 7 (bPowerselect) is not supported
                //
                if (((replyHeader->bStatus == 0x41) && (replyHeader->bError == ICC_MUTE))
                    || (replyHeader->bError == ICC_CLASS_NOT_SUPPORTED)
                    || (replyHeader->bError == 7)) {

                    SmartcardDebug( DEBUG_PROTOCOL, ("%s : Reader did not support voltage = 0x%x\n",DRIVER_NAME, voltage ));



                    // We are going to try another voltage
                        
                } else {
                    //
                    // We have a bigger problem that we can't handle
                    // Let's just ignore it for now and see if it is 
                    // due to insufficient voltage
                    //

                    SmartcardDebug( DEBUG_ERROR, ("%s!UsbScCardPower Unhandled error (probably due to insufficient voltage)\n",DRIVER_NAME ));
 
                }

            }

            // Save the ATR so smclib can parse it
            if (*SmartcardExtension->IoRequest.Information > ATR_SIZE) {
                SmartcardDebug( DEBUG_ERROR, ("%s : Invalid ATR size returned\n",DRIVER_NAME ));

                status = STATUS_DEVICE_PROTOCOL_ERROR;
                __leave;
            }
            RtlCopyMemory(SmartcardExtension->CardCapabilities.ATR.Buffer, 
                          SmartcardExtension->IoRequest.ReplyBuffer,
                          *SmartcardExtension->IoRequest.Information);

            SmartcardExtension->CardCapabilities.ATR.Length = *SmartcardExtension->IoRequest.Information;
            status = SmartcardUpdateCardCapabilities(SmartcardExtension);

            break;

        case SCARD_POWER_DOWN:

            SmartcardDebug( DEBUG_PROTOCOL, ("%s : SCARD_POWER_DOWN\n",DRIVER_NAME ));
            RtlZeroMemory(&powerMessage, sizeof(USBSC_OUT_MESSAGE_HEADER));

            powerMessage.bSlot = 0;
            powerMessage.bMessageType = PC_to_RDR_IccPowerOff;
            powerMessage.dwLength = 0;
            
            status = UsbScReadWrite(SmartcardExtension,
                                    &powerMessage,
                                    atr,
                                    0,
                                    NULL,
                                    FALSE);

            if (!NT_SUCCESS(status)) {
                SmartcardDebug( DEBUG_ERROR, ("%s : PC_to_RDR_IccPowerOff failed with status = 0x%x\n",DRIVER_NAME, status ));
                __leave;
            }

            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);
            if (SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_PRESENT) {

                SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_PRESENT;

            }

            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

            SmartcardExtension->CardCapabilities.ATR.Length = 0;
            
            break;
        }
    
    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardPower Exit : 0x%x\n",DRIVER_NAME, status ));
    
    }

    return status;

}


NTSTATUS 
UsbScCardTracking(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    RDF_CARD_TRACKING callback
    called from smclib


Arguments:

Return Value:

--*/
{       
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL ioIrql, keIrql;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardTracking Enter\n",DRIVER_NAME ));

   
        // set cancel routine
        IoAcquireCancelSpinLock( &ioIrql );

        IoSetCancelRoutine(
           SmartcardExtension->OsData->NotificationIrp,
           ScUtil_Cancel);

        IoReleaseCancelSpinLock( ioIrql );

        status = STATUS_PENDING;
    
    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardTracking Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}


NTSTATUS 
UsbScCardSwallow(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    RDF_READER_SWALLOW callback
    called from smclib


Arguments:

Return Value:

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    __try
    {

        USBSC_OUT_MESSAGE_HEADER header;
        USBSC_IN_MESSAGE_HEADER reply;

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardSwallow Enter\n",DRIVER_NAME ));

        header.bMessageType = PC_to_RDR_Mechanical;
        header.dwLength = 0;
        header.bSlot = 0;
        header.bFunction = 4; // lock

        status = UsbScReadWrite(SmartcardExtension,
                                &header,
                                (PUCHAR) &reply,
                                0,
                                NULL,
                                FALSE);

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardSwallow Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}


NTSTATUS 
UsbScCardEject(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    RDF_CARD_EJECT callback
    called from smclib

Arguments:

Return Value:

--*/
{
    
    NTSTATUS status = STATUS_SUCCESS;

    __try
    {

        USBSC_OUT_MESSAGE_HEADER header;
        USBSC_IN_MESSAGE_HEADER reply;
        
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardEject Enter\n",DRIVER_NAME ));

        header.bMessageType = PC_to_RDR_Mechanical;
        header.dwLength = 0;
        header.bSlot = 0;
        header.bFunction = 5; // unlock

        status = UsbScReadWrite(SmartcardExtension,
                                &header,
                                (PUCHAR) &reply,
                                0,
                                NULL,
                                FALSE);

    
    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCardEject Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}


NTSTATUS 
UsbScT0Transmit(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    Handles transmitting data to/from reader using the T=0 protocol

Arguments:
    SmartcardExtension

Return Value:
    NT status value

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PREADER_EXTENSION   ReaderExtension = SmartcardExtension->ReaderExtension;
    ULONG               bytesToSend;
    ULONG               requestLength;
    ULONG               bytesToRead;
    PUCHAR              currentHeaderPos;
    PUCHAR              currentData;
    ULONG               maxDataLen = 0;
    USBSC_OUT_MESSAGE_HEADER header;
    PUSBSC_IN_MESSAGE_HEADER replyHeader;
    PUCHAR              responseBuffer = NULL;
    PUCHAR              replyPos;
    LONG                timeout = 0;
    UCHAR               ins;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit Enter\n",DRIVER_NAME ));


        // Tell the lib to allocate space for the header
        SmartcardExtension->SmartcardRequest.BufferLength = sizeof(USBSC_OUT_MESSAGE_HEADER);
        SmartcardExtension->SmartcardReply.BufferLength = 0;

        status = SmartcardT0Request(SmartcardExtension);

        if (!NT_SUCCESS(status)) {
            
            __leave;

        }

        bytesToSend = SmartcardExtension->SmartcardRequest.BufferLength - sizeof(USBSC_OUT_MESSAGE_HEADER);
        bytesToRead = SmartcardExtension->T0.Le + 2;            // Le + SW2 and SW2
        replyPos    = SmartcardExtension->SmartcardReply.Buffer;
                       
        // allocate buffer to hold message header and data.
        responseBuffer = ExAllocatePool(NonPagedPool,
                                        sizeof( USBSC_OUT_MESSAGE_HEADER ) + bytesToRead);

        if (!responseBuffer) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }

        replyHeader = (PUSBSC_IN_MESSAGE_HEADER) responseBuffer;
        currentHeaderPos = SmartcardExtension->SmartcardRequest.Buffer;

        // Set parameters that are common to all ExchangeLevels.
        header.bMessageType = PC_to_RDR_XfrBlock;
        header.bSlot = 0;
        header.bBWI = 0;

        switch (ReaderExtension->ExchangeLevel) {
       
        case SHORT_APDU_LEVEL: 
            SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit SHORT_APDU_LEVEL\n",DRIVER_NAME ));

            // Fall through since short APDU is an extended APDU with bytesToSend <= MaxMessageLength-10
        case EXTENDED_APDU_LEVEL:

            if (ReaderExtension->ExchangeLevel == EXTENDED_APDU_LEVEL) {
                
                SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit EXTENDED_APDU_LEVEL\n",DRIVER_NAME ));

            }


            if (bytesToSend <= (ReaderExtension->MaxMessageLength - sizeof(USBSC_OUT_MESSAGE_HEADER))) {
                // this is basically just like a short APDU
                header.wLevelParameter = 0;
                requestLength = bytesToSend;

            } else {

                SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit multi-packet message\n",DRIVER_NAME ));


                requestLength = ReaderExtension->MaxMessageLength - sizeof(USBSC_OUT_MESSAGE_HEADER);
                header.wLevelParameter = 1;

            }

            while (bytesToSend || ((replyHeader->bChainParameter & 0x01) == 0x01)) {

                header.dwLength = requestLength;
                *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        bytesToRead,
                                        replyPos,
                                        FALSE);
                if (!NT_SUCCESS(status)) {

                    __leave;

                }

                SmartcardDebug( DEBUG_PROTOCOL, ("%s!UsbScT0Transmit SW1=0x%x, SW2=0x%x\n",DRIVER_NAME, replyPos[replyHeader->dwLength-2], replyPos[replyHeader->dwLength-1] ));

                if (bytesToSend < requestLength) {
                    // this should NEVER happen
                    status = STATUS_DEVICE_PROTOCOL_ERROR;
                    __leave;
                }
                bytesToSend -= requestLength;
                currentHeaderPos += requestLength;

                if ((bytesToSend <= (ReaderExtension->MaxMessageLength - sizeof(USBSC_OUT_MESSAGE_HEADER))) && (bytesToSend > 0)) {
                    // Last part of APDU
                    
                    requestLength = bytesToSend;
                    header.wLevelParameter = 2;
                    
                } else if (bytesToSend > 0) {
                    // Still more APDU to come

                    header.wLevelParameter = 3;
                 
                } else {
                    // Expect more data

                    header.wLevelParameter = 0x10;
                }

                if (bytesToRead < replyHeader->dwLength) {
                    status = STATUS_DEVICE_PROTOCOL_ERROR;
                    __leave;
                }
                bytesToRead -= replyHeader->dwLength;
                replyPos += replyHeader->dwLength;     
                SmartcardExtension->SmartcardReply.BufferLength += replyHeader->dwLength;            

            }

            break;

        case TPDU_LEVEL:

            SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit TPDU_LEVEL\n",DRIVER_NAME ));


            header.wLevelParameter = 0;
            header.dwLength = bytesToSend;
            *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;
            

            status = UsbScReadWrite(SmartcardExtension,
                                    currentHeaderPos,
                                    responseBuffer,
                                    bytesToRead,
                                    replyPos,
                                    FALSE);


            if (!NT_SUCCESS(status)) {
                __leave;
            }


            bytesToSend = 0;
            bytesToRead -= replyHeader->dwLength;
            
            replyPos += replyHeader->dwLength;    
            SmartcardExtension->SmartcardReply.BufferLength += replyHeader->dwLength;

            break;

        case CHARACTER_LEVEL:

            SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit CHARACTER_LEVEL\n",DRIVER_NAME ));

            //
            // Send T0 command header
            //
            requestLength = 5;
            currentHeaderPos = SmartcardExtension->SmartcardRequest.Buffer;
            ins = currentHeaderPos[sizeof(USBSC_OUT_MESSAGE_HEADER)+1];
            header.dwLength = requestLength;


            while (bytesToSend || bytesToRead) {

                BOOL restartWorkingTime = TRUE;

                header.wLevelParameter = 1;
                *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        header.wLevelParameter,
                                        replyPos,
                                        FALSE);
                if (!NT_SUCCESS(status)) {

                    __leave;

                }


                bytesToSend -= header.dwLength;
                currentHeaderPos += header.dwLength;

                currentData = responseBuffer + sizeof( USBSC_IN_MESSAGE_HEADER );
                if ((*currentData) == 0x60) {

                    // this is a NULL byte.
                    header.wLevelParameter = 1;
                    header.dwLength = 0;
                    continue;
                    

                } else if (((*currentData & 0xF0) == 0x60) || ((*currentData & 0xF0) == 0x90)) {
                    // Got SW1

                    //
                    // data has already been coppied to request buffer
                    // just increment replyPos to prevent overwriting
                    //
                    replyPos++;
                    SmartcardExtension->SmartcardReply.BufferLength++;


                    //Get SW2
                    header.dwLength = 0;
                    header.wLevelParameter = 1;
                    *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;


                    UsbScReadWrite(SmartcardExtension,
                                   currentHeaderPos,
                                   responseBuffer,
                                   header.wLevelParameter,
                                   replyPos,
                                   FALSE);
                    if (!NT_SUCCESS(status)) {

                        __leave;

                    }

                    
                    bytesToRead = 0;
                    bytesToSend = 0;
                    replyPos++;
                    SmartcardExtension->SmartcardReply.BufferLength++;

                    continue;

                }

                if ((*currentData & 0xFE) == (ins & 0xFE)) {

                    //
                    //Transfer all bytes
                    //
                    header.dwLength = bytesToSend;
                    header.wLevelParameter = bytesToRead;
                    if (bytesToSend) {
                        continue;
                    }

                } else if ((*currentData & 0xFE) == ((~ins) & 0xFE)) {

                    //
                    // Transfer next byte
                    //
                    header.dwLength = bytesToSend ? 1 : 0;
                    header.wLevelParameter = bytesToRead ? 1 : 0;

                    if (bytesToSend) {
                        continue;
                    }

                } else {

                    status = STATUS_UNSUCCESSFUL;
                    __leave;

                }
                    
                *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        header.wLevelParameter,
                                        replyPos,
                                        FALSE);    
                if (!NT_SUCCESS(status)) {

                    __leave;
                    
                }

                if (bytesToRead < replyHeader->dwLength) {
                    status = STATUS_DEVICE_PROTOCOL_ERROR;
                    __leave;
                }

                bytesToSend -= header.dwLength;
                currentHeaderPos += header.dwLength;
                bytesToRead -= replyHeader->dwLength;
                replyPos += replyHeader->dwLength;      
                SmartcardExtension->SmartcardReply.BufferLength += replyHeader->dwLength;

                 
            }


            break;
        }

        status = SmartcardT0Reply(SmartcardExtension);
        
    

    }

    __finally
    {

        if (responseBuffer) {

            ExFreePool(responseBuffer);
            responseBuffer = NULL;

        }

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT0Transmit Exit : 0x%x\n",DRIVER_NAME, status ));
    
    }

    return status;

}


NTSTATUS 
UsbScT1Transmit(
   PSMARTCARD_EXTENSION  SmartcardExtension
   )
/*++

Routine Description:
    Handles transmitting data to/from reader using the T=1 protocol

Arguments:
    SmartcardExtension

Return Value:
    NT status value

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PREADER_EXTENSION   ReaderExtension = SmartcardExtension->ReaderExtension;
    USBSC_OUT_MESSAGE_HEADER header;
    PUSBSC_IN_MESSAGE_HEADER replyHeader;
    PUCHAR              currentHeaderPos;
    PUCHAR              responseBuffer = NULL;
    PUCHAR              requestBuffer = NULL;
    PUCHAR              replyPos;
    ULONG               bytesToSend;
    ULONG               requestLength;
    ULONG               bytesToRead;
    LONG                timeout = 0;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT1Transmit Enter\n",DRIVER_NAME ));

        // allocate buffer to hold message header and data.
        responseBuffer = ExAllocatePool(NonPagedPool,
                                        SmartcardExtension->IoRequest.ReplyBufferLength + sizeof(USBSC_OUT_MESSAGE_HEADER));

        if (!responseBuffer) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }
        
        replyPos = SmartcardExtension->SmartcardReply.Buffer;
                       
        replyHeader      = (PUSBSC_IN_MESSAGE_HEADER) responseBuffer;
        currentHeaderPos = SmartcardExtension->SmartcardRequest.Buffer;
        SmartcardExtension->SmartcardReply.BufferLength = 0;
        bytesToRead = SmartcardExtension->ReaderCapabilities.MaxIFSD + 5;    // Set to MAX possible so we allocate enough


        // With the APDU exchange levels, we don't use smclib to manage the 
        // protocol.  We just shovel the data and the reader handles the details
        if ((ReaderExtension->ExchangeLevel == SHORT_APDU_LEVEL)
            || (ReaderExtension->ExchangeLevel == EXTENDED_APDU_LEVEL)) {
                    
            PIO_HEADER IoHeader = (PIO_HEADER) SmartcardExtension->IoRequest.RequestBuffer;

            SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT1Transmit APDU_LEVEL\n",DRIVER_NAME ));


            if (SmartcardExtension->IoRequest.ReplyBufferLength <
                IoHeader->ScardIoRequest.cbPciLength + 2) {

                //
                // We should at least be able to store 
                // the io-header plus SW1 and SW2
                //
                status = STATUS_BUFFER_TOO_SMALL;               
                __leave;

            }

            bytesToSend = SmartcardExtension->IoRequest.RequestBufferLength - 
                                IoHeader->ScardIoRequest.cbPciLength;

            // Need to allocate buffer for write data
            requestBuffer = ExAllocatePool(NonPagedPool,
                                           bytesToSend + sizeof(USBSC_OUT_MESSAGE_HEADER));

            if (requestBuffer == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            replyPos = SmartcardExtension->IoRequest.ReplyBuffer;
            currentHeaderPos = requestBuffer;
            *SmartcardExtension->IoRequest.Information = 0;

            // Copy over the data to write to the reader so we have room for the message header
            RtlCopyMemory(&requestBuffer[sizeof(USBSC_OUT_MESSAGE_HEADER)],
                          &SmartcardExtension->IoRequest.RequestBuffer[sizeof(SCARD_IO_REQUEST)],
                          SmartcardExtension->IoRequest.RequestBufferLength - sizeof(SCARD_IO_REQUEST));

            // Copy over the SCARD_IO)REQUEST structure from the request buffer to the 
            // reply buffer
            RtlCopyMemory(replyPos,
                          IoHeader,
                          sizeof(SCARD_IO_REQUEST ));

            replyPos += sizeof(SCARD_IO_REQUEST);

            header.bMessageType = PC_to_RDR_XfrBlock;
            header.bSlot = 0;
            header.bBWI = 0;

            if (bytesToSend <= (ReaderExtension->MaxMessageLength - sizeof(USBSC_OUT_MESSAGE_HEADER))) {

                // this is basically just like a short APDU
                header.wLevelParameter = 0;
                requestLength = bytesToSend;

            } else {

                requestLength = ReaderExtension->MaxMessageLength - sizeof(USBSC_OUT_MESSAGE_HEADER);
                header.wLevelParameter = 1;

            }

            while (bytesToSend || ((replyHeader->bChainParameter & 0x01) == 0x01)) {

                header.dwLength = requestLength;
                *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        bytesToRead,
                                        replyPos,
                                        FALSE);

                if (!NT_SUCCESS(status)) {

                    __leave;

                }

                bytesToSend -= requestLength;
                currentHeaderPos += requestLength;

                if ((bytesToSend <= (ReaderExtension->MaxMessageLength - sizeof(USBSC_OUT_MESSAGE_HEADER))) && (bytesToSend > 0)) {
                    // Last part of APDU

                    requestLength = bytesToSend;
                    header.wLevelParameter = 2;

                } else if (bytesToSend > 0) {
                    // Still more APDU to come

                    header.wLevelParameter = 3;

                } else {
                    // Expect more data

                    header.wLevelParameter = 0x10;
                }

                replyPos += replyHeader->dwLength;         
                *SmartcardExtension->IoRequest.Information += replyHeader->dwLength;
                
            }

            *SmartcardExtension->IoRequest.Information += IoHeader->ScardIoRequest.cbPciLength;

            __leave;  // Finished transmitting data


        }

        // TPDU and Character levels
        // Run this loop as long as he protocol requires to send data
        do {

            // Tell the lib to allocate space for the header
            SmartcardExtension->SmartcardRequest.BufferLength = sizeof(USBSC_OUT_MESSAGE_HEADER);
            SmartcardExtension->SmartcardReply.BufferLength = 0;

            status = SmartcardT1Request(SmartcardExtension);
    
            if (!NT_SUCCESS(status)) {

                __leave;

            }

            replyPos = SmartcardExtension->SmartcardReply.Buffer;

            bytesToSend = SmartcardExtension->SmartcardRequest.BufferLength - sizeof(USBSC_OUT_MESSAGE_HEADER);

            // Set parameters that are common to all ExchangeLevels.
            header.bMessageType = PC_to_RDR_XfrBlock;
            header.bSlot = 0;
            
            switch (ReaderExtension->ExchangeLevel) {
 
            case TPDU_LEVEL:

                SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT1Transmit TPDU_LEVEL\n",DRIVER_NAME ));


                header.wLevelParameter = 0;
                header.dwLength = bytesToSend;
                header.bBWI = SmartcardExtension->T1.Wtx;

                *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        bytesToRead,
                                        replyPos,
                                        FALSE);

                // 
                // smclib will detect timeout errors, so we set status
                // to success
                //
                if (status == STATUS_IO_TIMEOUT) {

                    status = STATUS_SUCCESS;

                }

                if (!NT_SUCCESS(status)) {

                    __leave;

                }

                bytesToSend = 0;
                SmartcardExtension->SmartcardReply.BufferLength = replyHeader->dwLength;

                break;

            case CHARACTER_LEVEL:
            
                SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT1Transmit CHARACTER_LEVEL\n",DRIVER_NAME ));

                currentHeaderPos = SmartcardExtension->SmartcardRequest.Buffer;
            
            
                header.dwLength = bytesToSend;
            
                header.wLevelParameter = 3; // response is just the prologue field

                header.bBWI = SmartcardExtension->T1.Wtx;

            
                *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

            
                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        header.wLevelParameter,
                                        replyPos,
                                        FALSE);

                //
                // smclib will detect timeout errors, so we set status to 
                // success
                //
                if (status == STATUS_IO_TIMEOUT) {

                    status = STATUS_SUCCESS;
                    SmartcardExtension->SmartcardReply.BufferLength += replyHeader->dwLength;
                    break;


                }


                if (!NT_SUCCESS(status)) {
                    ASSERT(FALSE);

                    __leave;

                }


                SmartcardExtension->SmartcardReply.BufferLength += replyHeader->dwLength;


                bytesToSend = 0;
                bytesToRead = replyPos[2] + 
                    (SmartcardExtension->CardCapabilities.T1.EDC & 0x01 ? 2 : 1);

                header.dwLength = 0;
                header.wLevelParameter = bytesToRead;
                    *(PUSBSC_OUT_MESSAGE_HEADER)currentHeaderPos = header;

                replyPos += replyHeader->dwLength;


                status = UsbScReadWrite(SmartcardExtension,
                                        currentHeaderPos,
                                        responseBuffer,
                                        header.wLevelParameter,
                                        replyPos,
                                        FALSE);

                //
                // smclib will detect timeout errors, so we set status to 
                // success
                //
                if (status == STATUS_IO_TIMEOUT) {

                    status = STATUS_SUCCESS;

                }


                if (!NT_SUCCESS(status)) {

                    __leave;

                }

                SmartcardExtension->SmartcardReply.BufferLength += replyHeader->dwLength;

                break;

            }

            status = SmartcardT1Reply(SmartcardExtension);

        } while (status == STATUS_MORE_PROCESSING_REQUIRED);


    }

    __finally
    {

        if (requestBuffer) {

            ExFreePool(requestBuffer);
            requestBuffer = NULL;

        }

        if (responseBuffer) {

            ExFreePool(responseBuffer);
            responseBuffer = NULL;

        }

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScT1Transmit Exit : 0x%x\n",DRIVER_NAME, status ));
    
    }

    return status;

}


NTSTATUS
UsbScReadWrite(
    PSMARTCARD_EXTENSION SmartcardExtension,
    PVOID WriteBuffer,
    PUCHAR ReadBuffer,
    WORD ReadLength,
    PVOID ResponseBuffer,
    BOOL NullByte)
/*++

Routine Description:
    Writes data to the reader, and then reads response from reader.
    Handles the bSeq value, checking the slot number, any time extension requests
    Also converts errors into NTSTATUS codes

Arguments:
    SmartcardExtension  - 
    WriteBuffer         - Data to be written to the reader
    ReaderBuffer        - Caller allocated buffer to hold the response 
    ReadLength          - Number of bytes expected (excluding header)
    ResponseBuffer      - optional buffer to copy response data only (no header)
    NullByte            - Look for NULL byte (used in T=0 protocol)

Return Value:
    NTSTATUS value

--*/
{
    
    NTSTATUS            status = STATUS_SUCCESS;
    PUSBSC_OUT_MESSAGE_HEADER header; 
    PUSBSC_IN_MESSAGE_HEADER replyHeader; 
    WORD                writeLength; 
    ULONG               timeout = 0;


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScReadWrite Enter\n",DRIVER_NAME ));

        header = (PUSBSC_OUT_MESSAGE_HEADER) WriteBuffer;
        replyHeader = (PUSBSC_IN_MESSAGE_HEADER) ReadBuffer;
        writeLength = header->dwLength + sizeof( USBSC_OUT_MESSAGE_HEADER);
        ReadLength += sizeof( USBSC_IN_MESSAGE_HEADER );


        header->bSeq = InterlockedIncrement(&SmartcardExtension->ReaderExtension->SequenceNumber);        

        //
        //  Send the data to the device
        //
        status = UsbWrite(SmartcardExtension->ReaderExtension,
                          WriteBuffer,
                          writeLength,
                          timeout);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

        SmartcardDebug( DEBUG_PROTOCOL, 
                        ("%s!UsbScReadWrite Wrote %s, 0x%x bytes (header + 0x%x)\n",
                         DRIVER_NAME, 
                         GetMessageName(header->bMessageType), 
                         writeLength, header->dwLength ));


        if (SmartcardExtension->CardCapabilities.Protocol.Selected == SCARD_PROTOCOL_T1) {

            if (SmartcardExtension->T1.Wtx) {

                SmartcardDebug( DEBUG_PROTOCOL, ("%s!UsbScReadWrite Wait time extension.  Wtx=0x%x, bBWI=0x%x\n",DRIVER_NAME, SmartcardExtension->T1.Wtx, header->bBWI));

            }

        }

        // We want to loop here if the reader requests a time extension
        while (1) {
            
            status = UsbRead(SmartcardExtension->ReaderExtension,
                             ReadBuffer,
                             ReadLength,
                             timeout);

            if (!NT_SUCCESS(status)) {

                __leave;

            }

            SmartcardDebug( DEBUG_PROTOCOL, 
                            ("%s!UsbScReadWrite Read %s, 0x%x bytes (header + 0x%x)\n",
                             DRIVER_NAME, 
                             GetMessageName(replyHeader->bMessageType),
                             ReadLength, replyHeader->dwLength ));
            


            if ((replyHeader->bSlot != header->bSlot) || (replyHeader->bSeq != header->bSeq)) {

                // This is not ours.  Who knows where this came from (probably a different slot that we don't support)
                SmartcardDebug( DEBUG_PROTOCOL, ("%s!UsbScReadWrite Someone else's message received\n\t\tSlot %x (%x), Seq %x (%x)\n",
                                              DRIVER_NAME,
                                              replyHeader->bSlot,
                                              header->bSlot,
                                              replyHeader->bSeq,
                                              header->bSeq ));
                


                continue;

            } else if (replyHeader->bStatus & COMMAND_STATUS_FAILED) {

                // Doh we have a problem
                SmartcardDebug( DEBUG_PROTOCOL, 
                                ("%s!UsbScReadWrite COMMAND_STATUS_FAILED\n\tbmICCStatus = 0x%x\n\tbmCommandStatus = 0x%x\n\tbError = 0x%x\n",
                                 DRIVER_NAME, 
                                 replyHeader->bStatus & ICC_STATUS_MASK,
                                 (replyHeader->bStatus & COMMAND_STATUS_MASK) >> 6,
                                 replyHeader->bError));

                status = UsbScErrorConvert(replyHeader);

            } else if (replyHeader->bStatus & COMMAND_STATUS_TIME_EXT) {

                // Time extension requested
                // We should sleep for a bit while the reader prepares the data

                UINT wi = replyHeader->bError;
                LARGE_INTEGER delayTime;

                SmartcardDebug( DEBUG_PROTOCOL, ("%s!UsbScReadWrite Time extension requested\n",DRIVER_NAME ));

                delayTime.HighPart = -1;
                if (SmartcardExtension->CardCapabilities.Protocol.Selected == SCARD_PROTOCOL_T1) {
                    
                    delayTime.LowPart = 
                        (-1) *
                        SmartcardExtension->CardCapabilities.T1.BWT *
                        wi *
                        10;

                } else {
                
                    delayTime.LowPart = 
                        (-1) *  // relative
                        SmartcardExtension->CardCapabilities.T0.WT *
                        wi * 
                        10;  // 100 nanosecond units
                                    
                }

//                KeDelayExecutionThread(KernelMode,
//                                       FALSE,
//                                       &delayTime);
                continue;

            } else if (NullByte && (ReadBuffer[sizeof(USBSC_IN_MESSAGE_HEADER)] == 0x60)) {

                // NULL byte, wait for another response
                SmartcardDebug( DEBUG_PROTOCOL, ("%s!UsbScReadWrite Received NULL byte, waiting for next response\n",DRIVER_NAME ));

                continue;

            } else {
                // SUCCESS!!
                SmartcardDebug( DEBUG_PROTOCOL, 
                                ("%s!UsbScReadWrite Read %s, 0x%x bytes (header + 0x%x)\n",
                                 DRIVER_NAME, 
                                 GetMessageName(replyHeader->bMessageType),
                                 ReadLength, replyHeader->dwLength ));


            }
            break;

        }

        

        //
        // copy data to request buffer
        //
        if (ResponseBuffer) {

            RtlCopyMemory(ResponseBuffer, 
                          ReadBuffer + sizeof(USBSC_IN_MESSAGE_HEADER),
                          replyHeader->dwLength);

        }
    
    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScReadWrite Exit : 0x%x\n",DRIVER_NAME, status ));
    
    }

    return status;


}


NTSTATUS
UsbScErrorConvert(
    PUSBSC_IN_MESSAGE_HEADER ReplyHeader
    )
/*++

Routine Description:
    Converts the errors returned by the reader into
    valid NTSTATUS codes

Arguments:
    ReplyHeader     - reply header recieved from reader

Return Value:
    NTSTATUS code corresponding to the reader error

--*/
{

    NTSTATUS status = STATUS_UNSUCCESSFUL;
    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScErrorConvert Enter\n",DRIVER_NAME ));

        SmartcardDebug( DEBUG_TRACE, ("bmICCStatus = 0x%x\n",ReplyHeader->bStatus & ICC_STATUS_MASK ));
        SmartcardDebug( DEBUG_TRACE, ("bmCommandStatus = 0x%x\n", (ReplyHeader->bStatus & COMMAND_STATUS_MASK) >> 6 ));
        SmartcardDebug( DEBUG_TRACE, ("bError = 0x%x\n",ReplyHeader->bError ));


        switch (ReplyHeader->bError) {
        case CMD_ABORTED:
            status = STATUS_CANCELLED;
            break;
        
        case ICC_MUTE:
            if ((ReplyHeader->bStatus & ICC_STATUS_MASK) == 2) {

                status = STATUS_NO_MEDIA;

            } else {

                status = STATUS_IO_TIMEOUT;

            }
            break;

        case XFR_PARITY_ERROR:
            status = STATUS_PARITY_ERROR;
            break;
        
        case XFR_OVERRUN:
            status = STATUS_DATA_OVERRUN;
            break;
        
        case HW_ERROR:
            status = STATUS_IO_DEVICE_ERROR;
            break;
        
        
        case BAD_ATR_TS:
            status = STATUS_DEVICE_PROTOCOL_ERROR;
            break;

        case BAD_ATR_TCK:
            status = STATUS_DEVICE_PROTOCOL_ERROR;
            break;

        case ICC_PROTOCOL_NOT_SUPPORTED:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case ICC_CLASS_NOT_SUPPORTED:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case PROCEDURE_BYTE_CONFLICT:
            status = STATUS_DEVICE_PROTOCOL_ERROR;
            break;

        case DEACTIVATED_PROTOCOL:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case BUSY_WITH_AUTO_SEQUENCE:
            status = STATUS_DEVICE_BUSY;
            break;

        case PIN_TIMEOUT:
            break;

        case PIN_CANCELLED:
            break;

        case CMD_SLOT_BUSY:
            status = STATUS_DEVICE_BUSY;
            break;
        

        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;                
        
        }

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScErrorConvert Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;


}


NTSTATUS
UsbScTrackingISR(
    PVOID         Context, 
    PVOID         Buffer,
    ULONG         BufferLength,
    ULONG         NotificationType,
    PBOOLEAN      QueueData)
/*++

Routine Description:
    Callback function that is called when there is a slot change notification or
    a reader error.  This handles completing card tracking irps.

Arguments:
    

Return Value:

--*/
{

    NTSTATUS            status = STATUS_SUCCESS;
    PSMARTCARD_EXTENSION SmartcardExtension = (PSMARTCARD_EXTENSION) Context;
    PUSBSC_SLOT_CHANGE_HEADER header;
    PUSBSC_HWERROR_HEADER errorHeader;
    ULONG               oldState;
    UCHAR               slotState;
    KIRQL               irql;

    __try
    {
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScTrackingISR Enter\n",DRIVER_NAME ));

        // We don't need this data to be saved
        *QueueData = FALSE;

        // Make sure that we got enough data
        if (BufferLength < sizeof(USBSC_SLOT_CHANGE_HEADER)) {

            status = STATUS_INVALID_PARAMETER;
            __leave;

        }

        header = (PUSBSC_SLOT_CHANGE_HEADER) Buffer;

        switch (header->bMessageType) {
        case RDR_to_PC_NotifySlotChange:
            slotState = header->bmSlotICCState & SLOT0_MASK;
            
            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);           
                    
            oldState = SmartcardExtension->ReaderCapabilities.CurrentState;
            if (slotState & 0x2) {

                // State changed
                if (slotState & 0x1) {

                    SmartcardDebug( DEBUG_PROTOCOL, ("%s: RDR_to_PC_NotifySlotChange - Card Inserted (0x%x)\n",DRIVER_NAME, slotState));

                    // Card is inserted
                    SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
                    
                    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                      irql);
                    if (SmartcardExtension->OsData->NotificationIrp && (oldState <= SCARD_ABSENT)) {
                        
                        UsbScCompleteCardTracking(SmartcardExtension);

                    }

                } else {

                    SmartcardDebug( DEBUG_PROTOCOL, ("%s: RDR_to_PC_NotifySlotChange - Card Removed (0x%x)\n",DRIVER_NAME, slotState));
                    // Card is removed
                    SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
                    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                      irql);

                    if (SmartcardExtension->OsData->NotificationIrp && (oldState > SCARD_ABSENT)) {
                        
                        UsbScCompleteCardTracking(SmartcardExtension);

                    }

                }

            } else {
                SmartcardDebug( DEBUG_PROTOCOL, ("%s: RDR_to_PC_NotifySlotChange - No change (0x%x)\n",DRIVER_NAME, slotState));
                KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                  irql);

            }

            break;

        case RDR_to_PC_HardwareError:

            errorHeader = (PUSBSC_HWERROR_HEADER) Buffer;

            SmartcardDebug( DEBUG_PROTOCOL, ("%s: RDR_to_PC_HardwareError - 0x%x\n",DRIVER_NAME, errorHeader->bHardwareErrorCode));
            // Lets just ignore hardware errors for now and see what happens.
            break;

        default:
            ASSERT(FALSE);
            break;

        }

    }

    __finally
    {
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScTrackingISR Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;




}


VOID
UsbScCompleteCardTracking(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:
    Checks to see if there is a pending card tracking irp, and completes it if
    necessary.

Arguments:

Return Value:

--*/
{
    KIRQL   ioIrql, 
            keIrql;
    PIRP    notificationIrp;
    KIRQL cancelIrql;


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCompleteCardTracking Enter\n",DRIVER_NAME ));

        // Grab the NotificationIrp
        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &keIrql);

        notificationIrp = SmartcardExtension->OsData->NotificationIrp;
        SmartcardExtension->OsData->NotificationIrp = NULL;

        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          keIrql);


        if (notificationIrp) {

            // Complete the irp
            if (notificationIrp->Cancel) {

               SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCompleteCardTracking Irp CANCELLED\n",DRIVER_NAME ));

               notificationIrp->IoStatus.Status = STATUS_CANCELLED;

            } else {

               SmartcardDebug( DEBUG_TRACE, ("%s!UsbScCompleteCardTracking Completing Irp\n",DRIVER_NAME ));


               notificationIrp->IoStatus.Status = STATUS_SUCCESS;
            }

            notificationIrp->IoStatus.Information = 0;

            IoAcquireCancelSpinLock(&cancelIrql);


            // reset the cancel function so that it won't be called anymore
            IoSetCancelRoutine(notificationIrp,
                               NULL);

            IoReleaseCancelSpinLock(cancelIrql);

            IoCompleteRequest(notificationIrp,
                              IO_NO_INCREMENT);

        }

    }
        
    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!TLP3CompleteCardTracking Exit\n",DRIVER_NAME ));

    }

}


NTSTATUS
UsbScVendorIoctl(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
{
/*++

Routine Description:
    Handles vendor specific ioctls, specifically the support for PC_to_RDR_Escape
    Which allows reader vendors to implement their own features and still 
    utilize this driver.  There is no parameter checking since this is a 
    generic pass through, so it is up to the vendor to have a rock-solid
    design.

Arguments:

Return Value:

--*/

    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PUSBSC_OUT_MESSAGE_HEADER header = NULL; 
    PUSBSC_IN_MESSAGE_HEADER replyHeader = NULL;
    ULONG replySize;
    ULONG requestSize;


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScVendorIoclt Enter\n", DRIVER_NAME ));

        switch (SmartcardExtension->MajorIoControlCode) {
        case IOCTL_CCID_ESCAPE:

            if (!SmartcardExtension->ReaderExtension->EscapeCommandEnabled) {

                SmartcardDebug( DEBUG_ERROR, ("%s!UsbScVendorIoclt Escape Command Not Enabled\n", DRIVER_NAME ));
                status = STATUS_INVALID_DEVICE_REQUEST;
                __leave;
            }

            if ((MAXULONG - sizeof(USBSC_OUT_MESSAGE_HEADER)) < SmartcardExtension->IoRequest.RequestBufferLength) {
                
                SmartcardDebug( DEBUG_ERROR, ("%s!UsbScVendorIoclt Request Buffer Length is too large\n", DRIVER_NAME ));
                status = STATUS_INVALID_DEVICE_REQUEST;
                __leave;

            }

            if ((MAXULONG - sizeof(USBSC_IN_MESSAGE_HEADER)) < SmartcardExtension->IoRequest.ReplyBufferLength) {
                SmartcardDebug( DEBUG_ERROR, ("%s!UsbScVendorIoclt Reply Buffer Length is too large\n", DRIVER_NAME ));

                status = STATUS_INVALID_DEVICE_REQUEST;
                __leave;

            }

            requestSize = SmartcardExtension->IoRequest.RequestBufferLength + sizeof(USBSC_OUT_MESSAGE_HEADER);
            replySize = SmartcardExtension->IoRequest.ReplyBufferLength + sizeof(USBSC_IN_MESSAGE_HEADER);


            header = ExAllocatePool(NonPagedPool,
                                    requestSize);

            if (!header) {
                
                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            RtlZeroMemory(header, 
                          sizeof(USBSC_OUT_MESSAGE_HEADER));

            replyHeader = ExAllocatePool(NonPagedPool,
                                         replySize);

            if (!replyHeader) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            header->bMessageType = PC_to_RDR_Escape;
            header->dwLength = SmartcardExtension->IoRequest.RequestBufferLength;
            header->bSlot = 0;

            RtlCopyMemory(&header[1], 
                          SmartcardExtension->IoRequest.RequestBuffer,
                          SmartcardExtension->IoRequest.RequestBufferLength);
            
           
            status = UsbScReadWrite(SmartcardExtension,
                                    header,
                                    (PUCHAR) replyHeader,
                                    replySize,
                                    SmartcardExtension->IoRequest.ReplyBuffer,
                                    FALSE);

            if (!NT_SUCCESS(status)) {

                __leave;

            }

            if (replyHeader->bMessageType != RDR_to_PC_Escape) {

                SmartcardDebug( DEBUG_ERROR, ("%s!UsbScVendorIoclt reader returned the wrong message type\n", DRIVER_NAME ));
                status = STATUS_DEVICE_PROTOCOL_ERROR;
                __leave;
            }

            *SmartcardExtension->IoRequest.Information = replyHeader->dwLength;


            break;


        default: 
            SmartcardDebug( DEBUG_ERROR, ("%s!UsbScVendorIoclt Unsupported Vendor IOCTL\n", DRIVER_NAME ));
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    }

    __finally
    {

        if (header) {
            
            ExFreePool(header);

        }

        if (replyHeader) {

            ExFreePool(replyHeader);

        }
        
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScVendorIoclt Exit (0x%x)\n", DRIVER_NAME, status ));
        
    }

    return status;
    
    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbsc\usbscpnp.c ===
#include "usbsc.h"
#include "usbscpnp.h"
#include "usbutil.h"
#include "usbcom.h"
#include "usbsccb.h"
#include "usbscnt.h"


NTSTATUS
UsbScStartDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Handles the IRP_MN_START_DEVICE
    Gets the usb descriptors from the reader and configures it.
    Also starts "polling" the interrupt pipe

Arguments:

Return Value:

--*/
{

    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       pDevExt;
    PSMARTCARD_EXTENSION    smartcardExtension;
    PREADER_EXTENSION       readerExtension;
    ULONG                   deviceInstance;
    UCHAR                   string[MAXIMUM_ATTR_STRING_LENGTH];
    HANDLE                  regKey;
    PKEY_VALUE_PARTIAL_INFORMATION pInfo;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScStartDevice Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;
        smartcardExtension = &pDevExt->SmartcardExtension;
        readerExtension = smartcardExtension->ReaderExtension;



        status = UsbConfigureDevice(DeviceObject);

        if (!NT_SUCCESS(status)) {
            __leave;
        }


        //
        // Set the vendor information
        //


        status = GetStringDescriptor(DeviceObject,
                                     pDevExt->DeviceDescriptor->iManufacturer,
                                     smartcardExtension->VendorAttr.VendorName.Buffer,
                                     &smartcardExtension->VendorAttr.VendorName.Length);

        status = GetStringDescriptor(DeviceObject,
                                     pDevExt->DeviceDescriptor->iProduct,
                                     smartcardExtension->VendorAttr.IfdType.Buffer,
                                     &smartcardExtension->VendorAttr.IfdType.Length);

        status = GetStringDescriptor(DeviceObject,
                                     pDevExt->DeviceDescriptor->iSerialNumber,
                                     smartcardExtension->VendorAttr.IfdSerialNo.Buffer,
                                     &smartcardExtension->VendorAttr.IfdSerialNo.Length);

        
        smartcardExtension->VendorAttr.UnitNo = MAXULONG;

        for (deviceInstance = 0; deviceInstance < MAXULONG; deviceInstance++) {

           PDEVICE_OBJECT devObj;

           for (devObj = DeviceObject; devObj != NULL; devObj = devObj->NextDevice) {

               PDEVICE_EXTENSION devExt = devObj->DeviceExtension;
               PSMARTCARD_EXTENSION smcExt = &devExt->SmartcardExtension;

               if (deviceInstance == smcExt->VendorAttr.UnitNo) {

                  break;

               }

           }

           if (devObj == NULL) {

              smartcardExtension->VendorAttr.UnitNo = deviceInstance;
              break;

           }

        }


        //
        // Initialize Reader Capabilities
        //
        smartcardExtension->ReaderCapabilities.SupportedProtocols 
                                = readerExtension->ClassDescriptor.dwProtocols;

        smartcardExtension->ReaderCapabilities.ReaderType = SCARD_READER_TYPE_USB;

        smartcardExtension->ReaderCapabilities.MechProperties = 0;      // Not currently supporting any Mechanical properties

        smartcardExtension->ReaderCapabilities.Channel = smartcardExtension->VendorAttr.UnitNo;

        // Assume card is absent.
        smartcardExtension->ReaderCapabilities.CurrentState = (ULONG) SCARD_ABSENT;


        smartcardExtension->ReaderCapabilities.CLKFrequency.Default 
                                = readerExtension->ClassDescriptor.dwDefaultClock;

        smartcardExtension->ReaderCapabilities.CLKFrequency.Max 
                                = readerExtension->ClassDescriptor.dwMaximumClock;

        smartcardExtension->ReaderCapabilities.DataRate.Default 
                                = readerExtension->ClassDescriptor.dwDataRate;

        smartcardExtension->ReaderCapabilities.DataRate.Max 
                                = readerExtension->ClassDescriptor.dwMaxDataRate;

        smartcardExtension->ReaderCapabilities.MaxIFSD 
                                = readerExtension->ClassDescriptor.dwMaxIFSD;

        // See if the escape command should be allowed
        status = IoOpenDeviceRegistryKey(pDevExt->PhysicalDeviceObject,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         GENERIC_READ,
                                         &regKey);

        if (!NT_SUCCESS(status)) {

            readerExtension->EscapeCommandEnabled = FALSE;

        } else {

            UNICODE_STRING strEnable;
            ULONG tmp = 0;
            ULONG size;
            ULONG length;

            length = sizeof(KEY_VALUE_PARTIAL_INFORMATION)  + sizeof(ULONG);

            pInfo = ExAllocatePool(PagedPool, length);

            if (pInfo) {
                
                RtlInitUnicodeString (&strEnable, ESCAPE_COMMAND_ENABLE);
                status = ZwQueryValueKey(regKey,
                                         &strEnable,
                                         KeyValuePartialInformation,
                                         pInfo,
                                         length,
                                         &size);

                
            }

            ZwClose(regKey);

            if (!NT_SUCCESS(status)) {
                readerExtension->EscapeCommandEnabled = FALSE;
            } else {
                readerExtension->EscapeCommandEnabled = *((PULONG)pInfo->Data) ? TRUE : FALSE;
            }

            ExFreePool(pInfo);


        }


        if (readerExtension->EscapeCommandEnabled) {
            SmartcardDebug( DEBUG_PROTOCOL, ("%s : Escape Command Enabled\n",DRIVER_NAME ));
        } else {
            SmartcardDebug( DEBUG_PROTOCOL, ("%s : Escape Command Disabled\n",DRIVER_NAME ));
        }



        //
        // Get clock frequencies and data rates
        //

        if (!(readerExtension->ClassDescriptor.dwFeatures & AUTO_CLOCK_FREQ)
            && readerExtension->ClassDescriptor.bNumClockSupported) { 
        
            // Doesn't support auto clock frequency selection
            ULONG   bufferLength;

            bufferLength = readerExtension->ClassDescriptor.bNumClockSupported * sizeof(DWORD);

            smartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.List 
                        = ExAllocatePool(NonPagedPool,
                                         bufferLength);

            if (!smartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.List) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            ASSERT(pDevExt->LowerDeviceObject);
            status = USBClassRequest(pDevExt->LowerDeviceObject,
                                     Interface,
                                     GET_CLOCK_FREQUENCIES,
                                     0,
                                     pDevExt->Interface->InterfaceNumber,
                                     smartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.List,
                                     &bufferLength,
                                     TRUE,
                                     0,
                                     &pDevExt->RemoveLock);

            if (!NT_SUCCESS(status)) {

                __leave;
                
            }

            smartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.Entries 
                = readerExtension->ClassDescriptor.bNumClockSupported;


        }

        if (!(readerExtension->ClassDescriptor.dwFeatures & AUTO_BAUD_RATE)
            && readerExtension->ClassDescriptor.bNumDataRatesSupported) {
            // Doesn't support auto data rate selection

            ULONG   bufferLength;

            bufferLength = readerExtension->ClassDescriptor.bNumDataRatesSupported * sizeof(DWORD);

            smartcardExtension->ReaderCapabilities.DataRatesSupported.List 
                = ExAllocatePool(NonPagedPool,
                                 bufferLength);

            if (!smartcardExtension->ReaderCapabilities.DataRatesSupported.List) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;

            }

            ASSERT(pDevExt->LowerDeviceObject);
            status = USBClassRequest(pDevExt->LowerDeviceObject,
                                     Interface,
                                     GET_DATA_RATES,
                                     0,
                                     pDevExt->Interface->InterfaceNumber,
                                     smartcardExtension->ReaderCapabilities.DataRatesSupported.List,
                                     &bufferLength,
                                     TRUE,
                                     0,
                                     &pDevExt->RemoveLock);

            if (!NT_SUCCESS(status)) {
                
                __leave;

            }

            smartcardExtension->ReaderCapabilities.DataRatesSupported.Entries 
                    = readerExtension->ClassDescriptor.bNumDataRatesSupported;
            
        }

        ASSERT(pDevExt->LowerDeviceObject);
        pDevExt->WrapperHandle = USBInitializeInterruptTransfers(DeviceObject,
                                                                 pDevExt->LowerDeviceObject,
                                                                 sizeof(USBSC_HWERROR_HEADER),
                                                                 &pDevExt->Interface->Pipes[readerExtension->InterruptIndex],
                                                                 smartcardExtension,
                                                                 UsbScTrackingISR,
                                                                 USBWRAP_NOTIFICATION_READ_COMPLETE,
                                                                 &pDevExt->RemoveLock);

        status = USBStartInterruptTransfers(pDevExt->WrapperHandle);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScStartDevice Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}

NTSTATUS
UsbScStopDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Handles IRP_MN_STOP_DEVICE
    Stops "polling" the interrupt pipe and frees resources allocated in StartDevice

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScStopDevice Enter\n",DRIVER_NAME ));

        

        if (!DeviceObject) {
            __leave;
        }

        pDevExt = DeviceObject->DeviceExtension;

        status = USBStopInterruptTransfers(pDevExt->WrapperHandle);
        status = USBReleaseInterruptTransfers(pDevExt->WrapperHandle);

        if (pDevExt->DeviceDescriptor) {

           ExFreePool(pDevExt->DeviceDescriptor);
           pDevExt->DeviceDescriptor = NULL;

        }

        if (pDevExt->Interface) {

           ExFreePool(pDevExt->Interface);
           pDevExt->Interface = NULL;

        }

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScStopDevice Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}


NTSTATUS
UsbScRemoveDevice(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    handles IRP_MN_REMOVE_DEVICE
    stops and unloads the device.

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScRemoveDevice Enter\n",DRIVER_NAME ));

        UsbScStopDevice(DeviceObject,
                        Irp);

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScRemoveDevice Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbsc\usbscnt.c ===
#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <ntddk.h>
#include <usbdrivr.h>
#include "usbutil.h"
#include "usbsc.h"
#include "smclib.h"
#include "usbscnt.h"
#include "usbsccb.h"
#include "usbscpnp.h"
#include "usbscpwr.h"

// declare pageable/initialization code
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGEABLE, UsbScAddDevice )
#pragma alloc_text( PAGEABLE, UsbScCreateClose )
#pragma alloc_text( PAGEABLE, UsbScUnloadDriver )


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:
    Drivers DriverEntry function

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
#ifdef BETA_SPEW
#if DEBUG
    SmartcardSetDebugLevel(DEBUG_PROTOCOL | DEBUG_ERROR);
#endif
#endif
    __try
    {
        SmartcardDebug( DEBUG_TRACE, ("%s!DriverEntry Enter\n",DRIVER_NAME ));

        // Initialize the Driver Object with driver's entry points
        DriverObject->DriverUnload                          = ScUtil_UnloadDriver;
        DriverObject->MajorFunction[IRP_MJ_CREATE]          = ScUtil_CreateClose;
        DriverObject->MajorFunction[IRP_MJ_CLOSE]           = ScUtil_CreateClose;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP]         = ScUtil_Cleanup;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = ScUtil_DeviceIOControl;
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = ScUtil_SystemControl;
        DriverObject->MajorFunction[IRP_MJ_PNP]             = ScUtil_PnP;
        DriverObject->MajorFunction[IRP_MJ_POWER]           = ScUtil_Power;
        DriverObject->DriverExtension->AddDevice            = UsbScAddDevice;


    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!DriverEntry Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}



NTSTATUS
UsbScAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:
    AddDevice routine.  Creates the FDO and does initialization work.

Arguments:

Return Value:

--*/
{

    NTSTATUS                status;
    PDEVICE_EXTENSION       pDevExt;
    PSMARTCARD_EXTENSION    pSmartcardExtension;
    PREADER_EXTENSION       pReaderExtension;
    RTL_QUERY_REGISTRY_TABLE parameters[3];
    PDEVICE_OBJECT          pDevObj = NULL;
    PURB                    urb;

    __try
    {
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScAddDevice Enter\n",DRIVER_NAME ));


        // create the device object
        status = IoCreateDevice(DriverObject,
                                sizeof( DEVICE_EXTENSION ),
                                NULL,
                                FILE_DEVICE_SMARTCARD,
                                0,
                                TRUE,
                                &pDevObj);

        if (!NT_SUCCESS(status)) {

            __leave;

        }

        // initialize device extension
        pDevExt = pDevObj->DeviceExtension;

        pSmartcardExtension = &pDevExt->SmartcardExtension;

        pDevObj->Flags |= DO_POWER_PAGABLE;

        IoInitializeRemoveLock(&pDevExt->RemoveLock,
                               SMARTCARD_POOL_TAG,
                               0,
                               10);

        pDevExt->DeviceDescriptor = NULL;
        pDevExt->Interface = NULL;

        // allocate & initialize reader extension
        pSmartcardExtension->ReaderExtension = ExAllocatePool(NonPagedPool,
                                                              sizeof( READER_EXTENSION ));

        if ( pSmartcardExtension->ReaderExtension == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;

        }

        pReaderExtension = pSmartcardExtension->ReaderExtension;

        ASSERT( pReaderExtension != NULL );

        RtlZeroMemory(pReaderExtension, sizeof( READER_EXTENSION ));
        pReaderExtension->DeviceObject = pDevObj;

        // initialize smartcard extension - version & callbacks

        // Write the version of the lib we use to the smartcard extension
        pSmartcardExtension->Version = SMCLIB_VERSION;
        pSmartcardExtension->SmartcardRequest.BufferSize =
            pSmartcardExtension->SmartcardReply.BufferSize = MIN_BUFFER_SIZE;

        //
        // Now let the lib allocate the buffer for data transmission
        // We can either tell the lib how big the buffer should be
        // by assigning a value to BufferSize or let the lib
        // allocate the default size
        //
        status = SmartcardInitialize(pSmartcardExtension);

        if (!NT_SUCCESS(status)) {

           __leave;

        }


        pSmartcardExtension->ReaderFunction[RDF_TRANSMIT]        = UsbScTransmit;
        pSmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL]    = UsbScSetProtocol;
        pSmartcardExtension->ReaderFunction[RDF_CARD_POWER]      = UsbScCardPower;
        pSmartcardExtension->ReaderFunction[RDF_CARD_TRACKING]   = UsbScCardTracking;
        pSmartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR]    = UsbScVendorIoctl;
        pSmartcardExtension->ReaderFunction[RDF_READER_SWALLOW]  = NULL; //UsbScCardSwallow;
        pSmartcardExtension->ReaderFunction[RDF_CARD_EJECT]      = NULL; //UsbScCardEject;


        // Save deviceObject
        pSmartcardExtension->OsData->DeviceObject = pDevObj;

        pDevExt = pDevObj->DeviceExtension;

        // attach the device object to the physical device object
        pDevExt->LowerDeviceObject = IoAttachDeviceToDeviceStack(pDevObj,
                                                                 Pdo);

        ASSERT( pDevExt->LowerDeviceObject != NULL );
        

        if ( pDevExt->LowerDeviceObject == NULL ) {

            status = STATUS_UNSUCCESSFUL;
            __leave;

        }

        pDevExt->PhysicalDeviceObject = Pdo;

        pDevObj->Flags |= DO_BUFFERED_IO;
        pDevObj->Flags |= DO_POWER_PAGABLE;
        pDevObj->Flags &= ~DO_DEVICE_INITIALIZING;

        ScUtil_Initialize(&pDevExt->ScUtilHandle,
                          Pdo,
                          pDevExt->LowerDeviceObject,
                          pSmartcardExtension,
                          &pDevExt->RemoveLock,
                          UsbScStartDevice,
                          UsbScStopDevice,
                          UsbScRemoveDevice,
                          NULL,
                          UsbScSetDevicePowerState);

        }

    __finally
    {
        SmartcardDebug(DEBUG_TRACE, ( "%s!DrvAddDevice: Exit (%lx)\n", DRIVER_NAME, status ));

    }
    return status;

}


NTSTATUS 
UsbScSetDevicePowerState(
    IN PDEVICE_OBJECT        DeviceObject, 
    IN DEVICE_POWER_STATE    DeviceState,
    OUT PBOOLEAN             PostWaitWake
    )
/*++

Routine Description:
    Handles whatever changes need to be made when the device is changing
    power states.

Arguments:
    DeviceObject
    DeviceState     - the device power state that the reader is entering
    PostWaitWakeIrp - used for future compatability with WDM Wrapper

Return Value:

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       pDevExt;
    PSMARTCARD_EXTENSION    smartcardExtension;
    KIRQL                   irql;
    PIO_STACK_LOCATION      irpStack;
    __try
    {
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSetDevicePowerState Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;
        smartcardExtension = &pDevExt->SmartcardExtension;

        if (DeviceState < pDevExt->PowerState) {
            // We are coming up!

            // 
            // According to the spec, we need to assume that all cards were removed.  
            // We will get insertion notification if a card is present.
            // So if there is a removal irp pending, we should complete that.
            // 
            KeAcquireSpinLock(&smartcardExtension->OsData->SpinLock,
                              &irql);

            if (smartcardExtension->OsData->NotificationIrp) {
                irpStack = IoGetCurrentIrpStackLocation(smartcardExtension->OsData->NotificationIrp);

                if (irpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SMARTCARD_IS_ABSENT) {
                    KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                      irql);
                    UsbScCompleteCardTracking(smartcardExtension);
                    
                } else {
                    
                    KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                      irql);


                }
            } else {

                KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                  irql);

            }

            //
            // Continue polling the interrupt pipe for insertion notifications
            //
            USBStartInterruptTransfers(pDevExt->WrapperHandle);

            pDevExt->PowerState = DeviceState;




        } else if (DeviceState > pDevExt->PowerState) {

            //
            // We are going down!
            //

                                     
            // Stop polling for insertion notifications
            USBStopInterruptTransfers(pDevExt->WrapperHandle);


            pDevExt->PowerState = DeviceState;

        }

        status = STATUS_SUCCESS;

    }

    __finally
    {
        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSetDevicePowerState Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\addfilter\addfilter.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    addfilter.c

Abstract:

    This command line utility adds and removes upper filter drivers
    for a given drive or volume

Author:

    Benjamin Strautin (t-bensta)

Environment:

    User mode only

Notes:

    - the filter is not checked for validity before it is added to the driver
      stack; if an invalid filter is added, the device may no longer be
      accessible.
    - all code works irrespective of character set (ANSI, Unicode, ...)

Revision History:

    05-24-99 : created

--*/

#include <windows.h>
#include <stdio.h>
#include <malloc.h>

// defines GUID
#include <initguid.h>

// the SetupDiXXX api (from the DDK)
#include <setupapi.h>

// defines guids for device classes (DiskClassGuid, etc)
#include <devioctl.h>
#include <ntddstor.h>

// for all of the _t stuff (to allow compiling for both Unicode/Ansi)
#include <tchar.h>


#if DBG
#include <assert.h>
#define ASSERT(condition) assert(condition)
#else
#define ASSERT(condition)
#endif

BOOLEAN
AddFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter,
    IN BOOLEAN UpperFilter
    );

BOOLEAN
RemoveFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter,
    IN BOOLEAN UpperFilter
    );

void
PrintFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN UpperFilters
    );

LPTSTR
GetFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN UpperFilters
    );

void PrintDeviceName(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

BOOLEAN
DeviceNameMatches(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR DeviceName
    );

PBYTE
GetDeviceRegistryProperty(
    IN  HDEVINFO DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD Property,
    OUT PDWORD PropertyRegDataType
    );

BOOLEAN
RestartDevice(
    IN HDEVINFO DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );

BOOLEAN
PrependSzToMultiSz(
    IN     LPTSTR  SzToPrepend,
    IN OUT LPTSTR *MultiSz
    );

size_t
MultiSzLength(
    IN LPTSTR MultiSz
    );

size_t
MultiSzSearchAndDeleteCaseInsensitive(
    IN  LPTSTR  FindThis,
    IN  LPTSTR  FindWithin,
    OUT size_t  *NewStringLength
    );

void
PrintUsage();

// To add/remove filter drivers:
// - use SetupDiGetClassDevs to get a list of devices of the given interface
//   class
// - use SetupDiEnumDeviceInfo to enumerate the items in that list and
//   obtain a SP_DEVINFO_DATA
// - use SetupDiGetDeviceRegistryProperty to get the list of filter drivers
// - add/remove items in the filter list
// - use SetupDiSetDeviceRegistryProperty to put the list back in place
// To restart the device:
// - use SetupDiCallClassInstaller with DIF_PROPERTYCHANGE and DICS_STOP to
//   stop the device
// - use SetupDiCallClassInstaller with DIF_PROPERTYCHANGE and DICS_START to
//   restart the device

int __cdecl _tmain(int argc, _TCHAR ** argv, _TCHAR ** envp)
{
    // these two constants are used to help enumerate through the list of all
    // disks and volumes on the system. Adding another GUID should "just work"
    static const GUID * deviceGuids[] = {
        &DiskClassGuid,
        &VolumeClassGuid,
        &CdRomClassGuid
    };
    static const int numdeviceGuids = sizeof(deviceGuids) / sizeof(LPGUID);

    // structs needed to contain information about devices
    HDEVINFO                 devInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA          devInfoData;

    // indices for stepping through devices, and device interface guids
    int argIndex;
    int devGuidIndex;
    int deviceIndex;

    // variables used to deal with the command-line options of this program
    BOOLEAN listDevices   = FALSE;
    BOOLEAN upperFilter   = TRUE;

    LPTSTR deviceName     = NULL;
    LPTSTR filterToAdd    = NULL;
    LPTSTR filterToRemove = NULL;

    BOOLEAN keepGoing   = TRUE;
    BOOLEAN needReboot  = FALSE;
    BOOLEAN deviceMatch = FALSE;

    ////////////////////////////////////////////////
    // parse arguments; nothing too exciting here //
    ////////////////////////////////////////////////

    if( argc < 2 || _tcscmp(argv[1], _T("/?")) == 0 )
    {
        PrintUsage();
        return (0);
    }

    argIndex=1;

    for (argIndex = 1; argIndex < argc; argIndex++) {

        if( _tcscmp(argv[argIndex], _T("/listdevices")) == 0 ) {
            
            listDevices = TRUE;
        
        } else if( _tcscmp(argv[argIndex], _T("/lower")) == 0 ) {

            upperFilter = FALSE;
            printf("Using Lower Filters\n");

        } else if( _tcscmp(argv[argIndex], _T("/device")) == 0 ) {
            
            argIndex++;
            
            if( argIndex < argc ) {
                deviceName = argv[argIndex];
            } else {
                PrintUsage();
                return (0);
            }

        } else if( _tcscmp(argv[argIndex], _T("/add")) == 0 ) {

            argIndex++;
            
            if( argIndex<argc ) {
                filterToAdd = argv[argIndex];
            } else {
                PrintUsage();
                return (0);
            }
        
        } else if( _tcscmp(argv[argIndex], _T("/remove")) == 0 ) {
            
            argIndex++;
            if( argIndex<argc ) {
                filterToRemove = argv[argIndex];
            } else {
                PrintUsage();
                return (0);
            }

        } else {
            PrintUsage();
            return (0);
        }

    }

    //////////////////////////////////////////////////////
    // done parsing arguments, move onto the good stuff //
    //////////////////////////////////////////////////////

    // This outer loop steps through the array of device guid pointers that is
    // defined above main(). It was just the easiest way to deal with both
    // Disks and Volumes (and it is easy to add other types of devices)
    
    for(devGuidIndex = 0; devGuidIndex<numdeviceGuids; devGuidIndex++) {
        
        // get a list of devices which support the given interface
        devInfo = SetupDiGetClassDevs( deviceGuids[devGuidIndex],
                                       NULL,
                                       NULL,
                                       DIGCF_PROFILE |
                                       DIGCF_DEVICEINTERFACE |
                                       DIGCF_PRESENT );

        if( devInfo == INVALID_HANDLE_VALUE ) {
            printf("got INVALID_HANDLE_VALUE!\n");
            return (1);
        }

        // as per DDK docs on SetupDiEnumDeviceInfo
        devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        // step through the list of devices for this handle
        // get device info at index deviceIndex, the function returns FALSE
        // when there is no device at the given index.
        for( deviceIndex=0;
             SetupDiEnumDeviceInfo( devInfo, deviceIndex, &devInfoData );
             deviceIndex++ ) {
            
            // setting this variable to FALSE will cause all of the if
            // statements to fall through, cutting off processing for this
            // device.
            keepGoing = TRUE;

            // if a device name was specified, and it doesn't match this one,
            // stop. If there is a match (or no name was specified), mark that
            // there was a match.
            if( deviceName != NULL &&
                !DeviceNameMatches( devInfo, &devInfoData, deviceName )
                ) {
                
                keepGoing = FALSE;

            } else {
                
                deviceMatch = TRUE;

            }

            // print the device name
            if( keepGoing && listDevices ) {
                
                PrintDeviceName( devInfo, &devInfoData );

            }

            // print the drivers, if we are not adding or removing one
            if( keepGoing && filterToAdd == NULL && filterToRemove == NULL ) {
                
                PrintFilters( devInfo, &devInfoData, upperFilter );

            }

            // add the filter, then try to restart the device
            if( keepGoing && filterToAdd != NULL ) {
                
                if( !AddFilterDriver(devInfo,
                                     &devInfoData,
                                     filterToAdd,
                                     upperFilter)) {
                    
                    printf("Unable to add filter!\n");
                
                } else {
                    
                    if( !RestartDevice( devInfo, &devInfoData) ) {
                        needReboot = TRUE;
                    }

                }
            }

            // remove the filter, then try to restart the device
            if( keepGoing && filterToRemove != NULL ) {
                
                if( !RemoveFilterDriver(devInfo,
                                        &devInfoData,
                                        filterToRemove,
                                        upperFilter)) {

                    printf("Unable to remove filter!\n");

                } else {

                    if( !RestartDevice( devInfo, &devInfoData) ) {
                        needReboot = TRUE;
                    }

                }

            }

            if( listDevices )
            {
                printf("\n");
            }

            // end of main processing loop
        }

        // clean up the device list
        if( devInfo != INVALID_HANDLE_VALUE ) {
            
            if( !SetupDiDestroyDeviceInfoList( devInfo ) ) {
                printf("unable to delete device info list! error: %u\n",
                       GetLastError());
            }

        }

    } // loop for each GUID index

    if( !deviceMatch ) {
        
        printf("No devices matched that name\n");
    
    } else {
        
        if( needReboot ) {
            
            printf("One or more devices could not be restarted. The machine "
                   "must be restarted\n"
                   "in order for settings to take effect\n");
        
        } else {
            
            printf("Everything has completed normally.\n");
            return (2);

        }

    }

    return (0);
}


/*
 * add the given filter driver to the list of upper filter drivers for the
 * device.
 *
 * After the call, the device must be restarted in order for the new setting to
 * take effect. This can be accomplished with a call to RestartDevice(), or by
 * rebooting the machine.
 *
 * returns TRUE if successful, FALSE otherwise
 *
 * note: The filter is prepended to the list of drivers, which will put it at
 * the bottom of the filter driver stack
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   Filter         - the filter to add
 */
BOOLEAN
AddFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter,
    IN BOOLEAN UpperFilter
    )
{
    size_t length = 0; // character length
    size_t size   = 0; // buffer size
    LPTSTR buffer = GetFilters( DeviceInfoSet, DeviceInfoData, UpperFilter );

    ASSERT(DeviceInfoData != NULL);
    ASSERT(Filter != NULL);

    if( buffer == NULL )
    {
        // if there is no such value in the registry, then there are no upper
        // filter drivers loaded, and we can just put one there

        // make room for the string, string null terminator, and multisz null
        // terminator
        length = _tcslen(Filter)+1;
        size   = (length+1)*sizeof(_TCHAR);
        buffer = malloc( size );
        if( buffer == NULL )
        {
            printf("in AddUpperFilterDriver(): unable to allocate memory!\n");
            return (FALSE);
        }
        memset(buffer, 0, size);

        // copy the string into the new buffer
        
        memcpy(buffer, Filter, length*sizeof(_TCHAR));

    }
    else
    {
        LPTSTR buffer2;
        // remove all instances of filter from driver list
        MultiSzSearchAndDeleteCaseInsensitive( Filter, buffer, &length );
        
        // allocate a buffer large enough to add the new filter
        // MultiSzLength already includes length of terminating NULL
        
        // determing the new length of the string
        length = MultiSzLength(buffer) + _tcslen(Filter) + 1;
        size   = length*sizeof(_TCHAR);
        
        buffer2 = malloc( size );
        if (buffer2 == NULL) {
            printf("Out of memory adding filter\n");
            return (0);
        }
        memset(buffer2, 0, size);
        
        // swap the buffers out
        memcpy(buffer2, buffer, MultiSzLength(buffer)*sizeof(_TCHAR));      
        free(buffer);
        buffer = buffer2;
        
        // add the driver to the driver list
        PrependSzToMultiSz(Filter, &buffer);
    
    }

    // set the new list of filters in place
    if( !SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                           DeviceInfoData,
                                           (UpperFilter ? SPDRP_UPPERFILTERS : SPDRP_LOWERFILTERS),
                                           (PBYTE)buffer,
                                           (MultiSzLength(buffer)*sizeof(_TCHAR)) )
        )
    {
        printf("in AddUpperFilterDriver(): "
               "couldn't set registry value! error: %u\n", GetLastError());
        free( buffer );
        return (FALSE);
    }

    // no need for buffer anymore
    free( buffer );

    return (TRUE);
}


/*
 * remove all instances of the given filter driver from the list of upper
 * filter drivers for the device.
 *
 * After the call, the device must be restarted in order for the new setting to
 * take effect. This can be accomplished with a call to RestartDevice(), or by
 * rebooting the machine.
 *
 * returns TRUE if successful, FALSE otherwise
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   Filter - the filter to remove
 */
BOOLEAN
RemoveFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter,
    IN BOOLEAN UpperFilter
    )
{
    size_t length  = 0;
    size_t size    = 0;
    LPTSTR buffer  = GetFilters( DeviceInfoSet, DeviceInfoData, UpperFilter );
    BOOL   success = FALSE;

    ASSERT(DeviceInfoData != NULL);
    ASSERT(Filter != NULL);

    if( buffer == NULL )
    {
        // if there is no such value in the registry, then there are no upper
        // filter drivers loaded, and we are done
        return (TRUE);
    }
    else
    {
        // remove all instances of filter from driver list
        MultiSzSearchAndDeleteCaseInsensitive( Filter, buffer, &length );
    }

    length = MultiSzLength(buffer);

    ASSERT ( length > 0 );

    if( length == 1 )
    {
        // if the length of the list is 1, the return value from
        // MultiSzLength() was just accounting for the trailing '\0', so we can
        // delete the registry key, by setting it to NULL.
        success = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                    DeviceInfoData,
                                                    (UpperFilter ? SPDRP_UPPERFILTERS : SPDRP_LOWERFILTERS),
                                                    NULL,
                                                    0 );
    }
    else
    {
        // set the new list of drivers into the registry
        size = length*sizeof(_TCHAR);
        success = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                    DeviceInfoData,
                                                    (UpperFilter ? SPDRP_UPPERFILTERS : SPDRP_LOWERFILTERS),
                                                    (PBYTE)buffer,
                                                    size );
    }

    // no need for buffer anymore
    free( buffer );

    if( !success )
    {
        printf("in RemoveUpperFilterDriver(): "
               "couldn't set registry value! error: %i\n", GetLastError());
        return (FALSE);
    }

    return (TRUE);
}

/*
 * print the list of upper filters for the given device
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 */
void
PrintFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN UpperFilters
    )
{
    // get the list of filters
    LPTSTR buffer = GetFilters( DeviceInfoSet, DeviceInfoData, UpperFilters );
    size_t filterPosition;

    if( buffer == NULL )
    {
        // if there is no such value in the registry, then there are no upper
        // filter drivers loaded
        printf("There are no upper filter drivers loaded for this device.\n");
    }
    else
    {
        // go through the multisz and print out each driver
        filterPosition=0;
        while( *buffer != _T('\0') )
        {
            _tprintf(_T("%i: %s\n"), filterPosition, buffer);
            buffer += _tcslen(buffer)+1;
            filterPosition++;
        }

        // no need for buffer anymore
        free( buffer );
    }

    return;
}

/*
 * print the device name
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 */
void PrintDeviceName(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    DWORD  regDataType;
    LPTSTR deviceName =
        (LPTSTR) GetDeviceRegistryProperty( DeviceInfoSet,
                                            DeviceInfoData,
                                            SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                            &regDataType );

    if( deviceName != NULL )
    {
        // just to make sure we are getting the expected type of buffer
        if( regDataType != REG_SZ )
        {
            printf("in PrintDeviceName(): registry key is not an SZ!\n");
        }
        else
        {
            // if the device name starts with \Device, cut that off (all
            // devices will start with it, so it is redundant)

            if( _tcsncmp(deviceName, _T("\\Device"), 7) == 0 )
            {
                memmove(deviceName,
                        deviceName+7,
                        (_tcslen(deviceName)-6)*sizeof(_TCHAR) );
            }

            _tprintf(_T("%s\n"), deviceName);
        }
        free( deviceName );
    }
    else
    {
        printf("in PrintDeviceName(): registry key is NULL! error: %u\n",
               GetLastError());
    }

    return;
}

/*
 * Returns a buffer containing the list of upper filters for the device. (NULL
 * is returned if there is no buffer, or an error occurs)
 * The buffer must be freed by the caller.
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 */
LPTSTR
GetFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN UpperFilters
    )
{
    DWORD  regDataType;
    LPTSTR buffer = (LPTSTR) GetDeviceRegistryProperty( DeviceInfoSet,
                                                        DeviceInfoData,
                                                        (UpperFilters ? SPDRP_UPPERFILTERS : SPDRP_LOWERFILTERS),
                                                        &regDataType );

    // just to make sure we are getting the expected type of buffer
    if( buffer != NULL && regDataType != REG_MULTI_SZ )
    {
        printf("in GetUpperFilters(): "
               "registry key is not a MULTI_SZ!\n");
        free( buffer );
        return (NULL);
    }

    return (buffer);
}

/*
 * return true if DeviceName matches the name of the device specified by
 * DeviceInfoData
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   DeviceName     - the name to try to match
 */
BOOLEAN
DeviceNameMatches(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR DeviceName
    )
{
    BOOLEAN matching = FALSE;
    DWORD   regDataType;

    // get the device name
    LPTSTR  deviceName =
        (LPTSTR) GetDeviceRegistryProperty( DeviceInfoSet,
                                            DeviceInfoData,
                                            SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                            &regDataType );

    if( deviceName != NULL )
    {
        // just to make sure we are getting the expected type of buffer
        if( regDataType != REG_SZ )
        {
            printf("in DeviceNameMatches(): registry key is not an SZ!\n");
            matching = FALSE;
        }
        else
        {
            // if the device name starts with \Device, cut that off (all
            // devices will start with it, so it is redundant)

            if( _tcsncmp(deviceName, _T("\\Device"), 7) == 0 )
            {
                memmove(deviceName,
                        deviceName+7,
                        (_tcslen(deviceName)-6)*sizeof(_TCHAR) );
            }

            // do the strings match?
            matching = (_tcscmp(deviceName, DeviceName) == 0);
        }
        free( deviceName );
    }
    else
    {
        printf("in DeviceNameMatches(): registry key is NULL!\n");
        matching = FALSE;
    }

    return (matching);
}

/*
 * A wrapper around SetupDiGetDeviceRegistryProperty, so that I don't have to
 * deal with memory allocation anywhere else
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   Property       - which property to get (SPDRP_XXX)
 *   PropertyRegDataType - the type of registry property
 */
PBYTE
GetDeviceRegistryProperty(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD Property,
    OUT PDWORD PropertyRegDataType
    )
{
    DWORD length = 0;
    PBYTE buffer = NULL;

    // get the required length of the buffer
    if( SetupDiGetDeviceRegistryProperty( DeviceInfoSet,
                                          DeviceInfoData,
                                          Property,
                                          NULL,   // registry data type
                                          NULL,   // buffer
                                          0,      // buffer size
                                          &length // required size
        ) )
    {
        // we should not be successful at this point, so this call succeeding
        // is an error condition
        printf("in GetDeviceRegistryProperty(): "
               "call SetupDiGetDeviceRegistryProperty did not fail? (%x)\n",
               GetLastError());
        return (NULL);
    }

    if( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
    {
        // this means there are no upper filter drivers loaded, so we can just
        // return.
        return (NULL);
    }

    // since we don't have a buffer yet, it is "insufficient"; we allocate
    // one and try again.
    buffer = malloc( length );
    if( buffer == NULL )
    {
        printf("in GetDeviceRegistryProperty(): "
               "unable to allocate memory!\n");
        return (NULL);
    }
    if( !SetupDiGetDeviceRegistryProperty( DeviceInfoSet,
                                           DeviceInfoData,
                                           Property,
                                           PropertyRegDataType,
                                           buffer,
                                           length,
                                           NULL // required size
        ) )
    {
        printf("in GetDeviceRegistryProperty(): "
               "couldn't get registry property! error: %i\n",
               GetLastError());
        free( buffer );
        return (NULL);
    }

    // ok, we are finally done, and can return the buffer
    return (buffer);
}


/*
 * restarts the given device
 *
 * call CM_Query_And_Remove_Subtree (to unload the driver)
 * call CM_Reenumerate_DevNode on the _parent_ (to reload the driver)
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 */
BOOLEAN
RestartDevice(
    IN HDEVINFO DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SP_PROPCHANGE_PARAMS params;
    SP_DEVINSTALL_PARAMS installParams;

    // for future compatibility; this will zero out the entire struct, rather
    // than just the fields which exist now
    memset(&params, 0, sizeof(SP_PROPCHANGE_PARAMS));

    // initialize the SP_CLASSINSTALL_HEADER struct at the beginning of the
    // SP_PROPCHANGE_PARAMS struct, so that SetupDiSetClassInstallParams will
    // work
    params.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    params.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

    // initialize SP_PROPCHANGE_PARAMS such that the device will be stopped.
    params.StateChange = DICS_STOP;
    params.Scope       = DICS_FLAG_CONFIGSPECIFIC;
    params.HwProfile   = 0; // current profile

    // prepare for the call to SetupDiCallClassInstaller (to stop the device)
    if( !SetupDiSetClassInstallParams( DeviceInfoSet,
                                       DeviceInfoData,
                                       (PSP_CLASSINSTALL_HEADER) &params,
                                       sizeof(SP_PROPCHANGE_PARAMS)
        ) )
    {
        printf("in RestartDevice(): couldn't set the install parameters!");
        printf(" error: %u\n", GetLastError());
        return (FALSE);
    }

    // stop the device
    if( !SetupDiCallClassInstaller( DIF_PROPERTYCHANGE,
                                    DeviceInfoSet,
                                    DeviceInfoData )
        )
    {
        printf("in RestartDevice(): call to class installer (STOP) failed!");
        printf(" error: %u\n", GetLastError() );
        return (FALSE);
    }

    // restarting the device
    params.StateChange = DICS_START;

    // prepare for the call to SetupDiCallClassInstaller (to stop the device)
    if( !SetupDiSetClassInstallParams( DeviceInfoSet,
                                       DeviceInfoData,
                                       (PSP_CLASSINSTALL_HEADER) &params,
                                       sizeof(SP_PROPCHANGE_PARAMS)
        ) )
    {
        printf("in RestartDevice(): couldn't set the install parameters!");
        printf(" error: %u\n", GetLastError());
        return (FALSE);
    }

    // restart the device
    if( !SetupDiCallClassInstaller( DIF_PROPERTYCHANGE,
                                    DeviceInfoSet,
                                    DeviceInfoData )
        )
    {
        printf("in RestartDevice(): call to class installer (START) failed!");
        printf(" error: %u\n", GetLastError());
        return (FALSE);
    }

    installParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    // same as above, the call will succeed, but we still need to check status
    if( !SetupDiGetDeviceInstallParams( DeviceInfoSet,
                                        DeviceInfoData,
                                        &installParams )
        )
    {
        printf("in RestartDevice(): couldn't get the device install params!");
        printf(" error: %u\n", GetLastError() );
        return (FALSE);
    }

    // to see if the machine needs to be rebooted
    if( installParams.Flags & DI_NEEDREBOOT )
    {
        return (FALSE);
    }

    // if we get this far, then the device has been stopped and restarted
    return (TRUE);
}


/*
 * prepend the given string to a MultiSz
 *
 * returns true if successful, false if not (will only fail in memory
 * allocation)
 *
 * note: This WILL allocate and free memory, so don't keep pointers to the
 * MultiSz passed in.
 *
 * parameters:
 *   SzToPrepend - string to prepend
 *   MultiSz     - pointer to a MultiSz which will be prepended-to
 */
BOOLEAN
PrependSzToMultiSz(
    IN     LPTSTR  SzToPrepend,
    IN OUT LPTSTR *MultiSz
    )
{
    size_t szLen;
    size_t multiSzLen;
    LPTSTR newMultiSz = NULL;

    ASSERT(SzToPrepend != NULL);
    ASSERT(MultiSz != NULL);

    // get the size, in bytes, of the two buffers
    szLen = (_tcslen(SzToPrepend)+1)*sizeof(_TCHAR);
    multiSzLen = MultiSzLength(*MultiSz)*sizeof(_TCHAR);
    newMultiSz = (LPTSTR)malloc( szLen+multiSzLen );

    if( newMultiSz == NULL )
    {
        return (FALSE);
    }

    // recopy the old MultiSz into proper position into the new buffer.
    // the (char*) cast is necessary, because newMultiSz may be a wchar*, and
    // szLen is in bytes.

    memcpy( ((char*)newMultiSz) + szLen, *MultiSz, multiSzLen );

    // copy in the new string
    _tcscpy( newMultiSz, SzToPrepend );

    free( *MultiSz );
    *MultiSz = newMultiSz;

    return (TRUE);
}


/*
 * returns the length (in characters) of the buffer required to hold this
 * MultiSz, INCLUDING the trailing null.
 *
 * example: MultiSzLength("foo\0bar\0") returns 9
 *
 * note: since MultiSz cannot be null, a number >= 1 will always be returned
 *
 * parameters:
 *   MultiSz - the MultiSz to get the length of
 */
size_t
MultiSzLength(
    IN LPTSTR MultiSz
    )
{
    size_t len = 0;
    size_t totalLen = 0;

    ASSERT( MultiSz != NULL );

    // search for trailing null character
    while( *MultiSz != _T('\0') )
    {
        len = _tcslen(MultiSz)+1;
        MultiSz += len;
        totalLen += len;
    }

    // add one for the trailing null character
    return (totalLen+1);
}


/*
 * Deletes all instances of a string from within a multi-sz.
 *
 * parameters:
 *   FindThis        - the string to find and remove
 *   FindWithin      - the string having the instances removed
 *   NewStringLength - the new string length
 */
size_t
MultiSzSearchAndDeleteCaseInsensitive(
    IN  LPTSTR FindThis,
    IN  LPTSTR FindWithin,
    OUT size_t *NewLength
    )
{
    LPTSTR search;
    size_t currentOffset;
    DWORD  instancesDeleted;
    size_t searchLen;

    ASSERT(FindThis != NULL);
    ASSERT(FindWithin != NULL);
    ASSERT(NewLength != NULL);

    currentOffset = 0;
    instancesDeleted = 0;
    search = FindWithin;

    *NewLength = MultiSzLength(FindWithin);

    // loop while the multisz null terminator is not found
    while ( *search != _T('\0') )
    {
        // length of string + null char; used in more than a couple places
        searchLen = _tcslen(search) + 1;

        // if this string matches the current one in the multisz...
        if( _tcsicmp(search, FindThis) == 0 )
        {
            // they match, shift the contents of the multisz, to overwrite the
            // string (and terminating null), and update the length
            instancesDeleted++;
            *NewLength -= searchLen;
            memmove( search,
                     search + searchLen,
                     (*NewLength - currentOffset) * sizeof(TCHAR) );
        }
        else
        {
            // they don't mactch, so move pointers, increment counters
            currentOffset += searchLen;
            search        += searchLen;
        }
    }

    return (instancesDeleted);
}


/*
 * print usage
 */
void PrintUsage()
{
    printf("usage:\n\n"
           "addfilter"
           " [/listdevices]"
           " [/device device_name]"
           " [/add filter]"
           " [/remove filter]"
           " [/lower]"
           "\n\n");
    printf("If device_name is not supplied, settings will apply "
           "to all devices.\n");
    printf("If there is no /add or /remove argument, a list of currently"
           " installed drivers\n"
           "will be printed.\n");
    printf("The default is to process upper filters.  Use the /lower switch"
           " to process lower filters instead.\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\usbsc\usbscpwr.c ===
#include "usbsc.h"

#include "usbscpwr.h"
#include "usbscnt.h"

NTSTATUS
UsbScDevicePower(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Handles Device Power Irps

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;
    PIO_STACK_LOCATION  stack;
    BOOLEAN             postWaitWake;
    POWER_STATE  state;



    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScDevicePower Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;
        stack = IoGetCurrentIrpStackLocation(Irp);
        state.DeviceState = stack->Parameters.Power.State.DeviceState;

        switch (stack->MinorFunction) {
        case IRP_MN_QUERY_POWER:

            // 
            // Since we can always wait for our irps to complete, so we just always succeed
            //

            IoReleaseRemoveLock(&pDevExt->RemoveLock,
                                Irp);
            PoStartNextPowerIrp(Irp);


            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(pDevExt->LowerDeviceObject,
                                  Irp);



            
            break;

        case IRP_MN_SET_POWER:

            if (state.DeviceState < pDevExt->PowerState) {

                //
                // We are coming up!!  We must let lower drivers power up before we do
                //
                IoMarkIrpPending(Irp);
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       UsbScDevicePowerUpCompletion,
                                       pDevExt,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                status = PoCallDriver(pDevExt->LowerDeviceObject,
                                      Irp);

                status = STATUS_PENDING;

            } else {

                //
                // We are moving to a lower power state, so we handle it before
                // passing it down
                //

                status = UsbScSetDevicePowerState(DeviceObject,
                                                  state.DeviceState,
                                                  &postWaitWake);
                

                PoSetPowerState(DeviceObject,
                                DevicePowerState,
                                state);


                IoReleaseRemoveLock(&pDevExt->RemoveLock,
                                    Irp);
                PoStartNextPowerIrp(Irp);
                IoSkipCurrentIrpStackLocation(Irp);

                status = PoCallDriver(pDevExt->LowerDeviceObject,
                                      Irp);

            }
            break;
        default:
            // We shouldn't be here
            ASSERT(FALSE);
            break;
        }

        

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScDevicePower Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;


}

NTSTATUS
UsbScSystemPower(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
/*++

Routine Description:
    Handles system power irps

Arguments:

Return Value:

--*/
{

    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSystemPower Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;


        IoMarkIrpPending(Irp);
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               UsbScSystemPowerCompletion,
                               pDevExt,
                               TRUE,
                               TRUE,
                               TRUE);

        status = PoCallDriver(pDevExt->LowerDeviceObject,
                              Irp);

        status = STATUS_PENDING;



    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSystemPower Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;


}

NTSTATUS
UsbScSystemPowerCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    )
/*++

Routine Description:
    Completion routine called after system power irp has been passed down the stack.
    handles mapping system state to device state and requests the device power irp.

Arguments:

Return Value:

--*/
{

    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;
    PIO_STACK_LOCATION  irpStack;
    POWER_STATE         state;
    POWER_STATE         systemState;


    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSystemPowerCompletion Enter\n",DRIVER_NAME ));
        pDevExt = (PDEVICE_EXTENSION) Context;

        if (!NT_SUCCESS(Irp->IoStatus.Status)) {
            SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSystemPowerCompletion SIRP failed by lower driver\n",DRIVER_NAME ));

            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp,
                              IO_NO_INCREMENT);
            status = Irp->IoStatus.Status;
            IoReleaseRemoveLock(&pDevExt->RemoveLock,
                                Irp);
            __leave;
        }

        irpStack = IoGetCurrentIrpStackLocation(Irp);

        systemState = irpStack->Parameters.Power.State;
        state.DeviceState = pDevExt->DeviceCapabilities.DeviceState[systemState.SystemState];

        status = PoRequestPowerIrp(DeviceObject,
                                   irpStack->MinorFunction,
                                   state,
                                   UsbScDeviceRequestCompletion,
                                   (PVOID) Irp,
                                   NULL);

        ASSERT(NT_SUCCESS(status));

        status = STATUS_MORE_PROCESSING_REQUIRED;


    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScSystemPowerCompletion Exit : 0x%x\n",DRIVER_NAME, status ));


    }

    return status;

}



VOID
UsbScDeviceRequestCompletion(
    PDEVICE_OBJECT  DeviceObject,
    UCHAR           MinorFunction,
    POWER_STATE     PowerState,
    PVOID           Context,
    PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:
    Completion routine called after device power irp completes.
    Completes the system power irp.

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;
    PIRP                irp;

    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScDeviceRequestCompletion Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;
        irp = (PIRP) Context;

        PoStartNextPowerIrp(irp);
        irp->IoStatus.Status = IoStatus->Status;
        IoCompleteRequest(irp,
                          IO_NO_INCREMENT);

        IoReleaseRemoveLock(&pDevExt->RemoveLock,
                            irp);

    }

    __finally
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScDeviceRequestCompletion Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return;


}


NTSTATUS
UsbScDevicePowerUpCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    )
/*++

Routine Description:
    Completion routine called after device irp for higher power state has been
    passed down the stack.

Arguments:

Return Value:

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;
    PIO_STACK_LOCATION  irpStack;
    BOOLEAN             postWaitWake; // We don't really care about this



    __try
    {

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScDevicePowerUpCompletion Enter\n",DRIVER_NAME ));

        pDevExt = DeviceObject->DeviceExtension;
        
        irpStack = IoGetCurrentIrpStackLocation(Irp);


        status = UsbScSetDevicePowerState(DeviceObject,
                                          irpStack->Parameters.Power.State.DeviceState,
                                          &postWaitWake);

        PoSetPowerState(DeviceObject,
                        DevicePowerState,
                        irpStack->Parameters.Power.State);

        PoStartNextPowerIrp(Irp);
 
    }

    __finally
    {

        IoReleaseRemoveLock(&pDevExt->RemoveLock,
                            Irp);

        SmartcardDebug( DEBUG_TRACE, ("%s!UsbScDevicePowerUpCompletion Exit : 0x%x\n",DRIVER_NAME, status ));

    }

    return status;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\cdrom\cdrom.c ===
/*--

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    cdrom.c

Abstract:

    The CDROM class driver tranlates IRPs to SRBs with embedded CDBs
    and sends them to its devices through the port driver.

Environment:

    kernel mode only

Notes:

    SCSI Tape, CDRom and Disk class drivers share common routines
    that can be found in the CLASS directory (..\ntos\dd\class).

Revision History:

--*/

#include "stddef.h"
#include "string.h"

#include "ntddk.h"

#include "ntddcdvd.h"
#include "classpnp.h"

#include "initguid.h"
#include "ntddstor.h"
#include "cdrom.h"

#include "cdrom.tmh"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, CdRomUnload)
#pragma alloc_text(PAGE, CdRomAddDevice)
#pragma alloc_text(PAGE, CdRomCreateDeviceObject)
#pragma alloc_text(PAGE, CdRomStartDevice)
#pragma alloc_text(PAGE, ScanForSpecial)
#pragma alloc_text(PAGE, ScanForSpecialHandler)
#pragma alloc_text(PAGE, CdRomRemoveDevice)
#pragma alloc_text(PAGE, CdRomGetDeviceType)
#pragma alloc_text(PAGE, CdRomReadWriteVerification)
#pragma alloc_text(PAGE, CdRomGetDeviceParameter)
#pragma alloc_text(PAGE, CdRomSetDeviceParameter)
#pragma alloc_text(PAGE, CdRomPickDvdRegion)
#pragma alloc_text(PAGE, CdRomIsPlayActive)

#pragma alloc_text(PAGEHITA, HitachiProcessError)
#pragma alloc_text(PAGEHIT2, HitachiProcessErrorGD2000)

#pragma alloc_text(PAGETOSH, ToshibaProcessErrorCompletion)
#pragma alloc_text(PAGETOSH, ToshibaProcessError)

#endif

#define IS_WRITE_REQUEST(irpStack)                                             \
 (irpStack->MajorFunction == IRP_MJ_WRITE)

#define IS_READ_WRITE_REQUEST(irpStack)                                        \
((irpStack->MajorFunction == IRP_MJ_READ)  ||                                  \
 (irpStack->MajorFunction == IRP_MJ_WRITE) ||                                  \
 ((irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL) &&                        \
  (irpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_RAW_READ)))




NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the cdrom class driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the name of the services node for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    CLASS_INIT_DATA InitializationData = {0};
    PCDROM_DRIVER_EXTENSION driverExtension;
    NTSTATUS status;

    PAGED_CODE();

    WPP_INIT_TRACING(DriverObject, RegistryPath);

    TraceLog((CdromDebugTrace,
                "CDROM.SYS DriverObject %p loading\n", DriverObject));

    status = IoAllocateDriverObjectExtension(DriverObject,
                                             CDROM_DRIVER_EXTENSION_ID,
                                             sizeof(CDROM_DRIVER_EXTENSION),
                                             &driverExtension);

    if (!NT_SUCCESS(status)) {
        TraceLog((CdromDebugWarning,
                    "DriverEntry !! no DriverObjectExtension %x\n", status));
        return status;
    }

    //
    // always zero the memory, since we are now reloading the driver.
    //

    RtlZeroMemory(driverExtension, sizeof(CDROM_DRIVER_EXTENSION));

    //
    // Zero InitData
    //

    RtlZeroMemory (&InitializationData, sizeof(CLASS_INIT_DATA));

    //
    // Set sizes
    //

    InitializationData.InitializationDataSize = sizeof(CLASS_INIT_DATA);

    InitializationData.FdoData.DeviceExtensionSize = DEVICE_EXTENSION_SIZE;

    InitializationData.FdoData.DeviceType = FILE_DEVICE_CD_ROM;
    InitializationData.FdoData.DeviceCharacteristics =
        FILE_REMOVABLE_MEDIA | FILE_DEVICE_SECURE_OPEN;

    //
    // Set entry points
    //

    InitializationData.FdoData.ClassError = CdRomErrorHandler;
    InitializationData.FdoData.ClassInitDevice = CdRomInitDevice;
    InitializationData.FdoData.ClassStartDevice = CdRomStartDevice;
    InitializationData.FdoData.ClassStopDevice = CdRomStopDevice;
    InitializationData.FdoData.ClassRemoveDevice = CdRomRemoveDevice;

    InitializationData.FdoData.ClassReadWriteVerification = CdRomReadWriteVerification;
    InitializationData.FdoData.ClassDeviceControl = CdRomDeviceControlDispatch;

    InitializationData.FdoData.ClassPowerDevice = ClassSpinDownPowerHandler;
    InitializationData.FdoData.ClassShutdownFlush = CdRomShutdownFlush;
    InitializationData.FdoData.ClassCreateClose = NULL;

    InitializationData.ClassStartIo = CdRomStartIo;
    InitializationData.ClassAddDevice = CdRomAddDevice;

    InitializationData.ClassTick = CdRomTickHandler;
    InitializationData.ClassUnload = CdRomUnload;

    //
    // Call the class init routine
    //

    return ClassInitialize( DriverObject, RegistryPath, &InitializationData);

} // end DriverEntry()


VOID
CdRomUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DriverObject);
    TraceLog((CdromDebugTrace,
                "CDROM.SYS DriverObject %p unloading\n", DriverObject));
    WPP_CLEANUP(DriverObject);
    return;
} // end CdRomUnload()


NTSTATUS
CdRomAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.  It may perform property queries on the FDO but cannot do any
    media access operations.

Arguments:

    DriverObject - CDROM class driver object.

    Pdo - the physical device object we are being added to

Return Value:

    status

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Get the address of the count of the number of cdroms already initialized.
    //

    status = CdRomCreateDeviceObject(DriverObject,
                                     PhysicalDeviceObject);

    //
    // Note: this always increments driver extension counter
    //       it will eventually wrap, and fail additions
    //       if an existing cdrom has the given number.
    //       so unlikely that we won't even bother considering
    //       this case, since the cure is quite likely worse
    //       than the symptoms.
    //

    if(NT_SUCCESS(status)) {

        //
        // keep track of the total number of active cdroms in IoGet(),
        // as some programs use this to determine when they have found
        // all the cdroms in the system.
        //

        TraceLog((CdromDebugTrace, "CDROM.SYS Add succeeded\n"));
        IoGetConfigurationInformation()->CdRomCount++;

    } else {

        TraceLog((CdromDebugWarning,
                    "CDROM.SYS Add failed! %x\n", status));

    }

    return status;
}


NTSTATUS
CdRomCreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates an object for the device and then calls the
    SCSI port driver for media capacity and sector size.

Arguments:

    DriverObject - Pointer to driver object created by system.
    PortDeviceObject - to connect to SCSI port driver.
    DeviceCount - Number of previously installed CDROMs.
    PortCapabilities - Pointer to structure returned by SCSI port
        driver describing adapter capabilites (and limitations).
    LunInfo - Pointer to configuration information for this device.

Return Value:

    NTSTATUS

--*/
{
    UCHAR ntNameBuffer[64] = {0};
    STRING ntNameString = {0};
    NTSTATUS status;

    PDEVICE_OBJECT lowerDevice = NULL;
    PDEVICE_OBJECT deviceObject = NULL;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = NULL;
    PCDROM_DATA cdData = NULL;
    PCDROM_DRIVER_EXTENSION driverExtension = NULL;
    ULONG deviceNumber;

    CCHAR                   dosNameBuffer[64] = {0};
    CCHAR                   deviceNameBuffer[64] = {0};
    STRING                  deviceNameString = {0};
    STRING                  dosString = {0};
    UNICODE_STRING          dosUnicodeString = {0};
    UNICODE_STRING          unicodeString = {0};

    PAGED_CODE();

    //
    // Claim the device. Note that any errors after this
    // will goto the generic handler, where the device will
    // be released.
    //

    lowerDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);

    status = ClassClaimDevice(lowerDevice, FALSE);

    if(!NT_SUCCESS(status)) {

        //
        // Someone already had this device - we're in trouble
        //

        ObDereferenceObject(lowerDevice);
        return status;
    }

    //
    // Create device object for this device by first getting a unique name
    // for the device and then creating it.
    //

    driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                 CDROM_DRIVER_EXTENSION_ID);
    ASSERT(driverExtension != NULL);

    //
    // InterlockedCdRomCounter is biased by 1.
    //

    deviceNumber = InterlockedIncrement(&driverExtension->InterlockedCdRomCounter) - 1;
    sprintf(ntNameBuffer, "\\Device\\CdRom%d", deviceNumber);


    status = ClassCreateDeviceObject(DriverObject,
                                     ntNameBuffer,
                                     PhysicalDeviceObject,
                                     TRUE,
                                     &deviceObject);

    if (!NT_SUCCESS(status)) {
        TraceLog((CdromDebugWarning,
                    "CreateCdRomDeviceObjects: Can not create device %s\n",
                    ntNameBuffer));

        goto CreateCdRomDeviceObjectExit;
    }

    //
    // Indicate that IRPs should include MDLs.
    //

    SET_FLAG(deviceObject->Flags, DO_DIRECT_IO);

    fdoExtension = deviceObject->DeviceExtension;

    //
    // Back pointer to device object.
    //

    fdoExtension->CommonExtension.DeviceObject = deviceObject;

    //
    // This is the physical device.
    //

    fdoExtension->CommonExtension.PartitionZeroExtension = fdoExtension;

    //
    // Initialize lock count to zero. The lock count is used to
    // disable the ejection mechanism when media is mounted.
    //

    fdoExtension->LockCount = 0;

    //
    // Save system cdrom number
    //

    fdoExtension->DeviceNumber = deviceNumber;

    //
    // Set the alignment requirements for the device based on the
    // host adapter requirements
    //

    if (lowerDevice->AlignmentRequirement > deviceObject->AlignmentRequirement) {
        deviceObject->AlignmentRequirement = lowerDevice->AlignmentRequirement;
    }

    //
    // Save the device descriptors
    //

    fdoExtension->AdapterDescriptor = NULL;

    fdoExtension->DeviceDescriptor = NULL;

    //
    // Clear the SrbFlags and disable synchronous transfers
    //

    fdoExtension->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Finally, attach to the PDO
    //

    fdoExtension->LowerPdo = PhysicalDeviceObject;

    fdoExtension->CommonExtension.LowerDeviceObject =
        IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

    if(fdoExtension->CommonExtension.LowerDeviceObject == NULL) {

        //
        // Uh - oh, we couldn't attach
        // cleanup and return
        //

        status = STATUS_UNSUCCESSFUL;
        goto CreateCdRomDeviceObjectExit;
    }

    //
    // CdRom uses an extra stack location for synchronizing it's start io
    // routine
    //

    deviceObject->StackSize++;

    //
    // cdData is used a few times below
    //

    cdData = fdoExtension->CommonExtension.DriverData;

    //
    // For NTMS to be able to easily determine drives-drv. letter matches.
    //

    status = CdRomCreateWellKnownName( deviceObject );

    if (!NT_SUCCESS(status)) {
        TraceLog((CdromDebugWarning,
                    "CdromCreateDeviceObjects: unable to create symbolic "
                    "link for device %wZ\n", &fdoExtension->CommonExtension.DeviceName));
        TraceLog((CdromDebugWarning,
                    "CdromCreateDeviceObjects: (non-fatal error)\n"));
    }

    ClassUpdateInformationInRegistry(deviceObject, "CdRom",
                                     fdoExtension->DeviceNumber, NULL, 0);

    //
    // from above IoGetAttachedDeviceReference
    //

    ObDereferenceObject(lowerDevice);

    //
    // need to init timerlist here in case a remove occurs
    // without a start, since we check the list is empty on remove.
    //

    cdData->DelayedRetryIrp = NULL;
    cdData->DelayedRetryInterval = 0;

    //
    // need this to be initialized for RPC Phase 1 drives (rpc0)
    //

    KeInitializeMutex(&cdData->Rpc0RegionMutex, 0);

    //
    // The device is initialized properly - mark it as such.
    //

    CLEAR_FLAG(deviceObject->Flags, DO_DEVICE_INITIALIZING);

    return(STATUS_SUCCESS);

CreateCdRomDeviceObjectExit:

    //
    // Release the device since an error occured.
    //

    // ClassClaimDevice(PortDeviceObject,
    //                      LunInfo,
    //                      TRUE,
    //                      NULL);

    //
    // from above IoGetAttachedDeviceReference
    //

    ObDereferenceObject(lowerDevice);

    if (deviceObject != NULL) {
        IoDeleteDevice(deviceObject);
    }

    return status;

} // end CreateCdRomDeviceObject()


NTSTATUS
CdRomInitDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will complete the cd-rom initialization.  This includes
    allocating sense info buffers and srb s-lists, reading drive capacity
    and setting up Media Change Notification (autorun).

    This routine will not clean up allocate resources if it fails - that
    is left for device stop/removal

Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCLASS_DRIVER_EXTENSION driverExtension = ClassGetDriverExtension(
                                                Fdo->DriverObject);

    PVOID senseData = NULL;

    ULONG timeOut;
    PCDROM_DATA cddata = (PCDROM_DATA)(commonExtension->DriverData);

    BOOLEAN changerDevice;
    BOOLEAN isMmcDevice = FALSE;

    ULONG bps;
    ULONG lastBit;


    NTSTATUS status;

    PAGED_CODE();

    //
    // Build the lookaside list for srb's for the physical disk.  Should only
    // need a couple.
    //

    ClassInitializeSrbLookasideList(&(fdoExtension->CommonExtension),
                                    CDROM_SRB_LIST_SIZE);

    //
    // Allocate request sense buffer.
    //

    senseData = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                      SENSE_BUFFER_SIZE,
                                      CDROM_TAG_SENSE_INFO);

    if (senseData == NULL) {

        //
        // The buffer cannot be allocated.
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CdRomInitDeviceExit;
    }

    //
    // Set the sense data pointer in the device extension.
    //

    fdoExtension->SenseData = senseData;

    //
    // CDROMs are not partitionable so starting offset is 0.
    //

    commonExtension->StartingOffset.LowPart = 0;
    commonExtension->StartingOffset.HighPart = 0;

    //
    // Set timeout value in seconds.
    //

    timeOut = ClassQueryTimeOutRegistryValue(Fdo);
    if ((timeOut != 0) && (timeOut <= 30 * 60)) { // 30 minutes
        fdoExtension->TimeOutValue = timeOut;
    } else {
        fdoExtension->TimeOutValue = SCSI_CDROM_TIMEOUT;
    }

    //
    // Set up media change support defaults.
    //

    KeInitializeSpinLock(&cddata->DelayedRetrySpinLock);

    cddata->DelayedRetryIrp = NULL;
    cddata->DelayedRetryInterval = 0;
    cddata->Mmc.WriteAllowed = FALSE;

    //
    // Scan for  controllers that require special processing.
    //

    ScanForSpecial(Fdo);

    //
    // Determine if the drive is MMC-Capable
    //

    CdRomIsDeviceMmcDevice(Fdo, &isMmcDevice);

    if (!isMmcDevice) {

        SET_FLAG(Fdo->Characteristics, FILE_READ_ONLY_DEVICE);

    } else {

        //
        // the drive supports at least a subset of MMC commands
        // (and therefore supports READ_CD, etc...)
        //

        cddata->Mmc.IsMmc = TRUE;

        //
        // allocate a buffer for all the capabilities and such
        //

        status = CdRomAllocateMmcResources(Fdo);
        if (!NT_SUCCESS(status)) {
            goto CdRomInitDeviceExit;
        }

        //
        // if the drive supports target defect management and sector-addressable
        // writes, then we should allow writes to the media.
        //

        if (CdRomFindFeaturePage(cddata->Mmc.CapabilitiesBuffer,
                                 cddata->Mmc.CapabilitiesBufferSize,
                                 FeatureDefectManagement) &&
            CdRomFindFeaturePage(cddata->Mmc.CapabilitiesBuffer,
                                 cddata->Mmc.CapabilitiesBufferSize,
                                 FeatureRandomWritable)) {

            //
            // the drive is target defect managed, and supports random writes
            // on sector-aligment.  allow writes to occur by setting the error
            // handler to point to a private media change detection handler.
            //

            KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                       "Found a WRITE capable device: %p\n", Fdo));

            //
            // the write specific pages have been found --
            // set the error handler and set it to require an update!
            //

            cddata->Mmc.UpdateState = CdromMmcUpdateRequired;
            cddata->ErrorHandler = CdRomMmcErrorHandler;

        }

        //
        // ISSUE-2000/4/4-henrygab - mmc-compliant compliant drives should
        //                           be initialized based upon reported
        //                           capabilities, such as CSS, Analogue Audio,
        //                           READ_CD capabilities, and (possibly) even
        //                           drive capacity information.
        //

        TraceLog((CdromDebugWarning,
                  "Defaulting to READ_CD because device %p is MMC compliant\n",
                  Fdo));
        SET_FLAG(fdoExtension->DeviceFlags, DEV_SAFE_START_UNIT);
        SET_FLAG(cddata->XAFlags, XA_USE_READ_CD);

    }


    //
    // Set the default geometry for the cdrom to match what NT 4 used.
    // Classpnp will use these values to compute the cylinder count rather
    // than using it's NT 5.0 defaults.
    //

    fdoExtension->DiskGeometry.TracksPerCylinder = 0x40;
    fdoExtension->DiskGeometry.SectorsPerTrack = 0x20;

    //
    // Do READ CAPACITY. This SCSI command returns the last sector address
    // on the device and the bytes per sector. These are used to calculate
    // the drive capacity in bytes.
    //
    // NOTE: This should be change to send the Srb synchronously, then
    // call CdRomInterpretReadCapacity() to properly setup the defaults.
    //

    status = ClassReadDriveCapacity(Fdo);

    bps = fdoExtension->DiskGeometry.BytesPerSector;

    if (!NT_SUCCESS(status) || !bps) {

        TraceLog((CdromDebugWarning,
                    "CdRomStartDevice: Can't read capacity for device %wZ\n",
                    &(fdoExtension->CommonExtension.DeviceName)));

        //
        // Set disk geometry to default values (per ISO 9660).
        //

        bps = 2048;
        fdoExtension->SectorShift = 11;
        commonExtension->PartitionLength.QuadPart = (LONGLONG)(0x7fffffff);

    } else {

        //
        // Insure that bytes per sector is a power of 2
        // This corrects a problem with the HP 4020i CDR where it
        // returns an incorrect number for bytes per sector.
        //

        lastBit = (ULONG) -1;
        while (bps) {
            lastBit++;
            bps = bps >> 1;
        }

        bps = 1 << lastBit;
    }
    fdoExtension->DiskGeometry.BytesPerSector = bps;
    TraceLog((CdromDebugTrace, "CdRomInitDevice: Calc'd bps = %x\n", bps));


    ClassInitializeMediaChangeDetection(fdoExtension, "CdRom");


    //
    // test for audio read capabilities
    //

    TraceLog((CdromDebugWarning,
              "Detecting XA_READ capabilities\n"));

    if (CdRomGetDeviceType(Fdo) == FILE_DEVICE_DVD) {

        TraceLog((CdromDebugWarning,
                    "CdRomInitDevice: DVD Devices require START_UNIT\n"));


        //
        // all DVD devices must support the READ_CD command
        //

        TraceLog((CdromDebugWarning,
                    "CdRomDetermineRawReadCapabilities: DVD devices "
                    "support READ_CD command for FDO %p\n", Fdo));
        SET_FLAG(fdoExtension->DeviceFlags, DEV_SAFE_START_UNIT);
        SET_FLAG(cddata->XAFlags, XA_USE_READ_CD);


        status = STATUS_SUCCESS;

    } else if ((fdoExtension->DeviceDescriptor->BusType != BusTypeScsi)  &&
               (fdoExtension->DeviceDescriptor->BusType != BusTypeAta)   &&
               (fdoExtension->DeviceDescriptor->BusType != BusTypeAtapi) &&
               (fdoExtension->DeviceDescriptor->BusType != BusTypeUnknown)
               ) {

        //
        // devices on the newer busses must support READ_CD command
        //

        TraceLog((CdromDebugWarning,
                  "CdRomDetermineRawReadCapabilities: Devices for newer "
                  "busses must support READ_CD command for FDO %p, Bus %x\n",
                  Fdo, fdoExtension->DeviceDescriptor->BusType));
        SET_FLAG(fdoExtension->DeviceFlags, DEV_SAFE_START_UNIT);
        SET_FLAG(cddata->XAFlags, XA_USE_READ_CD);

    }

    //
    // now clear all our READ_CD flags if the drive should have supported
    // it, but we are not sure it actually does.  we still won't query
    // the drive more than one time if it supports the command.
    //

    if (TEST_FLAG(cddata->HackFlags, CDROM_HACK_FORCE_READ_CD_DETECTION)) {

        TraceLog((CdromDebugWarning,
                  "Forcing detection of READ_CD for FDO %p because "
                  "testing showed some firmware did not properly support it\n",
                  Fdo));
        CLEAR_FLAG(cddata->XAFlags, XA_USE_READ_CD);

    }


    //
    // read our READ_CD support in the registry if it was seeded.
    //
    {
        ULONG readCdSupported = 0;

        ClassGetDeviceParameter(fdoExtension,
                                CDROM_SUBKEY_NAME,
                                CDROM_READ_CD_NAME,
                                &readCdSupported
                                );

        if (readCdSupported != 0) {

            TraceLog((CdromDebugWarning,
                      "Defaulting to READ_CD because previously detected "
                      "that the device supports it for Fdo %p.\n",
                      Fdo
                      ));
            SET_FLAG(cddata->XAFlags, XA_USE_READ_CD);

        }

    }


    //
    // backwards-compatible attempt to determine if the drive
    // supports any method of reading digital audio from the disc.
    //
    // NOTE: Deprecate this; remove this check in longhorn and
    //       always use READ_CD.

    if (!TEST_FLAG(cddata->XAFlags, XA_USE_READ_CD)) {

        SCSI_REQUEST_BLOCK srb = {0};
        PCDB cdb;
        ULONG length;
        PUCHAR buffer = NULL;
        ULONG count;

        //
        // ISSUE-2000/07/05-henrygab - use the mode page to determine
        //          READ_CD support, then fall back on the below
        //          method, which may not always detect this ability
        //          on older (pre-1999) drives.
        //

        //
        // Build the MODE SENSE CDB. The data returned will be kept in the
        // device extension and used to set block size.
        //

        length = max(sizeof(ERROR_RECOVERY_DATA),sizeof(ERROR_RECOVERY_DATA10));

        buffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                       length,
                                       CDROM_TAG_MODE_DATA);

        if (!buffer) {
            TraceLog((CdromDebugWarning,
                        "CdRomDetermineRawReadCapabilities: cannot allocate "
                        "buffer, so leaving for FDO %p\n", Fdo));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto CdRomInitDeviceExit;
        }

        for (count = 0; count < 2; count++) {

            if (count == 0) {
                length = sizeof(ERROR_RECOVERY_DATA);
            } else {
                length = sizeof(ERROR_RECOVERY_DATA10);
            }

            RtlZeroMemory(buffer, length);
            RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));
            cdb = (PCDB)srb.Cdb;

            srb.TimeOutValue = fdoExtension->TimeOutValue;

            if (count == 0) {
                srb.CdbLength = 6;
                cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                cdb->MODE_SENSE.PageCode = 0x1;
                // note: not setting DBD in order to get the block descriptor!
                cdb->MODE_SENSE.AllocationLength = (UCHAR)length;
            } else {
                srb.CdbLength = 10;
                cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
                cdb->MODE_SENSE10.PageCode = 0x1;
                // note: not setting DBD in order to get the block descriptor!
                cdb->MODE_SENSE10.AllocationLength[0] = (UCHAR)(length >> 8);
                cdb->MODE_SENSE10.AllocationLength[1] = (UCHAR)(length & 0xFF);
            }

            status = ClassSendSrbSynchronous(Fdo,
                                             &srb,
                                             buffer,
                                             length,
                                             FALSE);


            if (NT_SUCCESS(status) || (status == STATUS_DATA_OVERRUN)) {

                //
                // STATUS_DATA_OVERRUN means it's a newer drive with more info
                // to tell us, so it's probably able to support READ_CD
                //

                RtlZeroMemory(cdb, CDB12GENERIC_LENGTH);

                srb.CdbLength = 12;
                cdb->READ_CD.OperationCode = SCSIOP_READ_CD;

                status = ClassSendSrbSynchronous(Fdo,
                                                 &srb,
                                                 NULL,
                                                 0,
                                                 FALSE);

                if (NT_SUCCESS(status) ||
                    (status == STATUS_NO_MEDIA_IN_DEVICE) ||
                    (status == STATUS_NONEXISTENT_SECTOR) ||
                    (status == STATUS_UNRECOGNIZED_MEDIA)
                    ) {

                    //
                    // READ_CD works
                    //

                    TraceLog((CdromDebugWarning,
                              "CdRomDetermineRawReadCapabilities: Using "
                              "READ_CD for FDO %p due to status %x\n",
                              Fdo,
                              status));
                    SET_FLAG(cddata->XAFlags, XA_USE_READ_CD);

                    //
                    // ignore errors in saving this info
                    //

                    ClassSetDeviceParameter(fdoExtension,
                                            CDROM_SUBKEY_NAME,
                                            CDROM_READ_CD_NAME,
                                            1
                                            );


                    break; // out of the for loop

                }

                TraceLog((CdromDebugWarning,
                            "CdRomDetermineRawReadCapabilities: Using "
                            "%s-byte mode switching for FDO %p due to status "
                            "%x returned for READ_CD\n",
                            ((count == 0) ? "6" : "10"), Fdo, status));

                if (count == 0) {
                    SET_FLAG(cddata->XAFlags, XA_USE_6_BYTE);
                    RtlCopyMemory(&cddata->Header,
                                  buffer,
                                  sizeof(ERROR_RECOVERY_DATA));
                    cddata->Header.ModeDataLength = 0;
                } else {
                    SET_FLAG(cddata->XAFlags, XA_USE_10_BYTE);
                    RtlCopyMemory(&cddata->Header10,
                                  buffer,
                                  sizeof(ERROR_RECOVERY_DATA10));
                    cddata->Header10.ModeDataLength[0] = 0;
                    cddata->Header10.ModeDataLength[1] = 0;
                }
                break;  // out of for loop

            }
            TraceLog((CdromDebugWarning,
                      "FDO %p failed %x byte mode sense, status %x\n",
                      Fdo,
                      ((count == 0) ? 6 : 10),
                      status
                      ));

            //
            // mode sense failed
            //

        } // end of for loop to try 6 and 10-byte mode sense

        if (count == 2) {

            //
            // nothing worked.  we probably cannot support digital
            // audio extraction from this drive
            //

            TraceLog((CdromDebugWarning,
                        "CdRomDetermineRawReadCapabilities: FDO %p "
                        "cannot support READ_CD\n", Fdo));
            CLEAR_FLAG(cddata->XAFlags, XA_PLEXTOR_CDDA);
            CLEAR_FLAG(cddata->XAFlags, XA_NEC_CDDA);
            SET_FLAG(cddata->XAFlags, XA_NOT_SUPPORTED);

        } // end of count == 2

        //
        // free our resources
        //

        ExFreePool(buffer);

        //
        // set a successful status
        // (in case someone later checks this)
        //

        status = STATUS_SUCCESS;

    }

    //
    // Register interfaces for this device.
    //

    {
        UNICODE_STRING interfaceName = {0};

        RtlInitUnicodeString(&interfaceName, NULL);

        status = IoRegisterDeviceInterface(fdoExtension->LowerPdo,
                                           (LPGUID) &CdRomClassGuid,
                                           NULL,
                                           &interfaceName);

        if(NT_SUCCESS(status)) {

            cddata->CdromInterfaceString = interfaceName;

            status = IoSetDeviceInterfaceState(
                        &interfaceName,
                        TRUE);

            if(!NT_SUCCESS(status)) {

                TraceLog((CdromDebugWarning,
                            "CdromInitDevice: Unable to register cdrom "
                            "DCA for fdo %p [%lx]\n",
                            Fdo, status));
            }
        }
    }

    return(STATUS_SUCCESS);

CdRomInitDeviceExit:

    CdRomDeAllocateMmcResources(Fdo);
    RtlZeroMemory(&(cddata->Mmc), sizeof(CDROM_MMC_EXTENSION));

    return status;

}


NTSTATUS
CdRomStartDevice(
    IN PDEVICE_OBJECT Fdo
    )
/*++

Routine Description:

    This routine starts the timer for the cdrom

Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cddata = (PCDROM_DATA)(commonExtension->DriverData);
    PDVD_COPY_PROTECT_KEY copyProtectKey;
    PDVD_RPC_KEY rpcKey;
    IO_STATUS_BLOCK ioStatus = {0};
    ULONG bufferLen;

    //
    // if we have a DVD-ROM
    //    if we have a rpc0 device
    //        fake a rpc2 device
    //    if device does not have a dvd region set
    //        select a dvd region for the user
    //

    cddata->DvdRpc0Device = FALSE;

    //
    // since StartIo() will call IoStartNextPacket() on error, allowing
    // StartIo() to be non-recursive prevents stack overflow bugchecks in
    // severe error cases (such as fault-injection in the verifier).
    //
    // the only difference is that the thread context may be different
    // in StartIo() than in the caller of IoStartNextPacket().
    //

    IoSetStartIoAttributes(Fdo, TRUE, TRUE);

    //
    // check to see if we have a DVD device
    //

    if (CdRomGetDeviceType(Fdo) != FILE_DEVICE_DVD) {
        return STATUS_SUCCESS;
    }

    //
    // we got a DVD drive.
    // now, figure out if we have a RPC0 device
    //

    bufferLen = DVD_RPC_KEY_LENGTH;
    copyProtectKey =
        (PDVD_COPY_PROTECT_KEY)ExAllocatePoolWithTag(PagedPool,
                                                     bufferLen,
                                                     DVD_TAG_RPC2_CHECK);

    if (copyProtectKey == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // get the device region
    //
    RtlZeroMemory (copyProtectKey, bufferLen);
    copyProtectKey->KeyLength = DVD_RPC_KEY_LENGTH;
    copyProtectKey->KeyType = DvdGetRpcKey;

    //
    // Build a request for READ_KEY
    //
    ClassSendDeviceIoControlSynchronous(
        IOCTL_DVD_READ_KEY,
        Fdo,
        copyProtectKey,
        DVD_RPC_KEY_LENGTH,
        DVD_RPC_KEY_LENGTH,
        FALSE,
        &ioStatus
        );

    if (!NT_SUCCESS(ioStatus.Status)) {

        //
        // we have a rpc0 device
        //
        // NOTE: THIS MODIFIES THE BEHAVIOR OF THE IOCTL
        //

        cddata->DvdRpc0Device = TRUE;

        TraceLog((CdromDebugWarning,
                    "CdromStartDevice (%p): RPC Phase 1 drive detected\n",
                    Fdo));

        //
        // note: we could force this chosen now, but it's better to reduce
        // the number of code paths that could be taken.  always delay to
        // increase the percentage code coverage.
        //

        TraceLog((CdromDebugWarning,
                  "CdromStartDevice (%p): Delay DVD Region Selection\n",
                  Fdo));

        cddata->Rpc0SystemRegion           = 0xff;
        cddata->Rpc0SystemRegionResetCount = DVD_MAX_REGION_RESET_COUNT;
        cddata->PickDvdRegion              = 1;
        cddata->Rpc0RetryRegistryCallback  = 1;
        ExFreePool(copyProtectKey);
        return STATUS_SUCCESS;

    } else {

        rpcKey = (PDVD_RPC_KEY) copyProtectKey->KeyData;

        //
        // TypeCode of zero means that no region has been set.
        //

        if (rpcKey->TypeCode == 0) {
            TraceLog((CdromDebugWarning,
                        "CdromStartDevice (%p): must choose DVD region\n",
                        Fdo));
            cddata->PickDvdRegion = 1;
            CdRomPickDvdRegion(Fdo);
        }
    }

    ExFreePool (copyProtectKey);

    return STATUS_SUCCESS;
}


NTSTATUS
CdRomStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )
{
    return STATUS_SUCCESS;
}


VOID
CdRomStartIo(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION  currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION  nextIrpStack = IoGetNextIrpStackLocation(Irp);
    PIO_STACK_LOCATION  irpStack;
    PIRP                irp2 = NULL;
    ULONG               transferPages;
    ULONG               transferByteCount = currentIrpStack->Parameters.Read.Length;
    LARGE_INTEGER       startingOffset = currentIrpStack->Parameters.Read.ByteOffset;
    PCDROM_DATA         cdData;
    PSCSI_REQUEST_BLOCK srb = NULL;
    PCDB                cdb;
    PUCHAR              senseBuffer = NULL;
    PVOID               dataBuffer;
    NTSTATUS            status;
    BOOLEAN             use6Byte;
    KIRQL oldIrql;

    //
    // Mark IRP with status pending.
    //

    IoMarkIrpPending(Irp);

    cdData = (PCDROM_DATA)(fdoExtension->CommonExtension.DriverData);
    use6Byte = TEST_FLAG(cdData->XAFlags, XA_USE_6_BYTE);

    //
    // if this test is true, then we will exit the routine within this
    // code block, queueing the irp for later completion.
    //

    if ((cdData->Mmc.IsMmc) &&
        (cdData->Mmc.UpdateState != CdromMmcUpdateComplete)
        ) {

        ULONG queueDepth;
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdRomStartIo: [%p] Device needs to update capabilities\n",
                   Irp));
        ASSERT(cdData->Mmc.IsMmc);
        ASSERT(cdData->Mmc.CapabilitiesIrp != NULL);
        ASSERT(cdData->Mmc.CapabilitiesIrp != Irp);

        //
        // NOTE - REF #0002
        //
        // the state was either UpdateRequired (which means we will
        // have to start the work item) or UpdateStarted (which means
        // we have already started the work item at least once -- may
        // transparently change to UpdateComplete).
        //
        // if it's update required, we just queue it, change to UpdateStarted,
        // start the workitem, and start the next packet.
        //
        // else, we must queue the item and check the queue depth.  if the
        // queue depth is equal to 1, that means the worker item from the
        // previous attempt has already de-queued the items, so we should
        // call this routine again (retry) as an optimization rather than
        // re-add it this irp to the queue.  since this is tail recursion,
        // it won't take much/any stack to do this.
        //
        // NOTE: This presumes the following items are true:
        //
        // we only add to the list from CdRomStartIo(), which is serialized.
        // we only set to UpdateStarted from CdRomStartIo(), and only if
        //    the state was UpdateRequired.
        // we only set to UpdateRequired from CdRomMmcErrorHandler(), and
        //    only if the state was UpdateComplete.
        // we only set to UpdateComplete from the workitem, and assert the
        //    state was UpdateStarted.
        // we flush the entire queue in one atomic operation in the workitem,
        //    except in the special case described above when we dequeue
        //    the request immediately.
        //
        // order of operations is vitally important: queue, then test the depth
        // this will prevent lost irps.
        //

        KeAcquireSpinLock(&cdData->Mmc.DelayedIrpsLock, &oldIrql);
        InsertTailList(&cdData->Mmc.DelayedIrpsList, &Irp->Tail.Overlay.ListEntry);
        queueDepth = ++cdData->Mmc.NumDelayedIrps;
        KeReleaseSpinLock(&cdData->Mmc.DelayedIrpsLock, oldIrql);

        if (queueDepth == 1) {

            if (cdData->Mmc.UpdateState == CdromMmcUpdateRequired) {
                LONG oldState;

                //
                // should free any old partition list info that
                // we've previously saved away and then start the WorkItem
                //

                oldState = InterlockedExchange(&cdData->Mmc.UpdateState,
                                               CdromMmcUpdateStarted);
                ASSERT(oldState == CdromMmcUpdateRequired);

                IoQueueWorkItem(cdData->Mmc.CapabilitiesWorkItem,
                                CdRomUpdateMmcDriveCapabilities,
                                DelayedWorkQueue,
                                NULL);

            } else {

                //
                // they *just* finished updating, so we should flush the list
                // back onto the StartIo queue and start the next packet.
                //

                CdRompFlushDelayedList(Fdo, &(cdData->Mmc), STATUS_SUCCESS, FALSE);

            }

        }

        //
        // start the next packet so we don't deadlock....
        //

        IoStartNextPacket(Fdo, FALSE);
        return;

    }

    //
    // If the flag is set in the device object
    // force a verify for READ, WRITE and RAW_READ requests
    // Note that ioctls are passed through....
    //

    if (TEST_FLAG(Fdo->Flags, DO_VERIFY_VOLUME) &&
        IS_READ_WRITE_REQUEST(currentIrpStack)) {

        TraceLog((CdromDebugTrace,
                    "CdRomStartIo: [%p] Volume needs verified\n", Irp));

        if (!(currentIrpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME)) {

            if (Irp->Tail.Overlay.Thread) {
                IoSetHardErrorOrVerifyDevice(Irp, Fdo);
            }

            Irp->IoStatus.Status = STATUS_VERIFY_REQUIRED;

            TraceLog((CdromDebugTrace,
                        "CdRomStartIo: [%p] Calling UpdateCapcity - "
                        "ioctl event = %p\n",
                        Irp,
                        nextIrpStack->Parameters.Others.Argument1
                      ));

            //
            // our device control dispatch routine stores an event in the next
            // stack location to signal when startio has completed.  We need to
            // pass this in so that the update capacity completion routine can
            // set it rather than completing the Irp.
            //

            status = CdRomUpdateCapacity(fdoExtension,
                                         Irp,
                                         nextIrpStack->Parameters.Others.Argument1
                                         );

            TraceLog((CdromDebugTrace,
                        "CdRomStartIo: [%p] UpdateCapacity returned %lx\n",
                        Irp, status));
            return;
        }
    }

    //
    // fail writes if they are not allowed...
    //

    if ((currentIrpStack->MajorFunction == IRP_MJ_WRITE) &&
        !(cdData->Mmc.WriteAllowed)) {

        TraceLog((CdromDebugError,
                    "CdRomStartIo: [%p] Device %p failing write request\n",
                    Irp, Fdo));

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        BAIL_OUT(Irp);
        CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
        return;
    }

    if (currentIrpStack->MajorFunction == IRP_MJ_READ ||
        currentIrpStack->MajorFunction == IRP_MJ_WRITE ) {

        ULONG maximumTransferLength = fdoExtension->AdapterDescriptor->MaximumTransferLength;

        //
        // Add partition byte offset to make starting byte relative to
        // beginning of disk.
        //

        currentIrpStack->Parameters.Read.ByteOffset.QuadPart +=
            (fdoExtension->CommonExtension.StartingOffset.QuadPart);

        //
        // Calculate number of pages in this transfer.
        //

        transferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MmGetMdlVirtualAddress(Irp->MdlAddress),
                                                       currentIrpStack->Parameters.Read.Length);

        //
        // Check if request length is greater than the maximum number of
        // bytes that the hardware can transfer.
        //

        if (cdData->RawAccess) {

            //
            // a writable device must be MMC compliant, which supports
            // READ_CD commands.
            //

            ASSERT(currentIrpStack->MajorFunction != IRP_MJ_WRITE);

            ASSERT(!TEST_FLAG(cdData->XAFlags, XA_USE_READ_CD));

            //
            // Fire off a mode select to switch back to cooked sectors.
            //

            irp2 = IoAllocateIrp((CCHAR)(Fdo->StackSize+1), FALSE);

            if (!irp2) {
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            srb = ExAllocatePoolWithTag(NonPagedPool,
                                        sizeof(SCSI_REQUEST_BLOCK),
                                        CDROM_TAG_SRB);
            if (!srb) {
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

            cdb = (PCDB)srb->Cdb;

            //
            // Allocate sense buffer.
            //

            senseBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                                SENSE_BUFFER_SIZE,
                                                CDROM_TAG_SENSE_INFO);

            if (!senseBuffer) {
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // Set up the irp.
            //

            IoSetNextIrpStackLocation(irp2);
            irp2->IoStatus.Status = STATUS_SUCCESS;
            irp2->IoStatus.Information = 0;
            irp2->Flags = 0;
            irp2->UserBuffer = NULL;

            //
            // Save the device object and irp in a private stack location.
            //

            irpStack = IoGetCurrentIrpStackLocation(irp2);
            irpStack->DeviceObject = Fdo;
            irpStack->Parameters.Others.Argument2 = (PVOID) Irp;

            //
            // The retry count will be in the real Irp, as the retry logic will
            // recreate our private irp.
            //

            if (!(nextIrpStack->Parameters.Others.Argument1)) {

                //
                // Only jam this in if it doesn't exist. The completion routines can
                // call StartIo directly in the case of retries and resetting it will
                // cause infinite loops.
                //

                nextIrpStack->Parameters.Others.Argument1 = (PVOID) MAXIMUM_RETRIES;
            }

            //
            // Construct the IRP stack for the lower level driver.
            //

            irpStack = IoGetNextIrpStackLocation(irp2);
            irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_IN;
            irpStack->Parameters.Scsi.Srb = srb;

            srb->Length = SCSI_REQUEST_BLOCK_SIZE;
            srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
            srb->SrbStatus = srb->ScsiStatus = 0;
            srb->NextSrb = 0;
            srb->OriginalRequest = irp2;
            srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;
            srb->SenseInfoBuffer = senseBuffer;

            transferByteCount = (use6Byte) ? sizeof(ERROR_RECOVERY_DATA) : sizeof(ERROR_RECOVERY_DATA10);

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                               transferByteCount,
                                               CDROM_TAG_RAW);

            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            /*
             *  Zero out input buffer in case the device returns fewer bytes than advertized,
             *  which would cause us to return uninitialized kernel memory.
             */
            RtlZeroMemory(dataBuffer, transferByteCount);

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                            transferByteCount,
                                            FALSE,
                                            FALSE,
                                            (PIRP) NULL);

            if (!irp2->MdlAddress) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                ExFreePool(dataBuffer);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // Prepare the MDL
            //

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);

            srb->DataBuffer = dataBuffer;

            //
            // Set the new block size in the descriptor.
            //

            if (use6Byte) {
                cdData->BlockDescriptor.BlockLength[0] = (UCHAR)(COOKED_SECTOR_SIZE >> 16) & 0xFF;
                cdData->BlockDescriptor.BlockLength[1] = (UCHAR)(COOKED_SECTOR_SIZE >>  8) & 0xFF;
                cdData->BlockDescriptor.BlockLength[2] = (UCHAR)(COOKED_SECTOR_SIZE & 0xFF);
            } else {
                cdData->BlockDescriptor10.BlockLength[0] = (UCHAR)(COOKED_SECTOR_SIZE >> 16) & 0xFF;
                cdData->BlockDescriptor10.BlockLength[1] = (UCHAR)(COOKED_SECTOR_SIZE >>  8) & 0xFF;
                cdData->BlockDescriptor10.BlockLength[2] = (UCHAR)(COOKED_SECTOR_SIZE & 0xFF);
            }

            //
            // Move error page into dataBuffer.
            //

            RtlCopyMemory(srb->DataBuffer, &cdData->Header, transferByteCount);

            //
            // Build and send a mode select to switch into raw mode.
            //

            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_OUT);
            srb->DataTransferLength = transferByteCount;
            srb->TimeOutValue = fdoExtension->TimeOutValue * 2;

            if (use6Byte) {
                srb->CdbLength = 6;
                cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
                cdb->MODE_SELECT.PFBit = 1;
                cdb->MODE_SELECT.ParameterListLength = (UCHAR)transferByteCount;
            } else {
                srb->CdbLength = 10;
                cdb->MODE_SELECT10.OperationCode = SCSIOP_MODE_SELECT10;
                cdb->MODE_SELECT10.PFBit = 1;
                cdb->MODE_SELECT10.ParameterListLength[0] = (UCHAR)(transferByteCount >> 8);
                cdb->MODE_SELECT10.ParameterListLength[1] = (UCHAR)(transferByteCount & 0xFF);
            }

            //
            // Update completion routine.
            //

            IoSetCompletionRoutine(irp2,
                                   CdRomSwitchModeCompletion,
                                   srb,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }


        //
        // Request needs to be split. Completion of each portion of the
        // request will fire off the next portion. The final request will
        // signal Io to send a new request.
        //

        transferPages =
            fdoExtension->AdapterDescriptor->MaximumPhysicalPages - 1;

        if(maximumTransferLength > (transferPages << PAGE_SHIFT)) {
            maximumTransferLength = transferPages << PAGE_SHIFT;
        }

        //
        // Check that the maximum transfer size is not zero
        //

        if(maximumTransferLength == 0) {
            maximumTransferLength = PAGE_SIZE;
        }

        ClassSplitRequest(Fdo, Irp, maximumTransferLength);
        return;

    } else if (currentIrpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL) {

        //
        // Allocate an irp, srb and associated structures.
        //

        irp2 = IoAllocateIrp((CCHAR)(Fdo->StackSize+1),
                              FALSE);

        if (!irp2) {
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

            BAIL_OUT(Irp);
            CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
            return;
        }

        srb = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(SCSI_REQUEST_BLOCK),
                                    CDROM_TAG_SRB);
        if (!srb) {
            IoFreeIrp(irp2);
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

            BAIL_OUT(Irp);
            CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
            return;
        }

        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

        cdb = (PCDB)srb->Cdb;

        //
        // Allocate sense buffer.
        //

        senseBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                            SENSE_BUFFER_SIZE,
                                            CDROM_TAG_SENSE_INFO);

        if (!senseBuffer) {
            ExFreePool(srb);
            IoFreeIrp(irp2);
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

            BAIL_OUT(Irp);
            CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
            return;
        }

        RtlZeroMemory(senseBuffer, SENSE_BUFFER_SIZE);

        //
        // Set up the irp.
        //

        IoSetNextIrpStackLocation(irp2);
        irp2->IoStatus.Status = STATUS_SUCCESS;
        irp2->IoStatus.Information = 0;
        irp2->Flags = 0;
        irp2->UserBuffer = NULL;

        //
        // Save the device object and irp in a private stack location.
        //

        irpStack = IoGetCurrentIrpStackLocation(irp2);
        irpStack->DeviceObject = Fdo;
        irpStack->Parameters.Others.Argument2 = (PVOID) Irp;

        //
        // The retry count will be in the real Irp, as the retry logic will
        // recreate our private irp.
        //

        if (!(nextIrpStack->Parameters.Others.Argument1)) {

            //
            // Only jam this in if it doesn't exist. The completion routines can
            // call StartIo directly in the case of retries and resetting it will
            // cause infinite loops.
            //

            nextIrpStack->Parameters.Others.Argument1 = (PVOID) MAXIMUM_RETRIES;
        }

        //
        // keep track of the new irp as Argument3
        //

        nextIrpStack->Parameters.Others.Argument3 = irp2;


        //
        // Construct the IRP stack for the lower level driver.
        //

        irpStack = IoGetNextIrpStackLocation(irp2);
        irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_IN;
        irpStack->Parameters.Scsi.Srb = srb;

        IoSetCompletionRoutine(irp2,
                               CdRomDeviceControlCompletion,
                               srb,
                               TRUE,
                               TRUE,
                               TRUE);
        //
        // Setup those fields that are generic to all requests.
        //

        srb->Length = SCSI_REQUEST_BLOCK_SIZE;
        srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
        srb->SrbStatus = srb->ScsiStatus = 0;
        srb->NextSrb = 0;
        srb->OriginalRequest = irp2;
        srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;
        srb->SenseInfoBuffer = senseBuffer;

        if ((currentIrpStack->Parameters.DeviceIoControl.IoControlCode & 3) == METHOD_BUFFERED){
            /*
             *  The kernel allocated the output buffer for us and did not initialize it.
             *  We may not return the entire read length, so zero out the return buffer in order to avoid
             *  returning part of an uninitialized kernel buffer.
             */
            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength > currentIrpStack->Parameters.DeviceIoControl.InputBufferLength){
                RtlZeroMemory((PUCHAR)Irp->AssociatedIrp.SystemBuffer+currentIrpStack->Parameters.DeviceIoControl.InputBufferLength,
                                        currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength-currentIrpStack->Parameters.DeviceIoControl.InputBufferLength);
            }
        }


        switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {


        case IOCTL_CDROM_RAW_READ: {
            //
            // Determine whether the drive is currently in raw or cooked mode,
            // and which command to use to read the data.
            //
            RAW_READ_INFO rawReadInfo;
            PVOID outputVirtAddr = NULL;

            /*
             *  Since this ioctl is METHOD_OUT_DIRECT, we need to copy away the input buffer before interpreting it.
             *  This prevents a malicious app from messing with the input buffer while we are interpreting it.
             */
            rawReadInfo = *(PRAW_READ_INFO)currentIrpStack->Parameters.DeviceIoControl.Type3InputBuffer;

            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength){
                /*
                 *  Make sure that any user buffer that we pass down to the hardware is properly aligned
                 */
                ASSERT(Irp->MdlAddress);
                outputVirtAddr = MmGetMdlVirtualAddress(Irp->MdlAddress);
                if ((ULONG_PTR)outputVirtAddr & fdoExtension->AdapterDescriptor->AlignmentMask){
                    ASSERT(!((ULONG_PTR)outputVirtAddr & fdoExtension->AdapterDescriptor->AlignmentMask));
                    ExFreePool(senseBuffer);
                    ExFreePool(srb);
                    IoFreeIrp(irp2);
                    Irp->IoStatus.Information = 0;
                    Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                    BAIL_OUT(Irp);
                    CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                    return;
                }
            }

            if (!TEST_FLAG(cdData->XAFlags, XA_USE_READ_CD)) {
                ULONG          maximumTransferLength;

                if (cdData->RawAccess) {
                    ULONG rawTransferPages;

                    ULONG  startingSector;
                    UCHAR  min, sec, frame;

                    //
                    // Free the recently allocated irp, as we don't need it.
                    //

                    IoFreeIrp(irp2);

                    cdb = (PCDB)srb->Cdb;
                    RtlZeroMemory(cdb, CDB12GENERIC_LENGTH);

                    //
                    // Calculate starting offset.
                    //

                    startingSector = (ULONG)(rawReadInfo.DiskOffset.QuadPart >> fdoExtension->SectorShift);
                    transferByteCount  = rawReadInfo.SectorCount * RAW_SECTOR_SIZE;
                    maximumTransferLength = fdoExtension->AdapterDescriptor->MaximumTransferLength;
                    rawTransferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(outputVirtAddr, transferByteCount);

                    //
                    // Determine if request is within limits imposed by miniport.
                    //
                    if (transferByteCount > maximumTransferLength ||
                        rawTransferPages > fdoExtension->AdapterDescriptor->MaximumPhysicalPages) {

                        //
                        // The claim is that this won't happen, and is backed up by
                        // ActiveMovie usage, which does unbuffered XA reads of 0x18000, yet
                        // we get only 4 sector requests.
                        //

                        ExFreePool(senseBuffer);
                        ExFreePool(srb);

                        Irp->IoStatus.Information = 0;
                        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                        BAIL_OUT(Irp);
                        CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                        return;

                    }

                    srb->OriginalRequest = Irp;
                    srb->SrbFlags = fdoExtension->SrbFlags;
                    SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
                    SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
                    srb->DataTransferLength = transferByteCount;
                    srb->TimeOutValue = fdoExtension->TimeOutValue;
                    srb->CdbLength = 10;
                    srb->DataBuffer = outputVirtAddr;

                    if (rawReadInfo.TrackMode == CDDA) {
                        if (TEST_FLAG(cdData->XAFlags, XA_PLEXTOR_CDDA)) {

                            srb->CdbLength = 12;

                            cdb->PLXTR_READ_CDDA.LogicalBlockByte3  = (UCHAR) (startingSector & 0xFF);
                            cdb->PLXTR_READ_CDDA.LogicalBlockByte2  = (UCHAR) ((startingSector >>  8) & 0xFF);
                            cdb->PLXTR_READ_CDDA.LogicalBlockByte1  = (UCHAR) ((startingSector >> 16) & 0xFF);
                            cdb->PLXTR_READ_CDDA.LogicalBlockByte0  = (UCHAR) ((startingSector >> 24) & 0xFF);

                            cdb->PLXTR_READ_CDDA.TransferBlockByte3 = (UCHAR) (rawReadInfo.SectorCount & 0xFF);
                            cdb->PLXTR_READ_CDDA.TransferBlockByte2 = (UCHAR) (rawReadInfo.SectorCount >> 8);
                            cdb->PLXTR_READ_CDDA.TransferBlockByte1 = 0;
                            cdb->PLXTR_READ_CDDA.TransferBlockByte0 = 0;

                            cdb->PLXTR_READ_CDDA.SubCode = 0;
                            cdb->PLXTR_READ_CDDA.OperationCode = 0xD8;

                        } else if (TEST_FLAG(cdData->XAFlags, XA_NEC_CDDA)) {

                            cdb->NEC_READ_CDDA.LogicalBlockByte3  = (UCHAR) (startingSector & 0xFF);
                            cdb->NEC_READ_CDDA.LogicalBlockByte2  = (UCHAR) ((startingSector >>  8) & 0xFF);
                            cdb->NEC_READ_CDDA.LogicalBlockByte1  = (UCHAR) ((startingSector >> 16) & 0xFF);
                            cdb->NEC_READ_CDDA.LogicalBlockByte0  = (UCHAR) ((startingSector >> 24) & 0xFF);

                            cdb->NEC_READ_CDDA.TransferBlockByte1 = (UCHAR) (rawReadInfo.SectorCount & 0xFF);
                            cdb->NEC_READ_CDDA.TransferBlockByte0 = (UCHAR) (rawReadInfo.SectorCount >> 8);

                            cdb->NEC_READ_CDDA.OperationCode = 0xD4;
                        }
                    } else {

                        cdb->CDB10.TransferBlocksMsb  = (UCHAR) (rawReadInfo.SectorCount >> 8);
                        cdb->CDB10.TransferBlocksLsb  = (UCHAR) (rawReadInfo.SectorCount & 0xFF);

                        cdb->CDB10.LogicalBlockByte3  = (UCHAR) (startingSector & 0xFF);
                        cdb->CDB10.LogicalBlockByte2  = (UCHAR) ((startingSector >>  8) & 0xFF);
                        cdb->CDB10.LogicalBlockByte1  = (UCHAR) ((startingSector >> 16) & 0xFF);
                        cdb->CDB10.LogicalBlockByte0  = (UCHAR) ((startingSector >> 24) & 0xFF);

                        cdb->CDB10.OperationCode = SCSIOP_READ;
                    }

                    srb->SrbStatus = srb->ScsiStatus = 0;

                    nextIrpStack->MajorFunction = IRP_MJ_SCSI;
                    nextIrpStack->Parameters.Scsi.Srb = srb;

                    // HACKHACK - REF #0001

                    //
                    // Set up IoCompletion routine address.
                    //

                    IoSetCompletionRoutine(Irp,
                                           CdRomXACompletion,
                                           srb,
                                           TRUE,
                                           TRUE,
                                           TRUE);

                    IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, Irp);
                    return;

                } else {

                    transferByteCount = (use6Byte) ? sizeof(ERROR_RECOVERY_DATA) : sizeof(ERROR_RECOVERY_DATA10);
                    dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                                       transferByteCount,
                                                       CDROM_TAG_RAW );
                    if (!dataBuffer) {
                        ExFreePool(senseBuffer);
                        ExFreePool(srb);
                        IoFreeIrp(irp2);
                        Irp->IoStatus.Information = 0;
                        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                        BAIL_OUT(Irp);
                        CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                        return;

                    }

                    irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                                    transferByteCount,
                                                    FALSE,
                                                    FALSE,
                                                    (PIRP) NULL);

                    if (!irp2->MdlAddress) {
                        ExFreePool(senseBuffer);
                        ExFreePool(srb);
                        ExFreePool(dataBuffer);
                        IoFreeIrp(irp2);
                        Irp->IoStatus.Information = 0;
                        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                        BAIL_OUT(Irp);
                        CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                        return;
                    }

                    //
                    // Prepare the MDL
                    //

                    MmBuildMdlForNonPagedPool(irp2->MdlAddress);

                    srb->DataBuffer = dataBuffer;

                    //
                    // Set the new block size in the descriptor.
                    // This will set the block read size to RAW_SECTOR_SIZE
                    // TODO: Set density code, based on operation
                    //

                    if (use6Byte) {
                        cdData->BlockDescriptor.BlockLength[0] = (UCHAR)(RAW_SECTOR_SIZE >> 16) & 0xFF;
                        cdData->BlockDescriptor.BlockLength[1] = (UCHAR)(RAW_SECTOR_SIZE >>  8) & 0xFF;
                        cdData->BlockDescriptor.BlockLength[2] = (UCHAR)(RAW_SECTOR_SIZE & 0xFF);
                        cdData->BlockDescriptor.DensityCode = 0;
                    } else {
                        cdData->BlockDescriptor10.BlockLength[0] = (UCHAR)(RAW_SECTOR_SIZE >> 16) & 0xFF;
                        cdData->BlockDescriptor10.BlockLength[1] = (UCHAR)(RAW_SECTOR_SIZE >>  8) & 0xFF;
                        cdData->BlockDescriptor10.BlockLength[2] = (UCHAR)(RAW_SECTOR_SIZE & 0xFF);
                        cdData->BlockDescriptor10.DensityCode = 0;
                    }

                    //
                    // Move error page into dataBuffer.
                    //

                    RtlCopyMemory(srb->DataBuffer, &cdData->Header, transferByteCount);


                    //
                    // Build and send a mode select to switch into raw mode.
                    //

                    srb->SrbFlags = fdoExtension->SrbFlags;
                    SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
                    SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_OUT);
                    srb->DataTransferLength = transferByteCount;
                    srb->TimeOutValue = fdoExtension->TimeOutValue * 2;

                    if (use6Byte) {
                        srb->CdbLength = 6;
                        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
                        cdb->MODE_SELECT.PFBit = 1;
                        cdb->MODE_SELECT.ParameterListLength = (UCHAR)transferByteCount;
                    } else {

                        srb->CdbLength = 10;
                        cdb->MODE_SELECT10.OperationCode = SCSIOP_MODE_SELECT10;
                        cdb->MODE_SELECT10.PFBit = 1;
                        cdb->MODE_SELECT10.ParameterListLength[0] = (UCHAR)(transferByteCount >> 8);
                        cdb->MODE_SELECT10.ParameterListLength[1] = (UCHAR)(transferByteCount & 0xFF);
                    }

                    //
                    // Update completion routine.
                    //

                    IoSetCompletionRoutine(irp2,
                                           CdRomSwitchModeCompletion,
                                           srb,
                                           TRUE,
                                           TRUE,
                                           TRUE);

                }

            }
            else {
                ULONG  startingSector;

                //
                // Free the recently allocated irp, as we don't need it.
                //

                IoFreeIrp(irp2);

                cdb = (PCDB)srb->Cdb;
                RtlZeroMemory(cdb, CDB12GENERIC_LENGTH);


                //
                // Calculate starting offset.
                //

                startingSector = (ULONG)(rawReadInfo.DiskOffset.QuadPart >> fdoExtension->SectorShift);
                transferByteCount  = rawReadInfo.SectorCount * RAW_SECTOR_SIZE;

                srb->OriginalRequest = Irp;
                srb->SrbFlags = fdoExtension->SrbFlags;
                SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
                SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
                srb->DataTransferLength = transferByteCount;
                srb->TimeOutValue = fdoExtension->TimeOutValue;
                srb->DataBuffer = outputVirtAddr;
                srb->CdbLength = 12;
                srb->SrbStatus = srb->ScsiStatus = 0;

                //
                // Fill in CDB fields.
                //

                cdb = (PCDB)srb->Cdb;


                cdb->READ_CD.TransferBlocks[2]  = (UCHAR) (rawReadInfo.SectorCount & 0xFF);
                cdb->READ_CD.TransferBlocks[1]  = (UCHAR) (rawReadInfo.SectorCount >> 8 );
                cdb->READ_CD.TransferBlocks[0]  = (UCHAR) (rawReadInfo.SectorCount >> 16);


                cdb->READ_CD.StartingLBA[3]  = (UCHAR) (startingSector & 0xFF);
                cdb->READ_CD.StartingLBA[2]  = (UCHAR) ((startingSector >>  8));
                cdb->READ_CD.StartingLBA[1]  = (UCHAR) ((startingSector >> 16));
                cdb->READ_CD.StartingLBA[0]  = (UCHAR) ((startingSector >> 24));

                //
                // Setup cdb depending upon the sector type we want.
                //

                switch (rawReadInfo.TrackMode) {
                case CDDA:

                    cdb->READ_CD.ExpectedSectorType = CD_DA_SECTOR;
                    cdb->READ_CD.IncludeUserData = 1;
                    cdb->READ_CD.HeaderCode = 3;
                    cdb->READ_CD.IncludeSyncData = 1;
                    break;

                case YellowMode2:

                    cdb->READ_CD.ExpectedSectorType = YELLOW_MODE2_SECTOR;
                    cdb->READ_CD.IncludeUserData = 1;
                    cdb->READ_CD.HeaderCode = 1;
                    cdb->READ_CD.IncludeSyncData = 1;
                    break;

                case XAForm2:

                    cdb->READ_CD.ExpectedSectorType = FORM2_MODE2_SECTOR;
                    cdb->READ_CD.IncludeUserData = 1;
                    cdb->READ_CD.HeaderCode = 3;
                    cdb->READ_CD.IncludeSyncData = 1;
                    break;

                default:
                    ExFreePool(senseBuffer);
                    ExFreePool(srb);
                    Irp->IoStatus.Information = 0;
                    Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                    BAIL_OUT(Irp);
                    CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                    return;
                }

                cdb->READ_CD.OperationCode = SCSIOP_READ_CD;

                nextIrpStack->MajorFunction = IRP_MJ_SCSI;
                nextIrpStack->Parameters.Scsi.Srb = srb;

                // HACKHACK - REF #0001

                //
                // Set up IoCompletion routine address.
                //

                IoSetCompletionRoutine(Irp,
                                       CdRomXACompletion,
                                       srb,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, Irp);
                return;

            }

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        //
        // the _EX version does the same thing on the front end
        //

        case IOCTL_DISK_GET_LENGTH_INFO:
        case IOCTL_DISK_GET_DRIVE_GEOMETRY_EX:
        case IOCTL_DISK_GET_DRIVE_GEOMETRY:
        case IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX:
        case IOCTL_CDROM_GET_DRIVE_GEOMETRY: {

            //
            // Issue ReadCapacity to update device extension
            // with information for current media.
            //

            TraceLog((CdromDebugError,
                        "CdRomStartIo: Get drive geometry/length "
                        "info (%p)\n", Irp));

            //
            // setup remaining srb and cdb parameters.
            //

            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
            srb->DataTransferLength = sizeof(READ_CAPACITY_DATA);
            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                               sizeof(READ_CAPACITY_DATA),
                                               CDROM_TAG_READ_CAP);
            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;

            }

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                            sizeof(READ_CAPACITY_DATA),
                                            FALSE,
                                            FALSE,
                                            (PIRP) NULL);

            if (!irp2->MdlAddress) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                ExFreePool(dataBuffer);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // Prepare the MDL
            //

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);

            srb->DataBuffer = dataBuffer;
            cdb->CDB10.OperationCode = SCSIOP_READ_CAPACITY;

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_CDROM_GET_CONFIGURATION: {

            PGET_CONFIGURATION_IOCTL_INPUT inputBuffer;

            TraceLog((CdromDebugError,
                        "CdRomStartIo: Get configuration (%p)\n", Irp));

            if (!cdData->Mmc.IsMmc) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            transferByteCount = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                               transferByteCount,
                                               CDROM_TAG_GET_CONFIG);
            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            /*
             *  Zero out input buffer in case the device returns fewer bytes than advertized,
             *  which would cause us to return uninitialized kernel memory.
             */
            RtlZeroMemory(dataBuffer, transferByteCount);

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                             transferByteCount,
                                             FALSE,
                                             FALSE,
                                             (PIRP) NULL);
            if (!irp2->MdlAddress) {
                ExFreePool(dataBuffer);
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);

            //
            // setup remaining srb and cdb parameters
            //

            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
            srb->DataTransferLength = transferByteCount;
            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->DataBuffer = dataBuffer;

            cdb->GET_CONFIGURATION.OperationCode = SCSIOP_GET_CONFIGURATION;
            cdb->GET_CONFIGURATION.AllocationLength[0] = (UCHAR)(transferByteCount >> 8);
            cdb->GET_CONFIGURATION.AllocationLength[1] = (UCHAR)(transferByteCount & 0xff);

            inputBuffer = (PGET_CONFIGURATION_IOCTL_INPUT)Irp->AssociatedIrp.SystemBuffer;
            cdb->GET_CONFIGURATION.StartingFeature[0] = (UCHAR)(inputBuffer->Feature >> 8);
            cdb->GET_CONFIGURATION.StartingFeature[1] = (UCHAR)(inputBuffer->Feature & 0xff);
            cdb->GET_CONFIGURATION.RequestType        = (UCHAR)(inputBuffer->RequestType);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_DISK_VERIFY: {

            PVERIFY_INFORMATION verifyInfo = Irp->AssociatedIrp.SystemBuffer;
            LARGE_INTEGER byteOffset = {0};
            ULONG         sectorOffset;
            USHORT        sectorCount;

            if (!cdData->Mmc.WriteAllowed) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;
                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }
            //
            // Verify sectors
            //

            srb->CdbLength = 10;

            cdb->CDB10.OperationCode = SCSIOP_VERIFY;

            //
            // Add disk offset to starting sector.
            //

            byteOffset.QuadPart = commonExtension->StartingOffset.QuadPart +
                                  verifyInfo->StartingOffset.QuadPart;

            //
            // Convert byte offset to sector offset.
            //

            sectorOffset = (ULONG)(byteOffset.QuadPart >> fdoExtension->SectorShift);

            //
            // Convert ULONG byte count to USHORT sector count.
            //

            sectorCount = (USHORT)(verifyInfo->Length >> fdoExtension->SectorShift);

            //
            // Move little endian values into CDB in big endian format.
            //

            cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&sectorOffset)->Byte3;
            cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&sectorOffset)->Byte2;
            cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&sectorOffset)->Byte1;
            cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&sectorOffset)->Byte0;

            cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&sectorCount)->Byte1;
            cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&sectorCount)->Byte0;

            //
            // The verify command is used by the NT FORMAT utility and
            // requests are sent down for 5% of the volume size. The
            // request timeout value is calculated based on the number of
            // sectors verified.
            //

            srb->TimeOutValue = ((sectorCount + 0x7F) >> 7) *
                                fdoExtension->TimeOutValue;

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_STORAGE_CHECK_VERIFY:
        case IOCTL_DISK_CHECK_VERIFY:
        case IOCTL_CDROM_CHECK_VERIFY: {

            //
            // Since a test unit ready is about to be performed, reset the
            // timer value to decrease the opportunities for it to race with
            // this code.
            //

            ClassResetMediaChangeTimer(fdoExtension);

            //
            // Set up the SRB/CDB
            //

            srb->CdbLength = 6;
            cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
            srb->TimeOutValue = fdoExtension->TimeOutValue * 2;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);


            TraceLog((CdromDebugTrace,
                        "CdRomStartIo: [%p] Sending CHECK_VERIFY irp %p\n",
                        Irp, irp2));
            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_DVD_READ_STRUCTURE: {

            CdRomDeviceControlDvdReadStructure(Fdo, Irp, irp2, srb);
            return;

        }

        case IOCTL_DVD_END_SESSION: {
            CdRomDeviceControlDvdEndSession(Fdo, Irp, irp2, srb);
            return;
        }

        case IOCTL_DVD_START_SESSION:
        case IOCTL_DVD_READ_KEY: {

            CdRomDeviceControlDvdStartSessionReadKey(Fdo, Irp, irp2, srb);
            return;

        }


        case IOCTL_DVD_SEND_KEY:
        case IOCTL_DVD_SEND_KEY2: {

            CdRomDeviceControlDvdSendKey (Fdo, Irp, irp2, srb);
            return;


        }

        case IOCTL_CDROM_READ_TOC_EX: {

            PCDROM_READ_TOC_EX inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            transferByteCount = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                               transferByteCount,
                                               CDROM_TAG_TOC);
            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;

            }

            /*
             *  Zero out input buffer in case the device returns fewer bytes than advertized,
             *  which would cause us to return uninitialized kernel memory.
             */
            RtlZeroMemory(dataBuffer, transferByteCount);

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                            transferByteCount,
                                            FALSE,
                                            FALSE,
                                            (PIRP) NULL);

            if (!irp2->MdlAddress) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                ExFreePool(dataBuffer);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // setup the request per user request
            // do validity checking in devctl dispatch, not here
            //

            cdb->READ_TOC.OperationCode = SCSIOP_READ_TOC;
            cdb->READ_TOC.Msf = inputBuffer->Msf;
            cdb->READ_TOC.Format2 = inputBuffer->Format;
            cdb->READ_TOC.StartingTrack = inputBuffer->SessionTrack;
            cdb->READ_TOC.AllocationLength[0] = (UCHAR)(transferByteCount >> 8);
            cdb->READ_TOC.AllocationLength[1] = (UCHAR)(transferByteCount & 0xff);

            //
            // Prepare the MDL
            //

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);

            //
            // do the standard stuff....
            //

            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
            srb->DataTransferLength = transferByteCount;
            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->DataBuffer = dataBuffer;

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_CDROM_GET_LAST_SESSION:
        case IOCTL_CDROM_READ_TOC: {

            if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_CDROM_GET_LAST_SESSION) {
                //
                // Set format to return first and last session numbers.
                //
                cdb->READ_TOC.Format = CDROM_READ_TOC_EX_FORMAT_SESSION;
            } else {
                //
                // Use MSF addressing
                //
                cdb->READ_TOC.Msf = 1;
            }


            transferByteCount = min(currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength, sizeof(CDROM_TOC));

            //
            // Set size of TOC structure.
            //
            cdb->READ_TOC.AllocationLength[0] = (UCHAR) (transferByteCount >> 8);
            cdb->READ_TOC.AllocationLength[1] = (UCHAR) (transferByteCount & 0xFF);

            //
            // setup remaining srb and cdb parameters.
            //
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
            srb->DataTransferLength = transferByteCount;
            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                               transferByteCount,
                                               CDROM_TAG_TOC);
            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;

            }

            /*
             *  Zero out input buffer in case the device returns fewer bytes than advertized,
             *  which would cause us to return uninitialized kernel memory.
             */
            RtlZeroMemory(dataBuffer, transferByteCount);

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                            transferByteCount,
                                            FALSE,
                                            FALSE,
                                            (PIRP) NULL);

            if (!irp2->MdlAddress) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                ExFreePool(dataBuffer);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // Prepare the MDL
            //

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);

            srb->DataBuffer = dataBuffer;
            cdb->READ_TOC.OperationCode = SCSIOP_READ_TOC;

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;

        }

        case IOCTL_CDROM_PLAY_AUDIO_MSF: {

            PCDROM_PLAY_AUDIO_MSF inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            //
            // Set up the SRB/CDB
            //

            srb->CdbLength = 10;
            cdb->PLAY_AUDIO_MSF.OperationCode = SCSIOP_PLAY_AUDIO_MSF;

            cdb->PLAY_AUDIO_MSF.StartingM = inputBuffer->StartingM;
            cdb->PLAY_AUDIO_MSF.StartingS = inputBuffer->StartingS;
            cdb->PLAY_AUDIO_MSF.StartingF = inputBuffer->StartingF;

            cdb->PLAY_AUDIO_MSF.EndingM = inputBuffer->EndingM;
            cdb->PLAY_AUDIO_MSF.EndingS = inputBuffer->EndingS;
            cdb->PLAY_AUDIO_MSF.EndingF = inputBuffer->EndingF;

            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;

        }

        case IOCTL_CDROM_READ_Q_CHANNEL: {

            PSUB_Q_CHANNEL_DATA userChannelData =
                             Irp->AssociatedIrp.SystemBuffer;
            PCDROM_SUB_Q_DATA_FORMAT inputBuffer =
                             Irp->AssociatedIrp.SystemBuffer;

            //
            // Allocate buffer for subq channel information.
            //

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                               sizeof(SUB_Q_CHANNEL_DATA),
                                               CDROM_TAG_SUB_Q);

            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;

            }

            /*
             *  Zero out input buffer in case the device returns fewer bytes than advertized,
             *  which would cause us to return uninitialized kernel memory.
             */
            RtlZeroMemory(dataBuffer, sizeof(SUB_Q_CHANNEL_DATA));

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                             sizeof(SUB_Q_CHANNEL_DATA),
                                             FALSE,
                                             FALSE,
                                             (PIRP) NULL);

            if (!irp2->MdlAddress) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                ExFreePool(dataBuffer);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // Prepare the MDL
            //

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);

            srb->DataBuffer = dataBuffer;

            //
            // Always logical unit 0, but only use MSF addressing
            // for IOCTL_CDROM_CURRENT_POSITION
            //

            if (inputBuffer->Format==IOCTL_CDROM_CURRENT_POSITION)
                cdb->SUBCHANNEL.Msf = CDB_USE_MSF;

            //
            // Return subchannel data
            //

            cdb->SUBCHANNEL.SubQ = CDB_SUBCHANNEL_BLOCK;

            //
            // Specify format of informatin to return
            //

            cdb->SUBCHANNEL.Format = inputBuffer->Format;

            //
            // Specify which track to access (only used by Track ISRC reads)
            //

            if (inputBuffer->Format==IOCTL_CDROM_TRACK_ISRC) {
                cdb->SUBCHANNEL.TrackNumber = inputBuffer->Track;
            }

            //
            // Set size of channel data -- however, this is dependent on
            // what information we are requesting (which Format)
            //

            switch( inputBuffer->Format ) {

                case IOCTL_CDROM_CURRENT_POSITION:
                    transferByteCount = sizeof(SUB_Q_CURRENT_POSITION);
                    break;

                case IOCTL_CDROM_MEDIA_CATALOG:
                    transferByteCount = sizeof(SUB_Q_MEDIA_CATALOG_NUMBER);
                    break;

                case IOCTL_CDROM_TRACK_ISRC:
                    transferByteCount = sizeof(SUB_Q_TRACK_ISRC);
                    break;
            }

            cdb->SUBCHANNEL.AllocationLength[0] = (UCHAR) (transferByteCount >> 8);
            cdb->SUBCHANNEL.AllocationLength[1] = (UCHAR) (transferByteCount &  0xFF);
            cdb->SUBCHANNEL.OperationCode = SCSIOP_READ_SUB_CHANNEL;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
            srb->DataTransferLength = transferByteCount;
            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;

        }

        case IOCTL_CDROM_PAUSE_AUDIO: {

            cdb->PAUSE_RESUME.OperationCode = SCSIOP_PAUSE_RESUME;
            cdb->PAUSE_RESUME.Action = CDB_AUDIO_PAUSE;

            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_CDROM_RESUME_AUDIO: {

            cdb->PAUSE_RESUME.OperationCode = SCSIOP_PAUSE_RESUME;
            cdb->PAUSE_RESUME.Action = CDB_AUDIO_RESUME;

            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_CDROM_SEEK_AUDIO_MSF: {

            PCDROM_SEEK_AUDIO_MSF inputBuffer = Irp->AssociatedIrp.SystemBuffer;
            ULONG                 logicalBlockAddress;

            logicalBlockAddress = MSF_TO_LBA(inputBuffer->M, inputBuffer->S, inputBuffer->F);

            cdb->SEEK.OperationCode      = SCSIOP_SEEK;
            cdb->SEEK.LogicalBlockAddress[0] = ((PFOUR_BYTE)&logicalBlockAddress)->Byte3;
            cdb->SEEK.LogicalBlockAddress[1] = ((PFOUR_BYTE)&logicalBlockAddress)->Byte2;
            cdb->SEEK.LogicalBlockAddress[2] = ((PFOUR_BYTE)&logicalBlockAddress)->Byte1;
            cdb->SEEK.LogicalBlockAddress[3] = ((PFOUR_BYTE)&logicalBlockAddress)->Byte0;

            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;

        }

        case IOCTL_CDROM_STOP_AUDIO: {

            cdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
            cdb->START_STOP.Immediate = 1;
            cdb->START_STOP.Start = 0;
            cdb->START_STOP.LoadEject = 0;

            srb->CdbLength = 6;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_CDROM_GET_VOLUME:
        case IOCTL_CDROM_SET_VOLUME: {

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                        MODE_DATA_SIZE,
                                        CDROM_TAG_VOLUME);

            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            /*
             *  Zero out input buffer in case the device returns fewer bytes than advertized,
             *  which would cause us to return uninitialized kernel memory.
             */
            RtlZeroMemory(dataBuffer, MODE_DATA_SIZE);

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                            MODE_DATA_SIZE,
                                            FALSE,
                                            FALSE,
                                            (PIRP) NULL);

            if (!irp2->MdlAddress) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                ExFreePool(dataBuffer);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // Prepare the MDL
            //

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);
            srb->DataBuffer = dataBuffer;

            RtlZeroMemory(dataBuffer, MODE_DATA_SIZE);


            if (use6Byte) {

                cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                cdb->MODE_SENSE.PageCode = CDROM_AUDIO_CONTROL_PAGE;
                cdb->MODE_SENSE.AllocationLength = MODE_DATA_SIZE;

                srb->CdbLength = 6;

            } else {

                cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
                cdb->MODE_SENSE10.PageCode = CDROM_AUDIO_CONTROL_PAGE;
                cdb->MODE_SENSE10.AllocationLength[0] = (UCHAR)(MODE_DATA_SIZE >> 8);
                cdb->MODE_SENSE10.AllocationLength[1] = (UCHAR)(MODE_DATA_SIZE & 0xFF);

                srb->CdbLength = 10;
            }

            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->DataTransferLength = MODE_DATA_SIZE;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);

            if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_SET_VOLUME) {

                //
                // Setup a different completion routine as the mode sense data is needed in order
                // to send the mode select.
                //

                IoSetCompletionRoutine(irp2,
                                       CdRomSetVolumeIntermediateCompletion,
                                       srb,
                                       TRUE,
                                       TRUE,
                                       TRUE);

            }

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;

        }

        case IOCTL_STORAGE_SET_READ_AHEAD: {

            PSTORAGE_SET_READ_AHEAD readAhead = Irp->AssociatedIrp.SystemBuffer;

            ULONG blockAddress;
            PFOUR_BYTE fourByte = (PFOUR_BYTE) &blockAddress;

            //
            // setup the SRB for a set readahead command
            //

            cdb->SET_READ_AHEAD.OperationCode = SCSIOP_SET_READ_AHEAD;

            blockAddress = (ULONG) (readAhead->TriggerAddress.QuadPart >>
                                    fdoExtension->SectorShift);

            cdb->SET_READ_AHEAD.TriggerLBA[0] = fourByte->Byte3;
            cdb->SET_READ_AHEAD.TriggerLBA[1] = fourByte->Byte2;
            cdb->SET_READ_AHEAD.TriggerLBA[2] = fourByte->Byte1;
            cdb->SET_READ_AHEAD.TriggerLBA[3] = fourByte->Byte0;

            blockAddress = (ULONG) (readAhead->TargetAddress.QuadPart >>
                                    fdoExtension->SectorShift);

            cdb->SET_READ_AHEAD.ReadAheadLBA[0] = fourByte->Byte3;
            cdb->SET_READ_AHEAD.ReadAheadLBA[1] = fourByte->Byte2;
            cdb->SET_READ_AHEAD.ReadAheadLBA[2] = fourByte->Byte1;
            cdb->SET_READ_AHEAD.ReadAheadLBA[3] = fourByte->Byte0;

            srb->CdbLength = 12;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_DISK_GET_DRIVE_LAYOUT:
        case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:
        case IOCTL_DISK_GET_PARTITION_INFO:
        case IOCTL_DISK_GET_PARTITION_INFO_EX: {

            ASSERT(irp2);
            ASSERT(senseBuffer);
            ASSERT(srb);

            ExFreePool(srb);
            ExFreePool(senseBuffer);
            IoFreeIrp(irp2);

            //
            // NOTE: should probably update the media's capacity first...
            //

            CdromFakePartitionInfo(commonExtension, Irp);
            return;
        }

        case IOCTL_DISK_IS_WRITABLE: {

            TraceLog((CdromDebugWarning,
                        "CdRomStartIo: DiskIsWritable (%p) - returning %s\n",
                        Irp, (cdData->Mmc.WriteAllowed ? "TRUE" : "false")));

            ASSERT(irp2);
            ASSERT(senseBuffer);
            ASSERT(srb);

            ExFreePool(srb);
            ExFreePool(senseBuffer);
            IoFreeIrp(irp2);

            Irp->IoStatus.Information = 0;
            if (cdData->Mmc.WriteAllowed) {
                Irp->IoStatus.Status = STATUS_SUCCESS;
            } else {
                Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;
            }
            CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
            return;
        }

        default: {

            UCHAR uniqueAddress;

            //
            // Just complete the request - CdRomClassIoctlCompletion will take
            // care of it for us
            //
            // NOTE: THIS IS A SYNCHRONIZATION METHOD!!!
            //

            //
            // Acquire a new copy of the lock so that ClassCompleteRequest
            // doesn't get confused when we complete the other request while
            // holding the lock.
            //

            //
            // NOTE: CdRomDeviceControlDispatch/CdRomDeviceControlCompletion
            //       wait for the event and eventually calls
            //       IoStartNextPacket()
            //

            ASSERT(irp2);
            ASSERT(senseBuffer);
            ASSERT(srb);

            ExFreePool(srb);
            ExFreePool(senseBuffer);
            IoFreeIrp(irp2);



            ClassAcquireRemoveLock(Fdo, (PIRP)&uniqueAddress);
            ClassReleaseRemoveLock(Fdo, Irp);
            ClassCompleteRequest(Fdo, Irp, IO_NO_INCREMENT);
            ClassReleaseRemoveLock(Fdo, (PIRP)&uniqueAddress);
            return;
        }

        } // end switch()
    } else if (currentIrpStack->MajorFunction == IRP_MJ_SHUTDOWN ||
               currentIrpStack->MajorFunction == IRP_MJ_FLUSH_BUFFERS) {

        currentIrpStack->Parameters.Others.Argument1 = 0;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        CdRomShutdownFlushCompletion(Fdo, NULL, Irp);
        return;

    }

    //
    // If a read or an unhandled IRP_MJ_XX, end up here. The unhandled IRP_MJ's
    // are expected and composed of AutoRun Irps, at present.
    //

    IoCallDriver(commonExtension->LowerDeviceObject, Irp);
    return;
}


NTSTATUS
CdRomReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the entry called by the I/O system for read requests.
    It builds the SRB and sends it to the port driver.

Arguments:

    DeviceObject - the system object for the device.
    Irp - IRP involved.

Return Value:

    NT Status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION  currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG               transferByteCount = currentIrpStack->Parameters.Read.Length;
    LARGE_INTEGER       startingOffset = currentIrpStack->Parameters.Read.ByteOffset;

    PCDROM_DATA         cdData = (PCDROM_DATA)(commonExtension->DriverData);

    SCSI_REQUEST_BLOCK  srb = {0};
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    PAGED_CODE();

    //
    // note: we are no longer failing write commands immediately
    //       they are now failed in StartIo based upon media ability
    //

    //
    // If the cd is playing music then reject this request.
    //

    if (PLAY_ACTIVE(fdoExtension)) {
        Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        return STATUS_DEVICE_BUSY;
    }

    //
    // Verify parameters of this request.
    // Check that ending sector is on disc and
    // that number of bytes to transfer is a multiple of
    // the sector size.
    //

    startingOffset.QuadPart = currentIrpStack->Parameters.Read.ByteOffset.QuadPart +
                              transferByteCount;

    if (!fdoExtension->DiskGeometry.BytesPerSector) {
        fdoExtension->DiskGeometry.BytesPerSector = 2048;
    }

    if ((startingOffset.QuadPart > commonExtension->PartitionLength.QuadPart) ||
        (transferByteCount & fdoExtension->DiskGeometry.BytesPerSector - 1)) {

        //
        // Fail request with status of invalid parameters.
        //

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

        return STATUS_INVALID_PARAMETER;
    }


    return STATUS_SUCCESS;

} // end CdRomReadWriteVerification()


NTSTATUS
CdRomSwitchModeCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);
    PCDROM_DATA         cdData = (PCDROM_DATA)(commonExtension->DriverData);
    BOOLEAN             use6Byte = TEST_FLAG(cdData->XAFlags, XA_USE_6_BYTE);
    PIO_STACK_LOCATION  realIrpStack;
    PIO_STACK_LOCATION  realIrpNextStack;
    PSCSI_REQUEST_BLOCK srb     = Context;
    PIRP                realIrp = NULL;
    NTSTATUS            status;
    BOOLEAN             retry;

    //
    // Extract the 'real' irp from the irpstack.
    //

    realIrp = (PIRP) irpStack->Parameters.Others.Argument2;
    realIrpStack = IoGetCurrentIrpStackLocation(realIrp);
    realIrpNextStack = IoGetNextIrpStackLocation(realIrp);

    //
    // Check SRB status for success of completing request.
    //

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        ULONG retryInterval;

        TraceLog((CdromDebugTrace,
                    "CdRomSetVolumeIntermediateCompletion: Irp %p, Srb %p, Real Irp %p\n",
                    Irp,
                    srb,
                    realIrp));

        //
        // Release the queue if it is frozen.
        //

        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            ClassReleaseQueue(DeviceObject);
        }


        retry = ClassInterpretSenseInfo(DeviceObject,
                                        srb,
                                        irpStack->MajorFunction,
                                        irpStack->Parameters.DeviceIoControl.IoControlCode,
                                        MAXIMUM_RETRIES - ((ULONG)(ULONG_PTR)realIrpNextStack->Parameters.Others.Argument1),
                                        &status,
                                        &retryInterval);

        //
        // If the status is verified required and the this request
        // should bypass verify required then retry the request.
        //

        if (realIrpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME &&
            status == STATUS_VERIFY_REQUIRED) {

            status = STATUS_IO_DEVICE_ERROR;
            retry = TRUE;
        }

        if (retry && ((ULONG)(ULONG_PTR)realIrpNextStack->Parameters.Others.Argument1)--) {

            if (((ULONG)(ULONG_PTR)realIrpNextStack->Parameters.Others.Argument1)) {

                //
                // Retry request.
                //

                TraceLog((CdromDebugWarning,
                            "Retry request %p - Calling StartIo\n", Irp));


                ExFreePool(srb->SenseInfoBuffer);
                ExFreePool(srb->DataBuffer);
                ExFreePool(srb);
                if (Irp->MdlAddress) {
                    IoFreeMdl(Irp->MdlAddress);
                }

                IoFreeIrp(Irp);

                //
                // Call StartIo directly since IoStartNextPacket hasn't been called,
                // the serialisation is still intact.
                //

                CdRomRetryRequest(fdoExtension,
                                  realIrp,
                                  retryInterval,
                                  FALSE);

                return STATUS_MORE_PROCESSING_REQUIRED;

            }

            //
            // Exhausted retries. Fall through and complete the request with the appropriate status.
            //
        }
    } else {

        //
        // Set status for successful request.
        //

        status = STATUS_SUCCESS;

    }

    if (NT_SUCCESS(status)) {

        ULONG sectorSize, startingSector, transferByteCount;
        PCDB cdb;

        //
        // Update device ext. to show which mode we are currently using.
        //

        sectorSize =  cdData->BlockDescriptor.BlockLength[0] << 16;
        sectorSize |= (cdData->BlockDescriptor.BlockLength[1] << 8);
        sectorSize |= (cdData->BlockDescriptor.BlockLength[2]);

        cdData->RawAccess = (sectorSize == RAW_SECTOR_SIZE) ? TRUE : FALSE;

        //
        // Free the old data buffer, mdl.
        // reuse the SenseInfoBuffer and Srb
        //

        ExFreePool(srb->DataBuffer);
        IoFreeMdl(Irp->MdlAddress);
        IoFreeIrp(Irp);

        //
        // rebuild the srb.
        //

        cdb = (PCDB)srb->Cdb;
        RtlZeroMemory(cdb, CDB12GENERIC_LENGTH);


        if (cdData->RawAccess) {
            RAW_READ_INFO rawReadInfo;
            ULONG maximumTransferLength;
            ULONG transferPages;
            UCHAR min, sec, frame;

            /*
             *  Since this ioctl is METHOD_OUT_DIRECT, we need to copy away the input buffer before interpreting it.
             *  This prevents a malicious app from messing with the input buffer while we are interpreting it.
             *
             *  Note that the malicious app may have changed the input buffer while we were doing the mode select
             *  to switch to raw mode.  But it doesn't matter.
             *  All that matters is that we check and interpret the same input buffer (we've already checked the size).
             */
            rawReadInfo = *(PRAW_READ_INFO)realIrpStack->Parameters.DeviceIoControl.Type3InputBuffer;

            //
            // Calculate starting offset.
            //

            startingSector = (ULONG)(rawReadInfo.DiskOffset.QuadPart >> fdoExtension->SectorShift);
            transferByteCount  = rawReadInfo.SectorCount * RAW_SECTOR_SIZE;
            maximumTransferLength = fdoExtension->AdapterDescriptor->MaximumTransferLength;
            transferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MmGetMdlVirtualAddress(realIrp->MdlAddress),
                                                           transferByteCount);

            //
            // Determine if request is within limits imposed by miniport.
            // If the request is larger than the miniport's capabilities, split it.
            //

            if (transferByteCount > maximumTransferLength ||
                transferPages > fdoExtension->AdapterDescriptor->MaximumPhysicalPages) {


                ExFreePool(srb->SenseInfoBuffer);
                ExFreePool(srb);
                realIrp->IoStatus.Information = 0;
                realIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                BAIL_OUT(realIrp);
                CdRomCompleteIrpAndStartNextPacketSafely(DeviceObject, realIrp);
                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            srb->OriginalRequest = realIrp;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);

            srb->DataTransferLength = transferByteCount;
            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->CdbLength = 10;
            srb->DataBuffer = MmGetMdlVirtualAddress(realIrp->MdlAddress);

            if (rawReadInfo.TrackMode == CDDA) {
                if (TEST_FLAG(cdData->XAFlags, XA_PLEXTOR_CDDA)) {

                    srb->CdbLength = 12;

                    cdb->PLXTR_READ_CDDA.LogicalBlockByte3  = (UCHAR) (startingSector & 0xFF);
                    cdb->PLXTR_READ_CDDA.LogicalBlockByte2  = (UCHAR) ((startingSector >>  8) & 0xFF);
                    cdb->PLXTR_READ_CDDA.LogicalBlockByte1  = (UCHAR) ((startingSector >> 16) & 0xFF);
                    cdb->PLXTR_READ_CDDA.LogicalBlockByte0  = (UCHAR) ((startingSector >> 24) & 0xFF);

                    cdb->PLXTR_READ_CDDA.TransferBlockByte3 = (UCHAR) (rawReadInfo.SectorCount & 0xFF);
                    cdb->PLXTR_READ_CDDA.TransferBlockByte2 = (UCHAR) (rawReadInfo.SectorCount >> 8);
                    cdb->PLXTR_READ_CDDA.TransferBlockByte1 = 0;
                    cdb->PLXTR_READ_CDDA.TransferBlockByte0 = 0;

                    cdb->PLXTR_READ_CDDA.SubCode = 0;
                    cdb->PLXTR_READ_CDDA.OperationCode = 0xD8;

                } else if (TEST_FLAG(cdData->XAFlags, XA_NEC_CDDA)) {

                    cdb->NEC_READ_CDDA.LogicalBlockByte3  = (UCHAR) (startingSector & 0xFF);
                    cdb->NEC_READ_CDDA.LogicalBlockByte2  = (UCHAR) ((startingSector >>  8) & 0xFF);
                    cdb->NEC_READ_CDDA.LogicalBlockByte1  = (UCHAR) ((startingSector >> 16) & 0xFF);
                    cdb->NEC_READ_CDDA.LogicalBlockByte0  = (UCHAR) ((startingSector >> 24) & 0xFF);

                    cdb->NEC_READ_CDDA.TransferBlockByte1 = (UCHAR) (rawReadInfo.SectorCount & 0xFF);
                    cdb->NEC_READ_CDDA.TransferBlockByte0 = (UCHAR) (rawReadInfo.SectorCount >> 8);

                    cdb->NEC_READ_CDDA.OperationCode = 0xD4;
                }
            } else {
                cdb->CDB10.TransferBlocksMsb  = (UCHAR) (rawReadInfo.SectorCount >> 8);
                cdb->CDB10.TransferBlocksLsb  = (UCHAR) (rawReadInfo.SectorCount & 0xFF);

                cdb->CDB10.LogicalBlockByte3  = (UCHAR) (startingSector & 0xFF);
                cdb->CDB10.LogicalBlockByte2  = (UCHAR) ((startingSector >>  8) & 0xFF);
                cdb->CDB10.LogicalBlockByte1  = (UCHAR) ((startingSector >> 16) & 0xFF);
                cdb->CDB10.LogicalBlockByte0  = (UCHAR) ((startingSector >> 24) & 0xFF);

                cdb->CDB10.OperationCode = SCSIOP_READ;
            }

            srb->SrbStatus = srb->ScsiStatus = 0;


            irpStack = IoGetNextIrpStackLocation(realIrp);
            irpStack->MajorFunction = IRP_MJ_SCSI;
            irpStack->Parameters.Scsi.Srb = srb;

            if (!(irpStack->Parameters.Others.Argument1)) {

                //
                // Only jam this in if it doesn't exist. The completion routines can
                // call StartIo directly in the case of retries and resetting it will
                // cause infinite loops.
                //

                irpStack->Parameters.Others.Argument1 = (PVOID) MAXIMUM_RETRIES;
            }

            //
            // Set up IoCompletion routine address.
            //

            IoSetCompletionRoutine(realIrp,
                                   CdRomXACompletion,
                                   srb,
                                   TRUE,
                                   TRUE,
                                   TRUE);
        } else {

            PSTORAGE_ADAPTER_DESCRIPTOR adapterDescriptor;
            ULONG maximumTransferLength;
            ULONG transferPages;

            //
            // a writable device must be MMC compliant, which supports
            // READ_CD commands, so writes and mode switching should
            // never occur on the same device.
            //

            ASSERT(realIrpStack->MajorFunction != IRP_MJ_WRITE);

            //
            // free the SRB and SenseInfoBuffer since they aren't used
            // by either ClassBuildRequest() nor ClassSplitRequest().
            //

            ExFreePool(srb->SenseInfoBuffer);
            ExFreePool(srb);

            //
            // Back to cooked sectors. Build and send a normal read.
            // The real work for setting offsets was done in startio.
            //

            adapterDescriptor =
                commonExtension->PartitionZeroExtension->AdapterDescriptor;
            maximumTransferLength = adapterDescriptor->MaximumTransferLength;
            transferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                MmGetMdlVirtualAddress(realIrp->MdlAddress),
                                realIrpStack->Parameters.Read.Length);

            if ((realIrpStack->Parameters.Read.Length > maximumTransferLength) ||
                (transferPages > adapterDescriptor->MaximumPhysicalPages)) {

                ULONG maxPages = adapterDescriptor->MaximumPhysicalPages;

                if (maxPages != 0) {
                    maxPages --; // to account for page boundaries
                }

                TraceLog((CdromDebugTrace,
                            "CdromSwitchModeCompletion: Request greater than "
                            " maximum\n"));
                TraceLog((CdromDebugTrace,
                            "CdromSwitchModeCompletion: Maximum is %lx\n",
                            maximumTransferLength));
                TraceLog((CdromDebugTrace,
                            "CdromSwitchModeCompletion: Byte count is %lx\n",
                            realIrpStack->Parameters.Read.Length));

                //
                // Check that the maximum transfer length fits within
                // the maximum number of pages the device can handle.
                //

                if (maximumTransferLength > maxPages << PAGE_SHIFT) {
                    maximumTransferLength = maxPages << PAGE_SHIFT;
                }

                //
                // Check that maximum transfer size is not zero
                //

                if (maximumTransferLength == 0) {
                    maximumTransferLength = PAGE_SIZE;
                }

                //
                // Request needs to be split. Completion of each portion
                // of the request will fire off the next portion. The final
                // request will signal Io to send a new request.
                //

                ClassSplitRequest(DeviceObject, realIrp, maximumTransferLength);
                return STATUS_MORE_PROCESSING_REQUIRED;

            } else {

                //
                // Build SRB and CDB for this IRP.
                //

                ClassBuildRequest(DeviceObject, realIrp);

            }
        }

        //
        // Call the port driver.
        //

        IoCallDriver(commonExtension->LowerDeviceObject, realIrp);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // Update device Extension flags to indicate that XA isn't supported.
    //

    TraceLog((CdromDebugWarning,
                "Device Cannot Support CDDA (but tested positive) "
                "Now Clearing CDDA flags for FDO %p\n", DeviceObject));
    SET_FLAG(cdData->XAFlags, XA_NOT_SUPPORTED);
    CLEAR_FLAG(cdData->XAFlags, XA_PLEXTOR_CDDA);
    CLEAR_FLAG(cdData->XAFlags, XA_NEC_CDDA);

    //
    // Deallocate srb and sense buffer.
    //

    if (srb) {
        if (srb->DataBuffer) {
            ExFreePool(srb->DataBuffer);
        }
        if (srb->SenseInfoBuffer) {
            ExFreePool(srb->SenseInfoBuffer);
        }
        ExFreePool(srb);
    }

    if (Irp->PendingReturned) {
      IoMarkIrpPending(Irp);
    }

    if (realIrp->PendingReturned) {
        IoMarkIrpPending(realIrp);
    }

    if (Irp->MdlAddress) {
        IoFreeMdl(Irp->MdlAddress);
    }

    IoFreeIrp(Irp);

    //
    // Set status in completing IRP.
    //

    realIrp->IoStatus.Status = status;

    //
    // Set the hard error if necessary.
    //

    if (!NT_SUCCESS(status) && IoIsErrorUserInduced(status)) {

        //
        // Store DeviceObject for filesystem, and clear
        // in IoStatus.Information field.
        //

        if (realIrp->Tail.Overlay.Thread) {
            IoSetHardErrorOrVerifyDevice(realIrp, DeviceObject);
        }
        realIrp->IoStatus.Information = 0;
    }

    CdRomCompleteIrpAndStartNextPacketSafely(DeviceObject, realIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
ScanForSpecialHandler(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    ULONG_PTR HackFlags
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension;
    PCDROM_DATA cdData;

    PAGED_CODE();

    CLEAR_FLAG(HackFlags, CDROM_HACK_INVALID_FLAGS);

    commonExtension = &(FdoExtension->CommonExtension);
    cdData = (PCDROM_DATA)(commonExtension->DriverData);
    cdData->HackFlags = HackFlags;

    return;
}

VOID
ScanForSpecial(
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This function checks to see if an SCSI logical unit requires an special
    initialization or error processing.

Arguments:

    DeviceObject - Supplies the device object to be tested.

    InquiryData - Supplies the inquiry data returned by the device of interest.

    PortCapabilities - Supplies the capabilities of the device object.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension;
    PCDROM_DATA cdData;

    PAGED_CODE();

    fdoExtension = DeviceObject->DeviceExtension;
    commonExtension = DeviceObject->DeviceExtension;
    cdData = (PCDROM_DATA)(commonExtension->DriverData);


    //
    // set our hack flags
    //

    ClassScanForSpecial(fdoExtension, CdromHackItems, ScanForSpecialHandler);

    //
    // All CDRom's can ignore the queue lock failure for power operations
    // and do not require handling the SpinUp case (unknown result of sending
    // a cdrom a START_UNIT command -- may eject disks?)
    //
    // We send the stop command mostly to stop outstanding asynch operations
    // (like audio playback) from running when the system is powered off.
    // Because of this and the unlikely chance that a PLAY command will be
    // sent in the window between the STOP and the time the machine powers down
    // we don't require queue locks.  This is important because without them
    // classpnp's power routines will send the START_STOP_UNIT command to the
    // device whether or not it supports locking (atapi does not support locking
    // and if we requested them we would end up not stopping audio on atapi
    // devices).
    //

    SET_FLAG(fdoExtension->ScanForSpecialFlags, CLASS_SPECIAL_DISABLE_SPIN_UP);
    SET_FLAG(fdoExtension->ScanForSpecialFlags, CLASS_SPECIAL_NO_QUEUE_LOCK);

    if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_HITACHI_1750)
        && ( fdoExtension->AdapterDescriptor->AdapterUsesPio )
        ) {

        //
        // Read-ahead must be disabled in order to get this cdrom drive
        // to work on scsi adapters that use PIO.
        //


        TraceLog((CdromDebugWarning,
                    "CdRom ScanForSpecial:  Found Hitachi CDR-1750S.\n"));

        //
        // Setup an error handler to reinitialize the cd rom after it is reset.
        //

        cdData->ErrorHandler = HitachiProcessError;

        //
        // Lock down the hitachi error processing code.
        //

        MmLockPagableCodeSection(HitachiProcessError);
        SET_FLAG(cdData->HackFlags, CDROM_HACK_LOCKED_PAGES);


    } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_TOSHIBA_SD_W1101)) {

        TraceLog((CdromDebugError,
                    "CdRom ScanForSpecial: Found Toshiba SD-W1101 DVD-RAM "
                    "-- This drive will *NOT* support DVD-ROM playback.\n"));

    } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_HITACHI_GD_2000)) {

        TraceLog((CdromDebugWarning,
                    "CdRom ScanForSpecial: Found Hitachi GD-2000\n"));

        //
        // Setup an error handler to spin up the drive when it idles out
        // since it seems to like to fail to spin itself back up on its
        // own for a REPORT_KEY command.  It may also lose the AGIDs that
        // it has given, which will result in DVD playback failures.
        // This routine will just do what it can...
        //

        cdData->ErrorHandler = HitachiProcessErrorGD2000;

        //
        // this drive may require START_UNIT commands to spin
        // the drive up when it's spun itself down.
        //

        SET_FLAG(fdoExtension->DeviceFlags, DEV_SAFE_START_UNIT);

        //
        // Lock down the hitachi error processing code.
        //

        MmLockPagableCodeSection(HitachiProcessErrorGD2000);
        SET_FLAG(cdData->HackFlags, CDROM_HACK_LOCKED_PAGES);

    } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_FUJITSU_FMCD_10x)) {

        //
        // When Read command is issued to FMCD-101 or FMCD-102 and there is a music
        // cd in it. It takes longer time than SCSI_CDROM_TIMEOUT before returning
        // error status.
        //

        fdoExtension->TimeOutValue = 20;

    } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_DEC_RRD)) {

        PMODE_PARM_READ_WRITE_DATA modeParameters;
        SCSI_REQUEST_BLOCK         srb = {0};
        PCDB                       cdb;
        NTSTATUS                   status;


        TraceLog((CdromDebugWarning,
                    "CdRom ScanForSpecial:  Found DEC RRD.\n"));

        cdData->IsDecRrd = TRUE;

        //
        // Setup an error handler to reinitialize the cd rom after it is reset?
        //
        //commonExtension->DevInfo->ClassError = DecRrdProcessError;

        //
        // Found a DEC RRD cd-rom.  These devices do not pass MS HCT
        // multi-media tests because the DEC firmware modifieds the block
        // from the PC-standard 2K to 512.  Change the block transfer size
        // back to the PC-standard 2K by using a mode select command.
        //

        modeParameters = ExAllocatePoolWithTag(NonPagedPool,
                                               sizeof(MODE_PARM_READ_WRITE_DATA),
                                               CDROM_TAG_MODE_DATA
                                               );
        if (modeParameters == NULL) {
            return;
        }

        RtlZeroMemory(modeParameters, sizeof(MODE_PARM_READ_WRITE_DATA));
        RtlZeroMemory(&srb,           sizeof(SCSI_REQUEST_BLOCK));

        //
        // Set the block length to 2K.
        //

        modeParameters->ParameterListHeader.BlockDescriptorLength =
                sizeof(MODE_PARAMETER_BLOCK);

        //
        // Set block length to 2K (0x0800) in Parameter Block.
        //

        modeParameters->ParameterListBlock.BlockLength[0] = 0x00; //MSB
        modeParameters->ParameterListBlock.BlockLength[1] = 0x08;
        modeParameters->ParameterListBlock.BlockLength[2] = 0x00; //LSB

        //
        // Build the mode select CDB.
        //

        srb.CdbLength = 6;
        srb.TimeOutValue = fdoExtension->TimeOutValue;

        cdb = (PCDB)srb.Cdb;
        cdb->MODE_SELECT.PFBit               = 1;
        cdb->MODE_SELECT.OperationCode       = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = HITACHI_MODE_DATA_SIZE;

        //
        // Send the request to the device.
        //

        status = ClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         modeParameters,
                                         sizeof(MODE_PARM_READ_WRITE_DATA),
                                         TRUE);

        if (!NT_SUCCESS(status)) {
            TraceLog((CdromDebugWarning,
                        "CdRom ScanForSpecial: Setting DEC RRD to 2K block"
                        "size failed [%x]\n", status));
        }
        ExFreePool(modeParameters);

    } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_TOSHIBA_XM_3xx)) {

        SCSI_REQUEST_BLOCK srb = {0};
        PCDB               cdb;
        ULONG              length;
        PUCHAR             buffer;
        NTSTATUS           status;

        //
        // Set the density code and the error handler.
        //

        length = (sizeof(MODE_READ_RECOVERY_PAGE) + MODE_BLOCK_DESC_LENGTH + MODE_HEADER_LENGTH);

        RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

        //
        // Build the MODE SENSE CDB.
        //

        srb.CdbLength = 6;
        cdb = (PCDB)srb.Cdb;

        //
        // Set timeout value from device extension.
        //

        srb.TimeOutValue = fdoExtension->TimeOutValue;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = 0x1;
        // NOTE: purposely not setting DBD because it is what is needed.
        cdb->MODE_SENSE.AllocationLength = (UCHAR)length;

        buffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                (sizeof(MODE_READ_RECOVERY_PAGE) + MODE_BLOCK_DESC_LENGTH + MODE_HEADER_LENGTH),
                                CDROM_TAG_MODE_DATA);
        if (!buffer) {
            return;
        }

        status = ClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         buffer,
                                         length,
                                         FALSE);

        ((PERROR_RECOVERY_DATA)buffer)->BlockDescriptor.DensityCode = 0x83;
        ((PERROR_RECOVERY_DATA)buffer)->Header.ModeDataLength = 0x0;

        RtlCopyMemory(&cdData->Header, buffer, sizeof(ERROR_RECOVERY_DATA));

        RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

        //
        // Build the MODE SENSE CDB.
        //

        srb.CdbLength = 6;
        cdb = (PCDB)srb.Cdb;

        //
        // Set timeout value from device extension.
        //

        srb.TimeOutValue = fdoExtension->TimeOutValue;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = 1;
        cdb->MODE_SELECT.ParameterListLength = (UCHAR)length;

        status = ClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         buffer,
                                         length,
                                         TRUE);

        if (!NT_SUCCESS(status)) {
            TraceLog((CdromDebugWarning,
                        "Cdrom.ScanForSpecial: Setting density code on Toshiba failed [%x]\n",
                        status));
        }

        cdData->ErrorHandler = ToshibaProcessError;

        //
        // Lock down the toshiba error section.
        //

        MmLockPagableCodeSection(ToshibaProcessError);
        SET_FLAG(cdData->HackFlags, CDROM_HACK_LOCKED_PAGES);

        ExFreePool(buffer);

    }

    //
    // Determine special CD-DA requirements.
    //

    if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_READ_CD_SUPPORTED)) {

        SET_FLAG(cdData->XAFlags, XA_USE_READ_CD);

    } else if (!TEST_FLAG(cdData->XAFlags, XA_USE_READ_CD)) {

        if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_PLEXTOR_CDDA)) {
            SET_FLAG(cdData->XAFlags, XA_PLEXTOR_CDDA);
        } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_NEC_CDDA)) {
            SET_FLAG(cdData->XAFlags, XA_NEC_CDDA);
        }

    }

    if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_LOCKED_PAGES)) {
        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_ERROR_LEVEL,
                   "Locking pages for error handler\n"));
    }


    return;
}


VOID
HitachiProcessErrorGD2000(
    PDEVICE_OBJECT Fdo,
    PSCSI_REQUEST_BLOCK OriginalSrb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )
/*++

Routine Description:

   This routine checks the type of error.  If the error suggests that the
   drive has spun down and cannot reinitialize itself, send a
   START_UNIT or READ to the device.  This will force the drive to spin
   up.  This drive also loses the AGIDs it has granted when it spins down,
   which may result in playback failure the first time around.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    Srb - Supplies a pointer to the failing Srb.

    Status - return the final status for this command?

    Retry - return if the command should be retried.

Return Value:

    None.

--*/
{
    PSENSE_DATA senseBuffer = OriginalSrb->SenseInfoBuffer;

    UNREFERENCED_PARAMETER(Status);
    UNREFERENCED_PARAMETER(Retry);

    if (!TEST_FLAG(OriginalSrb->SrbStatus, SRB_STATUS_AUTOSENSE_VALID)) {
        return;
    }

    if (((senseBuffer->SenseKey & 0xf) == SCSI_SENSE_HARDWARE_ERROR) &&
        (senseBuffer->AdditionalSenseCode == 0x44)) {

        PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
        PIRP                irp;
        PIO_STACK_LOCATION  irpStack;
        PCOMPLETION_CONTEXT context;
        PSCSI_REQUEST_BLOCK newSrb;
        PCDB                cdb;

        TraceLog((CdromDebugWarning,
                    "HitachiProcessErrorGD2000 (%p) => Internal Target "
                    "Failure Detected -- spinning up drive\n", Fdo));

        //
        // the request should be retried because the device isn't ready
        //

        *Retry = TRUE;
        *Status = STATUS_DEVICE_NOT_READY;

        //
        // send a START_STOP unit to spin up the drive
        // NOTE: this temporarily violates the StartIo serialization
        //       mechanism, but the completion routine on this will NOT
        //       call StartNextPacket(), so it's a temporary disruption
        //       of the serialization only.
        //

        ClassSendStartUnit(Fdo);

    }

    return;
}


VOID
HitachiProcessError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )
/*++

Routine Description:

   This routine checks the type of error.  If the error indicates CD-ROM the
   CD-ROM needs to be reinitialized then a Mode sense command is sent to the
   device.  This command disables read-ahead for the device.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    Srb - Supplies a pointer to the failing Srb.

    Status - Not used.

    Retry - Not used.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PSENSE_DATA         senseBuffer = Srb->SenseInfoBuffer;
    LARGE_INTEGER       largeInt = {0};
    PUCHAR              modePage;
    PIO_STACK_LOCATION  irpStack;
    PIRP                irp;
    PSCSI_REQUEST_BLOCK srb;
    PCOMPLETION_CONTEXT context;
    PCDB                cdb;
    ULONG_PTR            alignment;

    UNREFERENCED_PARAMETER(Status);
    UNREFERENCED_PARAMETER(Retry);

    largeInt.QuadPart = (LONGLONG) 1;

    //
    // Check the status.  The initialization command only needs to be sent
    // if UNIT ATTENTION is returned.
    //

    if (!(Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID)) {

        //
        // The drive does not require reinitialization.
        //

        return;
    }

    //
    // Found an HITACHI cd-rom that does not work with PIO
    // adapters when read-ahead is enabled.  Read-ahead is disabled by
    // a mode select command.  The mode select page code is zero and the
    // length is 6 bytes.  All of the other bytes should be zero.
    //

    if ((senseBuffer->SenseKey & 0xf) == SCSI_SENSE_UNIT_ATTENTION) {

        TraceLog((CdromDebugWarning,
                    "HitachiProcessError: Reinitializing the CD-ROM.\n"));

        //
        // Send the special mode select command to disable read-ahead
        // on the CD-ROM reader.
        //

        alignment = DeviceObject->AlignmentRequirement ?
            DeviceObject->AlignmentRequirement : 1;

        context = ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(COMPLETION_CONTEXT) +  HITACHI_MODE_DATA_SIZE + (ULONG)alignment,
            CDROM_TAG_HITACHI_ERROR
            );

        if (context == NULL) {

            //
            // If there is not enough memory to fulfill this request,
            // simply return. A subsequent retry will fail and another
            // chance to start the unit.
            //

            return;
        }

        context->DeviceObject = DeviceObject;
        srb = &context->Srb;

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        //
        // Write length to SRB.
        //

        srb->Length = SCSI_REQUEST_BLOCK_SIZE;

        //
        // Set up SCSI bus address.
        //

        srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
        srb->TimeOutValue = fdoExtension->TimeOutValue;

        //
        // Set the transfer length.
        //

        srb->DataTransferLength = HITACHI_MODE_DATA_SIZE;
        srb->SrbFlags = fdoExtension->SrbFlags;
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_OUT);
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_AUTOSENSE);
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);

        //
        // The data buffer must be aligned.
        //

        srb->DataBuffer = (PVOID) (((ULONG_PTR) (context + 1) + (alignment - 1)) &
            ~(alignment - 1));


        //
        // Build the HITACHI read-ahead mode select CDB.
        //

        srb->CdbLength = 6;
        cdb = (PCDB)srb->Cdb;
        cdb->MODE_SENSE.LogicalUnitNumber = srb->Lun;
        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SENSE.AllocationLength = HITACHI_MODE_DATA_SIZE;

        //
        // Initialize the mode sense data.
        //

        modePage = srb->DataBuffer;

        RtlZeroMemory(modePage, HITACHI_MODE_DATA_SIZE);

        //
        // Set the page length field to 6.
        //

        modePage[5] = 6;

        //
        // Build the asynchronous request to be sent to the port driver.
        //

        irp = IoBuildAsynchronousFsdRequest(IRP_MJ_WRITE,
                                           DeviceObject,
                                           srb->DataBuffer,
                                           srb->DataTransferLength,
                                           &largeInt,
                                           NULL);

        if (irp == NULL) {

            //
            // If there is not enough memory to fulfill this request,
            // simply return. A subsequent retry will fail and another
            // chance to start the unit.
            //

            ExFreePool(context);
            return;
        }

        ClassAcquireRemoveLock(DeviceObject, irp);

        IoSetCompletionRoutine(irp,
                   (PIO_COMPLETION_ROUTINE)ClassAsynchronousCompletion,
                   context,
                   TRUE,
                   TRUE,
                   TRUE);

        irpStack = IoGetNextIrpStackLocation(irp);

        irpStack->MajorFunction = IRP_MJ_SCSI;

        srb->OriginalRequest = irp;

        //
        // Save SRB address in next stack for port driver.
        //

        irpStack->Parameters.Scsi.Srb = (PVOID)srb;

        //
        // Set up IRP Address.
        //

        (VOID)IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);

    }
}


NTSTATUS
ToshibaProcessErrorCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:

    Completion routine for the ClassError routine to handle older Toshiba units
    that require setting the density code.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    Irp - Pointer to irp created to set the density code.

    Context - Supplies a pointer to the Mode Select Srb.


Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{

    PSCSI_REQUEST_BLOCK srb = Context;

    //
    // Free all of the allocations.
    //

    ClassReleaseRemoveLock(DeviceObject, Irp);

    ExFreePool(srb->DataBuffer);
    ExFreePool(srb);
    IoFreeMdl(Irp->MdlAddress);
    IoFreeIrp(Irp);

    //
    // Indicate the I/O system should stop processing the Irp completion.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
ToshibaProcessError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

   This routine checks the type of error.  If the error indicates a unit attention,
   the density code needs to be set via a Mode select command.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    Srb - Supplies a pointer to the failing Srb.

    Status - Not used.

    Retry - Not used.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PCDROM_DATA         cdData = (PCDROM_DATA)(commonExtension->DriverData);
    PSENSE_DATA         senseBuffer = Srb->SenseInfoBuffer;
    PIO_STACK_LOCATION  irpStack;
    PIRP                irp;
    PSCSI_REQUEST_BLOCK srb;
    ULONG               length;
    PCDB                cdb;
    PUCHAR              dataBuffer;


    if (!(Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID)) {
        return;
    }

    //
    // The Toshiba's require the density code to be set on power up and media changes.
    //

    if ((senseBuffer->SenseKey & 0xf) == SCSI_SENSE_UNIT_ATTENTION) {


        irp = IoAllocateIrp((CCHAR)(DeviceObject->StackSize+1),
                              FALSE);

        if (!irp) {
            return;
        }

        srb = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(SCSI_REQUEST_BLOCK),
                                    CDROM_TAG_TOSHIBA_ERROR);
        if (!srb) {
            IoFreeIrp(irp);
            return;
        }


        length = sizeof(ERROR_RECOVERY_DATA);
        dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                           length,
                                           CDROM_TAG_TOSHIBA_ERROR);
        if (!dataBuffer) {
            ExFreePool(srb);
            IoFreeIrp(irp);
            return;
        }

        /*
         *  Zero out input buffer in case the device returns fewer bytes than advertized,
         *  which would cause us to return uninitialized kernel memory.
         */
        RtlZeroMemory(dataBuffer, length);

        irp->MdlAddress = IoAllocateMdl(dataBuffer,
                                        length,
                                        FALSE,
                                        FALSE,
                                        (PIRP) NULL);

        if (!irp->MdlAddress) {
            ExFreePool(srb);
            ExFreePool(dataBuffer);
            IoFreeIrp(irp);
            return;
        }

        //
        // Prepare the MDL
        //

        MmBuildMdlForNonPagedPool(irp->MdlAddress);

        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

        srb->DataBuffer = dataBuffer;
        cdb = (PCDB)srb->Cdb;

        //
        // Set up the irp.
        //

        IoSetNextIrpStackLocation(irp);
        irp->IoStatus.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = 0;
        irp->Flags = 0;
        irp->UserBuffer = NULL;

        //
        // Save the device object and irp in a private stack location.
        //

        irpStack = IoGetCurrentIrpStackLocation(irp);
        irpStack->DeviceObject = DeviceObject;

        //
        // Construct the IRP stack for the lower level driver.
        //

        irpStack = IoGetNextIrpStackLocation(irp);
        irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_OUT;
        irpStack->Parameters.Scsi.Srb = srb;

        IoSetCompletionRoutine(irp,
                               ToshibaProcessErrorCompletion,
                               srb,
                               TRUE,
                               TRUE,
                               TRUE);

        ClassAcquireRemoveLock(DeviceObject, irp);

        srb->Length = SCSI_REQUEST_BLOCK_SIZE;
        srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
        srb->SrbStatus = srb->ScsiStatus = 0;
        srb->NextSrb = 0;
        srb->OriginalRequest = irp;
        srb->SenseInfoBufferLength = 0;

        //
        // Set the transfer length.
        //

        srb->DataTransferLength = length;
        srb->SrbFlags = fdoExtension->SrbFlags;
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_OUT);
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_AUTOSENSE);
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);


        srb->CdbLength = 6;
        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = 1;
        cdb->MODE_SELECT.ParameterListLength = (UCHAR)length;

        //
        // Copy the Mode page into the databuffer.
        //

        RtlCopyMemory(srb->DataBuffer, &cdData->Header, length);

        //
        // Set the density code.
        //

        ((PERROR_RECOVERY_DATA)srb->DataBuffer)->BlockDescriptor.DensityCode = 0x83;

        IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);
    }
}


BOOLEAN
CdRomIsPlayActive(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine determines if the cd is currently playing music.

Arguments:

    DeviceObject - Device object to test.

Return Value:

    TRUE if the device is playing music.

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    IO_STATUS_BLOCK ioStatus = {0};
    PSUB_Q_CURRENT_POSITION currentBuffer;

    PAGED_CODE();

    //
    // if we don't think it is playing audio, don't bother checking.
    //

    if (!PLAY_ACTIVE(fdoExtension)) {
        return(FALSE);
    }

    currentBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                          sizeof(SUB_Q_CURRENT_POSITION),
                                          CDROM_TAG_PLAY_ACTIVE);

    if (currentBuffer == NULL) {
        return(FALSE);
    }

    ((PCDROM_SUB_Q_DATA_FORMAT) currentBuffer)->Format = IOCTL_CDROM_CURRENT_POSITION;
    ((PCDROM_SUB_Q_DATA_FORMAT) currentBuffer)->Track = 0;

    //
    // Build the synchronous request to be sent to ourself
    // to perform the request.
    //

    ClassSendDeviceIoControlSynchronous(
        IOCTL_CDROM_READ_Q_CHANNEL,
        DeviceObject,
        currentBuffer,
        sizeof(CDROM_SUB_Q_DATA_FORMAT),
        sizeof(SUB_Q_CURRENT_POSITION),
        FALSE,
        &ioStatus);

    if (!NT_SUCCESS(ioStatus.Status)) {
        ExFreePool(currentBuffer);
        return FALSE;
    }

    //
    // should update the playactive flag here.
    //

    if (currentBuffer->Header.AudioStatus == AUDIO_STATUS_IN_PROGRESS) {
        PLAY_ACTIVE(fdoExtension) = TRUE;
    } else {
        PLAY_ACTIVE(fdoExtension) = FALSE;
    }

    ExFreePool(currentBuffer);

    return(PLAY_ACTIVE(fdoExtension));

}


VOID
CdRomTickHandler(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine handles the once per second timer provided by the
    Io subsystem.  It is used to do delayed retries for cdroms.

Arguments:

    DeviceObject - what to check.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    ULONG isRemoved;

    KIRQL             oldIrql;

    PIRP              heldIrpList;
    PIRP              nextIrp;
    PLIST_ENTRY       listEntry;
    PCDROM_DATA       cddata;
    PIO_STACK_LOCATION irpStack;
    UCHAR             uniqueAddress;

    isRemoved = ClassAcquireRemoveLock(DeviceObject, (PIRP) &uniqueAddress);

    //
    // We stop the timer before deleting the device.  It's safe to keep going
    // if the flag value is REMOVE_PENDING because the removal thread will be
    // blocked trying to stop the timer.
    //

    ASSERT(isRemoved != REMOVE_COMPLETE);

    //
    // This routine is reasonably safe even if the device object has a pending
    // remove

    cddata = commonExtension->DriverData;

    //
    // Since cdrom is completely synchronized there can never be more than one
    // irp delayed for retry at any time.
    //

    KeAcquireSpinLock(&(cddata->DelayedRetrySpinLock), &oldIrql);

    if(cddata->DelayedRetryIrp != NULL) {

        PIRP irp = cddata->DelayedRetryIrp;

        //
        // If we've got a delayed retry at this point then there had beter
        // be an interval for it.
        //

        ASSERT(cddata->DelayedRetryInterval != 0);
        cddata->DelayedRetryInterval--;

        if(isRemoved) {

            //
            // This device is removed - flush the timer queue
            //

            cddata->DelayedRetryIrp = NULL;
            cddata->DelayedRetryInterval = 0;

            KeReleaseSpinLock(&(cddata->DelayedRetrySpinLock), oldIrql);

            ClassReleaseRemoveLock(DeviceObject, irp);
            ClassCompleteRequest(DeviceObject, irp, IO_CD_ROM_INCREMENT);

        } else if (cddata->DelayedRetryInterval == 0) {

            //
            // Submit this IRP to the lower driver.  This IRP does not
            // need to be remembered here.  It will be handled again when
            // it completes.
            //

            cddata->DelayedRetryIrp = NULL;

            KeReleaseSpinLock(&(cddata->DelayedRetrySpinLock), oldIrql);

            TraceLog((CdromDebugWarning,
                        "CdRomTickHandler: Reissuing request %p (thread = %p)\n",
                        irp,
                        irp->Tail.Overlay.Thread));

            //
            // feed this to the appropriate port driver
            //

            CdRomRerunRequest(fdoExtension, irp, cddata->DelayedRetryResend);
        } else {
            KeReleaseSpinLock(&(cddata->DelayedRetrySpinLock), oldIrql);
        }
    } else {
        KeReleaseSpinLock(&(cddata->DelayedRetrySpinLock), oldIrql);
    }

    ClassReleaseRemoveLock(DeviceObject, (PIRP) &uniqueAddress);
}


NTSTATUS
CdRomUpdateGeometryCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:

    This routine andles the completion of the test unit ready irps
    used to determine if the media has changed.  If the media has
    changed, this code signals the named event to wake up other
    system services that react to media change (aka AutoPlay).

Arguments:

    DeviceObject - the object for the completion
    Irp - the IRP being completed
    Context - the SRB from the IRP

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension;

    PSCSI_REQUEST_BLOCK srb = (PSCSI_REQUEST_BLOCK) Context;
    PREAD_CAPACITY_DATA readCapacityBuffer;
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    BOOLEAN             retry;
    ULONG               retryCount;
    ULONG               lastSector;
    PIRP                originalIrp;
    PCDROM_DATA         cddata;
    UCHAR               uniqueAddress;

    //
    // Get items saved in the private IRP stack location.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    retryCount = (ULONG)(ULONG_PTR) irpStack->Parameters.Others.Argument1;
    originalIrp = (PIRP) irpStack->Parameters.Others.Argument2;

    if (!DeviceObject) {
        DeviceObject = irpStack->DeviceObject;
    }
    ASSERT(DeviceObject);

    fdoExtension = DeviceObject->DeviceExtension;
    commonExtension = DeviceObject->DeviceExtension;
    cddata = commonExtension->DriverData;
    readCapacityBuffer = srb->DataBuffer;

    if ((NT_SUCCESS(Irp->IoStatus.Status)) && (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS)) {

        CdRomInterpretReadCapacity(DeviceObject, readCapacityBuffer);

    } else {

        ULONG retryInterval;

        TraceLog((CdromDebugWarning,
                    "CdRomUpdateGeometryCompletion: [%p] unsuccessful "
                    "completion of buddy-irp %p (status - %lx)\n",
                    originalIrp, Irp, Irp->IoStatus.Status));

        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            ClassReleaseQueue(DeviceObject);
        }

        retry = ClassInterpretSenseInfo(DeviceObject,
                                        srb,
                                        IRP_MJ_SCSI,
                                        0,
                                        retryCount,
                                        &status,
                                        &retryInterval);
        if (retry) {
            retryCount--;
            if ((retryCount) && (commonExtension->IsRemoved == NO_REMOVE)) {
                PCDB cdb;

                TraceLog((CdromDebugWarning,
                            "CdRomUpdateGeometryCompletion: [%p] Retrying "
                            "request %p .. thread is %p\n",
                            originalIrp, Irp, Irp->Tail.Overlay.Thread));

                //
                // set up a one shot timer to get this process started over
                //

                irpStack->Parameters.Others.Argument1 = ULongToPtr( retryCount );
                irpStack->Parameters.Others.Argument2 = (PVOID) originalIrp;
                irpStack->Parameters.Others.Argument3 = (PVOID) 2;

                //
                // Setup the IRP to be submitted again in the timer routine.
                //

                irpStack = IoGetNextIrpStackLocation(Irp);
                irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_IN;
                irpStack->Parameters.Scsi.Srb = srb;
                IoSetCompletionRoutine(Irp,
                                       CdRomUpdateGeometryCompletion,
                                       srb,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                //
                // Set up the SRB for read capacity.
                //

                srb->CdbLength = 10;
                srb->TimeOutValue = fdoExtension->TimeOutValue;
                srb->SrbStatus = srb->ScsiStatus = 0;
                srb->NextSrb = 0;
                srb->Length = SCSI_REQUEST_BLOCK_SIZE;
                srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
                srb->SrbFlags = fdoExtension->SrbFlags;
                SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
                SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
                srb->DataTransferLength = sizeof(READ_CAPACITY_DATA);

                //
                // Set up the CDB
                //

                cdb = (PCDB) &srb->Cdb[0];
                cdb->CDB10.OperationCode = SCSIOP_READ_CAPACITY;

                //
                // Requests queued onto this list will be sent to the
                // lower level driver during CdRomTickHandler
                //

                CdRomRetryRequest(fdoExtension, Irp, retryInterval, TRUE);

                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            if (commonExtension->IsRemoved != NO_REMOVE) {

                //
                // We cannot retry the request.  Fail it.
                //

                originalIrp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;

            } else {

                //
                // This has been bounced for a number of times.  Error the
                // original request.
                //

                originalIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                RtlZeroMemory(&(fdoExtension->DiskGeometry),
                              sizeof(DISK_GEOMETRY));
                fdoExtension->DiskGeometry.BytesPerSector = 2048;
                fdoExtension->SectorShift = 11;
                commonExtension->PartitionLength.QuadPart =
                    (LONGLONG)(0x7fffffff);
                fdoExtension->DiskGeometry.MediaType = RemovableMedia;
            }
        } else {

            //
            // Set up reasonable defaults
            //

            RtlZeroMemory(&(fdoExtension->DiskGeometry),
                          sizeof(DISK_GEOMETRY));
            fdoExtension->DiskGeometry.BytesPerSector = 2048;
            fdoExtension->SectorShift = 11;
            commonExtension->PartitionLength.QuadPart = (LONGLONG)(0x7fffffff);
            fdoExtension->DiskGeometry.MediaType = RemovableMedia;
        }
    }

    //
    // Free resources held.
    //

    ExFreePool(srb->SenseInfoBuffer);
    ExFreePool(srb->DataBuffer);
    ExFreePool(srb);
    if (Irp->MdlAddress) {
        IoFreeMdl(Irp->MdlAddress);
    }
    IoFreeIrp(Irp);
    Irp = NULL;

    if (originalIrp->Tail.Overlay.Thread) {

        TraceLog((CdromDebugTrace,
                    "CdRomUpdateGeometryCompletion: [%p] completing "
                    "original IRP\n", originalIrp));

    } else {

        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugError,
                   "CdRomUpdateGeometryCompletion: completing irp %p which has "
                   "no thread\n", originalIrp));

    }

    {
        // NOTE: should the original irp be sent down to the device object?
        //       it probably should if the SL_OVERRIDER_VERIFY_VOLUME flag
        //       is set!
        KIRQL oldIrql;
        PIO_STACK_LOCATION realIrpStack;

        realIrpStack = IoGetCurrentIrpStackLocation(originalIrp);
        oldIrql = KeRaiseIrqlToDpcLevel();

        if (TEST_FLAG(realIrpStack->Flags, SL_OVERRIDE_VERIFY_VOLUME)) {
            CdRomStartIo(DeviceObject, originalIrp);
        } else {
            originalIrp->IoStatus.Status = STATUS_VERIFY_REQUIRED;
            originalIrp->IoStatus.Information = 0;
            CdRomCompleteIrpAndStartNextPacketSafely(DeviceObject, originalIrp);
        }
        KeLowerIrql(oldIrql);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
CdRomUpdateCapacity(
    IN PFUNCTIONAL_DEVICE_EXTENSION DeviceExtension,
    IN PIRP IrpToComplete,
    IN OPTIONAL PKEVENT IoctlEvent
    )

/*++

Routine Description:

    This routine updates the capacity of the disk as recorded in the device extension.
    It also completes the IRP given with STATUS_VERIFY_REQUIRED.  This routine is called
    when a media change has occurred and it is necessary to determine the capacity of the
    new media prior to the next access.

Arguments:

    DeviceExtension - the device to update
    IrpToComplete - the request that needs to be completed when done.

Return Value:

    NTSTATUS

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = (PCOMMON_DEVICE_EXTENSION) DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = (PFUNCTIONAL_DEVICE_EXTENSION) DeviceExtension;

    PCDB                cdb;
    PIRP                irp;
    PSCSI_REQUEST_BLOCK srb;
    PREAD_CAPACITY_DATA capacityBuffer;
    PIO_STACK_LOCATION  irpStack;
    PUCHAR              senseBuffer;
    NTSTATUS            status;

    irp = IoAllocateIrp((CCHAR)(commonExtension->DeviceObject->StackSize+1),
                        FALSE);

    if (irp) {

        srb = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(SCSI_REQUEST_BLOCK),
                                    CDROM_TAG_UPDATE_CAP);
        if (srb) {
            capacityBuffer = ExAllocatePoolWithTag(
                                NonPagedPoolCacheAligned,
                                sizeof(READ_CAPACITY_DATA),
                                CDROM_TAG_UPDATE_CAP);

            if (capacityBuffer) {


                senseBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                                    SENSE_BUFFER_SIZE,
                                                    CDROM_TAG_UPDATE_CAP);

                if (senseBuffer) {

                    irp->MdlAddress = IoAllocateMdl(capacityBuffer,
                                                    sizeof(READ_CAPACITY_DATA),
                                                    FALSE,
                                                    FALSE,
                                                    (PIRP) NULL);

                    if (irp->MdlAddress) {

                        //
                        // Have all resources.  Set up the IRP to send for the capacity.
                        //

                        IoSetNextIrpStackLocation(irp);
                        irp->IoStatus.Status = STATUS_SUCCESS;
                        irp->IoStatus.Information = 0;
                        irp->Flags = 0;
                        irp->UserBuffer = NULL;

                        //
                        // Save the device object and retry count in a private stack location.
                        //

                        irpStack = IoGetCurrentIrpStackLocation(irp);
                        irpStack->DeviceObject = commonExtension->DeviceObject;
                        irpStack->Parameters.Others.Argument1 = (PVOID) MAXIMUM_RETRIES;
                        irpStack->Parameters.Others.Argument2 = (PVOID) IrpToComplete;

                        //
                        // Construct the IRP stack for the lower level driver.
                        //

                        irpStack = IoGetNextIrpStackLocation(irp);
                        irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                        irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_IN;
                        irpStack->Parameters.Scsi.Srb = srb;
                        IoSetCompletionRoutine(irp,
                                               CdRomUpdateGeometryCompletion,
                                               srb,
                                               TRUE,
                                               TRUE,
                                               TRUE);
                        //
                        // Prepare the MDL
                        //

                        MmBuildMdlForNonPagedPool(irp->MdlAddress);


                        //
                        // Set up the SRB for read capacity.
                        //

                        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));
                        RtlZeroMemory(senseBuffer, SENSE_BUFFER_SIZE);
                        srb->CdbLength = 10;
                        srb->TimeOutValue = DeviceExtension->TimeOutValue;
                        srb->SrbStatus = srb->ScsiStatus = 0;
                        srb->NextSrb = 0;
                        srb->Length = SCSI_REQUEST_BLOCK_SIZE;
                        srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
                        srb->SrbFlags = DeviceExtension->SrbFlags;
                        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
                        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
                        srb->DataBuffer = capacityBuffer;
                        srb->DataTransferLength = sizeof(READ_CAPACITY_DATA);
                        srb->OriginalRequest = irp;
                        srb->SenseInfoBuffer = senseBuffer;
                        srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

                        //
                        // Set up the CDB
                        //

                        cdb = (PCDB) &srb->Cdb[0];
                        cdb->CDB10.OperationCode = SCSIOP_READ_CAPACITY;

                        //
                        // Set the return value in the IRP that will be completed
                        // upon completion of the read capacity.
                        //

                        IrpToComplete->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
                        IoMarkIrpPending(IrpToComplete);

                        IoCallDriver(commonExtension->LowerDeviceObject, irp);

                        //
                        // status is not checked because the completion routine for this
                        // IRP will always get called and it will free the resources.
                        //

                        return STATUS_PENDING;

                    } else {
                        ExFreePool(senseBuffer);
                        ExFreePool(capacityBuffer);
                        ExFreePool(srb);
                        IoFreeIrp(irp);
                    }
                } else {
                    ExFreePool(capacityBuffer);
                    ExFreePool(srb);
                    IoFreeIrp(irp);
                }
            } else {
                ExFreePool(srb);
                IoFreeIrp(irp);
            }
        } else {
            IoFreeIrp(irp);
        }
    }

    //
    // complete the original irp with a failure.
    // ISSUE-2000/07/05-henrygab - find a way to avoid failure.
    //

    RtlZeroMemory(&(fdoExtension->DiskGeometry),
                  sizeof(DISK_GEOMETRY));
    fdoExtension->DiskGeometry.BytesPerSector = 2048;
    fdoExtension->SectorShift = 11;
    commonExtension->PartitionLength.QuadPart =
        (LONGLONG)(0x7fffffff);
    fdoExtension->DiskGeometry.MediaType = RemovableMedia;

    IrpToComplete->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
    IrpToComplete->IoStatus.Information = 0;

    BAIL_OUT(IrpToComplete);
    CdRomCompleteIrpAndStartNextPacketSafely(commonExtension->DeviceObject,
                                             IrpToComplete);
    return STATUS_INSUFFICIENT_RESOURCES;
}


NTSTATUS
CdRomRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )

/*++

Routine Description:

    This routine is responsible for releasing any resources in use by the
    cdrom driver and shutting down it's timer routine.  This routine is called
    when all outstanding requests have been completed and the device has
    disappeared - no requests may be issued to the lower drivers.

Arguments:

    DeviceObject - the device object being removed

Return Value:

    none - this routine may not fail

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension =
        DeviceObject->DeviceExtension;

    PCDROM_DATA cdData = deviceExtension->CommonExtension.DriverData;

    PAGED_CODE();

    if((Type == IRP_MN_QUERY_REMOVE_DEVICE) ||
       (Type == IRP_MN_CANCEL_REMOVE_DEVICE)) {
        return STATUS_SUCCESS;
    }

    if(cdData->DelayedRetryIrp != NULL) {
        cdData->DelayedRetryInterval = 1;
        CdRomTickHandler(DeviceObject);
    }

    if (Type == IRP_MN_REMOVE_DEVICE){

        CdRomDeAllocateMmcResources(DeviceObject);

        if (deviceExtension->DeviceDescriptor) {
            ExFreePool(deviceExtension->DeviceDescriptor);
            deviceExtension->DeviceDescriptor = NULL;
        }

        if (deviceExtension->AdapterDescriptor) {
            ExFreePool(deviceExtension->AdapterDescriptor);
            deviceExtension->AdapterDescriptor = NULL;
        }

        if (deviceExtension->SenseData) {
            ExFreePool(deviceExtension->SenseData);
            deviceExtension->SenseData = NULL;
        }

        ClassDeleteSrbLookasideList(&deviceExtension->CommonExtension);
    }

    if(cdData->CdromInterfaceString.Buffer != NULL) {
        IoSetDeviceInterfaceState(
            &(cdData->CdromInterfaceString),
            FALSE);
        RtlFreeUnicodeString(&(cdData->CdromInterfaceString));
        RtlInitUnicodeString(&(cdData->CdromInterfaceString), NULL);
    }

    if(cdData->VolumeInterfaceString.Buffer != NULL) {
        IoSetDeviceInterfaceState(
            &(cdData->VolumeInterfaceString),
            FALSE);
        RtlFreeUnicodeString(&(cdData->VolumeInterfaceString));
        RtlInitUnicodeString(&(cdData->VolumeInterfaceString), NULL);
    }

    CdRomDeleteWellKnownName(DeviceObject);

    ASSERT(cdData->DelayedRetryIrp == NULL);

    if(Type == IRP_MN_REMOVE_DEVICE) {

        if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_LOCKED_PAGES)) {

            //
            // unlock locked pages by locking (to get Mm pointer)
            // and then unlocking twice.
            //

            PVOID locked;

            if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_HITACHI_1750)) {

                locked = MmLockPagableCodeSection(HitachiProcessError);

            } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_HITACHI_GD_2000)) {

                locked = MmLockPagableCodeSection(HitachiProcessErrorGD2000);

            } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_TOSHIBA_XM_3xx )) {

                locked = MmLockPagableCodeSection(ToshibaProcessError);

            } else {

                // this is a problem!
                // workaround by locking this twice, once for us and
                // once for the non-existant locker from ScanForSpecial
                ASSERT(!"hack flags show locked section, but none exists?");
                locked = MmLockPagableCodeSection(CdRomRemoveDevice);
                locked = MmLockPagableCodeSection(CdRomRemoveDevice);


            }

            MmUnlockPagableImageSection(locked);
            MmUnlockPagableImageSection(locked);

        }

        //
        // keep the system-wide count accurate, as
        // programs use this info to know when they
        // have found all the cdroms in a system.
        //

        TraceLog((CdromDebugTrace,
                    "CDROM.SYS Remove device\n"));
        IoGetConfigurationInformation()->CdRomCount--;
    }

    //
    // so long, and thanks for all the fish!
    //

    return STATUS_SUCCESS;
}


DEVICE_TYPE
CdRomGetDeviceType(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine figures out the real device type
    by checking CDVD_CAPABILITIES_PAGE

Arguments:

    DeviceObject -

Return Value:

    FILE_DEVICE_CD_ROM or FILE_DEVICE_DVD


--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PCDROM_DATA cdromExtension;
    ULONG bufLength;
    SCSI_REQUEST_BLOCK srb = {0};
    PCDB cdb;
    PMODE_PARAMETER_HEADER10 modePageHeader;
    PCDVD_CAPABILITIES_PAGE capPage;
    ULONG capPageOffset;
    DEVICE_TYPE deviceType;
    NTSTATUS status;
    BOOLEAN use6Byte;

    PAGED_CODE();

    //
    // NOTE: don't cache this until understand how it affects GetMediaTypes()
    //

    //
    // default device type
    //

    deviceType = FILE_DEVICE_CD_ROM;

    fdoExtension = DeviceObject->DeviceExtension;

    cdromExtension = fdoExtension->CommonExtension.DriverData;

    use6Byte = TEST_FLAG(cdromExtension->XAFlags, XA_USE_6_BYTE);

    RtlZeroMemory(&srb, sizeof(srb));
    cdb = (PCDB)srb.Cdb;

    //
    // Build the MODE SENSE CDB. The data returned will be kept in the
    // device extension and used to set block size.
    //
    if (use6Byte) {

        bufLength = sizeof(CDVD_CAPABILITIES_PAGE) +
                    sizeof(MODE_PARAMETER_HEADER);

        capPageOffset = sizeof(MODE_PARAMETER_HEADER);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = 1;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_CAPABILITIES;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)bufLength;
        srb.CdbLength = 6;
    } else {

        bufLength = sizeof(CDVD_CAPABILITIES_PAGE) +
                    sizeof(MODE_PARAMETER_HEADER10);

        capPageOffset = sizeof(MODE_PARAMETER_HEADER10);

        cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
        cdb->MODE_SENSE10.Dbd = 1;
        cdb->MODE_SENSE10.PageCode = MODE_PAGE_CAPABILITIES;
        cdb->MODE_SENSE10.AllocationLength[0] = (UCHAR)(bufLength >> 8);
        cdb->MODE_SENSE10.AllocationLength[1] = (UCHAR)(bufLength >> 0);
        srb.CdbLength = 10;
    }

    //
    // Set timeout value from device extension.
    //
    srb.TimeOutValue = fdoExtension->TimeOutValue;

    modePageHeader = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                           bufLength,
                                           CDROM_TAG_MODE_DATA);
    if (modePageHeader) {

        RtlZeroMemory(modePageHeader, bufLength);

        status = ClassSendSrbSynchronous(
                     DeviceObject,
                     &srb,
                     modePageHeader,
                     bufLength,
                     FALSE);

        if (NT_SUCCESS(status) ||
            (status == STATUS_DATA_OVERRUN) ||
            (status == STATUS_BUFFER_OVERFLOW)
            ) {

            capPage = (PCDVD_CAPABILITIES_PAGE) (((PUCHAR) modePageHeader) + capPageOffset);

            if ((capPage->PageCode == MODE_PAGE_CAPABILITIES) &&
                (capPage->DVDROMRead || capPage->DVDRRead ||
                 capPage->DVDRAMRead || capPage->DVDRWrite ||
                 capPage->DVDRAMWrite)) {

                deviceType = FILE_DEVICE_DVD;
            }
        }
        ExFreePool (modePageHeader);
    }

    return deviceType;
}


NTSTATUS
CdRomCreateWellKnownName(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine creates a symbolic link to the cdrom device object
    under \dosdevices.  The number of the cdrom device does not neccessarily
    match between \dosdevices and \device, but usually will be the same.

    Saves the buffer

Arguments:

    DeviceObject -

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PCDROM_DATA cdromData = commonExtension->DriverData;

    UNICODE_STRING unicodeLinkName = {0};
    WCHAR wideLinkName[64] = {0};
    PWCHAR savedName;

    LONG cdromNumber = fdoExtension->DeviceNumber;

    NTSTATUS status;

    //
    // if already linked, assert then return
    //

    if (cdromData->WellKnownName.Buffer != NULL) {

        TraceLog((CdromDebugError,
                    "CdRomCreateWellKnownName: link already exists %p\n",
                    cdromData->WellKnownName.Buffer));
        ASSERT(FALSE);
        return STATUS_UNSUCCESSFUL;

    }

    //
    // find an unused CdRomNN to link to
    //

    do {

        swprintf(wideLinkName, L"\\DosDevices\\CdRom%d", cdromNumber);
        RtlInitUnicodeString(&unicodeLinkName, wideLinkName);
        status = IoCreateSymbolicLink(&unicodeLinkName,
                                      &(commonExtension->DeviceName));

        cdromNumber++;

    } while((status == STATUS_OBJECT_NAME_COLLISION) ||
            (status == STATUS_OBJECT_NAME_EXISTS));

    if (!NT_SUCCESS(status)) {

        TraceLog((CdromDebugWarning,
                    "CdRomCreateWellKnownName: Error %lx linking %wZ to "
                    "device %wZ\n",
                    status,
                    &unicodeLinkName,
                    &(commonExtension->DeviceName)));
        return status;

    }

    TraceLog((CdromDebugWarning,
                "CdRomCreateWellKnownName: successfully linked %wZ "
                "to device %wZ\n",
                &unicodeLinkName,
                &(commonExtension->DeviceName)));

    //
    // Save away the symbolic link name in the driver data block.  We need
    // it so we can delete the link when the device is removed.
    //

    savedName = ExAllocatePoolWithTag(PagedPool,
                                      unicodeLinkName.MaximumLength,
                                      CDROM_TAG_STRINGS);

    if (savedName == NULL) {
        IoDeleteSymbolicLink(&unicodeLinkName);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(savedName,
                  unicodeLinkName.Buffer,
                  unicodeLinkName.MaximumLength);

    RtlInitUnicodeString(&(cdromData->WellKnownName), savedName);

    //
    // the name was saved and the link created
    //

    return STATUS_SUCCESS;
}


VOID
CdRomDeleteWellKnownName(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PCDROM_DATA cdromData = commonExtension->DriverData;

    if(cdromData->WellKnownName.Buffer != NULL) {

        IoDeleteSymbolicLink(&(cdromData->WellKnownName));
        ExFreePool(cdromData->WellKnownName.Buffer);
        cdromData->WellKnownName.Buffer = NULL;
        cdromData->WellKnownName.Length = 0;
        cdromData->WellKnownName.MaximumLength = 0;

    }
    return;
}


NTSTATUS
CdRomGetDeviceParameter (
    IN     PDEVICE_OBJECT      Fdo,
    IN     PWSTR               ParameterName,
    IN OUT PULONG              ParameterValue
    )
/*++

Routine Description:

    retrieve a devnode registry parameter

Arguments:

    DeviceObject - Cdrom Device Object

    ParameterName - parameter name to look up

    ParameterValuse - default parameter value

Return Value:

    NT Status

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;
    RTL_QUERY_REGISTRY_TABLE queryTable[2] = {0};
    ULONG                    defaultParameterValue;

    PAGED_CODE();

    //
    // open the given parameter
    //
    status = IoOpenDeviceRegistryKey(fdoExtension->LowerPdo,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_READ,
                                     &deviceParameterHandle);

    if(NT_SUCCESS(status)) {

        RtlZeroMemory(queryTable, sizeof(queryTable));

        defaultParameterValue = *ParameterValue;

        queryTable->Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
        queryTable->Name          = ParameterName;
        queryTable->EntryContext  = ParameterValue;
        queryTable->DefaultType   = REG_NONE;
        queryTable->DefaultData   = NULL;
        queryTable->DefaultLength = 0;

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) deviceParameterHandle,
                                        queryTable,
                                        NULL,
                                        NULL);
        if (!NT_SUCCESS(status)) {

            *ParameterValue = defaultParameterValue;
        }

        //
        // close what we open
        //
        ZwClose(deviceParameterHandle);
    }

    return status;

} // CdRomGetDeviceParameter


NTSTATUS
CdRomSetDeviceParameter (
    IN PDEVICE_OBJECT Fdo,
    IN PWSTR          ParameterName,
    IN ULONG          ParameterValue
    )
/*++

Routine Description:

    save a devnode registry parameter

Arguments:

    DeviceObject - Cdrom Device Object

    ParameterName - parameter name

    ParameterValuse - parameter value

Return Value:

    NT Status

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;

    PAGED_CODE();

    //
    // open the given parameter
    //
    status = IoOpenDeviceRegistryKey(fdoExtension->LowerPdo,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_READ | KEY_WRITE,
                                     &deviceParameterHandle);

    if(NT_SUCCESS(status)) {

        status = RtlWriteRegistryValue(
                    RTL_REGISTRY_HANDLE,
                    (PWSTR) deviceParameterHandle,
                    ParameterName,
                    REG_DWORD,
                    &ParameterValue,
                    sizeof (ParameterValue));

        //
        // close what we open
        //
        ZwClose(deviceParameterHandle);
    }

    return status;

} // CdromSetDeviceParameter


VOID
CdRomPickDvdRegion(
    IN PDEVICE_OBJECT Fdo
    )
/*++

Routine Description:

    pick a default dvd region

Arguments:

    DeviceObject - Cdrom Device Object

Return Value:

    NT Status

--*/
{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cddata = (PCDROM_DATA)(commonExtension->DriverData);

    //
    // these five pointers all point to dvdReadStructure or part of
    // its data, so don't deallocate them more than once!
    //

    PDVD_READ_STRUCTURE dvdReadStructure;
    PDVD_COPY_PROTECT_KEY copyProtectKey;
    PDVD_COPYRIGHT_DESCRIPTOR dvdCopyRight;
    PDVD_RPC_KEY rpcKey;
    PDVD_SET_RPC_KEY dvdRpcKey;

    IO_STATUS_BLOCK ioStatus = {0};
    ULONG bufferLen;
    UCHAR mediaRegion;
    ULONG pickDvdRegion;
    ULONG defaultDvdRegion;
    ULONG dvdRegion;

    PAGED_CODE();

    if ((pickDvdRegion = InterlockedExchange(&cddata->PickDvdRegion, 0)) == 0) {

        //
        // it was non-zero, so either another thread will do this, or
        // we no longer need to pick a region
        //

        return;
    }

    //
    // short-circuit if license agreement violated
    //

    if (cddata->DvdRpc0LicenseFailure) {
        TraceLog((CdromDebugWarning,
                    "DVD License failure.  Refusing to pick a region\n"));
        InterlockedExchange(&cddata->PickDvdRegion, 0);
        return;
    }


    bufferLen = max(
                    max(sizeof(DVD_DESCRIPTOR_HEADER) +
                            sizeof(DVD_COPYRIGHT_DESCRIPTOR),
                        sizeof(DVD_READ_STRUCTURE)
                        ),
                    max(DVD_RPC_KEY_LENGTH,
                        DVD_SET_RPC_KEY_LENGTH
                        )
                    );

    dvdReadStructure = (PDVD_READ_STRUCTURE)
        ExAllocatePoolWithTag(PagedPool, bufferLen, DVD_TAG_DVD_REGION);

    if (dvdReadStructure == NULL) {
        InterlockedExchange(&cddata->PickDvdRegion, pickDvdRegion);
        return;
    }

    if (cddata->DvdRpc0Device && cddata->Rpc0RetryRegistryCallback) {

        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): now retrying RPC0 callback\n",
                    Fdo));

        //
        // get the registry settings again
        //

        ioStatus.Status = CdRomGetRpc0Settings(Fdo);

        if (ioStatus.Status == STATUS_LICENSE_VIOLATION) {

            //
            // if this is the returned error, then
            // the routine should have set this!
            //

            ASSERT(cddata->DvdRpc0LicenseFailure);
            cddata->DvdRpc0LicenseFailure = 1;
            TraceLog((CdromDebugWarning,
                        "CdRomPickDvdRegion (%p): "
                        "setting to fail all dvd ioctls due to CSS licensing "
                        "failure.\n", Fdo));

            pickDvdRegion = 0;
            goto getout;

        }

        //
        // get the device region, again
        //

        copyProtectKey = (PDVD_COPY_PROTECT_KEY)dvdReadStructure;
        RtlZeroMemory(copyProtectKey, bufferLen);
        copyProtectKey->KeyLength = DVD_RPC_KEY_LENGTH;
        copyProtectKey->KeyType = DvdGetRpcKey;

        //
        // Build a request for READ_KEY
        //

        ClassSendDeviceIoControlSynchronous(
            IOCTL_DVD_READ_KEY,
            Fdo,
            copyProtectKey,
            DVD_RPC_KEY_LENGTH,
            DVD_RPC_KEY_LENGTH,
            FALSE,
            &ioStatus);

        if (!NT_SUCCESS(ioStatus.Status)) {
            TraceLog((CdromDebugWarning,
                        "CdRomPickDvdRegion: Unable to get "
                        "device RPC data (%x)\n", ioStatus.Status));
            pickDvdRegion = 0;
            goto getout;
        }

        //
        // now that we have gotten the device's RPC data,
        // we have set the device extension to usable data.
        // no need to call back into this section of code again
        //

        cddata->Rpc0RetryRegistryCallback = 0;


        rpcKey = (PDVD_RPC_KEY) copyProtectKey->KeyData;

        //
        // TypeCode of zero means that no region has been set.
        //

        if (rpcKey->TypeCode != 0) {
            TraceLog((CdromDebugWarning,
                        "CdRomPickDvdRegion (%p): DVD Region already "
                        "chosen\n", Fdo));
            pickDvdRegion = 0;
            goto getout;
        }

        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): must choose initial DVD "
                    " Region\n", Fdo));
    }



    copyProtectKey = (PDVD_COPY_PROTECT_KEY) dvdReadStructure;

    dvdCopyRight = (PDVD_COPYRIGHT_DESCRIPTOR)
        ((PDVD_DESCRIPTOR_HEADER) dvdReadStructure)->Data;

    //
    // get the media region
    //

    RtlZeroMemory (dvdReadStructure, bufferLen);
    dvdReadStructure->Format = DvdCopyrightDescriptor;

    //
    // Build and send a request for READ_KEY
    //

    TraceLog((CdromDebugTrace,
                "CdRomPickDvdRegion (%p): Getting Copyright Descriptor\n",
                Fdo));

    ClassSendDeviceIoControlSynchronous(
        IOCTL_DVD_READ_STRUCTURE,
        Fdo,
        dvdReadStructure,
        sizeof(DVD_READ_STRUCTURE),
        sizeof (DVD_DESCRIPTOR_HEADER) +
        sizeof(DVD_COPYRIGHT_DESCRIPTOR),
        FALSE,
        &ioStatus
        );
    TraceLog((CdromDebugTrace,
                "CdRomPickDvdRegion (%p): Got Copyright Descriptor %x\n",
                Fdo, ioStatus.Status));

    if ((NT_SUCCESS(ioStatus.Status)) &&
        (dvdCopyRight->CopyrightProtectionType == 0x01)
        ) {

        //
        // keep the media region bitmap around
        // a 1 means ok to play
        //

        if (dvdCopyRight->RegionManagementInformation == 0xff) {
            TraceLog((CdromDebugError,
                      "CdRomPickDvdRegion (%p): RegionManagementInformation "
                      "is set to dis-allow playback for all regions.  This is "
                      "most likely a poorly authored disc.  defaulting to all "
                      "region disc for purpose of choosing initial region\n",
                      Fdo));
            dvdCopyRight->RegionManagementInformation = 0;
        }


        mediaRegion = ~dvdCopyRight->RegionManagementInformation;

    } else {

        //
        // could be media, can't set the device region
        //

        if (!cddata->DvdRpc0Device) {

            //
            // can't automatically pick a default region on a rpc2 drive
            // without media, so just exit
            //
            TraceLog((CdromDebugWarning,
                        "CdRomPickDvdRegion (%p): failed to auto-choose "
                        "a region due to status %x getting copyright "
                        "descriptor\n", Fdo, ioStatus.Status));
            goto getout;

        } else {

            //
            // for an RPC0 drive, we can try to pick a region for
            // the drive
            //

            mediaRegion = 0x0;
        }

    }

    //
    // get the device region
    //

    RtlZeroMemory (copyProtectKey, bufferLen);
    copyProtectKey->KeyLength = DVD_RPC_KEY_LENGTH;
    copyProtectKey->KeyType = DvdGetRpcKey;

    //
    // Build and send a request for READ_KEY for RPC key
    //

    TraceLog((CdromDebugTrace,
                "CdRomPickDvdRegion (%p): Getting RpcKey\n",
                Fdo));
    ClassSendDeviceIoControlSynchronous(
        IOCTL_DVD_READ_KEY,
        Fdo,
        copyProtectKey,
        DVD_RPC_KEY_LENGTH,
        DVD_RPC_KEY_LENGTH,
        FALSE,
        &ioStatus
        );
    TraceLog((CdromDebugTrace,
                "CdRomPickDvdRegion (%p): Got RpcKey %x\n",
                Fdo, ioStatus.Status));

    if (!NT_SUCCESS(ioStatus.Status)) {

        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): failed to get RpcKey from "
                    "a DVD Device\n", Fdo));
        goto getout;

    }

    //
    // so we now have what we can get for the media region and the
    // drive region.  we will not set a region if the drive has one
    // set already (mask is not all 1's), nor will we set a region
    // if there are no more user resets available.
    //

    rpcKey = (PDVD_RPC_KEY) copyProtectKey->KeyData;


    if (rpcKey->RegionMask != 0xff) {
        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): not picking a region since "
                    "it is already chosen\n", Fdo));
        goto getout;
    }

    if (rpcKey->UserResetsAvailable <= 1) {
        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): not picking a region since "
                    "only one change remains\n", Fdo));
        goto getout;
    }

    defaultDvdRegion = 0;

    //
    // the proppage dvd class installer sets
    // this key based upon the system locale
    //

    CdRomGetDeviceParameter (
        Fdo,
        DVD_DEFAULT_REGION,
        &defaultDvdRegion
        );

    if (defaultDvdRegion > DVD_MAX_REGION) {

        //
        // the registry has a bogus default
        //

        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): registry has a bogus default "
                    "region value of %x\n", Fdo, defaultDvdRegion));
        defaultDvdRegion = 0;

    }

    //
    // if defaultDvdRegion == 0, it means no default.
    //

    //
    // we will select the initial dvd region for the user
    //

    if ((defaultDvdRegion != 0) &&
        (mediaRegion &
         (1 << (defaultDvdRegion - 1))
         )
        ) {

        //
        // first choice:
        // the media has region that matches
        // the default dvd region.
        //

        dvdRegion = (1 << (defaultDvdRegion - 1));

        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): Choice #1: media matches "
                    "drive's default, chose region %x\n", Fdo, dvdRegion));


    } else if (mediaRegion) {

        //
        // second choice:
        // pick the lowest region number
        // from the media
        //

        UCHAR mask;

        mask = 1;
        dvdRegion = 0;
        while (mediaRegion && !dvdRegion) {

            //
            // pick the lowest bit
            //
            dvdRegion = mediaRegion & mask;
            mask <<= 1;
        }

        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): Choice #2: choosing lowest "
                    "media region %x\n", Fdo, dvdRegion));

    } else if (defaultDvdRegion) {

        //
        // third choice:
        // default dvd region from the dvd class installer
        //

        dvdRegion = (1 << (defaultDvdRegion - 1));
        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): Choice #3: using default "
                    "region for this install %x\n", Fdo, dvdRegion));

    } else {

        //
        // unable to pick one for the user -- this should rarely
        // happen, since the proppage dvd class installer sets
        // the key based upon the system locale
        //
        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): Choice #4: failed to choose "
                    "a media region\n", Fdo));
        goto getout;

    }

    //
    // now that we've chosen a region, set the region by sending the
    // appropriate request to the drive
    //

    RtlZeroMemory (copyProtectKey, bufferLen);
    copyProtectKey->KeyLength = DVD_SET_RPC_KEY_LENGTH;
    copyProtectKey->KeyType = DvdSetRpcKey;
    dvdRpcKey = (PDVD_SET_RPC_KEY) copyProtectKey->KeyData;
    dvdRpcKey->PreferredDriveRegionCode = (UCHAR) ~dvdRegion;

    //
    // Build and send request for SEND_KEY
    //
    TraceLog((CdromDebugTrace,
                "CdRomPickDvdRegion (%p): Sending new Rpc Key to region %x\n",
                Fdo, dvdRegion));

    ClassSendDeviceIoControlSynchronous(
        IOCTL_DVD_SEND_KEY2,
        Fdo,
        copyProtectKey,
        DVD_SET_RPC_KEY_LENGTH,
        0,
        FALSE,
        &ioStatus);
    TraceLog((CdromDebugTrace,
                "CdRomPickDvdRegion (%p): Sent new Rpc Key %x\n",
                Fdo, ioStatus.Status));

    if (!NT_SUCCESS(ioStatus.Status)) {
        DebugPrint ((1, "CdRomPickDvdRegion (%p): unable to set dvd initial "
                     " region code (%p)\n", Fdo, ioStatus.Status));
    } else {
        DebugPrint ((1, "CdRomPickDvdRegion (%p): Successfully set dvd "
                     "initial region\n", Fdo));
        pickDvdRegion = 0;
    }

getout:
    if (dvdReadStructure) {
        ExFreePool (dvdReadStructure);
    }

    //
    // update the new PickDvdRegion value
    //

    InterlockedExchange(&cddata->PickDvdRegion, pickDvdRegion);

    return;
}


NTSTATUS
CdRomRetryRequest(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PIRP Irp,
    IN ULONG Delay,
    IN BOOLEAN ResendIrp
    )
{
    PCDROM_DATA cdData;
    KIRQL oldIrql;

    if(Delay == 0) {
        return CdRomRerunRequest(FdoExtension, Irp, ResendIrp);
    }

    cdData = FdoExtension->CommonExtension.DriverData;

    KeAcquireSpinLock(&(cdData->DelayedRetrySpinLock), &oldIrql);

    ASSERT(cdData->DelayedRetryIrp == NULL);
    ASSERT(cdData->DelayedRetryInterval == 0);

    cdData->DelayedRetryIrp = Irp;
    cdData->DelayedRetryInterval = Delay;
    cdData->DelayedRetryResend = ResendIrp;

    KeReleaseSpinLock(&(cdData->DelayedRetrySpinLock), oldIrql);

    return STATUS_PENDING;
}


NTSTATUS
CdRomRerunRequest(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN OPTIONAL PIRP Irp,
    IN BOOLEAN ResendIrp
    )
{
    if(ResendIrp) {
        return IoCallDriver(FdoExtension->CommonExtension.LowerDeviceObject,
                            Irp);
    } else {
        KIRQL oldIrql;

        oldIrql = KeRaiseIrqlToDpcLevel();
        CdRomStartIo(FdoExtension->DeviceObject, Irp);
        KeLowerIrql(oldIrql);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
}


/*++

Routine Description:

    This routine just checks for media change sense/asc/ascq and
    also for other events, such as bus resets.  this is used to
    determine if the device behaviour has changed, to allow for
    read and write operations to be allowed and/or disallowed.

Arguments:

    ISSUE-2000/3/30-henrygab - not fully doc'd

Return Value:

    NTSTATUS

--*/
NTSTATUS
CdRomMmcErrorHandler(
    IN PDEVICE_OBJECT Fdo,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PNTSTATUS Status,
    OUT PBOOLEAN Retry
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    BOOLEAN queryCapabilities = FALSE;

    if (TEST_FLAG(Srb->SrbStatus, SRB_STATUS_AUTOSENSE_VALID)) {

        PCDROM_DATA cddata = (PCDROM_DATA)commonExtension->DriverData;
        PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;

        //
        // the following sense keys could indicate a change in
        // capabilities.
        //

        //
        // we used to expect this to be serialized, and only hit from our
        // own routine. we now allow some requests to continue during our
        // processing of the capabilities update in order to allow
        // IoReadPartitionTable() to succeed.
        //

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY: {
            if (senseBuffer->AdditionalSenseCode ==
                SCSI_ADSENSE_NO_MEDIA_IN_DEVICE) {

                if (cddata->Mmc.WriteAllowed) {
                    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                               "CdromErrorHandler: media removed, writes will be "
                               "failed until new media detected\n"));
                }

                // NOTE - REF #0002
                cddata->Mmc.WriteAllowed = FALSE;
            } else
            if (senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY) {

                if (senseBuffer->AdditionalSenseCodeQualifier ==
                    SCSI_SENSEQ_BECOMING_READY) {
                    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                               "CdromErrorHandler: media becoming ready, "
                               "SHOULD notify shell of change time by sending "
                               "GESN request immediately!\n"));
                } else if (((senseBuffer->AdditionalSenseCodeQualifier ==
                             SCSI_SENSEQ_OPERATION_IN_PROGRESS) ||
                            (senseBuffer->AdditionalSenseCodeQualifier ==
                             SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS)
                            ) &&
                           ((Srb->Cdb[0] == SCSIOP_READ) ||
                            (Srb->Cdb[0] == SCSIOP_READ6) ||
                            (Srb->Cdb[0] == SCSIOP_READ_CAPACITY) ||
                            (Srb->Cdb[0] == SCSIOP_READ_CD) ||
                            (Srb->Cdb[0] == SCSIOP_READ_CD_MSF) ||
                            (Srb->Cdb[0] == SCSIOP_READ_TOC) ||
                            (Srb->Cdb[0] == SCSIOP_WRITE) ||
                            (Srb->Cdb[0] == SCSIOP_WRITE6) ||
                            (Srb->Cdb[0] == SCSIOP_READ_TRACK_INFORMATION) ||
                            (Srb->Cdb[0] == SCSIOP_READ_DISK_INFORMATION)
                            )
                           ) {
                    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                               "CdromErrorHandler: LONG_WRITE or "
                               "OP_IN_PROGRESS for limited subset of cmds -- "
                               "setting retry to TRUE\n"));
                    *Retry = TRUE;
                    *Status = STATUS_DEVICE_BUSY;
                }
            }
            break;
        } // end SCSI_SENSE_NOT_READY

        case SCSI_SENSE_UNIT_ATTENTION: {
            switch (senseBuffer->AdditionalSenseCode) {
            case SCSI_ADSENSE_MEDIUM_CHANGED: {

                //
                // always update if the medium may have changed
                //

                // NOTE - REF #0002
                cddata->Mmc.WriteAllowed = FALSE;
                InterlockedCompareExchange(&(cddata->Mmc.UpdateState),
                                           CdromMmcUpdateRequired,
                                           CdromMmcUpdateComplete);

                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                           "CdromErrorHandler: media change detected, need to "
                           "update drive capabilities\n"));
                break;

            } // end SCSI_ADSENSE_MEDIUM_CHANGED

            case SCSI_ADSENSE_BUS_RESET: {

                // NOTE - REF #0002
                cddata->Mmc.WriteAllowed = FALSE;
                InterlockedCompareExchange(&(cddata->Mmc.UpdateState),
                                           CdromMmcUpdateRequired,
                                           CdromMmcUpdateComplete);

                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                           "CdromErrorHandler: bus reset detected, need to "
                           "update drive capabilities\n"));
                break;

            } // end SCSI_ADSENSE_BUS_RESET

            case SCSI_ADSENSE_OPERATOR_REQUEST: {

                BOOLEAN b = FALSE;

                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                case SCSI_SENSEQ_MEDIUM_REMOVAL: {

                    //
                    // eject notification currently handled by classpnp
                    //

                    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                               "CdromErrorHandler: Eject requested by user\n"));
                    *Retry = TRUE;
                    *Status = STATUS_DEVICE_BUSY;
                    break;
                }

                case SCSI_SENSEQ_WRITE_PROTECT_DISABLE:
                    b = TRUE;
                case SCSI_SENSEQ_WRITE_PROTECT_ENABLE: {

                    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                               "CdromErrorHandler: Write protect %s requested "
                               "by user\n",
                               (b ? "disable" : "enable")));
                    *Retry = TRUE;
                    *Status = STATUS_DEVICE_BUSY;
                    // NOTE - REF #0002
                    cddata->Mmc.WriteAllowed = FALSE;
                    InterlockedCompareExchange(&(cddata->Mmc.UpdateState),
                                               CdromMmcUpdateRequired,
                                               CdromMmcUpdateComplete);
                    break;

                }

                } // end of AdditionalSenseCodeQualifier switch


                break;

            } // end SCSI_ADSENSE_OPERATOR_REQUEST

            default: {
                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                           "CdromErrorHandler: Unit attention %02x/%02x\n",
                           senseBuffer->AdditionalSenseCode,
                           senseBuffer->AdditionalSenseCodeQualifier));
                break;
            }

            } // end of AdditionSenseCode switch
            break;

        } // end SCSI_SENSE_UNIT_ATTENTION

        case SCSI_SENSE_ILLEGAL_REQUEST: {
            if (senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_WRITE_PROTECT) {

                if (cddata->Mmc.WriteAllowed) {
                    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                               "CdromErrorHandler: media was writable, but "
                               "failed request with WRITE_PROTECT error...\n"));
                }
                // NOTE - REF #0002
                // do not update all the capabilities just because
                // we can't write to the disc.
                cddata->Mmc.WriteAllowed = FALSE;
            }
            break;
        } // end SCSI_SENSE_ILLEGAL_REQUEST

        } // end of SenseKey switch

    } // end of SRB_STATUS_AUTOSENSE_VALID

    return STATUS_SUCCESS;
}

/*++

Routine Description:

    This routine checks for a device-specific error handler
    and calls it if it exists.  This allows multiple drives
    that require their own error handler to co-exist.

--*/
VOID
CdRomErrorHandler(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PCDROM_DATA cddata = (PCDROM_DATA)commonExtension->DriverData;
    PSENSE_DATA sense = Srb->SenseInfoBuffer;

    if ((Srb->SenseInfoBufferLength >=
         RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA,AdditionalSenseCodeQualifier)) &&
        TEST_FLAG(Srb->SrbStatus, SRB_STATUS_AUTOSENSE_VALID)) {

        //
        //  Many non-WHQL certified drives (mostly CD-RW) return
        //  2/4/0 when they have no media instead of the obvious
        //  choice of:
        //
        //      SCSI_SENSE_NOT_READY/SCSI_ADSENSE_NO_MEDIA_IN_DEVICE
        //
        //  These drives should not pass WHQL certification due
        //  to this discrepency.
        //
        //  However, we have to retry on 2/4/0 (Not ready, LUN not ready,
        //  no info) and also 3/2/0 (no seek complete).
        //
        //  These conditions occur when the shell tries to examine an
        //  injected CD (e.g. for autoplay) before the CD is spun up.
        //
        //  The drive should be returning an ASCQ of SCSI_SENSEQ_BECOMING_READY
        //  (0x01) in order to comply with WHQL standards.
        //
        //  The default retry timeout of one second is acceptable to balance
        //  these discrepencies.  don't modify the status, though....
        //

        if (((sense->SenseKey & 0xf) == SCSI_SENSE_NOT_READY) &&
            (sense->AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY) &&
            (sense->AdditionalSenseCodeQualifier == SCSI_SENSEQ_CAUSE_NOT_REPORTABLE)
            ) {

            *Retry = TRUE;

        } else if (((sense->SenseKey & 0xf) == SCSI_SENSE_MEDIUM_ERROR) &&
                   (sense->AdditionalSenseCode == SCSI_ADSENSE_NO_SEEK_COMPLETE) &&
                   (sense->AdditionalSenseCodeQualifier == 0x00)
                   ) {

            *Retry = TRUE;

        } else if ((sense->AdditionalSenseCode == 0x57) &&
                   (sense->AdditionalSenseCodeQualifier == 0x00)
                   ) {

            //
            // UNABLE_TO_RECOVER_TABLE_OF_CONTENTS
            // the Matshita CR-585 returns this for all read commands
            // on blank CD-R and CD-RW media, and we need to handle
            // this for READ_CD detection ability.
            //

            *Retry = FALSE;
            *Status = STATUS_UNRECOGNIZED_MEDIA;

        }

    }

    //
    // tail recursion in both cases takes no stack
    //

    if (cddata->ErrorHandler) {
        cddata->ErrorHandler(DeviceObject, Srb, Status, Retry);
    }
    return;
}


/*++

Routine Description:

    This routine is called for a shutdown and flush IRPs.
    These are sent by the system before it actually shuts
    down or when the file system does a flush.

Arguments:

    DriverObject - Pointer to device object to being shutdown by system.

    Irp - IRP involved.

Return Value:

    NT Status

--*/
NTSTATUS
CdRomShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    IoMarkIrpPending(Irp);
    IoStartPacket(DeviceObject, Irp, NULL, NULL);
    return STATUS_PENDING;

}

/*++

Routine Description:

    This routine is called for intermediate work a shutdown or
    flush IRPs would need to do.  We just want to free our resources
    and return STATUS_MORE_PROCESSING_REQUIRED.

Arguments:

    DeviceObject - NULL?

    Irp - IRP to free

    Context - NULL

Return Value:

    NT Status

--*/
NTSTATUS
CdRomShutdownFlushCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP NewIrp,
    IN PIRP OriginalIrp
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION originalIrpStack;
    ULONG_PTR iteration;
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT(OriginalIrp);

    originalIrpStack = IoGetCurrentIrpStackLocation(OriginalIrp);

    //
    // always use a new irp so we can call
    // CdRomCompleteIrpAndStartNextPacketSafely() from this routine.
    //

    if (NewIrp != NULL) {
        status = NewIrp->IoStatus.Status;
        IoFreeIrp(NewIrp);
        NewIrp = NULL;
    }

    if (!NT_SUCCESS(status)) {
        BAIL_OUT(OriginalIrp);
        goto SafeExit;
    }

    //
    // the current irpstack saves the counter which states
    // what part of the multi-part shutdown or flush we are in.
    //

    iteration = (ULONG_PTR)originalIrpStack->Parameters.Others.Argument1;
    iteration++;
    originalIrpStack->Parameters.Others.Argument1 = (PVOID)iteration;

    switch (iteration) {
    case 2:
        if (originalIrpStack->MajorFunction != IRP_MJ_SHUTDOWN) {
            //
            // then we don't want to send the unlock command
            // the incrementing of the state was done above.
            // return the completion routine's result.
            //
            return CdRomShutdownFlushCompletion(Fdo, NULL, OriginalIrp);
        }
        // else fall through....

    case 1: {

        PIRP                newIrp = NULL;
        PSCSI_REQUEST_BLOCK newSrb = NULL;
        PCDB                newCdb = NULL;
        PIO_STACK_LOCATION  newIrpStack = NULL;
        ULONG               isRemoved;

        newIrp = IoAllocateIrp((CCHAR)(Fdo->StackSize+1), FALSE);
        if (newIrp == NULL) {
            BAIL_OUT(OriginalIrp);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto SafeExit;
        }
        newSrb = ExAllocatePoolWithTag(NonPagedPool,
                                        sizeof(SCSI_REQUEST_BLOCK),
                                        CDROM_TAG_SRB);
        if (newSrb == NULL) {
            IoFreeIrp(newIrp);
            BAIL_OUT(OriginalIrp);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto SafeExit;
        }

        //
        // ClassIoComplete will free the SRB, but we need a routine
        // that will free the irp.  then just call ClassSendAsync,
        // and don't care about the return value, since the completion
        // routine will be called anyways.
        //

        IoSetNextIrpStackLocation(newIrp);
        newIrpStack = IoGetCurrentIrpStackLocation(newIrp);
        newIrpStack->DeviceObject = Fdo;
        IoSetCompletionRoutine(newIrp,
                               CdRomShutdownFlushCompletion,
                               OriginalIrp,
                               TRUE, TRUE, TRUE);
        IoSetNextIrpStackLocation(newIrp);
        newIrpStack = IoGetCurrentIrpStackLocation(newIrp);
        newIrpStack->DeviceObject = Fdo;

        //
        // setup the request
        //

        RtlZeroMemory(newSrb, sizeof(SCSI_REQUEST_BLOCK));
        newCdb = (PCDB)(newSrb->Cdb);

        newSrb->QueueTag = SP_UNTAGGED;
        newSrb->QueueAction = SRB_SIMPLE_TAG_REQUEST;
        newSrb->Function = SRB_FUNCTION_EXECUTE_SCSI;

        //
        // tell classpnp not to call StartNextPacket()
        //

        newSrb->SrbFlags = SRB_FLAGS_DONT_START_NEXT_PACKET;

        if (iteration == 1) {

            //
            // first synchronize the cache
            //

            newSrb->TimeOutValue = fdoExtension->TimeOutValue * 4;
            newSrb->CdbLength = 10;
            newCdb->SYNCHRONIZE_CACHE10.OperationCode = SCSIOP_SYNCHRONIZE_CACHE;

        } else if (iteration == 2) {

            //
            // then unlock the medium
            //

            ASSERT( originalIrpStack->MajorFunction == IRP_MJ_SHUTDOWN );

            newSrb->TimeOutValue = fdoExtension->TimeOutValue;
            newSrb->CdbLength = 6;
            newCdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            newCdb->MEDIA_REMOVAL.Prevent = FALSE;

        }


        isRemoved = ClassAcquireRemoveLock(Fdo, newIrp);
        if (isRemoved) {
            IoFreeIrp(newIrp);
            ExFreePool(newSrb);
            ClassReleaseRemoveLock(Fdo, newIrp);
            BAIL_OUT(OriginalIrp);
            status = STATUS_DEVICE_DOES_NOT_EXIST;
            goto SafeExit;
        }
        ClassSendSrbAsynchronous(Fdo, newSrb, newIrp, NULL, 0, FALSE);
        break;
    }

    case 3: {

        PSCSI_REQUEST_BLOCK srb;
        PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(OriginalIrp);

        //
        // forward this request to the device appropriately,
        // don't use this completion routine anymore...
        //

        srb = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(SCSI_REQUEST_BLOCK),
                                    CDROM_TAG_SRB);
        if (srb == NULL) {
            BAIL_OUT(OriginalIrp);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto SafeExit;
        }

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        srb->Length = SCSI_REQUEST_BLOCK_SIZE;
        srb->TimeOutValue = fdoExtension->TimeOutValue * 4;
        srb->QueueTag = SP_UNTAGGED;
        srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;
        srb->SrbFlags = fdoExtension->SrbFlags;
        srb->CdbLength = 0;
        srb->OriginalRequest = OriginalIrp;

        if (originalIrpStack->MajorFunction == IRP_MJ_SHUTDOWN) {
            srb->Function = SRB_FUNCTION_SHUTDOWN;
        } else {
            srb->Function = SRB_FUNCTION_FLUSH;
        }

        //
        // Set up IoCompletion routine address.
        //

        IoSetCompletionRoutine(OriginalIrp,
                               ClassIoComplete,
                               srb,
                               TRUE, TRUE, TRUE);

        //
        // Set the retry count to zero.
        //

        originalIrpStack->Parameters.Others.Argument4 = (PVOID) 0;

        //
        // Get next stack location and set major function code.
        //

        nextIrpStack->MajorFunction = IRP_MJ_SCSI;

        //
        // Set up SRB for execute scsi request.
        // Save SRB address in next stack for port driver.
        //

        nextIrpStack->Parameters.Scsi.Srb = srb;

        //
        // Call the port driver to process the request.
        //

        IoCallDriver(commonExtension->LowerDeviceObject, OriginalIrp);

        break;

    }
    default: {
        ASSERT(FALSE);
        break;
    }

    } // end switch

    status = STATUS_SUCCESS;

SafeExit:

    if (!NT_SUCCESS(status)) {
        OriginalIrp->IoStatus.Status = status;
        CdRomCompleteIrpAndStartNextPacketSafely(Fdo, OriginalIrp);
    }

    //
    // always return STATUS_MORE_PROCESSING_REQUIRED, so noone else tries
    // to access the new irp that we free'd....
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // end CdromShutdownFlush()


VOID
CdromFakePartitionInfo(
    IN PCOMMON_DEVICE_EXTENSION CommonExtension,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG ioctl = currentIrpStack->Parameters.DeviceIoControl.IoControlCode;
    PVOID systemBuffer = Irp->AssociatedIrp.SystemBuffer;

    ASSERT(systemBuffer);

    if ((ioctl != IOCTL_DISK_GET_DRIVE_LAYOUT) &&
        (ioctl != IOCTL_DISK_GET_DRIVE_LAYOUT_EX) &&
        (ioctl != IOCTL_DISK_GET_PARTITION_INFO) &&
        (ioctl != IOCTL_DISK_GET_PARTITION_INFO_EX)) {
        TraceLog((CdromDebugError,
                    "CdromFakePartitionInfo: unhandled ioctl %x\n", ioctl));
        Irp->IoStatus.Status = STATUS_INTERNAL_ERROR;
        Irp->IoStatus.Information = 0;
        CdRomCompleteIrpAndStartNextPacketSafely(CommonExtension->DeviceObject,
                                                 Irp);
        return;
    }

    //
    // nothing to fail from this point on, so set the size appropriately
    // and set irp's status to success.
    //

    TraceLog((CdromDebugWarning,
                "CdromFakePartitionInfo: incoming ioctl %x\n", ioctl));


    Irp->IoStatus.Status = STATUS_SUCCESS;
    switch (ioctl) {
    case IOCTL_DISK_GET_DRIVE_LAYOUT:
        Irp->IoStatus.Information = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION,
                                                 PartitionEntry[1]);
        RtlZeroMemory(systemBuffer, FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION,
                                                 PartitionEntry[1]));
        break;
    case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:
        Irp->IoStatus.Information = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX,
                                                 PartitionEntry[1]);
        RtlZeroMemory(systemBuffer, FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX,
                                                 PartitionEntry[1]));
        break;
    case IOCTL_DISK_GET_PARTITION_INFO:
        Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);
        RtlZeroMemory(systemBuffer, sizeof(PARTITION_INFORMATION));
        break;
    case IOCTL_DISK_GET_PARTITION_INFO_EX:
        Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION_EX);
        RtlZeroMemory(systemBuffer, sizeof(PARTITION_INFORMATION_EX));
        break;
    default:
        ASSERT(!"Invalid ioctl should not have reached this point\n");
        break;
    }

    //
    // if we are getting the drive layout, then we need to start by
    // adding some of the non-partition stuff that says we have
    // exactly one partition available.
    //


    if (ioctl == IOCTL_DISK_GET_DRIVE_LAYOUT) {

        PDRIVE_LAYOUT_INFORMATION layout;
        layout = (PDRIVE_LAYOUT_INFORMATION)systemBuffer;
        layout->PartitionCount = 1;
        layout->Signature = 1;
        systemBuffer = (PVOID)(layout->PartitionEntry);
        ioctl = IOCTL_DISK_GET_PARTITION_INFO;

    } else if (ioctl == IOCTL_DISK_GET_DRIVE_LAYOUT_EX) {

        PDRIVE_LAYOUT_INFORMATION_EX layoutEx;
        layoutEx = (PDRIVE_LAYOUT_INFORMATION_EX)systemBuffer;
        layoutEx->PartitionStyle = PARTITION_STYLE_MBR;
        layoutEx->PartitionCount = 1;
        layoutEx->Mbr.Signature = 1;
        systemBuffer = (PVOID)(layoutEx->PartitionEntry);
        ioctl = IOCTL_DISK_GET_PARTITION_INFO_EX;

    }

    //
    // NOTE: the local var 'ioctl' is now modified to either EX or
    // non-EX version. the local var 'systemBuffer' is now pointing
    // to the partition information structure.
    //

    if (ioctl == IOCTL_DISK_GET_PARTITION_INFO) {

        PPARTITION_INFORMATION partitionInfo;
        partitionInfo = (PPARTITION_INFORMATION)systemBuffer;
        partitionInfo->RewritePartition = FALSE;
        partitionInfo->RecognizedPartition = TRUE;
        partitionInfo->PartitionType = PARTITION_FAT32;
        partitionInfo->BootIndicator = FALSE;
        partitionInfo->HiddenSectors = 0;
        partitionInfo->StartingOffset.QuadPart = 0;
        partitionInfo->PartitionLength = CommonExtension->PartitionLength;
        partitionInfo->PartitionNumber = 0;

    } else {

        PPARTITION_INFORMATION_EX partitionInfo;
        partitionInfo = (PPARTITION_INFORMATION_EX)systemBuffer;
        partitionInfo->PartitionStyle = PARTITION_STYLE_MBR;
        partitionInfo->RewritePartition = FALSE;
        partitionInfo->Mbr.RecognizedPartition = TRUE;
        partitionInfo->Mbr.PartitionType = PARTITION_FAT32;
        partitionInfo->Mbr.BootIndicator = FALSE;
        partitionInfo->Mbr.HiddenSectors = 0;
        partitionInfo->StartingOffset.QuadPart = 0;
        partitionInfo->PartitionLength = CommonExtension->PartitionLength;
        partitionInfo->PartitionNumber = 0;

    }
    TraceLog((CdromDebugWarning,
                "CdromFakePartitionInfo: finishing ioctl %x\n",
                currentIrpStack->Parameters.DeviceIoControl.IoControlCode));

    //
    // complete the irp
    //

    CdRomCompleteIrpAndStartNextPacketSafely(CommonExtension->DeviceObject,
                                             Irp);
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\cdrom\cdrom.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    cdromp.h

Abstract:

    Private header file for cdrom.sys.  This contains private
    structure and function declarations as well as constant
    values which do not need to be exported.

Author:

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#ifndef __CDROMP_H__
#define __CDROMP_H__

#include "ntddmmc.h"
#include "trace.h"

extern CLASSPNP_SCAN_FOR_SPECIAL_INFO CdromHackItems[];

typedef enum {
    CdromDebugError     = 0,  // always printed
    CdromDebugWarning   = 1,  // set bit 0x00000001 in nt!kd_cdrom_mask
    CdromDebugTrace     = 2,  // set bit 0x00000002 in nt!kd_cdrom_mask
    CdromDebugInfo      = 3,  // set bit 0x00000004 in nt!kd_cdrom_mask
#if 0
    CdromDebug          = z,  // set bit 0x00000000 in nt!kd_cdrom_mask
    CdromDebug          = z,  // set bit 0x00000000 in nt!kd_cdrom_mask
    CdromDebug          = z,  // set bit 0x00000000 in nt!kd_cdrom_mask
    CdromDebug          = z,  // set bit 0x00000000 in nt!kd_cdrom_mask
#endif 0
    CdromDebugFeatures  = 32  // set bit 0x80000000 in nt!kd_cdrom_mask
};

#define CDROM_GET_CONFIGURATION_TIMEOUT    (0x4)

#define CDROM_HACK_DEC_RRD                 (0x00000001)
#define CDROM_HACK_FUJITSU_FMCD_10x        (0x00000002)
#define CDROM_HACK_HITACHI_1750            (0x00000004)
#define CDROM_HACK_HITACHI_GD_2000         (0x00000008)
#define CDROM_HACK_TOSHIBA_SD_W1101        (0x00000010)
#define CDROM_HACK_TOSHIBA_XM_3xx          (0x00000020)
#define CDROM_HACK_NEC_CDDA                (0x00000040)
#define CDROM_HACK_PLEXTOR_CDDA            (0x00000080)
#define CDROM_HACK_BAD_GET_CONFIG_SUPPORT  (0x00000100)
#define CDROM_HACK_FORCE_READ_CD_DETECTION (0x00000200)
#define CDROM_HACK_READ_CD_SUPPORTED       (0x00000400)
#define CDROM_HACK_LOCKED_PAGES            (0x80000000) // not a valid flag to save

#define CDROM_HACK_VALID_FLAGS             (0x000007ff)
#define CDROM_HACK_INVALID_FLAGS           (~CDROM_HACK_VALID_FLAGS)


typedef struct _XA_CONTEXT {

    //
    // Pointer to the device object.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Pointer to the original request when
    // a mode select must be sent.
    //

    PIRP OriginalRequest;

    //
    // Pointer to the mode select srb.
    //

    PSCSI_REQUEST_BLOCK Srb;
} XA_CONTEXT, *PXA_CONTEXT;

typedef struct _ERROR_RECOVERY_DATA {
    MODE_PARAMETER_HEADER   Header;
    MODE_PARAMETER_BLOCK BlockDescriptor;
    MODE_READ_RECOVERY_PAGE ReadRecoveryPage;
} ERROR_RECOVERY_DATA, *PERROR_RECOVERY_DATA;

typedef struct _ERROR_RECOVERY_DATA10 {
    MODE_PARAMETER_HEADER10 Header10;
    MODE_PARAMETER_BLOCK BlockDescriptor10;
    MODE_READ_RECOVERY_PAGE ReadRecoveryPage10;
} ERROR_RECOVERY_DATA10, *PERROR_RECOVERY_DATA10;

//
// CdRom specific addition to device extension.
//

typedef struct _CDROM_DRIVER_EXTENSIO